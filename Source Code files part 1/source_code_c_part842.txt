
{
    private:
        //
        // Prevent copying.
        //
        FSRemoteVolume(const FSRemoteVolume&);
        void operator = (const FSRemoteVolume&);

    public:
        FSRemoteVolume(VOID)
            : FSVolume() { }

        BOOL IsLocal(VOID) const
            { return FALSE; }

};


class FSDirectory : public FSObject
{
    private:
        //
        // Prevent copying.
        //
        FSDirectory(const FSDirectory&);
        void operator = (const FSDirectory&);

    protected:
        HANDLE m_hDirectory;

    public:
        FSDirectory(VOID)
            : FSObject(),
              m_hDirectory(NULL) { }

        HRESULT Initialize(DWORD dwAccess)
            { return E_NOTIMPL; }

        UINT Type(VOID) const
            { return FSObject::Directory; }


        virtual HRESULT QueryObjectQuotaInformation(
                            PDISKQUOTA_FSOBJECT_INFORMATION poi
                            ) { return E_NOTIMPL; }


        virtual HRESULT SetObjectQuotaInformation(
                            PDISKQUOTA_FSOBJECT_INFORMATION poi,
                            DWORD dwChangeMask
                            ) const { return E_NOTIMPL; }

        virtual HRESULT QueryUserQuotaInformation(
                            PVOID pUserInfoBuffer,
                            ULONG uBufferLength,
                            BOOL bReturnSingleEntry,
                            PVOID pSidList,
                            ULONG uSidListLength,
                            PSID pStartSid,
                            BOOL bRestartScan
                            ) { return E_NOTIMPL; }

        virtual HRESULT SetUserQuotaInformation(
                            PVOID pUserInfoBuffer,
                            ULONG uBufferLength
                            ) const { return E_NOTIMPL; }

};


class FSLocalDirectory : public FSDirectory
{
    private:
        //
        // Prevent copying.
        //
        FSLocalDirectory(const FSLocalDirectory&);
        void operator = (const FSLocalDirectory&);

    public:
        FSLocalDirectory(VOID)
            : FSDirectory() { }

        BOOL IsLocal(VOID) const
            { return TRUE; }

};


class FSRemoteDirectory : public FSDirectory
{
    private:
        //
        // Prevent copying.
        //
        FSRemoteDirectory(const FSRemoteDirectory&);
        void operator = (const FSRemoteDirectory&);

    public:
        FSRemoteDirectory(VOID)
            : FSDirectory() { }

        BOOL IsLocal(VOID) const
            { return FALSE; }
};
*/
#endif // #if 0

#endif  // DISKQUOTA_FSOBJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\dskquota.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: dskquota.cpp

    Description: Contains standard functions for an OLE component server DLL.

                    DllMain
                    DllGetClassObject
                    DllCanUnloadNow

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    12/10/96    Moved to free-threading OLE apartment model.         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#define INITGUIDS  // Define GUIDs.
#include "dskquota.h"
#include "guidsp.h"    // Private GUIDs.
#include <gpedit.h>    // For GUIDs.

#include "factory.h"   // Class factory declarations.
#include "sidcache.h"  // SID/Name cache.
#include "registry.h"
//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


HINSTANCE     g_hInstDll     = NULL;    // DLL instance handle.
LONG          g_cRefThisDll  = 0;       // DLL reference count.
LONG          g_cLockThisDll = 0;       // DLL lock count.


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllGetClassObject

    Description: Creates instance of DiskQuotaControlClassFactory.

    Arguments:
        rclsid - Reference to class ID that identifies the type of object that the
            class factory will be asked to create.

        riid - Reference to interface ID on the class factory object.

        ppvOut - Destination location for class factory object pointer after 
            instantiation.

    Returns:
        NOERROR                   - Success.
        E_OUTOFMEMORY             - Can't create class factory object.
        E_NOINTERFACE             - Interface not supported.
        E_INVALIDARG              - ppvOut arg is NULL.
        CLASS_E_CLASSNOTAVAILABLE - Class factory not available.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDAPI 
DllGetClassObject(
    REFCLSID rclsid, 
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllGetClassObject")));
    DBGPRINTIID(DM_COM, DL_HIGH, (REFIID)rclsid);
    DBGPRINTIID(DM_COM, DL_HIGH, riid);

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    try
    {
        if (IsEqualIID(rclsid, CLSID_DiskQuotaControl))
        {
            DiskQuotaControlClassFactory *pClassFactory = NULL;

            pClassFactory = new DiskQuotaControlClassFactory;
            hr = pClassFactory->QueryInterface(riid, ppvOut);
            if (FAILED(hr))
            {
                delete pClassFactory;
            }
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory exception")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllCanUnloadNow

    Description: Called by OLE to determine if DLL can be unloaded.

    Arguments: None.

    Returns:
        S_FALSE     - Can't unload.  Ref count or lock count are > 0.
        S_OK        - OK to unload. Ref count and lock count are 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDAPI 
DllCanUnloadNow(
    VOID
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllCanUnloadNow")));
    DBGPRINT((DM_COM, DL_HIGH, TEXT("\tRefCnt = %d  LockCnt = %d"),
              g_cRefThisDll, g_cLockThisDll));

    return (0 == g_cRefThisDll && 0 == g_cLockThisDll) ? S_OK : S_FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DllRegisterServer

    Description: Create the necessary registry entries for dskquota.dll
        to operate properly.  This is called by REGSVR32.EXE.

    Arguments: None.

    Returns:
        S_OK            - Succeeded.
        SELFREG_E_CLASS - Failed to create one of the registry entries.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DllRegisterServer(
    VOID
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllRegisterServer")));
    HRESULT hr = CallRegInstall(g_hInstDll, "RegDll");

    if (FAILED(hr))
    {
        hr = SELFREG_E_CLASS;
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllUnregisterServer

    Description: Remove the necessary registry entries for dskquota.dll.
        This is called by REGSVR32.EXE.

    Arguments: None.

    Returns:
        S_OK            - Succeeded.
        SELFREG_E_CLASS - Failed to remove the CLSID entry.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DllUnregisterServer(
    VOID
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllUnregisterServer")));
    HRESULT hr = CallRegInstall(g_hInstDll, "UnregDll");

    if (FAILED(hr))
    {
        hr = SELFREG_E_CLASS;
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: OnProcessAttach

    Description: Handles all tasks associated with a process attaching to 
        the DLL.

        Try to keep processing time to a minimum.

    Arguments:
        hInstDll - The DLL instance handle passed to DllMain.

    Returns:
        NOERROR    - Success.
        E_FAIL     - Something failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
OnProcessAttach(
    HINSTANCE hInstDll
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("OnProcessAttach")));
    HRESULT hr = NOERROR;

    //
    // Start IceCAP profiling.
    //
    ICAP_START_ALL;

#if DBG
    DBGMODULE(TEXT("DSKQUOTA"));  // Name of module displayed with messages.
    RegKey key(HKEY_LOCAL_MACHINE, REGSTR_KEY_DISKQUOTA);
    if (SUCCEEDED(key.Open(KEY_READ)))
    {
        DebugRegParams dp;
        if (SUCCEEDED(key.GetValue(REGSTR_VAL_DEBUGPARAMS, (LPBYTE)&dp, sizeof(dp))))
        {
            DBGPRINTMASK(dp.PrintMask);
            DBGPRINTLEVEL(dp.PrintLevel);
            DBGPRINTVERBOSE(dp.PrintVerbose);
            DBGTRACEMASK(dp.TraceMask);
            DBGTRACELEVEL(dp.TraceLevel);
            DBGTRACEVERBOSE(dp.TraceVerbose);
            DBGTRACEONEXIT(dp.TraceOnExit);
        }
    }
#endif // DBG

    g_hInstDll = hInstDll;
    DisableThreadLibraryCalls(hInstDll);

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: OnProcessDetach

    Description: Handles all tasks associated with a process detaching from 
        the DLL.

    Arguments: None.

    Returns:
        NOERROR    - Success.
 
    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
OnProcessDetach(
    VOID
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("OnProcessAttach")));

    HRESULT hr = NOERROR;

    SidNameCache_Destroy();

    //
    // Stop IceCAP profiling.
    //
    ICAP_STOP_ALL;

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DllMain

    Description: Main entry point for OLE component server.

    Arguments:
        hInstDll - Instance handle of DLL

        fdwReason - Reason DllMain is being called.  Can be at Process attach/
            detach or Thread attach/detach.

        lpdwReserved - Reserved.

    Returns:
        TRUE    - Successful initialization.
        FALSE   - Failed initialization.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/09/96    Moved code associated with process attach and        BrianAu
                detach out to separate functions.
*/
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI 
DllMain(
    HINSTANCE hInstDll, 
    DWORD fdwReason, 
    LPVOID lpvReserved
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllMain")));
    BOOL bResult = FALSE;

    switch(fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DBGPRINT((DM_COM, DL_HIGH, TEXT("DLL_PROCESS_ATTACH")));
            bResult = SUCCEEDED(OnProcessAttach(hInstDll));
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            bResult = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            DBGPRINT((DM_COM, DL_HIGH, TEXT("DLL_PROCESS_DETACH")));
            bResult = SUCCEEDED(OnProcessDetach());
            break;
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\oadisp.h ===
#ifndef _INC_DSKQUOTA_OADISP_H
#define _INC_DSKQUOTA_OADISP_H
///////////////////////////////////////////////////////////////////////////////
/*  File: oadisp.h

    Description: Provides reusable implementation of IDispatch.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _OLEAUTO_H_
#   include <oleauto.h>
#endif

#ifndef _INC_DSKQUOTA_STRCLASS_H
#   include "strclass.h"
#endif

class OleAutoDispatch
{
    public:
        OleAutoDispatch(VOID);

        OleAutoDispatch(IDispatch *pObject,
                        REFIID riidTypeLib,
                        REFIID riidDispInterface,
                        LPCTSTR pszTypeLib);

        ~OleAutoDispatch(VOID);

        HRESULT 
        Initialize(
            IDispatch *pObject,
            REFIID riidTypeLib,
            REFIID riidDispInterface,
            LPCTSTR pszTypeLib);

        HRESULT 
        GetIDsOfNames(
            REFIID riid,  
            OLECHAR ** rgszNames,  
            UINT cNames,  
            LCID lcid,  
            DISPID *rgDispId);
        
        HRESULT 
        GetTypeInfo(
            UINT iTInfo,  
            LCID lcid,  
            ITypeInfo **ppTInfo);

        HRESULT 
        GetTypeInfoCount(
            UINT *pctinfo);

        HRESULT 
        Invoke(
            DISPID dispIdMember,  
            REFIID riid,  
            LCID lcid,  
            WORD wFlags,  
            DISPPARAMS *pDispParams,  
            VARIANT *pVarResult,  
            EXCEPINFO *pExcepInfo,  
            UINT *puArgErr);

    private:
        IDispatch *m_pObject;
        GUID       m_idTypeLib;
        GUID       m_idDispInterface;
        ITypeInfo *m_pTypeInfo;
        CString    m_strTypeLib;

        //
        // Prevent copy.
        //
        OleAutoDispatch(const OleAutoDispatch& rhs);
        OleAutoDispatch& operator = (const OleAutoDispatch& rhs);
};

#endif //_INC_DSKQUOTA_OADISP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\pch.h ===
#ifndef _INC_DSKQUOTA_PCH_H
#define _INC_DSKQUOTA_PCH_H
///////////////////////////////////////////////////////////////////////////////
/*  File: pch.h

    Description: Precompiled header file for dskquota project.
        Includes all headers that are compiled into the pre-compiled header.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "private.h"

#endif // _INC_DSKQUOTA_PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\sidcache.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: sidcache.cpp

    Description: This module provides the functionality for a cache of user
        SID/Name pairs.  See the file header in sidcache.h for details.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/12/96    Initial creation.                                    BrianAu
    08/14/96    Added SidCacheQueueIterator.                         BrianAu
    09/20/96    Total redesign.  Old design loaded data from file    BrianAu
                into an in-memory hash table.  New design leaves
                everything on disk and merely maps the file into
                memory.  Much more efficient with respect to
                speed and size.
    07/02/97    Added SidNameCache::GetFileNames.                    Brianau
                Changed logic for identifying cache file path.
                Removed index bucket count param from registry.
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in
                reponse to making the quota UI DS-aware.  The
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "dskquota.h"
#include "sidcache.h"
#include "registry.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif

//
// How long (milliseconds) we'll wait to get a lock on the cache.
//
const DWORD MUTEX_WAIT_TIMEOUT      = 5000;
//
// Byte value used to fill in unused blocks in the data file.
//
const BYTE  RECORD_UNUSED_BYTE      = 0xCC;
//
// A value to signify the start of a record in the data file.
// The bit pattern is  1010101010101010 0101010101010101
// Highly unlikely that any data file data will produce this
// pattern.
//
const DWORD RECORD_SIGNATURE        = 0xAAAA5555;
//
// Signatures written into the header of the index and data files.
// For validating a file just in case someone's put another file
// in their place.  The numbers are arbitrary.
// 2600 means "MS building 26N (where I'm working now).
// 3209 is my office number.
// 3210 is BobDay's office number (across the hall).
// Hey, I had to pick something.
//
const DWORD INDEX_FILE_SIGNATURE    = 0x26003209;
const DWORD DATA_FILE_SIGNATURE     = 0x26003210;
//
// A version number so a future build of the software won't be confused
// by a change in file formats.  Bump this if the file format changes.
//
const DWORD FILE_VERSION            = 0x00000003;
//
// Average number of 32-byte blocks per cache entry.
// Entries are variable length (SID, Name etc).  This average is used
// in initially sizing the data file.  I've found that most entries (by far)
// require 4 blocks. Both the data file and index file grow independently
// as needed so it isn't a problem if this isn't always accurate.
//
const DWORD AVG_BLOCKS_PER_ENTRY    = 4;
//
// Create space for this many records in a new data file.
// Since the data and index files grow automatically as needed,
// this can change as you see fit.
//
#if DBG
    const DWORD NEW_CACHE_ENTRY_COUNT   = 4;   // Force frequent file growth.
#else
    const DWORD NEW_CACHE_ENTRY_COUNT   = 128;
#endif
//
// The index and data files automatically grow when needed.  These
// values control how much they grow by.
//
#if DBG
    const DWORD DATA_FILE_GROW_BLOCKS   = 4;  // Force frequent file growth.
#else
    const DWORD DATA_FILE_GROW_BLOCKS   = 512;
#endif

const DWORD INDEX_FILE_GROW_ENTRIES = (DATA_FILE_GROW_BLOCKS / AVG_BLOCKS_PER_ENTRY);
//
// The number of buckets in the cache index hash table.
// Number should be prime.  Remember, this index is on disk so we can afford to
// have a reasonably large hash table.  While it would be nice to fit the
// buckets within a single page of memory, that would be too small to be effective
// 512 / 4 == 64 buckets.  There's also no guarantee that all buckets would be
// mapped to a single physical page.
//
const DWORD INDEX_BUCKET_COUNT = 503;
//
// Convert between blocks and bytes.
// BLOCK_SIZE is a power of 2 so the multiply and division
// can be optimized to shifts.
//
#define BYTE_TO_BLOCK(b)  ((b) / BLOCK_SIZE)
#define BLOCK_TO_BYTE(b)  ((b) * BLOCK_SIZE)
//
// Base pointers for mapped data and index files.
// When the files are mapped into memory, these globals contain
// the address of the mapped memory.
//
LPBYTE g_pbMappedDataFile;
LPBYTE g_pbMappedIndexFile;

//
// Macros for working with based pointers.
// Pointer members in the file structures contain offsets relative
// to the start of the file.  When dereferencing these pointers,
// they must be converted to "based" pointers which add the file's
// base address to the pointer value.  This results in a true
// virtual address that can be accessed.
//
#if defined(_X86_)
#   define NDX_BASED(t)  t __based(g_pbMappedIndexFile)
#   define DAT_BASED(t)  t __based(g_pbMappedDataFile)
#   define NDX_BASED_CAST(t,e)  (NDX_BASED(t) *)((DWORD)(e))
#   define DAT_BASED_CAST(t,e)  (DAT_BASED(t) *)((DWORD)(e))
#else
//
// APPCOMPAT:
// I think there's a bug in the ALPHA compiler that is preventing __based pointers
// from working as I have used them.
// This is a workaround until the bug is fixed or I find out what I'm doing wrong.
//
#   define NDX_BASED(t)  t
#   define DAT_BASED(t)  t
#   define NDX_BASED_CAST(t,e)  ((NDX_BASED(t) *)(((BYTE *)g_pbMappedIndexFile) + ((DWORD_PTR)(e))))
#   define DAT_BASED_CAST(t,e)  ((DAT_BASED(t) *)(((BYTE *)g_pbMappedDataFile) + ((DWORD_PTR)(e))))
#endif

//
// Macros to verify that the files have been mapped.
// These are primarily used in assertions.
//
#define INDEX_FILE_MAPPED  (NULL != g_pbMappedIndexFile)
#define DATA_FILE_MAPPED   (NULL != g_pbMappedDataFile)
//
// Names for system objects.  Mutex and maps are named so they can
// be shared between processes.
//
const LPCTSTR g_szSidCacheMutex     = TEXT("DSKQUOTA_SIDCACHE_MUTEX");
const LPCTSTR g_pszIndexFileMapping = TEXT("DSKQUOTA_SIDCACHE_INDEX");
const LPCTSTR g_pszDataFileMapping  = TEXT("DSKQUOTA_SIDCACHE_DATA");
//
// Use to clear a file's GUID and to test for a NULL guid.
//
static const GUID GUID_Null =
{ 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };

//
// Registry parameter value names.
//
const TCHAR g_szSidCacheRecLifeMin[]   = TEXT("SidCacheRecLifeMin");
const TCHAR g_szSidCacheRecLifeMax[]   = TEXT("SidCacheRecLifeMax");


//***********************************************************************************
//***********************************************************************************
//  C A C H E   M A N A G E R
//***********************************************************************************
//***********************************************************************************

//
// Called by both SidNameCache_Get and SidNameCache_Destroy to either retrieve
// the address (and create if necessary) of the singleton cache object or to
// destroy that object.  The reason to have this single function is so that
// the singleton pointer is a local variable, inaccessible outside of this
// function.  This way the only access to the cache object is through
// the SidNameCache_Get function.
//
HRESULT 
SidNameCache_GetOrDestroy(
    SidNameCache **ppCache, 
    bool bGet
    )
{
    DBGASSERT((NULL != ppCache));

    HRESULT hr = E_FAIL;

    //
    // This is the one-and-only pointer to the SID-Name cache object.
    // All code obtains this address through this function.
    // 
    static SidNameCache *pTheCache;

    *ppCache = NULL;

    HANDLE hMutex = CreateMutex(NULL, FALSE, g_szSidCacheMutex);
    if (NULL != hMutex)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(hMutex, INFINITE))
        {
            if (!bGet)
            {
                //
                // Destroy the existing cache object.  NULL the static
                // ptr so next request will recreate the cache object.
                //
                delete pTheCache;
                pTheCache = NULL;
                hr = S_OK;
            }
            else
            {
                //
                // Retrieve existing or create new cache object.
                //
                SidNameCache *pCache = pTheCache;
                if (NULL != pCache)
                {
                    //
                    // Use the existing object.
                    //
                    hr = S_OK;
                }
                else
                {
                    try
                    {
                        //
                        // Doesn't yet exist.  Create new one.
                        //
                        autoptr<SidNameCache> ptrCache(new SidNameCache);

                        //
                        // Open/Create new cache data and index files.
                        // Will first try to open existing.  If either the index or
                        // data file doesn't exist or is invalid, new files are created.
                        //
                        hr = ptrCache->Initialize(TRUE);
                        if (SUCCEEDED(hr))
                        {
                            pCache = ptrCache.get();
                            ptrCache.disown();
                            //
                            // Save in our static variable for future use.
                            //
                            pTheCache = pCache;
                        }
                        else
                        {
                            DBGERROR((TEXT("SID cache initialization failed with error 0x%08X"), hr));
                        }
                    }
                    catch(CAllocException& e)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    catch(CSyncException& e)
                    {
                        hr = E_FAIL;
                    }
                }
                if (SUCCEEDED(hr))
                {
                    //
                    // Return the pointer to the caller.
                    //
                    *ppCache = pCache;
                }
            }
            ReleaseMutex(hMutex);
        }
        CloseHandle(hMutex);
    }
    return hr;
}


//
// Retrieves the address of the singleton SidNameCache object.
// If the object doesn't exist it is created.
// Callers do not release or delete this pointer.
// On Process-Detach, the SidNameCache_Destroy() function is 
// called to delete the singleton object.
//
HRESULT SidNameCache_Get(SidNameCache **ppCache)
{
    const bool bGet = true;
    return SidNameCache_GetOrDestroy(ppCache, bGet);
}

//
// Called on Process-Detach to destroy the singleton cache
// object.
//
HRESULT SidNameCache_Destroy(void)
{
    const bool bGet = false;
    SidNameCache *pUnused;
    return SidNameCache_GetOrDestroy(&pUnused, bGet);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::SidNameCache

    Description: Constructor.  Creates an empty SID/Name cache object.
        Call one of the Initialize() methods to either create a new index and
        data file or to open existing ones.

    Arguments: None.

    Returns: Nothing.

    Exceptions: SyncObjErrorCreate.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::SidNameCache(
    VOID
    ) : m_hMutex(NULL),
        m_pIndexMgr(NULL),
        m_pRecordMgr(NULL)
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::SidNameCache")));
    if (NULL == (m_hMutex = CreateMutex(NULL,                    // Default security
                                        FALSE,                   // Non-owned
                                        g_szSidCacheMutex)))
    {
        throw CSyncException(CSyncException::mutex, CSyncException::create);
    }

    SetCacheFilePath();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::~SidNameCache

    Description: Destructor.  Destroys the cache object by deleting the
        Index Manager and Record Manager objects.  The respective destructor's
        for each of the managers will handle closing their files and mapping
        objects.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::~SidNameCache(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::~SidNameCache")));
    if (NULL != m_hMutex)
        Lock();

    delete m_pIndexMgr;
    delete m_pRecordMgr;

    if (NULL != m_hMutex)
    {
        ReleaseLock();
        CloseHandle(m_hMutex);
    }
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Initialize

    Description: Initializes a new cache object by creating the Index and
        Record manager objects then initializing each.  Initialization first
        tries to open existing index and data files.  If one (or both) of the
        files does not exist OR one (or both) of the files is considered
        "invalid", new files are created.  Need to take a "fail safe" approach
        to this.

    Arguments:
        bOpenExisting - TRUE = Try to open an existing cache index and data file.
            If it can't, it creates a new one.  FALSE = Just create a new one.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Could not open nor create required files.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::Initialize(
    BOOL bOpenExisting
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("SidNameCache::Initialize")));
    DBGASSERT((NULL == m_pIndexMgr));
    DBGASSERT((NULL == m_pRecordMgr));

    HRESULT hResult = E_FAIL;
    CacheAutoLock lock(*this);

    if (lock.Lock())
    {
        try
        {
            if (m_strFilePath.IsEmpty())
            {
                //
                // If file path is empty, it means we couldn't get the
                // user's profile directory from the registry.
                //
                DBGERROR((TEXT("Error creating SID cache files.  No path.")));
            }
            else
            {
                //
                // Name for our cache data and index files.
                // Will append .DAT and .NDX respectively.
                // This is where you change the file name or extension(s)
                // if you want to do that.
                //
                const TCHAR szSidCacheFile[] = TEXT("NTDiskQuotaSidCache");

                //
                // Create a fully-qualified path for the cache data and index
                // files.  m_strFilePath was set in the cache object ctor.
                //
                CString strDataFile(m_strFilePath);
                CString strIndexFile(m_strFilePath);

                strDataFile.Format(TEXT("%1\\%2.dat"), (LPCTSTR)m_strFilePath, szSidCacheFile);
                strIndexFile.Format(TEXT("%1\\%2.ndx"),(LPCTSTR)m_strFilePath, szSidCacheFile);

                //
                // Create the record and index manager objects.
                //
                m_pRecordMgr = new RecordMgr(*this);
                m_pIndexMgr  = new IndexMgr(*this);

                DBGPRINT((DM_CONTROL, DL_MID, TEXT("Create SID cache DataFile = %s  IndexFile = %s"),
                         (LPCTSTR)strDataFile, (LPCTSTR)strIndexFile));

                if (bOpenExisting)
                {
                    //
                    // First try opening existing data and index files.
                    //
                    if (NULL != m_pRecordMgr->Initialize(strDataFile))
                    {
                        if (NULL != m_pIndexMgr->Initialize(strIndexFile))
                            hResult = NO_ERROR;
                    }
                }

                if (FAILED(hResult) || !FilesAreValid())
                {
                    hResult = E_FAIL;
                    //
                    // Couldn't open existing files, try creating new ones.
                    // Any open files/mappings will be closed.
                    //
                    if (NULL != m_pRecordMgr->Initialize(strDataFile,
                                          NEW_CACHE_ENTRY_COUNT * AVG_BLOCKS_PER_ENTRY))
                    {
                        if (NULL != m_pIndexMgr->Initialize(strIndexFile,
                                                            INDEX_BUCKET_COUNT,
                                                            NEW_CACHE_ENTRY_COUNT))
                        {
                            hResult = NO_ERROR;
                        }
                    }
                }
            }
        }
        catch(CAllocException& e)
        {
            delete m_pRecordMgr;
            m_pRecordMgr = NULL;
            delete m_pIndexMgr;
            m_pIndexMgr = NULL;
            hResult = E_OUTOFMEMORY;
        }
        //
        // Mark files as "valid".
        //
        if (SUCCEEDED(hResult))
            ValidateFiles();
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::OpenMappedFile

    Description: Opens or creates a file, maps the file into memory and
        returns the address of the mapping.

    Arguments:
        pszFile - Address of name of file to create/open.

        pszMapping - Name to give the mapping object.  This object is
            named so that if multiple processes map the same file (using
            the same mapping name), the file is only mapped once.

        dwCreation - Creation flag (CREATE_ALWAYS, OPEN_EXISTING);

        cbFileHigh/Low - If creating a new file or extending an existing
            these two arguments contain the desired size in bytes.

        phFile - Address of handle variable to receive the open file's
            handle value.  Call CloseHandle on this to close the file.

        phFileMapping - Address of handle variable to receive the open
            file mapping's handle value.  Call CloseFileMapping on this
            to close the mapping.

    Returns:
        Address of the mapped file in memory.  NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
    07/21/97    Files are now created in user's profile under a      BrianAu
                "DiskQuota" subdirectory.
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::OpenMappedFile(
    LPCTSTR pszFile,
    LPCTSTR pszMapping,
    DWORD dwCreation,
    DWORD cbFileHigh,
    DWORD cbFileLow,
    PHANDLE phFile,
    PHANDLE phFileMapping
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::OpenMappedFile")));
    LPBYTE pbBase = NULL;

    DBGASSERT((NULL != pszFile));
    DBGASSERT((NULL != pszMapping));
    DBGASSERT((NULL != phFile));
    DBGASSERT((NULL != phFileMapping));

    *phFile = CreateFile(pszFile,
                         GENERIC_READ | GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         dwCreation,
                         FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN,
                         NULL);

    if (INVALID_HANDLE_VALUE != *phFile)
    {
        if ((*phFileMapping = CreateFileMapping(*phFile,
                                                NULL,    // default security
                                                PAGE_READWRITE,
                                                cbFileHigh,
                                                cbFileLow,
                                                pszMapping)) != NULL)
        {
            pbBase = (LPBYTE)MapViewOfFile(*phFileMapping,
                                           FILE_MAP_WRITE,
                                           0,
                                           0,
                                           0);
            if (NULL == pbBase)
                DBGERROR((TEXT("SIDCACHE - Failed to map view of file %s"),
                         pszFile));
        }
        else
        {
            DBGERROR((TEXT("SIDCACHE - Failed to create mapping %s for file %s"),
                     pszMapping, pszFile));
        }
        if (NULL == pbBase)
        {
            CloseHandle(*phFile);
            *phFile = NULL;
        }
    }
    else
        DBGERROR((TEXT("SIDCACHE - Failed to open file %s"), pszFile));


    return pbBase;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::SetCacheFilePath

    Description: Obtains the fully-qualified path for the cache's data
        and index files and stores the value in m_strFilePath.  The files
        are to be created under in the user's profile under the directory
        \AppData\Microsoft\Windows NT\DiskQuota.  We have to read the registry
        to find exactly where this subtree lives for this user.

    Arguments: None.

    Returns: Nothing.
             On return, m_strFilePath contains the path to the files.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/02/97    Initial creation.                                    BrianAu
    07/21/97    Removed default file path.                           BrianAu
                Files can only be stored in user's profile.
                Can't allow unsecure access to SID/Name pairs.
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::SetCacheFilePath(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_HIGH, TEXT("SidNameCache::SetCacheFilePath")));
    //
    // Get the user's %UserProfile%\Application Data directory.
    // Normally, an app gets this through SHGetSpecialFolderLocation or
    // SHGetSpecialFolderPath.  However, I don't want to load shell32.dll
    // just for that purpose (I've tried to keep shell32 out of this dll).
    // Therefore, we read the registry values just like the shell does.
    // EricFlo suggested this so it's OK ZAW-wise.
    //
    LONG lResult        = ERROR_SUCCESS;
    HKEY hKey           = NULL;
    DWORD dwDisposition = 0;
    const TCHAR szKeyNameRoot[]      = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer");
    const TCHAR szMSWinNTDiskQuota[] = TEXT("Microsoft\\Windows NT\\DiskQuota");

    LPCTSTR rgpszKeys[] = {
                            TEXT("\\User Shell Folders"),
                            TEXT("\\Shell Folders"),
                          };

    //
    // Start with an empty path buffer.
    //
    m_strFilePath.Empty();

    for (INT i = 0; i < ARRAYSIZE(rgpszKeys) && m_strFilePath.IsEmpty(); i++)
    {
        //
        // Create the key name.
        //
        CString strKeyName(szKeyNameRoot);
        strKeyName += CString(rgpszKeys[i]);

        //
        // Open the reg key.
        //
        lResult = RegCreateKeyEx(HKEY_CURRENT_USER,
                                 strKeyName,
                                 0,
                                 NULL,
                                 0,
                                 KEY_READ,
                                 NULL,
                                 &hKey,
                                 &dwDisposition);

        if (ERROR_SUCCESS == lResult)
        {
            try
            {
                //
                // Get the path to the user's "Application Data" directory.
                //
                DBGASSERT((NULL != hKey));

                DWORD dwValueType = 0;
                DWORD cbValue     = MAX_PATH * sizeof(TCHAR);

                lResult = RegQueryValueEx(hKey,
                                          TEXT("AppData"),
                                          0,
                                          &dwValueType,
                                          (LPBYTE)m_strFilePath.GetBuffer(MAX_PATH),
                                          &cbValue);

                m_strFilePath.ReleaseBuffer();

                if (ERROR_SUCCESS == lResult)
                {
                    //
                    // Ensure the path has a trailing backslash.
                    //
                    INT cchPath = m_strFilePath.Length();
                    if (0 < cchPath && TEXT('\\') != m_strFilePath[cchPath-1])
                    {
                        m_strFilePath += CString(TEXT("\\"));
                    }
                    //
                    // Append "Microsoft\Windows NT\DiskQuota" to the path.
                    //
                    m_strFilePath += CString(szMSWinNTDiskQuota);
                }
                else
                {
                    //
                    // Something failed.  Ensure m_strFilePath is empty.
                    //
                    m_strFilePath.Empty();
                    if (ERROR_FILE_NOT_FOUND != lResult)
                    {
                        DBGERROR((TEXT("SIDCACHE - Error %d getting \"AppData\" reg value."), lResult));
                    }
                }
            }
            catch(CAllocException& e)
            {
                lResult = ERROR_OUTOFMEMORY;
            }
            RegCloseKey(hKey);
        }
        else if (ERROR_FILE_NOT_FOUND != lResult)
        {
            DBGERROR((TEXT("SIDCACHE - Error %d opening \"\\User Shell Folders\" or \"Shell Folders\" reg key"), lResult));
        }
    }

    if (!m_strFilePath.IsEmpty())
    {
        //
        // Expand any embedded environment strings.
        //
        m_strFilePath.ExpandEnvironmentStrings();

        //
        // Ensure the path DOES NOT have a trailing backslash.
        //
        INT cchPath = m_strFilePath.Length();
        if (0 < cchPath && TEXT('\\') == m_strFilePath[cchPath-1])
        {
            m_strFilePath[cchPath-1] = TEXT('\0');
        }

        if ((DWORD)-1 == ::GetFileAttributes(m_strFilePath))
        {
            //
            // If the directory doesn't exist, try to create it.
            //
            if (0 == CreateCacheFileDirectory(m_strFilePath))
            {
                //
                // Couldn't create the directory, make sure the path
                // is empty so we don't try to write to a non-existent
                // directory.
                //
                DBGERROR((TEXT("SIDCACHE - Error %d creating directory \"%s\""),
                         GetLastError(), (LPCTSTR)m_strFilePath));
                m_strFilePath.Empty();
            }
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::CreateCacheFileDirectory

    Description: Creates the directory for the SID/Name cache files.  Since
        the directory lives several levels below "Application Data", we
        may need to create several directories before we get to DiskQuota.

    Arguments: pszPath - This is a fully-qualified directory path.

    Returns: TRUE  = Directory created.
             FALSE = Directory not created.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/21/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::CreateCacheFileDirectory(
    LPCTSTR pszPath
    )
{
    DBGTRACE((DM_SIDCACHE, DL_HIGH, TEXT("SidNameCache::CreateCacheFileDirectory")));
    BOOL bResult = TRUE;
    CString s(pszPath);     // Local copy we can play with.
    LPTSTR psz = (LPTSTR)s; // Ptr to C string.

    while(TEXT('\0') != *psz && bResult)
    {
        //
        // Find the next backslash (or end-of-string).
        //
        while(TEXT('\0') != *psz && TEXT('\\') != *psz)
        {
            psz++;
        }
        //
        // Replace backslash with a temporary NUL.
        //
        TCHAR chSaved = *psz;
        *psz = TEXT('\0');
        //
        // See if the directory already exists.
        //
        if ((DWORD)-1 == ::GetFileAttributes(s))
        {
            //
            // It doesn't.  Try to create it.
            //
            if (0 == ::CreateDirectory(s, NULL))
            {
                DBGERROR((TEXT("SIDCACHE - Error %d creating directory \"%s\""),
                         GetLastError(), (LPCTSTR)s));
                bResult = FALSE;
            }
        }
        //
        // Replace temp NUL with original backslash and advance ptr
        // to next character in path (if we're not at the end of the string).
        //
        *psz = chSaved;
        if (TEXT('\0') != *psz)
        {
            psz++;
        }
    }

    if (bResult)
    {
        //
        // Created directory. Set SYSTEM & HIDDEN attribute bits on the final
        // subdirectory ("\DiskQuota").
        //
        SetFileAttributes(pszPath,
                          GetFileAttributes(pszPath) | (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN));
    }

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Lock

    Description: Obtains an exclusive lock on the cache.  This lock is
        system-wide so that multiple processes can access the cache files.

    Arguments: None.

    Returns:
        TRUE  - Exclusive lock obtained or the lock was abandoned.
                No matter how the lock was obtained, the caller should always
                check the validity of the index and data files before trusting
                their contents.
        FALSE - Lock could not be obtained in the required timeout period.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::Lock(
    VOID
    )
{
    BOOL bResult = FALSE;
    DBGASSERT((NULL != m_hMutex));

    //
    // IMPORTANT:  Don't try handling thread messages with MsgWaitForMultipleObjects.
    //             This lock function can be called on the resolver's background
    //             thread.  If you pull up that thread's messages, it won't receive
    //             the WM_QUIT message commanding it to shutdown.
    //
    switch(WaitForSingleObject(m_hMutex, MUTEX_WAIT_TIMEOUT))
    {
        case WAIT_OBJECT_0:
        case WAIT_ABANDONED:
            bResult = TRUE;
            break;

        case WAIT_FAILED:
        case WAIT_TIMEOUT:
        default:
            break;
    }
    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::ReleaseLock

    Description: Releases the exclusive lock on the cache.  This function must
        always be paired with a call to Lock().  Be careful of conditions
        which may throw an exception and bypass releasing the lock.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::ReleaseLock(
    VOID
    )
{
    DBGASSERT((NULL != m_hMutex));
    ReleaseMutex(m_hMutex);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::BeginTransaction

    Description: Called at the beginning of any "transaction" to obtain
        exclusive access to the cache and verify the cache files are valid.
        Although this is of course not true transaction processing, it provides
        a simple approximation that is sufficient for this cache implementation.
        Note that before returning, the files are "invalidated".  After the
        transaction is completed, the caller must call EndTransaction to
        release the exclusive lock and mark the files as "valid".

    Arguments: None.

    Returns:
        NO_ERROR            - Success.  Transaction can be carried out.
        ERROR_INVALID_DATA (hr) - Index or data file is invalid.  Caller should
            re-initialize both index and data files.
        ERROR_LOCK_FAILED (hr) - Could not obtain exclusive access to the
            index and data files.  Caller can either repeat the call or
            simply fail the cache access.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::BeginTransaction(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;
    if (Lock())
    {
        if (FilesAreValid())
        {
            InvalidateFiles();
        }
        else
        {
            ReleaseLock();
            hResult = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
    }
    else
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::EndTransaction

    Description: Called at the end of any "transaction" to release
        exclusive access to the cache and validate the cache files.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::EndTransaction(
    VOID
    )
{
    //
    // If you hit this assertion, probably didn't call BeginTransaction
    // first.
    //
    DBGASSERT((!FilesAreValid()));

    ValidateFiles();
    ReleaseLock();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Clear

    Description: Resets both the index and data files to an empty state.

    Arguments: None.

    Returns:
        TRUE  - Files reset.
        FALSE - Couldn't obtain lock to reset files or another process
                is also using the cache.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
    08/07/00    Clear cache by clearing index and data files.  Not   BrianAu
                destroying and recreating.
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::Clear(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_HIGH, TEXT("SidNameCache::Clear")));
    BOOL bResult = FALSE;
    CacheAutoLock lock(*this);
    if (lock.Lock())
    {
        if (NULL != m_pIndexMgr && NULL != m_pRecordMgr)
        {
            m_pIndexMgr->Clear();
            m_pRecordMgr->Clear();
            ValidateFiles();
            bResult = TRUE;
        }
    }
    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::FilesAreValid

    Description: Examines the guid field in the index and data files.
        If the guids are non-zero and are equal, the files are considered
        "valid".  BeginTransaction sets each guid to all 0's while
        EndTransaction fills them with a new GUID.

    Arguments: None.

    Returns:
        TRUE/FALSE indicating file validity.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::FilesAreValid(
    VOID
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((INDEX_FILE_MAPPED));

    GUID guidIndexFile;
    GUID guidDataFile;

    m_pIndexMgr->GetFileGUID(&guidIndexFile);
    if (GUID_Null != guidIndexFile)
    {
        m_pRecordMgr->GetFileGUID(&guidDataFile);
        return guidDataFile == guidIndexFile;
    }
    return FALSE; // At least one GUID was all 0's
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::ValidateFiles

    Description: Generates a new GUID and writes it to the header of the
        index and data files.  This should only be called when a transaction
        has been successfully completed.  EndTransaction calls this method
        to mark the files as "valid".

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
    05/18/00    Check return value from CoCreateGuid.                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::ValidateFiles(
    VOID
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((INDEX_FILE_MAPPED));

    //
    // If GUID creation fails, the cache will be considered invalid.
    // That's a reasonable system response.  Failure of GUID creation
    // is highly unlikely.
    //
    GUID guid;
    if (SUCCEEDED(CoCreateGuid(&guid)))
    {
        m_pRecordMgr->SetFileGUID(&guid);
        m_pIndexMgr->SetFileGUID(&guid);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::InvalidateFiles

    Description: Sets the guid field in each file to all 0's.   This marks
        a file as "invalid".  BeginTransaction calls this.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::InvalidateFiles(
    VOID
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((INDEX_FILE_MAPPED));

    m_pRecordMgr->SetFileGUID(&GUID_Null);
    m_pIndexMgr->SetFileGUID(&GUID_Null);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Lookup

    Description: Given a user SID, this method locates the corresponding
        data record in the cache and returns the requested information.
        (i.e. container, name, full name).  Several conditions will cause
        the lookup to fail.
            1. SID not found in cache.
            2. Can't get exclusive lock on cache.
            3. Index or data file (or both) are invalid.
            4. Record found but expired.

    Arguments:
        pKeySid - Address of SID to use as lookup key.

        ppszContainer [optional] - Address of pointer variable to receive the
            address of buffer containing the "container" name string. Caller is
            responsible for freeing the buffer with delete[].
            May be NULL if the container is not desired.

        ppszLogonName [optional] - Address of pointer variable to receive the
            address of buffer containing logon name string. Caller is
            responsible for freeing the buffer with delete[].
            May be NULL if logon name is not desired.

        ppszDisplayName [optional] - Address of pointer variable to receive the
            address of buffer containing account display string. Caller is
            responsible for freeing the buffer with delete[].
            May be NULL if display name is not desired.

    Returns:
        NO_ERROR                  - Success.
        ERROR_FILE_NOT_FOUND (hr) - Sid not found in cache.
        ERROR_LOCK_FAILED (hr)    - Couldn't get exclusive lock on cache.
        ERROR_INVALID_DATA (hr)   - Index or data file is invalid.

    Exceptions: OutOfMemory


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::Lookup(
    PSID pKeySid,
    LPTSTR *ppszContainer,
    LPTSTR *ppszLogonName,
    LPTSTR *ppszDisplayName
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::Lookup [SID]")));
    DBGASSERT((NULL != pKeySid));

    HRESULT hResult = BeginTransaction();

    if (SUCCEEDED(hResult))
    {
        try
        {
            DWORD iBlock = m_pIndexMgr->Lookup(pKeySid);

            if ((DWORD)-1 != iBlock)
            {
                if (!m_pRecordMgr->RecordExpired(iBlock))
                {
                    PSID pSid = NULL;
                    //
                    // This can throw OutOfMemory.
                    //
                    hResult = m_pRecordMgr->Retrieve(iBlock,
                                                     &pSid,
                                                     ppszContainer,
                                                     ppszLogonName,
                                                     ppszDisplayName);
                    if (SUCCEEDED(hResult))
                        DBGASSERT((EqualSid(pSid, pKeySid)));

                    if (NULL != pSid)
                        delete[] pSid;
                }
                else
                {
                    //
                    // Record is outdated.  Delete it from the cache.
                    // Returning "not found" will cause the caller to get
                    // a fresh one from the domain controller - which will
                    // then again be added to the cache.
                    //
                    DBGPRINT((DM_SIDCACHE, DL_HIGH,
                             TEXT("SIDCACHE - Record at block %d has expired."),
                             iBlock));

                    m_pIndexMgr->FreeEntry(pKeySid);
                    m_pRecordMgr->FreeRecord(iBlock);
                    hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }
            else
            {
                hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);  // SID not in cache.
            }
        }
        catch(CAllocException &e)
        {
            hResult = E_OUTOFMEMORY;
        }
        EndTransaction();
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Lookup

    Description: Given a user's logon name name, this method locates
        the corresponding SID in the cache.  All comments in the previous
        (above) version of this method apply.

    Arguments:
        pszLogonName - Address of account logon name string.

        ppSid - Address of pointer variable to receive the address of buffer
            containing the SID. Caller is responsible for freeing the buffer
            with delete[].

    Returns:
        See list in previous method.

    Exception: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
    03/18/98    Replaced domain\name key arguments with single       BrianAu
                logon name key.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::Lookup(
    LPCTSTR pszLogonName,
    PSID *ppSid
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::Lookup [name]")));
    DBGASSERT((NULL != pszLogonName));
    DBGASSERT((NULL != ppSid));

    HRESULT hResult = BeginTransaction();

    if (SUCCEEDED(hResult))
    {
        try
        {
            //
            // Can throw OutOfMemory.
            //
            DWORD iBlock = m_pIndexMgr->Lookup(pszLogonName);

            if ((DWORD)-1 != iBlock)
            {
                //
                // Can throw OutOfMemory.
                //
                hResult = m_pRecordMgr->Retrieve(iBlock,
                                                 ppSid,
                                                 NULL,
                                                 NULL,
                                                 NULL);

                if (m_pRecordMgr->RecordExpired(iBlock))
                {
                    //
                    // Record is outdated.  Delete it from the cache.
                    // Returning "not found" will cause the caller to get
                    // a fresh one from the domain controller - which will
                    // then again be added to the cache.
                    //
                    DBGASSERT((NULL != *ppSid));
                    m_pIndexMgr->FreeEntry(*ppSid);
                    m_pRecordMgr->FreeRecord(iBlock);
                    delete[] *ppSid;
                    *ppSid = NULL;
                    hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }
            else
            {
                hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);  // SID not in cache.
            }
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
        EndTransaction();
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Add

    Description: Add user's information to the cache.  Information consists
        of the SID (key), container name, account logon name and
        account display name.

    Arguments:
        pSid - Address of user's SID.

        pszContainer - Address of account container name string.
            i.e. "REDMOND" or "ntdev.microsoft.com\US-SOS ....."

        pszLogonName - Address of account logon name string.
            i.e. "REDMOND\brianau" or "brianau@microsoft.com"

        pszDisplayName - Address of display name string.
            i.e. "Brian Aust"

    Returns:
        NO_ERROR                  - Success.
        S_FALSE                   - Already exists in cache.  Not added.
        ERROR_LOCK_FAILED (hr)    - Couldn't get exclusive lock on cache.
        ERROR_INVALID_DATA (hr)   - Index or data file is invalid.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::Add(
    PSID pSid,
    LPCTSTR pszContainer,
    LPCTSTR pszLogonName,
    LPCTSTR pszDisplayName
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::Add")));

    DBGASSERT((NULL != pSid));
    DBGASSERT((NULL != pszContainer));
    DBGASSERT((NULL != pszLogonName));
    DBGASSERT((NULL != pszDisplayName));

    HRESULT hResult = BeginTransaction();

    if (SUCCEEDED(hResult))
    {
        try
        {
            //
            // Can throw OutOfMemory.
            //
            if ((DWORD)-1 == m_pIndexMgr->Lookup(pSid))
            {
                DWORD iBlock = m_pRecordMgr->Store(pSid,
                                                   pszContainer,
                                                   pszLogonName,
                                                   pszDisplayName);

                if ((DWORD)-1 != iBlock)
                {
                    m_pIndexMgr->Add(pSid, iBlock);
                    hResult = NO_ERROR;
                }
            }
            else
            {
                hResult = S_FALSE;  // Already exists. Not a failure.
            }
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
        EndTransaction();
    }

    return hResult;
}



//***********************************************************************************
//***********************************************************************************
//   I N D E X   F I L E   M A N A G E R
//***********************************************************************************
//***********************************************************************************


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::IndexMgr

    Description: Index manager constructor.

    Arguments:
        refCache - Reference to containing cache object.  Used to call
            record manager and cache manager public methods.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::IndexMgr::IndexMgr(
    SidNameCache& refCache
    ) : m_refCache(refCache),
        m_pFileHdr(NULL),
        m_hFile(NULL),
        m_hFileMapping(NULL)
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::SidNameCache::IndexMgr")));
    //
    // Nothing to do.
    //
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::~IndexMgr

    Description: Index manager destructor.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::IndexMgr::~IndexMgr(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::SidNameCache::~IndexMgr")));
    CloseIndexFile();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Initialize

    Description: Initializes a new index manager object.  If both cBuckets
        and cMaxEntries are 0 (default), existing cache files are opened.
        Otherwise, new cache files are created.

    Arguments:
        pszFile - Address of full path for new file.

        cBuckets - Number of hash table buckets in index file.  Should be
            prime.

        cMaxEntries - Initial max number of entries for the index.  Note
            that the index file grows automatically as required.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::IndexMgr::Initialize(
    LPCTSTR pszFile,
    DWORD cBuckets,
    DWORD cMaxEntries
    )
{
    DBGTRACE((DM_SIDCACHE, DL_HIGH, TEXT("SidNameCache::IndexMgr::Initialize")));
    DBGASSERT((NULL != pszFile));

    //
    // Store the file name in our CString object.
    //
    m_strFileName = pszFile;

    if (0 == cBuckets && 0 == cMaxEntries)
    {
        //
        // Initialize manager using existing cache files.
        //
        m_pFileHdr = (PINDEX_FILE_HDR)OpenIndexFile(pszFile);
        if (NULL != m_pFileHdr)
        {
            if (FILE_VERSION != m_pFileHdr->dwVersion ||
                INDEX_FILE_SIGNATURE != m_pFileHdr->dwSignature)
            {
                //
                // This version of the software doesn't understand this
                // version of the file or file has an invalid signature.
                // Don't take any chances.  We'll just create a new one.
                //
                DBGERROR((TEXT("SIDCACHE - Index file is invalid or incorrect version. A new index file will be created.")));

                CloseIndexFile();
                m_pFileHdr = NULL;
            }
        }
    }
    else
    {
        //
        // Initialize manager by creating new cache files.
        //
        ULARGE_INTEGER uliFileSize;
        uliFileSize.QuadPart = FileSize(cMaxEntries, cBuckets);

        m_pFileHdr = (PINDEX_FILE_HDR)CreateIndexFile(pszFile,
                                                      uliFileSize.HighPart,
                                                      uliFileSize.LowPart);
        if (NULL != m_pFileHdr)
        {
            InitNewIndexFile(cBuckets, cMaxEntries);
        }
    }
    return (LPBYTE)m_pFileHdr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::CreateIndexFile

    Description: Creates and initializes a new index file.

    Arguments:
        pszFile - Address of full path for new file.

        cbFileHigh/Low - Size of file in bytes.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::IndexMgr::CreateIndexFile(
    LPCTSTR pszFile,
    DWORD cbFileHigh,
    DWORD cbFileLow
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::CreateIndexFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tFile: \"%s\""), pszFile ? pszFile : TEXT("<null>")));

    DBGASSERT((NULL != pszFile));

    CloseIndexFile();  // Make sure any existing index file is closed.

    g_pbMappedIndexFile = SidNameCache::OpenMappedFile(
                                pszFile,
                                g_pszIndexFileMapping,
                                CREATE_ALWAYS,
                                cbFileHigh,
                                cbFileLow,
                                &m_hFile,
                                &m_hFileMapping);

    return g_pbMappedIndexFile;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::OpenIndexFile

    Description: Opens an existing index file.

    Arguments:
        pszFile - Address of full path for new file.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::IndexMgr::OpenIndexFile(
    LPCTSTR pszFile
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::OpenIndexFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tFile: \"%s\""), pszFile ? pszFile : TEXT("<null>")));
    DBGASSERT((NULL != pszFile));

    CloseIndexFile();  // Make sure any existing index file is closed.

    g_pbMappedIndexFile = SidNameCache::OpenMappedFile(
                                pszFile,
                                g_pszIndexFileMapping,
                                OPEN_EXISTING,
                                0,
                                0,
                                &m_hFile,
                                &m_hFileMapping);
    return g_pbMappedIndexFile;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::CloseIndexFile

    Description: Closes the current index mapping and file.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::CloseIndexFile(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::CloseIndexFile")));
    if (NULL != g_pbMappedIndexFile)
    {
        UnmapViewOfFile(g_pbMappedIndexFile);
        g_pbMappedIndexFile = NULL;
        m_pFileHdr = NULL;
    }
    if (NULL != m_hFileMapping)
    {
        CloseHandle(m_hFileMapping);
        m_hFileMapping = NULL;
    }
    if (NULL != m_hFile && INVALID_HANDLE_VALUE != m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::GrowIndexFile

    Description: Increases the size of the current index file.

    Arguments:
        cGrowEntries - Make room for this many more entries.  Note that the
            size of the hash table is fixed.  If we were to allow this to
            change, it would invalidate any existing hash values in the
            table (hash code is a function of the SID and table size).

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::IndexMgr::GrowIndexFile(
    DWORD cGrowEntries
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::GrowIndexFile")));
    DBGASSERT((INDEX_FILE_MAPPED));

    DWORD cOldMaxEntries = m_pFileHdr->cMaxEntries;
    DWORD cNewMaxEntries = cOldMaxEntries + cGrowEntries;

    DBGPRINT((DM_SIDCACHE, DL_MID,
             TEXT("Growing SID cache index %d -> %d entries."),
             cOldMaxEntries, cNewMaxEntries));

    //
    // Open the existing file and map with a new larger size.
    // Must calc new size BEFORE closing current index file so that m_pFileHdr
    // is still valid.
    //
    ULARGE_INTEGER uliFileSize;
    uliFileSize.QuadPart = FileSize(cNewMaxEntries, m_pFileHdr->cBuckets);

    CloseIndexFile();

    g_pbMappedIndexFile = SidNameCache::OpenMappedFile(
                                m_strFileName,
                                g_pszIndexFileMapping,
                                OPEN_EXISTING,
                                uliFileSize.HighPart,
                                uliFileSize.LowPart,
                                &m_hFile,
                                &m_hFileMapping);

    m_pFileHdr = (PINDEX_FILE_HDR)g_pbMappedIndexFile;

    if (NULL != g_pbMappedIndexFile)
    {
        m_pFileHdr->cMaxEntries = cNewMaxEntries;

        //
        // Growing the index only expands the number of index
        // pool entries. The index hash table is left alone.
        // Good reason to make it large to start with.  If we changed
        // the hash table size, existing hash codes would be
        // invalid.
        //
        PINDEX_ENTRY pEntry = m_pFileHdr->pEntries + cOldMaxEntries;
        for (UINT i = 0; i < cGrowEntries; i++)
        {
            AddEntryToFreeList(pEntry++);
        }
        DBGPRINT((DM_SIDCACHE, DL_HIGH, TEXT("SIDCACHE - Index growth complete.")));
    }

    return g_pbMappedIndexFile;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::InitNewIndexFile

    Description: Initializes a new index file filling in the header information
        and clearing the index entries.

    Arguments:
        cBuckets - Number of hash table buckets in index file.  Should be
            prime.

        cMaxEntries - Initial max number of entries for the index.  Note
            that the index file grows automatically as required.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::InitNewIndexFile(
    DWORD cBuckets,
    DWORD cMaxEntries
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::InitNewIndexFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tcBuckets = %d, cMaxEntries = %d"),
               cBuckets, cMaxEntries));
    DBGASSERT((INDEX_FILE_MAPPED));

    m_pFileHdr->dwSignature   = INDEX_FILE_SIGNATURE;
    m_pFileHdr->dwVersion     = FILE_VERSION;
    m_pFileHdr->cBuckets      = cBuckets;
    m_pFileHdr->cMaxEntries   = cMaxEntries;
    m_pFileHdr->pBuckets      = (PINDEX_ENTRY *)(sizeof(INDEX_FILE_HDR));
    m_pFileHdr->pEntries      = (PINDEX_ENTRY)(m_pFileHdr->pBuckets + cBuckets);

    //
    // Initialize the hash table and return all entries to the free list.
    //
    Clear();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Clear

    Description: Fills the hash table with NULL pointers and returns all
        entry nodes to the free list.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::Clear(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::Clear")));
    DBGASSERT((INDEX_FILE_MAPPED));

    m_pFileHdr->cEntries = 0;
    SetFileGUID(&GUID_Null);

    //
    // Initialize all hash buckets to NULL.
    //
    DBGASSERT((0 < m_pFileHdr->cBuckets));
    ZeroMemory(NDX_BASED_CAST(BYTE, m_pFileHdr->pBuckets),
               m_pFileHdr->cBuckets * sizeof(PINDEX_ENTRY *));

    //
    // Return all index entry nodes to the free list.
    //
    PINDEX_ENTRY pEntry = m_pFileHdr->pEntries;
    DBGASSERT((0 < m_pFileHdr->cMaxEntries));
    for (UINT i = 0; i < m_pFileHdr->cMaxEntries; i++)
    {
        //
        // We're iterating through all entries.  No need to detach first.
        //
        AddEntryToFreeList(pEntry++);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::SetFileGUID
    Function: SidNameCache::IndexMgr::GetFileGUID

    Description: These functions manipulate the guid field in the index file's
        header.
        The GUID is used to ensure integrity between
        the data and index files.  Before any change to either file, the
        GUID's are both set to 0.  When the change operation is complete,
        a new GUID is generated and written to both files.  Therefore, before
        any transaction, we can validate the data and index files by reading
        and comparing GUIDs.  If the GUIDs are not 0 and are equal, the
        file can be assumed to be valid.

    Arguments:
        pguid - Address of source or destination GUID.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::SetFileGUID(
    const GUID *pguid
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pguid));
    CopyMemory(&m_pFileHdr->guid, pguid, sizeof(m_pFileHdr->guid));
}

VOID
SidNameCache::IndexMgr::GetFileGUID(
    LPGUID pguid
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pguid));
    CopyMemory(pguid, &m_pFileHdr->guid, sizeof(*pguid));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::AllocEntry

    Description: Allocates an entry from the free list.

    Arguments: None.

    Returns:
        Address of new entry node or NULL if free list is empty.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PINDEX_ENTRY
SidNameCache::IndexMgr::AllocEntry(
    VOID
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    PINDEX_ENTRY pEntry = m_pFileHdr->pFirstFree;

    if (NULL != pEntry)
    {
        NDX_BASED(INDEX_ENTRY) *pBasedEntry = NDX_BASED_CAST(INDEX_ENTRY, pEntry);

        //
        // Unlink the entry from the free list.
        //
        m_pFileHdr->pFirstFree = pBasedEntry->pNext;

        //
        // Clear it's "prev" and "next" pointers.
        //
        pBasedEntry->pNext = pBasedEntry->pPrev = NULL;

        if (NULL != m_pFileHdr->pFirstFree)
        {
            //
            // If there is at least one entry in the free list, set the "prev"
            // pointer of the new "first" entry to NULL.
            //
            pBasedEntry = NDX_BASED_CAST(INDEX_ENTRY, m_pFileHdr->pFirstFree);
            pBasedEntry->pPrev = NULL;
        }

        m_pFileHdr->cEntries++;
    }
    return pEntry;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::FreeEntry

    Description: Removes an entry from it's current list and returns it to the
        free list.  Two versions are provided.  One accepts a SID as an entry
        identifier, the other accepts the address of the index entry.

    Arguments:
        pSid - Address of SID associated with entry to be free'd.

        pEntry - Address of index entry to be free'd

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::FreeEntry(
    PSID pSid
    )
{
    DBGASSERT((NULL != pSid));
    PINDEX_ENTRY pEntry = Find(pSid);
    if (NULL != pEntry)
    {
        FreeEntry(pEntry);
    }
}


VOID
SidNameCache::IndexMgr::FreeEntry(
    PINDEX_ENTRY pEntry
    )
{
    DBGASSERT((NULL != pEntry));
    DetachEntry(pEntry);
    AddEntryToFreeList(pEntry);

    m_pFileHdr->cEntries--;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::AddEntryToFreeList

    Description: Returns a detached index entry to the free list.

    Arguments:
        pEntry - Address of index entry to be added to free list.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::AddEntryToFreeList(
    PINDEX_ENTRY pEntry
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pEntry));

    NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);

    //
    // Insert the node at the head of the free list.
    // Note that double-linking isn't necessary in the free list
    // (we always add and remove free list entries at the head)
    // therefore we don't need to set the next node's "prev" pointer.
    //
    pBased->iBucket        = (DWORD)-1;
    pBased->iBlock         = (DWORD)-1;
    pBased->pPrev          = NULL;
    pBased->pNext          = m_pFileHdr->pFirstFree;
    m_pFileHdr->pFirstFree = pEntry;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::DetachEntry

    Description: Detaches an index entry from its current list.
        Note that this function assumes that the node exists in a valid
        linked list of nodes.  Do not call this function on an uninitialized
        index entry.

    Arguments:
        pEntry - Address of index entry to be detached.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PINDEX_ENTRY
SidNameCache::IndexMgr::DetachEntry(
    PINDEX_ENTRY pEntry
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pEntry));

    NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
    NDX_BASED(INDEX_ENTRY) *pBasedNext;
    NDX_BASED(INDEX_ENTRY) *pBasedPrev;

    //
    // Unlink the entry from it's list.
    //
    if (NULL != pBased->pPrev)
    {
        pBasedPrev        = NDX_BASED_CAST(INDEX_ENTRY, pBased->pPrev);
        pBasedPrev->pNext = pBased->pNext;
    }
    if (NULL != pBased->pNext)
    {
        pBasedNext        = NDX_BASED_CAST(INDEX_ENTRY, pBased->pNext);
        pBasedNext->pPrev = pBased->pPrev;
    }
    //
    // If we're detaching the entry that's attached to the hash array element,
    // adjust the element's value.
    //
    if (GetHashBucketValue(pBased->iBucket) == pEntry)
        SetHashBucketValue(pBased->iBucket, pBased->pNext);

    pBased->pNext = pBased->pPrev = NULL;

    return pEntry;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::GetHashBucketValue

    Description: Returns the address of the first index entry in a hash bucket.

    Arguments:
        iBucket - Array index of bucket in hash table array.

    Returns:
        Address of first entry in bucket's entry list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PINDEX_ENTRY
SidNameCache::IndexMgr::GetHashBucketValue(
    DWORD iBucket
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((iBucket < m_pFileHdr->cBuckets));

    NDX_BASED(PINDEX_ENTRY) *pBased = NDX_BASED_CAST(PINDEX_ENTRY, m_pFileHdr->pBuckets + iBucket);
    return *pBased;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::SetHashBucketValue

    Description: Sets the address of the first index entry in a hash bucket.
        OK to set it as NULL.

    Arguments:
        iBucket - Array index of bucket in hash table array.

        pEntry - Address of entry node.

    Returns:
        Address of first entry in bucket's entry list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::SetHashBucketValue(
    DWORD iBucket,
    PINDEX_ENTRY pEntry
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((iBucket < m_pFileHdr->cBuckets));
    //
    // pEntry == NULL is OK.
    //

    NDX_BASED(PINDEX_ENTRY) *pBased = NDX_BASED_CAST(PINDEX_ENTRY,
                                                     m_pFileHdr->pBuckets + iBucket);
    *pBased = pEntry;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Find (3 overloaded methods)

    Description: Given either a SID, a SID and hash value, or a user logon name,
        this method returns the address of the index entry
        representing that cache entry.

    Arguments:
        pKeySid - Address of SID to use as a lookup key.

        dwHashCode - Result of calling Hash(pKeySid).

        pszKeyLogonName - Address of account logon name string.

    Returns:
        Address of index entry representing the user.
        NULL if not found.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PINDEX_ENTRY
SidNameCache::IndexMgr::Find(
    PSID pKeySid
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pKeySid));

    return Find(pKeySid, Hash(pKeySid));  // Can throw OutOfMemory.
}


PINDEX_ENTRY
SidNameCache::IndexMgr::Find(
    PSID pKeySid,
    DWORD dwHashCode
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pKeySid));

    BOOL bFound         = FALSE;
    PINDEX_ENTRY pEntry = GetHashBucketValue(dwHashCode);
    while(NULL != pEntry && !bFound)
    {
        PSID pSid = NULL;
        NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);

        //
        // This can throw OutOfMemory.
        //
        if (SUCCEEDED(m_refCache.m_pRecordMgr->Retrieve(pBased->iBlock,
                                                        &pSid,
                                                        NULL,
                                                        NULL,
                                                        NULL)))
        {
            if (EqualSid(pKeySid, pSid))
            {
                bFound = TRUE;
            }
        }
        if (!bFound)
        {
            pEntry = pBased->pNext;
        }

        delete[] pSid;
    }

    return pEntry;
}


//
// This version of Find() performs a linear search of the index to locate
// the specified logon name.  The cache is currently indexed only
// on user SID because this is the only key used for very rapid lookups.
// The cache implementation could be easily extended to include a
// logon name index.  All that's needed is a second hash bucket array,
// a hash-on-name function and some adjustments to the placement of
// file data.  I just don't think the benefit is worth the cost.
//
PINDEX_ENTRY
SidNameCache::IndexMgr::Find(
    LPCTSTR pszKeyLogonName
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pszKeyLogonName));

    BOOL bFound         = FALSE;
    PINDEX_ENTRY pEntry = NULL;

    for (UINT i = 0; !bFound && (i < m_pFileHdr->cBuckets); i++)
    {
        pEntry = GetHashBucketValue(i);
        while(NULL != pEntry && !bFound)
        {
            array_autoptr<TCHAR> ptrLogonName;

            NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);

            //
            // This can throw OutOfMemory.
            //
            if (SUCCEEDED(m_refCache.m_pRecordMgr->Retrieve(pBased->iBlock,
                                                            NULL,
                                                            NULL,  // no container.
                                                            ptrLogonName.getaddr(),
                                                            NULL))) // no display name
            {
                DBGASSERT((NULL != ptrLogonName.get()));

                if (0 == lstrcmpi(ptrLogonName.get(), pszKeyLogonName))
                {
                    bFound = TRUE;
                }
            }
            if (!bFound)
            {
                pEntry = pBased->pNext;
            }
        }
    }
    return pEntry;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Lookup (2 overloaded methods)

    Description: Given either a SID or an account logon name,
        this method returns the starting block index of the corresponding
        record in the data file.

    Arguments:
        pSid - Address of SID to use as a lookup key.

        pszLogonName - Address of account logon name string.

    Returns:
        Index of the starting block for the record in the data file.
        (DWORD)-1 if the record is not found.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::IndexMgr::Lookup(
    PSID pSid
    )
{
    DBGASSERT((NULL != pSid));

    //
    // This can throw OutOfMemory.
    //
    PINDEX_ENTRY pEntry = Find(pSid, Hash(pSid));

    if (NULL != pEntry)
    {
        NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
        return pBased->iBlock;
    }

    return (DWORD)-1;
}



DWORD
SidNameCache::IndexMgr::Lookup(
    LPCTSTR pszLogonName
    )
{
    DBGASSERT((NULL != pszLogonName));

    //
    // This can throw OutOfMemory.
    //
    PINDEX_ENTRY pEntry = Find(pszLogonName);

    if (NULL != pEntry)
    {
        NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
        return pBased->iBlock;
    }

    return (DWORD)-1;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Add

    Description: Adds a SID/data-file-index pair to the index file.  This
        entry can later be used to locate the SID's record in the data file.

    Arguments:
        pSid - Address of SID to use as a lookup key.

        iBlock - Index of the starting block for the SID's record in the
            data file.

    Returns: Address of the item's new index entry.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PINDEX_ENTRY
SidNameCache::IndexMgr::Add(
    PSID pSid,
    DWORD iBlock
    )
{
    DWORD dwHashCode    = Hash(pSid);
    PINDEX_ENTRY pEntry = Find(pSid, dwHashCode); // Can throw OutOfMemory.

    //
    // Don't create duplicate entries.
    //
    if (NULL == pEntry)
    {
        //
        // Try to allocate an index entry from the free list.
        //
        pEntry = AllocEntry();
        if (NULL == pEntry)
        {
            //
            // Grow the index file and try again.
            //
            GrowIndexFile(INDEX_FILE_GROW_ENTRIES);
            pEntry = AllocEntry();
        }
        if (NULL != pEntry)
        {
            NDX_BASED(INDEX_ENTRY) *pBasedEntry = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
            NDX_BASED(INDEX_ENTRY) *pBasedNext;

            //
            // Fill in the members of the new entry.
            //
            pBasedEntry->iBucket = dwHashCode;
            pBasedEntry->iBlock  = iBlock;
            pBasedEntry->pNext   = GetHashBucketValue(dwHashCode);
            pBasedEntry->pPrev   = NULL;
            //
            // Now insert it at the head of the hash bucket's entry list.
            //
            if (NULL != pBasedEntry->pNext)
            {
                pBasedNext = NDX_BASED_CAST(INDEX_ENTRY, pBasedEntry->pNext);
                pBasedNext->pPrev = pEntry;
            }
            SetHashBucketValue(dwHashCode, pEntry);
        }
    }

    return pEntry;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Hash

    Description: Given a SID, this method calculates a hash value to be used
        as an offset into the index's hash table bucket array.  The
        algorithm simply sums the value of the SID's bytes.  The resulting
        hash code is this sum modulo the size of the hash table.  For this
        simple algorithm to be effective, it is important that the hash
        table size be a prime number.

        Here's some representative primes: 101, 503, 1009, 5003, 10007

    Arguments:
        pSid - Address of SID to use as an index lookup key.

    Returns: Hashed SID.  The value will be between 0 and m_pFileHdr->cBuckets.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::IndexMgr::Hash(
    PSID pSid
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DWORD dwCode   = 0;
    PBYTE pbSid    = (PBYTE)pSid;
    PBYTE pbEndSid = pbSid + GetLengthSid(pSid);

    for ( ;pbSid < pbEndSid; pbSid++)
        dwCode += *pbSid;

    return dwCode % m_pFileHdr->cBuckets;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Dump [DEBUG only]

    Description: Dumps the contents of the index file to the debugger output.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#if DBG
VOID
SidNameCache::IndexMgr::Dump(
    VOID
    )
{
    UINT i, j;
    DBGASSERT((INDEX_FILE_MAPPED));

    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("Dumping SidNameCache IndexMgr at 0x%p"), this));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  Base...............: 0x%p"), g_pbMappedIndexFile));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  m_pFileHdr.........: 0x%p"), m_pFileHdr));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    dwSignature......: 0x%08X"), (DWORD)m_pFileHdr->dwSignature));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    dwVersion........: 0x%08X"), (DWORD)m_pFileHdr->dwVersion));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cBuckets.........: %d"),     (DWORD)m_pFileHdr->cBuckets));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cMaxEntries......: %d"),     (DWORD)m_pFileHdr->cMaxEntries));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cEntries.........: %d"),     (DWORD)m_pFileHdr->cEntries));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    pBuckets.........: 0x%p"), m_pFileHdr->pBuckets));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    pEntries.........: 0x%p"), m_pFileHdr->pEntries));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    pFirstFree.......: 0x%p"), m_pFileHdr->pFirstFree));

    for (i = 0; i < m_pFileHdr->cBuckets; i++)
    {
        PINDEX_ENTRY pEntry = GetHashBucketValue(i);
        DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  Bucket[%03d] = 0x%p"), i, pEntry));

        while(NULL != pEntry)
        {
            NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
            DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("     Bkt = %3d  P = 0x%08X  N = 0x%08X  Blk = %d"),
                       pBased->iBucket,
                       pBased->pPrev,
                       pBased->pNext,
                       pBased->iBlock));

            pEntry = pBased->pNext;
        }
    }

    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  FreeList")));
    PINDEX_ENTRY pEntry = m_pFileHdr->pFirstFree;
    while(NULL != pEntry)
    {
        NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
        DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("     Bkt = %3d  P = 0x%08X  N = 0x%08X  Blk = %d"),
                   pBased->iBucket,
                   pBased->pPrev,
                   pBased->pNext,
                   pBased->iBlock));

        pEntry = pBased->pNext;
    }
}
#endif


//***********************************************************************************
//***********************************************************************************
//   D A T A    F I L E    M A N A G E R
//***********************************************************************************
//***********************************************************************************

//
// Default cache record life values in days.
//
const DWORD DEF_REC_LIFE_MIN = 30;
const DWORD DEF_REC_LIFE_MAX = 60;

///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::RecordMgr

    Description: Record manager constructor.

    Arguments:
        refCache - Reference to containing cache object.  Used to call
            index manager and cache manager public methods.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::RecordMgr::RecordMgr(
    SidNameCache& refCache
    ) : m_refCache(refCache),
        m_pFileHdr(NULL),
        m_hFile(NULL),
        m_hFileMapping(NULL),
        m_cDaysRecLifeMin(DEF_REC_LIFE_MIN),
        m_cDaysRecLifeRange(DEF_REC_LIFE_MAX - DEF_REC_LIFE_MIN)
{
    DWORD cDaysRecLifeMax = DEF_REC_LIFE_MAX;

    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::SidNameCache::RecordMgr")));

    //
    // Retrieve the min/max record life (days) from the registry.
    // Note that we store record life min and range since those are
    // what's used in the record life calculation.  Seems more
    // self-explanatory to store min/max in the registry rather than
    // min/range.
    //
    RegKey key(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
    if (key.Open(KEY_WRITE, true))
    {
        if (FAILED(key.GetValue(g_szSidCacheRecLifeMin, &m_cDaysRecLifeMin)) ||
            65536 <= m_cDaysRecLifeMin)
        {
            m_cDaysRecLifeMin = DEF_REC_LIFE_MIN; // Default;
            key.SetValue(g_szSidCacheRecLifeMin, m_cDaysRecLifeMin);
        }
        if (FAILED(key.GetValue(g_szSidCacheRecLifeMax, &cDaysRecLifeMax)) ||
            65536 <= cDaysRecLifeMax)
        {
            cDaysRecLifeMax = DEF_REC_LIFE_MAX; // Default;
            key.SetValue(g_szSidCacheRecLifeMax, cDaysRecLifeMax);
        }
    }

    if (cDaysRecLifeMax < m_cDaysRecLifeMin)
        cDaysRecLifeMax = m_cDaysRecLifeMin;

    m_cDaysRecLifeRange = cDaysRecLifeMax - m_cDaysRecLifeMin;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::~RecordMgr

    Description: Record manager destructor. Closes the data file.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::RecordMgr::~RecordMgr(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::SidNameCache::~RecordMgr")));
    CloseDataFile();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::Initialize

    Description: Initializes a new record manager object.

    Arguments:
        pszFile - Address of full path for new file.

        cBlocks - Number of storage blocks in data file. Each is 32 bytes.
            If this argument is 0, the function tries to open an existing
            cache data file.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::RecordMgr::Initialize(
    LPCTSTR pszFile,
    DWORD cBlocks
    )
{
    DBGTRACE((DM_SIDCACHE, DL_HIGH, TEXT("SidNameCache::RecordMgr::Initialize")));
    DBGPRINT((DM_SIDCACHE, DL_HIGH, TEXT("\tpszFile = \"%s\", cBlocks = %d"),
              pszFile ? pszFile : TEXT("<null>"), cBlocks));
    //
    // Store the file name in our CString object.
    //
    m_strFileName = pszFile;

    if (0 != cBlocks)
    {
        //
        // Create a new data file.
        //
        // cBlocks must be a multiple of 32.
        // This satisfies the quadword alignment and makes sizing the
        // allocation bitmap much easier.  We let the caller pass in any value
        // they want and we just adjust it upward as needed.
        //
        if (cBlocks & 0x0000001F)
            cBlocks = (cBlocks & 0xFFFFFFE0) + 32;

        ULARGE_INTEGER uliFileSize;
        uliFileSize.QuadPart = FileSize(cBlocks);

        m_pFileHdr = (PDATA_FILE_HDR)CreateDataFile(pszFile,
                                                    uliFileSize.HighPart,
                                                    uliFileSize.LowPart);
        if (NULL != m_pFileHdr)
        {
            InitNewDataFile(cBlocks);
        }
    }
    else
    {
        //
        // Open an existing data file.
        //
        m_pFileHdr = (PDATA_FILE_HDR)OpenDataFile(pszFile);
        if (NULL != m_pFileHdr)
        {
            if (FILE_VERSION != m_pFileHdr->dwVersion ||
                DATA_FILE_SIGNATURE != m_pFileHdr->dwSignature)
            {
                //
                // This version of the software doesn't understand this
                // version of the file or the signature is invalid.
                // Don't take any chances.  We'll just create a new one.
                //
                DBGERROR((TEXT("SIDCACHE - Data file is invalid or incorrect version. A new data file will be created.")));

                CloseDataFile();
                m_pFileHdr = NULL;
            }
        }
    }
    return (LPBYTE)m_pFileHdr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::CreateDataFile

    Description: Creates and initializes a new data file.

    Arguments:
        pszFile - Address of full path for new file.

        cbFileHigh/Low - Size of file in bytes.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::RecordMgr::CreateDataFile(
    LPCTSTR pszFile,
    DWORD cbFileHigh,
    DWORD cbFileLow
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::CreateDataFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tpszFile = \"%s\""),
              pszFile ? pszFile : TEXT("<null>")));

    CloseDataFile();  // Make sure any existing data file is closed.

    g_pbMappedDataFile = SidNameCache::OpenMappedFile(
                                pszFile,
                                g_pszDataFileMapping,
                                CREATE_ALWAYS,
                                cbFileHigh,
                                cbFileLow,
                                &m_hFile,
                                &m_hFileMapping);

    return g_pbMappedDataFile;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::OpenDataFile

    Description: Opens an existing data file.

    Arguments:
        pszFile - Address of full path of existing file.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::RecordMgr::OpenDataFile(
    LPCTSTR pszFile
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::OpenDataFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tpszFile = \"%s\""),
              pszFile ? pszFile : TEXT("<null>")));

    CloseDataFile();  // Make sure any existing data file is closed.

    g_pbMappedDataFile = SidNameCache::OpenMappedFile(
                                pszFile,
                                g_pszDataFileMapping,
                                OPEN_EXISTING,
                                0,
                                0,
                                &m_hFile,
                                &m_hFileMapping);

    return g_pbMappedDataFile;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::CloseDataFile

    Description: Closes the current data mapping and file.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::CloseDataFile(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::CloseDataFile")));
    if (NULL != g_pbMappedDataFile)
    {
        UnmapViewOfFile(g_pbMappedDataFile);
        g_pbMappedDataFile = NULL;
        m_pFileHdr = NULL;
    }
    if (NULL != m_hFileMapping)
    {
        CloseHandle(m_hFileMapping);
        m_hFileMapping = NULL;
    }
    if (NULL != m_hFile && INVALID_HANDLE_VALUE != m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::GrowDataFile

    Description: Increases the size of the current data file.

    Arguments:
        cGrowBlocks - Add this many more blocks to the data file.  The
            block allocation bitmap is also extended to accomdate the new
            block count.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::RecordMgr::GrowDataFile(
    DWORD cGrowBlocks
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::GrowDataFile")));

    DBGASSERT((DATA_FILE_MAPPED));

    DWORD cOldBlocks = m_pFileHdr->cBlocks;
    DWORD cNewBlocks = cOldBlocks + cGrowBlocks;
    DWORD cOldMapEle = m_pFileHdr->cMapElements;
    DWORD cNewMapEle = 0; // Will calc later.

    //
    // cBlocks must be a multiple of 32.
    // This satisfies the quadword alignment and makes sizing the
    // allocation bitmap much easier.
    //
    if (cNewBlocks & 0x0000001F)
        cNewBlocks = (cNewBlocks & 0xFFFFFFE0) + 32;
    DBGASSERT((cNewBlocks >= cOldBlocks));

    //
    // Adjust cGrowBlocks for any adjustments in cNewBlocks.
    //
    cGrowBlocks = cNewBlocks - cOldBlocks;

    //
    // How many alloc map elements (DWORDs) do we need now?
    //
    cNewMapEle = cNewBlocks / BITS_IN_DWORD;

    DBGPRINT((DM_SIDCACHE, DL_MID,
             TEXT("Growing SID cache data file\nMap Ele %d -> %d\nBlocks %d -> %d"),
             cOldMapEle, cNewMapEle, cOldBlocks, cNewBlocks));

    //
    // Open the mapped file with a new larger size.
    //
    ULARGE_INTEGER uliFileSize;
    uliFileSize.QuadPart = FileSize(cNewBlocks);

    CloseDataFile();

    g_pbMappedDataFile = SidNameCache::OpenMappedFile(
                                m_strFileName,
                                g_pszDataFileMapping,
                                OPEN_EXISTING,
                                uliFileSize.HighPart,
                                uliFileSize.LowPart,
                                &m_hFile,
                                &m_hFileMapping);

    m_pFileHdr = (PDATA_FILE_HDR)g_pbMappedDataFile;

    if (NULL != g_pbMappedDataFile)
    {
        UINT i = 0;

        //
        // Block count and map size both increase.
        // Since map size increases, blocks must be moved to accomodate new
        // map elements.  Since the index file tracks records by block index,
        // this movement doesn't affect existing index file entries.
        //
        m_pFileHdr->cBlocks       = cNewBlocks;
        m_pFileHdr->cMapElements  = cNewMapEle;
        //
        // Save current block base for when we move the blocks to make room for
        // the growth of the allocation bitmap.
        //
        PBLOCK pBlocksOld = m_pFileHdr->pBlocks;
        //
        // Calculate the new address of block 0.
        // We want all of the data blocks quadword aligned because they contain
        // a FILETIME structure (64-bits).
        //
        m_pFileHdr->pBlocks = (PBLOCK)(m_pFileHdr->pdwMap + m_pFileHdr->cMapElements);
        QuadAlign((LPDWORD)(&m_pFileHdr->pBlocks));

        //
        // Move all of the existing blocks to their new locations.
        //
        MoveMemory(DAT_BASED_CAST(BLOCK, m_pFileHdr->pBlocks),
                   DAT_BASED_CAST(BLOCK, pBlocksOld),
                   cOldBlocks * sizeof(BLOCK));
        //
        // Initialize the new map elements to 0 (un-allocated).
        //
        ZeroMemory(DAT_BASED_CAST(BYTE, m_pFileHdr->pdwMap + cOldMapEle),
                   (cNewMapEle - cOldMapEle) * sizeof(DWORD));
        //
        // Initialize the new data blocks to 0xCC pattern.
        //
        FillBlocks(cOldBlocks, cGrowBlocks, RECORD_UNUSED_BYTE);

        DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("SIDCACHE - Data file growth complete.")));
    }
    return g_pbMappedDataFile;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::SetFileGUID
    Function: SidNameCache::RecordMgr::GetFileGUID

    Description: These functions manipulate the guid field in the data file's
        header.
        The GUID is used to ensure integrity between
        the data and index files.  Before any change to either file, the
        GUID's are both set to 0.  When the change operation is complete,
        a new GUID is generated and written to both files.  Therefore, before
        any transaction, we can validate the data and index files by reading
        and comparing GUIDs.  If the GUIDs are not 0 and are equal, the
        file can be assumed to be valid.

    Arguments:
        pguid - Address of source or destination GUID.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::SetFileGUID(
    const GUID *pguid
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((NULL != pguid));
    CopyMemory(&m_pFileHdr->guid, pguid, sizeof(m_pFileHdr->guid));
}


VOID
SidNameCache::RecordMgr::GetFileGUID(
    LPGUID pguid
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((NULL != pguid));
    CopyMemory(pguid, &m_pFileHdr->guid, sizeof(*pguid));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::InitNewDataFile

    Description: Initializes a new data file filling in the header information
        and writing 0xCC in all the data block bytes.

    Arguments:
        cBlocks - Number of data blocks (32 bytes each) in data file.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::InitNewDataFile(
    DWORD cBlocks
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::InitNewDataFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tcBlocks = %d"), cBlocks));
    UINT i = 0;

    DBGASSERT((DATA_FILE_MAPPED));

    //
    // Initialize file header.
    //
    m_pFileHdr->dwSignature   = DATA_FILE_SIGNATURE;
    m_pFileHdr->dwVersion     = FILE_VERSION;
    m_pFileHdr->cBlocks       = cBlocks;
    m_pFileHdr->cMapElements  = cBlocks / BITS_IN_DWORD;
    m_pFileHdr->pdwMap        = (LPDWORD)(sizeof(DATA_FILE_HDR));
    m_pFileHdr->pBlocks       = (PBLOCK)(m_pFileHdr->pdwMap + m_pFileHdr->cMapElements);

    //
    // We want all of the data blocks quadword aligned because they contain
    // a FILETIME structure (64-bits).
    //
    QuadAlign((LPDWORD)(&m_pFileHdr->pBlocks));

    //
    // Write 0xCC to all data block bytes.
    //
    Clear();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::Clear

    Description: Zero's the file header guid, clears all bits in the
        block allocation bitmap and fills the data blocks with 0xCC.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::Clear(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::Clear")));
    DBGASSERT((DATA_FILE_MAPPED));

    m_pFileHdr->cBlocksUsed   = 0;
    m_pFileHdr->iFirstFree    = 0;
    SetFileGUID(&GUID_Null);

    //
    // Initialize all block allocation map bits to 0 (un-allocated).
    //
    ZeroMemory(DAT_BASED_CAST(BYTE, m_pFileHdr->pdwMap),
               m_pFileHdr->cMapElements * sizeof(DWORD));
    //
    // Initialize all data blocks to 0xCC pattern.
    //
    FillBlocks(0, m_pFileHdr->cBlocks, RECORD_UNUSED_BYTE);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::FillBlocks

    Description: Fills a range of blocks with a specified byte.

    Arguments:
        iBlock - Index of first block in range.

        cBlocks - Number of blocks to fill.

        b - Byte to write to blocks.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::FillBlocks(
    DWORD iBlock,
    DWORD cBlocks,
    BYTE b
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));

    DAT_BASED(BYTE) *pb = DAT_BASED_CAST(BYTE, BlockAddress(iBlock));
    DBGASSERT((SidNameCache::IsQuadAligned(pb)));

    //
    // Just in case the fill request would extend over the
    // end of the file, truncate the requested block count.  The assertion
    // will catch it during development.
    //
    DWORD iLastBlock = iBlock + cBlocks - 1;
    DBGASSERT((ValidBlockNumber(iLastBlock)));
    if (iLastBlock >= m_pFileHdr->cBlocks)
        cBlocks = m_pFileHdr->cBlocks - iBlock;

    FillMemory(pb, sizeof(BLOCK) * cBlocks, b);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::IsBitSet
    Function: SidNameCache::RecordMgr::SetBit
    Function: SidNameCache::RecordMgr::ClrBit

    Description: Tests and sets bits in the block allocation bitmap.

    Arguments:
        pdwBase - Address of 1st DWORD in bitmap.

        iBit - 0-based index of bit in bitmap.

    Returns: IsBitSet returns TRUE/FALSE indicating the state of the bit.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::RecordMgr::IsBitSet(
    LPDWORD pdwBase,
    DWORD iBit
    )
{
    DBGASSERT((NULL != pdwBase));
    DWORD b = iBit & 0x0000001F;
    DWORD i = iBit >> 5;

    return (*(pdwBase + i)) & (1 << b);
}


VOID
SidNameCache::RecordMgr::SetBit(
    LPDWORD pdwBase,
    DWORD iBit
    )
{
    DBGASSERT((NULL != pdwBase));
    DWORD b = iBit & 0x0000001F;
    DWORD i = iBit >> 5;

    (*(pdwBase + i)) |= (1 << b);
}

VOID
SidNameCache::RecordMgr::ClrBit(
    LPDWORD pdwBase,
    DWORD iBit
    )
{
    DBGASSERT((NULL != pdwBase));
    DWORD b = iBit & 0x0000001F;
    DWORD i = iBit >> 5;

    (*(pdwBase + i)) &= ~(1 << b);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::ValidBlockNumber

    Description: Determine if a given block number is valid for the
        current data file.  Primarily meant for use in assertions.

    Arguments:
        iBlock - 0-based index of block in data file.

    Returns: TRUE/FALSE indicating validity of block number.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::RecordMgr::ValidBlockNumber(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    return (iBlock < m_pFileHdr->cBlocks);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::IsBlockUsed
    Function: SidNameCache::RecordMgr::MarkBlockUsed
    Function: SidNameCache::RecordMgr::MarkBlockUnused

    Description: Examines and changes the allocation state of a block in the
        data file.

    Arguments:
        iBlock - 0-based index of block in data file.

    Returns: IsBlockUsed returns TRUE/FALSE indicating the allocation state.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::RecordMgr::IsBlockUsed(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));
    DAT_BASED(DWORD) *pdwBased = DAT_BASED_CAST(DWORD, m_pFileHdr->pdwMap);

    return IsBitSet((LPDWORD)pdwBased, iBlock);
}


VOID
SidNameCache::RecordMgr::MarkBlockUsed(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));

    DAT_BASED(DWORD) *pdwBased = DAT_BASED_CAST(DWORD, m_pFileHdr->pdwMap);
    DBGASSERT((!IsBitSet((LPDWORD)pdwBased, iBlock)));
    SetBit((LPDWORD)pdwBased, iBlock);
}

VOID
SidNameCache::RecordMgr::MarkBlockUnused(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));

    DAT_BASED(DWORD) *pdwBased = DAT_BASED_CAST(DWORD, m_pFileHdr->pdwMap);
    DBGASSERT((IsBitSet((LPDWORD)pdwBased, iBlock)));
    ClrBit((LPDWORD)pdwBased, iBlock);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::BlocksRequired

    Description: Calculate the number of blocks required to store a given
        number of bytes.

    Arguments:
        cb - Number of bytes requested.

    Returns: Number of 32-byte blocks required to store the bytes.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::RecordMgr::BlocksRequired(
    DWORD cb
    )
{
    //
    // Round byte request up to nearest 32-byte block.
    //
    if (cb & 0x0000001F)
        cb = (cb & 0xFFFFFFE0) + 32;

    //
    // How many "blocks" are required?
    //
    return BYTE_TO_BLOCK(cb);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IsQuadAligned
    Function: SidNameCache::QuadAlign
    Function: SidNameCache::WordAlign

    Description: Methods that determine if a value is quad aligned and for
        updating a value so that it is quad or word aligned.

    Arguments:
        See the individual methods.  It's pretty self-explanatory.

    Returns:
        See the individual methods.  It's pretty self-explanatory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::IsQuadAligned(
    LPVOID pv
    )
{
    return (IsQuadAligned((DWORD_PTR)pv));
}


BOOL
SidNameCache::IsQuadAligned(
    DWORD_PTR dw
    )
{
    return (0 == (dw & 0x00000007));
}


VOID
SidNameCache::QuadAlign(
    LPDWORD pdwValue
    )
{
    DBGASSERT((NULL != pdwValue));
    if (*pdwValue & 0x00000007)
    {
        //
        // Round up to next whole multiple of 8.
        //
        *pdwValue = (*pdwValue & 0xFFFFFFF8) + 8;
    }
}


VOID
SidNameCache::WordAlign(
    LPDWORD pdwValue
    )
{
    DBGASSERT((NULL != pdwValue));
    if (*pdwValue & 0x00000001)
    {
        //
        // Round up to next whole multiple of 2.
        //
        *pdwValue = (*pdwValue & 0xFFFFFFFE) + 2;
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::BytesRequiredForRecord

    Description: Calculates the number of bytes required to store a given
        data file record.  Optionally returns the required size for each
        field in the record (SID, name, domain etc).  The function makes
        allowances for any required data type alignments in the file.

    Arguments:
        pSid - Address of user's SID.

        pcbSid [optional] - Address of variable to receive required SID length.

        pszContainer - Address of user's account container name string.

        pcbContainer [optional] - Address of variable to receive required length
            of container name string.

        pszLogonName - Address of user's logon name string.

        pcbLogonName [optional] - Address of variable to receive required length
            of logon name string.

        pszDisplayName - Address of user's display name string.

        pcbDisplayName [optional] - Address of variable to receive required
            length of display name string.

    Returns: Number of bytes required to store the record.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::RecordMgr::BytesRequiredForRecord(
    PSID pSid,
    LPDWORD pcbSid,
    LPCTSTR pszContainer,
    LPDWORD pcbContainer,
    LPCTSTR pszLogonName,
    LPDWORD pcbLogonName,
    LPCTSTR pszDisplayName,
    LPDWORD pcbDisplayName
    )
{
    DWORD cb      = 0;
    DWORD cbTotal = sizeof(RECORD_HDR);

    //
    // SID follows the header so it IS quadword aligned.
    // It's a byte structure so it doesn't have to be; but it is anyway.
    //
    cb = GetLengthSid(pSid);
    cbTotal += cb;
    if (NULL != pcbSid)
        *pcbSid = cb;

    //
    // Strings are UNICODE and must be word-aligned.  Just align the first.
    // All subsequent are guaranteed to be properly aligned.
    //
    SidNameCache::WordAlign(&cbTotal);
    cb = (lstrlen(pszContainer) + 1) * sizeof(TCHAR);
    cbTotal += cb;
    if (NULL != pcbContainer)
        *pcbContainer = cb;

    cb = (lstrlen(pszLogonName) + 1) * sizeof(TCHAR);
    cbTotal += cb;
    if (NULL != pcbLogonName)
        *pcbLogonName = cb;

    cb = (lstrlen(pszDisplayName) + 1) * sizeof(TCHAR);
    cbTotal += cb;
    if (NULL != pcbDisplayName)
        *pcbDisplayName = cb;

    return cbTotal;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::FreeBlock

    Description: Frees a single block in the data file.

    Arguments:
        iBlock - 0-based index of the block.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::FreeBlock(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));
    DBGASSERT((IsBlockUsed(iBlock)));

    MarkBlockUnused(iBlock);
    DBGASSERT((!IsBlockUsed(iBlock)));

    FillBlocks(iBlock, 1, RECORD_UNUSED_BYTE);

    //
    // Update the "first free" index if needed.
    //
    if (iBlock < m_pFileHdr->iFirstFree)
        m_pFileHdr->iFirstFree = iBlock;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::FreeBlocks

    Description: Frees a series of contiguous blocks in the data file.

    Arguments:
        iBlock - 0-based index of the first block in the series.

        cBlocks - Number of blocks in the series.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::FreeBlocks(
    DWORD iFirstBlock,
    DWORD cBlocks
    )
{
    for (UINT i = 0; i < cBlocks; i++)
        FreeBlock(iFirstBlock + i);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::FreeRecord

    Description: Frees all blocks in a data file record.

    Arguments:
        iFirstBlock - 0-based index of the first block in the record.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::FreeRecord(
    DWORD iFirstBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iFirstBlock)));
    DAT_BASED(RECORD_HDR) *pRecHdr = DAT_BASED_CAST(RECORD_HDR, BlockAddress(iFirstBlock));

    DBGASSERT((RECORD_SIGNATURE == pRecHdr->dwSignature));
    FreeBlocks(iFirstBlock, pRecHdr->cBlocks);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::BlockAddress

    Description: Calculates the non-based address of a given block in the
        data file.

    Arguments:
        iBlock - 0-based index of the block.

    Returns: Address of the block in the data file.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PBLOCK
SidNameCache::RecordMgr::BlockAddress(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));

    return m_pFileHdr->pBlocks + iBlock;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::FileSize

    Description: Calculate the data file size required for a given number of
        data blocks.  Accounts for data type alignment.

    Arguments:
        cBlocks - Number of blocks required in the data file.

    Returns: Bytes required.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT64
SidNameCache::RecordMgr::FileSize(
    DWORD cBlocks
    )

{
    DWORD dwTemp = sizeof(DATA_FILE_HDR) +
                  ((cBlocks / BITS_IN_DWORD) * sizeof(DWORD));

    //
    // Start of blocks must be quad-aligned.
    //
    SidNameCache::QuadAlign(&dwTemp);

    return (UINT64)(dwTemp) +
           (UINT64)(sizeof(BLOCK) * cBlocks);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::AllocBlocks

    Description: Allocates a specified number of contiguous blocks in the
        data file.

    Arguments:
        cBlocksReqd - Number of blocks required in the allocation.

    Returns: If successful, returns the index of the first block in the
        allocation.  Returns (DWORD)-1 if the block's can't be allocated.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::RecordMgr::AllocBlocks(
    DWORD cBlocksReqd
    )
{
    DBGASSERT((DATA_FILE_MAPPED));

    DWORD iBlock = m_pFileHdr->iFirstFree;

    DBGPRINT((DM_SIDCACHE, DL_MID,
             TEXT("SIDCACHE - AllocBlocks: Allocate %d blocks"),
             cBlocksReqd));

    while(iBlock < m_pFileHdr->cBlocks)
    {
        DBGPRINT((DM_SIDCACHE, DL_MID,
                 TEXT("   Start scan at block %d"), iBlock));
        //
        // Look for cBlocksReqd consecutive free blocks.
        //
        for (UINT j = 0; j < cBlocksReqd && (iBlock + j) < m_pFileHdr->cBlocks ; j++)
        {
            DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("      Checking %d"), iBlock + j));
            if (IsBlockUsed(iBlock + j))
            {
                //
                // This one's used. Start searching again.
                //
                DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("      %d is used"), iBlock + j));
                break;
            }
#if DBG
            //
            // If a block is marked "unused", it should contain all 0xCC.
            //
            DAT_BASED(BYTE) *pb = DAT_BASED_CAST(BYTE, BlockAddress(iBlock + j));
            for (UINT k = 0; k < sizeof(BLOCK); k++)
            {
                DBGASSERT((RECORD_UNUSED_BYTE == *(pb + k)));
            }
#endif
        }

        DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("   Scan complete.  %d blocks checked"), j));
        if (j == cBlocksReqd)
        {
            //
            // Found a sufficient range of free blocks.
            // Mark the blocks as allocated in the allocation bitmap.
            //
            for (UINT i = 0; i < cBlocksReqd; i++)
                MarkBlockUsed(iBlock + i);

            if (iBlock == m_pFileHdr->iFirstFree)
            {
                //
                // Now scan to find the next free block.
                // We'll save it's location to help with future free-block searches.
                //
                for (m_pFileHdr->iFirstFree = iBlock + cBlocksReqd;
                     m_pFileHdr->iFirstFree < m_pFileHdr->cBlocks && IsBlockUsed(m_pFileHdr->iFirstFree);
                     m_pFileHdr->iFirstFree++)
                {
                    DBGPRINT((DM_SIDCACHE, DL_MID,
                             TEXT("SIDCACHE - Advancing first free %d"),
                             m_pFileHdr->iFirstFree));
                    NULL;
                }
            }
            DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("SIDCACHE - Found free block range at %d"), iBlock));
            return iBlock;
        }

        iBlock += (j + 1);  // Continue search.
    }
    DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("SIDCACHE - No blocks available")));

    return (DWORD)-1;  // No blocks available of sufficient size.
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::RecordExpired

    Description: Determine if a given record has expired.  A record has
        "expired" if it's expiration date is prior to "today".

    Arguments:
        iBlock - 0-based index of first block in record.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::RecordMgr::RecordExpired(
    DWORD iBlock
    )
{
    DBGASSERT((ValidBlockNumber(iBlock)));
    DAT_BASED(RECORD_HDR) *pRec = DAT_BASED_CAST(RECORD_HDR, BlockAddress(iBlock));
    DBGASSERT((SidNameCache::IsQuadAligned(pRec)));
    DBGASSERT((RECORD_SIGNATURE == pRec->dwSignature));

    SYSTEMTIME SysNow;
    FILETIME FileNow;
    ULARGE_INTEGER uliFileNow;
    ULARGE_INTEGER uliBirthday;

    uliBirthday.LowPart  = pRec->Birthday.dwLowDateTime;
    uliBirthday.HighPart = pRec->Birthday.dwHighDateTime;

    GetSystemTime(&SysNow);
    SystemTimeToFileTime(&SysNow, &FileNow);

    uliFileNow.LowPart  = FileNow.dwLowDateTime;
    uliFileNow.HighPart = FileNow.dwHighDateTime;

    DWORD cDaysVariation = 0;
    //
    // Avoid div-by-zero.
    //
    if (0 < m_cDaysRecLifeRange)
        cDaysVariation = SysNow.wMilliseconds % m_cDaysRecLifeRange;

    //
    // Add time specified in registry to the record's birthday.
    // 864,000,000,000L is the number of 100 nanosecond periods in a day
    // which is the unit the FILETIME structure is based on.
    //
    uliBirthday.QuadPart += ((UINT64)864000000000L *
                            (UINT64)(m_cDaysRecLifeMin + cDaysVariation));
    //
    // If it's still less than "now", the record is considered good.
    //
    return uliFileNow.QuadPart > uliBirthday.QuadPart;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::Store

    Description: Stores a record in the data file.

    Arguments:
        pSid - Address of user's SID.

        pszContainer - Address of user's account container name string.

        pszLogonName - Address of user's logon name string.

        pszDisplayName - Address of user's display name string.

    Returns: Index of the first block used for the record.
        (DWORD)-1 if the block couldn't be stored.  Could mean out-of-disk
        space.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::RecordMgr::Store(
    PSID pSid,
    LPCTSTR pszContainer,
    LPCTSTR pszLogonName,
    LPCTSTR pszDisplayName
    )
{
    DWORD cbSid         = 0;
    DWORD cbContainer   = 0;
    DWORD cbLogonName   = 0;
    DWORD cbDisplayName = 0;

    DWORD cbRequired = BytesRequiredForRecord(
                            pSid,
                            &cbSid,
                            pszContainer,
                            &cbContainer,
                            pszLogonName,
                            &cbLogonName,
                            pszDisplayName,
                            &cbDisplayName);

    DWORD cBlocksRequired = BlocksRequired(cbRequired);
    DBGPRINT((DM_SIDCACHE, DL_MID,
             TEXT("SIDCACHE - Store: %s (%s) in \"%s\"  %d bytes, %d blocks"),
             pszDisplayName, pszLogonName, pszContainer, cbRequired, cBlocksRequired));

    //
    // Try to allocate the required blocks.
    //
    DWORD iBlock = AllocBlocks(cBlocksRequired);
    if ((DWORD)-1 == iBlock)
    {
        //
        // Couldn't allocate blocks.  Extend the data file.
        //
        GrowDataFile(DATA_FILE_GROW_BLOCKS);
        iBlock = AllocBlocks(cBlocksRequired);
    }
    if ((DWORD)-1 != iBlock)
    {
        //
        // Got the required number of blocks.
        //
        DBGASSERT((ValidBlockNumber(iBlock)));
        PBLOCK pBlock               = BlockAddress(iBlock);
        DAT_BASED(RECORD_HDR) *pRec = DAT_BASED_CAST(RECORD_HDR, pBlock);
        DAT_BASED(BYTE) *pbRec      = DAT_BASED_CAST(BYTE, pBlock);

        //
        // Fill in the record header.
        // Includes storing the item offset values from the start of the record.
        // Storing these values in the record hdr will help with data retrieval.
        //
        pRec->dwSignature       = RECORD_SIGNATURE;
        pRec->cBlocks           = cBlocksRequired;
        pRec->cbOfsSid          = sizeof(RECORD_HDR);
        pRec->cbOfsContainer    = pRec->cbOfsSid    + cbSid;
        WordAlign(&pRec->cbOfsContainer);

        pRec->cbOfsLogonName   = pRec->cbOfsContainer + cbContainer;
        pRec->cbOfsDisplayName = pRec->cbOfsLogonName + cbLogonName;;

        //
        // Record the "birthday" so we can age the record.
        //
        SYSTEMTIME SysNow;
        GetSystemTime(&SysNow);
        SystemTimeToFileTime(&SysNow, &pRec->Birthday);

        //
        // Store the record's data.
        // Use ACTUAL length values for memory transfers.
        //
        const size_t cbRec = pRec->cBlocks * BLOCK_SIZE;
        CopySid(cbSid, (PSID)(pbRec + pRec->cbOfsSid), pSid);
        StringCbCopy((LPTSTR)(pbRec + pRec->cbOfsContainer), 
                      cbRec - pRec->cbOfsContainer, 
                      pszContainer);
        StringCbCopy((LPTSTR)(pbRec + pRec->cbOfsLogonName),
                      cbRec - pRec->cbOfsLogonName,
                      pszLogonName);
        StringCbCopy((LPTSTR)(pbRec + pRec->cbOfsDisplayName), 
                      cbRec - pRec->cbOfsDisplayName,
                      pszDisplayName);

        //
        // Update the file's "blocks used" count.
        //
        m_pFileHdr->cBlocksUsed += pRec->cBlocks;
    }

    return iBlock;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::Retrieve

    Description: Retrieves a record in the data file.

    Arguments:
        iBlock - 0-based index of the starting block in the record.

        ppSid [optional] - Address of SID pointer variable to receive the
            address of the SID buffer.  The caller is responsible for freeing
            the buffer.  May be NULL.

        ppszContainer [optional] - Address of pointer variable to receive the
            address of the container name string buffer.  The caller is
            responsible for freeing the buffer.  May be NULL.

        ppszLogonName [optional] - Address of pointer variable to receive the
            address of the logon name string buffer.  The caller is
            responsible for freeing the buffer.  May be NULL.

        ppszDisplayName [optional] - Address of pointer variable to receive the
            address of the display name string buffer.  The caller is
            responsible for freeing the buffer.  May be NULL.

    Returns:
        NO_ERROR          - Success.
        ERROR_INVALID_SID (hr) - The record contains an invalid SID.  Probably
            a corrupt record.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::RecordMgr::Retrieve(
    DWORD iBlock,
    PSID *ppSid,
    LPTSTR *ppszContainer,
    LPTSTR *ppszLogonName,
    LPTSTR *ppszDisplayName
    )
{
    PBLOCK pBlock               = BlockAddress(iBlock);
    DAT_BASED(RECORD_HDR) *pRec = DAT_BASED_CAST(RECORD_HDR, pBlock);
    DAT_BASED(BYTE) *pbRec      = DAT_BASED_CAST(BYTE, pBlock);

    DBGASSERT((SidNameCache::IsQuadAligned(pRec)));
    DBGASSERT((RECORD_SIGNATURE == pRec->dwSignature));

    if (NULL != ppSid)
    {
        PSID pSid = (PSID)(pbRec + pRec->cbOfsSid);
        if (IsValidSid(pSid))
        {
            *ppSid = SidDup(pSid);
        }
        else
            return HRESULT_FROM_WIN32(ERROR_INVALID_SID);
    }

    if (NULL != ppszContainer)
    {
        *ppszContainer = StringDup((LPTSTR)(pbRec + pRec->cbOfsContainer));
    }

    if (NULL != ppszLogonName)
    {
        *ppszLogonName = StringDup((LPTSTR)(pbRec + pRec->cbOfsLogonName));
    }

    if (NULL != ppszDisplayName)
    {
        *ppszDisplayName = StringDup((LPTSTR)(pbRec + pRec->cbOfsDisplayName));
    }

    return NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::Dump

    Description: Dumps the contents of the data file to the debugger output.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#if DBG
VOID
SidNameCache::RecordMgr::Dump(
    VOID
    )
{
    UINT i, j;
    DBGASSERT((DATA_FILE_MAPPED));

    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("Dumping SidNameCache RecordMgr at 0x%p"), this));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  Base...............: 0x%p"), g_pbMappedDataFile));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  m_pFileHdr.........: 0x%p"), m_pFileHdr));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    dwSignature......: 0x%08X"), (DWORD)m_pFileHdr->dwSignature));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    dwVersion........: 0x%08X"), (DWORD)m_pFileHdr->dwVersion));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cBlocks..........: %d"),     (DWORD)m_pFileHdr->cBlocks));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cBlocksUsed......: %d"),     (DWORD)m_pFileHdr->cBlocksUsed));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cMapElements.....: %d"),     (DWORD)m_pFileHdr->cMapElements));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    iFirstFree.......: %d"),     (DWORD)m_pFileHdr->iFirstFree));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    pdwMap...........: 0x%p"), m_pFileHdr->pdwMap));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    pBlocks..........: 0x%p"), m_pFileHdr->pBlocks));

    PBLOCK pBlock = m_pFileHdr->pBlocks;

    for (i = 0; i < m_pFileHdr->cBlocks; i++)
    {
        DAT_BASED(BYTE) *pb = DAT_BASED_CAST(BYTE, pBlock);

        DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("BLOCK %d --------------------"), i));
        for (UINT row = 0; row < 2; row++)
        {
            TCHAR szHex[MAX_PATH];
            TCHAR szAscii[MAX_PATH];

            LPTSTR pszHex = szHex;
            size_t cchHex = ARRAYSIZE(szHex);
            pb = DAT_BASED_CAST(BYTE, pBlock) + (row * (sizeof(BLOCK)/2));
            for (j = 0; j < 16; j++)
            {
                StringCchPrintfEx(pszHex, cchHex, &pszHex, &cchHex, 0, TEXT("%02X "), *pb);
                pb++;
            }

            LPTSTR pszAscii = szAscii;
            size_t cchAscii = ARRAYSIZE(szAscii);
            pb = DAT_BASED_CAST(BYTE, pBlock) + (row * (sizeof(BLOCK)/2));
            for (j = 0; j < 16; j++)
            {
                StringCchPrintfEx(pszAscii, cchAscii, &pszAscii, &cchAscii, 0, TEXT("%c"), *pb > 31 ? *pb : TEXT('.'));
                pb++;
            }
            DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("%s %s"), szHex, szAscii));
        }
        pBlock++;
    }
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\user.h ===
#ifndef _INC_DSKQUOTA_USER_H
#define _INC_DSKQUOTA_USER_H
///////////////////////////////////////////////////////////////////////////////
/*  File: user.h

    Description: Contains declarations for class DiskQuotaUser.  The
        DiskQuotaUser object represents a user's quota information on a
        particular volume.  Per-user quota information is managed through
        the IDiskQuotaUser interface.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/20/96    Added m_dwID member to DiskQuotaUser.                BrianAu
    09/05/96    Added domain name string and cache.                  BrianAu
    08/25/97    Added OLE automation support.                        BrianAu
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in 
                reponse to making the quota UI DS-aware.  The 
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_FSOBJECT_H
#   include "fsobject.h"
#endif
#ifndef _INC_DSKQUOTA_DISPATCH_H
#   include "dispatch.h"   // MIDL-generated header (automation).
#endif
#ifndef _INC_DSKQUOTA_OADISP_H
#   include "oadisp.h"     // OleAutoDispatch class (automation).
#endif


class DiskQuotaUser : public IDiskQuotaUser {
    private:
        LONGLONG      m_llQuotaUsed;
        LONGLONG      m_llQuotaThreshold;
        LONGLONG      m_llQuotaLimit;
        LONG          m_cRef;                 // Ref counter.
        ULONG         m_ulUniqueId;           // Unique object ID.
        PSID          m_pSid;                 // Ptr to user's SID structure.
        LPTSTR        m_pszLogonName;         // "brianau@microsoft.com"
        LPTSTR        m_pszDisplayName;       // "Brian Aust"
        FSObject     *m_pFSObject;            // Ptr to file sys object.
        BOOL          m_bNeedCacheUpdate;     // T = Cached data is invalid.
        INT           m_iContainerName;       // Index into acct container name cache.
        DWORD         m_dwAccountStatus;      // Status of user account.

        static HANDLE m_hMutex;               // For serializing access to users.
        static DWORD  m_dwMutexWaitTimeout;   // How long to wait for mutex.
        static LONG   m_cUsersAlive;          // Count of users currently alive.
        static ULONG  m_ulNextUniqueId;       // Unique ID generator.
        static CArray<CString> m_ContainerNameCache; // Cache container names as they
                                                  // are found.  Don't need to dup
                                                  // names in each user object.
        VOID Destroy(VOID);
        VOID DestroyContainerNameCache(VOID);

        BOOL Lock(VOID);
        VOID ReleaseLock(VOID);

        //
        // Prevent copy construction.
        //
        DiskQuotaUser(const DiskQuotaUser& user);
        void operator = (const DiskQuotaUser& user);

        HRESULT
        GetLargeIntegerQuotaItem(
            PLONGLONG pllItem,
            PLONGLONG pllValueOut);

        HRESULT
        SetLargeIntegerQuotaItem(
            PLONGLONG pllItem,
            LONGLONG llValue,
            BOOL bWriteThrough = TRUE);

        HRESULT
        RefreshCachedInfo(
            VOID);
            
        HRESULT
        WriteCachedInfo(
            VOID);

        HRESULT
        GetCachedContainerName(
            INT iCacheIndex,
            LPTSTR pszContainer,
            UINT cchContainer);

        HRESULT
        CacheContainerName(
            LPCTSTR pszContainer,
            INT *pCacheIndex);
        

    public:
        DiskQuotaUser(FSObject *pFSObject);
        ~DiskQuotaUser(VOID);

        HRESULT 
        Initialize(
            PFILE_QUOTA_INFORMATION pfqi = NULL);

        VOID
        SetAccountStatus(
            DWORD dwStatus);

        STDMETHODIMP
        SetName(
            LPCWSTR pszContainer,
            LPCWSTR pszLogonName,
            LPCWSTR pszDisplayName);

        //
        // IUnknown interface.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IDiskQuotaUser methods.
        //
        STDMETHODIMP
        GetID(
            ULONG *pulID);

        STDMETHODIMP
        GetName(
            LPWSTR pszContainerBuffer,
            DWORD cchContainerBuffer,
            LPWSTR pszLogonNameBuffer,
            DWORD cchLogonNameBuffer,
            LPWSTR pszDisplayNameBuffer,
            DWORD cchDisplayNameBuffer);

        STDMETHODIMP 
        GetSidLength(
            LPDWORD pcbSid);

        STDMETHODIMP 
        GetSid(
            PBYTE pSid, 
            DWORD cbSidBuf);

        STDMETHODIMP 
        GetQuotaThreshold(
            PLONGLONG pllThreshold)
            {
                return GetLargeIntegerQuotaItem(&m_llQuotaThreshold, 
                                                pllThreshold);
            }

        STDMETHODIMP 
        GetQuotaThresholdText(
            LPWSTR pszText,
            DWORD cchText);

        STDMETHODIMP 
        GetQuotaLimit(
            PLONGLONG pllLimit)
            {
                return GetLargeIntegerQuotaItem(&m_llQuotaLimit, 
                                                pllLimit);
            }

        STDMETHODIMP 
        GetQuotaLimitText(
            LPWSTR pszText,
            DWORD cchText);

        STDMETHODIMP 
        GetQuotaUsed(
            PLONGLONG pllUsed)
            {
                return GetLargeIntegerQuotaItem(&m_llQuotaUsed, 
                                                pllUsed);
            }

        STDMETHODIMP 
        GetQuotaUsedText(
            LPWSTR pszText,
            DWORD cchText);

        STDMETHODIMP
        GetQuotaInformation(
            LPVOID pbInfo,
            DWORD cbInfo);

        STDMETHODIMP 
        SetQuotaThreshold(
            LONGLONG llThreshold,
            BOOL bWriteThrough = TRUE);

        STDMETHODIMP 
        SetQuotaLimit(
            LONGLONG llLimit,
            BOOL bWriteThrough = TRUE);

        STDMETHODIMP
        Invalidate(
            VOID) { m_bNeedCacheUpdate = TRUE;
                    return NO_ERROR; }

        STDMETHODIMP
        GetAccountStatus(
            LPDWORD pdwAccountStatus);

};


//
// Proxy class to handle all automation interface duties.
// It implements IDispatch and DIDiskQuotaUser passing any actions
// for real disk quota activity onto a referenced DiskQuotaUser object.
// Instances are created in DiskQuotaUser::QueryInterface in response
// to requests for IDispatch and DIDiskQuotaUser.
//
class DiskQuotaUserDisp : public DIDiskQuotaUser 
{
    public:

        explicit DiskQuotaUserDisp(PDISKQUOTA_USER pUser);
        ~DiskQuotaUserDisp(VOID);

        //
        // IUnknown interface.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IDispatch methods.
        //
        STDMETHODIMP
        GetIDsOfNames(
            REFIID riid,  
            OLECHAR ** rgszNames,  
            UINT cNames,  
            LCID lcid,  
            DISPID *rgDispId);

        STDMETHODIMP
        GetTypeInfo(
            UINT iTInfo,  
            LCID lcid,  
            ITypeInfo **ppTInfo);

        STDMETHODIMP
        GetTypeInfoCount(
            UINT *pctinfo);

        STDMETHODIMP
        Invoke(
            DISPID dispIdMember,  
            REFIID riid,  
            LCID lcid,  
            WORD wFlags,  
            DISPPARAMS *pDispParams,  
            VARIANT *pVarResult,  
            EXCEPINFO *pExcepInfo,  
            UINT *puArgErr);

        STDMETHODIMP
        get_ID(
            long *pID);

        STDMETHODIMP
        get_AccountContainerName(
            BSTR *pContainerName);

        STDMETHODIMP 
        get_DisplayName(
            BSTR *pDisplayName);

        STDMETHODIMP 
        get_LogonName(
            BSTR *pLogonName);

        STDMETHODIMP 
        get_QuotaThreshold(
            double *pThreshold);

        STDMETHODIMP 
        put_QuotaThreshold(
            double Threshold);

        STDMETHODIMP 
        get_QuotaThresholdText(
            BSTR *pThresholdText);

        STDMETHODIMP 
        get_QuotaLimit(
            double *pLimit);

        STDMETHODIMP 
        put_QuotaLimit(
            double Limit);

        STDMETHODIMP 
        get_QuotaLimitText(
            BSTR *pLimitText);

        STDMETHODIMP 
        get_QuotaUsed(
            double *pUsed);

        STDMETHODIMP 
        get_AccountStatus(
            AccountStatusConstants *pStatus);

        STDMETHODIMP 
        get_QuotaUsedText(
            BSTR *pUsedText);

        //
        // Methods.
        //
        STDMETHODIMP 
        Invalidate(void);

    private:
        LONG            m_cRef;
        PDISKQUOTA_USER m_pUser;     // For delegation
        OleAutoDispatch m_Dispatch;  // Automation dispatch object.

        //
        // Prevent copy.
        //
        DiskQuotaUserDisp(const DiskQuotaUserDisp& rhs);
        DiskQuotaUserDisp& operator = (const DiskQuotaUserDisp& rhs);
};


#endif // _INC_DISKQUOTA_USER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\user.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: user.cpp

    Description: Contains member function definitions for class DiskQuotaUser.
        The DiskQuotaUser object represents a user's record in a volume's
        quota information file.  The holder of a user object's IDiskQuotaUser
        interface can query and modify information for that user as security
        privileges permit.  A user object is obtained through a UserEnumerator
        object (IEnumDiskQuotaUsers) which is itself obtained through
        IDiskQuotaControl::CreateEnumUsers().

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/20/96    Added m_dwID member to DiskQuotaUser.                BrianAu
    09/05/96    Added exception handling.                            BrianAu
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in
                reponse to making the quota UI DS-aware.  The
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include <comutil.h>
#include "user.h"
#include "resource.h"  // For IDS_NO_LIMIT.

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


//
// Only one of these for all users. (static member).
//
LONG            DiskQuotaUser::m_cUsersAlive        = 0;    // Cnt of users alive now.
ULONG           DiskQuotaUser::m_ulNextUniqueId     = 0;
HANDLE          DiskQuotaUser::m_hMutex             = NULL;
DWORD           DiskQuotaUser::m_dwMutexWaitTimeout = 5000; // 5 seconds.
CArray<CString> DiskQuotaUser::m_ContainerNameCache;



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::DiskQuotaUser

    Description: Constructor.

    Arguments:
         pFSObject - Pointer to "file system" object.  It is through this pointer
            that the object accesses the ntioapi functions.  Caller must call
            AddRef() for this pointer prior to calling Initialize().


    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUser::DiskQuotaUser(
    FSObject *pFSObject
    ) : m_cRef(0),
        m_ulUniqueId(InterlockedIncrement((LONG *)&m_ulNextUniqueId)),
        m_pSid(NULL),
        m_pszLogonName(NULL),
        m_pszDisplayName(NULL),
        m_pFSObject(pFSObject),
        m_bNeedCacheUpdate(TRUE),     // Data cache, not domain name cache.
        m_iContainerName(-1),
        m_dwAccountStatus(DISKQUOTA_USER_ACCOUNT_UNRESOLVED)
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUser::DiskQuotaUser")));
    DBGPRINT((DM_USER, DL_HIGH, TEXT("\tthis = 0x%08X"), this));
    DBGASSERT((NULL != m_pFSObject));

    m_llQuotaUsed      = 0;
    m_llQuotaThreshold = 0;
    m_llQuotaLimit     = 0;

    //
    // Initialize the domain name cache and class-wide locking mutex.
    // These members are static so we only do it once.
    //
    InterlockedIncrement(&m_cUsersAlive);
    if (NULL == DiskQuotaUser::m_hMutex)
    {
        DiskQuotaUser::m_hMutex = CreateMutex(NULL, FALSE, NULL);
        m_ContainerNameCache.SetSize(25);
        m_ContainerNameCache.SetGrow(25);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::~DiskQuotaUser

    Description: Destructor

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUser::~DiskQuotaUser(
    VOID
    )
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUser::~DiskQuotaUser")));
    DBGPRINT((DM_USER, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    Destroy();
    ASSERT( 0 != m_cUsersAlive );
    if (InterlockedDecrement(&m_cUsersAlive) == 0)
    {
        //
        // If active user count is 0, destroy the domain name cache and
        // class-wide mutex.
        //
        DestroyContainerNameCache();

        if (NULL != DiskQuotaUser::m_hMutex)
        {
            CloseHandle(DiskQuotaUser::m_hMutex);
            DiskQuotaUser::m_hMutex = NULL;
        }
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or
        IDiskQuotaUser interface.  Only IID_IUnknown and
        IID_IDiskQuotaUser are recognized.  The object referenced by the
        returned interface pointer is uninitialized.  The recipient of the
        pointer must call Initialize() before the object is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NOERROR         - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::QueryInterface(
    REFIID riid,
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_USER, DL_MID, TEXT("DiskQuotaUser::QueryInterface")));
    DBGPRINTIID(DM_USER, DL_MID, riid);

    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    try
    {
        *ppvOut = NULL;

        if (IID_IUnknown == riid ||
            IID_IDiskQuotaUser == riid)
        {
            *ppvOut = static_cast<IDiskQuotaUser *>(this);
        }
        else if (IID_IDispatch == riid ||
                 IID_DIDiskQuotaUser == riid)
        {
            //
            // Create a disk quota user "dispatch" object to handle all of
            // the automation duties. This object takes a pointer to the real
            // user object so that it can call the real object to do the real
            // work.  The reason we use a special "dispatch" object is so that
            // we can maintain identical names for dispatch and vtable methods
            // that perform the same function.  Otherwise, if the DiskQuotaUser
            // object implements both IDiskQuotaUser and DIDiskQuotaUser methods,
            // we could not have two methods named Invalidate (one for vtable
            // and one for dispatch.
            //
            DiskQuotaUserDisp *pUserDisp = new DiskQuotaUserDisp(static_cast<PDISKQUOTA_USER>(this));
            *ppvOut = static_cast<DIDiskQuotaUser *>(pUserDisp);
        }
        if (NULL != *ppvOut)
        {
            ((LPUNKNOWN)*ppvOut)->AddRef();
            hResult = NOERROR;
        }
    }
    catch(CAllocException& e)
    {
        *ppvOut = NULL;
        hResult = E_OUTOFMEMORY;
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
DiskQuotaUser::AddRef(
    VOID
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUser::AddRef")));
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_USER, DL_LOW, TEXT("\t0x%08X  %d -> %d"), this, cRef - 1, cRef ));    
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
DiskQuotaUser::Release(
    VOID
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUser::Release")));

    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_USER, DL_LOW, TEXT("\t0x%08X  %d -> %d"), this, cRef + 1, cRef ));

    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::Initialize

    Description: Initializes a new DiskQuotaUser object from a quota information
        record read from a volume's quota information file.

    Arguments:
        pfqi [optional] - Pointer to a record of type FILE_QUOTA_INFORMATION.  If
            not NULL, the data from this record is used to initialize the new user
            object.

    Returns:
        NOERROR             - Success.
        E_UNEXPECTED        - SID buffer too small (shouldn't happen).
        ERROR_INVALID_SID (hr) - SID in quota information is invalid.
        ERROR_ACCESS_DENIED (hr) - Need READ access to quota device.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/11/96    Added access control.                                BrianAu
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::Initialize(
    PFILE_QUOTA_INFORMATION pfqi
    )
{
    HRESULT hResult = NOERROR;

    DBGASSERT((NULL != m_pFSObject));

    //
    // Need READ access to create a user object.
    //
    if (m_pFSObject->GrantedAccess(GENERIC_READ))
    {
        if (NULL != pfqi)  // pfqi is optional.
        {
            if (0 < pfqi->SidLength && IsValidSid(&pfqi->Sid))
            {
                //
                // Allocate space for SID structure.
                //
                m_pSid = (PSID) new BYTE[pfqi->SidLength];

                //
                // Copy SID structure to object.
                //
                if (CopySid(pfqi->SidLength, m_pSid, &pfqi->Sid))
                {
                    //
                    // Initialize user's quota data values.
                    // If error copying SID, don't bother with these.
                    //
                    m_llQuotaUsed      = pfqi->QuotaUsed.QuadPart;
                    m_llQuotaThreshold = pfqi->QuotaThreshold.QuadPart;
                    m_llQuotaLimit     = pfqi->QuotaLimit.QuadPart;
                }
                else
                {
                    //
                    // The only reason CopySid can fail is
                    // STATUS_BUFFER_TOO_SMALL.  Since we allocated the buffer
                    // above, this should never fail.
                    //
                    DBGASSERT((FALSE));
                    hResult = E_UNEXPECTED; // Error copying SID.
                }
            }
            else
            {
                DBGERROR((TEXT("DiskQuotaUser::Initialize - Invalid SID or Bad Sid Length (%d)"), pfqi->SidLength));
                hResult = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
            }
        }
    }
    else
        hResult = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::Destroy

    Description: Destroys a user object by deleting its SID buffer and releasing
        its FSObject pointer.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID DiskQuotaUser::Destroy(
    VOID
    )
{
    //
    // Delete the SID buffer.
    //
    delete [] m_pSid;
    m_pSid = NULL;

    //
    // Delete the logon name buffer.
    //
    delete[] m_pszLogonName;
    m_pszLogonName = NULL;

    //
    // Delete the display name buffer.
    //
    delete[] m_pszDisplayName;
    m_pszDisplayName = NULL;

    if (NULL != m_pFSObject)
    {
        //
        // Release hold on File System object.
        //
        m_pFSObject->Release();
        m_pFSObject = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::DestroyContainerNameCache

    Description: Destroys the container name cache.  Should only be called
        when there are not more active user objects.  The container name cache
        is a static member of DiskQuotaUser.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DiskQuotaUser::DestroyContainerNameCache(
    VOID
    )
{
    //
    // Remove all container name strings from the cache.  No need to lock
    // the cache object before clearing it.  It will handle the locking
    // and unlocking.
    //
    m_ContainerNameCache.Clear();
}


//
// Return user object's unique ID.
//
STDMETHODIMP
DiskQuotaUser::GetID(
    ULONG *pulID
    )
{
    *pulID = m_ulUniqueId;
    return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetAccountStatus

    Description: Retrieves the account name resolution status for the
        user object.

    Arguments:
        pdwAccountStatus - Address of variable to recieve status.  The following
            values (see dskquota.h) can be returned in this variable:

            DISKQUOTA_USER_ACCOUNT_RESOLVED
            DISKQUOTA_USER_ACCOUNT_UNAVAILABLE
            DISKQUOTA_USER_ACCOUNT_DELETED
            DISKQUOTA_USER_ACCOUNT_INVALID
            DISKQUOTA_USER_ACCOUNT_UNKNOWN
            DISKQUOTA_USER_ACCOUNT_UNRESOLVED

    Returns:
        NOERROR       - Success.
        E_INVALIDARG  - pdwAccountStatus arg is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetAccountStatus(
    LPDWORD pdwAccountStatus
    )
{
    if (NULL == pdwAccountStatus)
        return E_INVALIDARG;

    *pdwAccountStatus = m_dwAccountStatus;

    return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::SetName

    Description: Sets the account names of the user object.
        It is intended that the SidNameResolver object will call this member
        when it has resolved a user's SID into an account name.  This function
        is not included in IDiskQuotaUser.  Therefore, it is not for public
        consumption.

    Arguments:
        pszContainer - Address of buffer containing container name string.

        pszLogonName - Address of buffer containing user's logon name string.

        pszDisplayName - Address of buffer containing user's display name string.

    Returns:
        NOERROR        - Success.
        E_INVALIDARG   - pszName or pszDomain arg is NULL.
        E_OUTOFMEMORY  - Insufficient memory.
        ERROR_LOCK_FAILED (hr) - Couldn't lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
    09/22/96    Added full name string.                              BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
    05/18/97    Removed access token.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::SetName(
    LPCWSTR pszContainer,
    LPCWSTR pszLogonName,
    LPCWSTR pszDisplayName
    )
{
    HRESULT hResult = NOERROR;

    if (NULL == pszContainer || NULL == pszLogonName || NULL == pszDisplayName)
        return E_INVALIDARG;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        //
        // Delete existing name buffer.
        //
        delete[] m_pszLogonName;
        m_pszLogonName = NULL;
        delete[] m_pszDisplayName;
        m_pszDisplayName = NULL;

        try
        {
            //
            // Save name and full name in user object.
            // Cache container string in container name cache and
            // save cache index in user object.
            //
            INT index     = -1;
            m_pszLogonName   = StringDup(pszLogonName);
            m_pszDisplayName = StringDup(pszDisplayName);
            CacheContainerName(pszContainer, &m_iContainerName);
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetName

    Description: Retrieves the domain and account names from the user object.
        It is intended that the client of the user object will register
        a callback (event sink) with a DiskQuotaControl object.  When the
        resolver has resolved the SID to an account name, the resolver will
        set the user object's name string and the client will be notified.
        The client then calls this method to get the user's name.

    Arguments:
        pszContainerBuffer - Address of destination buffer for container name string.

        cchContainerBuffer - Size of container destination buffer in characters.

        pszLogonNameBuffer - Address of destination buffer for logon name string.

        cchLogonNameBuffer - Size of logon name destination buffer in characters.

        pszDisplayNameBuffer - Address of destination buffer for display name string.

        cchDisplayNameBuffer - Size of display name destination buffer in characters.

    Returns:
        NOERROR                - Success.
        ERROR_LOCK_FAILED (hr) - Failed to lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
    09/22/96    Added full name string.                              BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetName(
    LPWSTR pszContainerBuffer,
    DWORD cchContainerBuffer,
    LPWSTR pszLogonNameBuffer,
    DWORD cchLogonNameBuffer,
    LPWSTR pszDisplayNameBuffer,
    DWORD cchDisplayNameBuffer
    )
{
    HRESULT hResult = NOERROR;
    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        if (NULL != pszContainerBuffer)
        {
            if (-1 != m_iContainerName)
            {
                GetCachedContainerName(m_iContainerName,
                                       pszContainerBuffer,
                                       cchContainerBuffer);
            }
            else
                lstrcpyn(pszContainerBuffer, TEXT(""), cchContainerBuffer);
        }

        if (NULL != pszLogonNameBuffer)
        {
            lstrcpyn(pszLogonNameBuffer,
                     (NULL != m_pszLogonName) ? m_pszLogonName : TEXT(""),
                     cchLogonNameBuffer);
        }

        if (NULL != pszDisplayNameBuffer)
        {
            lstrcpyn(pszDisplayNameBuffer,
                     (NULL != m_pszDisplayName) ? m_pszDisplayName : TEXT(""),
                     cchDisplayNameBuffer);
        }
        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetSidLength

    Description: Retrieves the length of the user's SID in bytes.

    Arguments:
        pcbSid - Address of DWORD to accept SID length value.

    Returns:
        NOERROR                - Success.
        E_INVALIDARG           - pcbSid argument is NULL.
        ERROR_INVALID_SID (hr) - Invalid SID.
        ERROR_LOCK_FAILED (hr) - Couldn't lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetSidLength(
    LPDWORD pcbSid
    )
{
    HRESULT hResult = NOERROR;

    if (NULL == pcbSid)
        return E_INVALIDARG;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        if (NULL != m_pSid && IsValidSid(m_pSid))
        {
            *pcbSid = GetLengthSid(m_pSid);
        }
        else
            hResult = HRESULT_FROM_WIN32(ERROR_INVALID_SID);

        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetSid

    Description: Retrieves the user's SID to a caller-provided buffer.
        The caller should call GetSidLength() to obtain the required buffer
        size before calling GetSid().

    Arguments:
        pSid - Address of destination buffer for SID.  This argument type must
            be PBYTE to work with the MIDL compiler.  Since PSID is really just
            LPVOID and since MIDL doesn't like pointers to void, we have to
            use something other than PSID.

        cbSidBuf - Size of destination buffer in bytes.

    Returns:
        NOERROR                        - Success.
        E_INVALIDARG                   - pSID is NULL.
        ERROR_INVALID_SID (hr)         - User's SID is invalid.
        ERROR_INSUFFICIENT_BUFFER (hr) - Insufficient dest buffer size.
        ERROR_LOCK_FAILED (hr)         - Couldn't lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetSid(
    PBYTE pSid,
    DWORD cbSidBuf
    )
{
    HRESULT hResult = NOERROR;

    if (NULL == pSid)
        return E_INVALIDARG;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        if (NULL != m_pSid && IsValidSid(m_pSid))
        {
            if (!CopySid(cbSidBuf, (PSID)pSid, m_pSid))
            {
                //
                // The only reason CopySid can fail is STATUS_BUFFER_TOO_SMALL.
                // Force status code to INSUFFICIENT_BUFFER.
                //
                DBGERROR((TEXT("ERROR in DiskQuotaUser::GetSid. CopySid() failed.  Result = 0x%08X."),
                          GetLastError()));
                hResult = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
        }
        else
        {
            DBGERROR((TEXT("ERROR in DiskQuotaUser::GetSid. Invalid SID.")));
            hResult = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        }
        DiskQuotaUser::ReleaseLock();
    }

    return hResult;

}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::RefreshCachedInfo

    Description: Refreshes a user object's cached quota information from the
        volume's quota information file.

    Arguments: None.

    Returns:
        NOERROR                  - Success.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        E_FAIL                   - Unexpected NTIOAPI error.

        This function can propagate errors from the NTIOAPI system.  A few
        known ones are mapped to HResults in fsobject.cpp (see HResultFromNtStatus).
        All others are mapped to E_FAIL.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/05/96    Initial creation.                                    BrianAu
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::RefreshCachedInfo(
    VOID
    )
{
    HRESULT hResult   = NOERROR;
    DWORD cbBuffer    = FILE_QUOTA_INFORMATION_MAX_LEN;
    PSIDLIST pSidList = NULL;
    DWORD cbSidList   = 0;
    PSID pSids[]      = { m_pSid, NULL };
    PBYTE pbBuffer    = NULL;

    try
    {
        pbBuffer = new BYTE[cbBuffer];

        //
        // This can throw OutOfMemory.
        //
        hResult = CreateSidList(pSids, 0, &pSidList, &cbSidList);
        if (SUCCEEDED(hResult))
        {
            hResult = m_pFSObject->QueryUserQuotaInformation(
                            pbBuffer,               // Buffer to receive data.
                            cbBuffer,               // Buffer size in bytes.
                            TRUE,                   // Single entry requested.
                            pSidList,               // Sid.
                            cbSidList,              // Length of Sid.
                            NULL,                   // Starting Sid
                            TRUE);                  // Start search at first user.

            if (SUCCEEDED(hResult) || ERROR_NO_MORE_ITEMS == HRESULT_CODE(hResult))
            {
                PFILE_QUOTA_INFORMATION pfqi = (PFILE_QUOTA_INFORMATION)pbBuffer;

                m_llQuotaUsed      = pfqi->QuotaUsed.QuadPart;
                m_llQuotaThreshold = pfqi->QuotaThreshold.QuadPart;
                m_llQuotaLimit     = pfqi->QuotaLimit.QuadPart;
                m_bNeedCacheUpdate = FALSE;

                //
                // Don't return ERROR_NO_MORE_ITEMS to caller.
                // They won't care.
                //
                hResult = NOERROR;
            }
            delete[] pSidList;
        }
        delete[] pbBuffer;
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
        delete[] pbBuffer;
        delete[] pSidList;
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::WriteCachedInfo

    Description: Writes quota information cached in a user object to the
        volume's quota information file.

    Arguments: None.

    Returns:
        NOERROR                  - Success.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        E_FAIL                   - Some other NTIOAPI error.
        E_UNEXPECTED             - CopySid failed.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/31/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::WriteCachedInfo(
    VOID
    )
{
    HRESULT hResult = NOERROR;
    BYTE Buffer[FILE_QUOTA_INFORMATION_MAX_LEN];

    PFILE_QUOTA_INFORMATION pfqi = (PFILE_QUOTA_INFORMATION)Buffer;

    pfqi->NextEntryOffset         = 0;
    pfqi->SidLength               = GetLengthSid(m_pSid);
    pfqi->QuotaUsed.QuadPart      = m_llQuotaUsed;
    pfqi->QuotaLimit.QuadPart     = m_llQuotaLimit;
    pfqi->QuotaThreshold.QuadPart = m_llQuotaThreshold;

    if (CopySid(pfqi->SidLength, &(pfqi->Sid), m_pSid))
        hResult = m_pFSObject->SetUserQuotaInformation(pfqi, sizeof(Buffer));
    else
        hResult = E_UNEXPECTED;

    if (FAILED(hResult))
    {
        //
        // Something failed.
        // Invalidate cached information so next request reads from disk.
        //
        Invalidate();
    }


    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetQuotaInformation

    Description: Retrieves a user's quota limit, threshold and used quota
        values in a single method.  Since the user interface is marshaled
        across thread boundaries, this can be a big performance improvement
        if you want all three values.

    Arguments:
        pbInfo - Address of destination buffer.  Should be sized for structure
            DISKQUOTA_USER_INFORMATION.

        cbInfo - Number of bytes in destination buffer.  Should be
            sizeof(DISKQUOTA_USER_INFORMATION).

    Returns:
        NOERROR                        - Success.
        E_INVALIDARG                   - pbInfo argument is NULL.
        E_OUTOFMEMORY                  - Insufficient memory.
        ERROR_INSUFFICIENT_BUFFER (hr) - Destination buffer is too small.
        ERROR_LOCK_FAILED (hr)         - Couldn't lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/31/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetQuotaInformation(
    LPVOID pbInfo,
    DWORD cbInfo
    )
{
    HRESULT hResult = NOERROR;

    if (NULL == pbInfo)
        return E_INVALIDARG;

    try
    {
        if (cbInfo < sizeof(DISKQUOTA_USER_INFORMATION))
        {
            hResult = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if (!DiskQuotaUser::Lock())
            {
                hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
            }
            else
            {
                //
                // Refresh cached info from disk if needed.
                // Can throw OutOfMemory.
                //
                if (m_bNeedCacheUpdate)
                    hResult = RefreshCachedInfo();

                if (SUCCEEDED(hResult))
                {
                    PDISKQUOTA_USER_INFORMATION pui = (PDISKQUOTA_USER_INFORMATION)pbInfo;

                    pui->QuotaUsed      = m_llQuotaUsed;
                    pui->QuotaThreshold = m_llQuotaThreshold;
                    pui->QuotaLimit     = m_llQuotaLimit;
                }
                DiskQuotaUser::ReleaseLock();
            }
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    return hResult;
}


STDMETHODIMP
DiskQuotaUser::GetQuotaUsedText(
    LPWSTR pszText,
    DWORD cchText
    )
{
    if (NULL == pszText)
        return E_INVALIDARG;

    LONGLONG llValue;
    HRESULT hr = GetQuotaUsed(&llValue);
    if (SUCCEEDED(hr))
    {
        if (NOLIMIT == llValue)
        {
            LoadString(g_hInstDll, IDS_NO_LIMIT, pszText, cchText);
        }
        else
        {
            XBytes::FormatByteCountForDisplay(llValue, pszText, cchText);
        }
    }
    return hr;
}

STDMETHODIMP
DiskQuotaUser::GetQuotaThresholdText(
    LPWSTR pszText,
    DWORD cchText
    )
{
    if (NULL == pszText)
        return E_INVALIDARG;

    LONGLONG llValue;
    HRESULT hr = GetQuotaThreshold(&llValue);
    if (SUCCEEDED(hr))
    {
        if (NOLIMIT == llValue)
        {
            LoadString(g_hInstDll, IDS_NO_LIMIT, pszText, cchText);
        }
        else
        {
            XBytes::FormatByteCountForDisplay(llValue, pszText, cchText);
        }
    }
    return hr;
}


STDMETHODIMP
DiskQuotaUser::GetQuotaLimitText(
    LPWSTR pszText,
    DWORD cchText
    )
{
    if (NULL == pszText)
        return E_INVALIDARG;

    LONGLONG llValue;
    HRESULT hr = GetQuotaLimit(&llValue);
    if (SUCCEEDED(hr))
    {
        if (NOLIMIT == llValue)
        {
            LoadString(g_hInstDll, IDS_NO_LIMIT, pszText, cchText);
        }
        else
        {
            XBytes::FormatByteCountForDisplay(llValue, pszText, cchText);
        }
    }
    return hr;
}


STDMETHODIMP
DiskQuotaUser::SetQuotaThreshold(
    LONGLONG llThreshold,
    BOOL bWriteThrough
    )
{
    if (MARK4DEL > llThreshold)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return SetLargeIntegerQuotaItem(&m_llQuotaThreshold,
                                    llThreshold,
                                    bWriteThrough);
}


STDMETHODIMP
DiskQuotaUser::SetQuotaLimit(
    LONGLONG llLimit,
    BOOL bWriteThrough
    )
{
    if (MARK4DEL > llLimit)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return SetLargeIntegerQuotaItem(&m_llQuotaLimit,
                                    llLimit,
                                    bWriteThrough);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetLargeIntegerQuotaItem

    Description: Retrieves a single quota information item (used, limit,
        threshold) for the user.  If the cached data is invalid, fresh data is
        read in from disk.

    Arguments:
        pllItem - Address of cached member item.

        pllValueOut - Address of LONGLONG to receive item's value.

    Returns:
        NOERROR                - Success.
        E_INVALIDARG           - Either pdwLowPart or pdwHighPart arg was NULL.
        E_OUTOFMEMORY          - Insufficient memory.
        E_UNEXPECTED           - Unexpected exception.
        ERROR_LOCK_FAILED (hr) - Couldn't lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/05/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::GetLargeIntegerQuotaItem(
    PLONGLONG pllItem,
    PLONGLONG pllValueOut
    )
{
    HRESULT hResult = NOERROR;

    DBGASSERT((NULL != pllItem));

    if (NULL == pllItem || NULL == pllValueOut)
        return E_INVALIDARG;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        if (m_bNeedCacheUpdate)
        try
        {
            hResult = RefreshCachedInfo();
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
        if (SUCCEEDED(hResult))
        {
            *pllValueOut = *pllItem;
        }
        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::SetLargeIntegerQuotaItem

    Description: Sets the quota information for a given quota item (limit or
        threshold).  If the bWriteThrough argument is TRUE, the information is
        also written through to the volume's quota file.  Otherwise, it is
        just cached in the user object.

    Arguments:
        pllItem - Address of cached member item.

        llValue - LONGLONG value to assign to member item.

        bWriteThrough - TRUE  = Write data through to disk.
                        FALSE = Only cache data in user object.

    Returns:
        NOERROR                  - Success.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        ERROR_LOCK_FAILED (hr)   - Couldn't lock user object.
        E_FAIL                   - Some other NTIOAPI error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/06/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::SetLargeIntegerQuotaItem(
    PLONGLONG pllItem,
    LONGLONG llValue,
    BOOL bWriteThrough)
{
    DBGASSERT((NULL != pllItem));
    HRESULT hResult = NOERROR;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        *pllItem = llValue;
        if (bWriteThrough)
            hResult = WriteCachedInfo();

        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::CacheContainerName

    Description: Class DiskQuotaUser maintains a static member that is
        a cache of account container names.   It is likely that there will be
        few distinct container names in use on a volume.  Therefore, there's
        no need to store a container name for each user object.  We cache the
        names and store only an index into the cache in each user object.

        This method adds a name to the cache and returns the index of the
        name in the cache.  If the name already exists in the cache,
        it is not added.

    Arguments:
        pszContainer - Address of container name string to add to cache.

        pCacheIndex [optional] - Address of integer variable to receive the
            cache index of the container name string.  May be NULL.

    Returns:
        S_OK        - Success.
        S_FALSE     - Name already in cache.
        E_FAIL      - No cache object.

    Exceptions: OutOfMemory.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/05/09    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::CacheContainerName(
    LPCTSTR pszContainer,
    INT *pCacheIndex
    )
{
    DBGASSERT((NULL != pszContainer));

    HRESULT hResult  = S_OK;
    INT iCacheIndex  = -1;
    UINT cItems      = 0;

    m_ContainerNameCache.Lock();

    cItems = m_ContainerNameCache.Count();

    for (UINT i = 0; i < cItems; i++)
    {
        //
        // See if the name is already in the cache.
        //
        if (0 == m_ContainerNameCache[i].Compare(pszContainer))
        {
            iCacheIndex = i;
            hResult     = S_FALSE; // Already cached.
            break;
        }
    }

    if (S_OK == hResult)
    {
        //
        // Not in the cache. Add it.
        //
        try
        {
            m_ContainerNameCache.Append(CString(pszContainer));
            iCacheIndex = m_ContainerNameCache.UpperBound();
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
    }
    m_ContainerNameCache.ReleaseLock();

    if (NULL != pCacheIndex)
        *pCacheIndex = iCacheIndex;

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetCachedContainerName

    Description: Retrieves an account container name string from the
        container name cache.

    Arguments:
        iCacheIndex - User's index in domain name cache.

        pszContainer - Destination buffer to receive container name string.

        cchContainer - Number of characters in destination buffer.

    Returns:
        NOERROR      - Success.
        E_UNEXPECTED - No name at index iCacheIndex.  Returns "" as name.
        E_FAIL       - No domain name cache object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/05/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::GetCachedContainerName(
    INT iCacheIndex,
    LPTSTR pszContainer,
    UINT cchContainer
    )
{
    DBGASSERT((NULL != pszContainer));
    DBGASSERT((-1 != iCacheIndex));

    HRESULT hResult  = NOERROR;

    m_ContainerNameCache.Lock();

    DBGASSERT((iCacheIndex < m_ContainerNameCache.Count()));

    lstrcpyn(pszContainer, m_ContainerNameCache[iCacheIndex], cchContainer);

    m_ContainerNameCache.ReleaseLock();

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::Lock

    Description: Call this to obtain an exclusive lock to the user object.
        In actuality, there is only one lock for all user objects so you're
        really getting an exclusive lock to all users.  Since there can be
        a high number of users, it was decided to use a single class-wide
        lock instead of a unique lock for each user object.

    Arguments: None.

    Returns:
        TRUE    = Obtained exclusive lock.
        FALSE   = Couldn't get a lock.  Either mutex hasn't been created or
                  the mutex wait timeout expired, or the wait operation failed.
                  Either way, we couldn't get the lock.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DiskQuotaUser::Lock(
    VOID
    )
{
    BOOL bResult = FALSE;

    if (NULL != DiskQuotaUser::m_hMutex)
    {
        DWORD dwWaitResult = WaitForSingleObject(DiskQuotaUser::m_hMutex,
                                                 DiskQuotaUser::m_dwMutexWaitTimeout);
        bResult = (WAIT_OBJECT_0 == dwWaitResult);
    }
    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::ReleaseLock

    Description: Call this to release a lock obtained with DiskQuotaUser::Lock.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DiskQuotaUser::ReleaseLock(
    VOID
    )
{
    if (NULL != DiskQuotaUser::m_hMutex)
    {
        ReleaseMutex(DiskQuotaUser::m_hMutex);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::SetAccountStatus

    Description: Stores the status of the user's account in the user object.
                 User accounts may be "unresolved", "unavailable", "resolved",
                 "deleted", "invalid" or "unknown".
                 These states correspond to the values obtained
                 through LookupAccountSid.

    Arguments:
        dwStatus - DISKQUOTA_USER_ACCOUNT_UNRESOLVED
                   DISKQUOTA_USER_ACCOUNT_UNAVAILABLE
                   DISKQUOTA_USER_ACCOUNT_RESOLVED
                   DISKQUOTA_USER_ACCOUNT_DELETED
                   DISKQUOTA_USER_ACCOUNT_UNKNOWN
                   DISKQUOTA_USER_ACCOUNT_INVALID

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DiskQuotaUser::SetAccountStatus(
    DWORD dwStatus
    )
{
    DBGASSERT((DISKQUOTA_USER_ACCOUNT_UNRESOLVED  == dwStatus ||
           DISKQUOTA_USER_ACCOUNT_UNAVAILABLE == dwStatus ||
           DISKQUOTA_USER_ACCOUNT_RESOLVED    == dwStatus ||
           DISKQUOTA_USER_ACCOUNT_DELETED     == dwStatus ||
           DISKQUOTA_USER_ACCOUNT_INVALID     == dwStatus ||
           DISKQUOTA_USER_ACCOUNT_UNKNOWN     == dwStatus));

    m_dwAccountStatus = dwStatus;
}



//
// The following functions implement the DiskQuotaUser "dispatch" object that
// is created to handle OLE automation duties for the DiskQuotaUser object.
// The functions are all fairly basic and require little explanation.
// Therefore, I'll spare you the function headers.  In most cases,
// the property and method functions call directly through to their
// corresponding functions in class DiskQuotaUser.
//
DiskQuotaUserDisp::DiskQuotaUserDisp(
    PDISKQUOTA_USER pUser
    ) : m_cRef(0),
        m_pUser(pUser)
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUserDisp::DiskQuotaUserDisp")));
    DBGPRINT((DM_USER, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    if (NULL != m_pUser)
    {
        m_pUser->AddRef();
    }
    m_Dispatch.Initialize(static_cast<IDispatch *>(this),
                          LIBID_DiskQuotaTypeLibrary,
                          IID_DIDiskQuotaUser,
                          L"DSKQUOTA.DLL");
}

DiskQuotaUserDisp::~DiskQuotaUserDisp(
    VOID
    )
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUserDisp::~DiskQuotaUserDisp")));
    DBGPRINT((DM_USER, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    if (NULL != m_pUser)
    {
        m_pUser->Release();
    }
}


STDMETHODIMP
DiskQuotaUserDisp::QueryInterface(
    REFIID riid,
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_USER, DL_MID, TEXT("DiskQuotaUserDisp::QueryInterface")));
    DBGPRINTIID(DM_USER, DL_MID, riid);

    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid)
    {
        *ppvOut = this;
    }
    else if (IID_IDispatch == riid)
    {
        *ppvOut = static_cast<IDispatch *>(this);
    }
    else if (IID_DIDiskQuotaUser == riid)
    {
        *ppvOut = static_cast<DIDiskQuotaUser *>(this);
    }
    else if (IID_IDiskQuotaUser == riid)
    {
        //
        // Return the quota user's vtable interface.
        // This allows code to "typecast" (COM-style) between
        // the dispatch interface and vtable interface.
        //
        return m_pUser->QueryInterface(riid, ppvOut);
    }

    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}

STDMETHODIMP_(ULONG)
DiskQuotaUserDisp::AddRef(
    VOID
    )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserDisp::AddRef, 0x%08X  %d -> %d"), this, cRef - 1, cRef ));
    return cRef;
}


STDMETHODIMP_(ULONG)
DiskQuotaUserDisp::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserDisp::Release, 0x%08X  %d -> %d"),
             this, cRef + 1, cRef));

    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}



//
// IDispatch::GetIDsOfNames
//
STDMETHODIMP
DiskQuotaUserDisp::GetIDsOfNames(
    REFIID riid,
    OLECHAR **rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID *rgDispId
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUserDisp::GetIDsOfNames")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetIDsOfNames(riid,
                                    rgszNames,
                                    cNames,
                                    lcid,
                                    rgDispId);
}


//
// IDispatch::GetTypeInfo
//
STDMETHODIMP
DiskQuotaUserDisp::GetTypeInfo(
    UINT iTInfo,
    LCID lcid,
    ITypeInfo **ppTypeInfo
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUserDisp::GetTypeInfo")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetTypeInfo(iTInfo, lcid, ppTypeInfo);
}


//
// IDispatch::GetTypeInfoCount
//
STDMETHODIMP
DiskQuotaUserDisp::GetTypeInfoCount(
    UINT *pctinfo
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUserDisp::GetTypeInfoCount")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetTypeInfoCount(pctinfo);
}


//
// IDispatch::Invoke
//
STDMETHODIMP
DiskQuotaUserDisp::Invoke(
    DISPID dispIdMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pVarResult,
    EXCEPINFO *pExcepInfo,
    UINT *puArgErr
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUserDisp::Invoke")));
    DBGPRINT((DM_USER, DL_LOW, TEXT("DispId = %d"), dispIdMember));
    DBGPRINTIID(DM_USER, DL_LOW, riid);
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.Invoke(dispIdMember,
                             riid,
                             lcid,
                             wFlags,
                             pDispParams,
                             pVarResult,
                             pExcepInfo,
                             puArgErr);
}


//
// Return user object's unique ID.
//
STDMETHODIMP
DiskQuotaUserDisp::get_ID(
    long *pID
    )
{
    return m_pUser->GetID((ULONG *)pID);
}


STDMETHODIMP
DiskQuotaUserDisp::get_AccountContainerName(
    BSTR *pContainerName
    )
{
    TCHAR szName[MAX_DOMAIN] = { TEXT('\0') };
    HRESULT hr = m_pUser->GetName(szName, ARRAYSIZE(szName),
                                  NULL,   0,
                                  NULL,   0);
    if (SUCCEEDED(hr))
    {
        *pContainerName = SysAllocString(szName);
        if (NULL == *pContainerName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_LogonName(
    BSTR *pLogonName
    )
{
    TCHAR szName[MAX_USERNAME] = { TEXT('\0') };
    HRESULT hr = m_pUser->GetName(NULL,   0,
                                  szName, ARRAYSIZE(szName),
                                  NULL,   0);
    if (SUCCEEDED(hr))
    {
        *pLogonName = SysAllocString(szName);
        if (NULL == *pLogonName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_DisplayName(
    BSTR *pDisplayName
    )
{
    TCHAR szName[MAX_FULL_USERNAME] = { TEXT('\0') };
    HRESULT hr = m_pUser->GetName(NULL,   0,
                                  NULL,   0,
                                  szName, ARRAYSIZE(szName));

    if (SUCCEEDED(hr))
    {
        *pDisplayName = SysAllocString(szName);
        if (NULL == *pDisplayName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaThreshold(
    double *pThreshold
    )
{
    LONGLONG llValue;
    HRESULT hr = m_pUser->GetQuotaThreshold(&llValue);
    if (SUCCEEDED(hr))
        *pThreshold = (double)llValue;

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::put_QuotaThreshold(
    double Threshold
    )
{
    if (MAXLONGLONG < Threshold)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return m_pUser->SetQuotaThreshold((LONGLONG)Threshold, TRUE);
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaThresholdText(
    BSTR *pThresholdText
    )
{
    TCHAR szValue[40];
    HRESULT hr = m_pUser->GetQuotaThresholdText(szValue, ARRAYSIZE(szValue));
    if (SUCCEEDED(hr))
    {
        *pThresholdText = SysAllocString(szValue);
        if (NULL == *pThresholdText)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaLimit(
    double *pQuotaLimit
    )
{
    LONGLONG llValue;
    HRESULT hr = m_pUser->GetQuotaLimit(&llValue);

    if (SUCCEEDED(hr))
        *pQuotaLimit = (double)llValue;

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::put_QuotaLimit(
    double Limit
    )
{
    if (MAXLONGLONG < Limit)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return m_pUser->SetQuotaLimit((LONGLONG)Limit, TRUE);
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaLimitText(
    BSTR *pLimitText
    )
{
    TCHAR szValue[40];
    HRESULT hr = m_pUser->GetQuotaLimitText(szValue, ARRAYSIZE(szValue));
    if (SUCCEEDED(hr))
    {
        *pLimitText = SysAllocString(szValue);
        if (NULL == *pLimitText)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaUsed(
    double *pUsed
    )
{
    LONGLONG llValue;
    HRESULT hr = m_pUser->GetQuotaUsed(&llValue);
    if (SUCCEEDED(hr))
        *pUsed = (double)llValue;

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaUsedText(
    BSTR *pUsedText
    )
{
    TCHAR szValue[40];
    HRESULT hr = m_pUser->GetQuotaUsedText(szValue, ARRAYSIZE(szValue));
    if (SUCCEEDED(hr))
    {
        *pUsedText = SysAllocString(szValue);
        if (NULL == *pUsedText)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

STDMETHODIMP
DiskQuotaUserDisp::get_AccountStatus(
    AccountStatusConstants *pStatus
    )
{
    DWORD dwStatus;
    HRESULT hr = m_pUser->GetAccountStatus(&dwStatus);
    if (SUCCEEDED(hr))
    {
        *pStatus = (AccountStatusConstants)dwStatus;
    }
    return hr;
}


//
// Methods.
//
STDMETHODIMP
DiskQuotaUserDisp::Invalidate(
    void
    )
{
    return m_pUser->Invalidate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\userbat.h ===
#ifndef _INC_DSKQUOTA_USERBAT_H
#define _INC_DSKQUOTA_USERBAT_H
///////////////////////////////////////////////////////////////////////////////
/*  File: userbat.h

    Description: Provides declaration for class DiskQuotaUserBatch.
        This class is provided to allow batch updates of quota user information.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/07/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_FSOBJECT_H
#   include "fsobject.h"
#endif
#ifndef _INC_DSKQUOTA_EXCEPT_H
#   include "except.h"
#endif

class DiskQuotaUserBatch : public IDiskQuotaUserBatch
{
    private:
        LONG              m_cRef;            // Ref counter.
        FSObject         *m_pFSObject;       // Ptr to file sys object.
        CArray<PDISKQUOTA_USER> m_UserList;  // List of users to batch process.
        
        HRESULT
        RemoveUser(
            PDISKQUOTA_USER pUser);

        STDMETHODIMP
        RemoveAllUsers(VOID);

        VOID
        Destroy(
            VOID);

        //
        // Prevent copying.
        //
        DiskQuotaUserBatch(const DiskQuotaUserBatch& );
        DiskQuotaUserBatch& operator = (const DiskQuotaUserBatch& );

    public:
//
// APPCOMPAT: Find out why compiler doesn't like this exception decl.
//
//        DiskQuotaUserBatch(FSObject *pFSObject) throw(OutOfMemory, SyncObjErrorCreate);
        DiskQuotaUserBatch(FSObject *pFSObject);
        ~DiskQuotaUserBatch(VOID);

        //
        // IUnknown interface.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IDiskQuotaUserBatch interface.
        //
        STDMETHODIMP
        Add(
            PDISKQUOTA_USER);

        STDMETHODIMP
        Remove(
            PDISKQUOTA_USER);

        STDMETHODIMP
        RemoveAll(
            VOID);

        STDMETHODIMP
        FlushToDisk(
            VOID);
};

#endif // _INC_DSKQUOTA_USERBAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\sidname.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: sidname.cpp

    Description: Implements the SID-to-NAME resolver.  It is anticipated that
        resolving a user's SID to it's corresponding name can be a lengthy
        process.  We don't want the quota controller's client to experience
        slow user enumerations just because it takes a long time to resolve
        a name.  Therefore, this object was created to perform the 
        SID-to-name resolutions on a background thread and notify the
        client whenever a name has been resolved.  That way, the client
        can display a list of users then fill in the names as names
        are resolved.  


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/12/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "control.h"
#include "guidsp.h"    // Private GUIDs.
#include "registry.h"
#include "sidname.h"
#include "sidcache.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


//
// SID/Name resolver messages (SNRM_XXXXXXXX).
//
#define SNRM_CLEAR_INPUT_QUEUE   (WM_USER + 1)
#define SNRM_EXIT_THREAD         (WM_USER + 2)

///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::SidNameResolver

    Description: SidNameResolver constructor.

    Arguments:
        rQuotaController - Reference to quota controller that this resolver is
            working for.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/12/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameResolver::SidNameResolver(
    DiskQuotaControl& rQuotaController)
    : m_cRef(0),
      m_rQuotaController(rQuotaController),
      m_hsemQueueNotEmpty(NULL),
      m_hMutex(NULL),
      m_dwResolverThreadId(0),
      m_hResolverThread(NULL),
      m_heventResolverThreadReady(NULL)
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::SidNameResolver")));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::~SidNameResolver

    Description: SidNameResolver destructor.

    Arguments: None.

    Returns: Nothing.
 
    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/12/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameResolver::~SidNameResolver(void)
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::~SidNameResolver")));

    if (NULL != m_hsemQueueNotEmpty)
    {
        CloseHandle(m_hsemQueueNotEmpty);
    }
    if (NULL != m_hMutex)
    {
        CloseHandle(m_hMutex);
    }
    if (NULL != m_hResolverThread)
    {
        CloseHandle(m_hResolverThread);
    }
    if (NULL != m_heventResolverThreadReady)
    {
        CloseHandle(m_heventResolverThreadReady);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or
        ISidNameResolver interface.  
        Only IID_IUnknown, IID_ISidNameResolver are recognized.  
        The object referenced by the returned interface pointer is uninitialized.  
        The recipient of the pointer must call Initialize() before the object 
        is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/07/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
SidNameResolver::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::QueryInterface")));
    DBGPRINTIID(DM_RESOLVER, DL_MID, riid);

    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_ISidNameResolver == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
SidNameResolver::AddRef(
    VOID
    )
{
    DBGTRACE((DM_RESOLVER, DL_LOW, TEXT("SidNameResolver::AddRef")));
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_RESOLVER, DL_LOW, TEXT("\t0x%08X %d -> %d"), this, cRef - 1, cRef ));    
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
SidNameResolver::Release(
    VOID
    )
{
    DBGTRACE((DM_RESOLVER, DL_LOW, TEXT("SidNameResolver::Release")));

    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_RESOLVER, DL_LOW, TEXT("\t0x%08X %d -> %d"), this, cRef + 1, cRef ));

    if ( 0 == cRef )
    {   
        delete this;
    }
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::Initialize

    Description: Initializes a SidNameResolver object.
        This function performs lot's of initialization steps so I chose to 
        use the "jump to label on failure" approach.  It avoids a lot of
        deeply nested "ifs".

    Arguments: None.

    Returns:
        NO_ERROR        - Success.
        E_FAIL          - Initialization failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    08/14/96    Moved SID/Name cache initialization to               BrianAu
                FindCachedUserName() method.  Only initialize cache
                when it is truly needed.
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
SidNameResolver::Initialize(
    VOID
    ) 
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::Initialize")));
    HRESULT hResult  = NO_ERROR;
    DWORD dwThreadId = 0;

    //
    // Configure the user queue so it grows in chunks of 100.
    //
    m_UserQueue.SetSize(100);
    m_UserQueue.SetGrow(100);

    //
    // IMPORTANT:  There is code in the QuotaControl object that
    //             counts on the thread being created LAST in this function.
    //             See DiskQuotaControl::CreateEnumUsers.  
    //             Thread creation must be the last thing performed in this
    //             function.  The caller assumes that if this function returns
    //             E_FAIL, no thread was created.
    //
    m_hMutex = CreateMutex(NULL, FALSE, NULL);
    if (NULL == m_hMutex)
        goto InitFailed;

    m_hsemQueueNotEmpty = CreateSemaphore(NULL,        // Default security.
                                          0,           // Initially empty queue.
                                          0x7FFFFFFF,  // Max count (a lot).
                                          NULL);       // No name.
    if (NULL == m_hsemQueueNotEmpty)
        goto InitFailed;

    m_heventResolverThreadReady = CreateEvent(NULL,   // Default security.
                                              TRUE,   // Manual reset.
                                              FALSE,  // Initially non-signaled.
                                              NULL);  // No name.
    if (NULL == m_heventResolverThreadReady)
        goto InitFailed;


    hResult = CreateResolverThread(&m_hResolverThread, &m_dwResolverThreadId);
    DBGPRINT((DM_RESOLVER, DL_MID, TEXT("Resolver thread. hThread = 0x%08X, idThread = %d"),
             m_hResolverThread, m_dwResolverThreadId));

    if (FAILED(hResult))
        goto InitFailed;
InitFailed:

    //
    // Failure only returns E_FAIL.
    //
    if (FAILED(hResult))
        hResult = E_FAIL;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::Shutdown

    Description: Commands the resolver to terminate its activities.
        When the resolver's client is through with the resolver's services,
        it should call Shutdown() followed by IUnknown::Release().  The function
        sends a WM_QUIT message to the resolver thread.

    Arguments: None.

    Returns:
        NO_ERROR    - Success
        E_FAIL      - Failed to send WM_QUIT message.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/29/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
SidNameResolver::Shutdown(
    BOOL bWait
    )
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::Shutdown")));
    DBGPRINT((DM_RESOLVER, DL_HIGH, TEXT("\tThread ID = %d"), m_dwResolverThreadId));

    BOOL bResult = FALSE;
    if (0 != m_dwResolverThreadId)
    {
        bResult = PostThreadMessage(m_dwResolverThreadId, WM_QUIT, 0, 0);
        if (bResult && bWait && NULL != m_hResolverThread)
        {
            //
            // Wait for thread to terminate normally.
            //
            DBGPRINT((DM_RESOLVER, DL_HIGH, TEXT("Resolver waiting for thread to exit...")));
            WaitForSingleObject(m_hResolverThread, INFINITE);
        }
    }

    return bResult ? NO_ERROR : E_FAIL;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::GetUserSid

    Description: Private method that allocates a SID buffer and retrieves
        the user's SID into that buffer.  The caller must free the returned
        buffer when done with it.

    Arguments:
        pUser - Pointer to user's IDiskQuotaUser interface.

        ppSid - Address of a PSID variable to receive the address of the
            allocated SID buffer.

    Returns:
        NO_ERROR        - Success.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
SidNameResolver::GetUserSid(
    PDISKQUOTA_USER pUser, 
    PSID *ppSid
    )
{
    HRESULT hResult   = NO_ERROR;
    DWORD cbSid = 0;

    DBGASSERT((NULL != pUser));
    hResult = pUser->GetSidLength(&cbSid);
    if (SUCCEEDED(hResult))
    {
        PSID pUserSid = NULL;

        pUserSid = (PSID) new BYTE[cbSid];

        hResult = pUser->GetSid((PBYTE)pUserSid, cbSid);
        if (SUCCEEDED(hResult))
        {
            DBGASSERT((IsValidSid(pUserSid)));
            DBGASSERT((NULL != ppSid));
            *ppSid = pUserSid; // Return address of buffer to caller.
                               // Caller must free it when done.
        }
        else
        {
            DBGERROR((TEXT("RESOLVER - GetSid failed.")));
            delete[] pUserSid; // Failed to get SID.  Free buffer.
        }
    }
    else
    {
        DBGERROR((TEXT("RESOLVER - GetUserSid failed.")));
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::AddUserToResolverQueue

    Description: Adds a user pointer to the resolver's input queue.

    Arguments:
        pUser - Address of IDiskQuotaUser ptr.

    Returns:
        NO_ERROR        - Success.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
    12/10/96    Removed interface marshaling. Using free-threading   BrianAu
                model.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameResolver::AddUserToResolverQueue(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::AddUserToResolverQueue")));
    DBGASSERT((NULL != pUser));
    HRESULT hResult = NO_ERROR;

    //
    // Add user object pointer to resolver input queue.
    // This can throw OutOfMemory.
    //
    pUser->AddRef();
    try
    {
        m_UserQueue.Add(pUser);
    }
    catch(CAllocException& e)
    {
        pUser->Release();
        hResult = E_OUTOFMEMORY;
    }

    //
    // Increment queue's semaphore count.
    // Means there's something in queue to process.
    //
    ReleaseSemaphore(m_hsemQueueNotEmpty, 1, NULL);

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::RemoveUserFromResolverQueue

    Description: Removes a user pointer from the resolver's input queue.

    Arguments:
        ppUser - Address of pointer variable to receive IDiskQuotaUser ptr.

    Returns:
        NO_ERROR     - Success.
        E_UNEXPECTED - Resolver queue was empty.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
    12/10/96    Removed interface marshaling. Using free-threading   BrianAu
                model.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameResolver::RemoveUserFromResolverQueue(
    PDISKQUOTA_USER *ppUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::RemoveUserFromResolverQueue")));
    DBGASSERT((NULL != ppUser));
    HRESULT hResult = E_UNEXPECTED;

    *ppUser = NULL;

    if (!m_UserQueue.IsEmpty() && 
        m_UserQueue.Remove(*ppUser))
    {
        hResult = NO_ERROR;
    }
    else
    {
        DBGERROR((TEXT("RESOLVER - Input queue unexpectedly empty.")));
    }


    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::PromoteUserToQueueHead

    Description: Promotes a user object to the head of the resolver queue
                 if the user object is in the queue.  This can be used to
                 give specific user objects higher priority if desired.
                 In particular, the initial requirement behind this feature
                 is so that user objects highlighted in the details list view
                 get higher name-resolution priority so that the user 
                 (app user) feels the UI is responsive to their inputs.

    Arguments:
        pUser - Address of IDiskQuotaUser interface for user object.

    Returns:
        NO_ERROR      - Success.
        S_FALSE       - User record not in queue.
        E_OUTOFMEMORY - Insufficient memory adding item.
        E_UNEXPECTED  - Exception caught.  User record not promoted.
        E_INVALIDARG  - pUser argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
SidNameResolver::PromoteUserToQueueHead(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::PromoteUserToQueueHead")));
    HRESULT hResult = S_FALSE;

    if (NULL == pUser)
        return E_INVALIDARG;

    m_UserQueue.Lock();
    try
    {
        //
        // Find the user in the resolver's queue.
        //
        INT iUser = m_UserQueue.Find(pUser);
        if (-1 != iUser)
        {
            //
            // Note we don't mess with the ref count of the
            // user object.  We're merely deleting a user and re
            // inserting it into the queue.  The queue's original
            // AddRef() is retained.
            //
            m_UserQueue.Delete(iUser);
            m_UserQueue.Add(pUser);
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    m_UserQueue.ReleaseLock();

    return hResult;            
}

 

///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::ResolveSidToName

    Description: Finds the name corresponding to a user's SID.
        Once the name is found, it is sent to the user object for storage.

    Arguments:
        pUser - Pointer to user objects's IDiskQuotaUser interface.

    Returns:
        NO_ERROR        - Success.
        E_FAIL          - Couldn't resolve SID to a name.
        ERROR_NONE_MAPPED (hr) - No SID-to-Name mapping available.
            No need to try again.


    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    08/09/96    Set hResult to E_FAIL when LookupAccountSid fails.   BrianAu
    09/05/96    Added user domain name string.                       BrianAu
    05/18/97    Changed to report deleted SIDs.                      BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameResolver::ResolveSidToName(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::ResolveSidToName")));
    HRESULT hResult     = NO_ERROR;
    array_autoptr<BYTE> ptrUserSid;

    DBGASSERT((NULL != pUser));
    
    hResult = GetUserSid(pUser, (PSID *)(ptrUserSid.getaddr()));
    if (SUCCEEDED(hResult))
    {
        SID_NAME_USE SidNameUse = SidTypeUnknown;
        CString strContainer;
        CString strLogonName;
        CString strDisplayName;

        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - Calling LookupAccountBySid.")));

        hResult = m_rQuotaController.m_NTDS.LookupAccountBySid(
                                                         NULL,
                                                         (PSID)(ptrUserSid.get()),
                                                         &strContainer,
                                                         &strLogonName,
                                                         &strDisplayName,
                                                         &SidNameUse);
        if (SUCCEEDED(hResult))
        {                                         
            switch(SidNameUse)
            {
                case SidTypeDeletedAccount:
                    static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_DELETED);
                    break;

                case SidTypeInvalid:
                    static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_INVALID);
                    break;

                case SidTypeUnknown:
                    static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_UNKNOWN);
                    break;

                default:
                {
                    //
                    // Valid account.
                    //
                    SidNameCache *pSidCache;
                    HRESULT hr = SidNameCache_Get(&pSidCache);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Add SID/Name pair to cache.  
                        // Indicate failure only with a debug msg.  If cache
                        // addition fails, we'll still work OK, just slower.
                        // This can throw OutOfMemory.
                        //
                        hr = pSidCache->Add((PSID)(ptrUserSid.get()), 
                                             strContainer, 
                                             strLogonName, 
                                             strDisplayName);
                        if (FAILED(hr))
                        {
                            DBGERROR((TEXT("SIDNAME - Addition of %s\\%s failed."), strLogonName.Cstr()));
                        }
                    }

                    //
                    // Set the user object's account name strings.
                    //
                    hResult = static_cast<DiskQuotaUser *>(pUser)->SetName(
                                                                        strContainer,
                                                                        strLogonName, 
                                                                        strDisplayName);
                    if (SUCCEEDED(hResult))
                    {
                        static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_RESOLVED);
                    }
                    else
                    {
                        DBGERROR((TEXT("SIDNAME - SetName failed in ResolveSidToName. hResult = 0x%08X"),
                                 hResult));
                    }

                    break;
                }
            }
        }
        else
        {
            //
            // Failed asynch name resolution.
            //
            static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_UNAVAILABLE);
            if (ERROR_NONE_MAPPED == GetLastError())
                hResult = HRESULT_FROM_WIN32(ERROR_NONE_MAPPED);
            else
                hResult = E_FAIL; 
        }
    }
    else
    {
        DBGERROR((TEXT("SIDNAME - GetUserSid failed in ResolveSidToName, hResult = 0x%08X"),
                 hResult));
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::FindCachedUserName

    Description: Accepts a user object's IDiskQuotaUser interface pointer and
        looks for it's SID/Name pair in the SID/Name cache.  If found, the 
        name is set in the user object and the function returns NO_ERROR.

    Arguments:
        pUser - Pointer to user objects's IDiskQuotaUser interface.

    Returns:
        NO_ERROR             - Success.  User's SID found in cache.
        ERROR_FILE_NOT_FOUND (hr) - User's SID not in cache.

    Exceptions: OutOfMemory

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/27/96    Initial creation.                                    BrianAu
    08/14/96    Moved initialization of SID/Name cache from          BrianAu
                SidNameResolver::Initialize().
    09/05/96    Added user domain name string.                       BrianAu
    09/21/96    New cache design.                                    BrianAu
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in 
                reponse to making the quota UI DS-aware.  The 
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
SidNameResolver::FindCachedUserName(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::FindCachedUserName")));
    HRESULT hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND); // Assume not found.

    PSID pUserSid = NULL;

    hResult = GetUserSid(pUser, &pUserSid);
    if (SUCCEEDED(hResult))
    {
        LPTSTR pszContainer   = NULL;
        LPTSTR pszLogonName   = NULL;
        LPTSTR pszDisplayName = NULL;

        try
        {
            //
            // Can throw OutOfMemory.
            //
            SidNameCache *pSidCache;
            hResult = SidNameCache_Get(&pSidCache);
            if (SUCCEEDED(hResult))
            {
                //
                // Check cache for SID/Name pair.
                // This can throw OutOfMemory.
                //
                DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - Query cache for user 0x%08X."), pUser));
                hResult = pSidCache->Lookup(pUserSid, 
                                            &pszContainer,
                                            &pszLogonName,
                                            &pszDisplayName);

                if (SUCCEEDED(hResult))
                {
                    //
                    // Name was cached.  Set it in the user object and return NO_ERROR.
                    //
                    hResult = static_cast<DiskQuotaUser *>(pUser)->SetName(
                                                                        pszContainer, 
                                                                        pszLogonName, 
                                                                        pszDisplayName);
                    if (SUCCEEDED(hResult))
                    {
                        static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_RESOLVED);
                    }
                }
            }
            else
            {
                //
                // Set the return value so the caller knows to resolve
                // the user name.
                //
                hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                DBGERROR((TEXT("RESOLVER - SID/Name cache not available.")));
            }
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }

        delete[] pszContainer;
        delete[] pszLogonName;
        delete[] pszDisplayName;
        delete[] pUserSid;  
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::FindUserName

    Description: Accepts a user object's IDiskQuotaUser interface pointer and
        looks for it's SID/Name pair in the SID/Name cache.  If the information
        is not cached, the function calls ResolveSidToName to synchronously
        determine the SID's account name.  The function blocks until the name
        is retrieved.

    Arguments:
        pUser - Pointer to user objects's IDiskQuotaUser interface.

    Returns:
        NO_ERROR             - Success.
        E_FAIL               - Couldn't resolve SID to name.
        ERROR_NONE_MAPPED (hr) - No SID-to-Name mapping found.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/27/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
SidNameResolver::FindUserName(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::FindUserName")));
    HRESULT hResult = NO_ERROR;
    
    DBGASSERT((NULL != pUser));
    hResult = FindCachedUserName(pUser); // Can throw OutOfMemory.
    if (ERROR_FILE_NOT_FOUND == HRESULT_CODE(hResult))
    {
        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - User 0x%08X not cached.  Resolving..."),
                 pUser));
        hResult = ResolveSidToName(pUser); // Can throw OutOfMemory.
    }
    else
    {
        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - User 0x%08X found in cache."), pUser));
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::FindUserNameAsync

    Description: Accepts a user object's IDiskQuotaUser interface pointer and
        looks for it's SID/Name pair in the SID/Name cache.  If the information
        is not cached, the user object is submitted to the resolver for 
        background processing and asynchronous client notification when the 
        operation is complete.

    Arguments:
        pUser - Pointer to user objects's IDiskQuotaUser interface.

    Returns:
        NO_ERROR        - Success.
        E_FAIL          - Resolver thread not active.  Can't resolve Async.
        S_FALSE         - User name not in cache.  Submitted for background
                          processing.  Client will be notified when name is
                          found and set in user object.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    06/25/96    Added SID/Name caching.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
SidNameResolver::FindUserNameAsync(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::FindUserNameAsync")));
    HRESULT hResult = NO_ERROR;
    
    DBGASSERT((NULL != pUser));

    hResult = FindCachedUserName(pUser);

    if (ERROR_FILE_NOT_FOUND == HRESULT_CODE(hResult))
    {
        if (0 != m_dwResolverThreadId)
        {
            DBGPRINT((DM_RESOLVER, DL_MID, 
                     TEXT("RESOLVER - User 0x%08X not cached.  Submitting to Resolver."),
                     pUser));

            //
            // Name was not cached.  Add the user object to the resolver's input queue
            // so that the name can be located by the resolver's background thread.
            //
            hResult = AddUserToResolverQueue(pUser);
        }
        else
        {
            DBGERROR((TEXT("RESOLVER - Thread not active.  Can't resolve user 0x%08X async."),
                     pUser));
            hResult = E_FAIL;
        }
    }
    else
    {
        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - User 0x%08X found in cache."),
                 pUser));
    }

    return hResult;
}

    

///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::ClearInputQueue.

    Description: Called by a SidNameResolver thread after the thread receives
        a WM_QUIT message.  This function removes all user object pointers
        from the input queue before the thread exists.

    Arguments: None.

    Returns:
        NO_ERROR    - Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
    12/10/96    Moved Semaphore reduction from method                BrianAu
                HandleShutdownMessages then deleted that method.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
SidNameResolver::ClearInputQueue(
    void
    )
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::ClearInputQueue")));
    PDISKQUOTA_USER pUser = NULL;

    //
    // Decrement the queue-not-empty semaphore to 0 so that the thread
    // doesn't try to remove any more queue entries.
    // Set the resolver's thread ID to 0 so that FindNameAsync will not
    // submit any more users to the resolver.
    //
    m_dwResolverThreadId = 0;
    while(WAIT_OBJECT_0 == WaitForSingleObject(m_hsemQueueNotEmpty, 0))
        NULL;
    //
    // Remove all remaining items from input queue
    // Remove will return E_FAIL if list is empty.
    //
    m_UserQueue.Lock();
    while(m_UserQueue.Count() > 0)
    {
        HRESULT hResult = RemoveUserFromResolverQueue(&pUser);
        if (SUCCEEDED(hResult) && NULL != pUser)
        {
            pUser->Release(); // Release user object.
        }
    }
    m_UserQueue.ReleaseLock();

    return NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::ThreadOnQueueNotEmpty

    Description: Called by a SidNameResolver thread when the resolver's input
        queue is not empty.  This function removes the next entry
        from the queue, resolves the user's SID to its name, sets the name
        in the user object and notifies the client of the name change.

    Arguments: None.

    Returns:
        NO_ERROR    - Always returns NO_ERROR.

    Exceptions: OutOfMemory

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
SidNameResolver::ThreadOnQueueNotEmpty(
    void
    )
{
    DBGTRACE((DM_RESOLVER, DL_LOW, TEXT("SidNameResolver::ThreadOnQueueNotEmpty")));
    HRESULT hResult       = NO_ERROR;
    PDISKQUOTA_USER pUser = NULL;
    LPSTREAM pstm         = NULL;

    //
    // Remove item from queue
    // RemoveFirst() will return E_FAIL if list is empty.
    //
    try
    {
        hResult = RemoveUserFromResolverQueue(&pUser);
        if (SUCCEEDED(hResult) && NULL != pUser)
        {
            ResolveSidToName(pUser);

            //
            // If successful or not, notify client event sink.
            // Even if we couldn't resolve the name, the object's account
            // status has changed.  The client will want to respond to this.
            // 
            // Don't bother with return value.  We don't care if it fails.
            // The client will but we don't.
            //
            m_rQuotaController.NotifyUserNameChanged(pUser);
            pUser->Release(); // Release pointer obtained from resolver queue.
        }
        else
        {
            DBGERROR((TEXT("RESOLVER - Error removing stream ptr from input queue.")));
        }
    }
    catch(CAllocException& e)
    {
        if (NULL != pUser)
            pUser->Release();

        hResult = E_OUTOFMEMORY;
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::ThreadProc

    Description: This thread procedure sits in a loop handling events and
        thread messages.

        Conditions that cause the thread to exit.

        1. OleInitalize() fails.
        2. Thread receives a WM_QUIT message.
        3. Wait function failure or timeout.

    Arguments:
        pvParam - "this" pointer for the SidNameResolver object.
            Required since ThreadProc must be static to be a THREADPROC.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    03/22/00    Changed dwParam for ia64 compat.                     BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD 
SidNameResolver::ThreadProc(
    LPVOID pvParam
    )
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::ThreadProc")));
    DBGPRINT((DM_RESOLVER, DL_HIGH, TEXT("\tThreadID = %d"), GetCurrentThreadId()));
    SidNameResolver *pThis = (SidNameResolver *)pvParam;
    BOOL bExitThread       = FALSE;

    //
    // Make sure DLL stays loaded while this thread is active.
    //
    InterlockedIncrement(&g_cRefThisDll);

    //
    // Must call CoInitializeEx() for each thread.
    //
    if (SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        BOOL bReadyToReceiveMsgs = FALSE;

        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER: Thread %d entering msg loop."), GetCurrentThreadId()));
        while(!bExitThread)
        {
            MSG msg;
            try
            {
                //
                // Allow blocked thread to respond to sent messages.
                //
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) && !bExitThread)
                {
                    if ( WM_QUIT != msg.message )
                    {
                        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER: Thread %d dispatching msg %d"),
                                 GetCurrentThreadId(), msg.message));
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                    else
                    {
                        //
                        // Rcvd WM_QUIT.  Clear the resolver's input queue and
                        // exit the msg loop.
                        //
                        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER: Thread %d received WM_QUIT"),
                                 GetCurrentThreadId()));
                        pThis->ClearInputQueue();
                        bExitThread = TRUE;
                    }
                }

                if (!bExitThread)
                {
                    DWORD dwWaitResult = 0;

                    if (!bReadyToReceiveMsgs)
                    {
                        //
                        // Tell the thread creation function that it can
                        // now return.  The thread is ready to accept messages.
                        //
                        SetEvent(pThis->m_heventResolverThreadReady);
                        bReadyToReceiveMsgs = TRUE;
                    }

                    //
                    // Sleep if the queue is empty.
                    // Wake up on queue-not-empty or any thread messages.
                    //
                    DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - Thread %d waiting for messages..."),
                              GetCurrentThreadId()));
                    dwWaitResult = MsgWaitForMultipleObjects(
                                           1,
                                           &(pThis->m_hsemQueueNotEmpty),
                                           FALSE,
                                           INFINITE,
                                           QS_ALLINPUT);

                    switch(dwWaitResult)
                    {
                        case WAIT_OBJECT_0:
                            //
                            // Have data in input queue. Process one user.
                            //
                            DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - Something added to input queue.")));
                            pThis->ThreadOnQueueNotEmpty();
                            break;

                        case WAIT_OBJECT_0 + 1:
                            //
                            // Received input message(s).
                            // Loop back around and handle them.
                            //
                            DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER -  Thread %d rcvd message(s)."),
                                     GetCurrentThreadId()));
                            break;

                        case WAIT_FAILED:
                        case WAIT_TIMEOUT:
                        default:
                            //
                            // Something bad happened.
                            //
                            DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - Thread %d wait failed."),
                                     GetCurrentThreadId()));

                            DBGASSERT((FALSE));
                            bExitThread = TRUE;
                            break;
                    }
                }
            }
            catch(CAllocException& e)
            {
                DBGERROR((TEXT("RESOLVER - Out of memory")));
                bExitThread = TRUE;
            }
        }
        CoUninitialize();
    }
    else
    {
        DBGERROR((TEXT("RESOLVER - OleInitialize failed for thread %d."),
                 GetCurrentThreadId()));
    }

    DBGPRINT((DM_RESOLVER, DL_HIGH, TEXT("RESOLVER - Exit thread %d"), GetCurrentThreadId()));

    pThis->m_dwResolverThreadId = 0;

    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::CreateResolverThread

    Description: Creates a thread that will process user objects and resolve
        their SIDs to account names.  

    Arguments:
        phThread [optional] - Address of handle variable to receive handle of 
            new thread.  Can be NULL.

        pdwThreadId [optional] - Address of DWORD to receive thread ID.
            Can be NULL.

    Returns:
        NO_ERROR    - Started thread.
        E_FAIL      - Couldn't start thread.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/27/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameResolver::CreateResolverThread(
    PHANDLE phThread,
    LPDWORD pdwThreadId
    )
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::CreateResolverThread")));
    HRESULT hResult  = NO_ERROR;
    DWORD dwThreadId = 0;
    HANDLE hThread   = NULL;

    //
    // Launch new thread.
    //
    hThread = CreateThread(NULL,        // No security attributes.
                           0,           // Default stack size.
                           &ThreadProc,
                           this,        // Static thread proc needs this.
                           0,           // Not suspended.
                           &dwThreadId);
    if (NULL != hThread)
    {
        if (NULL != phThread)
            *phThread = hThread;  // Caller want's handle value.
        else
            CloseHandle(hThread); // Caller doesn't want it.

        if (NULL != pdwThreadId)
            *pdwThreadId = dwThreadId; // Caller want's thread ID.

        //
        // Wait here until the thread is ready to receive thread messages.
        // This event is set in ThreadProc.
        //
        WaitForSingleObject(m_heventResolverThreadReady, INFINITE);
    }
    else
    {
        hResult = E_FAIL;
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\sidcache.h ===
#ifndef _INC_DSKQUOTA_SIDCACHE_H
#define _INC_DSKQUOTA_SIDCACHE_H
///////////////////////////////////////////////////////////////////////////////
/*  File: sidcache.h

    Description: Header for classes associated with the SID/Name cache.


   Here's a ER-style diagram of the SID cache.  The cache consists
   of a data file and index file.  The index is a hash table consisting
   of an array of hash buckets, each containing 0 or more hash bucket entries.
   Each hash bucket entry contains the index of it's corresponding user record
   in the data file.  The index hash code is based on the user SID.

   The index is designed for fast lookup of queue entries.  Hash values are
   calculated by simply summing the value of the bytes in a SID and
   performing modulo division with the number of hash buckets.  Each hash
   bucket contains a doubly-linked list to handle hash value collisions
   and removal of expired entries. Each hash bucket entry contains the index
   of the starting block for the user's record in the data file.


                         +-----------+      +--------+<---> User SID
                     +-->| data file |<--->>| record |<---> User Domain
                     |   +-----------+      +--------+<---> User Name
                     |                            ^   <---> User Full User Name
    +-----------+<---+                            |
    |  cache    |                                 |
    +-----------+<---+                            +--- points to ----+
                     |                                               |
                     |                                               |
                     |   +----------+      +-------------+     +--------------+
                     +-->| ndx file |<--->>| hash bucket |<-->>| bucket entry |
                         +----------+      +-------------+     +--------------+

    <--->  = One-to-one
    <-->>  = One-to-many


   Notes:
     1. Because SID->Name resolution over the network is very slow
        (0-10 seconds), I anticipate that this cache will be used heavily
        and may contain 100's or 1000's of entries depending upon the
        volume's usage.

    Index file structure ------------------------------------------------------

        +------------------------+
        |      Header            | <--- Type INDEX_FILE_HDR
        +------------------------+
        |                        |
        |                        | <--- Array of DWORDs.  Count should be prime.
        |    Hash bucket array   |      Each element represents a hash bucket.
        |                        |      Unused elements contain NULL.
        |                        |      Used elements contain address of first
        |                        |      entry in hash bucket's entry list.
        +------------------------+
        |                        |
        |                        |
        |                        | <--- Array of INDEX_ENTRY.
        |      Index entries     |      Each entry is a node in a linked list.
        |                        |      Initially, all are on the "free list".
        |                        |      As entries are allocated, they are
        |                        |      transfered to the appropriate hash bucket's
        |                        |      list.  Each used entry contains the
        |                        |      starting block number of the corresponding
        |                        |      record in the data file.
        +------------------------+

    Data file structure -------------------------------------------------------

        +------------------------+
        |      Header            | <--- Type DATA_FILE_HDR
        +------------------------+
        |                        |
        |    Block alloc map     | <--- Array of DWORDs.  Each bit represents the
        |                        |      allocation state of a record block.
        |                        |      0 = free, 1 = allocated.
        +------------------------+
        |                        |
        |                        |
        |                        | <--- Array of BLOCKs. (32-bytes each)
        |    Record blocks       |      Each data record consists of one or more
        |                        |      blocks.  The first block in each record
        |                        |      is of type RECORD_HDR.  The remaining
        |                        |      blocks contain the variable-length SID,
        |                        |      Domain name, User name and Full User
        |                        |      name.  Blocks are aligned on quadword
        |                        |      boundaries for the FILETIME structure
        |                        |      in RECORD_HDR.  The 3 name string fields
        |                        |      are UNICODE and are WORD-aligned.
        |                        |      Unused blocks are filled with 0xCC.
        |                        |      A BLOCK is the smallest allocation unit.
        +------------------------+


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/12/96    Initial creation.                                    BrianAu
    08/14/96    Added SidCacheQueueIterator.                         BrianAu
    09/05/96    Added domain name string.                            BrianAu
    09/20/96    Total redesign.  Old design loaded data from file    BrianAu
                into an in-memory hash table.  New design leaves
                everything on disk and merely maps the file into
                memory.  Much more efficient with respect to
                speed and size.
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in
                reponse to making the quota UI DS-aware.  The
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
const DWORD BITS_IN_BYTE         = 8;
const DWORD BITS_IN_DWORD        = BITS_IN_BYTE * sizeof(DWORD);


//
// On-disk structure of a single index entry.
// There's an entry for each record in the cache.
// Length = 16 bytes.
//
typedef struct index_entry
{
    index_entry *pPrev;
    index_entry *pNext;
    DWORD        iBlock;
    DWORD        iBucket;

} INDEX_ENTRY, *PINDEX_ENTRY;

//
// On-disk structure of index file header.
// Length = 48 bytes
// Must be even multiple of 8 bytes (quadword-align).
//
typedef struct index_file_hdr
{
    DWORD dwSignature;       // ID's file as a quota cache index.
    DWORD dwVersion;         // SW version that created file.
    GUID  guid;              // Verifies validity of data.
    DWORD cBuckets;          // Number of hash buckets.
    DWORD cMaxEntries;       // Max number of entries.
    DWORD cEntries;          // Number of used entries.
    PINDEX_ENTRY *pBuckets;  // Address of first hash bucket.
    PINDEX_ENTRY pEntries;   // Offset to first entry.
    PINDEX_ENTRY pFirstFree; // Offset to first entry in free list.

} INDEX_FILE_HDR, *PINDEX_FILE_HDR;

//
// Define what a data file "block" is.
// Keep the block size a power of 2.
//
const DWORD BLOCK_SIZE = 32;    // Size is in bytes.

typedef BYTE BLOCK[BLOCK_SIZE];
typedef BLOCK *PBLOCK;

//
// On-disk structure of data file header.
// Length = 48 bytes.
//
typedef struct data_file_hdr
{
    DWORD dwSignature;  // ID's file as quota cache data.
    DWORD dwVersion;    // SW version that created file.
    GUID  guid;         // Verifies validity of data.
    DWORD cBlocks;      // Total number of allocation blocks.
    DWORD cBlocksUsed;  // Number of used allocation blocks.
    DWORD cMapElements; // Number of alloc map elements.
    DWORD iFirstFree;   // Index of first free block.
    LPDWORD pdwMap;     // Address of alloc map.
    PBLOCK pBlocks;     // Address of block pool.

} DATA_FILE_HDR, *PDATA_FILE_HDR;

//
// On-disk structure of the header info for each record.
// This fixed length structure precedes the variable-length part.
// Quad-word aligned.
// Length = 32 bytes (1 block).
// Strings are UNICODE, WORD-aligned.
//
typedef struct record_hdr
{
    DWORD dwSignature;       // Rec hdr signature. (0xAAAA5555)
    DWORD cBlocks;           // Blks in record.
    FILETIME Birthday;       // When was record added to cache?
    DWORD cbOfsSid;          // Ofs from start of record.
    DWORD cbOfsContainer;    // Ofs from start of record.
    DWORD cbOfsLogonName;    // Ofs from start of record.
    DWORD cbOfsDisplayName;  // Ofs from start of record.

} RECORD_HDR, *PRECORD_HDR;


class SidNameCache
{
    private:
        //
        // Private class encapsulating the functions of the cache index.
        //
        class IndexMgr
        {
            private:

                SidNameCache&    m_refCache;     // Ref to outer cache object.
                PINDEX_FILE_HDR  m_pFileHdr;     // Same as g_pbMappedIndexFile.
                HANDLE           m_hFile;        // Handle to index file.
                HANDLE           m_hFileMapping; // Mapped file.
                CString          m_strFileName;  // Full path\name of index file.


                LPBYTE CreateIndexFile(LPCTSTR pszFile,
                                       DWORD cbFileHigh,
                                       DWORD cbFileLow);

                LPBYTE OpenIndexFile(LPCTSTR pszFile);

                LPBYTE GrowIndexFile(DWORD cGrowEntries);

                VOID CloseIndexFile(VOID);

                VOID InitNewIndexFile(DWORD cBuckets, DWORD cMaxEntries);

                PINDEX_ENTRY AllocEntry(VOID);

                VOID FreeEntry(PINDEX_ENTRY pEntry);
                VOID AddEntryToFreeList(PINDEX_ENTRY pEntry);
                PINDEX_ENTRY DetachEntry(PINDEX_ENTRY pEntry);

                PINDEX_ENTRY Find(PSID pSid);
                PINDEX_ENTRY Find(PSID pSid, DWORD dwHashCode);
                PINDEX_ENTRY Find(LPCTSTR pszLogonName);

                DWORD Hash(PSID pSid);

                PINDEX_ENTRY GetHashBucketValue(DWORD iBucket);
                VOID SetHashBucketValue(DWORD iBucket, PINDEX_ENTRY pEntry);

                //
                // Prevent copy.
                //
                IndexMgr(const IndexMgr& rhs);
                IndexMgr& operator = (const IndexMgr& rhs);


            public:
                IndexMgr(SidNameCache& refCache);
                ~IndexMgr(VOID);

                LPBYTE Initialize(LPCTSTR pszFile,
                                  DWORD cBuckets = 0,
                                  DWORD cMaxEntries = 0);

                DWORD Lookup(PSID pSid);
                DWORD Lookup(LPCTSTR pszLogonName);

                PINDEX_ENTRY Add(PSID pSid, DWORD iBlock);

                static UINT64 FileSize(DWORD cMaxEntries, DWORD cBuckets)
                    {
                        return (UINT64)(sizeof(INDEX_FILE_HDR)) +
                               (UINT64)(sizeof(PINDEX_ENTRY) * cBuckets) +
                               (UINT64)(sizeof(INDEX_ENTRY) * cMaxEntries);
                    }

                VOID SetFileGUID(const GUID *pguid);
                VOID GetFileGUID(LPGUID pguid);
                VOID FreeEntry(PSID pSid);
                VOID Clear(VOID);
#ifdef DBG
                VOID Dump(VOID);
#endif
        };

        //
        // Private class that manages the cache's stored data records.
        //
        class RecordMgr
        {
            private:
                SidNameCache&   m_refCache;          // Ref to outer cache object.
                PDATA_FILE_HDR  m_pFileHdr;          // Same as g_pbMappedDataFile
                HANDLE          m_hFile;             // Handle to data file.
                HANDLE          m_hFileMapping;      // Mapped data file.
                DWORD           m_cDaysRecLifeMin;   // Min and range are used to
                DWORD           m_cDaysRecLifeRange; // calc lifetime of records.
                CString         m_strFileName;       // Full path\name of data file.

                BOOL ValidBlockNumber(DWORD iBlock);
                VOID FillBlocks(DWORD iBlock, DWORD cBlocks, BYTE b);
                BOOL IsBitSet(LPDWORD pdwBase, DWORD iBit);
                VOID SetBit(LPDWORD pdwBase, DWORD iBit);
                VOID ClrBit(LPDWORD pdwBase, DWORD iBit);
                BOOL IsBlockUsed(DWORD iBlock);
                VOID MarkBlockUsed(DWORD iBlock);
                VOID MarkBlockUnused(DWORD iBlock);
                DWORD BlocksRequired(DWORD cb);
                DWORD BytesRequiredForRecord(
                    PSID pSid,
                    LPDWORD pcbSid,
                    LPCTSTR pszContainer,
                    LPDWORD pcbContainer,
                    LPCTSTR pszLogonName,
                    LPDWORD pcbLogonName,
                    LPCTSTR pszDisplayName,
                    LPDWORD pcbDisplayName);

                VOID FreeBlock(DWORD iBlock);
                VOID FreeBlocks(DWORD iFirstBlock, DWORD cBlocks);
                BLOCK *BlockAddress(DWORD iBlock);
                DWORD AllocBlocks(DWORD cbRecord);
                LPBYTE CreateDataFile(LPCTSTR pszFile, DWORD cbFileHigh, DWORD cbFileLow);
                LPBYTE OpenDataFile(LPCTSTR pszFile);
                LPBYTE GrowDataFile(DWORD cGrowBlocks);
                VOID InitNewDataFile(DWORD cBlocks);
                VOID CloseDataFile(VOID);

                //
                // Prevent copy.
                //
                RecordMgr(const RecordMgr& rhs);
                RecordMgr& operator = (const RecordMgr& rhs);


            public:

                RecordMgr(SidNameCache& refCache);
                ~RecordMgr(VOID);

                LPBYTE Initialize(
                    LPCTSTR pszFile,
                    DWORD cBlocks = 0);

                static UINT64 FileSize(DWORD cBlocks);

                DWORD Store(
                    PSID pSid,
                    LPCTSTR pszContainer,
                    LPCTSTR pszLogonName,
                    LPCTSTR pszDisplayName);

                BOOL RecordExpired(DWORD iBlock);

                HRESULT Retrieve(
                    DWORD iBlock,
                    PSID *ppSid,
                    LPTSTR *ppszContainer,
                    LPTSTR *ppszLogonName,
                    LPTSTR *ppszDisplayName);

                VOID SetFileGUID(const GUID *pguid);
                VOID GetFileGUID(LPGUID pguid);
                VOID FreeRecord(DWORD iFirstBlock);
                VOID Clear(VOID);
#ifdef DBG
                VOID Dump(VOID);
#endif
        };

        //
        // Private class for handling locks on cache files that must
        // be automatically released when an exception is thrown.
        //
        class CacheAutoLock
        {
            public:
                explicit CacheAutoLock(SidNameCache& Cache)
                    : m_Cache(Cache) { };

                BOOL Lock(VOID)
                    { return m_Cache.Lock(); }

                ~CacheAutoLock(VOID)
                    {m_Cache.ReleaseLock(); }

            private:
                SidNameCache& m_Cache;
                //
                // Prevent copy.
                //
                CacheAutoLock(const CacheAutoLock& rhs);
                CacheAutoLock& operator = (const CacheAutoLock& rhs);
        };

        friend class CacheAutoLock;

        HANDLE        m_hMutex;        // For locking during updates.
        IndexMgr     *m_pIndexMgr;     // Manages index file.
        RecordMgr    *m_pRecordMgr;    // Manages data file.
        CString       m_strFilePath;   // Path to cache files.

        BOOL Lock(VOID);
        VOID ReleaseLock(VOID);
        BOOL FilesAreValid(VOID);
        VOID ValidateFiles(VOID);
        VOID InvalidateFiles(VOID);
        VOID SetCacheFilePath(VOID);
        BOOL CreateCacheFileDirectory(LPCTSTR pszPath);

        //
        // Private ctor prevents creation outside of singleton access
        // function.
        //
        SidNameCache(VOID);
        //
        // The singleton instance access function.
        //
        friend HRESULT SidNameCache_GetOrDestroy(SidNameCache **ppCache, bool bGet);

    public:
        ~SidNameCache(VOID);

        HRESULT Initialize(
            BOOL bOpenExisting);

        HRESULT Lookup(
            PSID pSid,
            LPTSTR *ppszContainer,
            LPTSTR *ppszLogonName,
            LPTSTR *ppszDisplayName);

        HRESULT Lookup(
            LPCTSTR pszLogonName,
            PSID *ppSid);

        HRESULT Add(
            PSID pSid,
            LPCTSTR pszContainer,
            LPCTSTR pszLogonName,
            LPCTSTR pszDisplayName);

//        HRESULT CheckConsistency(VOID);

        BOOL Clear(VOID);

        HRESULT BeginTransaction(VOID);
        VOID EndTransaction(VOID);

        static LPBYTE OpenMappedFile(
                        LPCTSTR pszDataFile,
                        LPCTSTR pszMapping,
                        DWORD dwCreation,
                        DWORD cbFileHigh,
                        DWORD cbFileLow,
                        PHANDLE phFile,
                        PHANDLE phFileMapping);

        static BOOL IsQuadAligned(LPVOID pv);
        static BOOL IsQuadAligned(DWORD_PTR dw);
        static VOID QuadAlign(LPDWORD lpdwValue);
        static VOID WordAlign(LPDWORD lpdwValue);

#if DBG
        VOID Dump(VOID)
            { m_pIndexMgr->Dump(); m_pRecordMgr->Dump(); }
#endif

        friend class IndexMgr;
        friend class RecordMgr;
};


HRESULT SidNameCache_Get(SidNameCache **ppCache);
HRESULT SidNameCache_Destroy(void);


#endif // _INC_DSKQUOTA_SIDCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\userbat.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: userbat.cpp

    Description: Contains member function definitions for class 
        DiskQuotaUserBatch.
        The DiskQuotaUserBatch object represents a batch update mechanism for
        rapid update of multiple-user-object quota information.  This class
        takes advantage of the batching capabilities built into the NTIOAPI.
        A user batch object is obtained through 
        IDiskQuotaControl::CreateUserBatch().

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "userbat.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif

//
// The NTFS quota write function can only handle a max of 64K of data
// in any one write operation.  IssacHe recommended 60K as a comfortable
// limit.
//
const INT MAX_BATCH_BUFFER_BYTES = (1 << 10) * 60;

///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::DiskQuotaUserBatch

    Description: Constructor.

    Arguments: 
        pFSObject - Address of File System object to be utilized by the
            batching operations.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/03/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUserBatch::DiskQuotaUserBatch(
    FSObject *pFSObject
    ) : m_cRef(0),
        m_pFSObject(pFSObject)
{      
    DBGASSERT((NULL != m_pFSObject));

    m_pFSObject->AddRef();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::~DiskQuotaUserBatch

    Description: Destructor.

    Arguments: Destroys the batch object.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/26/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUserBatch::~DiskQuotaUserBatch(
    VOID
    )
{
    Destroy();
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or 
        IDiskQuotaUserBatch interface.  Only IID_IUnknown and 
        IID_IDiskQuotaUserBatch are recognized.  The object referenced by the 
        returned interface pointer is uninitialized.  The recipient of the 
        pointer must call Initialize() before the object is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NOERROR         - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUserBatch::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IDiskQuotaUserBatch == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserBatch::AddRef(
    VOID
    )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserBatch::AddRef, 0x%08X  %d -> %d\n"), this, cRef - 1, cRef ));
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserBatch::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserBatch::Release, 0x%08X  %d -> %d\n"),
             this, cRef + 1, cRef));

    if ( 0 == cRef)
    {   
        delete this;
    }
    return cRef;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::Destroy

    Description: Destroys the contents of a user batch object and releases
        its FSObject pointer.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DiskQuotaUserBatch::Destroy(VOID)
{
    //
    // Remove and release all user object pointers from the batch list.
    //
    RemoveAll();

    if (NULL != m_pFSObject)
    {
        //
        // Release hold on File System object.
        //
        m_pFSObject->Release();
        m_pFSObject = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::Add

    Description: Adds an IDiskQuotaUser interface pointer to the batch list.

    Arguments:
        pUser - Address of IDiskQuotaUser interface.

    Returns:
        NOERROR         - Success.
        E_INVALIDARG    - pUser arg is NULL. 
        E_OUTOFMEMORY   - Couldn't create new node in batch list.
        E_UNEXPECTED    - Unexpected exception.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
    09/03/96    Add exception handling.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUserBatch::Add(
    PDISKQUOTA_USER pUser
    )
{
    HRESULT hResult = NOERROR;
        
    if (NULL == pUser)
        return E_INVALIDARG;

    try
    {
        m_UserList.Append(pUser);
        //
        // Success.  Increment ref count on object.
        //
        pUser->AddRef();
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::Remove

    Description: Removes a user pointer from the batch queue.  

    Arguments:
        pUser - Address of IDiskQuotaUser interface for the user object to
            be removed.

    Returns:
        S_OK         - Success.
        S_FALSE      - User not found in batch object.
        E_INVALIDARG - pUser argument is NULL.
        E_UNEXPECTED - Unexpected exception.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
    09/03/96    Add exception handling.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUserBatch::Remove(
    PDISKQUOTA_USER pUser
    )
{
    HRESULT hResult = S_FALSE;  // Assume user not present.
    PDISKQUOTA_USER pRemoved = NULL;

    if (NULL == pUser)
        return E_INVALIDARG;

    m_UserList.Lock();
    INT iUser = m_UserList.Find(pUser);
    if (-1 != iUser)
    {
        try
        {
            DBGASSERT((NULL != m_UserList[iUser]));
            m_UserList[iUser]->Release();
            m_UserList.Delete(iUser);
            hResult = S_OK;
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
    }
    m_UserList.ReleaseLock();

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::RemoveAll

    Description: Removes all user pointers from the batch
        list and calling Release() through the removed pointer.  

    Arguments: None.

    Returns:
        NOERROR      - Success.
        E_UNEXPECTED - Unexpected exception.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
    09/03/96    Add exception handling.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUserBatch::RemoveAll(
    VOID
    )
{
    HRESULT hResult = NOERROR;

    m_UserList.Lock();
    INT cUsers = m_UserList.Count();
    for (INT i = 0; i < cUsers; i++)
    {
        try
        {
            DBGASSERT((NULL != m_UserList[i]));
            m_UserList[i]->Release();
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
    }
    m_UserList.Clear();
    m_UserList.ReleaseLock();

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::FlushToDisk

    Description: Writes data for all batched user objects to disk in a single
        NTIOAPI call.  This is the real worker function for the batch object.

    Arguments: None.

    Returns:
        NOERROR       - Success.
        E_OUTOFMEMORY - Insufficient memory.
        E_UNEXPECTED  - Unexpected exception.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
    09/03/96    Add exception handling.                              BrianAu
    02/27/97    Divided NTFS writes into max 60KB pieces.            BrianAu
                The quota code in NTFS couldn't handle larger
                buffers.  It got into an infinite loop condition
                due to filling of the log.
    07/01/97    Replaced use of PointerList with CArray<>.           BrianAu
                Now use indexes instead of iterators.
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUserBatch::FlushToDisk(
    VOID
    )
{
    HRESULT hResult                   = NOERROR;
    PFILE_QUOTA_INFORMATION pUserInfo = NULL;
    PDISKQUOTA_USER pUser             = NULL;
    PBYTE pbBatchBuffer               = NULL;
    DWORD cbMinimumSid = FIELD_OFFSET(SID, SubAuthority) + sizeof(LONG);
    INT iOuter = 0;

    //
    // Do nothing if the batch object is empty.
    //
    if (0 == m_UserList.Count())
        return NOERROR;

    m_UserList.Lock();

    try
    {
        //
        // Process the data in 60K chunks using a nested loop.
        //
        while(iOuter < m_UserList.UpperBound())
        {
            //
            // Clone the outer iterator so we can process the next 60K of data.
            // Need two new iterators.  One for counting the bytes and
            // one for transferring data to the write buffer.  They're very small
            // objects and cheap to create.
            //
            INT iCount    = iOuter;
            INT iTransfer = iOuter;

            DWORD cbBatchBuffer = 0;
            DWORD cItemsThisBatch = 0;

            while(cbBatchBuffer < MAX_BATCH_BUFFER_BYTES &&
                  iCount <= m_UserList.UpperBound())

            {
                DWORD cbSid = 0;
                pUser = m_UserList[iCount++];
                pUser->GetSidLength(&cbSid);

                //
                // Total size required for user records.
                //
                cbBatchBuffer += FIELD_OFFSET(FILE_QUOTA_INFORMATION, Sid) + cbSid;

                //
                // Ensure it's quad-word aligned.
                //
                if (cbBatchBuffer & 0x00000007)
                    cbBatchBuffer = (cbBatchBuffer & 0xFFFFFFF8) + 8;

                cItemsThisBatch++;
            }

            //
            // Allocate the buffer.
            //
            pbBatchBuffer = new BYTE[cbBatchBuffer];

            PBYTE pbBatchBufferItem = pbBatchBuffer;
            DWORD cbNextEntryOffset = 0;
            //
            // Now fill in the batch transaction buffer with data from 
            // all of the users in the batch list.
            //
            while(0 != cItemsThisBatch-- &&
                  iTransfer <= m_UserList.UpperBound())
            {
                pUser = m_UserList[iTransfer++];
                pUserInfo = (PFILE_QUOTA_INFORMATION)pbBatchBufferItem;

                pUser->GetSidLength(&pUserInfo->SidLength);

                cbNextEntryOffset = FIELD_OFFSET(FILE_QUOTA_INFORMATION, Sid) + pUserInfo->SidLength;
                //
                // Ensure quad-word alignment.
                //
                if (cbNextEntryOffset & 0x00000007)
                    cbNextEntryOffset = (cbNextEntryOffset & 0xFFFFFFF8) + 8;

                pUserInfo->NextEntryOffset = cbNextEntryOffset;

                pUser->GetQuotaThreshold(&pUserInfo->QuotaThreshold.QuadPart);
                pUser->GetQuotaLimit(&pUserInfo->QuotaLimit.QuadPart);
                pUser->GetSid((PBYTE)&pUserInfo->Sid, pUserInfo->SidLength);

                //
                // These two don't get set but let's provide a known value anyway.
                //
                pUserInfo->ChangeTime.QuadPart = 0;
                pUserInfo->QuotaUsed.QuadPart  = 0;

                pbBatchBufferItem += cbNextEntryOffset;
            }
            pUserInfo->NextEntryOffset = 0;  // Last entry needs a 0 here.
            //
            // Submit the batch to the NTIOAPI for update.
            //
            hResult = m_pFSObject->SetUserQuotaInformation(pbBatchBuffer, cbBatchBuffer);

            //
            // Delete the data buffer.
            //
            delete[] pbBatchBuffer;
            pbBatchBuffer = NULL;

            //
            // Advance the outer iterator to where the transfer iterator left off.
            //
            iOuter = iTransfer;
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    if (FAILED(hResult))
    {
        //
        // Something failed.  Invalid data cached in user objects.
        // Next request for user data will have to read from disk.
        //
        iOuter = 0;

        while(iOuter <= m_UserList.UpperBound())
        {
            pUser = m_UserList[iOuter++];
            pUser->Invalidate();
        }
    }

    m_UserList.ReleaseLock();

    delete[] pbBatchBuffer;

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\sidname.h ===
#ifndef _INC_DSKQUOTA_SIDNAME_H
#define _INC_DSKQUOTA_SIDNAME_H
///////////////////////////////////////////////////////////////////////////////
/*  File: sidname.h

    Description: Declarations for SID/Name resolver.  See sidname.cpp for
        details of operation.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/12/96    Initial creation.                                    BrianAu
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in 
                reponse to making the quota UI DS-aware.  The 
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_SIDCACHE_H
#   include "sidcache.h"
#endif
#ifndef _INC_DSKQUOTA_USER_H
#   include "user.h"
#endif

//
// This is a PRIVATE interface.  That's why it's here and not in dskquota.h
//
#undef  INTERFACE
#define INTERFACE ISidNameResolver

DECLARE_INTERFACE_(ISidNameResolver, IUnknown)
{
    //
    // ISidNameResolver methods.
    //
    STDMETHOD(Initialize)(THIS) PURE;
    STDMETHOD(FindUserName)(THIS_ PDISKQUOTA_USER) PURE;
    STDMETHOD(FindUserNameAsync)(THIS_ PDISKQUOTA_USER) PURE;
    STDMETHOD(Shutdown)(THIS_ BOOL) PURE;
    STDMETHOD(PromoteUserToQueueHead)(THIS_ PDISKQUOTA_USER) PURE;
};

typedef ISidNameResolver SID_NAME_RESOLVER, *PSID_NAME_RESOLVER;



class DiskQuotaControl;  // Fwd reference.

class SidNameResolver : public ISidNameResolver
{
    private:
        LONG                      m_cRef;
        DiskQuotaControl&         m_rQuotaController;
        HANDLE                    m_hsemQueueNotEmpty;
        HANDLE                    m_hMutex;
        HANDLE                    m_hResolverThread;
        HANDLE                    m_heventResolverThreadReady;
        DWORD                     m_dwResolverThreadId;
        CQueueAsArray<PDISKQUOTA_USER> m_UserQueue;

        //
        // Prevent copying.
        //
        SidNameResolver(const SidNameResolver& );
        operator = (const SidNameResolver& );

        HRESULT
        ResolveSidToName(PDISKQUOTA_USER pUser);

        static DWORD ThreadProc(LPVOID dwParam);

        HRESULT
        CreateResolverThread(
            PHANDLE phThread,
            LPDWORD pdwThreadId);

        HRESULT
        ThreadOnQueueNotEmpty(VOID);

        HRESULT
        ClearInputQueue(VOID);

        HRESULT
        FindCachedUserName(
            PDISKQUOTA_USER);

        HRESULT
        GetUserSid(PDISKQUOTA_USER pUser, PSID *ppSid);

        HRESULT
        RemoveUserFromResolverQueue(PDISKQUOTA_USER *ppUser);

        HRESULT
        AddUserToResolverQueue(PDISKQUOTA_USER pUser);

        void Lock(void)
            { WaitForSingleObject(m_hMutex, INFINITE); }

        void ReleaseLock(void)
            { ReleaseMutex(m_hMutex); }

    public:
        SidNameResolver(DiskQuotaControl& rQuotaController);
        ~SidNameResolver(void);

        //
        // IUnknown methods.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // ISidNameResolver methods.
        //
        STDMETHODIMP
        Initialize(
            VOID);

        STDMETHODIMP
        FindUserName(
            PDISKQUOTA_USER);

        STDMETHODIMP
        FindUserNameAsync(
            PDISKQUOTA_USER);

        STDMETHODIMP
        Shutdown(
            BOOL bWait);

        STDMETHODIMP
        PromoteUserToQueueHead(
            PDISKQUOTA_USER);
};


#endif // _INC_DSKQUOTA_SIDNAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\alloc.cpp ===
#include "pch.h"
#pragma hdrstop

#include "alloc.h"
#include "except.h"


void * __cdecl operator new(
    size_t size
    )
{
    void *pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL == pv)
        throw CAllocException();

    return pv;
}

void* __cdecl operator new[] (size_t size)
{
    void *pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL == pv)
        throw CAllocException();

    return pv;
}


void __cdecl operator delete(
    void *ptr
    )
{
    if (NULL != ptr)
        LocalFree(ptr);
}


void __cdecl operator delete[] (void* ptr)
{
    if (NULL != ptr)
        LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\adusrdlg.h ===
#ifndef __DSKQUOTA_ADDUSER_DIALOG_H
#define __DSKQUOTA_ADDUSER_DIALOG_H
///////////////////////////////////////////////////////////////////////////////
/*  File: adusrdlg.h

    Description: Provides declarations for the "Add User" dialog.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/15/98    Initial creation.                                    BrianAu
                Separated code from userprop.h
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_USER_H
#   include "user.h"
#endif
#ifndef _INC_DSKQUOTA_UNDO_H
#   include "undo.h"
#endif
#ifndef _INC_DSKQUOTA_DETAILS_H
#   include "details.h"    // For LVSelection
#endif
#ifndef __OBJSEL_H_
#   include <objsel.h>
#endif

#include "resource.h"

class AddUserDialog
{
    public:
        //
        // Prop sheet for editing users.
        //
        AddUserDialog(PDISKQUOTA_CONTROL pQuotaControl,
                      const CVolumeID& idVolume,
                      HINSTANCE hInstance,
                      HWND hwndParent,
                      HWND hwndDetailsLV,
                      UndoList& UndoList);

        virtual ~AddUserDialog(VOID);

        HRESULT Run(VOID);

    private:
        enum { iICON_USER_SINGLE, iICON_USER_MULTIPLE, cUSER_ICONS };

        LONGLONG           m_cVolumeMaxBytes;
        LONGLONG           m_llQuotaLimit;
        LONGLONG           m_llQuotaThreshold;
        PDISKQUOTA_CONTROL m_pQuotaControl;
        UndoList&          m_UndoList;
        HINSTANCE          m_hInstance;
        HWND               m_hwndParent;
        HWND               m_hwndDetailsLV;
        DS_SELECTION_LIST *m_pSelectionList;
        CLIPFORMAT         m_cfSelectionList;
        CVolumeID          m_idVolume;
        HICON              m_hIconUser[cUSER_ICONS];     // 0=Single, 1=Multi-user.
        XBytes            *m_pxbQuotaLimit;
        XBytes            *m_pxbQuotaThreshold;

        INT_PTR OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnHelp(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnContextMenu(HWND hwndItem, int xPos, int yPos);
        INT_PTR OnEditNotifyUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnComboNotifySelChange(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnOk(HWND hDlg, WPARAM wParam, LPARAM lParam);
        HRESULT ApplySettings(HWND hDlg, bool bUndo = true);
        HRESULT BrowseForUsers(HWND hwndParent, IDataObject **ppdtobj);

        LPCWSTR GetDsSelUserName(const DS_SELECTION& sel);
        HRESULT GetDsSelUserSid(const DS_SELECTION& sel, LPBYTE pbSid, int cbSid);
        HRESULT HexCharsToByte(LPTSTR pszByte, LPBYTE pb);

        static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

        //
        // Prevent copy.
        //
        AddUserDialog(const AddUserDialog&);
        void operator = (const AddUserDialog&);
};


#endif // __DSKQUOTA_ADDUSER_DIALOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\userenum.h ===
#ifndef _INC_DSKQUOTA_USERENUM_H
#define _INC_DSKQUOTA_USERENUM_H
///////////////////////////////////////////////////////////////////////////////
/*  File: userenum.h

    Description: Contains declaration for class DiskQuotaUserEnum.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_FSOBJECT_H
#   include "fsobject.h"
#endif
#ifndef _INC_DSKQUOTA_SIDNAME_H
#   include "sidname.h"
#endif
#ifndef _INC_DSKQUOTA_DISPATCH_H
#   include "dispatch.h"   // MIDL-generated header.
#endif
#ifndef _INC_DSKQUOTA_OADISP_H
#   include "oadisp.h"     // OleAutoDispatch class.
#endif


class DiskQuotaUserEnum : public IEnumDiskQuotaUsers {

    private:
        LONG     m_cRef;            // Object Ref counter.
        LPBYTE   m_pbBuffer;        // For reading disk info.
        LPBYTE   m_pbCurrent;       // Pointer to "current" rec in cache.
        DWORD    m_cbBuffer;        // Size of buffer in bytes.
        PSIDLIST m_pSidList;        // Optional SidList filter.
        BOOL     m_bEOF;            // End of quota info file reached?
        DWORD    m_cbSidList;       // Sid list length in bytes.
        BOOL     m_bSingleUser;     // Single-user enumeration?
        BOOL     m_bInitialized;    // Initialize() already called?
        BOOL     m_bRestartScan;    // Restart NTFS quota file scan?
        DWORD    m_fNameResolution; // None, sync, async
        FSObject *m_pFSObject;      // Pointer to file system object.
        PDISKQUOTA_CONTROL m_pQuotaController; // Ptr to quota controller.
        PSID_NAME_RESOLVER m_pSidNameResolver; // For getting SID account names.

        HRESULT 
        QueryQuotaInformation(
            BOOL bReturnSingleEntry = FALSE,
            PVOID pSidList = NULL,
            ULONG cbSidList = 0,
            PSID pStartSid = NULL,
            BOOL bRestartScan = FALSE);

        HRESULT 
        CreateUserObject(
            PFILE_QUOTA_INFORMATION pfqi, 
            PDISKQUOTA_USER *ppOut);

        HRESULT 
        GetNextUser(
            PDISKQUOTA_USER *ppOut);

        HRESULT
        InitializeSidList(
            PSIDLIST pSidList,
            DWORD cbSidList);

        HRESULT
        InitializeSidList(
            PSID *rgpSids,
            DWORD cpSids);

        //
        // Prevent copy construction.
        //
        DiskQuotaUserEnum(const DiskQuotaUserEnum& UserEnum);
        void operator = (const DiskQuotaUserEnum& UserEnum);

    public:
        DiskQuotaUserEnum(
            PDISKQUOTA_CONTROL pQuotaController,
            PSID_NAME_RESOLVER pSidNameResolver,
            FSObject *pFSObject);

        ~DiskQuotaUserEnum(VOID);

        HRESULT 
        Initialize(
            DWORD fNameResolution, 
            DWORD cbBuffer = 2048, 
            PSID *rgpSids = NULL,
            DWORD cpSids = 0);

        HRESULT 
        Initialize(
            const DiskQuotaUserEnum& UserEnum);

        STDMETHODIMP
        SetNameResolution(
            DWORD fNameResolution);

        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IEnumDiskQuotaUsers methods.
        //
        STDMETHODIMP 
        Next(
            DWORD, 
            PDISKQUOTA_USER *, 
            LPDWORD);

        STDMETHODIMP 
        Skip(
            DWORD);

        STDMETHODIMP 
        Reset(
            VOID);

        STDMETHODIMP 
        Clone(
            PENUM_DISKQUOTA_USERS *);
};

//
// Enumerator for VB's "for each" construct.
//
class DiskQuotaUserCollection : public IEnumVARIANT
{
    public:
        DiskQuotaUserCollection(PDISKQUOTA_CONTROL pController,
                                DWORD fNameResolution);

        ~DiskQuotaUserCollection(VOID);

        HRESULT Initialize(VOID);

        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IEnumVARIANT Methods.
        //
        STDMETHODIMP
        Next(
            DWORD cUsers,
            VARIANT *rgvar,
            DWORD *pcUsersFetched);

        STDMETHODIMP
        Skip(
            DWORD cUsers);

        STDMETHODIMP
        Reset(
            void);

        STDMETHODIMP
        Clone(
            IEnumVARIANT **ppEnum);

    private:
        LONG                  m_cRef;
        PDISKQUOTA_CONTROL    m_pController;
        PENUM_DISKQUOTA_USERS m_pEnum;
        DWORD                 m_fNameResolution;
};


#endif // _INC_DSKQUOTA_USERENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\adusrdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: adusrdlg.cpp

    Description: Provides implementations for the "Add User" dialog.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include <lm.h>
#include "undo.h"
#include "adusrdlg.h"
#include "uihelp.h"
#include "progress.h"
#include "uiutils.h"


//
// Context help IDs.
//
#pragma data_seg(".text", "CODE")
const static DWORD rgAddUserDialogHelpIDs[] =
{
    IDC_ICON_USER,               DWORD(-1),
    IDC_STATIC2,                 DWORD(-1),
    IDC_TXT_DEFAULTS,            DWORD(-1),
    IDC_TXT_USERNAME,            IDH_TXT_USERNAME,
    IDC_TXT_SPACEUSED,           IDH_TXT_SPACEUSED,
    IDC_TXT_SPACEREMAINING,      IDH_TXT_SPACEREMAINING,
    IDC_ICON_USERSTATUS,         IDH_ICON_USERSTATUS,
    IDC_RBN_USER_NOLIMIT,        IDH_RBN_USER_NOLIMIT,
    IDC_RBN_USER_LIMIT,          IDH_RBN_USER_LIMIT,
    IDC_TXT_WARN_LEVEL,          DWORD(-1),
    IDC_EDIT_USER_LIMIT,         IDH_EDIT_USER_LIMIT,
    IDC_EDIT_USER_THRESHOLD,     IDH_EDIT_USER_THRESHOLD,
    IDC_CMB_USER_LIMIT,          IDH_CMB_USER_LIMIT,
    IDC_CMB_USER_THRESHOLD,      IDH_CMB_USER_THRESHOLD,
    0,0
};

#pragma data_seg()


///////////////////////////////////////////////////////////////////////////////
/*  Function: AddUserDialog::AddUserDialog

    Description: Constructor for a user property sheet object.
        Initializes the members that hold user quota data.

    Arguments: None.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
AddUserDialog::AddUserDialog(
    PDISKQUOTA_CONTROL pQuotaControl,
    const CVolumeID& idVolume,
    HINSTANCE hInstance,
    HWND hwndParent,
    HWND hwndDetailsLV,
    UndoList& UndoList
    ) : m_cVolumeMaxBytes(0),
        m_pQuotaControl(pQuotaControl),
        m_idVolume(idVolume),
        m_UndoList(UndoList),
        m_hInstance(hInstance),
        m_hwndParent(hwndParent),
        m_hwndDetailsLV(hwndDetailsLV),
        m_pxbQuotaLimit(NULL),
        m_pxbQuotaThreshold(NULL),
        m_llQuotaLimit(0),
        m_llQuotaThreshold(0),
        m_pSelectionList(NULL),  // Object instance doesn't own this memory.
        m_cfSelectionList((CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST))
{
    DBGASSERT((NULL != m_pQuotaControl));
    DBGASSERT((NULL != m_hwndParent));
    DBGTRACE((DM_UPROP, DL_HIGH, TEXT("AddUserDialog::AddUserDialog")));

    DBGASSERT((0 == iICON_USER_SINGLE));
    DBGASSERT((1 == iICON_USER_MULTIPLE));
    m_hIconUser[0]     = LoadIcon(m_hInstance, MAKEINTRESOURCE(IDI_SINGLE_USER));
    m_hIconUser[1]     = LoadIcon(m_hInstance, MAKEINTRESOURCE(IDI_MULTI_USER));
}



AddUserDialog::~AddUserDialog(
    VOID
    )
{
    DBGTRACE((DM_UPROP, DL_HIGH, TEXT("AddUserDialog::~AddUserDialog")));
    INT i = 0;

    if (NULL != m_pQuotaControl)
        m_pQuotaControl->Release();

    if (NULL != m_pxbQuotaLimit)
        delete m_pxbQuotaLimit;
    if (NULL != m_pxbQuotaThreshold)
        delete m_pxbQuotaThreshold;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: AddUserDialog::Run

    Description: Creates and runs the property sheet dialog.
        This is the only method a client needs to call once the object
        is created.

    Arguments: None.

    Returns:
        NO_ERROR
        E_FAIL      - Couldn't create property sheet.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
AddUserDialog::Run(
    VOID
    )
{
    //
    // Invoke the standard object picker dialog.
    //
    IDataObject *pdtobj = NULL;
    HRESULT hr = BrowseForUsers(m_hwndParent, &pdtobj);
    if (S_OK == hr)
    {
        //
        // Retrieve the data object representing the selected user objects.
        //
        FORMATETC fe = { m_cfSelectionList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM stg;
        hr = pdtobj->GetData(&fe, &stg);
        {
            //
            // Cache the data obj ptr so the dialog can have access.
            //
            m_pSelectionList = (DS_SELECTION_LIST *)GlobalLock(stg.hGlobal);

            if (NULL != m_pSelectionList)
            {
                hr = (HRESULT) DialogBoxParam(m_hInstance,
                                              MAKEINTRESOURCE(IDD_ADDUSER),
                                              m_hwndParent,
                                              DlgProc,
                                              (LPARAM)this);
                GlobalUnlock(stg.hGlobal);
                m_pSelectionList = NULL;
            }
            ReleaseStgMedium(&stg);
        }
        pdtobj->Release();
    }
    return hr;

}



///////////////////////////////////////////////////////////////////////////////
/*  Function: AddUserDialog::DlgProc

    Description: Static method called by windows to process messages for the
        property page dialog.  Since it's static, we have to save the "this"
        pointer in the window's USERDATA.

    Arguments: Standard WndProc-type arguments.

    Returns: Standard WndProc-type return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK
AddUserDialog::DlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR bResult = FALSE;

    //
    // Retrieve the "this" pointer from the dialog's userdata.
    // It was placed there in OnInitDialog().
    //
    AddUserDialog *pThis = (AddUserDialog *)GetWindowLongPtr(hDlg, DWLP_USER);

    try
    {
        switch(message)
        {
            case WM_INITDIALOG:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_INITDIALOG")));
                pThis = (AddUserDialog *)lParam;
                DBGASSERT((NULL != pThis));
                //
                // Save "this" in the window's userdata.
                //
                SetWindowLongPtr(hDlg, DWLP_USER, (INT_PTR)pThis);
                bResult = pThis->OnInitDialog(hDlg, wParam, lParam);
                break;

            case WM_COMMAND:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_COMMAND")));
                bResult = pThis->OnCommand(hDlg, wParam, lParam);
                break;

            case WM_CONTEXTMENU:
                bResult = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
                break;

            case WM_HELP:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_HELP")));
                bResult = pThis->OnHelp(hDlg, wParam, lParam);
                break;

            case WM_DESTROY:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_DESTROY")));
                break;

            default:
                break;
        }

    }
    catch(CAllocException& e)
    {
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return bResult;
}

INT_PTR
AddUserDialog::OnInitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hResult = NO_ERROR;

    DWORD dwSectorsPerCluster = 0;
    DWORD dwBytesPerSector    = 0;
    DWORD dwFreeClusters      = 0;
    DWORD dwTotalClusters     = 0;

    //
    // The "new user" dialog is initialized with the volume's default quota
    // limit and threshold for new users.
    //
    m_pQuotaControl->GetDefaultQuotaLimit(&m_llQuotaLimit);
    m_pQuotaControl->GetDefaultQuotaThreshold(&m_llQuotaThreshold);

    //
    // Configure the Limit/NoLimit radio buttons.
    //
    if (NOLIMIT == m_llQuotaThreshold)
    {
        CheckDlgButton(hDlg, IDC_RBN_USER_LIMIT,   FALSE);
        CheckDlgButton(hDlg, IDC_RBN_USER_NOLIMIT, TRUE);
    }
    else
    {
        CheckDlgButton(hDlg, IDC_RBN_USER_LIMIT,   TRUE);
        CheckDlgButton(hDlg, IDC_RBN_USER_NOLIMIT, FALSE);
    }

    //
    // Calculate the volume's size.
    // We'll use this to limit user threshold and quota limit entries.
    //
    if (GetDiskFreeSpace(m_idVolume.ForParsing(),
                         &dwSectorsPerCluster,
                         &dwBytesPerSector,
                         &dwFreeClusters,
                         &dwTotalClusters))
    {
        m_cVolumeMaxBytes = (LONGLONG)dwSectorsPerCluster *
                            (LONGLONG)dwBytesPerSector *
                            (LONGLONG)dwTotalClusters;
    }

    m_pxbQuotaLimit     = new XBytes(hDlg,
                                     IDC_EDIT_USER_LIMIT,
                                     IDC_CMB_USER_LIMIT,
                                     m_llQuotaLimit);

    m_pxbQuotaLimit->SetBytes(m_llQuotaLimit);

    m_pxbQuotaThreshold = new XBytes(hDlg,
                                     IDC_EDIT_USER_THRESHOLD,
                                     IDC_CMB_USER_THRESHOLD,
                                     m_llQuotaThreshold);

    m_pxbQuotaThreshold->SetBytes(m_llQuotaThreshold);

    DBGASSERT((0 < m_pSelectionList->cItems));
    if (1 == m_pSelectionList->cItems)
    {
        SetDlgItemText(hDlg,
                       IDC_TXT_USERNAME,
                       GetDsSelUserName(m_pSelectionList->aDsSelection[0]));
    }
    else
    {
        CString strMultiple(m_hInstance, IDS_MULTIPLE);
        SetDlgItemText(hDlg, IDC_TXT_USERNAME, strMultiple);
    }

    SendMessage(GetDlgItem(hDlg, IDC_ICON_USER),
                STM_SETICON,
                (WPARAM)m_hIconUser[1 == m_pSelectionList->cItems ? iICON_USER_SINGLE :
                                                                    iICON_USER_MULTIPLE],
                0);


    return TRUE;  // Set focus to default control.
}

//
// The Object Picker scope definition structure looks like this
// JeffreyS created these helper macros for working with the object picker
// in the ACLEDIT security UI. Thanks Jeff!
//
#if 0
{   // DSOP_SCOPE_INIT_INFO
    cbSize,
    flType,
    flScope,
    {   // DSOP_FILTER_FLAGS
        {   // DSOP_UPLEVEL_FILTER_FLAGS
            flBothModes,
            flMixedModeOnly,
            flNativeModeOnly
        },
        flDownlevel
    },
    pwzDcName,
    pwzADsPath,
    hr // OUT
}
#endif

//
// macro for declaring one of the above
//
#define DECLARE_SCOPE(t,f,b,m,n,d)  \
{ sizeof(DSOP_SCOPE_INIT_INFO), (t), (f), { { (b), (m), (n) }, (d) }, NULL, NULL, S_OK }


#define COMMON_SCOPE_FLAGS    (DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP | DSOP_SCOPE_FLAG_WANT_SID_PATH)

#define TARGET_COMPUTER_SCOPE                             \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_TARGET_COMPUTER,                      \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define JOINED_UPLEVEL_DOMAIN_SCOPE                       \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,                \
    COMMON_SCOPE_FLAGS | DSOP_SCOPE_FLAG_STARTING_SCOPE,  \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define JOINED_DOWNLEVEL_DOMAIN_SCOPE                     \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,              \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define ENTERPRISE_DOMAIN_SCOPE                           \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,                    \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define EXTERNAL_UPLEVEL_DOMAIN_SCOPE                     \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN,              \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define EXTERNAL_DOWNLEVEL_DOMAIN_SCOPE                   \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,            \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define GLOBAL_CATALOG_SCOPE                              \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_GLOBAL_CATALOG,                       \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define WORKGROUP_SCOPE                                   \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_WORKGROUP,                            \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

//
// Invokes the standard DS object picker dialog.
// Returns a list of DS_SELECTION structures in a data object
// representing the selected user objects.
//
HRESULT
AddUserDialog::BrowseForUsers(
    HWND hwndParent,
    IDataObject **ppdtobj
    )
{
    DBGASSERT((NULL != hwndParent));
    DBGASSERT((NULL != ppdtobj));

    *ppdtobj = NULL;

    IDsObjectPicker *pop = NULL;
    HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDsObjectPicker,
                                  (void **)&pop);
    if (SUCCEEDED(hr))
    {
        //
        // This array initializes the scopes of the DS object picker.
        // The first entry is the "default" scope.
        //
        DSOP_SCOPE_INIT_INFO rgdsii[] = {
                JOINED_UPLEVEL_DOMAIN_SCOPE,
                JOINED_DOWNLEVEL_DOMAIN_SCOPE,
                ENTERPRISE_DOMAIN_SCOPE,
                EXTERNAL_UPLEVEL_DOMAIN_SCOPE,
                EXTERNAL_DOWNLEVEL_DOMAIN_SCOPE,
                GLOBAL_CATALOG_SCOPE,
                WORKGROUP_SCOPE,
                TARGET_COMPUTER_SCOPE
                };

        DSOP_INIT_INFO dii;
        dii.cbSize             = sizeof(dii);
        dii.pwzTargetComputer  = NULL;
        dii.cDsScopeInfos      = ARRAYSIZE(rgdsii);
        dii.aDsScopeInfos      = rgdsii;
        dii.flOptions          = DSOP_FLAG_MULTISELECT;
        dii.cAttributesToFetch = 0;
        dii.apwzAttributeNames = NULL;
        //
        // Init and run the object picker dialog.
        //
        hr = pop->Initialize(&dii);
        if (SUCCEEDED(hr))
        {
            hr = pop->InvokeDialog(hwndParent, ppdtobj);
        }
        pop->Release();
    }

    return hr;
}


INT_PTR
AddUserDialog::OnCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD dwCtlId      = LOWORD(wParam);
    HWND hWndCtl       = (HWND)lParam;
    DWORD dwNotifyCode = HIWORD(wParam);
    INT_PTR bResult    = FALSE;

    switch(dwCtlId)
    {
        case IDC_RBN_USER_NOLIMIT:
            if (m_pxbQuotaThreshold->IsEnabled())
            {
                //
                // This is simple.  Just set both the limit and threshold controls
                // to "no limit".
                //
                m_pxbQuotaThreshold->SetBytes(NOLIMIT);
                m_pxbQuotaLimit->SetBytes(NOLIMIT);
            }
            break;

        case IDC_RBN_USER_LIMIT:
            if (!m_pxbQuotaThreshold->IsEnabled())
            {
                LONGLONG llValue = 0;
                m_pQuotaControl->GetDefaultQuotaLimit(&llValue);
                m_pxbQuotaLimit->SetBytes(NOLIMIT == llValue ? 0 : llValue);

                llValue = 0;
                m_pQuotaControl->GetDefaultQuotaThreshold(&llValue);
                m_pxbQuotaThreshold->SetBytes(NOLIMIT == llValue ? 0 : llValue);
            }
            break;

        case IDC_EDIT_USER_LIMIT:
        case IDC_EDIT_USER_THRESHOLD:
            switch(dwNotifyCode)
            {
                case EN_UPDATE:
                    bResult = OnEditNotifyUpdate(hDlg, wParam, lParam);
                    break;

                default:
                    break;
            }
            break;

        case IDC_CMB_USER_LIMIT:
        case IDC_CMB_USER_THRESHOLD:
            switch(dwNotifyCode)
            {
                case CBN_SELCHANGE:
                    bResult = OnComboNotifySelChange(hDlg, wParam, lParam);
                    break;

                default:
                    break;
            }
            break;

        case IDOK:
            if (!OnOk(hDlg, wParam, lParam))
                return FALSE;
            //
            // Fall through...
            //
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;

        default:
            bResult = TRUE;  // Didn't handle message.
            break;
    }

    return bResult;
}




INT_PTR
AddUserDialog::OnOk(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hResult  = NO_ERROR;

    //
    // We need to do this because if you activate the OK button
    // with [Return] we receive the WM_COMMAND before EN_KILLFOCUS.
    //
    m_pxbQuotaThreshold->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_USER_THRESHOLD));
    m_pxbQuotaLimit->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_USER_LIMIT));

    //
    // Ensure warning threshold is not above limit.
    //
    INT64 iThreshold = m_pxbQuotaThreshold->GetBytes();
    INT64 iLimit     = m_pxbQuotaLimit->GetBytes();

    if (NOLIMIT != iLimit && iThreshold > iLimit)
    {
        TCHAR szLimit[40], szThreshold[40];
        XBytes::FormatByteCountForDisplay(iLimit, szLimit, ARRAYSIZE(szLimit));
        XBytes::FormatByteCountForDisplay(iThreshold, szThreshold, ARRAYSIZE(szThreshold));

        CString s(m_hInstance, IDS_FMT_ERR_WARNOVERLIMIT, szThreshold, szLimit, szLimit);
        switch(DiskQuotaMsgBox(hDlg, s, IDS_TITLE_DISK_QUOTA, MB_ICONWARNING | MB_YESNO))
        {
            case IDYES:
                m_pxbQuotaThreshold->SetBytes(iLimit);
                break;

            case IDNO:
                //
                // Set focus to threshold edit box so user can correct
                // the entry.  Return early with FALSE value.
                //
                SetFocus(GetDlgItem(hDlg, IDC_EDIT_USER_THRESHOLD));
                SendMessage(GetDlgItem(hDlg, IDC_EDIT_USER_THRESHOLD), EM_SETSEL, 0, -1);
                return FALSE;
        }
    }

    //
    // Only apply settings if the "Apply" button is enabled indicating
    // that something has been changed.  No need to apply unchanged
    // settings when the OK button is pressed.
    //
    hResult = ApplySettings(hDlg);
    if (FAILED(hResult))
    {
        INT idMsg   = IDS_UNKNOWN_ERROR;
        UINT uFlags = MB_OK;
        switch(hResult)
        {
            case E_FAIL:
                idMsg = IDS_WRITE_ERROR;
                uFlags |= MB_ICONERROR;
                break;

            default:
                switch(HRESULT_CODE(hResult))
                {

//                      case ERROR_USER_EXISTS:
//                          idMsg = IDS_NOADD_EXISTING_USER;
//                          uFlags |= MB_ICONWARNING;
//                          break;
//
// Still valid?  [brianau - 5/27/98]
//
                    case ERROR_NO_SUCH_USER:
                        idMsg = IDS_NOADD_UNKNOWN_USER;
                        uFlags |= MB_ICONWARNING;
                        break;

                    case ERROR_ACCESS_DENIED:
                        idMsg  = IDS_NO_WRITE_ACCESS;
                        uFlags |= MB_ICONWARNING;
                        break;

                    default:
                    uFlags |= MB_ICONERROR;
                    break;
                }
                break;
        }
        DiskQuotaMsgBox(GetDesktopWindow(),
                        idMsg,
                        IDS_TITLE_DISK_QUOTA,
                        uFlags);
    }
    return TRUE;
}



INT_PTR
AddUserDialog::OnHelp(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, STR_DSKQUOUI_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) rgAddUserDialogHelpIDs);
    return TRUE;
}


INT_PTR
AddUserDialog::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem,
            UseWindowsHelp(idCtl) ? NULL : STR_DSKQUOUI_HELPFILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)((LPTSTR)rgAddUserDialogHelpIDs));

    return FALSE;
}



INT_PTR
AddUserDialog::OnEditNotifyUpdate(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *pxb = NULL;

    switch(LOWORD(wParam))
    {
        case IDC_EDIT_USER_LIMIT:
            pxb = m_pxbQuotaLimit;
            break;

        case IDC_EDIT_USER_THRESHOLD:
            pxb = m_pxbQuotaThreshold;
            break;

        default:
            break;
    }

    if (NULL != pxb)
        pxb->OnEditNotifyUpdate(lParam);

    return FALSE;
}


INT_PTR
AddUserDialog::OnComboNotifySelChange(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *pxb = NULL;

    switch(LOWORD(wParam))
    {
        case IDC_CMB_USER_LIMIT:
            pxb = m_pxbQuotaLimit;
            break;

        case IDC_CMB_USER_THRESHOLD:
            pxb = m_pxbQuotaThreshold;
            break;

        default:
            break;
    }
    if (NULL != pxb)
       pxb->OnComboNotifySelChange(lParam);

    return FALSE;
}


//
// Retrieve from a DS_SELECTION structure the name to display for
// a user object.
//
LPCWSTR
AddUserDialog::GetDsSelUserName(
    const DS_SELECTION& sel
    )
{
    return sel.pwzUPN && *sel.pwzUPN ? sel.pwzUPN : sel.pwzName;
}


//
// Convert two hex chars into a single byte value.
// Assumes input string is in upper case.
//
HRESULT
AddUserDialog::HexCharsToByte(
    LPTSTR pszByteIn,
    LPBYTE pbOut
    )
{
    static const int iShift[] = { 4, 0 };

    *pbOut = (BYTE)0;
    for (int i = 0; i < 2; i++)
    {
        TCHAR ch = *(pszByteIn + i);
        BYTE b   = (BYTE)0;
        if (TEXT('0') <= ch && TEXT('9') >= ch)
        {
            b = ch - TEXT('0');
        }
        else if (TEXT('A') <= ch && TEXT('F') >= ch)
        {
            b = 10 + (ch - TEXT('A'));
        }
        else
        {
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        *pbOut |= (b << iShift[i]);
    }
    return NOERROR;
}

//
// Returns:
//
//  NOERROR
//  ERROR_INSUFFICIENT_BUFFER (as hresult)
//  ERROR_INVALID_DATA (as hresult)
//
HRESULT
AddUserDialog::GetDsSelUserSid(
    const DS_SELECTION& sel,
    LPBYTE pbSid,
    int cbSid
    )
{
    static const WCHAR szPrefix[] = L"LDAP://<SID=";
    static const WCHAR chTerm     = L'>';

    HRESULT hr     = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    LPWSTR pszLDAP = CharUpper(sel.pwzADsPath);
    if (NULL != pszLDAP)
    {
        int cb = 0;

        //
        // First check for the required prefix.
        //
        if (0 == StrCmpNW(pszLDAP, szPrefix, ARRAYSIZE(szPrefix) - 1))
        {
            hr = NOERROR;
            //
            // Advance ptr beyond prefix and convert the hex string
            // into a SID.  Process chars until we hit a '>'.
            //
            pszLDAP += ARRAYSIZE(szPrefix) - 1;

            while(SUCCEEDED(hr) && *pszLDAP && chTerm != *pszLDAP)
            {
                if (0 < cbSid--)
                {
                    hr = HexCharsToByte(pszLDAP, pbSid++);
                    pszLDAP += 2;
                }
                else
                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            if (SUCCEEDED(hr) && chTerm != *pszLDAP)
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
    }

    if (FAILED(hr))
    {
        //
        // FEATURE:  This can be removed once I'm comfortable that all
        //          ADs paths returned from the object picker contain
        //          a SID.
        //
        DBGERROR((TEXT("GetDsSelUserSid returning hr = 0x%08X for path \"%s\""),
                  hr, sel.pwzADsPath));
    }

    return hr;
}


HRESULT
AddUserDialog::ApplySettings(
    HWND hDlg,
    bool bUndo
    )
{
    HRESULT hResult = E_FAIL;
    int cUsers = m_pSelectionList->cItems;
    CAutoWaitCursor wait_cursor;

    //
    // Retrieve limit and threshold values from dialog controls.
    //
    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RBN_USER_NOLIMIT))
    {
        m_llQuotaThreshold = NOLIMIT;
        m_llQuotaLimit     = NOLIMIT;
    }
    else
    {
        m_llQuotaThreshold = m_pxbQuotaThreshold->GetBytes();
        m_llQuotaLimit     = m_pxbQuotaLimit->GetBytes();
    }


    if (bUndo)
        m_UndoList.Clear();

    ProgressDialog dlgProgress(IDD_PROGRESS,
                               IDC_PROGRESS_BAR,
                               IDC_TXT_PROGRESS_DESCRIPTION,
                               IDC_TXT_PROGRESS_FILENAME);
    if (2 < cUsers)
    {
        //
        // Create and display a progress dialog if we're adding more than 2
        // users.
        //
        HWND hwndParent = IsWindowVisible(hDlg) ? hDlg : GetParent(hDlg);
        if (dlgProgress.Create(m_hInstance, hwndParent))
        {
            dlgProgress.ProgressBarInit(0, cUsers, 1);
            dlgProgress.SetDescription(MAKEINTRESOURCE(IDS_PROGRESS_ADDUSER));
            dlgProgress.Show();
        }
    }

    bool bCancelled = false;
    for (int i = 0; i < cUsers && !bCancelled; i++)
    {
        DS_SELECTION *pdss = &(m_pSelectionList->aDsSelection[i]);
        LPCWSTR pwzName = GetDsSelUserName(*pdss);

        //
        // Add a user to the quota file.  This will add it using the defaults
        // for new users.  We get back an interface to the new user object.
        // Also specify async name resolution.
        //
        if (NULL == pwzName)
        {
            dlgProgress.ProgressBarAdvance();
            continue;
        }

        dlgProgress.SetFileName(pwzName);

        com_autoptr<DISKQUOTA_USER> ptrUser;
        DiskQuotaControl *pDQC = static_cast<DiskQuotaControl *>(m_pQuotaControl);

        BYTE sid[MAX_SID_LEN];
        hResult = GetDsSelUserSid(*pdss, sid, ARRAYSIZE(sid));
        if (SUCCEEDED(hResult))
        {
            hResult = pDQC->AddUserSid(sid,
                                       DISKQUOTA_USERNAME_RESOLVE_ASYNC,
                                       ptrUser.getaddr());

            if (SUCCEEDED(hResult))
            {
                if (S_FALSE == hResult)
                {
                    hResult = HRESULT_FROM_WIN32(ERROR_USER_EXISTS);
                }
                else
                {
                    if (SUCCEEDED(hResult = ptrUser->SetQuotaLimit(m_llQuotaLimit, TRUE)) &&
                        SUCCEEDED(hResult = ptrUser->SetQuotaThreshold(m_llQuotaThreshold, TRUE)))
                    {
                        if (bUndo)
                        {
                            //
                            // Create local autoptrs to ensure iface release if an
                            // exception is thrown.
                            //
                            com_autoptr<DISKQUOTA_CONTROL> ptrQuotaControl(m_pQuotaControl);
                            com_autoptr<DISKQUOTA_USER> ptrQuotaUser(ptrUser);

                            ptrQuotaUser->AddRef();
                            ptrQuotaControl->AddRef();

                            autoptr<UndoAdd> ptrUndoAdd = new UndoAdd(ptrUser, m_pQuotaControl);

                            m_UndoList.Add(ptrUndoAdd);
                            //
                            // Undo list now owns the action object.
                            //
                            ptrUndoAdd.disown();

                            //
                            // Successfully added to undo list.  Disown real ptrs so
                            // ref count stays with undo list.  If an exception was
                            // thrown, the local com_autoptr objects will automatically
                            // release the interfaces.
                            //
                            ptrQuotaUser.disown();
                            ptrQuotaControl.disown();
                        }

                        //
                        // Add the user to the listview.
                        //
                        SendMessage(m_hwndDetailsLV,
                                    WM_ADD_USER_TO_DETAILS_VIEW,
                                    0,
                                    (LPARAM)ptrUser.get());
                        //
                        // iface pointer added to listview.  autoptr disowns the real
                        // pointer so the autoptr's dtor doesn't release it.
                        //
                        ptrUser.disown();
                    }
                }
            }
        }
        if (FAILED(hResult))
        {
            INT idMsg   = IDS_UNKNOWN_ERROR;
            UINT uFlags = MB_OKCANCEL;
            switch(hResult)
            {
                case E_FAIL:
                    idMsg = IDS_WRITE_ERROR;
                    uFlags |= MB_ICONERROR;
                    break;

                default:
                    switch(HRESULT_CODE(hResult))
                    {
                        case ERROR_USER_EXISTS:
                            idMsg = IDS_NOADD_EXISTING_USER;
                            uFlags |= MB_ICONWARNING;
                            break;

                        case ERROR_NO_SUCH_USER:
                            idMsg = IDS_NOADD_UNKNOWN_USER;
                            uFlags |= MB_ICONWARNING;
                            break;

                        case ERROR_ACCESS_DENIED:
                            idMsg  = IDS_NO_WRITE_ACCESS;
                            uFlags |= MB_ICONWARNING;
                            break;

                        default:
                            uFlags |= MB_ICONERROR;
                            break;
                    }
                    break;
            }

            //
            // Display message box with msg formatted as:
            //
            //      The user already exists and could not be added.
            //
            //      User:  brianau
            //      In Folder: Domain/Folder: ntdev.microsoft.com/US SOS-...
            //
            CString strError(m_hInstance, idMsg);
            CString strMsg(m_hInstance, IDS_FMT_ERR_ADDUSER, strError.Cstr(), pwzName);

            HWND hwndMsgBoxParent = (NULL != dlgProgress.m_hWnd && IsWindowVisible(dlgProgress.m_hWnd)) ?
                                    dlgProgress.m_hWnd : hDlg;

            if (IDCANCEL == DiskQuotaMsgBox(hwndMsgBoxParent,
                                            strMsg.Cstr(),
                                            IDS_TITLE_DISK_QUOTA,
                                            uFlags))
            {
                bCancelled = true;
            }
        }
        dlgProgress.ProgressBarAdvance();
        bCancelled = bCancelled || dlgProgress.UserCancelled();
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\dynarray.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: dynarray.cpp

    Description: Wrapper classes around the DPA_xxxxx and DSA_xxxxx functions 
        provided by the common control's library.  The classes add value by 
        providing multi-threaded protection, iterators and automatic cleanup 
        semantics.  

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "dynarray.h"



///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::PointerList

    Description: Constructor.  

    Arguments:
        cItemGrow - Number of items to grow list when expansion is required.
                    Default value is 0 which causes DPA to use 8.

    Returns: Nothing.
    
    Exception: Throws OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/03/96    Initial creation.                                    BrianAu
    02/21/97    Added cItemGrow argument.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PointerList::PointerList(
    INT cItemGrow
    )
      : m_hdpa(NULL)
{
    if (!InitializeCriticalSectionAndSpinCount(&m_cs, 0))
    {
        throw CAllocException();
    }
    if (NULL == (m_hdpa = DPA_CreateEx(cItemGrow, NULL)))
    {
        DeleteCriticalSection(&m_cs);
        throw CAllocException();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::~PointerList

    Description: Destructor.  Destroys the DPA and closes the mutex handle.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PointerList::~PointerList(
    VOID
    )
{
    Lock();
    if (NULL != m_hdpa)
        DPA_Destroy(m_hdpa);

    ReleaseLock();
    DeleteCriticalSection(&m_cs);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Count

    Description: Returns the number of elements in the list.

    Arguments: None.

    Returns: Count of elements in list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT 
PointerList::Count(
    VOID
    )
{
    UINT n = 0;

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));
    n = DPA_GetPtrCount(m_hdpa);

    return n;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Insert

    Description: Inserts a pointer into the pointer list at a given index.
        If the index is beyond the upper bounds of the array, the array
        is extended by one and the item is appended to the list.

    Arguments:
        pvItem - Pointer value to add to list.

        index - List index where pointer is to be inserted.  All following
            items are shifted to one index higher.  The list automatically
            grows to accomodate as required.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID 
PointerList::Insert(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));

    if (DPA_InsertPtr(m_hdpa, index, pvItem) < 0)
    {
        throw CAllocException();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Replace

    Description: Replaces a pointer in the pointer list at a given index.
        If the index is beyond the upper bounds of the array, the array
        is extended by one and the item is appended to the list.

    Arguments:
        pvItem - Pointer value to add to list.

        index - List index where pointer is to be replaced.
          
    Returns:
        TRUE  - Success.
        FALSE - Invalid index or empty container.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::Replace(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));

    return DPA_SetPtr(m_hdpa, index, pvItem);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Append

    Description: Appends a pointer to the end of the list.

    Arguments:
        pvItem - Pointer value to add to list.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
PointerList::Append(
    LPVOID pvItem
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    //
    // Yes, this is correct.  We're "inserting" an item to append something
    // to the list.  This saves a ( count - 1 ) calculation.
    //
    DBGASSERT((NULL != m_hdpa));
    Insert(pvItem, DPA_GetPtrCount(m_hdpa));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Remove

    Description: Removes a pointer from the list at a given index.

    Arguments: 
        ppvItem - Address of variable to contain removed pointer value.

        index - List index where pointer is to be removed.  All following
            items are shifted to one index lower. 

    Returns:
        TRUE  - Success.
        FASLE - Index is invalid (or container is empty).

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::Remove(
    LPVOID *ppvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != ppvItem));
    DBGASSERT((NULL != m_hdpa));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    *ppvItem = DPA_DeletePtr(m_hdpa, index);
    if (NULL == *ppvItem)
        return FALSE;

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::RemoveLast

    Description: Removes the last pointer from the list.

    Arguments: 
        ppvItem - Address of variable to contain removed pointer value.
            All following items are shifted to one index lower. 

    Returns: 
        TRUE  - Success.
        FALSE - Container is emtpy.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL 
PointerList::RemoveLast(
    LPVOID *ppvItem
    )
{
    DBGASSERT((NULL != ppvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    if (0 == Count())
        return FALSE;

    Remove(ppvItem, Count() - 1);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Retrieve

    Description: Retrieve a pointer from the list at a given index.
        The pointer value is merely retrieved and not removed from the list.

    Arguments:
        ppvItem - Address of variable to contain retrieved pointer value.

        index - List index where pointer is to be retrieved.  

    Returns: 
        TRUE  - Success.
        FALSE - Invalid index or container is empty.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::Retrieve(
    LPVOID *ppvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != ppvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));
    *ppvItem = DPA_GetPtr(m_hdpa, index);

    if (NULL == *ppvItem)
        return FALSE;

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::RetrieveLast

    Description: Retrieves the last pointer from the list.

    Arguments: 
        ppvItem - Address of variable to contain retrieved pointer value.

    Returns:
        TRUE  - Success.
        FALSE - Container is empty.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::RetrieveLast(
    LPVOID *ppvItem
    )
{
    DBGASSERT((NULL != ppvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    if (0 == Count())
        return FALSE;

    Retrieve(ppvItem, Count() - 1);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::FindIndex

    Description: Returns the list index associated with a given pointer
        value.  If duplicates exist, the index of the first item is returned.

    Arguments: 
        pvItem - Pointer value of item to be found.

        pIndex - Address of index variable to hold resulting index.

    Returns:
        TRUE  = Success
        FALSE = Item not found in list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Changed returned value to BOOL.                      BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::FindIndex(
    LPVOID pvItem, 
    INT *pIndex
    )
{
    INT i = -1;

    DBGASSERT((NULL != pIndex));
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));
    i = *pIndex = DPA_GetPtrIndex(m_hdpa, pvItem);

    if (-1 == i)
        return FALSE;

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Sort

    Description: Sorts the list given a comparison function.

    Arguments: 
        pfnCompare - Address of comparison callback.

        lParam - 32-bit parameter passed to the callback.

    Returns:
        TRUE  = Success
        FALSE = Item not found in list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/21/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::Sort(
    PFNDPACOMPARE pfnCompare, 
    LPARAM lParam
    )
{
    DBGASSERT((NULL != pfnCompare));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));
    DBGASSERT((NULL != pfnCompare));

    return DPA_Sort(m_hdpa, pfnCompare, lParam);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Search

    Description: Searches the list for a given item.

    Arguments: 
        pvKey - Address of key item used for search.

        pfnCompare - Address of comparison callback.

        uOptions - Options controlling sort operation.
            DPAS_SORTED       = Array is already sorted.  
                                Will use binary search.
            DPAS_INSERTBEFORE = If no exact match is found, return index of
                                previous best match.
            DPAS_INSERTAFTER  = If no exact match is found, return index of
                                next best match.

        iStart - Index of where to start search.  0 for start of list.

        lParam - 32-bit parameter passed to the callback.

    Returns: Index of found item or -1 if none found.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/21/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
PointerList::Search(
    LPVOID pvKey,
    PFNDPACOMPARE pfnCompare, 
    UINT uOptions,
    INT iStart,
    LPARAM lParam
    )
{
    DBGASSERT((NULL != pfnCompare));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));
    DBGASSERT((NULL != pvKey));
    DBGASSERT((NULL != pfnCompare));

    return DPA_Search(m_hdpa, pvKey, iStart, pfnCompare, lParam, uOptions);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerListIterator::operator = 

    Description: Assignment for PointerListIterator.

    Arguments:
        rhs - Reference to constant iterator that is the rhs of the assignment.

    Returns:
        Returns a reference to "this" iterator object following the assignment.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/27/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PointerListIterator&
PointerListIterator::operator = (
    const PointerListIterator& rhs
    )
{
    if (this != &rhs)
    {
        m_pList = rhs.m_pList;
        m_Index = rhs.m_Index;
    }
    return *this;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerListIterator::Advance

    Description: Both the Next() and Prev() iterator functions call this
        one function.  It handles the actual iteration.

    Arguments:
        ppvOut - Address of pointer variable to contain the value of the 
            pointer at the "current" iterator location.  The iterator is
            advance (or retreated) after the pointer value is copied to the
            destination.

        bForward - TRUE  = Advance toward end of list.
                   FALSE = Advance toward front of list.

    Returns:
        NO_ERROR      - Iterator advanced.  Returned pointer is valid.
        E_FAIL        - Iterator already at begining or end of list.  Returned
                        pointer will be NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
PointerListIterator::Advance(
    LPVOID *ppvOut, 
    BOOL bForward
    )
{
    LPVOID pv       = NULL;
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != ppvOut));

    m_pList->Lock();
    if (0 < m_pList->Count() && m_Index != EndOfList)
    {
        //
        // Get pointer value at index "m_Index".
        //
        DBGASSERT((NULL != m_pList->m_hdpa));
        pv = DPA_GetPtr(m_pList->m_hdpa, m_Index);

        if (bForward)
        {
            //
            // Advance iterator index.
            //
            if ((UINT)(++m_Index) == m_pList->Count())
                m_Index = EndOfList;
        }
        else
        {
            //
            // Retreat iterator index.
            //
            m_Index--;  // Will be -1 (EndOfList) if currently 0.
        }
    }
    else
        hResult = E_FAIL;

    m_pList->ReleaseLock();

    *ppvOut = pv;  // Return pointer value.

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::StructureList

    Description: Constructor.

    Arguments:
        cbItem - Size of each item in bytes.

        cItemGrow - Number of items to grow array at each expansion.


    Returns: Nothing.

    Exceptions: OutOfMemory

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
StructureList::StructureList(
    INT cbItem, 
    INT cItemGrow
    )
{
    if (!InitializeCriticalSectionAndSpinCount(&m_cs, 0))
    {
        throw CAllocException();
    }

    if (NULL == (m_hdsa = DSA_Create(cbItem, cItemGrow)))
    {
        DeleteCriticalSection(&m_cs);
        throw CAllocException();
    }
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::~StructureList

    Description: Destructor.  Destroys the DSA and closes the mutex handle.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
StructureList::~StructureList(void)
{
    Lock();

    if (NULL != m_hdsa)
        DSA_Destroy(m_hdsa);

    ReleaseLock();
    DeleteCriticalSection(&m_cs);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureListIterator::operator = 

    Description: Assignment for StructureListIterator.

    Arguments:
        rhs - Reference to constant iterator that is the rhs of the assignment.

    Returns:
        Returns a reference to "this" iterator object following the assignment.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/27/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
StructureListIterator&
StructureListIterator::operator = (
    const StructureListIterator& rhs
    )
{
    if (this != &rhs)
    {
        m_pList = rhs.m_pList;
        m_Index = rhs.m_Index;
    }
    return *this;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Count

    Description: Returns the number of elements in the list.

    Arguments: None.

    Returns: Count of elements in list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT StructureList::Count(VOID)
{
    UINT n = 0;

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.

    DBGASSERT((NULL != m_hdsa));
    n = DSA_GetItemCount(m_hdsa);

    return n;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Insert

    Description: Insert an item into the Structure list at a given index.
        If the index is beyond the upper bounds of the array, the array
        is extended by one and the item is appended to the list.

    Arguments:
        pvItem - Address of item to add to list.

        index - List index where item is to be inserted.  All following
            items are shifted to one index higher.  The list automatically
            grows to accomodate as required.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
    09/06/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
StructureList::Insert(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);   // Get lock on container.  Will auto-release.

    DBGASSERT((NULL != m_hdsa));

    if (DSA_InsertItem(m_hdsa, index, pvItem) < 0)
    {
        throw CAllocException();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Replace

    Description: Replaces an item in the Structure list at a given index.
        If the index is beyond the upper bounds of the array, the array
        is extended by one and the item is appended to the list.

    Arguments:
        pvItem - Address of item to replace existing item.

        index - List index where item is to be replaced.  

    Returns:
        TRUE  - Success.
        FALSE - Invalid index or empty container.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
StructureList::Replace(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.

    DBGASSERT((NULL != m_hdsa));

    return DSA_SetItem(m_hdsa, index, pvItem);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Append

    Description: Appends an item to the end of the list.

    Arguments:
        pvItem - Address of item to add to list.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
    09/06/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
StructureList::Append(
    LPVOID pvItem
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container. Will auto-release.
    //
    // Yes, this is correct.  We're "inserting" an item to append something
    // to the list.  This saves a ( count - 1 ) calculation.
    //
    DBGASSERT((NULL != m_hdsa));
    Insert(pvItem, DSA_GetItemCount(m_hdsa));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Remove

    Description: Removes an item from the list at a given index.

    Arguments: 
        pvItem - Address of buffer to receive removed item.  Assumes buffer
            is sized properly.

        index - List index where item is to be removed.  All following
            items are shifted to one index lower. 

    Returns:
        TRUE  - Success.
        FALSE - Invalid index or container is empty.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
StructureList::Remove(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.
    DBGASSERT((NULL != m_hdsa));

    if (!DSA_GetItem(m_hdsa, index, pvItem) ||
        !DSA_DeleteItem(m_hdsa, index))
    {
        return FALSE;
    }
    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Retrieve

    Description: Retrieve an item from the list at a given index.
        The item value is merely copied and not removed from the list.

    Arguments:
        pvItem - Address of buffer to receive removed item.  Assumes buffer
            is sized properly.

        index - List index where item is to be retrieved.  

    Returns:
        TRUE  - Success.
        FALSE - Invalid index or empty container.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
StructureList::Retrieve(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.
    DBGASSERT((NULL != m_hdsa));

    if (!DSA_GetItem(m_hdsa, index, pvItem))
    {
        return FALSE;
    }
    return TRUE;
}

    
///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::RemoveLast

    Description: Removes the last item from the list.

    Arguments: 
        pvItem - Address of buffer to receive removed item.  Assumes buffer
            is sized properly.

    Returns:
        TRUE  - Success.
        FALSE - Empty container.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
StructureList::RemoveLast(
    LPVOID pvItem
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.

    DBGASSERT((NULL != m_hdsa));

    if (0 == DSA_GetItemCount(m_hdsa))
        return FALSE;

    Remove(pvItem, DSA_GetItemCount(m_hdsa) - 1);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::RetrieveLast

    Description: Retrieves the last pointer from the list.

    Arguments: 
        pvItem - Address of buffer to receive removed item.  Assumes buffer
            is sized properly.

    Returns:
        TRUE  - Success.
        FALSE - Empty container.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
StructureList::RetrieveLast(
    LPVOID pvItem
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.
    DBGASSERT((NULL != m_hdsa));

    if (0 == DSA_GetItemCount(m_hdsa))
        return FALSE;

    Retrieve(pvItem, DSA_GetItemCount(m_hdsa) - 1);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Clear

    Description: Removes all items from the list.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/26/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
StructureList::Clear(
    VOID
    )
{
    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.

    DBGASSERT((NULL != m_hdsa));
    DSA_DeleteAllItems(m_hdsa);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureListIterator::Advance

    Description: Both the Next() and Prev() iterator functions call this
        one function.  It handles the actual iteration.

    Arguments:
        ppvOut - Address of pointer variable to receive the address of the 
            item at the "current" iterator location.  The iterator is
            advance (or retreated) after the pointer value is copied to the
            destination.

        bForward - TRUE  = Advance toward end of list.
                   FALSE = Advance toward front of list.

    Returns:
        NO_ERROR      - Iterator advanced.  Returned pointer is valid.
        E_FAIL        - Iterator already at begining or end of list.  Returned
                        pointer will be NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
StructureListIterator::Advance(
    LPVOID *ppvOut, 
    BOOL bForward
    )
{
    LPVOID pv       = NULL;
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != ppvOut));

    m_pList->Lock();
    if (0 < m_pList->Count() && m_Index != EndOfList)
    {
        //
        // Get address of item at index "m_Index".
        //
        DBGASSERT((NULL != m_pList->m_hdsa));
        pv = DSA_GetItemPtr(m_pList->m_hdsa, m_Index);

        if (bForward)
        {
            //
            // Advance iterator index.
            //
            if ((UINT)(++m_Index) == m_pList->Count())
                m_Index = EndOfList;
        }
        else
        {
            //
            // Retreat iterator index.
            //
            m_Index--;  // Will be -1 (EndOfList) if currently 0.
        }
    }
    else
        hResult = E_FAIL;

    m_pList->ReleaseLock();
    *ppvOut = pv;  // Return pointer value.

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\control\userenum.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: enumuser.cpp

    Description: Contains member function definitions for class DiskQuotaUserEnum.
        The DiskQuotaUserEnum object is provided to enumerate the users in a 
        volume's quota information file.  The caller instantiates an enumerator
        through IDiskQuotaControl::CreateDiskQuotaUserEnum().  The enumerator's
        interface IEnumDiskQuotaUsers supports the normal OLE 2 enumeration
        functions Next(), Skip(), Reset() and Clone().

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "user.h"
#include "userenum.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif

///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::DiskQuotaUserEnum

    Description: Constructor.

    Arguments:
        pFSObject - Pointer to an existing "file system" object.  
            It is through this object that the enumerator accesses the ntioapi 
            functions.  A pointer to this file system object is also passed 
            on to contained user objects so they may refresh their data when 
            required.  

        pQuotaController - Pointer to an IDiskQuotaControl interface that we'll
            AddRef().  The control object is who provides the "name changed"
            notification mechanism.  It needs to stay around as long as the
            enumerator is alive.

        pSidNameResolver - Pointer to an ISidNameResolver interface that will
            be used to resolve user SIDs to account names.  The resolver object
            is initially instantiated by the quota controller.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/97    Moved pQuotaControl, pSidNameResolver and pFSObject  BrianAu
                arguments from Initialize() to ctor.  Needed so
                that ref counting is correct.
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUserEnum::DiskQuotaUserEnum(
    PDISKQUOTA_CONTROL pQuotaController,
    PSID_NAME_RESOLVER pSidNameResolver,
    FSObject *pFSObject
    ) : m_cRef(0),
        m_pbBuffer(NULL),
        m_pbCurrent(NULL),
        m_cbBuffer(0),
        m_pSidList(NULL),
        m_cbSidList(0),
        m_bEOF(FALSE),
        m_bSingleUser(FALSE),
        m_bInitialized(FALSE),
        m_bRestartScan(TRUE),
        m_fNameResolution(DISKQUOTA_USERNAME_RESOLVE_NONE),
        m_pFSObject(pFSObject),
        m_pQuotaController(pQuotaController),
        m_pSidNameResolver(pSidNameResolver)
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUserEnum::DiskQuotaUserEnum")));

    if (NULL != m_pQuotaController)
        m_pQuotaController->AddRef();

    if (NULL != m_pSidNameResolver)
        m_pSidNameResolver->AddRef();

    if (NULL != m_pFSObject)
        m_pFSObject->AddRef();

    InterlockedIncrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::~DiskQuotaUserEnum

    Description: Destructor.  Destroys the enumerator's internal buffers and
        releases any held interface pointers.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUserEnum::~DiskQuotaUserEnum(void)
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUserEnum::~DiskQuotaUserEnum")));

    if (NULL != m_pFSObject)
        m_pFSObject->Release();

    //
    // Order is important here.  Release the resolver before the controller.
    //
    if (NULL != m_pSidNameResolver)
        m_pSidNameResolver->Release();

    if (NULL != m_pQuotaController)
        m_pQuotaController->Release();

    delete [] m_pbBuffer;
    delete [] m_pSidList;

    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::QueryInterface

    Description: Obtain pointer to IUnknown or IEnumDiskQuotaUser.  Note that
        referenced object is uninitialized.  Recipient of interface pointer
        must call Initialize() member function before object is usable.

    Arguments:
        riid - Reference to requested interface ID.  IID_IUnknown and 
            IID_IEnumDiskQuotaUser are recognized.

        ppvOut - Address of interface pointer variable to accept the
            returned interface pointer.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUserEnum::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IEnumDiskQuotaUsers == riid)
    {
        //
        // Interface supported.
        //
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserEnum::AddRef(
    VOID
    )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserEnum::AddRef, 0x%08X  %d -> %d"), this, cRef - 1, cRef ));
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserEnum::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserEnum::Release, 0x%08X  %d -> %d"),
                     this, cRef + 1, cRef ));

    if ( 0 == cRef )
    {   
        delete this;
    }
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Initialize

    Description: Initializes a new enumerator object.
        This member function is overloaded to provide two
        implementations.  The first accepts explicit arguments for
        initialization.  This member is intended for creating a new unique
        enumerator through IDiskQuotaControl::CreateEnumUsers.  The
        second implementation merely accepts a reference to an existing 
        EnumUsers object.  This member is intended to support the function
        IEnumDiskQuotaUser::Clone().

    Arguments:
        fNameResolution - Method of SID-to-name resolution. Can be one of the 
            following:
                    DISKQUOTA_USERNAME_RESOLVE_NONE
                    DISKQUOTA_USERNAME_RESOLVE_SYNC
                    DISKQUOTA_USERNAME_RESOLVE_ASYNC
 
        cbBuffer [optional] - Size in bytes of the internal buffer used in 
            calls to the NTIOAPI functions.  Default is ENUMUSER_BUF_LEN.

        rgpSids [optional] - Pointer to a list of SID pointers.  If 
            provided, only those users with SIDs included in the list are 
            returned.  This argument may be NULL in which case ALL users are
            included.  Any element containing a NULL pointer will terminate
            the list.

        cpSids [optional] - If pSidList is not NULL, this arg contains
            the count of entries in rgpSids.  If rgpSids is not NULL and this 
            argument contains 0, rgpSids is assumed to contain a terminating
            NULL pointer entry.

        UserEnum - Reference to an existing DiskQuotaUserEnum object.  The new
            object opens a connection to the same volume as the object being
            cloned.  The new object maintains a separate buffer for transfer
            of data from the NTIOAPI system.

    Returns:
        NO_ERROR          - Success.
        S_FALSE           - Already initialized.
        E_OUTOFMEMORY     - Insufficient memory.
        ERROR_INVALID_SID (hr) - A SID in rgpSids was invalid.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::Initialize(
    DWORD fNameResolution,
    DWORD cbBuffer,
    PSID *rgpSids,
    DWORD cpSids
    )
{
    HRESULT hResult = NO_ERROR;

    if (m_bInitialized)
    {
        hResult = S_FALSE;
    }
    else
    {
        try
        {
            //
            // Create an internal buffer for data transfer from the ntioapi.
            //
            m_pbBuffer = new BYTE [cbBuffer];

            m_cbBuffer = cbBuffer;

            if (NULL != rgpSids)
            {
                //
                // A list of SID pointers was provided.
                // Initialize the SID list structure.
                // Can throw OutOfMemory.
                //
                m_bSingleUser = (cpSids == 1);
                hResult = InitializeSidList(rgpSids, cpSids);
            }

            if (SUCCEEDED(hResult))
            {
                //
                // Must have an independent instance of the controller's file system 
                // object.  The NTIOAPI functions maintain an enumeration context
                // for each open handle.  Therefore, each user enumerator must have a 
                // unique file handle to the NTIOAPI object.
                // I say this because it appears tempting to just keep a copy of the 
                // controller's FSObject pointer and AddRef it.
                //
                // This create-n-swap is sort of slimy.  We originally got a 
                // ptr to the caller's FSObject in the ctor.  However, now we want
                // to create our own FSObject.  Create a copy and release the original.
                //
                FSObject *pFsoTemp = m_pFSObject;
                m_pFSObject        = NULL;
                hResult = FSObject::Create(*pFsoTemp, &m_pFSObject);
                pFsoTemp->Release();

                if (SUCCEEDED(hResult))
                {
                    m_fNameResolution  = fNameResolution;
                    m_bInitialized     = TRUE;
                }
            }
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
    }

    return hResult;
}



HRESULT 
DiskQuotaUserEnum::Initialize(
    const DiskQuotaUserEnum& UserEnum
    )
{
    HRESULT hResult = NO_ERROR;

    try
    {
        //
        // Initialize the new enumerator without a SID list.
        // If the enumerator being copied has a SID list, we 
        // don't want to re-create a list of SID pointers for Initialize()
        // so we defer this for InitializeSidList.  InitializeSidList
        // has an overloaded version that accepts a pointer to an existing
        // SIDLIST structure and merely copies the bytes.
        //
        hResult = Initialize(UserEnum.m_fNameResolution,
                             UserEnum.m_cbBuffer,
                             NULL,
                             0);

        if (SUCCEEDED(hResult) && NULL != UserEnum.m_pSidList)
        {
            m_bSingleUser = UserEnum.m_bSingleUser;
            hResult = InitializeSidList(UserEnum.m_pSidList,
                                        UserEnum.m_cbSidList);
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::InitializeSidList

    Description: Initializes the m_pSidList member of the enumerator.
        The method comes in two overloaded forms.  The first accepts a pointer
        to an existing SIDLIST structure and merely creates a new copy.
        The second form accepts the address of an array of SID pointers and
        generates a new SIDLIST structure.

    Arguments:
        pSidList - Address of an existing SIDLIST structure to be copied.

        cbSidList - Number of bytes in the SIDLIST structure.

        rgpSids  - Pointer to a list of SID pointers.  If provided, only those 
            users with SIDs included in the list are returned.  This argument 
            may be NULL in which case ALL users are included.  Any element 
            containing a NULL pointer will terminate the list.

        cpSids - If pSidList is not NULL, this arg contains the count of 
            entries in rgpSids.  If rgpSids is not NULL and this argument 
            contains 0, rgpSids is assumed to contain a terminating NULL 
            pointer entry.

    Returns:
        NO_ERROR            - Success.
        ERROR_INVALID_SID (hr) - A SID in rgpSids was invalid.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/13/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUserEnum::InitializeSidList(
    PSIDLIST pSidList,
    DWORD cbSidList
    )
{
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != pSidList));
    DBGASSERT((0 < cbSidList));

    //
    // Create a buffer for the SID list copy.
    //
    m_pSidList = (PSIDLIST)new BYTE[cbSidList];

    //
    // Copy the enumerator's SID list.
    //
    CopyMemory(m_pSidList, pSidList, cbSidList);
    m_cbSidList = cbSidList;

    return hResult;
}


HRESULT
DiskQuotaUserEnum::InitializeSidList(
    PSID *rgpSids,
    DWORD cpSids
    )
{
    HRESULT hResult = NO_ERROR;
    
    DBGASSERT((NULL != rgpSids));
    DBGASSERT((0 < cpSids));

    //
    // Create a SIDLIST structure from the array of SID pointers.
    // Can throw OutOfMemory.
    //
    hResult = CreateSidList(rgpSids, cpSids, &m_pSidList, &m_cbSidList);

    if (FAILED(hResult))
    {
        DBGASSERT((NULL == m_pSidList));
        DBGASSERT((0 == m_cbSidList));
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::QueryQuotaInformation

    Description: Provides a simple wrapper around the NTIOAPI function
        QueryQuotaInformationFile. The function adds value by providing
        the address and size of the enumerator's data buffer.
        Note that the QueryQuotaInformationFile interface in NTIOAPI 
        functions as an enumerator itself.  Repeated calls enumerate
        user quota data much the same way the Next() function does in an OLE
        enumerator interface.  Data is returned in a byte buffer as a series
        of variable-length quota records.

    Arguments:
        bReturnSingleEntry [optional] - TRUE if only a single entry is
            desired.  FALSE if multiple records are desired.  Default is
            FALSE.

        pSidList [optional] - Pointer to a list of SIDs.  If provided, the
            data returned is only for those users included in the SID list.
            Default is NULL.

        cbSidList [optional] - If SidList is not NULL, contains length
            of SidList in bytes.  Default is 0.

        pStartSid [optional] - Pointer to SID in SID list where scan is to 
            start if bRestartScan is TRUE.  Default is NULL.

        bRestartScan [optional] - TRUE = restart enumeration at first user
            or user pointed to by StartSid in SidList (if provided).  
            FALSE = continue enumeration from current point.
            Default is FALSE.

    Returns:
        NO_ERROR             - Success.
        ERROR_NO_MORE_ITEMS  - No more user records.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::QueryQuotaInformation(
    BOOL bReturnSingleEntry, 
    PVOID pSidList,           
    ULONG cbSidList,     
    PSID pStartSid,           
    BOOL bRestartScan        
    )
{
    HRESULT hResult = NO_ERROR;
    
    if (bRestartScan)
    {
        //
        // Reset EOF flag if restarting enumerator scan.
        //
        m_bEOF = FALSE;
    }

    if (!m_bEOF)
    {
        ZeroMemory(m_pbBuffer, m_cbBuffer);
    
        hResult = m_pFSObject->QueryUserQuotaInformation(
                        m_pbBuffer,
                        m_cbBuffer,
                        bReturnSingleEntry,
                        pSidList,
                        cbSidList,
                        pStartSid,
                        bRestartScan);

        if (ERROR_SUCCESS == HRESULT_CODE(hResult) || ERROR_NO_MORE_ITEMS == HRESULT_CODE(hResult))
        {
            //
            // The enumeration logic changed between Win2000 and WinXP.
            // On Win2000, NTFS will return ERROR_NO_MORE_ITEMS on the last
            // buffer returned that contains data.  On WinXP, this error
            // code is returned on the first buffer that returns NO data.
            // To handle both cases, we zero out the buffer before reading data
            // and inspect the SidLength value in the first record to determine
            // if the buffer contains any data.  If the sid length is 0, we 
            // can assume the buffer is empty.
            //
            hResult = NO_ERROR;
        }
    }
    else
    {
        //
        // There REALLY are no more entries.
        //
        hResult = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::CreateUserObject

    Description: Creates a new DiskQuotaUser object from the quota information
        retrieved through QueryQuotaInformation.  The caller provides a pointer
        to the start of the desired quota info record to be used for 
        initialization.

    Arguments:
        pfqi - Pointer to the quota information record used for initialization.

        ppOut - Address of interface pointer variable to accept the user object's
            IDiskQuotaUser interface pointer.

    Returns:
        NO_ERROR                - Success.
        E_INVALIDARG            - pfqi or ppOut arg is NULL.
        E_UNEXPECTED            - Unexpected error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::CreateUserObject(
    PFILE_QUOTA_INFORMATION pfqi, 
    PDISKQUOTA_USER *ppOut
    )
{
    HRESULT hResult = NO_ERROR;

    if (NULL == pfqi || NULL == ppOut)
        return E_INVALIDARG;

    //
    // Create the user object and get the IDiskQuotaUser interface pointer.
    // This pointer is what is given to the caller.
    //
    m_pFSObject->AddRef();
    DiskQuotaUser *pUser = new DiskQuotaUser(m_pFSObject);

    //
    // Initialize the new user object using the buffered quota data pointed to
    // by pfqi.
    //
    hResult = pUser->Initialize(pfqi);

    if (SUCCEEDED(hResult))
    {
        hResult = pUser->QueryInterface(IID_IDiskQuotaUser, (LPVOID *)ppOut);
    }

    if (FAILED(hResult))
    {
        //
        // Either Initialize or QueryInterface failed.  Delete the object.
        //
        delete pUser;
        pUser = NULL;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::GetNextUser

    Description: Creates a new user object from the "current" record in the
        quota information buffer. A pointer to the object's IDiskQuotaUser
        interface is returned and the "current" record pointer in the 
        quota information buffer is advanced to the next user record.

    Arguments:
        ppOut [optional] - Address of interface pointer variable to receive 
            address of user object's IDiskQuotaUserInterface pointer.  If this
            argument is NULL, the new user object is not created.  This is 
            useful for skipping items in the enumeration.

    Returns:
        NO_ERROR                 - Success.
        E_DISKQUOTA_INVALID_SID  - User record's SID is invalid.
        ERROR_NO_MORE_ITEMS      - No more users.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::GetNextUser(
    PDISKQUOTA_USER *ppOut
    )
{
    PFILE_QUOTA_INFORMATION pfqi = (PFILE_QUOTA_INFORMATION)m_pbCurrent;
    HRESULT hResult              = NO_ERROR;

    //
    // If m_pbCurrent is NULL, this is the first request for data.
    // If pfqi->NextEntryOffset is 0, we need to read another buffer of data.
    //
    if (NULL == m_pbCurrent)
    {
        //
        // No more user entries in buffer.
        // Read quota information into m_pbBuffer.
        // Use SID list if we have one.
        //
        hResult = QueryQuotaInformation(m_bSingleUser,   // Single user?
                                        m_pSidList,      // SID list.
                                        m_cbSidList,     // SID list length.
                                        0,               // Start SID,
                                        m_bRestartScan); // Restart scan?
        if (SUCCEEDED(hResult))
        {
            //
            // New information in buffer. Reset record pointers.
            //
            m_pbCurrent    = m_pbBuffer;
            m_bRestartScan = FALSE;
            pfqi = (PFILE_QUOTA_INFORMATION)m_pbCurrent;
        }
    }

    if (SUCCEEDED(hResult))
    {
        //
        // We have a valid pointer into the buffer of user quota data.
        //
        if (NULL != ppOut)
        {
            if (0 != pfqi->SidLength)
            {
                // 
                // Caller provided a user interface pointer variable.
                // Create a new user record.  This can throw OutOfMemory.
                //
                hResult = CreateUserObject(pfqi, ppOut);
            }
            else
            {
                m_bEOF  = TRUE;
                hResult = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            }
        }

        if (0 != pfqi->NextEntryOffset)
            m_pbCurrent += pfqi->NextEntryOffset; // Advance to next user.
        else
            m_pbCurrent = NULL;  // Reset to trigger quota file read.

    }
    return hResult;
}    


    
///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Next

    Description: Retrieve the next cUsers records from the volume's quota
        information file.  If the enumerator was created with a SidList,
        only those users contained in the SidList are included in the 
        enumeration.  Repeated calls to Next() continue to enumerate
        successive quota users.   The Reset() function may be used to 
        reset the enumerator to the start of the enumeration.  

    Arguments:
        cUsers - Number of elements in paUsers array.

        pUser - Array of IDiskQuotaUser pointers.  Must provide space for 
            cUsers pointers. Upon return, each element of this array contains 
            an interface pointer to a DiskQuotaUser object.

        pcCreated [optional] - Address of DWORD to accept the count of user 
            object interface pointers returned in pUser.  Note that any 
            array locations equal to or beyond the value returned in 
            pcCreated are invalid and set to NULL.

    Returns:
        S_OK            - Success.  Enumerated number of requested users.
        S_FALSE         - End of enumeration encountered.  Returning less than
                          cUsers records.
        E_INVALIDARG    - pUser arg is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::Next(
    DWORD cUsers,                        // Number of elements in array.
    PDISKQUOTA_USER *pUser,              // Dest array for quota user interface ptrs.
    DWORD *pcCreated                     // Return number created.
    )
{
    HRESULT hResult = S_OK;
    UINT i          = 0;                // Index into user caller's array.
    UINT cCreated   = 0;

    if (NULL == pUser)
        return E_INVALIDARG;

    if (NULL != pcCreated)
        *pcCreated = 0;

    try
    {
        IDiskQuotaUser *pNextUser = NULL;   // Ptr to new user.

        //
        // Enumerate user records until one of the following:
        // 1. Failure.
        // 2. No more users.
        // 3. Enumerated requested count.
        //
        while(SUCCEEDED(hResult) && cUsers > 0)
        {
            //
            // Create new user object.  This can throw OutOfMemory.
            //
            hResult = GetNextUser(&pNextUser);
            if (SUCCEEDED(hResult))
            {
                //
                // User records come from the quota file containing only a SID.
                // We must ask the SidNameResolver to locate the corresponding
                // account name.  If client wants names synchronously, we block
                // here until account name is found.  User object will contain
                // account name.
                // If client wants names asynchronously, the user object is handed
                // off to the resolver for background processing.  We continue on.
                // If the client implemented the IDiskQuotaEvents interface and
                // called IConnectionPoint::Advise, it will receive a 
                // OnUserNameChange notification when the name is finally resolved.
                // If user doesn't want user name resolved, don't do either. 
                // This would be the case if the client already has the SID/Name
                // pair and just wants user objects.
                //
                switch(m_fNameResolution)
                {
                    case DISKQUOTA_USERNAME_RESOLVE_ASYNC:
                        m_pSidNameResolver->FindUserNameAsync(pNextUser);
                        break;
                    case DISKQUOTA_USERNAME_RESOLVE_SYNC:
                        m_pSidNameResolver->FindUserName(pNextUser);
                        break;
                    case DISKQUOTA_USERNAME_RESOLVE_NONE:
                    default:
                        break;
                }

                //
                // Note: Ref count for pUser already incremented in 
                // DiskQuotaUser::QueryInterface.
                //
                *pUser = pNextUser;
                pUser++;
                cUsers--;
                cCreated++;
            }
        }

        if (NULL != pcCreated)
            *pcCreated = cCreated; // If requested, return number of users created.

        if (cUsers > 0)
        {
            //
            // Less than requested number of users were retrieved.
            // 
            hResult = S_FALSE;
            while(cUsers > 0)
            {
                //
                // Set any un-filled array elements to NULL.
                //
                *pUser = NULL;
                pUser++;
                cUsers--;
            }
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    if (FAILED(hResult))
    {
        //
        // Release any user objects already created.
        //
        for (i = 0; i < cCreated; i++)
        {
            PDISKQUOTA_USER pu = *(pUser + i);
            if (NULL != pu)
            {
                pu->Release();
                *(pUser + i) = NULL;
            }
        }

        *pcCreated = 0;        
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Skip

    Description: Skips a specified number of users in the user enumeration.

    Arguments:
        cUsers - Number of users to skip.

    Returns:
        S_OK            - Success.  Skipped number of requested users.
        S_FALSE         - End of enumeration encountered.  Skipped less than
                          cUsers records.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::Skip(
    DWORD cUsers
    )
{
    while(cUsers > 0 && SUCCEEDED(GetNextUser(NULL)))
    {
        cUsers--;
    }

    return cUsers == 0 ? S_OK : S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Reset

    Description: Resets the enumerator object so that the next call to Next()
        starts enumerating at the beginning of the enumeration.

    Arguments: None.

    Returns:
        Always returns S_OK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    02/09/99    Changed so we just reset m_pbCurrent and             BrianAu
                m_bRestartScan.
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUserEnum::Reset(
    VOID
    )
{
    m_pbCurrent    = NULL;
    m_bRestartScan = TRUE;
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Clone

    Description: Creates a duplicate of the enumerator object and returns
        a pointer to the new object's IEnumDiskQuotaUser interface.

    Arguments:
        ppOut - Address of interface pointer variable to accept the pointer
            to the new object's IEnumDiskQuotaUser interface.

    Returns:
        NO_ERROR        - Success.
        E_OUTOFMEMORY   - Insufficient memory to create new enumerator.
        E_INVALIDARG    - ppOut arg was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUserEnum::Clone(
    PENUM_DISKQUOTA_USERS *ppOut
    )
{
    HRESULT hResult = NO_ERROR;

    if (NULL == ppOut)
        return E_INVALIDARG;

    try
    {
        DiskQuotaUserEnum *pUserEnum = new DiskQuotaUserEnum(
                                                m_pQuotaController,
                                                m_pSidNameResolver,
                                                m_pFSObject);

        hResult = pUserEnum->Initialize(*this);

        if (SUCCEEDED(hResult))
        {
            hResult = pUserEnum->QueryInterface(IID_IEnumDiskQuotaUsers, 
                                               (LPVOID *)ppOut);
        }

        if (FAILED(hResult))
        {
            //
            // Either Initialize or QueryInterface failed.
            //
            delete pUserEnum;
            pUserEnum = NULL;
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    return hResult;
}

    

DiskQuotaUserCollection::DiskQuotaUserCollection(
    PDISKQUOTA_CONTROL pController,
    DWORD fNameResolution

    ) : m_cRef(0),
        m_pController(pController),
        m_pEnum(NULL),
        m_fNameResolution(fNameResolution)
{
    if (NULL != m_pController)
    {
        m_pController->AddRef();
    }
}

DiskQuotaUserCollection::~DiskQuotaUserCollection(
    VOID
    )
{
    if (NULL != m_pEnum)
    {
        m_pEnum->Release();
    }
    if (NULL != m_pController)
    {
        m_pController->Release();
    }
}


HRESULT
DiskQuotaUserCollection::Initialize(
    VOID
    )
{
    HRESULT hr = S_FALSE; // Assume already initialized.

    if (NULL == m_pEnum)
    {
        if (NULL == m_pController)
        {
            hr = E_UNEXPECTED;
        }
        else
        {
            hr = m_pController->CreateEnumUsers(NULL,
                                                0,
                                                m_fNameResolution,
                                                &m_pEnum);
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserCollection::QueryInterface

    Description: Obtain pointer to IUnknown or IEnumDiskQuotaUserVARIANTs.  

    Arguments:
        riid - Reference to requested interface ID.  

        ppvOut - Address of interface pointer variable to accept the
            returned interface pointer.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUserCollection::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || 
        IID_IEnumVARIANT == riid)
    {
        //
        // Interface supported.
        //
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserCollection::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserCollection::AddRef(
    VOID
    )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserCollection::AddRef, 0x%08X  %d -> %d"), this, cRef - 1, cRef ));
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserCollection::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserCollection::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserCollection::Release, 0x%08X  %d -> %d"),
                     this, cRef + 1, cRef));

    if ( 0 == cRef )
    {   
        delete this;
    }
    return cRef;
}


STDMETHODIMP
DiskQuotaUserCollection::Next(
    DWORD cUsers,
    VARIANT *rgvar,
    DWORD *pcUsersFetched
    )
{
    HRESULT hr = E_UNEXPECTED;
    try
    {
        if (NULL == pcUsersFetched && 1 < cUsers)
        {
            //
            // If pcUsersFetched is NULL, cUsers must be 1.
            //
            hr = E_INVALIDARG;
        }
        else
        {
            DWORD cEnumerated = 0;
            PDISKQUOTA_USER *prgUsers = new PDISKQUOTA_USER[cUsers];
            if (NULL != prgUsers)
            {
                hr = m_pEnum->Next(cUsers, prgUsers, &cEnumerated);
                if (SUCCEEDED(hr))
                {
                    for (INT i = 0; i < (INT)cEnumerated; i++)
                    {
                        VariantInit(&rgvar[i]);

                        IDispatch *pIDisp = NULL;
                        hr = prgUsers[i]->QueryInterface(IID_IDispatch, (LPVOID *)&pIDisp);
                        if (SUCCEEDED(hr))
                        {
                            V_VT(&rgvar[i])       = VT_DISPATCH;
                            V_DISPATCH(&rgvar[i]) = pIDisp;
                        }
                        prgUsers[i]->Release();
                    }
                }
                delete[] prgUsers;
            }
            if (NULL != pcUsersFetched)
            {
                *pcUsersFetched = cEnumerated;
            }
        }
    }
    catch(CAllocException& e)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


STDMETHODIMP
DiskQuotaUserCollection::Skip(
    DWORD cUsers
    )
{
    return m_pEnum->Skip(cUsers);
}

STDMETHODIMP
DiskQuotaUserCollection::Reset(
    void
    )
{
    return m_pEnum->Reset();
}


STDMETHODIMP
DiskQuotaUserCollection::Clone(
    IEnumVARIANT **ppEnum
    )
{
    HRESULT hr = E_FAIL;
    try
    {
        DiskQuotaUserCollection *pEnum = new DiskQuotaUserCollection(m_pController,
                                                                     m_fNameResolution);
        if (NULL != pEnum)
        {
            hr = pEnum->Initialize();
            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(IID_IEnumVARIANT, (LPVOID *)ppEnum);
            }
            else
            {
                delete pEnum;
            }
        }
    }
    catch(CAllocException& me)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\details.h ===
#ifndef _INC_DSKQUOTA_DETAILS_H
#define _INC_DSKQUOTA_DETAILS_H
///////////////////////////////////////////////////////////////////////////////
/*  File: details.h

    Description: Declaration for class DetailsView.
        This is a complex class but don't be intimidated by it.
        Much of the functionality has been layered in private subclasses
        so that the scope of any individual piece is minimized.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    12/06/96    Removed INLINE from message handler methods.         BrianAu
                It's just too hard to debug when they're inline.
    05/28/97    Major changes.                                       BrianAu
                - Added "User Finder".
                - Added promotion of selected item to front of
                  name resolution queue.
                - Improved name resolution status reporting through
                  listview.
                - Moved drag/drop and report generation code
                  from dragdrop.cpp and reptgen.cpp into the
                  DetailsView class.  DetailsView now implements
                  IDataObject, IDropSource and IDropTarget instead
                  of deferring implementation to secondary objects.
                  dragdrop.cpp and reptgen.cpp have been dropped
                  from the project.
                - Added support for CF_HDROP and private import/
                  export clipboard formats.
                - Added import/export functionality.
    07/28/97    Removed export support for CF_HDROP.  Replaced       BrianAu
                with FileContents and FileGroupDescriptor.  Import
                from CF_HDROP is still supported.
                Added Import Source object hierarchy.
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_CONTROL_H
#   include "control.h"
#endif
#ifndef _INC_DSKQUOTA_UNDO_H
#   include "undo.h"
#endif
#ifndef _INC_DSKQUOTA_FORMAT_H
#   include "format.h"
#endif
#ifndef _INC_DSKQUOTA_PROGRESS_H
#   include "progress.h"
#endif

//
// Custom messages for this implementation.
//
#define WM_MAINWINDOW_CREATED         (WM_USER + 1)
#define WM_ADD_USER_TO_DETAILS_VIEW   (WM_USER + 2)
#define WM_DEL_USER_FROM_DETAILS_VIEW (WM_USER + 3)


//
// Structure containing column definition data for the listview.
//
struct DV_COLDATA
{
    int fmt;
    int cx;
    DWORD idMsgText;
    int iColId;
};


//
// Listview report item structure.
// Used for obtaining text/numeric data for a given item in the listview
// for purposes of generating a drag-drop data source.
//
typedef struct
{
    DWORD  fType;
    LPTSTR pszText;
    UINT   cchMaxText;
    DWORD  dwValue;
    double dblValue;
} LV_REPORT_ITEM, *PLV_REPORT_ITEM;

//
// Listview Report Item (LVRI) type constants (fType)
// These indicate what type of data is requested for a LV_REPORT_ITEM and
// also what type of data is provided in LV_REPORT_ITEM.  A caller of
// DetailsView::GetReportItem provides an LV_REPORT_ITEM that acts as the
// communication mechanism between the caller and the DetailsView.  The
// caller fills in the fType member indicating what format of information
// is desired for that row/col item.  The request may be any one of the
// following constants:
//
//      LVRI_TEXT   = Would like data in text format if possible.
//      LVRI_INT    = Would like data in integer format if possible.
//      LVRI_REAL   = Would like data in floating point format if possible.
//      LVRI_NUMBER = Would like data in either INT or REAL format if possible.
//
// This value in fType is merely a hint.  If the data can't be provided in the
// requested format, the next best format is supplied.  Upon return, the fType
// flag may be modified to indicate the actual format of the data returned.
// This value may be either LVRI_TEXT, LVRI_INT or LVRI_REAL.  LVRI_NUMBER is
// only used for hinting by the caller.
//
const DWORD LVRI_TEXT   = 0x00000001;
const DWORD LVRI_INT    = 0x00000002;
const DWORD LVRI_REAL   = 0x00000004;
const DWORD LVRI_NUMBER = (LVRI_INT | LVRI_REAL);

//
// Structure of "ListViewState" information stored in registry per-user.
// Note that we include the structure size and the screen width/height
// to validate the information when we read it from the registry.  If the
// structure size has changed, we don't trust the data and use defaults.
// If the screen size has changed, we use defaults.
//
//
//
// WARNING: I really don't like this but...
//          The size of the rgcxCol[] member must be at least as large
//          as the value of DetailsView::idCol_Last.  Because of the
//          order dependencies of the LV_STATE_INFO and DetailsView
//          structures, I can't use idCol_Last in this declaration.
//          If you have to add a new column and change the value of
//          idCol_Last, make sure the size of rgcxCol[] is adjusted
//          appropriately.  Also adjust rgColIndices[].
//
typedef struct
{
    WORD cb;                   // Count of bytes in structure.
    WORD wVersion;             // Version of state info (for upgrades).
    LONG cxScreen;             // Screen width.
    LONG cyScreen;             // Screen height.
    LONG cx;                   // Width of window (pixels).
    LONG cy;                   // Height of window (pixels).
    WORD fToolBar       :  1;  // Toolbar visible?
    WORD fStatusBar     :  1;  // Status bar visible?
    WORD fShowFolder    :  1;  // Folder column visible?
    WORD iLastColSorted :  4;  // Current sort column.
    WORD fSortDirection :  1;  // 0 = Ascending, 1 = Descending.
    WORD fReserved      :  8;  // Unused bits.
    INT  rgcxCol[8];           // Width of each column (pixels).
    INT  rgColIndices[8];      // Order of subitems in listview.

} LV_STATE_INFO, *PLV_STATE_INFO;

//
// Increment this if you make a change that causes problems with
// state info saved for existing users.  It will cause us to invalidate
// any existing state information and to use defaults.  It may cancel
// any user's existing preferences but at least the view will look OK.
//
const WORD wLV_STATE_INFO_VERSION = 3;

//
// This class maps our column ids (idCol_XXXX) to a listview column
// index (SubItem).
//
class ColumnMap
{
    private:
        INT *m_pMap;
        UINT m_cMapSize;

        //
        // Prevent copying.
        //
        ColumnMap(const ColumnMap&);
        void operator = (const ColumnMap&);

    public:
        ColumnMap(UINT cMapSize);
        ~ColumnMap(VOID);

        INT SubItemToId(INT iSubItem) const;
        INT IdToSubItem(INT iColId) const;
        VOID RemoveId(INT iSubItem);
        VOID InsertId(INT iSubItem, INT iColId);
};


class DetailsView : public IDiskQuotaEvents,
                    public IDropSource,
                    public IDropTarget,
                    public IDataObject
{
    private:
        //
        // DetailsView::Finder ------------------------------------------------
        //
        //
        // This class implements the "find a user" feature.
        // 1. "Attaches" to the "find" combo box in the toolbar by subclassing
        //     that combo box window.
        // 2. Invokes the "Find User" dialog on command.
        // 3. Repositions the listview highlight bar on a user if found.
        // 4. Maintains an MRU list for populating the toolbar and dialog
        //    combo boxes.
        //
        class Finder
        {
            public:
                Finder(DetailsView& DetailsView, INT cMaxMru);
                VOID ConnectToolbarCombo(HWND hwndToolbarCombo);
                VOID InvokeFindDialog(HWND hwndParent);

                static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
                static LRESULT CALLBACK ToolbarComboSubClassWndProc(HWND, UINT, WPARAM, LPARAM);

            private:
                HWND m_hwndToolbarCombo;    // Combo box in toolbar.
                INT  m_cMaxComboEntries;    // Max entries allowed in combo MRU.
                DetailsView& m_DetailsView; // Reference to associated details view.
                WNDPROC m_pfnOldToolbarComboWndProc; // Saved wnd proc address.

                VOID AddNameToCombo(HWND hwndCombo, LPCTSTR pszName, INT cMaxEntries);
                BOOL UserNameEntered(HWND hwndCombo);
                VOID FillDialogCombo(HWND hwndComboSrc, HWND hwndComboDest);

                //
                // Prevent copy.
                //
                Finder(const Finder& rhs);
                Finder& operator = (const Finder& rhs);
        };

        //
        // DetailsView::Importer ----------------------------------------------
        //
        class Importer
        {
            public:
                Importer(DetailsView& DV);
                ~Importer(VOID);

                HRESULT Import(IDataObject *pIDataObject);
                HRESULT Import(const FORMATETC& fmt, const STGMEDIUM& medium);
                HRESULT Import(LPCTSTR pszFilePath);
                HRESULT Import(HDROP hDrop);

            private:
                //
                // DetailsView::Importer::AnySource ---------------------------
                //
                // This small hierarchy of "Source" classes is here to insulate
                // the import process from the import source.  There are two
                // basic forms of import source data; OLE stream and memory-
                // mapped file.  So that we only have one function that actually
                // contains the import logic, this layer of abstraction insulates
                // that import function from any differences between streams
                // and simple memory blocks.
                // Instead of calling Import(pStream) or Import(pbBlock), a
                // client uses Import(Source(pIStream)) or Import(Source(pbBlock)).
                // The Source object uses the virtual constructor technique to
                // create the correct object for the input source.  Each
                // descendant of AnySource implements the single Read() function
                // to read data from it's specific source.
                //
                class AnySource
                {
                    public:
                        AnySource(VOID) { }
                        virtual ~AnySource(VOID) { }
                        virtual HRESULT Read(LPVOID pvOut, ULONG cb, ULONG *pcbRead) = 0;

                    private:
                        //
                        // Prevent copy.
                        //
                        AnySource(const AnySource& rhs);
                        AnySource& operator = (const AnySource& rhs);
                };

                //
                // DetailsView::Importer::StreamSource ------------------------
                //
                class StreamSource : public AnySource
                {
                    public:
                        StreamSource(IStream *pStm);
                        virtual ~StreamSource(VOID);

                        virtual HRESULT Read(LPVOID pvOut, ULONG cb, ULONG *pcbRead);

                    private:
                        IStream *m_pStm;

                        //
                        // Prevent copy.
                        //
                        StreamSource(const StreamSource& rhs);
                        StreamSource& operator = (const StreamSource& rhs);
                };

                //
                // DetailsView::Importer::MemorySource ------------------------
                //
                class MemorySource : public AnySource
                {
                    public:
                        MemorySource(LPBYTE pb, ULONG cbMax);
                        virtual ~MemorySource(VOID) { };

                        virtual HRESULT Read(LPVOID pvOut, ULONG cb, ULONG *pcbRead);

                    private:
                        LPBYTE m_pb;
                        ULONG  m_cbMax;

                        //
                        // Prevent copy.
                        //
                        MemorySource(const MemorySource& rhs);
                        MemorySource& operator = (const MemorySource& rhs);
                };

                //
                // DetailsView::Importer::Source ------------------------------
                //
                class Source
                {
                    public:
                        Source(IStream *pStm);
                        Source(LPBYTE pb, ULONG cbMax);

                        virtual ~Source(VOID);

                        virtual HRESULT Read(LPVOID pvOut, ULONG cb, ULONG *pcbRead);

                    private:
                        AnySource *m_pTheSource;

                        //
                        // Prevent copy.
                        //
                        Source(const Source& rhs);
                        Source& operator = (const Source& rhs);
                };


                //
                // These two import functions are the real workers.
                // All other import functions eventually end up at
                // Import(Source& ) which calls Import(pbSid, Threshold, Limit)
                // to import each user record.
                //
                HRESULT Import(Source& source);
                HRESULT Import(LPBYTE pbSid, LONGLONG llQuotaThreshold,
                                             LONGLONG llQuotaLimit);

                VOID Destroy(VOID);
                HWND GetTopmostWindow(VOID);

                DetailsView&   m_DV;
                BOOL           m_bUserCancelled;   // User cancelled import.
                BOOL           m_bPromptOnReplace; // Prompt user when replacing record?
                ProgressDialog m_dlgProgress;      // Progress dialog.
                HWND           m_hwndParent;       // Parent HWND for any UI elements.
                INT            m_cImported;        // Number of records imported.

                //
                // Prevent copy.
                //
                Importer(const Importer& rhs);
                Importer& operator = (const Importer& rhs);
        };

        //
        // DetailsView::DataObject --------------------------------------------
        //
        class DataObject
        {
            public:
                DataObject(DetailsView& DV);
                ~DataObject(VOID);

                HRESULT IsFormatSupported(FORMATETC *pFormatEtc);
                HRESULT RenderData(FORMATETC *pFormatEtc, STGMEDIUM *pMedium);

                static VOID SetFormatEtc(FORMATETC& fe,
                                         CLIPFORMAT cfFormat,
                                         DWORD tymed,
                                         DWORD dwAspect = DVASPECT_CONTENT,
                                         DVTARGETDEVICE *ptd = NULL,
                                         LONG lindex = -1);

                static LPSTR WideToAnsi(LPCWSTR pszTextW);

                static const INT   CF_FORMATS_SUPPORTED;
                static LPCWSTR     SZ_EXPORT_STREAM_NAME;
                static LPCTSTR     SZ_EXPORT_CF_NAME;
                static const DWORD EXPORT_STREAM_VERSION;

                LPFORMATETC  m_rgFormats;            // Array of supported formats.
                DWORD        m_cFormats;             // Number of supported formats.
                static CLIPFORMAT m_CF_Csv;                // Comma-separated fields format.
                static CLIPFORMAT m_CF_RichText;           // RTF format.
                static CLIPFORMAT m_CF_NtDiskQuotaExport;  // Internal fmt for import/export.
                static CLIPFORMAT m_CF_FileGroupDescriptor;// Used by shell for drop to folder.
                static CLIPFORMAT m_CF_FileContents;       // Used by shell for drop to folder.

            private:
                //
                // DetailsView::DataObject::Renderer --------------------------
                //
                class Renderer
                {
                    protected:
                        //
                        // DetailsView::DataObject::Renderer::Stream ----------
                        //
                        class Stream
                        {
                            private:
                                IStream *m_pStm;

#ifdef CLIPBOARD_DEBUG_OUTPUT

                                IStorage *m_pStgDbgOut; // For debugging clipboard output.
                                IStream  *m_pStmDbgOut; // For debugging clipboard output.

#endif  // CLIPBOARD_DEBUG_OUTPUT
                                //
                                // Prevent copy.
                                //
                                Stream(const Stream& rhs);
                                Stream& operator = (const Stream& rhs);

                            public:
                                Stream(IStream *pStm = NULL);
                                ~Stream(VOID);

                                VOID SetStream(IStream *pStm);
                                IStream *GetStream(VOID)
                                    { return m_pStm; }

                                VOID Write(LPBYTE pbData, UINT cbData);
                                VOID Write(LPCSTR pszTextA);
                                VOID Write(LPCWSTR pszTextW);
                                VOID Write(BYTE bData);
                                VOID Write(CHAR chDataA);
                                VOID Write(WCHAR chDataW);
                                VOID Write(DWORD dwData);
                                VOID Write(double dblData);
                        };


                        DetailsView& m_DV;   // Details view is source of data.
                        Stream       m_Stm;  // Stream on which report is writtn.

                        virtual VOID Begin(INT cRows, INT cCols) { }
                        virtual VOID AddTitle(LPCWSTR pszTitleW) { }
                        virtual VOID BeginHeaders(VOID) { }
                        virtual VOID AddHeader(LPCWSTR pszHeaderW) { }
                        virtual VOID AddHeaderSep(VOID) { }
                        virtual VOID EndHeaders(VOID) { }
                        virtual VOID BeginRow(VOID) { }
                        virtual VOID AddRowColData(INT iRow, INT idCol) { }
                        virtual VOID AddRowColSep(VOID) { }
                        virtual VOID EndRow(VOID) { }
                        virtual VOID End(VOID) { }

                        //
                        // Prevent copy.
                        //
                        Renderer(const Renderer& rhs);
                        Renderer& operator = (const Renderer& rhs);


                    public:
                        Renderer(DetailsView& DV)
                            : m_DV(DV) { }

                        virtual ~Renderer(VOID) { }

                        virtual VOID Render(IStream *pStm);
                };

                //
                // DetailsView::DataObject::Renderer_UNICODETEXT --------------
                //
                class Renderer_UNICODETEXT : public Renderer
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_UNICODETEXT(const Renderer_UNICODETEXT& rhs);
                        Renderer_UNICODETEXT& operator = (const Renderer_UNICODETEXT& rhs);

                    protected:
                        virtual VOID AddTitle(LPCWSTR pszTitleW);

                        virtual VOID AddHeader(LPCWSTR pszHeaderW)
                            { m_Stm.Write(pszHeaderW); }

                        virtual VOID AddHeaderSep(VOID)
                            { m_Stm.Write(L'\t'); }

                        virtual VOID EndHeaders(VOID)
                            { m_Stm.Write(L'\r'); m_Stm.Write(L'\n'); }

                        virtual VOID AddRowColData(INT iRow, INT idCol);

                        virtual VOID AddRowColSep(VOID)
                            { m_Stm.Write(L'\t'); }

                        virtual VOID EndRow(VOID)
                            { m_Stm.Write(L'\r'); m_Stm.Write(L'\n'); }

                    public:
                        Renderer_UNICODETEXT(DetailsView& DV)
                            : Renderer(DV) { }

                        virtual ~Renderer_UNICODETEXT(VOID) { }
                };

                //
                // DetailsView::DataObject::Renderer_TEXT ---------------------
                //
                class Renderer_TEXT : public Renderer_UNICODETEXT
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_TEXT(const Renderer_TEXT& rhs);
                        Renderer_TEXT& operator = (const Renderer_TEXT& rhs);

                    protected:
                        virtual VOID AddTitle(LPCWSTR pszTitleW);

                        virtual VOID AddHeader(LPCWSTR pszHeaderW);

                        virtual VOID AddHeaderSep(VOID)
                            { m_Stm.Write('\t'); }

                        virtual VOID EndHeaders(VOID)
                            { m_Stm.Write('\r'); m_Stm.Write('\n'); }

                        virtual VOID AddRowColData(INT iRow, INT idCol);

                        virtual VOID AddRowColSep(VOID)
                            { m_Stm.Write('\t'); }

                        virtual VOID EndRow(VOID)
                            { m_Stm.Write('\r'); m_Stm.Write('\n'); }

                    public:
                        Renderer_TEXT(DetailsView& DV)
                            : Renderer_UNICODETEXT(DV) { }

                        virtual ~Renderer_TEXT(VOID) { }
                };


                //
                // DetailsView::DataObject::Renderer_Csv ----------------------
                //
                class Renderer_Csv : public Renderer_TEXT
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_Csv(const Renderer_Csv& rhs);
                        Renderer_Csv& operator = (const Renderer_Csv& rhs);

                    protected:
                        virtual VOID AddHeaderSep(VOID)
                            { m_Stm.Write(','); }

                        virtual VOID AddRowColSep(VOID)
                            { m_Stm.Write(','); }

                    public:
                        Renderer_Csv(DetailsView& DV)
                            : Renderer_TEXT(DV) { }

                        virtual ~Renderer_Csv(VOID) { }
                };

                //
                // DetailsView::DataObject::Renderer_RTF ----------------------
                //
                class Renderer_RTF : public Renderer
                {
                    private:
                        INT m_cCols;

                        LPSTR DoubleBackslashes(LPSTR pszText);

                        //
                        // Prevent copy.
                        //
                        Renderer_RTF(const Renderer_RTF& rhs);
                        Renderer_RTF& operator = (const Renderer_RTF& rhs);

                    protected:
                        virtual VOID Begin(INT cRows, INT cCols);

                        virtual VOID AddTitle(LPCWSTR pszTitleW);

                        virtual VOID BeginHeaders(VOID);

                        virtual VOID AddHeader(LPCWSTR pszHeaderW);

                        virtual VOID AddHeaderSep(VOID)
                            { AddRowColSep(); }

                        virtual VOID EndHeaders(VOID)
                            { m_Stm.Write("\\row "); }

                        virtual VOID BeginRow(VOID)
                            { BeginHeaderOrRow();
                              AddCellDefs(); }

                        virtual VOID AddRowColData(INT iRow, INT idCol);

                        virtual VOID AddRowColSep(VOID)
                            { m_Stm.Write("\\cell "); }

                        virtual VOID EndRow(VOID)
                            { m_Stm.Write("\\row "); }

                        virtual VOID End(VOID)
                            { m_Stm.Write(" \\pard \\widctlpar \\par }"); }

                        virtual VOID BeginHeaderOrRow(VOID);

                        virtual VOID AddCellDefs(VOID);


                    public:
                        Renderer_RTF(DetailsView& DV)
                            : Renderer(DV),
                              m_cCols(0) { }

                        virtual ~Renderer_RTF(VOID) { }
                };


                //
                // DetailsView::DataObject::Renderer_Export -------------------
                //
                class Renderer_Export : public Renderer
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_Export(const Renderer_Export& rhs);
                        Renderer_Export& operator = (const Renderer_Export& rhs);

                    protected:
                        virtual VOID Render(IStream *pStm);

                        virtual VOID Begin(INT cRows, INT cCols);

                        virtual VOID AddBinaryRecord(INT iRow);

                        virtual VOID End(VOID) { }

                    public:
                        Renderer_Export(DetailsView& DV)
                            : Renderer(DV) { }

                        virtual ~Renderer_Export(VOID) { }
                };

                //
                // DetailsView::DataObject::Renderer_FileGroupDescriptor ------
                //
                class Renderer_FileGroupDescriptor : public Renderer
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_FileGroupDescriptor(const Renderer_FileGroupDescriptor& rhs);
                        Renderer_FileGroupDescriptor& operator = (const Renderer_FileGroupDescriptor& rhs);

                    protected:
                        virtual VOID Begin(INT cRows, INT cCols);

                    public:
                        Renderer_FileGroupDescriptor(DetailsView& DV)
                            : Renderer(DV) { }

                        virtual ~Renderer_FileGroupDescriptor(VOID) { };
                };


                //
                // DetailsView::DataObject::Renderer_FileContents -------------
                //
                class Renderer_FileContents : public Renderer_Export
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_FileContents(const Renderer_FileContents& rhs);
                        Renderer_FileContents& operator = (const Renderer_FileContents& rhs);

                    protected:

                    public:
                        Renderer_FileContents(DetailsView& DV)
                            : Renderer_Export(DV) { }

                        virtual ~Renderer_FileContents(VOID) { };
                };

                //
                // DetailsView::DataObject private member variables.
                //
                IStorage    *m_pStg;                 // Storage pointer.
                IStream     *m_pStm;                 // Stream pointer.
                DetailsView& m_DV;

                //
                // Private functions to help with the rendering process.
                //
                HRESULT CreateRenderStream(DWORD tymed, IStream **ppStm);
                HRESULT RenderData(IStream *pStm, CLIPFORMAT cf);

                //
                // Prevent copy.
                //
                DataObject(const DataObject& rhs);
                DataObject& operator = (const DataObject& rhs);
        };

        //
        // DetailsView::DropSource --------------------------------------------
        //
        class DropSource
        {
            public:
                DropSource(DWORD grfKeyState)
                    : m_grfKeyState(grfKeyState) { }

                ~DropSource(VOID) { }
                DWORD m_grfKeyState;  // "Key" used to start drag/drop.

            private:

                //
                // Prevent copying.
                //
                DropSource(const DropSource&);
                void operator = (const DropSource&);
        };

        //
        // DetailsView::DropTarget --------------------------------------------
        //
        class DropTarget
        {
            public:
                DropTarget(DWORD grfKeyState)
                    : m_grfKeyState(grfKeyState),
                      m_pIDataObject(NULL) { }

                ~DropTarget(VOID) { };

                DWORD m_grfKeyState;  // "Key" used to start drag/drop.
                IDataObject *m_pIDataObject; // Ptr received through DragEnter.

            private:
                //
                // Prevent copying.
                //
                DropTarget(const DropTarget&);
                void operator = (const DropTarget&);
        };


        LONG               m_cRef;
        PointerList        m_UserList;         // List of user objects.
        HWND               m_hwndMain;         // Main window.
        HWND               m_hwndListView;     // Listview window.
        HWND               m_hwndStatusBar;    // Status bar.
        HWND               m_hwndToolBar;      // Tool bar.
        HWND               m_hwndToolbarCombo; // "Find User" combo box.
        HWND               m_hwndListViewToolTip;   // Tool tip window.
        HWND               m_hwndHeader;       // Listview header control.
        HACCEL             m_hKbdAccel;        // Accelerator table.
        WNDPROC            m_lpfnLVWndProc;    // We subclass the LV control.
        PDISKQUOTA_CONTROL m_pQuotaControl;    // Ptr to quota controller.
        Finder            *m_pUserFinder;      // For locating users in listview.
        UndoList          *m_pUndoList;        // For "undoing" mods and deletes.
        ColumnMap          m_ColMap;           // ColId to iSubItem map.
        DropSource         m_DropSource;
        DropTarget         m_DropTarget;
        DataObject        *m_pDataObject;
        CVolumeID          m_idVolume;
        CString            m_strVolumeDisplayName;
        CString            m_strAccountUnresolved;
        CString            m_strAccountUnavailable;
        CString            m_strAccountDeleted;
        CString            m_strAccountUnknown;
        CString            m_strAccountInvalid;
        CString            m_strNoLimit;
        CString            m_strNotApplicable;
        CString            m_strStatusOK;
        CString            m_strStatusWarning;
        CString            m_strStatusOverlimit;
        CString            m_strDispText;
        LPDATAOBJECT       m_pIDataObjectOnClipboard;
        POINT              m_ptMouse;          // For hit-testing tooltips.
        DWORD              m_dwEventCookie;    // Event sink cookie.
        INT                m_iLastItemHit;     // Last item mouse was over.
        INT                m_iLastColSorted;
        DWORD              m_fSortDirection;   // 0 = Ascending, 1 = Descending
        CRITICAL_SECTION   m_csAsyncUpdate;
        LV_STATE_INFO      m_lvsi;             // Persistent lv state info.
        BOOL               m_bMenuActive;      // Is a menu active?
        BOOL               m_bWaitCursor;      // Show wait cursor?
        BOOL               m_bStopLoadingObjects;
        BOOL               m_bDestroyingView;
        BOOL               m_bCritSecInited_AsyncUpdate;
        static const INT   MAX_FINDMRU_ENTRIES;
        static const INT   CX_TOOLBAR_COMBO;
        static const INT   CY_TOOLBAR_COMBO;


        HRESULT InitializeStaticStrings(VOID);
        HRESULT CreateMainWindow(VOID);
        HRESULT CreateListView(VOID);
        HRESULT CreateStatusBar(VOID);
        HRESULT CreateToolBar(VOID);
        HRESULT CreateListViewToolTip(VOID);
        HRESULT AddColumn(INT iColumn, const DV_COLDATA& ColDes);
        HRESULT RemoveColumn(INT iColumn);
        HRESULT AddImages(VOID);
        HRESULT LoadObjects(VOID);
        HRESULT ReleaseObjects(VOID);
        LRESULT SortObjects(DWORD idColumn, DWORD dwDirection);
        LRESULT Refresh(bool bInvalidateCache = false);
        LRESULT SelectAllItems(VOID);
        LRESULT InvertSelectedItems(VOID);
        LRESULT ShowItemCountInStatusBar(VOID);
        LRESULT ShowMenuTextInStatusBar(DWORD idMenuOption);
        VOID SaveViewStateToRegistry(VOID);
        VOID EnableMenuItem_ArrangeByFolder(BOOL bEnable);
        VOID EnableMenuItem_Undo(BOOL bEnable);
        VOID SetWaitCursor(VOID);
        VOID ClearWaitCursor(VOID);
        VOID Redraw(VOID)
            {
                RedrawWindow(m_hwndMain, NULL, NULL,
                             RDW_ERASE |
                             RDW_FRAME |
                             RDW_INVALIDATE |
                             RDW_ALLCHILDREN |
                             RDW_UPDATENOW);
            }

        VOID RedrawItems(VOID)
        {
            ListView_RedrawItems(m_hwndListView, -1, -1);
            UpdateWindow(m_hwndListView);
        }

        BOOL AddUser(PDISKQUOTA_USER pUser);
        INT  GetUserQuotaState(PDISKQUOTA_USER pUser);
        VOID RegisterAsDropTarget(BOOL bActive);
        bool SingleSelectionIsAdmin(void);

        //
        // Message handlers.
        //
        LRESULT OnNotify(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnSize(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnSetCursor(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnSetFocus(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnDestroy(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnMainWindowCreated(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnCommand(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnCmdViewStatusBar(VOID);
        LRESULT OnCmdViewToolBar(VOID);
        LRESULT OnCmdViewShowFolder(VOID);
        LRESULT OnCmdProperties(VOID);
        LRESULT OnCmdNew(VOID);
        LRESULT OnCmdDelete(VOID);
        LRESULT OnCmdUndo(VOID);
        LRESULT OnCmdFind(VOID);
        LRESULT OnCmdEditCopy(VOID);
        LRESULT OnCmdImport(VOID);
        LRESULT OnCmdExport(VOID);
        LRESULT OnMenuSelect(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnContextMenu(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnHelpAbout(HWND);
        LRESULT OnHelpTopics(HWND);
        LRESULT OnSettingChange(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnLVN_OwnerDataFindItem(NMLVFINDITEM *);
        LRESULT OnLVN_GetDispInfo(LV_DISPINFO *);
        LRESULT OnLVN_GetDispInfo_Text(LV_DISPINFO *, PDISKQUOTA_USER);
        LRESULT OnLVN_GetDispInfo_Image(LV_DISPINFO *, PDISKQUOTA_USER);
        LRESULT OnLVN_ColumnClick(NM_LISTVIEW *);
        LRESULT OnLVN_ItemChanged(NM_LISTVIEW *);
        LRESULT OnLVN_BeginDrag(NM_LISTVIEW *);
        LRESULT OnTTN_NeedText(TOOLTIPTEXT *);
        LRESULT LV_OnTTN_NeedText(TOOLTIPTEXT *);
        LRESULT LV_OnMouseMessages(HWND, UINT, WPARAM, LPARAM);
        BOOL HitTestHeader(int xPos, int yPos);

        INT_PTR ActivateListViewToolTip(BOOL bActivate)
            { return SendMessage(m_hwndListViewToolTip, TTM_ACTIVATE, (WPARAM)bActivate, 0); }

        VOID FocusOnSomething(VOID);
        VOID CleanupAfterAbnormalTermination(VOID);

        INT FindUserByName(LPCTSTR pszUserName, PDISKQUOTA_USER *ppIUser = NULL);
        INT FindUserBySid(LPBYTE pbUserSid, PDISKQUOTA_USER *ppIUser = NULL);
        INT FindUserByObjPtr(PDISKQUOTA_USER pIUser);
        BOOL GotoUserName(LPCTSTR pszUser);

        //
        // Connection point stuff.
        //
        HRESULT ConnectEventSink(VOID);
        HRESULT DisconnectEventSink(VOID);
        IConnectionPoint *GetConnectionPoint(VOID);

        static DWORD ThreadProc(LPVOID);
        static INT CompareItems(LPVOID, LPVOID, LPARAM);
        static HRESULT CalcPctQuotaUsed(PDISKQUOTA_USER, LPDWORD);
        static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
        static LRESULT CALLBACK LVSubClassWndProc(HWND, UINT, WPARAM, LPARAM);

        //
        // Prevent copying.
        //
        DetailsView(const DetailsView&);
        void operator = (const DetailsView&);


    public:
        DetailsView(VOID);
        ~DetailsView(VOID);

        BOOL Initialize(
            const CVolumeID& idVolume);

        CVolumeID GetVolumeID(void) const
            { return m_idVolume; }

        //
        // This is public so other UI elements can use it. (i.e. VolPropPage).
        //
        static HRESULT CreateVolumeDisplayName(
                const CVolumeID& idVolume, // [in] - "C:\" or "\\?\Volume{ <guid> }\"
                CString *pstrDisplayName); // [out] - "My Disk (C:)"
        //
        // If you change the value of idCol_Last, see the note with
        // the LV_STATE_INFO structure above regarding the rgcxCol[] member
        // of LV_STATE_INFO.
        //
        enum ColumnIDs { idCol_Status,
                         idCol_Folder,
                         idCol_Name,
                         idCol_LogonName,
                         idCol_AmtUsed,
                         idCol_Limit,
                         idCol_Threshold,
                         idCol_PctUsed,
                         idCol_Last };

        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID riid,
            LPVOID *ppv);

        STDMETHODIMP_(ULONG)
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG)
        Release(
            VOID);

        //
        // IDiskQuotaEvents method.
        //
        STDMETHODIMP
        OnUserNameChanged(
            PDISKQUOTA_USER pUser);


        //
        // IDropSource methods.
        //
        STDMETHODIMP
        GiveFeedback(
            DWORD dwEffect);

        STDMETHODIMP
        QueryContinueDrag(
            BOOL fEscapePressed,
            DWORD grfKeyState);

        //
        // IDropTarget methods.
        //
        STDMETHODIMP DragEnter(
            IDataObject * pDataObject,
            DWORD grfKeyState,
            POINTL pt,
            DWORD * pdwEffect);

        STDMETHODIMP DragOver(
            DWORD grfKeyState,
            POINTL pt,
            DWORD * pdwEffect);

        STDMETHODIMP DragLeave(
            VOID);

        STDMETHODIMP Drop(
            IDataObject * pDataObject,
            DWORD grfKeyState,
            POINTL pt,
            DWORD * pdwEffect);


        //
        // IDataObject methods.
        //
        STDMETHODIMP
        GetData(
            FORMATETC *pFormatetc,
            STGMEDIUM *pmedium);

        STDMETHODIMP
        GetDataHere(
            FORMATETC *pFormatetc,
            STGMEDIUM *pmedium);

        STDMETHODIMP
        QueryGetData(
            FORMATETC *pFormatetc);

        STDMETHODIMP
        GetCanonicalFormatEtc(
            FORMATETC *pFormatetcIn,
            FORMATETC *pFormatetcOut);

        STDMETHODIMP
        SetData(
            FORMATETC *pFormatetc,
            STGMEDIUM *pmedium,
            BOOL fRelease);

        STDMETHODIMP
        EnumFormatEtc(
            DWORD dwDirection,
            IEnumFORMATETC **ppenumFormatetc);

        STDMETHODIMP
        DAdvise(
            FORMATETC *pFormatetc,
            DWORD advf,
            IAdviseSink *pAdvSink,
            DWORD *pdwConnection);

        STDMETHODIMP
        DUnadvise(
            DWORD dwConnection);

        STDMETHODIMP
        EnumDAdvise(
            IEnumSTATDATA **ppenumAdvise);



        HWND GetHWndMain(VOID)
            { return m_hwndMain; }

        static VOID InitLVStateInfo(PLV_STATE_INFO plvsi);
        static BOOL IsValidLVStateInfo(PLV_STATE_INFO plvsi);

        void GetVolumeDisplayName(CString *pstrName)
            { *pstrName = m_strVolumeDisplayName; }

        UINT GetColumnIds(INT *prgColIds, INT cColIds);

        //
        // Methods for getting drag-drop report data from details view.
        //
        INT GetNextSelectedItemIndex(INT iRow);
        BOOL GetReportItem(UINT iRow, UINT iColId, PLV_REPORT_ITEM pItem);
        VOID GetReportTitle(LPTSTR pszDest, UINT cchDest);
        VOID GetReportColHeader(UINT iColId, LPTSTR pszDest, UINT cchDest);
        UINT GetReportColCount(VOID);
        UINT GetReportRowCount(VOID);
        //
        // These methods are for generating binary "reports" used in exporting
        // user quota information for transfer between volumes.
        //
        UINT GetReportBinaryRecordSize(UINT iRow);
        BOOL GetReportBinaryRecord(UINT iRow, LPBYTE pbRecord, UINT cbRecord);

        //
        // NOTE:  If the requirement for friendship between DetailsView and
        //        DetailsView::Finder exceeds only a few instances, we
        //        might as well grant total friendship to the Finder class.
        //        As long as the instance count is small, I like to keep
        //        the friendship restricted as much as possible.
        //
        // This Finder::DlgProc needs to call DetailsView::GotoUserName.
        //
        friend BOOL Finder::UserNameEntered(HWND);
        //
        // Finder::DlgProc needs access to Details::CY_TOOLBAR_COMBO.
        //
        friend INT_PTR CALLBACK Finder::DlgProc(HWND, UINT, WPARAM, LPARAM);

        friend class Importer;
};



//
// Represents a selection in the listview.
// Objects of this type are used for communicating a selection set to
// a function.  The recpient of the LVSelection object can query it
// to obtain information about the selection.
//
class LVSelection
{
    private:
        HWND m_hwndListView;
        struct ListEntry
        {
            PDISKQUOTA_USER pUser;
            INT iItem;
        };

        StructureList m_List;

        //
        // Prevent copying.
        //
        LVSelection(const LVSelection&);
        void operator = (const LVSelection&);

    public:
        LVSelection(HWND hwndListView)
            : m_hwndListView(hwndListView),
              m_List(sizeof(ListEntry), 10) { }

        LVSelection(VOID)
            : m_hwndListView(NULL),
              m_List(sizeof(ListEntry), 1) { }

        ~LVSelection(VOID) { }

        VOID Add(PDISKQUOTA_USER pUser, INT iItem);
        HWND GetListViewHwnd(VOID)
            { return m_hwndListView; }
        INT Count(VOID)
            { return m_List.Count(); }
        BOOL Retrieve(INT i, PDISKQUOTA_USER *ppUser, INT *piItem);
        BOOL Retrieve(INT i, PDISKQUOTA_USER *ppUser)
            { return Retrieve(i, ppUser, NULL); }
        BOOL Retrieve(INT i, INT *pItem)
            { return Retrieve(i, NULL, pItem); }
        VOID Clear(VOID)
            { m_List.Clear(); }
};




#endif // _INC_DSKQUOTA_DETAILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\details.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: details.cpp

    Description: Contains definition for class DetailsView.
        This class implements a list view containing quota information about
        the various accounts in a volume's quota information file.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    05/28/97    Major changes.                                       BrianAu
                - Added "User Finder".
                - Added promotion of selected item to front of
                  name resolution queue.
                - Improved name resolution status reporting through
                  listview.
                - Moved drag/drop and report generation code
                  from dragdrop.cpp and reptgen.cpp into the
                  DetailsView class.  DetailsView now implements
                  IDataObject, IDropSource and IDropTarget instead
                  of deferring implementation to secondary objects.
                  dragdrop.cpp and reptgen.cpp have been dropped
                  from the project.
                - Added support for CF_HDROP and private import/
                  export clipboard formats.
                - Added import/export functionality.
    07/28/97    Removed export support for CF_HDROP.  Replaced       BrianAu
                with FileContents and FileGroupDescriptor.  Import
                from CF_HDROP is still supported.
                Added Import Source object hierarchy.
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"  // PCH
#pragma hdrstop

#include <htmlhelp.h>
#include <commctrl.h>
#include <commdlg.h>

#include "uihelp.h"
#include "uiutils.h"
#include "dskquota.h"
#include "registry.h"
#include "resource.h"
#include "shellinc.h"
#include "userprop.h"
#include "details.h"
#include "guidsp.h"
#include "mapfile.h"
#include "progress.h"
#include "yntoall.h"
#include "ownerlst.h"
#include "ownerdlg.h"
#include "adusrdlg.h"
//
// Constant text strings.
//
TCHAR c_szWndClassDetailsView[]   = TEXT("DetailsView");

//
// Bitmap dimension constants.
//
const UINT BITMAP_WIDTH     = 16;
const UINT BITMAP_HEIGHT    = 16;
const UINT LG_BITMAP_WIDTH  = 32;
const UINT LG_BITMAP_HEIGHT = 32;

//
// How much to grow the user object list whenever expansion is required.
//
const INT USER_LIST_GROW_AMT = 100;

//
// This structure is used to pass the DetailsView object's "this" pointer
// in WM_CREATE.
//
typedef struct WndCreationData {
    SHORT   cbExtra;
    LPVOID  pThis;
} WNDCREATE_DATA;

typedef UNALIGNED WNDCREATE_DATA *PWNDCREATE_DATA;

//
// Structure passed to CompareItems callback.
//
typedef struct comparestruct
{
    DWORD idColumn;
    DWORD dwDirection;
    DetailsView *pThis;
} COMPARESTRUCT, *PCOMPARESTRUCT;


//
// Define some names for indexes into the listview's image list.
//
#define iIMAGELIST_ICON_NOIMAGE       (-1)
#define iIMAGELIST_ICON_OK              0
#define iIMAGELIST_ICON_WARNING         1
#define iIMAGELIST_ICON_LIMIT           2

//
// The 0-based index of the "View" item in the main menu and of the
// "Arrange" item in the view menu.
// WARNING:  If you change menu items, these may need updating.
//
#define iMENUITEM_VIEW                  2
#define iMENUITEM_VIEW_ARRANGE          4
//
// Same thing for the "Edit" menu.
//
#define iMENUITEM_EDIT                  1

//
// Add/remove from this array to change the columns in the list view.
// IMPORTANT:
//     The ordering of these items is very important (sort of).
//     Because of a bug in commctrl.h, they don't paint under the bitmap
//     if it's the only thing in the column (or if it's the bitmap of the primary
//     item).  Also, the behavior of the listview is such that the text in
//     subitem 0 is always shifted right the width of a small bitmap.  When
//     I had the status column NOT as item 0, there were two display problems.
//     1) First, the text in column 0 was always shifted right to allow for the
//        bitmap we weren't using.  This looked funny.
//     2) The full-row-select highlight didn't properly paint the background
//        of the status bitmap.
//
//     By placing the status column as subitem 0, we eliminate problem 1 since
//     we're using a bitmap in subitem 0 (listview's default behavior).
//     If we drag the status column out of the leftmost position, they still don't
//     paint under the bitmap but at least it will work like any other explorer
//     view.  When/if they fix listview, we'll be fixed automatically.
//
const DV_COLDATA g_rgColumns[] = {
    { LVCFMT_LEFT |
      LVCFMT_COL_HAS_IMAGES,
                     0, IDS_TITLE_COL_STATUS,    DetailsView::idCol_Status      },
    { LVCFMT_LEFT,   0, IDS_TITLE_COL_FOLDER,    DetailsView::idCol_Folder      },
    { LVCFMT_LEFT,   0, IDS_TITLE_COL_USERNAME,  DetailsView::idCol_Name        },
    { LVCFMT_LEFT,   0, IDS_TITLE_COL_LOGONNAME, DetailsView::idCol_LogonName   },
    { LVCFMT_RIGHT,  0, IDS_TITLE_COL_AMTUSED,   DetailsView::idCol_AmtUsed     },
    { LVCFMT_RIGHT,  0, IDS_TITLE_COL_LIMIT,     DetailsView::idCol_Limit       },
    { LVCFMT_RIGHT,  0, IDS_TITLE_COL_THRESHOLD, DetailsView::idCol_Threshold   },
    { LVCFMT_RIGHT,  0, IDS_TITLE_COL_PCTUSED,   DetailsView::idCol_PctUsed     },
    };

//
// User quota state constants.
// used for identifying which icon to display in "Status" column.
//
const INT iUSERSTATE_OK        = 0;
const INT iUSERSTATE_WARNING   = 1;
const INT iUSERSTATE_OVERLIMIT = 2;

//
// Maximum number of entries allowed in the "Find User" MRU list.
//
const INT DetailsView::MAX_FINDMRU_ENTRIES = 10;

//
// Dimensions for the "Find User" combo box in the toolbar.
//
const INT DetailsView::CX_TOOLBAR_COMBO    = 200;
const INT DetailsView::CY_TOOLBAR_COMBO    = 200;


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DetailsView

    Description: Class constructor.

    Arguments: None.

    Returns: Nothing.

    Exceptions: OutOfMemory

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/21/97    Ownerdata listview. Added m_UserList.                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::DetailsView(
    VOID
    ) : m_cRef(0),
        m_UserList(USER_LIST_GROW_AMT),
        m_hwndMain(NULL),
        m_hwndListView(NULL),
        m_hwndStatusBar(NULL),
        m_hwndToolBar(NULL),
        m_hwndListViewToolTip(NULL),
        m_hwndHeader(NULL),
        m_hKbdAccel(NULL),
        m_lpfnLVWndProc(NULL),
        m_pQuotaControl(NULL),
        m_pUserFinder(NULL),
        m_DropSource(MK_LBUTTON),
        m_DropTarget(MK_LBUTTON),
        m_pDataObject(NULL),
        m_pUndoList(NULL),
        m_ColMap(ARRAYSIZE(g_rgColumns)),
        m_strAccountUnresolved(g_hInstDll, IDS_USER_ACCOUNT_UNRESOLVED),
        m_strAccountUnavailable(g_hInstDll, IDS_USER_ACCOUNT_UNAVAILABLE),
        m_strAccountUnknown(g_hInstDll, IDS_USER_ACCOUNT_UNKNOWN),
        m_strAccountDeleted(g_hInstDll, IDS_USER_ACCOUNT_DELETED),
        m_strAccountInvalid(g_hInstDll, IDS_USER_ACCOUNT_INVALID),
        m_strNoLimit(g_hInstDll, IDS_NO_LIMIT),
        m_strNotApplicable(g_hInstDll, IDS_NOT_APPLICABLE),
        m_strStatusOK(g_hInstDll, IDS_STATUS_OK),
        m_strStatusWarning(g_hInstDll, IDS_STATUS_WARNING),
        m_strStatusOverlimit(g_hInstDll, IDS_STATUS_OVERLIMIT),
        m_pIDataObjectOnClipboard(NULL),
        m_dwEventCookie(0),
        m_iLastItemHit(-1),
        m_iLastColSorted(-1),
        m_fSortDirection(0),
        m_bMenuActive(FALSE),
        m_bWaitCursor(FALSE),
        m_bStopLoadingObjects(FALSE),
        m_bDestroyingView(FALSE),
        m_bCritSecInited_AsyncUpdate(FALSE)
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("DetailsView::DetailsView")));

    //
    // Make sure the idCol_XXX constants agree
    // with the size of g_rgColumns.
    //
    DBGASSERT((ARRAYSIZE(g_rgColumns) == DetailsView::idCol_Last));

    ZeroMemory(&m_lvsi, sizeof(m_lvsi));
    m_ptMouse.x     = 0;
    m_ptMouse.y     = 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Initialize

    Description: Initializes a new details view object.

    Arguments:
        idVolume - Ref to a const CVolumeID object containing both the
            parsable and displayable names for the volume.

    Returns: TRUE  = Success.
             FALSE = Out of memory or couldn't create thread.
                     Either way, we can't run the view.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/06/96    Initial creation.  Moved this code out of the ctor.  BrianAu
    02/25/97    Removed m_hwndPropPage from DetailsView.             BrianAu
    05/20/97    Added user finder object.                            BrianAu
    06/28/98    Added support for mounted volumes.                   BrianAu
    02/26/02    Moved critsec initialization from ctor.              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::Initialize(
    const CVolumeID& idVolume
    )
{
    BOOL bResult   = FALSE;
    HANDLE hThread = NULL;

    if (!InitializeCriticalSectionAndSpinCount(&m_csAsyncUpdate, 0))
    {
        return FALSE;
    }
    m_bCritSecInited_AsyncUpdate = TRUE;

    try
    {
        //
        // Create the reg parameter objects we'll be using in the UI.
        // The RegParamTable functions will not add a duplicate entry.
        //
        //
        // Parameter: Preferences
        //
        LV_STATE_INFO lvsi;
        InitLVStateInfo(&lvsi);

        //
        // Create a private copy of the file sys object name string.
        // This can throw OutOfMemory.
        //
        m_idVolume = idVolume;
        if (FAILED(CreateVolumeDisplayName(m_idVolume, &m_strVolumeDisplayName)))
        {
            m_strVolumeDisplayName = m_idVolume.ForDisplay();
        }

        //
        // Read saved state of listview from registry.
        // Saved info includes window ht/wd, column widths and
        // toolbar/status bar visibility.  Need this info before we start thread.
        //
        RegKey keyPref(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
        if (FAILED(keyPref.Open(KEY_READ)) ||
            FAILED(keyPref.GetValue(REGSTR_VAL_PREFERENCES, (LPBYTE)&m_lvsi, sizeof(m_lvsi))) ||
            !DetailsView::IsValidLVStateInfo(&m_lvsi))
        {
            //
            // Protect us from truly bogus data.  If it's bad, or obsolete,
            // just re-initialize it.
            //
            DBGERROR((TEXT("Listview persist state info invalid.  Re-initializing.")));
            DetailsView::InitLVStateInfo(&m_lvsi);
        }

        //
        // Transfer sorting information to member variables.
        // These can be changed by user-initiated events.
        //
        m_iLastColSorted  = m_lvsi.iLastColSorted;
        m_fSortDirection  = m_lvsi.fSortDirection;

        //
        // Create the user finder object.
        // This is used to locate users through the toolbar combo box and
        // the "Find User" dialog.  The finder object maintains a MRU list for
        // both the toolbar and dialog combos.
        //
        m_pUserFinder = new Finder(*this, MAX_FINDMRU_ENTRIES);

        //
        // Create the data object we use to control data transfers.
        //
        m_pDataObject = new DataObject(*this);

        //
        // Create a new thread on which to run the details view window.
        // This is so that the details view will remain alive if the
        // property page is destroyed.  This must be done last in this method
        // so that if we return FALSE, the caller is assured there is no thread
        // running loose.  If we return FALSE, they'll have to call "delete"
        // to release any string allocations done above.  If we return TRUE,
        // the caller must not call delete on the object.  The object will
        // destroy itself when the user closes the view window.
        //
        hThread = CreateThread(NULL,        // No security attributes.
                               0,           // Default stack size.
                               &ThreadProc,
                               this,        // Static thread proc needs this.
                               0,           // Not suspended.
                               NULL);
        if (NULL != hThread)
        {
            CloseHandle(hThread);
            //
            // Everything succeeded.
            //
            bResult = TRUE;
        }
    }
    catch(CAllocException& e)
    {
        //
        // Catch an allocation exception here.
        // We'll return FALSE indicating initialization failure.
        //
    }
    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::~DetailsView

    Description: Class destructor.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/21/97    Ownerdata listview. Added m_UserList.                BrianAu
    05/20/97    Added user finder object.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::~DetailsView(
    VOID
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("DetailsView::~DetailsView")));

    //
    // Destroy the user object list if it still has some objects.
    //
    ReleaseObjects();

    delete m_pUserFinder;
    delete m_pUndoList;
    delete m_pDataObject;

    if (m_bCritSecInited_AsyncUpdate)
    {
        DeleteCriticalSection(&m_csAsyncUpdate);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::QueryInterface

    Description: Returns an interface pointer to the object's supported
        interfaces.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hResult = NO_ERROR;

    if (NULL != ppv)
    {
        *ppv = NULL;

        if (IID_IUnknown == riid || IID_IDiskQuotaEvents == riid)
        {
            *ppv = static_cast<IDiskQuotaEvents *>(this);
        }
        else if (IID_IDataObject == riid)
        {
            *ppv = static_cast<IDataObject *>(this);
        }
        else if (IID_IDropSource == riid)
        {
            *ppv = static_cast<IDropSource *>(this);
        }
        else if (IID_IDropTarget == riid)
        {
            *ppv = static_cast<IDropTarget *>(this);
        }
        else
            hResult = E_NOINTERFACE;

        if (NULL != *ppv)
        {
            ((LPUNKNOWN)*ppv)->AddRef();
        }
    }
    else
        hResult = E_INVALIDARG;

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
DetailsView::AddRef(
    VOID
    )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_COM, DL_HIGH, TEXT("DetailsView::AddRef, 0x%08X  %d -> %d\n"), this, cRef - 1, cRef ));
    return cRef;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
DetailsView::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DetailsView::Release, 0x%08X  %d -> %d\n"),
             this, cRef + 1, cRef ));

    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::ThreadProc

    Description: Thread procedure for the details view window.  Creates the
        quota control object and the main window.  Then it just sits
        processing messages until it receives a WM_QUIT message.

    Arguments:
        pvParam - Address of DetailsView instance.

    Returns:
        Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    03/22/00    Fixed proc param for ia64.                           BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
DetailsView::ThreadProc(
    LPVOID pvParam
    )
{
    HRESULT hResult = NO_ERROR;
    DetailsView *pThis = (DetailsView *)pvParam;

    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("LISTVIEW - New thread %d"), GetCurrentThreadId()));

    DBGASSERT((NULL != pThis));

    //
    // Need to ensure DLL stays loaded while this thread is active.
    //
    InterlockedIncrement(&g_cRefThisDll);
    //
    // This will keep the view object alive while the thread is alive.
    // We call Release when the thread terminates.
    //
    pThis->AddRef();

    //
    // Must call OleInitialize() for new thread.
    //
    try
    {
        if (SUCCEEDED(OleInitialize(NULL)))
        {
            //
            // Create the quota control object.
            // Why don't we just use the same quota controller as the
            // volume property page?  Good question.
            // Since we're on a separate thread, we either need a new
            // object or marshal the IDiskQuotaControl interface.
            // I chose to create a new object rather than take the
            // performance hit of the additional marshaling.  The quota
            // controller object is used heavily by the details view.
            //
            hResult = CoCreateInstance(CLSID_DiskQuotaControl,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IDiskQuotaControl,
                                       (LPVOID *)&(pThis->m_pQuotaControl));

            if (SUCCEEDED(hResult))
            {
                hResult = pThis->m_pQuotaControl->Initialize(pThis->m_idVolume.ForParsing(),
                                                             TRUE); // Read-write.

                if (SUCCEEDED(hResult))
                {
                    //
                    // Create the main window.
                    //
                    hResult = pThis->CreateMainWindow();
                    if (SUCCEEDED(hResult))
                    {
                        MSG msg;
                        DBGASSERT((NULL != pThis->m_hwndMain));
                        //
                        // Place a message in the queue that the window has been
                        // created.  Now creation of the other controls can procede.
                        //
                        // It is VERY important that once we receive a WM_QUIT message,
                        // no members of the DetailsView instance are referenced.
                        // Posting WM_QUIT is the last thing done by the WM_DESTROY handler.
                        //
                        PostMessage(pThis->m_hwndMain, WM_MAINWINDOW_CREATED, 0, 0);

                        while (0 != GetMessage(&msg, NULL, 0, 0))
                        {
                            if (NULL == pThis->m_hKbdAccel ||
                               !TranslateAccelerator(pThis->m_hwndMain,
                                                     pThis->m_hKbdAccel,
                                                     &msg))
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                    }
                }
            }
            else
            {
                DBGERROR((TEXT("LISTVIEW - OleInitialize failed for thread %d."),
                         GetCurrentThreadId()));
            }
            OleUninitialize();
        }
    }
    catch(CAllocException& e)
    {
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);

        pThis->CleanupAfterAbnormalTermination();
    }

    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("LISTVIEW - Exit thread %d"), GetCurrentThreadId()));

    //
    // Release the view object since it's no longer required.
    // This will call the destructor.
    //
    pThis->Release();
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);

    return 0;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CleanupAfterAbnormalTermination

    Description: Perform operations required after the thread has terminated
        abnormally.  This function assumes that the thread's message pump is
        no longer active.  Any operations performed must not generate messages
        that require processing by the thread.

        This method does almost the same things as OnDestroy().

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::CleanupAfterAbnormalTermination(
    VOID
    )
{
    //
    // Cancel subclassing of the listview control.
    //
    if (NULL != m_lpfnLVWndProc)
        SetWindowLongPtr(m_hwndListView, GWLP_WNDPROC, (INT_PTR)m_lpfnLVWndProc);

    DisconnectEventSink();
    //
    // NOTE:  We can't call ReleaseObjects() because that method
    //        requires an active listview.  Our thread is finished and the
    //        window is gone.
    //
    if (NULL != m_pQuotaControl)
    {
        m_pQuotaControl->Release();
        m_pQuotaControl = NULL;
    }

    //
    // If we have a data object on the clipboard, clear the clipboard.
    // Note that the clipboard holds the reference to the data object.
    // When we clear the clipboard, the data object will be released.
    //
    if (NULL != m_pIDataObjectOnClipboard &&
       S_OK == OleIsCurrentClipboard(m_pIDataObjectOnClipboard))
    {
        OleFlushClipboard();
    }
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnUserNameChanged

    Description: Called by the event source (SidNameResolver) whenever a disk
        quota user object's name has changed.  The user object's folder and
        account name strings are updated in the list view.

    Arguments:
        pUser - Address of IDiskQuotaUser interface for user object that has
            a new name.

    Returns:
        NO_ERROR     - Success.
        E_INVALIDARG - User object pointer received from event source was invalid.
        E_FAIL       - User not found in listview list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    12/10/96    Use free-threading OLE apartment model.              BrianAu
    02/05/98    Changed ListView_RedrawItems to use                  BrianAu
                SendMessageTimeout().

*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::OnUserNameChanged(
    PDISKQUOTA_USER pUser
    )
{
    HRESULT hResult = E_FAIL;

    //
    // Ensure the DetailsView object stay's alive while the view is updated.
    // Remember, this code is being run on the SID/Name resolver's thread.
    //
    AddRef();

    //
    // We don't want to perform a user-name-changed update if the
    // view is being or has been destroyed.  Likewise, we don't want to
    // destroy the view window while a user-name-changed update is in
    // progress.  The crit sec m_csAsyncUpdate and the flag m_bDestroyingView
    // work together to ensure this.
    //
    EnterCriticalSection(&m_csAsyncUpdate);
    if (!m_bDestroyingView)
    {
        try
        {
            if (NULL != pUser)
            {
                INT iItem = -1;

                if (m_UserList.FindIndex((LPVOID)pUser, &iItem))
                {
                    //
                    // Send message to listview to redraw the item
                    // that changed.  Use the "timeout" version of
                    // SendMessage because the main window thread
                    // could be blocked waiting for m_csAsyncUpdate
                    // which is now owned by the resolver thread.
                    // If the main thread is blocked (waiting to
                    // process WM_DESTROY), this call will return 0
                    // after 5 seconds.  If this happens, we leave the
                    // CS without generating a window update, releasing
                    // the CS and letting the main window thread continue
                    // with WM_DESTROY processing.
                    //
                    DWORD_PTR dwResult;
                    LRESULT lResult = SendMessageTimeout(m_hwndListView,
                                                         LVM_REDRAWITEMS,
                                                         (WPARAM)iItem,
                                                         (LPARAM)iItem,
                                                         SMTO_BLOCK,
                                                         5000,
                                                         &dwResult);
                    if (lResult)
                        UpdateWindow(m_hwndListView);
                    else
                        DBGERROR((TEXT("ListView update timed out after 5 seconds")));

                    hResult = NO_ERROR;
                }
            }
            else
                hResult = E_INVALIDARG;
        }
        catch(CAllocException& e)
        {
            //
            // Catch allocation exceptions and do nothing.
            // Resolver doesn't care about return value.
            // Want to ensure that Release() is called no matter what.
            //
            hResult = E_OUTOFMEMORY;
        }
    }
    LeaveCriticalSection(&m_csAsyncUpdate);

    Release();

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateMainWindow

    Description: Creates the main window for the details view.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Couldn't create window.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateMainWindow(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;
    WNDCLASSEX wc;
    DWORD dwExStyle;
    LANGID LangID;

    wc.cbSize           = sizeof(WNDCLASSEX);
    wc.style            = CS_PARENTDC;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_hInstDll;
    wc.hIcon            = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_QUOTA));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = NULL;
    wc.lpszMenuName     = MAKEINTRESOURCE(IDM_LISTVIEW_MENU);
    wc.lpszClassName    = c_szWndClassDetailsView;
    wc.hIconSm          = NULL;

    RegisterClassEx(&wc);

    //
    // Need to pass "this" pointer in WM_CREATE.  We'll store "this"
    // in the window's USERDATA.
    //
    WNDCREATE_DATA wcd;
    wcd.cbExtra = sizeof(WNDCREATE_DATA);
    wcd.pThis   = this;

    //
    // Create the window title string.
    // "Quota Details for My Disk (X:)"
    //
    CString strWndTitle(g_hInstDll, IDS_TITLE_MAINWINDOW, (LPCTSTR)m_strVolumeDisplayName);

    HWND hwndDesktop   = GetDesktopWindow();
    HDC hdc            = GetDC(hwndDesktop);

    //
    // Get current screen resolution.
    //
    if ((m_lvsi.cxScreen != (WORD)GetDeviceCaps(hdc, HORZRES)) ||
        (m_lvsi.cyScreen != (WORD)GetDeviceCaps(hdc, VERTRES)))
    {
        //
        // Screen resolution has changed since listview state data was
        // last saved to registry.  Use the default window ht/wd.
        //
        m_lvsi.cx = 0;
        m_lvsi.cy = 0;
    }
    ReleaseDC(hwndDesktop, hdc);


    // Check if we are running on BiDi Localized build. we need to create the Main Window 
    // mirrored (WS_EX_LAYOUTRTL).
    dwExStyle = 0;
    LangID = GetUserDefaultUILanguage();
    if( LangID )
    {
       LCID   iLCID;
       WCHAR wchLCIDFontSignature[16];
       iLCID = MAKELCID( LangID , SORT_DEFAULT );

        if( GetLocaleInfoW( iLCID ,
                           LOCALE_FONTSIGNATURE ,
                           (WCHAR *) &wchLCIDFontSignature[0] ,
                           (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
        {
           if( wchLCIDFontSignature[7] & (WCHAR)0x0800 )
           {
              dwExStyle = WS_EX_LAYOUTRTL;
           }
        }
    }


    m_hwndMain = CreateWindowEx(dwExStyle,
                              c_szWndClassDetailsView,
                              strWndTitle,
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              m_lvsi.cx ? m_lvsi.cx : CW_USEDEFAULT,
                              m_lvsi.cy ? m_lvsi.cy : CW_USEDEFAULT,
                              hwndDesktop,
                              NULL,
                              g_hInstDll,
                              &wcd);
    if (NULL != m_hwndMain)
    {
        //
        // Register the main window as an OLE drop target.
        //
        RegisterAsDropTarget(TRUE);
    }
    else
    {
        hResult = E_FAIL;
    }

#if DBG
    if (FAILED(hResult))
        DBGERROR((TEXT("LISTVIEW - Failed creating main window."), hResult));
#endif

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateListView

    Description: Create the list view control.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed to create listview or load icons.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/21/97    Modified to use virtual listview (LVS_OWNERDATA)     BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateListView(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;
    RECT rc;

    DBGASSERT((NULL != m_hwndMain));

    GetClientRect(m_hwndMain, &rc);

    m_hwndListView = CreateWindowEx(WS_EX_CLIENTEDGE,
                                    WC_LISTVIEW,
                                    TEXT(""),
                                    WS_CHILD | WS_CLIPCHILDREN |
                                    WS_VISIBLE | WS_CLIPSIBLINGS |
                                    WS_TABSTOP | LVS_REPORT | LVS_SHOWSELALWAYS |
                                    LVS_OWNERDATA,
                                    0, 0,
                                    rc.right - rc.left,
                                    rc.bottom - rc.top,
                                    m_hwndMain,
                                    (HMENU)NULL,
                                    g_hInstDll,
                                    NULL);
    if (NULL != m_hwndListView)
    {
        //
        // Store "this" ptr so subclass WndProc can access members.
        //
        SetWindowLongPtr(m_hwndListView, GWLP_USERDATA, (INT_PTR)this);

        //
        // We talk to the header control so save it's handle.
        //
        m_hwndHeader = ListView_GetHeader(m_hwndListView);

        //
        // Subclass the listview control so we can monitor mouse position.
        // This is used for listview tooltip management.
        //
        m_lpfnLVWndProc = (WNDPROC)GetWindowLongPtr(m_hwndListView, GWLP_WNDPROC);
        SetWindowLongPtr(m_hwndListView, GWLP_WNDPROC, (INT_PTR)LVSubClassWndProc);

        //
        // Enable listview for images in sub-item columns and full-row select.
        //
        ListView_SetExtendedListViewStyle(m_hwndListView,
                                          LVS_EX_SUBITEMIMAGES |
                                          LVS_EX_FULLROWSELECT |
                                          LVS_EX_HEADERDRAGDROP);

        //
        // Add all columns to the listview.
        // Adjust for showing/hiding the Folder column.
        //
        INT iColId = 0; // Start with 1st col.
        for (INT iSubItem = 0;
             iSubItem < (m_lvsi.fShowFolder ? DetailsView::idCol_Last : DetailsView::idCol_Last - 1);
             iSubItem++)
        {
            AddColumn(iSubItem, g_rgColumns[iColId]);
            iColId++;

            //
            // Skip over the Folder column if it's hidden.
            //
            if (!m_lvsi.fShowFolder && DetailsView::idCol_Folder == iColId)
                iColId++;
        }

        //
        // Restore column widths to where the user left them last time
        // the details view was used.
        //
        if (m_lvsi.cb == sizeof(LV_STATE_INFO))
        {
            for (UINT i = 0; i < DetailsView::idCol_Last; i++)
            {
                if (0 != m_lvsi.rgcxCol[i])
                {
                    ListView_SetColumnWidth(m_hwndListView, i, m_lvsi.rgcxCol[i]);
                }
            }
        }

        //
        // Restore the user's last column ordering.
        //
        DBGASSERT((Header_GetItemCount(m_hwndHeader) <= ARRAYSIZE(m_lvsi.rgColIndices)));

        Header_SetOrderArray(m_hwndHeader, Header_GetItemCount(m_hwndHeader),
                             m_lvsi.rgColIndices);

        //
        // Check the "Show Folder" menu item to indicate the current visibility state
        // of the Folder column.
        //
        CheckMenuItem(GetMenu(m_hwndMain),
                      IDM_VIEW_SHOWFOLDER,
                      MF_BYCOMMAND | (m_lvsi.fShowFolder ? MF_CHECKED : MF_UNCHECKED));

        //
        // Set the sensitivity of the "by Folder" item arrangement menu option.
        //
        EnableMenuItem_ArrangeByFolder(m_lvsi.fShowFolder);

        //
        // Create and activate the listview tooltip window.
        // Even though the standard listview has a tooltip window, we need more
        // control that it provides.  i.e.:  We need to be able to enable/disable
        // the tooltip as well as notify the control when a new listview item
        // has been hit.  Therefore, we need our own tooltip window.
        //
        if (SUCCEEDED(CreateListViewToolTip()))
            ActivateListViewToolTip(!m_lvsi.fShowFolder);
        else
            DBGERROR((TEXT("LISTVIEW, Failed creating tooltip window.")));

        //
        // Add WARNING and ERROR images to the listview's image list.
        // These are used for the "Status" column.
        //
        if (FAILED(hResult = AddImages()))
            DBGERROR((TEXT("LISTVIEW, Failed adding images to image list.")));
    }
    else
        hResult = E_FAIL;

#if DBG
    if (FAILED(hResult))
        DBGERROR((TEXT("LISTVIEW - Failed creating list view with result 0x%08X"),
                 hResult));
#endif

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::RemoveColumn

    Description: Removes a specified column from the list view.

    Arguments:
        iColId - 0-based index of the column in the list view.
            i.e. idCol_Folder, idCol_Name etc.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Column could not be removed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::RemoveColumn(
    INT iColId
    )
{
    INT iSubItem = m_ColMap.IdToSubItem(iColId);
    if (-1 != iSubItem && ListView_DeleteColumn(m_hwndListView, iSubItem))
    {
        m_ColMap.RemoveId(iSubItem);
        return NO_ERROR;
    }

    return E_FAIL;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::AddColumn

    Description: Adds a column to the list view.  The caller specifies which
        0-based position the column is to occupy and a reference to a column
        descriptor record containing information that defines the column.

    Arguments:
        iSubItem - 0-based index of the column in the list view.

        ColDesc - Reference to column descriptor record.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - One or more columns could not be inserted.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::AddColumn(
    INT iSubItem,
    const DV_COLDATA& ColDesc
    )
{
    LV_COLUMN col;
    HRESULT hResult = NO_ERROR;

    CString strColText(g_hInstDll, ColDesc.idMsgText);
    col.pszText = strColText;

    if (0 == ColDesc.cx)
    {
        //
        // No width specified in col desc record.  Size column to the title.
        //
        HDC hdc = NULL;
        TEXTMETRIC tm;

        hdc = GetDC(m_hwndListView);
        GetTextMetrics(hdc, &tm);
        ReleaseDC(m_hwndListView, hdc);
        //
        // Nothing special about the +2.  Without it, we get trailing ellipsis.
        //
        col.cx = tm.tmAveCharWidth * (lstrlen(col.pszText) + 2);
    }
    else
        col.cx = ColDesc.cx;  // Use width from col descriptor.


    col.iSubItem = iSubItem;
    col.fmt      = ColDesc.fmt;
    col.mask     = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;

    if (-1 != ListView_InsertColumn(m_hwndListView, iSubItem, &col))
        m_ColMap.InsertId(iSubItem, ColDesc.iColId);
    else
        hResult = E_FAIL;

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::AddImages

    Description: Adds icon images to the list view's image lists.  These
        icons are used in the status column to indicate overrun of the
        quota threshold and limit.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - One or more icons could not be loaded.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::AddImages(
    VOID
    )
{
    HRESULT hResult         = NO_ERROR;
    HIMAGELIST hSmallImages = NULL;

    //
    // Create the image lists for the listview.
    //
    hSmallImages = ImageList_Create(BITMAP_WIDTH, BITMAP_HEIGHT, ILC_MASK, 3, 0);

    //
    // Note:  The order of these icon ID's in this array must match with the
    //        iIMAGELIST_ICON_XXXXX macros defined at the top of this file.
    //        The macro values represent the image indices in the image list.
    //
    struct IconDef
    {
        LPTSTR szName;
        HINSTANCE hInstDll;
    } rgIcons[] = {
                    { MAKEINTRESOURCE(IDI_OKBUBBLE), g_hInstDll },
                    { IDI_WARNING,                   NULL       },
                    { MAKEINTRESOURCE(IDI_WARNERR),  g_hInstDll }
                  };

    for (UINT i = 0; i < ARRAYSIZE(rgIcons) && SUCCEEDED(hResult); i++)
    {
        HICON hIcon = LoadIcon(rgIcons[i].hInstDll, rgIcons[i].szName);

        if (NULL != hIcon)
        {
            ImageList_AddIcon(hSmallImages, hIcon);
            DestroyIcon(hIcon);
        }
        else
        {
            DBGERROR((TEXT("LISTVIEW - Error loading icon")));
            hResult = E_FAIL;
        }
    }
    ImageList_SetBkColor(hSmallImages, CLR_NONE);  // Transparent background.

    ListView_SetImageList(m_hwndListView, hSmallImages, LVSIL_SMALL);

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateListViewToolTip

    Description: Creates a tooltip window for displaying the user's folder
        name when the Folder column is hidden.  The entire listview
        is defined as a single tool.  We make the tooltip control think
        each listview item is a separate tool by intercepting WM_MOUSEMOVE,
        and performing a hit test to determine which listview item is hit.
        If the cursor has moved over a new item, the tooltip control is sent
        a WM_MOUSEMOVE(0,0).  The next real WM_MOUSEMOVE that we relay to the
        tooltip makes it think that it is on a new tool.  This is required
        so that tooltips popup and hide appropriately.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed to create tooltip window.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateListViewToolTip(
    VOID
    )
{
    HRESULT hResult = E_FAIL;

    m_hwndListViewToolTip = CreateWindowEx(0,
                                           TOOLTIPS_CLASS,
                                           (LPTSTR)NULL,
                                           TTS_ALWAYSTIP,
                                           CW_USEDEFAULT,
                                           CW_USEDEFAULT,
                                           CW_USEDEFAULT,
                                           CW_USEDEFAULT,
                                           m_hwndListView,
                                           (HMENU)NULL,
                                           g_hInstDll,
                                           NULL);
    if (NULL != m_hwndListViewToolTip)
    {
        TOOLINFO ti;

        //
        // Set tooltip timing parameter so that it pops up after
        // 1/2 second of no-mouse-movement.
        //
        SendMessage(m_hwndListViewToolTip,
                    TTM_SETDELAYTIME,
                    TTDT_INITIAL,
                    (LPARAM)500);

        ti.cbSize      = sizeof(TOOLINFO);
        ti.uFlags      = TTF_IDISHWND;
        ti.hwnd        = m_hwndListView;
        ti.hinst       = g_hInstDll;
        ti.uId         = (UINT_PTR)m_hwndListView;  // Treat entire LV as a tool.
        ti.lpszText    = LPSTR_TEXTCALLBACK;

        if (SendMessage(m_hwndListViewToolTip,
                        TTM_ADDTOOL,
                        0,
                        (LPARAM)&ti))
        {
            hResult = NO_ERROR;
        }
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateStatusBar

    Description: Creates the status bar.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed to create status bar.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateStatusBar(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != m_hwndMain));
    m_hwndStatusBar = CreateWindow(STATUSCLASSNAME,
                                   TEXT(""),
                                   WS_VISIBLE | WS_CHILD | WS_BORDER | SBS_SIZEGRIP,
                                   0, 0, 0, 0,
                                   m_hwndMain,
                                   (HMENU)NULL,
                                   g_hInstDll,
                                   NULL);
    if (NULL != m_hwndStatusBar)
    {
        //
        // Show/hide status bar according to registry setting.
        //
        if (!m_lvsi.fStatusBar)
            ShowWindow(m_hwndStatusBar, SW_HIDE);

        //
        // Check the menu item to indicate the current status bar state.
        //
        CheckMenuItem(GetMenu(m_hwndMain),
                      IDM_VIEW_STATUSBAR,
                      MF_BYCOMMAND | (m_lvsi.fStatusBar ? MF_CHECKED : MF_UNCHECKED));
    }
    else
    {
        hResult = E_FAIL;
        DBGERROR((TEXT("LISTVIEW - Failed creating status bar."), hResult));
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateToolBar

    Description: Creates the tool bar.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed to create status bar.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/26/97    Changed to flat toolbar buttons.                     BrianAu
    05/20/97    Added "Find User" button and combo box.              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateToolBar(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    //
    // Array describing each of the tool bar buttons.
    //
    TBBUTTON rgToolBarBtns[] = {
        { STD_FILENEW,     IDM_QUOTA_NEW,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { STD_DELETE,      IDM_QUOTA_DELETE,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { STD_PROPERTIES,  IDM_QUOTA_PROPERTIES, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { STD_UNDO,        IDM_EDIT_UNDO,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { STD_FIND,        IDM_EDIT_FIND,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0}
        };

    DBGASSERT((NULL != m_hwndMain));

    m_hwndToolBar = CreateToolbarEx(m_hwndMain,
                                    WS_CHILD | WS_BORDER | WS_VISIBLE | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT,
                                    IDC_TOOLBAR,
                                    15,
                                    (HINSTANCE)HINST_COMMCTRL,
                                    IDB_STD_SMALL_COLOR,
                                    (LPCTBBUTTON)rgToolBarBtns,
                                    ARRAYSIZE(rgToolBarBtns),
                                    0,
                                    0,
                                    100,
                                    30,
                                    sizeof(TBBUTTON));

    if (NULL != m_hwndToolBar)
    {
        //
        // FEATURE:  I'm creating this combo without the WS_VISIBLE
        //          attribute set.  I originally coded this to have a
        //          "find" dropdown combo in the toolbar similar to that
        //          found in MS Dev Studio.  Later we decided that this
        //          was unnecessarily redundant with the "find" dialog
        //          and it's dropdown combo.  I'm leaving the code for
        //          two reasons.
        //             1. I don't want to break the existing implementation.
        //             2. If we decide later to re-enable the feature it will
        //                be easy to reactivate.
        //
        //          [brianau - 1/20/98]
        //
        m_hwndToolbarCombo = CreateWindowEx(0,
                                            TEXT("COMBOBOX"),
                                            TEXT(""),
                                            WS_CHILD | WS_BORDER |
                                            CBS_HASSTRINGS | CBS_DROPDOWN |
                                            CBS_AUTOHSCROLL,
                                            0, 0,
                                            CX_TOOLBAR_COMBO,
                                            CY_TOOLBAR_COMBO,
                                            m_hwndToolBar,
                                            (HMENU)IDC_TOOLBAR_COMBO,
                                            g_hInstDll,
                                            NULL);
        if (NULL != m_hwndToolbarCombo)
        {
            //
            // Set the font in the toolbar combo to be the same as that
            // used in listview.  This assumes that the listview
            // has already been created.
            //
            DBGASSERT((NULL != m_hwndListView));
            HFONT hfontMain = (HFONT)SendMessage(m_hwndListView, WM_GETFONT, 0, 0);
            SendMessage(m_hwndToolbarCombo, WM_SETFONT, (WPARAM)hfontMain, 0);

            //
            // Initialize the "user finder" object so that it knows
            // how to communicate with the toolbar combo box.
            //
            m_pUserFinder->ConnectToolbarCombo(m_hwndToolbarCombo);

            //
            // Retrieve the finder's MRU list contents from the registry and
            // load the toolbar's combo box.
            // The check for cMruEntries < MAX_FINDMRU_ENTRIES is to prevent
            // this loop from running wild if someone trashes the registry entry.
            //
            RegKey keyPref(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
            if (SUCCEEDED(keyPref.Open(KEY_READ)))
            {
                CArray<CString> rgstrMRU;
                if (SUCCEEDED(keyPref.GetValue(REGSTR_VAL_FINDMRU, &rgstrMRU)))
                {
                    int n = rgstrMRU.Count();
                    for (int i = 0; i < n; i++)
                    {
                        SendMessage(m_hwndToolbarCombo,
                                    CB_ADDSTRING,
                                    0,
                                    (LPARAM)(rgstrMRU[i].Cstr()));
                    }
                }
            }
        }

        //
        // Show/hide tool bar according to registry setting.
        //
        if (!m_lvsi.fToolBar)
            ShowWindow(m_hwndToolBar, SW_HIDE);

        //
        // Check the menu item to indicate the current tool bar state.
        //
        CheckMenuItem(GetMenu(m_hwndMain),
                      IDM_VIEW_TOOLBAR,
                      MF_BYCOMMAND | (m_lvsi.fToolBar ? MF_CHECKED : MF_UNCHECKED));
        //
        // Initially, we have nothing in the undo list.
        //
        EnableMenuItem_Undo(FALSE);
    }
    else
    {
        hResult = E_FAIL;
        DBGERROR((TEXT("LISTVIEW - Failed creating tool bar."), hResult));
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::LoadObjects

    Description: Loads the user object list with quota record objects.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed enumerating users or adding objects to listview.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::LoadObjects(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != m_pQuotaControl));


    //
    // Use a user enumerator object for obtaining all of the quota users.
    //
    IEnumDiskQuotaUsers *pEnumUsers = NULL;

    hResult = m_pQuotaControl->CreateEnumUsers(
                            NULL,                             // All entries.
                            0,                                // All entries.
                            DISKQUOTA_USERNAME_RESOLVE_ASYNC, // Asynchronous operation.
                            &pEnumUsers);
    if (SUCCEEDED(hResult))
    {
        IDiskQuotaUser *pUser = NULL;
        hResult = S_OK;

        //
        // m_bStopLoadingObjects is sort of a hack so that we can interrupt
        // object loading if the user closes the view while loading is in progress.
        //
        // This is probably the most speed-critical loop in the disk quota UI.
        // The faster it is, the less time the user must wait for the listview
        // to be populated with user objects.
        //
        try
        {
            //
            // Go ahead and take a lock on the user list during the entire loading
            // process.  This will let the list locking code in m_UserList.Append
            // proceded without having to obtain the lock each time.
            //
            m_UserList.Lock();
            while(!m_bStopLoadingObjects)
            {
                DWORD cUsers = 1;

                hResult = pEnumUsers->Next(cUsers, &pUser, &cUsers);
                if (S_OK == hResult)
                {
                    m_UserList.Append(pUser);
                }
                else
                {
                    break;
                }

                pUser = NULL;
            }
            pEnumUsers->Release();  // Release the enumerator.
            pEnumUsers = NULL;
            m_UserList.ReleaseLock();
        }
        catch(CAllocException& e)
        {
            //
            // Clean up before re-throwing exception.
            // Leave m_UserList in the pre-exception state.
            //
            if (NULL != pUser)
                pUser->Release();
            if (NULL != pEnumUsers)
                pEnumUsers->Release();
            m_UserList.ReleaseLock();

            m_bStopLoadingObjects = FALSE;
            hResult = E_OUTOFMEMORY;
        }
    }

    if (S_FALSE == hResult)     // Means no-more-users.
        hResult = NO_ERROR;

#if DBG
    if (FAILED(hResult))
    {
        DBGERROR((TEXT("LISTVIEW - Failed loading objects.  Result = 0x%08X"),
                 hResult));
    }
#endif

    m_bStopLoadingObjects = FALSE;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::ReleaseObjects

    Description: Releases all objects from the user object list (listview).

    Arguments: None.

    Returns: Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/21/97    Ownerdata listview. Added m_UserList.                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::ReleaseObjects(
    VOID
    )
{
    //
    // Destroy the user objects in the list.
    //
    PDISKQUOTA_USER pUser = NULL;
    m_UserList.Lock();
    while(m_UserList.RemoveLast((LPVOID *)&pUser))
    {
        if (NULL != pUser)
            pUser->Release();
    }
    m_UserList.ReleaseLock();

    return NO_ERROR;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::SortObjects

    Description: Sort objects in the list view using a given column as the key.

    Arguments:
        idColumn - Number of the column (0-based) to use as the key.

        dwDirection - 0 = Ascending sort, 1 = Descending sort.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/24/97    Added m_UserList.  Ownerdata listview.               BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::SortObjects(
    DWORD idColumn,
    DWORD dwDirection
    )
{
    DBGASSERT((idColumn < DetailsView::idCol_Last));

    CAutoWaitCursor waitcursor;
    COMPARESTRUCT cs;

    cs.idColumn    = idColumn;
    cs.dwDirection = dwDirection;
    cs.pThis       = this;

    m_UserList.Lock();
    m_UserList.Sort(CompareItems, (LPARAM)&cs);
    InvalidateRect(m_hwndListView, NULL, TRUE);
    UpdateWindow(m_hwndListView);
    m_UserList.ReleaseLock();

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CompareItems [static]

    Description: Compares two items from the details view.
        Note that it's a static method so there's no "this" pointer.

    Arguments:
        lParam1 - Address of first user object.

        lParam2 - Address of second user object.

        lParam3 - Address of a COMPARESTRUCT structure.

    Returns:
        < 0 = User 1 is "less than" user 2.
          0 = Users are "equivalent".
        > 0 = User 1 is "greater than" user 2.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
    05/19/97    Fixed overflow in difference calculations.           BrianAu
                Changed type of "diff" from INT to __int64.
    07/18/97    Use CompareString for name comparisons.              BrianAu
                Need to be locale-sensitive.
*/
///////////////////////////////////////////////////////////////////////////////
INT
DetailsView::CompareItems(
    LPVOID lParam1,
    LPVOID lParam2,
    LPARAM lParam3
    )
{
    INT i[2];
    __int64 diff = 0;
    PDISKQUOTA_USER pUser[2];
    LONGLONG llValue[2];
    PCOMPARESTRUCT pcs = (PCOMPARESTRUCT)lParam3;
    DBGASSERT((NULL != pcs));
    DetailsView *pThis = pcs->pThis;
    pUser[0] = (PDISKQUOTA_USER)lParam1;
    pUser[1] = (PDISKQUOTA_USER)lParam2;

    i[0] = pcs->dwDirection; // Sort direction (0 = ascending, 1 = descending)
    i[1] = i[0] ^ 1;         // Opposite of i[0].

    DBGASSERT((NULL != pUser[0]));
    DBGASSERT((NULL != pUser[1]));

    switch(pcs->idColumn)
    {
        case DetailsView::idCol_Name:
        case DetailsView::idCol_LogonName:
        case DetailsView::idCol_Folder:
        {
            DWORD dwAccountStatus[2];
            pUser[0]->GetAccountStatus(&dwAccountStatus[0]);
            pUser[1]->GetAccountStatus(&dwAccountStatus[1]);

            if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus[0] &&
                DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus[1])
            {
                //
                // Both users have valid logon name  strings.
                //
                INT iCompareResult;         // For CompareString.
                TCHAR szContainer[2][MAX_DOMAIN];
                TCHAR szName[2][MAX_USERNAME];
                TCHAR szLogonName[2][MAX_USERNAME];
                pUser[0]->GetName(szContainer[0], ARRAYSIZE(szContainer[0]),
                                  szLogonName[0], ARRAYSIZE(szLogonName[0]),
                                  szName[0],      ARRAYSIZE(szName[0]));

                pUser[1]->GetName(szContainer[1], ARRAYSIZE(szContainer[1]),
                                  szLogonName[1], ARRAYSIZE(szLogonName[1]),
                                  szName[1],      ARRAYSIZE(szName[1]));

                if (DetailsView::idCol_Folder == pcs->idColumn)
                {
                    //
                    // Sort by container + logon name.
                    // Use CompareString so we're locale-sensitive.
                    //
                    iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                   NORM_IGNORECASE,
                                                   szContainer[ i[0] ], -1,
                                                   szContainer[ i[1] ], -1);
                    if (CSTR_EQUAL == iCompareResult)
                    {
                        iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                       NORM_IGNORECASE,
                                                       szLogonName[ i[0] ], -1,
                                                       szLogonName[ i[1] ], -1);
                    }
                }
                else if (DetailsView::idCol_Name == pcs->idColumn)
                {
                    //
                    // Sort by display name + container.
                    // Use CompareString so we're locale-sensitive.
                    //
                    iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                   NORM_IGNORECASE,
                                                   szName[ i[0] ], -1,
                                                   szName[ i[1] ], -1);

                    if (CSTR_EQUAL == iCompareResult)
                    {
                        iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                       NORM_IGNORECASE,
                                                       szContainer[ i[0] ], -1,
                                                       szContainer[ i[1] ], -1);
                    }
                }
                else if (DetailsView::idCol_LogonName == pcs->idColumn)
                {
                    //
                    // Sort by logon name + container.
                    // Use CompareString so we're locale-sensitive.
                    //
                    iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                   NORM_IGNORECASE,
                                                   szLogonName[ i[0] ], -1,
                                                   szLogonName[ i[1] ], -1);

                    if (CSTR_EQUAL == iCompareResult)
                    {
                        iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                       NORM_IGNORECASE,
                                                       szContainer[ i[0] ], -1,
                                                       szContainer[ i[1] ], -1);
                    }
                }
                //
                // Convert iCompareResult [1,2,3] to [-1,0,1].
                //
                diff = iCompareResult - 2;
            }
            else
            {
                //
                // At least one of the users hasn't been or can't be resolved.
                // Compare by account status alone.  Status values are such
                // that a resolved name will sort before an unresolved name.
                // Cast to (INT) is required for proper ordering.
                //
                diff = (INT)dwAccountStatus[ i[0] ] - (INT)dwAccountStatus[ i[1] ];
            }
            break;
        }
        case DetailsView::idCol_Status:
        {
            //
            // The status image is based on the quota "state" of the user.
            // This expression effectively compares user records by status image.
            //
            diff = (pThis->GetUserQuotaState(pUser[ i[0] ]) - pThis->GetUserQuotaState(pUser[ i[1] ]));
            break;
        }
        case DetailsView::idCol_AmtUsed:
        {
            pUser[0]->GetQuotaUsed(&llValue[0]);
            pUser[1]->GetQuotaUsed(&llValue[1]);
            diff = llValue[ i[0] ] - llValue[ i[1] ];
            break;
        }
        case DetailsView::idCol_Limit:
        {
            pUser[0]->GetQuotaLimit(&llValue[0]);
            pUser[1]->GetQuotaLimit(&llValue[1]);

            if (NOLIMIT == llValue[ i[0] ])
                diff = 1;
            else if (NOLIMIT == llValue[ i[1] ])
                diff = -1;
            else
                diff = llValue[ i[0] ] - llValue[ i[1] ];
            break;
        }
        case DetailsView::idCol_Threshold:
        {
            pUser[0]->GetQuotaThreshold(&llValue[0]);
            pUser[1]->GetQuotaThreshold(&llValue[1]);

            if (NOLIMIT == llValue[ i[0] ])
                diff = 1;
            else if (NOLIMIT == llValue[ i[1] ])
                diff = -1;
            else
                diff = llValue[ i[0] ] - llValue[ i[1] ];
            break;
        }
        case DetailsView::idCol_PctUsed:
        {
            DWORD dwPct[2];
            CalcPctQuotaUsed(pUser[0], &dwPct[0]);
            CalcPctQuotaUsed(pUser[1], &dwPct[1]);
            diff = (INT)dwPct[ i[0] ] - (INT)dwPct[ i[1] ];
            break;
        }

        default:
            break;
    }

    //
    // Translate return value to -1, 0 or 1.
    //
    INT iReturn = 0;
    if (0 != diff)
    {
        if (0 < diff)
            iReturn = 1;
        else
            iReturn = -1;
    }

    return iReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::WndProc

    Description: Window procedure for the details view main window.  This
        method merely dispatches the messages to other methods that do the
        actual work.  These work methods should be declared "inline".

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK
DetailsView::WndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    //
    // Retrieve the DetailsView object's "this" pointer from the window's
    // USERDATA.
    //
    DetailsView *pThis = (DetailsView *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    try
    {
        switch(message)
        {
            case WM_CREATE:
            {
                CREATESTRUCT *pcs = (CREATESTRUCT *)lParam;
                PWNDCREATE_DATA pCreateData = (PWNDCREATE_DATA)(pcs->lpCreateParams);
                DBGASSERT((NULL != pCreateData));

                pThis = (DetailsView *)(pCreateData->pThis);
                DBGASSERT((NULL != pThis));
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (INT_PTR)pThis);

                InitCommonControls();
                return 0;
            }

            case WM_COMMAND:
                DBGASSERT((NULL != pThis));
                pThis->OnCommand(hWnd, message, wParam, lParam);
                //
                // Enable the "Undo" menu if the undo list is not empty.
                //
                pThis->EnableMenuItem_Undo(0 != pThis->m_pUndoList->Count());
                return 0;

            case WM_CONTEXTMENU:
                DBGASSERT((NULL != pThis));
                pThis->OnContextMenu(hWnd, message, wParam, lParam);
                return 0;

            case WM_CLOSE:
            case WM_ENDSESSION:
                DestroyWindow(hWnd);
                return 0;

            case WM_DESTROY:
                DBGASSERT((NULL != pThis));
                pThis->OnDestroy(hWnd, message, wParam, lParam);
                return 0;

            case WM_ADD_USER_TO_DETAILS_VIEW:  // This is DSKQUOTA-specific.
                DBGASSERT((NULL != pThis));
                pThis->AddUser((PDISKQUOTA_USER)lParam);
                return 0;

            case WM_MAINWINDOW_CREATED:  // This is DSKQUOTA-specific.
                DBGASSERT((NULL != pThis));
                pThis->OnMainWindowCreated(hWnd, message, wParam, lParam);
                return 0;

            case WM_MENUSELECT:
                DBGASSERT((NULL != pThis));
                pThis->OnMenuSelect(hWnd, message, wParam, lParam);
                return 0;

            case WM_NOTIFY:
                DBGASSERT((NULL != pThis));
                pThis->OnNotify(hWnd, message, wParam, lParam);
                return 0;

            case WM_SETFOCUS:
                DBGASSERT((NULL != pThis));
                pThis->OnSetFocus(hWnd, message, wParam, lParam);
                return 0;

            case WM_SIZE:
                DBGASSERT((NULL != pThis));
                pThis->OnSize(hWnd, message, wParam, lParam);
                return 0;

            case WM_SYSCOLORCHANGE:
            case WM_SETTINGCHANGE:
                DBGASSERT((NULL != pThis));
                pThis->OnSettingChange(hWnd, message, wParam, lParam);
                return 0;

            default:
                break;
        }
    }
    catch(CAllocException& e)
    {
        //
        // Handle out-of-memory errors here.  Any other exceptions
        // can be thrown to caller.  Let ThreadProc handle them.
        //
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return DefWindowProc(hWnd, message, wParam, lParam);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::LVSubClassWndProc

    Description: Window proc for the sub-classed listview control.
        This is required so that we can intecept mouse messages and respond
        to the request for tooltip text.

    Arguments: Std windows WndProc args.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK
DetailsView::LVSubClassWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DetailsView *pThis = (DetailsView *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch(message)
    {
        case WM_NOTIFY:
            {
                //
                // Only return ToolTip text if TTN_NEEDTEXT is being
                // sent from our tooltip.  Don't respond to the listview's
                // internal tooltip's request for text.
                //
                LV_DISPINFO *pDispInfo  = (LV_DISPINFO *)lParam;
                if (pDispInfo->hdr.hwndFrom == pThis->m_hwndListViewToolTip)
                {
                    switch(pDispInfo->hdr.code)
                    {
                        case TTN_NEEDTEXT:
//
// FEATURE:  With the removal of the "domain" term from the UI, I
//          decided we don't need this tooltip any more.
//          However, I'm making this change in the last hour before
//          "code complete" and I don't want to break something else.
//          Therefore I'm just commenting this out and leaving the
//          subclassing in place.  If there's time later, this subclassing
//          of the listview should be removed. [brianau - 03/19/98]
//
//                            pThis->LV_OnTTN_NeedText((TOOLTIPTEXT *)lParam);
                            return 0;

                        default:
                            break;
                    }
                }
            }
            break;

        case WM_MOUSEMOVE:
            DBGASSERT((NULL != pThis));
            pThis->LV_OnMouseMessages(hWnd, message, wParam, lParam);
            break;

        case WM_ADD_USER_TO_DETAILS_VIEW:  // This is DSKQUOTA-specific.
            DBGASSERT((NULL != pThis));
            pThis->AddUser((PDISKQUOTA_USER)lParam);
            break;

        default:
            break;
    }
    DBGASSERT((NULL != pThis->m_lpfnLVWndProc));
    return CallWindowProc(pThis->m_lpfnLVWndProc, hWnd, message, wParam, lParam);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCommand

    Description: Handler for WM_COMMAND.

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    09/06/96    Added "Show Domain" menu option.                     BrianAu
    05/20/97    Added IDM_EDIT_FIND and IDM_EDIT_FIND_LIST.          BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCommand(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(LOWORD(wParam))
    {
        case IDM_EDIT_INVERTSELECTION:
            InvertSelectedItems();
            break;

        case IDM_EDIT_UNDO:
            OnCmdUndo();
            break;

        case IDM_EDIT_FIND:
            OnCmdFind();
            break;

        case IDM_EDIT_FIND_LIST:
            SetFocus(m_hwndToolbarCombo);
            break;

        case IDM_EDIT_SELECTALL:
            SelectAllItems();
            break;

        case IDM_EDIT_COPY:
            OnCmdEditCopy();
            break;

        case IDM_HELP_ABOUT:
            OnHelpAbout(hWnd);
            break;

        case IDM_HELP_TOPICS:
            OnHelpTopics(hWnd);
            break;

        case IDM_QUOTA_CLOSE:
            DestroyWindow(m_hwndMain);
            break;

        case IDM_QUOTA_DELETE:
            OnCmdDelete();
            FocusOnSomething();      // Needed if DEL key pressed.
            break;

        case IDM_QUOTA_NEW:
            OnCmdNew();
            break;

        case IDM_QUOTA_PROPERTIES:
            OnCmdProperties();
            break;

        case IDM_QUOTA_IMPORT:
            OnCmdImport();
            break;

        case IDM_QUOTA_EXPORT:
            OnCmdExport();
            break;

        case IDM_VIEW_ARRANGE_BYFOLDER:
            SortObjects(DetailsView::idCol_Folder, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYLIMIT:
            SortObjects(DetailsView::idCol_Limit, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYNAME:
            SortObjects(DetailsView::idCol_Name, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYLOGONNAME:
            SortObjects(DetailsView::idCol_LogonName, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYPERCENT:
            SortObjects(DetailsView::idCol_PctUsed, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYTHRESHOLD:
            SortObjects(DetailsView::idCol_Threshold, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYSTATUS:
            SortObjects(DetailsView::idCol_Status, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYUSED:
            SortObjects(DetailsView::idCol_AmtUsed, m_fSortDirection);
            break;

        case IDM_VIEW_REFRESH:
            Refresh(true);
            break;

        case IDM_VIEW_STATUSBAR:
            OnCmdViewStatusBar();
            break;

        case IDM_VIEW_TOOLBAR:
            OnCmdViewToolBar();
            break;
        case IDM_VIEW_SHOWFOLDER:
            OnCmdViewShowFolder();
            break;
//
// These are just for development.
//
//      case IDM_CLEAR_CACHE:
//          m_pQuotaControl->InvalidateSidNameCache();
//          break;

        default:
            break;
    }
    return 0;
}


LRESULT
DetailsView::OnSettingChange(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND rghwnd[] = { m_hwndListView,
                      m_hwndStatusBar,
                      m_hwndToolBar,
                      m_hwndToolbarCombo,
                      m_hwndListViewToolTip,
                      m_hwndHeader };

    for (int i = 0; i < ARRAYSIZE(rghwnd); i++)
    {
        SendMessage(rghwnd[i], uMsg, wParam, lParam);
    }
    return 0;
}


//
// Is an x,y screen position in the LV header control?
//
BOOL
DetailsView::HitTestHeader(
    int xPos,
    int yPos
    )
{
    RECT rcHdr;
    POINT pt = { xPos, yPos };

    GetWindowRect(m_hwndHeader, &rcHdr);
    return PtInRect(&rcHdr, pt);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnContextMenu

    Description: Handler for WM_CONTEXTMENU.
        Creates and tracks a popup context menu for deleting
        selected object(s) and showing their properties.


    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnContextMenu(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Only display menu if the message is from the list view and there's
    // one or more objects selected in the list view.
    //
    if ((HWND)wParam == m_hwndListView &&
        !HitTestHeader(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)) &&
        ListView_GetSelectedCount(m_hwndListView) > 0)
    {
        HMENU hMenu = LoadMenu(g_hInstDll, MAKEINTRESOURCE(IDM_CONTEXT_MENU));
        if (NULL != hMenu)
        {
            HMENU hMenuTrackPopup = GetSubMenu(hMenu, 0);

            SetMenuDefaultItem(hMenuTrackPopup, IDM_QUOTA_PROPERTIES, MF_BYCOMMAND);

            if (LPARAM(-1) == lParam)
            {
                //
                // Invoked from keyboard.  Place menu at focused item.
                //
                POINT pt = { -1, -1 };
                int i = ListView_GetNextItem(m_hwndListView, -1, LVNI_FOCUSED);
                if (i != -1)
                {
                    ListView_GetItemPosition(m_hwndListView, i, &pt);
                    ClientToScreen(m_hwndListView, &pt);
                }

                lParam = MAKELPARAM(pt.x, pt.y);
            }
            if (LPARAM(-1) != lParam)
            {
                TrackPopupMenu(hMenuTrackPopup,
                               TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                               GET_X_LPARAM(lParam),
                               GET_Y_LPARAM(lParam),
                               0,
                               hWnd,
                               NULL);
            }
            DestroyMenu(hMenu);
        }
    }

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnDestroy

    Description: Handler for WM_DESTROY.

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnDestroy(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // We don't want to destroy the view window while a user-name-changed
    // update is in progress.  Likewise, we don't want to perform a name
    // update if the view is being (or has been) destroyed.  The crit sec
    // m_csAsyncUpdate and the flag m_bDestroyingView work together to
    // ensure this.
    //
    EnterCriticalSection(&m_csAsyncUpdate);

    m_bDestroyingView     = TRUE;  // Destruction of DetailsView in progress.
    m_bStopLoadingObjects = TRUE;  // Will terminate in-progress loading.

    //
    // Unregister the main window as an OLE drop target.
    //
    if (NULL != hWnd)
    {
        RegisterAsDropTarget(FALSE);
    }

    //
    // Cancel subclassing of the listview control.
    //
    if (NULL != m_lpfnLVWndProc)
        SetWindowLongPtr(m_hwndListView, GWLP_WNDPROC, (INT_PTR)m_lpfnLVWndProc);

    DisconnectEventSink();

    if (NULL != m_pQuotaControl)
    {
        m_pQuotaControl->Release();
        m_pQuotaControl = NULL;
    }

    //
    // Save the view dimensions and column widths to the registry.
    // We want the user to be able to configure the view and leave it.
    //
    SaveViewStateToRegistry();

    //
    // If we have a data object on the clipboard, clear the clipboard.
    // Note that the clipboard holds the reference to the data object.
    // When we clear the clipboard, the data object will be released.
    //
    if (NULL != m_pIDataObjectOnClipboard &&
       S_OK == OleIsCurrentClipboard(m_pIDataObjectOnClipboard))
    {
        OleFlushClipboard();
    }

    //
    // All done now.  Post a WM_QUIT message to the thread to tell
    // it to exit.  On termination, the thread proc will release
    // the view object, calling the destructor.
    //
    PostMessage(hWnd, WM_QUIT, 0, 0);

    LeaveCriticalSection(&m_csAsyncUpdate);
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::RegisterAsDropTarget

    Description: Registers or De-Registers the details view window as
        an OLE drop target.

    Arguments:
        bActive - If TRUE, registers as a drop target.
                  If FALSE, un-registers as a drop target.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::RegisterAsDropTarget(
    BOOL bActive
    )
{
    if (bActive)
    {
        //
        // Register as a drop target.
        //
        CoLockObjectExternal(static_cast<IDropTarget *>(this), TRUE, FALSE);
        RegisterDragDrop(m_hwndMain, static_cast<IDropTarget *>(this));
    }
    else
    {
        //
        // Un-register as a drop target.
        //
        RevokeDragDrop(m_hwndMain);
        CoLockObjectExternal(static_cast<IDropTarget *>(this), FALSE, TRUE);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::SaveViewStateToRegistry

    Description: Saves the listview height/width and the column widths to
        the registry.  When the listview is created, these values are used
        to size it so that the user doesn't always have to re-configure the
        view every time they open it.  Also saves the visibility state of the
        toolbar, statusbar and folder column.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/25/96    Initial creation.                                    BrianAu
    05/20/97    Added FindMRU list to persistent reg data.           BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::SaveViewStateToRegistry(
    VOID
    )
{
    RECT rc;
    HDC hdc = GetDC(m_hwndMain);

    RegKey keyPref(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
    if (FAILED(keyPref.Open(KEY_WRITE, true)))
    {
        DBGERROR((TEXT("Error opening reg key \"%s\""), REGSTR_KEY_DISKQUOTA));
        return;
    }

    m_lvsi.cb = sizeof(LV_STATE_INFO);

    //
    // Save current screen resolution.
    //
    m_lvsi.cxScreen = (WORD)GetDeviceCaps(hdc, HORZRES);
    m_lvsi.cyScreen = (WORD)GetDeviceCaps(hdc, VERTRES);
    ReleaseDC(m_hwndMain, hdc);

    //
    // Save current listview window size.
    //
    GetWindowRect(m_hwndMain, &rc);
    m_lvsi.cx = rc.right - rc.left;
    m_lvsi.cy = rc.bottom - rc.top;

    //
    // Save listview column widths.
    //
    UINT cColumns = Header_GetItemCount(m_hwndHeader);
    for (UINT i = 0; i < cColumns; i++)
    {
        m_lvsi.rgcxCol[i] = ListView_GetColumnWidth(m_hwndListView, i);
    }

    //
    // Save the current order of the columns in the listview.
    //
    DBGASSERT(cColumns <=  ARRAYSIZE(m_lvsi.rgColIndices));

    Header_GetOrderArray(m_hwndHeader, cColumns, m_lvsi.rgColIndices);

    //
    // Save column sorting state.
    // Casts are because we use a WORD bit field in the LVSI structure.
    //
    m_lvsi.iLastColSorted = (WORD)(m_iLastColSorted & 0xF);  // Uses only lower 4 bits.
    m_lvsi.fSortDirection = (WORD)m_fSortDirection;

    //
    // Write preference data to registry.
    //
    keyPref.SetValue(REGSTR_VAL_PREFERENCES, (LPBYTE)&m_lvsi, m_lvsi.cb);

    //
    // Save the contents of the Find MRU list.
    //
    UINT cNames = (UINT)SendMessage(m_hwndToolbarCombo, CB_GETCOUNT, 0, 0);
    if (CB_ERR != cNames && 0 < cNames)
    {
        CArray<CString> rgstrNames(cNames);
        for (i = 0; i < cNames; i++)
        {
            INT cchName = (INT)SendMessage(m_hwndToolbarCombo, CB_GETLBTEXTLEN, i, 0);
            if (CB_ERR != cchName && 0 < cchName)
            {
                CString s;
                cchName = (INT)SendMessage(m_hwndToolbarCombo, CB_GETLBTEXT, i, (LPARAM)s.GetBuffer(cchName + 1));
                s.ReleaseBuffer();
                if (CB_ERR != cchName)
                {
                    rgstrNames[i] = s;
                }
            }
        }
        keyPref.SetValue(REGSTR_VAL_FINDMRU, rgstrNames);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnMainWindowCreated

    Description: Handles WM_MAIN_WINDOW_CREATED.
        This message is posted by ThreadProc after main window creation is
        complete.  It does all the stuff to get the window up and running.

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnMainWindowCreated(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGASSERT((NULL != m_hwndMain));

    //
    // The accelerator table is automatically freed by Windows
    // when the app terminates.
    //
    m_hKbdAccel = LoadAccelerators(g_hInstDll,
                                   MAKEINTRESOURCE(IDR_KBDACCEL));

    CreateListView();
    CreateStatusBar();
    CreateToolBar();
    ConnectEventSink();
    ShowWindow(m_hwndMain, SW_SHOWNORMAL);
    UpdateWindow(m_hwndMain);
    //
    // Create the UNDO object.
    //
    m_pUndoList = new UndoList(&m_UserList, m_hwndListView);

    ShowItemCountInStatusBar();
    Refresh();
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnMenuSelect

    Description: Handles WM_MENUSELECT.
        If a menu item is currently selected AND the status bar is visible,
        the menu item's description is displayed in the status bar.  When
        the menu is closed, the status bar reverts back to an item count.

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnMenuSelect(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (0xFFFF == HIWORD(wParam) && NULL == (HMENU)lParam)
    {
        //
        // Menu closed.
        //
        m_bMenuActive = FALSE;
        ShowItemCountInStatusBar();
    }
    else
    {
        //
        // Item selected.
        //
        m_bMenuActive = TRUE;
        ShowMenuTextInStatusBar(LOWORD(wParam));
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnNotify

    Description: Handles all LVN_XXXXXX list view control notifications.
        Dispatches specific notifications to other handlers.

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnNotify(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    NMHDR *pnmhdr = (NMHDR *)lParam;

    switch(pnmhdr->code)
    {
        case NM_DBLCLK:
        case NM_RETURN:
            OnCmdProperties( );
            //
            // Enable/disable Undo menu item.
            //
            EnableMenuItem_Undo(0 != m_pUndoList->Count());
            break;

        case NM_SETFOCUS:
            FocusOnSomething(); // Something should always be highlighted.
            break;

        case LVN_ODFINDITEM:
            OnLVN_OwnerDataFindItem((NMLVFINDITEM *)lParam);
            break;

        case LVN_GETDISPINFO:
            OnLVN_GetDispInfo((LV_DISPINFO *)lParam);
            break;

        case LVN_BEGINDRAG:
            OnLVN_BeginDrag((NM_LISTVIEW *)lParam);
            break;

        case LVN_COLUMNCLICK:
            OnLVN_ColumnClick((NM_LISTVIEW *)lParam);
            break;

        case LVN_ITEMCHANGED:
            OnLVN_ItemChanged((NM_LISTVIEW *)lParam);
            break;

        case TTN_NEEDTEXT:
            OnTTN_NeedText((TOOLTIPTEXT *)lParam);
            //
            // Fall through.
            //

        default:
            break;
    }

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::LV_OnMouseMessages

    Description: Handles mouse messages for the subclassed listview control.
        These must be intercepted so that we can...

        a) Tell the tooltip when we've hit another listview item.
    and b) Forward all mouse messages to the tooltip window.

    Arguments: Standard WndProc args.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::LV_OnMouseMessages(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(message)
    {
        case WM_MOUSEMOVE:
            {
                //
                // If we've moved the mouse to another listview item,
                // make the tooltip window think we're over another tool.
                // The tooltip window thinks the entire listview is a single
                // tool but we want to treat each item as a separate tool.
                // Note that m_ptMouse.x and .y are recorded when the main
                // window receives WM_MOUSEMOVE.
                //
                LV_HITTESTINFO hti;
                INT iItem = 0;

                hti.pt.x = m_ptMouse.x = GET_X_LPARAM(lParam);
                hti.pt.y = m_ptMouse.y = GET_Y_LPARAM(lParam);

                if (-1 != (iItem = ListView_HitTest(m_hwndListView, &hti)))
                {
                    if (iItem != m_iLastItemHit)
                    {
                        SendMessage(m_hwndListViewToolTip, WM_MOUSEMOVE, 0, 0);
                        m_iLastItemHit = iItem;
                    }
                }
                else
                {
                    ShowWindow(m_hwndListViewToolTip, SW_HIDE);
                    m_iLastItemHit = iItem;
                }
            }

            //
            // Fall through.
            //
        case WM_LBUTTONUP:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONUP:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_RBUTTONDOWN:
            {
                //
                // Relay all mouse messages to the listview's tooltip control.
                //
                MSG msg;
                msg.hwnd    = hWnd;
                msg.message = message;
                msg.wParam  = wParam;
                msg.lParam  = lParam;

                SendMessage(m_hwndListViewToolTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);
            }
            break;

        default:
            break;
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdEditCopy

    Description: Handles WM_COMMAND, IDM_EDIT_COPY.  This is invoked whenever
        a user selects the Copy menu item or presses Ctrl + C.  The method
        creates a DataObject (same used in drag-drop) and places it on the
        OLE clipboard.  The data is rendered when OLE asks for it via
        IDataObject::GetData.

    Arguments: None.

    Returns: Always 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdEditCopy(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    hResult = QueryInterface(IID_IDataObject, (LPVOID *)&m_pIDataObjectOnClipboard);
    if (SUCCEEDED(hResult))
    {
        OleSetClipboard(m_pIDataObjectOnClipboard);
        //
        // OLE calls AddRef() so we can release the count added in QI.
        //
        m_pIDataObjectOnClipboard->Release();
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_BeginDrag

    Description: Called when the user has selected one or more items in the
        listview and begins a drag operation.  Creates a DropSource object
        and a DataObject then calls DoDragDrop() to execute the drag-drop
        operation.

        Note that we don't store the IDataObject pointer in
        m_IDataObjectOnClipboard.  That member is only for clipboard copy
        operations, not drag/drop.

    Arguments:
        pNm - Address of notification message structure.

    Returns: TRUE  = Succeeded.
             FALSE = Failed.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_BeginDrag(
    NM_LISTVIEW *pNm
    )
{
    DBGTRACE((DM_DRAGDROP, DL_HIGH, TEXT("DetailsView::OnLVN_BeginDragDrop")));
    HRESULT hResult           = NO_ERROR;
    IDataObject *pIDataObject = NULL;
    IDropSource *pIDropSource = NULL;

    DBGPRINT((DM_DRAGDROP, DL_HIGH, TEXT("DRAGDROP - Beginning Drag/Drop")));
    try
    {
        hResult = QueryInterface(IID_IDataObject, (LPVOID *)&pIDataObject);
        if (SUCCEEDED(hResult))
        {
            hResult = QueryInterface(IID_IDropSource, (LPVOID *)&pIDropSource);
            if (SUCCEEDED(hResult))
            {
                DWORD dwEffect = 0;

                //
                // Unregister our window as a drop target while we're acting as a drop
                // source.  Don't want to drop our own data onto our own window.
                //
                RegisterAsDropTarget(FALSE);

                hResult = DoDragDrop(pIDataObject,
                                     pIDropSource,
                                     DROPEFFECT_COPY | DROPEFFECT_MOVE,
                                     &dwEffect);

                //
                // FEATURE:  Should probably display some error UI here.
                //          The shell doesn't indicate any error if the
                //          destination volume is full or if there's a write
                //          error.  The only indication of a failure is that
                //          dwEffect will contain 0.  We could display something
                //          like "An error occured while transferring the selected
                //          items."  The big problem is that only the shell knows
                //          where the data was stored so only it could delete
                //          the created file.  Displaying a message but leaving
                //          the file is also confusing. [brianau 7/29/97]
                //          NT Bug 96282 will fix the shell not deleting the file.
                //
                RegisterAsDropTarget(TRUE);

                DBGPRINT((TEXT("DRAGDROP - Drag/Drop complete.\n\t hResult = 0x%08X  Effect = 0x%08X"),
                         hResult, dwEffect));

                pIDropSource->Release();
                pIDropSource = NULL;
            }
            pIDataObject->Release();
            pIDataObject = NULL;
        }
    }
    catch(CAllocException& e)
    {
        if (NULL != pIDropSource)
            pIDropSource->Release();
        if (NULL != pIDataObject)
            pIDataObject->Release();
        RegisterAsDropTarget(TRUE);
        throw;
    }
    return SUCCEEDED(hResult);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnTTN_NeedText

    Description: Handles requests for tooltip text for the main window's tool
        bar buttons.

    Arguments:
        pToolTipText - Address of tooltip text notification information.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
    07/09/97    Added cmd/TT cross reference.                        BrianAu
                Previously used the tool status text in tooltip.
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnTTN_NeedText(
    TOOLTIPTEXT *pToolTipText
    )
{
    //
    // Cross-reference tool command IDs with tooltip text IDs.
    //
    const struct
    {
        UINT idCmd;  // Tool cmd ID.
        UINT idTT;   // Tooltip text ID.

    } CmdTTXRef[] = {
                        { IDM_QUOTA_NEW,        IDS_TT_QUOTA_NEW        },
                        { IDM_QUOTA_DELETE,     IDS_TT_QUOTA_DELETE     },
                        { IDM_QUOTA_PROPERTIES, IDS_TT_QUOTA_PROPERTIES },
                        { IDM_EDIT_UNDO,        IDS_TT_EDIT_UNDO        },
                        { IDM_EDIT_FIND,        IDS_TT_EDIT_FIND        }
                    };
    INT idTT = -1;
    for (INT i = 0; i < ARRAYSIZE(CmdTTXRef) && -1 == idTT; i++)
    {
        if (CmdTTXRef[i].idCmd == pToolTipText->hdr.idFrom)
            idTT = CmdTTXRef[i].idTT;
    }

    if (-1 != idTT)
    {
        m_strDispText.Format(g_hInstDll, idTT);
        pToolTipText->lpszText = (LPTSTR)m_strDispText;
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::LV_OnTTN_NeedText

    Description: Handles requests for tooltip text for the listview tooltip
        window.  This is where we get the foldername DOMAIN/USERNAME text for when the
        "domain name" column is hidden.

    Arguments:
        pToolTipText - Address of tooltip text notification information.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
    10/11/96    Added support for draggable columns.                 BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::LV_OnTTN_NeedText(
    TOOLTIPTEXT *pToolTipText
    )
{
    //
    // Only provide text when the mouse is over the "User Name" column.
    //
    if (-1 != m_iLastItemHit)
    {
        INT cxMin    = 0;
        INT cxMax    = 0;
        INT cHdrs    = Header_GetItemCount(m_hwndHeader);

        for (INT i = 0; i < cHdrs; i++)
        {
            //
            // Find the left and right X coordinate for the "Name" column.
            //
            INT iCol  = Header_OrderToIndex(m_hwndHeader, i);
            INT cxCol = ListView_GetColumnWidth(m_hwndListView, iCol);
            if (DetailsView::idCol_Name == m_ColMap.SubItemToId(iCol))
            {
                cxMax = cxMin + cxCol;
                break;
            }
            else
            {
                cxMin += cxCol;
            }
        }
        //
        // cxMin now contains left edge of Name column.
        // cxMax now contains right edge of Name column.
        //
        if (m_ptMouse.x >= cxMin && m_ptMouse.x <= cxMax)
        {
            PDISKQUOTA_USER pUser = NULL;

            if (m_UserList.Retrieve((LPVOID *)&pUser, m_iLastItemHit))
            {
                TCHAR szContainer[MAX_DOMAIN]          = { TEXT('\0') };
                TCHAR szLogonName[MAX_USERNAME]        = { TEXT('\0') };
                TCHAR szDisplayName[MAX_FULL_USERNAME] = { TEXT('\0') };

                pUser->GetName(szContainer,   ARRAYSIZE(szContainer),
                               szLogonName, ARRAYSIZE(szLogonName),
                               szDisplayName, ARRAYSIZE(szDisplayName));

                if (TEXT('\0') != szContainer[0] && TEXT('\0') != szLogonName[0])
                {
                    if (TEXT('\0') != szDisplayName[0])
                        m_strDispText.Format(g_hInstDll,
                                      IDS_FMT_DISPLAY_LOGON_CONTAINER,
                                      szDisplayName,
                                      szLogonName,
                                      szContainer);
                    else
                        m_strDispText.Format(g_hInstDll,
                                      IDS_FMT_LOGON_CONTAINER,
                                      szLogonName,
                                      szContainer);

                    pToolTipText->lpszText = (LPTSTR)m_strDispText;
                }
                else
                {
                    pToolTipText->lpszText = NULL;
                    pToolTipText->szText[0] = TEXT('\0');
                }
            }
        }
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_OwnerDataFindItem

    Description: Handles LVN_ODFINDITEM for the listview control.

    Arguments:
        pFindInfo - Address of NMLVFINDITEM structure associated with the
            notification.

    Returns: 0-based index of found item.  -1 if not found.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/21/97    Initial creation.  Ownerdraw listview.               BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_OwnerDataFindItem(
    NMLVFINDITEM *pFindInfo
    )
{
    INT iItem = -1;
    switch(pFindInfo->lvfi.flags)
    {
        case LVFI_PARAM:
        {
            LPVOID pvUser = NULL;

            m_UserList.Lock();
            INT cUsers = m_UserList.Count();
            for (INT i = 0; i < cUsers; i++)
            {
                if (m_UserList.Retrieve(&pvUser, i) &&
                    pvUser == (LPVOID)pFindInfo->lvfi.lParam)
                {
                    iItem = i;
                    break;
                }
            }
            m_UserList.ReleaseLock();
            break;
        }

        default:
            //
            // This app only uses lParam for locating items.
            //
            break;
    }
    return iItem;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_GetDispInfo

    Description: Handles LVN_GETDISPINFO for the listview control.

    Arguments:
        pDispInfo - Address of LV_DISPINFO structure associated with the
            notification.

    Returns: Always 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/21/97    Initial creation.  Ownerdraw listview.               BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_GetDispInfo(
    LV_DISPINFO * pDispInfo
    )
{
    PDISKQUOTA_USER pUser = NULL;

    m_UserList.Retrieve((LPVOID *)&pUser, pDispInfo->item.iItem);
    if (NULL != pUser)
    {
        if (LVIF_TEXT & pDispInfo->item.mask)
            OnLVN_GetDispInfo_Text(pDispInfo, pUser);

        if ((LVIF_IMAGE & pDispInfo->item.mask) &&
           (m_ColMap.SubItemToId(pDispInfo->item.iSubItem) == DetailsView::idCol_Status))

        {
            OnLVN_GetDispInfo_Image(pDispInfo, pUser);
        }
    }
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_GetDispInfo_Text

    Description: Handles LVN_GETDISPINFO - LVIF_TEXT for the listview control.

    Arguments:
        pDispInfo - Address of LV_DISPINFO structure associated with the
            notification.

        pUser - Address of user object for listview item.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    09/22/96    Added user "full name" support.                      BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_GetDispInfo_Text(
    LV_DISPINFO *pDispInfo,
    PDISKQUOTA_USER pUser
    )
{
    HRESULT hResult = NO_ERROR;
    LONGLONG llValue;
    NUMBERFMT NumFmt;

    DBGASSERT((NULL != pDispInfo));
    DBGASSERT((NULL != pUser));

    NumFmt.NumDigits = 0;
    m_strDispText.Empty();

    switch(m_ColMap.SubItemToId(pDispInfo->item.iSubItem))
    {
        case DetailsView::idCol_Status:
            DBGASSERT((NULL != pUser));
            switch(GetUserQuotaState(pUser))
            {
                case iUSERSTATE_OK:
                    m_strDispText = m_strStatusOK;
                    break;
                case iUSERSTATE_WARNING:
                    m_strDispText = m_strStatusWarning;
                    break;
                default:
                    DBGASSERT((0));
                    //
                    // Fall through.
                    //
                case iUSERSTATE_OVERLIMIT:
                    m_strDispText = m_strStatusOverlimit;
                    break;
            }
            break;

        case DetailsView::idCol_Folder:
        {
            DWORD dwAccountStatus = 0;
            DBGASSERT((NULL != pUser));
            pUser->GetAccountStatus(&dwAccountStatus);
            if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
            {
                pUser->GetName(m_strDispText.GetBuffer(MAX_PATH),
                               MAX_PATH,
                               NULL,
                               0,
                               NULL,
                               0);
            }
            else
            {
                //
                // Non-normal account status.  Leave domain column
                // blank.  Account name column will contain status information.
                //
            }
            break;
        }

        case DetailsView::idCol_Name:
        {
            DWORD dwAccountStatus = 0;
            DBGASSERT((NULL != pUser));
            pUser->GetAccountStatus(&dwAccountStatus);
            switch(dwAccountStatus)
            {
                case DISKQUOTA_USER_ACCOUNT_RESOLVED:
                    pUser->GetName(NULL,       0,
                                   NULL,       0,
                                   m_strDispText.GetBuffer(MAX_USERNAME), MAX_USERNAME);

                    m_strDispText.ReleaseBuffer();
                    break;

                case DISKQUOTA_USER_ACCOUNT_UNRESOLVED:
                    m_strDispText = m_strAccountUnresolved;
                    break;

                case DISKQUOTA_USER_ACCOUNT_UNKNOWN:
                    m_strDispText = m_strAccountUnknown;
                    break;

                case DISKQUOTA_USER_ACCOUNT_INVALID:
                    m_strDispText = m_strAccountInvalid;
                    break;

                case DISKQUOTA_USER_ACCOUNT_DELETED:
                    m_strDispText = m_strAccountDeleted;
                    break;

                case DISKQUOTA_USER_ACCOUNT_UNAVAILABLE:
                    m_strDispText = m_strAccountUnavailable;
                    break;
            }
            break;
        }

        case DetailsView::idCol_LogonName:
        {
            DBGASSERT((NULL != pUser));

            DWORD dwAccountStatus = 0;
            pUser->GetAccountStatus(&dwAccountStatus);
            if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
            {
                //
                // If the account SID has been resolved to a name,
                // display the name.
                //
                pUser->GetName(NULL,       0,
                               m_strDispText.GetBuffer(MAX_USERNAME), MAX_USERNAME,
                               NULL,       0);
                m_strDispText.ReleaseBuffer();
            }
            else
            {
                //
                // If the account SID has NOT been resolved to a name, display
                // the SID as a string.
                //
                BYTE Sid[MAX_SID_LEN];
                DWORD cchSidStr = MAX_PATH;
                if (SUCCEEDED(pUser->GetSid(Sid, ARRAYSIZE(Sid))))
                {
                    SidToString(Sid, m_strDispText.GetBuffer(cchSidStr), &cchSidStr);
                    m_strDispText.ReleaseBuffer();
                }
            }
            break;
        }

        case DetailsView::idCol_AmtUsed:
            pUser->GetQuotaUsed(&llValue);
            XBytes::FormatByteCountForDisplay(llValue,
                                              m_strDispText.GetBuffer(40), 40);
            break;

        case DetailsView::idCol_Limit:
            pUser->GetQuotaLimit(&llValue);

            if (NOLIMIT == llValue)
                m_strDispText = m_strNoLimit;
            else
                XBytes::FormatByteCountForDisplay(llValue,
                                                  m_strDispText.GetBuffer(40), 40);
            break;

        case DetailsView::idCol_Threshold:
            pUser->GetQuotaThreshold(&llValue);

            if (NOLIMIT == llValue)
                m_strDispText = m_strNoLimit;
            else
                XBytes::FormatByteCountForDisplay(llValue,
                                      m_strDispText.GetBuffer(40), 40);
            break;

        case DetailsView::idCol_PctUsed:
        {
            DWORD dwPct = 0;
            hResult = CalcPctQuotaUsed(pUser, &dwPct);

            if (SUCCEEDED(hResult))
                m_strDispText.Format(TEXT("%1!d!"), dwPct);
            else
                m_strDispText = m_strNotApplicable; // Not a number.

            break;
        }

        default:
            break;
    }
    pDispInfo->item.pszText = (LPTSTR)m_strDispText;  // Used by all text callbacks.
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_GetDispInfo_Image

    Description: Handles LVN_GETDISPINFO - LVIF_IMAGE for the listview control.

    Arguments:
        pDispInfo - Address of LV_DISPINFO structure associated with the
            notification.

        pUser - Address of user object for listview item.


    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    09/12/96    Added CheckMark icon.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_GetDispInfo_Image(
    LV_DISPINFO *pDispInfo,
    PDISKQUOTA_USER pUser
    )
{
    switch(GetUserQuotaState(pUser))
    {
        case iUSERSTATE_OK:
            pDispInfo->item.iImage = iIMAGELIST_ICON_OK;
            break;
        case iUSERSTATE_WARNING:
            pDispInfo->item.iImage = iIMAGELIST_ICON_WARNING;
            break;
        default:
            DBGASSERT((0));
            //
            // Fall through.
            //
        case iUSERSTATE_OVERLIMIT:
            pDispInfo->item.iImage = iIMAGELIST_ICON_LIMIT;
            break;
    }
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetUserQuotaState

    Description: Determines which of 3 states the user's quota values place
        the user in.  This is mainly used to determine what icon to display
        in the "Status" column.  It is also used to determine what text
        to display in the "Status" column in a drag-drop report.

    Arguments:
        pUser - Address of user object for listview item.


    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
DetailsView::GetUserQuotaState(
    PDISKQUOTA_USER pUser
    )
{
    LONGLONG llUsed;
    LONGLONG llLimit;
    INT iState = iUSERSTATE_OK;

    DBGASSERT((NULL != pUser));

    pUser->GetQuotaUsed(&llUsed);
    pUser->GetQuotaLimit(&llLimit);

    if (NOLIMIT != llLimit && llUsed > llLimit)
    {
        iState = iUSERSTATE_OVERLIMIT;
    }
    else
    {
        LONGLONG llThreshold;
        pUser->GetQuotaThreshold(&llThreshold);

        if (NOLIMIT != llThreshold && llUsed > llThreshold)
            iState = iUSERSTATE_WARNING;
    }

    return iState;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_ColumnClick

    Description: Handles LVN_COLUMNCLICK list view notifications.
        This is received when the user selects a column's label.

    Arguments:
        pNm - Address of listview notification message structure.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_ColumnClick(
    NM_LISTVIEW *pNm
    )
{
    INT idCol = m_ColMap.SubItemToId(pNm->iSubItem);

    if (idCol != m_iLastColSorted)
    {
        //
        // New column selected.  Reset to ascending sort order.
        //
        m_fSortDirection = 0;
    }
    else
    {
        //
        // Column selected more than once.  Toggle sort order.
        //
        m_fSortDirection ^= 1;
    }

    SortObjects(idCol, m_fSortDirection);

    //
    // Remember what column was selected.
    //
    m_iLastColSorted = idCol;

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_ItemChanged

    Description: Handles LVN_ITEMCHANGED listview notifications.
        Updates the selected-item-count in the status bar.

    Arguments:
        pNm - Address of listview notification structure.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    05/18/97    Added promotion of user object in name resolution    BrianAu
                queue.
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_ItemChanged(
    NM_LISTVIEW *pNm
    )
{
    if (LVIS_FOCUSED & pNm->uNewState)
    {
        if (!m_bMenuActive)
        {
            //
            // Only update the item count if a menu item is not active.
            // This method is called WHENEVER an item is updated.  This includes
            // asynchronous notifications following name resolution.  Without
            // this check, a menu's descriptive text can be overwritten while
            // the user is walking through menu items.
            //
            ShowItemCountInStatusBar();
        }

        PDISKQUOTA_USER pUser = NULL;
        m_UserList.Lock();
        m_UserList.Retrieve((LPVOID *)&pUser, pNm->iItem);

        if (NULL != pUser &&
            NULL != m_pQuotaControl)
        {
            DWORD dwAccountStatus = 0;
            pUser->GetAccountStatus(&dwAccountStatus);

            if (DISKQUOTA_USER_ACCOUNT_UNRESOLVED == dwAccountStatus)
            {
                //
                // If the user object hasn't been resolved yet, promote it to the
                // head of the quota controller's SID-Name resolver queue.
                // This will speed up the name resolution for this user without
                // performing a blocking operation.
                //
                m_pQuotaControl->GiveUserNameResolutionPriority(pUser);
            }
        }
        m_UserList.ReleaseLock();
    }
    else if ((0 == pNm->uNewState) || (LVIS_SELECTED & pNm->uNewState))
    {
        ShowItemCountInStatusBar();
    }

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::SetFocus

    Description: Called whenever the main window receives focus.  Immediately
        transfers focus to the listview control.  The listview in turn
        ensures that one or more items are highlighted.

    Arguments: Std WndProc arguments.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnSetFocus(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (NULL != m_hwndListView)
        SetFocus(m_hwndListView);
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnSize

    Description: Handles WM_SIZE message.

    Arguments: Standard WndProc arguments.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    05/20/97    Added positioning of "Find User" combo in toolbar.   BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnSize(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    RECT rcMain;
    RECT rcListView;

    GetClientRect(hWnd, &rcMain);  // How big's the main window?

    rcListView = rcMain;

    if (m_lvsi.fToolBar)
    {
        //
        // Adjust toolbar if it's visible.
        //
        RECT rcToolBar;
        INT cyToolBar = 0;

        SendMessage(m_hwndToolBar, message, wParam, lParam);
        GetClientRect(m_hwndToolBar, &rcToolBar);

        cyToolBar = rcToolBar.bottom - rcToolBar.top;

        rcListView.top += (cyToolBar + 1);

        //
        // Position the "Find User" combo box to the immediate right of the
        // "Find" toolbar button.
        // This code assumes that the "Find" toolbar button is the right-most
        // button in the toolbar.
        //
        INT cButtons = (INT)SendMessage(m_hwndToolBar, TB_BUTTONCOUNT, 0, 0);
        if (0 < cButtons)
        {
            RECT rcButton;
            SendMessage(m_hwndToolBar, TB_GETITEMRECT, cButtons - 1, (LPARAM)&rcButton);

            RECT rcCombo;
            GetWindowRect(m_hwndToolbarCombo, &rcCombo);

            SetWindowPos(m_hwndToolbarCombo,
                         NULL,
                         rcButton.right + 1,
                         rcButton.top + 1,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);

        }
    }


    if (m_lvsi.fStatusBar)
    {
        //
        // Adjust status bar if it's visible.
        //
        RECT rcStatusBar;
        INT cyStatusBar = 0;

        SendMessage(m_hwndStatusBar, message, wParam, lParam);
        GetClientRect(m_hwndStatusBar, &rcStatusBar);

        cyStatusBar = rcStatusBar.bottom - rcStatusBar.top;

        rcListView.bottom -= cyStatusBar;
    }

    //
    // Adjust the listview.  Accounts for toolbar and status bar.
    //
    MoveWindow(m_hwndListView,
               0,
               rcListView.top,
               rcListView.right - rcListView.left,
               rcListView.bottom - rcListView.top,
               TRUE);

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::SelectAllItems

    Description: Highlights all items in the listview for selection.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::SelectAllItems(
    VOID
    )
{
    INT cItems    = ListView_GetItemCount(m_hwndListView);
    DWORD dwState = 0;

    CAutoWaitCursor waitcursor;
    SetFocus(m_hwndListView);
    //
    // This isn't documented but it's the way the shell does it for DefView.
    //
    ListView_SetItemState(m_hwndListView, -1, LVIS_SELECTED, LVIS_SELECTED);
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::InvertSelection

    Description: Selects all items that are not selected and unselects all
        items that are.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::InvertSelectedItems(
    VOID
    )
{
    INT iItem = -1;

    CAutoWaitCursor waitcursor;
    SetFocus(m_hwndListView);
    while ((iItem = ListView_GetNextItem(m_hwndListView, iItem, 0)) != -1)
    {
        DWORD dwState;

        dwState = ListView_GetItemState(m_hwndListView, iItem, LVIS_SELECTED);
        dwState ^= LVNI_SELECTED;
        ListView_SetItemState(m_hwndListView, iItem, dwState, LVIS_SELECTED);
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnHelpAbout

    Description: Handler for "About Windows NT" menu option.

    Arguments:
        hWnd - Handle of parent window for "about" dialog.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnHelpAbout(
    HWND hWnd
    )
{
    TCHAR szOpSysName[MAX_PATH];

    LoadString(g_hInstDll, IDS_WINDOWS, szOpSysName, ARRAYSIZE(szOpSysName));
    ShellAbout(hWnd, szOpSysName, NULL, NULL);
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnHelpTopics

    Description: Handler for "Help Topics" menu option.

    Arguments:
        hWnd - Handle of parent window for the help UI.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnHelpTopics(
    HWND hWnd
    )
{
    const char szHtmlHelpFileA[]  = "DSKQUOUI.CHM > windefault";
    const char szHtmlHelpTopicA[] = "sag_DQtopnode.htm";

    HtmlHelpA(hWnd,
             szHtmlHelpFileA,
             HH_DISPLAY_TOPIC,
             (DWORD_PTR)szHtmlHelpTopicA);
    return 0;
}



bool
DetailsView::SingleSelectionIsAdmin(
    void
    )
{
    bool bResult = false;

    if (1 == ListView_GetSelectedCount(m_hwndListView))
    {
        INT iItem = ListView_GetNextItem(m_hwndListView, -1, LVNI_SELECTED);
        if (-1 != iItem)
        {
            PDISKQUOTA_USER pUser = NULL;
            if (m_UserList.Retrieve((LPVOID *)&pUser, iItem) && NULL != pUser)
            {
                bResult = !!UserIsAdministrator(pUser);
            }
        }
    }
    return bResult;
}


//
// NTRAID#NTBUG9-157269-2000/08/08-BrianAu  Temporary workaround.
//
// This workaround was added for bug 157269.  However,
// the root cause is bug 24904.  Once 24904 is fixed, we should
// be able to remove this code.  Bug 157269 provides a detailed
// explanation of the issue.
//
// Since it's a temporary function and doesn't use any members
// of the DetailsView class I chose to not make it a member
// of DetailsView.  The logic used is taken from 
// DiskQuotaControl::AddUserSid.
//
// The Retry and sleep code is a total hack.  
//
bool 
UserWasReallyDeleted(
    IDiskQuotaControl *pQuotaControl, 
    IDiskQuotaUser *pIUser
    )
{
    bool bDeleted = true;
    BYTE rgbSid[MAX_SID_LEN];
    HRESULT hr = pIUser->GetSid(rgbSid, sizeof(rgbSid));
    if (SUCCEEDED(hr))
    {
        IDiskQuotaUser *pIUserTemp;
        hr = pQuotaControl->FindUserSid(rgbSid,
                                        DISKQUOTA_USERNAME_RESOLVE_NONE,
                                        &pIUserTemp);
        if (SUCCEEDED(hr))
        {
            const int MAX_RETRY_COUNT = 1;
            const DWORD RETRY_WAIT_MS = 100;

            for (int i = 0; i <= MAX_RETRY_COUNT && bDeleted; i++)
            {
                LONGLONG llLimit;
                LONGLONG llThreshold;
                LONGLONG llUsed;

                pIUserTemp->GetQuotaLimit(&llLimit);
                pIUserTemp->GetQuotaThreshold(&llThreshold);
                pIUserTemp->GetQuotaUsed(&llUsed);

                bDeleted = ((MARK4DEL == llLimit) ||
                            ( 0 == llLimit && 
                              0 == llThreshold && 
                              0 == llUsed));

                if (bDeleted && i < MAX_RETRY_COUNT)
                {
                    Sleep(RETRY_WAIT_MS);
                    //
                    // Invalidate cached data so next request fetches from
                    // volume, not memory.
                    //
                    pIUserTemp->Invalidate();
                }
            }
            pIUserTemp->Release();
        }
    }
    return bDeleted;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdDelete

    Description: Called whenever the user presses DEL or selects the "Delete"
        option from the main menu, context menu or toolbar.
        The method attempts to delete the selected records.  Any records that
        have 1+ bytes charged to them will not be deleted.  A message box
        is displayed informing the user if any selected records have 1+ bytes.

    Arguments: None.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/11/96    Initial creation.                                    BrianAu
    03/11/98    Added code for resolving "owned" files.              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdDelete(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    //
    // Make sure they really want to do this.
    // Early return if they don't.
    // Don't ask if it's a single selection and the selected user
    // is BUILTIN/Administrators.  This user can't be deleted anyway so
    // we don't want to ask for confirmation.  The deletion attempt will
    // fail later and we'll display a "can't be deleted" msgbox.
    //
    if (!SingleSelectionIsAdmin() && IDNO == DiskQuotaMsgBox(m_hwndListView,
                                                             IDS_CONFIRM_DELETE_USER,
                                                             IDS_TITLE_DISK_QUOTA,
                                                             MB_ICONWARNING | MB_YESNO))
    {
        return 0;
    }

    //
    // Clear any previous undo actions.
    // Only allow undo for a single delete (single or multi-user) operation.
    //
    m_pUndoList->Clear();

    CAutoWndEnable autoenable(m_hwndListView);
    PDISKQUOTA_USER pUser = NULL;
    INT iItem             = -1;
    INT cItemsToDelete    = ListView_GetSelectedCount(m_hwndListView);
    ProgressDialog dlgProgress(IDD_PROGRESS,
                               IDC_PROGRESS_BAR,
                               IDC_TXT_PROGRESS_DESCRIPTION,
                               IDC_TXT_PROGRESS_FILENAME);

    if (2 < cItemsToDelete)
    {
        //
        // Create and display a progress dialog if we're deleting more than 2
        // user quota records.
        //
        if (dlgProgress.Create(g_hInstDll,
                               m_hwndMain))
        {
            autoenable.Enable(false);
            dlgProgress.ProgressBarInit(0, cItemsToDelete, 1);
            dlgProgress.SetDescription(MAKEINTRESOURCE(IDS_PROGRESS_DELETING));
            dlgProgress.Show();
        }
    }

    //
    // Set each user's threshold and limit to -2 (MARK4DEL) and remove the
    // item from the listview.
    // A limit of -2 tells the quota system (NTFS) that the record should be
    // removed from the quota file.  However, if the user still has quota
    // charged, the record will be restored.
    //
    CAutoSetRedraw autoredraw(m_hwndListView, false);
    CArray<IDiskQuotaUser *> rgpUsersWithFiles;
    LONGLONG Threshold;
    LONGLONG Limit;


    while(-1 != (iItem = ListView_GetNextItem(m_hwndListView, iItem, LVNI_SELECTED)) &&
          !dlgProgress.UserCancelled())
    {
        if (m_UserList.Retrieve((LPVOID *)&pUser, iItem))
        {
            if (UserIsAdministrator(pUser))
            {
                //
                // Deletion of the BUILTINS\Administrators quota record is not
                // allowed.
                //
                CString strText(g_hInstDll, IDS_CANT_DELETE_ADMIN_RECORD);
                DiskQuotaMsgBox(dlgProgress.m_hWnd ? dlgProgress.m_hWnd : m_hwndListView,
                                strText,
                                IDS_TITLE_DISK_QUOTA,
                                MB_ICONWARNING | MB_OK);
            }
            else
            {
                //
                // Get threshold and limit values for undo action.
                //
                pUser->GetQuotaThreshold(&Threshold);
                pUser->GetQuotaLimit(&Limit);

                //
                // Remove the user from the quota file.
                //
                hResult = m_pQuotaControl->DeleteUser(pUser);
                if (SUCCEEDED(hResult))
                {
                    if (!UserWasReallyDeleted(m_pQuotaControl, pUser))
                    {
                        //
                        // NTRAID#NTBUG9-157269-2000/08/08-BrianAu  Temporary workaround.
                        //
                        // This workaround was added for bug 157269.  However,
                        // the root cause is bug 24904.  Once 24904 is fixed, we should
                        // be able to remove this code.  Bug 157269 provides a detailed
                        // explanation of the issue.
                        //
                        pUser->SetQuotaThreshold(Threshold, TRUE);
                        pUser->SetQuotaLimit(Limit, TRUE);
                    }
                    else
                    {
                        pUser->AddRef(); // Giving ptr to UNDO list.
                        try
                        {
                            autoptr<UndoDelete> ptrUndoDelete = new UndoDelete(pUser, Threshold, Limit);
                            m_pUndoList->Add(ptrUndoDelete);
                            ptrUndoDelete.disown();
                        }
                        catch(CAllocException& e)
                        {
                            pUser->Release(); // Release from Undo list.
                            EnableWindow(m_hwndMain, TRUE);
                            throw;
                        }

                        ListView_DeleteItem(m_hwndListView, iItem);
                        //
                        // Deletion is successful.  Now actually remove the user from
                        // the user list.
                        //
                        m_UserList.Remove((LPVOID *)&pUser, iItem);

                        pUser->Release();  // Release from listview.
                        //
                        // Decrement the search index by 1 since what was index + 1
                        // is now index.  ListView_GetNextItem ignores the item at "index".
                        //
                        iItem--;
                    }
                    dlgProgress.ProgressBarAdvance();
                }
                else if (ERROR_FILE_EXISTS == HRESULT_CODE(hResult))
                {
                    //
                    // One more we couldn't delete.
                    //
                    rgpUsersWithFiles.Append(pUser);
                }
            }
        }
    }

    if (0 < rgpUsersWithFiles.Count())
    {
        //
        // Display a dialog listing users selected for deletion and
        // and the files owned by those users on this volume.  From the dialog,
        // the admin can Delete, Move or Take Ownership of the files.
        //
        dlgProgress.SetDescription(MAKEINTRESOURCE(IDS_PROGRESS_SEARCHINGFORFILES));
        CFileOwnerDialog dlg(g_hInstDll,
                             dlgProgress.m_hWnd ? dlgProgress.m_hWnd : m_hwndListView,
                             m_idVolume.FSPath(),
                             rgpUsersWithFiles);
        dlg.Run();
        dlgProgress.SetDescription(MAKEINTRESOURCE(IDS_PROGRESS_DELETING));

        int cUsers = rgpUsersWithFiles.Count();
        int cCannotDelete = 0;
        for (int i = 0; i < cUsers; i++)
        {
            pUser = rgpUsersWithFiles[i];
            //
            // Get threshold and limit values for undo action.
            //
            pUser->GetQuotaThreshold(&Threshold);
            pUser->GetQuotaLimit(&Limit);

            //
            // Try to remove the user from the quota file.
            //
            hResult = m_pQuotaControl->DeleteUser(pUser);
            if (SUCCEEDED(hResult))
            {
                if (!UserWasReallyDeleted(m_pQuotaControl, pUser))
                {
                    //
                    // NTRAID#NTBUG9-157269-2000/08/08-BrianAu  Temporary workaround.
                    //
                    // This workaround was added for bug 157269.  However,
                    // the root cause is bug 24904.  Once 24904 is fixed, we should
                    // be able to remove this code.  Bug 157269 provides a detailed
                    // explanation of the issue.
                    //
                    pUser->SetQuotaThreshold(Threshold, TRUE);
                    pUser->SetQuotaLimit(Limit, TRUE);
                }
                else
                {
                    pUser->AddRef(); // Giving ptr to UNDO list.
                    try
                    {
                        autoptr<UndoDelete> ptrUndoDelete = new UndoDelete(pUser, Threshold, Limit); 
                        m_pUndoList->Add(ptrUndoDelete);
                        ptrUndoDelete.disown();
                    }
                    catch(CAllocException& e)
                    {
                        pUser->Release(); // Release from Undo list.
                        throw;
                    }

                    iItem = FindUserByObjPtr(pUser);
                    if (-1 != iItem)
                    {
                        ListView_DeleteItem(m_hwndListView, iItem);
                        //
                        // Deletion is successful.  Now actually remove the user from
                        // the user list.
                        //
                        m_UserList.Remove((LPVOID *)&pUser, iItem);
                        pUser->Release();  // Release from listview.
                    }
                }
                dlgProgress.ProgressBarAdvance();
            }
            else if (ERROR_FILE_EXISTS == HRESULT_CODE(hResult))
            {
                cCannotDelete++;
            }
        }
        if (0 < cCannotDelete)
        {
            //
            // One or more records could not be deleted because they have
            // disk space charged to them.
            //
            CString strText;

            if (1 == cCannotDelete)
                strText.Format(g_hInstDll, IDS_CANNOT_DELETE_USER);
            else
                strText.Format(g_hInstDll, IDS_CANNOT_DELETE_USERS, cCannotDelete);

            DiskQuotaMsgBox(m_hwndListView,
                            strText,
                            IDS_TITLE_DISK_QUOTA,
                            MB_ICONINFORMATION | MB_OK);
        }
    }

    ShowItemCountInStatusBar();

    if (FAILED(hResult) && ERROR_FILE_EXISTS != HRESULT_CODE(hResult))
    {
        //
        // Something bad happened.
        // FEATURE: Do we need to discriminate between a general failure and
        //         a quota file write error?
        //
        DiskQuotaMsgBox(m_hwndListView,
                        IDS_ERROR_DELETE_USER,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return 0;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdUndo

    Description: Called whenever the user presses Ctrl + Z or selects
        the "Undo" option from the main menu, context menu or toolbar.
        The method invokes the current undo list to "undo" its actions.

    Arguments: None.

    Returns: Always 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/01/96    Initial creation.                                    BrianAu
    02/26/97    Added call to update status bar.                     BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdUndo(
    VOID
    )
{
    if (NULL != m_pUndoList)
    {
        CAutoWaitCursor waitcursor;
        m_pUndoList->Undo();
        ShowItemCountInStatusBar();
    }
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdFind

    Description: Called whenever the user presses Ctrl + F or selects
        the "Find" option from the main menu, context menu or toolbar.
        The method invokes the "Find User" dialog.

    Arguments: None.

    Returns: Always 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdFind(
    VOID
    )
{
    if (NULL != m_pUserFinder)
    {
        m_pUserFinder->InvokeFindDialog(m_hwndListView);
    }
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdProperties

    Description: Displays a properties dialog for one or more selected objects.
        Invoked when the user selects a "Properties" menu option, dbl clicks
        a selection or presses Return for a selection.

    Arguments: None.

    Returns: Always returns 0.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    09/10/96    Added passing of LVSelection to prop sheet ctor.     BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdProperties(
    VOID
    )
{
    LVSelection lvs(m_hwndListView);

    INT iItem = -1;

    //
    // Fill in arrays of user pointers and item indices.
    //
    while(-1 != (iItem = ListView_GetNextItem(m_hwndListView, iItem, LVNI_SELECTED)))
    {
        LPVOID pvUser = 0;

        if (m_UserList.Retrieve(&pvUser, iItem))
        {
            //
            // Add user object pointer and item index to the selection object.
            // We'll use this container to communicate the selected items to the
            // property sheet object.
            // This can throw OutOfMemory.
            //
            lvs.Add((PDISKQUOTA_USER)pvUser, iItem);
        }
    }

    if (0 < lvs.Count())
    {
        //
        // Create and run the property sheet.  It's modal.
        // There's a condition where the user can select in the listview and
        // nothing is actually selected (i.e. select below the last item).
        // Therefore, we need the (0 < count) check.
        //
        m_pQuotaControl->AddRef();
        UserPropSheet ups(m_pQuotaControl,
                          m_idVolume,
                          m_hwndListView,
                          lvs,
                          *m_pUndoList);
        ups.Run();
    }

    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdNew

    Description: Displays a properties dialog for adding a new user to the
        quota information file.
        Invoked when the user selects the "New" menu option.

    Arguments: None.

    Returns: Always returns 0.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/27/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdNew(
    VOID
    )
{
    //
    // Create and run the AddUser dialog.
    // Note that it first launches the DS Object Picker dialog.
    //
    m_pQuotaControl->AddRef();
    AddUserDialog dlg(m_pQuotaControl,
                      m_idVolume,
                      g_hInstDll,
                      m_hwndListView,
                      m_hwndListView,
                      *m_pUndoList);
    dlg.Run();

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateVolumeDisplayName [static]

    Description: Obtains the display name used by the shell for a given
        volume.

    Arguments:
        pszDrive - Address of string containing drive name (i.e. "C:\").

        pstrDisplayName - Address of CString object to receive the
            display name.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/30/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateVolumeDisplayName(
    const CVolumeID& idVolume, // [in] - "C:\" or "\\?\Volume{ <guid }\"
    CString *pstrDisplayName   // [out] - "My Disk (C:)"
    )
{
    HRESULT hr = E_FAIL;

    if (idVolume.IsMountedVolume())
    {
        //
        // If it's a mounted volume thingy "\\?\Volume{ <guid> }\", the shell won't
        // understand it.  Just use the default display name provided by the
        // CVolumeID object.
        //
        *pstrDisplayName = idVolume.ForDisplay();
    }
    else
    {
        //
        // It's a normal volume.  Get the display name the shell uses.
        //
        com_autoptr<IShellFolder> ptrDesktop;
        //
        // Bind to the desktop folder.
        //
        hr = SHGetDesktopFolder(ptrDesktop.getaddr());
        if (SUCCEEDED(hr))
        {
            sh_autoptr<ITEMIDLIST> ptrIdlDrives;
            hr = SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, ptrIdlDrives.getaddr());
            if (SUCCEEDED(hr))
            {
                //
                // Bind to the "Drives" folder.
                //
                com_autoptr<IShellFolder> ptrDrives;
                hr = ptrDesktop->BindToObject(ptrIdlDrives, NULL, IID_IShellFolder, (LPVOID *)ptrDrives.getaddr());
                if (SUCCEEDED(hr))
                {
                    com_autoptr<IEnumIDList> ptrEnum;

                    //
                    // Enumerate all of the non-folder objects in the drives folder.
                    //
                    hr = ptrDrives->EnumObjects(NULL, SHCONTF_NONFOLDERS, ptrEnum.getaddr());
                    if (SUCCEEDED(hr))
                    {
                        sh_autoptr<ITEMIDLIST> ptrIdlItem;
                        ULONG ulFetched = 0;
                        LPCTSTR pszDrive = idVolume.ForParsing();
                        //
                        // For each item in the drives folder...
                        //
                        while(S_OK == ptrEnum->Next(1, ptrIdlItem.getaddr(), &ulFetched))
                        {
                            STRRET strretName;
                            //
                            // Get the non-display name form; i.e. "G:\"
                            //
                            hr = ptrDrives->GetDisplayNameOf(ptrIdlItem, SHGDN_FORPARSING, &strretName);
                            if (SUCCEEDED(hr))
                            {
                                TCHAR szName[MAX_PATH];
                                StrRetToBuf(&strretName, ptrIdlItem, szName, ARRAYSIZE(szName));
                                if (TEXT(':') == szName[1] &&
                                    *pszDrive == szName[0])
                                {
                                    //
                                    // Get the display name form; i.e. "My Disk (G:)"
                                    //
                                    hr = ptrDrives->GetDisplayNameOf(ptrIdlItem, SHGDN_NORMAL, &strretName);
                                    if (SUCCEEDED(hr))
                                    {
                                        StrRetToBuf(&strretName, ptrIdlItem, pstrDisplayName->GetBuffer(MAX_PATH), MAX_PATH);
                                        pstrDisplayName->ReleaseBuffer();
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdImport

    Description: Called when the user selects the "Import" option on the
        "Quota" menu.  Presents the "Open File" common dialog to get the
        name for the file containing the import information.  Then passes
        the path off to an Importer object to do the actual import.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdImport(
    VOID
    )
{
    HRESULT hResult            = NO_ERROR;
    TCHAR szFileName[MAX_PATH] = { TEXT('\0') };
    TCHAR szTitle[80] = { TEXT('\0') };
    LoadString(g_hInstDll, IDS_DLGTITLE_IMPORT, szTitle, ARRAYSIZE(szTitle));

    OPENFILENAME ofn;
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner   = m_hwndMain;
    ofn.hInstance   = g_hInstDll;
    ofn.lpstrFile   = szFileName;
    ofn.lpstrTitle  = szTitle;
    ofn.nMaxFile    = ARRAYSIZE(szFileName);
    ofn.Flags       = OFN_HIDEREADONLY | OFN_NOCHANGEDIR |
                      OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

    //
    // Get name of import file from user and import the files.
    //
    if (GetOpenFileName(&ofn))
    {
        Importer importer(*this);
        hResult = importer.Import(ofn.lpstrFile);
    }

    return SUCCEEDED(hResult);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdExport

    Description: Called when the user selects the "Export" option on the
        "Quota" menu or listview context menu.  Presents the "Save File"
        common dialog to get the name for the output file. It then creates
        the doc file, the stream within the doc file and then calls the
        DetailsView's IDataObject implementation to render the data on the
        stream.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdExport(
    VOID
    )
{
    HRESULT hResult           = NO_ERROR;
    IDataObject *pIDataObject = NULL;

    try
    {
        hResult = QueryInterface(IID_IDataObject, (LPVOID *)&pIDataObject);
        if (SUCCEEDED(hResult))
        {
            FORMATETC fmt;
            DataObject::SetFormatEtc(fmt,
                                     DataObject::m_CF_NtDiskQuotaExport,
                                     TYMED_ISTREAM);

            hResult = pIDataObject->QueryGetData(&fmt);
            if (SUCCEEDED(hResult))
            {
                TCHAR szFileName[MAX_PATH] = { TEXT('\0') };
                TCHAR szTitle[80] = { TEXT('\0') };

                LoadString(g_hInstDll, IDS_DLGTITLE_EXPORT, szTitle, ARRAYSIZE(szTitle));

                OPENFILENAME ofn;
                ZeroMemory(&ofn, sizeof(ofn));
                ofn.lStructSize = sizeof(ofn);
                ofn.hwndOwner   = m_hwndMain;
                ofn.hInstance   = g_hInstDll;
                ofn.lpstrFile   = szFileName;
                ofn.lpstrTitle  = szTitle;
                ofn.nMaxFile    = ARRAYSIZE(szFileName);
                ofn.Flags       = OFN_HIDEREADONLY | OFN_NOCHANGEDIR |
                                  OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
                //
                // Get output file name from user.
                //
                if (GetSaveFileName(&ofn))
                {
                    DWORD grfMode = STGM_DIRECT | STGM_READWRITE |
                                    STGM_CREATE | STGM_SHARE_EXCLUSIVE;
                    IStorage *pStg;

                    //
                    // Create the output doc file.
                    //
                    hResult = StgCreateDocfile(ofn.lpstrFile,
                                               grfMode,
                                               0,
                                               &pStg);
                    if (SUCCEEDED(hResult))
                    {
                        //
                        // Create the stream in the doc file.
                        //
                        IStream *pStm;
                        hResult = pStg->CreateStream(DataObject::SZ_EXPORT_STREAM_NAME,
                                                     grfMode,
                                                     0, 0,
                                                     &pStm);
                        if (SUCCEEDED(hResult))
                        {
                            CStgMedium medium;

                            //
                            // Render the quota information onto the file stream.
                            //
                            hResult = pIDataObject->GetData(&fmt, &medium);
                            if (SUCCEEDED(hResult))
                            {
                                const LARGE_INTEGER ofsBegin = {0, 0};
                                ULARGE_INTEGER ofsOriginal   = {0, 0};
                                hResult = medium.pstm->Seek(ofsBegin, STREAM_SEEK_CUR, &ofsOriginal);
                                if (SUCCEEDED(hResult))
                                {
                                    hResult = medium.pstm->Seek(ofsBegin, STREAM_SEEK_SET, NULL);
                                    if (SUCCEEDED(hResult))
                                    {                                
                                        ULARGE_INTEGER cb = {0xFFFFFFFF, 0xFFFFFFFF};
                                        medium.pstm->CopyTo(pStm, cb, NULL, NULL);

                                        const LARGE_INTEGER ofs = { ofsOriginal.LowPart, (LONG)ofsOriginal.HighPart };
                                        medium.pstm->Seek(ofs, STREAM_SEEK_SET, NULL);
                                    }
                                }
                            }
                            pStm->Release();
                        }
                        pStg->Release();
                    }
                    if (FAILED(hResult))
                    {
                        UINT iMsg = IDS_EXPORT_STREAM_FAILED;

                        switch(hResult)
                        {
                            case STG_E_ACCESSDENIED:
                                iMsg = IDS_EXPORT_STREAM_NOACCESS;
                                break;

                            case E_OUTOFMEMORY:
                            case STG_E_INSUFFICIENTMEMORY:
                                iMsg = IDS_EXPORT_STREAM_OUTOFMEMORY;
                                break;

                            case STG_E_INVALIDNAME:
                                iMsg = IDS_EXPORT_STREAM_INVALIDNAME;
                                break;

                            case STG_E_TOOMANYOPENFILES:
                                iMsg = IDS_EXPORT_STREAM_TOOMANYFILES;
                                break;

                            default:
                                break;
                        }
                        DiskQuotaMsgBox(m_hwndMain,
                                        iMsg,
                                        IDS_TITLE_DISK_QUOTA,
                                        MB_ICONERROR | MB_OK);

                    }
                }
            }
            else
            {
                DBGERROR((TEXT("Export: Error 0x%08X returned from QueryGetData."), hResult));
            }
            pIDataObject->Release();
            pIDataObject = NULL;
        }
        else
        {
            DBGERROR((TEXT("Export: Error 0x%08X getting IDataObject."), hResult));
        }
    }
    catch(CAllocException& e)
    {
        if (NULL != pIDataObject)
            pIDataObject->Release();
        throw;
    }
    return SUCCEEDED(hResult);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdViewStatusBar

    Description:  Toggles the visibility of the status bar.  Invoked when the
        user selects the "Status Bar" menu option.

    Arguments: None.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdViewStatusBar(
    VOID
    )
{
    RECT rc;

    m_lvsi.fStatusBar ^= TRUE;
    ShowWindow(m_hwndStatusBar, m_lvsi.fStatusBar ? SW_SHOW : SW_HIDE);

    //
    // Adjust the main window.
    //
    GetWindowRect(m_hwndMain, &rc);
    OnSize(m_hwndMain, WM_SIZE, SIZE_RESTORED, MAKELONG(rc.right-rc.left,rc.bottom-rc.top));

    //
    // Check the menu item to indicate the current status bar state.
    //
    CheckMenuItem(GetMenu(m_hwndMain),
                  IDM_VIEW_STATUSBAR,
                  MF_BYCOMMAND | (m_lvsi.fStatusBar ? MF_CHECKED : MF_UNCHECKED));
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdViewToolBar

    Description:  Toggles the visibility of the tool bar.  Invoked when the
        user selects the "Tool Bar" menu option.

    Arguments: None.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdViewToolBar(
    VOID
    )
{
    RECT rc;

    m_lvsi.fToolBar ^= TRUE;
    ShowWindow(m_hwndToolBar, m_lvsi.fToolBar ? SW_SHOW : SW_HIDE);

    //
    // Adjust the main window.
    //
    GetWindowRect(m_hwndMain, &rc);
    OnSize(m_hwndMain, WM_SIZE, SIZE_RESTORED, MAKELONG(rc.right-rc.left,rc.bottom-rc.top));

    //
    // Check the menu item to indicate the current tool bar state.
    //
    CheckMenuItem(GetMenu(m_hwndMain),
                  IDM_VIEW_TOOLBAR,
                  MF_BYCOMMAND | (m_lvsi.fToolBar ? MF_CHECKED : MF_UNCHECKED));
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdViewShowFolder

    Description:  Toggles the visibility of the Domain Name column.  Invoked
        when the user selects the "Show Domain" menu option.

    Arguments: None.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdViewShowFolder(
    VOID
    )
{
    m_lvsi.fShowFolder ^= TRUE;

    if (m_lvsi.fShowFolder)
    {
        //
        // Insert the folder column and DEACTIVATE listview tooltip.
        // Always add at index 1 then shift it to position 0.
        // User can drag it elsewhere if they like.
        // Because of the listview's icon painting behavior, we only let the
        // "status" column be index 0.
        //
        AddColumn(1, g_rgColumns[DetailsView::idCol_Folder]);
        INT cCols = Header_GetItemCount(m_hwndHeader);
        INT rgColIndicies[DetailsView::idCol_Last];
        INT iTemp = 0;

        DBGASSERT((DetailsView::idCol_Last >= cCols));
        Header_GetOrderArray(m_hwndHeader, cCols, rgColIndicies);
        //
        // Swap the column we just added with column 0.
        //
        iTemp = rgColIndicies[0];
        rgColIndicies[0] = rgColIndicies[1];
        rgColIndicies[1] = iTemp;
        Header_SetOrderArray(m_hwndHeader, cCols, rgColIndicies);

        ActivateListViewToolTip(FALSE);
    }
    else
    {
        //
        // Remove the folder column and ACTIVATE listview tooltip.
        // With the column hidden, users can view a user's folder by hovering
        // over the user's name.
        //
        ActivateListViewToolTip(TRUE);
        RemoveColumn(DetailsView::idCol_Folder);
    }

    //
    // Check/Uncheck the "Show Folder" menu item.
    //
    CheckMenuItem(GetMenu(m_hwndMain),
                  IDM_VIEW_SHOWFOLDER,
                  MF_BYCOMMAND | (m_lvsi.fShowFolder ? MF_CHECKED : MF_UNCHECKED));

    //
    // If the folder column is hidden, the "Arrange by Folder" menu option
    // is disabled.
    //
    EnableMenuItem_ArrangeByFolder(m_lvsi.fShowFolder);

    //
    // I haven't found a way to do this without unloading and reloading the
    // objects following the new column configuration.
    //
    Refresh();

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::EnableMenuItem_ArrangeByFolder

    Description:  Sets the sensitivity of the "by Folder" menu item
        in the "Arrange Items" submenu.

    Arguments:
        bEnable - TRUE = Enable menu item, FALSE = Disable and gray item.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::EnableMenuItem_ArrangeByFolder(
    BOOL bEnable
    )
{
    HMENU hMainMenu        = GetMenu(m_hwndMain);
    HMENU hViewMenu        = GetSubMenu(hMainMenu, iMENUITEM_VIEW);
    HMENU hViewArrangeMenu = GetSubMenu(hViewMenu, iMENUITEM_VIEW_ARRANGE);

    //
    // If these assert, it probably means somebody's changed the
    // menus so that the iMENUITEM_XXXXX constants are no longer correct.
    //
    DBGASSERT((NULL != hViewMenu));
    DBGASSERT((NULL != hViewArrangeMenu));

    EnableMenuItem(hViewArrangeMenu,
                   IDM_VIEW_ARRANGE_BYFOLDER,
                   MF_BYCOMMAND | (bEnable ? MF_ENABLED : MF_GRAYED));
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::EnableMenuItem_Undo

    Description:  Sets the sensitivity of the "Undo" menu item
        in the "Edit" submenu.

    Arguments:
        bEnable - TRUE = Enable menu item, FALSE = Disable and gray item.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
    10/22/96    Replaced Assert() with nested if's.                  BrianAu
                Tester hit assert via WM_COMMAND when closing
                details view.
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::EnableMenuItem_Undo(
    BOOL bEnable
    )
{
    HMENU hMainMenu = GetMenu(m_hwndMain);

    if (NULL != hMainMenu)
    {
        HMENU hEditMenu  = GetSubMenu(hMainMenu, iMENUITEM_EDIT);
        if (NULL != hEditMenu)
        {
            EnableMenuItem(hEditMenu,
                           IDM_EDIT_UNDO,
                           MF_BYCOMMAND | (bEnable ? MF_ENABLED : MF_GRAYED));

            SendMessage(m_hwndToolBar, TB_ENABLEBUTTON, IDM_EDIT_UNDO, MAKELONG(bEnable, 0));
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::ShowItemCountInStatusBar

    Description: Displays the current count of selected items in the status bar.
        This is what is displayed in the status bar when a menu item is not
        currently selected.

    Arguments: None.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    12/16/96    Appended "incorrect data" warning to status bar      BrianAu
                text when quotas are disabled on system.
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::ShowItemCountInStatusBar(
    VOID
    )
{
    DWORD cTotalItems    = m_UserList.Count();
    DWORD cSelectedItems = ListView_GetSelectedCount(m_hwndListView);

    CString strText(g_hInstDll, IDS_STATUSBAR_ITEMCOUNT, cTotalItems, cSelectedItems);
    SendMessage(m_hwndStatusBar, SB_SETTEXT, 0, (LPARAM)((LPCTSTR)strText));

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::ShowMenuTextInStatusBar

    Description: Displays the description of the currently-selected menu
        item in the status bar.

    Arguments: None.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::ShowMenuTextInStatusBar(
    DWORD idMenuOption
    )
{
    TCHAR szText[MAX_PATH];

    LoadString(g_hInstDll, idMenuOption, szText, ARRAYSIZE(szText));
    SendMessage(m_hwndStatusBar, SB_SETTEXT, 0, (LPARAM)szText);
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Refresh

    Description: Refreshes the view by re-loading the objects.

    Arguments: bInvalidateCache - true == invalidate all entries in the
                    SID-name cache.  Default is false.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/21/97    Ownerdata listview.                                  BrianAu
    10/10/98    Added bInvalidateCache argument.                     BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::Refresh(
    bool bInvalidateCache    // optional.  default is false.
    )
{
    CAutoWaitCursor waitcursor;
    if (bInvalidateCache)
        m_pQuotaControl->InvalidateSidNameCache();

    InvalidateRect(m_hwndListView, NULL, TRUE);

    CAutoSetRedraw autoredraw(m_hwndListView, false);
    ReleaseObjects();
    autoredraw.Set(true);

    LoadObjects();
    ListView_SetItemCountEx(m_hwndListView,
                            m_UserList.Count(),
                            LVSICF_NOINVALIDATEALL | LVSICF_NOSCROLL);

    SortObjects(m_iLastColSorted, m_fSortDirection);
    ShowItemCountInStatusBar();
    FocusOnSomething();
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::FocusOnSomething

    Description: Ensures that one or more listview items have the focus
        highlighting.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::FocusOnSomething(
    VOID
    )
{
    INT iFocus;

    iFocus = ListView_GetNextItem(m_hwndListView, -1, LVNI_FOCUSED);
    if (-1 == iFocus)
        iFocus = 0;

    ListView_SetItemState(m_hwndListView, iFocus, LVIS_FOCUSED | LVIS_SELECTED,
                                                  LVIS_FOCUSED | LVIS_SELECTED)
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CalcPctQuotaUsed

    Description: Calculates the percent quota used for a given user.  The
        value returned is an integer.

    Arguments:
        pUser - Address of IDiskQuotaUser interface for user object.

        pdwPct - Address of DWORD to receive the percentage value.
            If the method returns div-by-zero, this value is set to ~0.
            This lets a caller sort erroneous values from valid values.
            The (~0 - 1) return value is used so that NOLIMIT users
            are grouped separate from 0 limit users when sorted on % used.
            Both are using 0% of their quota but it looks better if
            they are each grouped separately.

    Returns:
        NO_ERROR    - Success.
        STATUS_INTEGER_DIVIDE_BY_ZERO - The user's quota limit was 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CalcPctQuotaUsed(
    PDISKQUOTA_USER pUser,
    LPDWORD pdwPct
    )
{
    LONGLONG llUsed;
    LONGLONG llLimit;
    HRESULT hResult = E_FAIL;

    DBGASSERT((NULL != pUser));
    DBGASSERT((NULL != pdwPct));

    pUser->GetQuotaUsed(&llUsed);
    pUser->GetQuotaLimit(&llLimit);

    if (NOLIMIT == llLimit)
    {
        *pdwPct = (DWORD)~0 - 1;  // No quota limit for user.
    }
    else if (0 < llLimit)
    {
        *pdwPct = (INT)((llUsed * 100) / llLimit);
        hResult = NO_ERROR;
    }
    else
    {
        //
        // Limit is 0.  Would produce div-by-zero.
        //
        *pdwPct = (DWORD)~0;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::AddUser

    Description: Adds a user object to the listview.  Note that this is used
        for adding a single user object such as in an "add user" operation.
        The method LoadObjects is used to load the whole listview.  It's
        more efficient than calling this for each user.

    Arguments:
        pUser - Address of user's IDiskQuotaUser interface.

    Returns:
        TRUE  - User was added.
        FALSE - User wasn't added.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::AddUser(
    PDISKQUOTA_USER pUser
    )
{
    BOOL bResult    = FALSE;
    LV_ITEM item;

    item.mask       = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;
    item.state      = 0;
    item.stateMask  = 0;
    item.iSubItem   = 0;
    item.pszText    = LPSTR_TEXTCALLBACK;
    item.iImage     = I_IMAGECALLBACK;
    item.iItem      = 0;

    m_UserList.Insert((LPVOID)pUser);
    if (-1 != ListView_InsertItem(m_hwndListView, &item))
    {
        bResult = TRUE;
    }

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::FindUserByName

    Description: Locate a specified user in the listview by account name.
        Name comparison is case-insensitive.

    Arguments:
        pszUserName - Account name for user.

        ppIUser [optional] - Address of IDiskQuotaUser pointer variable to
            receive the address of the user object.

    Returns:
        -1 = account name not found.
        Otherwise, returns index of item in listview.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
DetailsView::FindUserByName(
    LPCTSTR pszLogonName,
    PDISKQUOTA_USER *ppIUser // [optional]
    )
{
    INT iItem = -1;

    m_UserList.Lock();
    try
    {
        INT cUsers = m_UserList.Count();
        PDISKQUOTA_USER pUser = NULL;
        //
        // Find the user that matches pszUserName.
        //
        for (INT i = 0; i < cUsers && -1 == iItem; i++)
        {
            if (m_UserList.Retrieve((LPVOID *)&pUser, i))
            {
                //
                // Get name from listview item.
                //
                if (NULL != pUser)
                {
                    TCHAR szLogonName[MAX_USERNAME];
                    pUser->GetName(NULL, 0,
                                   szLogonName, ARRAYSIZE(szLogonName),
                                   NULL, 0);

                    if (CSTR_EQUAL == CompareString(LOCALE_USER_DEFAULT,
                                                    NORM_IGNORECASE,
                                                    szLogonName, -1,
                                                    pszLogonName, -1))
                    {
                        iItem = i;
                        if (NULL != ppIUser)
                            *ppIUser = pUser;
                    }
                }
            }
        }
    }
    catch(CAllocException& e)
    {
        m_UserList.ReleaseLock();
        throw;
    }
    m_UserList.ReleaseLock();
    return iItem;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::FindUserBySid

    Description: Locate a specified user in the listview by SID.

    Arguments:
        pSid - Address of buffer containing key SID.

        ppIUser [optional] - Address of IDiskQuotaUser pointer variable to
            receive the address of the user object.

    Returns:
        -1 = Record not found.
        Otherwise, returns index of item in listview.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
DetailsView::FindUserBySid(
    LPBYTE pbSid,
    PDISKQUOTA_USER *ppIUser  // [optional]
    )
{
    INT iItem = -1;

    m_UserList.Lock();
    try
    {
        INT cUsers = m_UserList.Count();
        PDISKQUOTA_USER pUser = NULL;
        //
        // Find the user that matches pszUserName.
        //
        for (INT i = 0; i < cUsers && -1 == iItem; i++)
        {
            if (m_UserList.Retrieve((LPVOID *)&pUser, i))
            {
                //
                // Get SID from listview item.
                //
                if (NULL != pUser)
                {
                    BYTE Sid[MAX_SID_LEN];
                    pUser->GetSid((LPBYTE)&Sid, ARRAYSIZE(Sid));

                    if (EqualSid((LPBYTE)&Sid, pbSid))
                    {
                        iItem = i;
                        if (NULL != ppIUser)
                            *ppIUser = pUser;
                    }
                }
            }
        }
    }
    catch(CAllocException& e)
    {
        m_UserList.ReleaseLock();
        throw;
    }
    m_UserList.ReleaseLock();
    return iItem;
}

//
// Locate a user in the listview based on it's object pointer.
//
INT
DetailsView::FindUserByObjPtr(
    PDISKQUOTA_USER pUserKey
    )
{
    INT iItem = -1;

    m_UserList.Lock();
    try
    {
        INT cUsers = m_UserList.Count();
        PDISKQUOTA_USER pUser = NULL;
        //
        // Find the user that matches pszUserName.
        //
        for (INT i = 0; i < cUsers && -1 == iItem; i++)
        {
            if (m_UserList.Retrieve((LPVOID *)&pUser, i))
            {
                if (NULL != pUser && pUserKey == pUser)
                {
                    iItem = i;
                }
            }
        }
    }
    catch(CAllocException& e)
    {
        m_UserList.ReleaseLock();
        throw;
    }
    m_UserList.ReleaseLock();
    return iItem;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GotoUserName

    Description: Locate a specified user in the listview.  If found, highlight
        the row.  The search is case-insensitive.  This function was originally
        designed to work with the "Find User" feature so that when a record
        is located, it is made visible in the view and highlighted.

    Arguments:
        pszUserName - Account name for user.

    Returns:
        TRUE  = Record found.
        FALSE = Not found.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::GotoUserName(
    LPCTSTR pszUserName
    )
{
    INT iUser = FindUserByName(pszUserName);
    if (-1 != iUser)
    {
        //
        // Found a match (case-insensitive).
        //
        // Select the item specified by the user.
        // Note that we leave any selected items selected.
        // Users may use the find feature to select a set of
        // non-contiguous quota records in the listview.
        //
        ListView_EnsureVisible(m_hwndListView, iUser, FALSE);
        ListView_SetItemState(m_hwndListView, iUser, LVIS_FOCUSED | LVIS_SELECTED,
                                                     LVIS_FOCUSED | LVIS_SELECTED);
    }
    return (-1 != iUser);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetConnectionPoint

    Description: Retrieves the IDiskQuotaEvents connection point from
        the quota control object.  This is the connection point through which
        the asynchronous user name change events are delivered as names
        are resolved by the network DC.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
IConnectionPoint *
DetailsView::GetConnectionPoint(
    VOID
    )
{
    HRESULT hResult       = NO_ERROR;
    IConnectionPoint *pCP = NULL;
    if (NULL != m_pQuotaControl)
    {
        IConnectionPointContainer *pCPC = NULL;
        hResult = m_pQuotaControl->QueryInterface(IID_IConnectionPointContainer,
                                                  (LPVOID *)&pCPC);
        if (SUCCEEDED(hResult))
        {
            hResult = pCPC->FindConnectionPoint(IID_IDiskQuotaEvents, &pCP);
            pCPC->Release();
            if (FAILED(hResult))
                pCP = NULL;
        }
    }
    return pCP;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::ConnectEventSink

    Description: Connects the event sink (DetailsView) from the quota
        controller's IDiskQuotaEvents connection point object.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::ConnectEventSink(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    IConnectionPoint *pConnPt = GetConnectionPoint();
    if (NULL != pConnPt)
    {
        hResult = pConnPt->Advise((LPUNKNOWN)static_cast<IDataObject *>(this), &m_dwEventCookie);
        pConnPt->Release();
        DBGPRINT((DM_VIEW, DL_MID, TEXT("LISTVIEW - Connected event sink.  Cookie = %d"), m_dwEventCookie));
    }
    else
        hResult = E_FAIL;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DisconnectEventSink

    Description: Disconnects the event sink (DetailsView) from the quota
        controller's IDiskQuotaEvents connection point object.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DisconnectEventSink(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    DBGPRINT((DM_VIEW, DL_MID, TEXT("LISTVIEW - Disconnecting event sink.  Cookie = %d"), m_dwEventCookie));

    if (0 != m_dwEventCookie)
    {
        IConnectionPoint *pConnPt = GetConnectionPoint();
        if (NULL != pConnPt)
        {
            hResult = pConnPt->Unadvise(m_dwEventCookie);
            if (SUCCEEDED(hResult))
            {
                m_dwEventCookie = 0;
            }
            pConnPt->Release();
        }
        else
            hResult = E_FAIL;
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::InitLVStateInfo

    Description: Initializes an LV_STATE_INFO structure to default values.
        NOTE: This method is declared static so that it can be called
            without a DetailsView object (not needed).

            If you want to change any listview state defaults, this is the
            place to do it.

    Arguments:
        plvsi - Address of an LV_STATE_INFO structure to be initialized.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::InitLVStateInfo(
    PLV_STATE_INFO plvsi
    )
{
    ZeroMemory(plvsi, sizeof(*plvsi));

    plvsi->cb         = sizeof(*plvsi);

    plvsi->wVersion       = wLV_STATE_INFO_VERSION;
    plvsi->fToolBar       = 1;  // Default to toolbar visible.
    plvsi->fStatusBar     = 1;  // Default to statusbar visible.
    plvsi->iLastColSorted = 0;  // Default to sort first col.
    plvsi->fSortDirection = 1;  // Default to ascending sort.
    for (UINT i = 0; i < DetailsView::idCol_Last; i++)
        plvsi->rgColIndices[i] = i;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::IsValidLVStateInfo

    Description: Validates the contents of a LV_STATE_INFO structure.
        NOTE: This method is declared static so that it can be called
            without a DetailsView object (not needed).

    Arguments:
        plvsi - Address of an LV_STATE_INFO structure to be validated.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::IsValidLVStateInfo(
    PLV_STATE_INFO plvsi
    )
{
    BOOL bResult = FALSE;
    INT i = 0;

    //
    // Validate structure size member.
    //
    if (plvsi->cb != sizeof(LV_STATE_INFO))
        goto info_invalid;
    //
    // Validate version.
    //
    if (wLV_STATE_INFO_VERSION != plvsi->wVersion)
        goto info_invalid;
    //
    // Validate iLastSorted member.
    //
    if (!(plvsi->iLastColSorted >= 0 && plvsi->iLastColSorted < DetailsView::idCol_Last))
        goto info_invalid;
    //
    // Validate each of the column index members.  Used for ordering columns.
    //
    for (i = 0; i < DetailsView::idCol_Last; i++)
    {
        if (!(plvsi->rgColIndices[i] >= 0 && plvsi->rgColIndices[i] < DetailsView::idCol_Last))
            goto info_invalid;
    }

    bResult = TRUE;

info_invalid:

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetColumnIds

    Description: Retrieves a list of IDs for the visible columns in the list.
        A client can use this list to request report items from the
        GetReportXXXXX methods below.

    Arguments:
        prgColIds - Pointer to an array of INTs to receive the column IDs.

        cColIds - Size of the destination array.

    Returns: Number of IDs written to destination array.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
DetailsView::GetColumnIds(
    INT *prgColIds,
    INT cColIds
    )
{
    INT cHdrCols = Header_GetItemCount(m_hwndHeader);
    INT rgiSubItem[DetailsView::idCol_Last];
    INT i = 0;

    if (Header_GetOrderArray(m_hwndHeader, cHdrCols, rgiSubItem))
    {
        for (i = 0; i < cHdrCols && i < cColIds; i++)
        {
            *(prgColIds + i) = m_ColMap.SubItemToId(rgiSubItem[i]);
        }
    }
    return i;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetNextSelectedItemIndex

    Description: Retrieves the index of a selected item.  The search starts
        with the index supplied in the iRow argument.  Therefore, the following
        loop will find all selected items:

        INT iItem = -1;

        while(1)
        {
            iItem = GetNextSelectedItemIndex(iItem);
            if (-1 == iItem)
                break;

            //
            // Do something with item.
            //
        }


    Arguments:
        iRow - Row where to start search.  The row itself is exluded from
            the search.  -1 starts search from the head of the listview.

    Returns:
        0-based index of next selected item if found.
        -1 if no more selected items.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
DetailsView::GetNextSelectedItemIndex(INT iRow)
{
    return ListView_GetNextItem(m_hwndListView, iRow, LVNI_ALL | LVNI_SELECTED);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportItem

    Description: Retrieve a data item for a drag-drop/clipboard report.
        This method is patterned after the GetDispInfo_XXX methods but is
        taylored to placing data on a Stream object.

    Arguments:
        iRow - Row where to begin search for next selected item in listview.
            For the first call, specify -1 to begin the search with the
            first item.  Subsequent calls should specify the value returned
            from the previous call to GetReportItem.

        iColId - Item's column ID (idCol_Folder, idCol_Name etc).

        pItem - Address of an LV_REPORT_ITEM structure.  This structure
            is used to return the data to the caller and also to specify the
            desired format for numeric values.  Some report formats want
            all data in text format (i.e. CF_TEXT) while other binary formats
            want numeric data in numeric format (i.e. XlTable).

    Returns: TRUE  = Retrieved row/col data.
             FALSE = Invalid row or column index.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::GetReportItem(
    UINT iRow,
    UINT iColId,
    PLV_REPORT_ITEM pItem
    )
{
    DBGASSERT((NULL != pItem));
    BOOL bResult          = FALSE;
    PDISKQUOTA_USER pUser = NULL;

    if (m_UserList.Retrieve((LPVOID *)&pUser, iRow))
    {
        LONGLONG llValue;
        DBGASSERT((NULL != pUser));
        bResult = TRUE;

        switch(iColId)
        {
            case DetailsView::idCol_Folder:
            {
                DWORD dwAccountStatus = 0;
                pUser->GetAccountStatus(&dwAccountStatus);

                if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
                {
                    pUser->GetName(pItem->pszText, pItem->cchMaxText,
                                   NULL, 0,
                                   NULL, 0);
                }
                else
                {
                    //
                    // Folder name not resolved.  User name column will
                    // contain status text.
                    //
                    lstrcpyn(pItem->pszText, TEXT(""), pItem->cchMaxText);
                }
                pItem->fType = LVRI_TEXT;
                break;
            }

            case DetailsView::idCol_Name:
            {
                DWORD dwAccountStatus = 0;
                CString strNameText;
                pUser->GetAccountStatus(&dwAccountStatus);

                if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
                {
                    //
                    // User's name has been resolved.
                    //
                    pItem->fType = LVRI_TEXT;
                    pUser->GetName(NULL, 0,
                                   NULL, 0,
                                   strNameText.GetBuffer(MAX_USERNAME), MAX_USERNAME);
                    strNameText.ReleaseBuffer();
                }
                else
                {
                    //
                    // User's name not resolved.  Use a status message.
                    //
                    switch(dwAccountStatus)
                    {
                        case DISKQUOTA_USER_ACCOUNT_UNRESOLVED:
                            strNameText = m_strAccountUnresolved;
                            break;

                        case DISKQUOTA_USER_ACCOUNT_UNKNOWN:
                            strNameText = m_strAccountUnknown;
                            break;

                        case DISKQUOTA_USER_ACCOUNT_INVALID:
                            strNameText = m_strAccountInvalid;
                            break;

                        case DISKQUOTA_USER_ACCOUNT_DELETED:
                            strNameText = m_strAccountDeleted;
                            break;

                        case DISKQUOTA_USER_ACCOUNT_UNAVAILABLE:
                            strNameText = m_strAccountUnavailable;
                            break;
                    }
                }
                lstrcpyn(pItem->pszText, strNameText, pItem->cchMaxText);

                break;
            }

            case DetailsView::idCol_LogonName:
            {
                DBGASSERT((NULL != pUser));
                DWORD dwAccountStatus = 0;
                CString strNameText;
                pUser->GetAccountStatus(&dwAccountStatus);

                if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
                {
                    //
                    // User's name has been resolved.
                    //
                    pItem->fType = LVRI_TEXT;
                    pUser->GetName(NULL, 0,
                                   strNameText.GetBuffer(MAX_USERNAME), MAX_USERNAME,
                                   NULL, 0);
                    strNameText.ReleaseBuffer();
                }

                lstrcpyn(pItem->pszText, strNameText, pItem->cchMaxText);
                break;
            }

            case DetailsView::idCol_Status:
                //
                // Return a text string to represent the icon shown
                // in the "Status" column.
                //
                DBGASSERT((NULL != pUser));
                switch(GetUserQuotaState(pUser))
                {
                    case iUSERSTATE_OK:
                        lstrcpyn(pItem->pszText, m_strStatusOK, pItem->cchMaxText);
                        break;
                    case iUSERSTATE_WARNING:
                        lstrcpyn(pItem->pszText, m_strStatusWarning, pItem->cchMaxText);
                        break;
                    default:
                        DBGASSERT((0));
                        //
                        // Fall through.
                        //
                    case iUSERSTATE_OVERLIMIT:
                        lstrcpyn(pItem->pszText, m_strStatusOverlimit, pItem->cchMaxText);
                        break;
                }
                pItem->fType = LVRI_TEXT;
                break;

            //
            // For the following numeric columns, first get the data then
            // jump to fmt_byte_count to format it as requested.  Note that
            // all numeric values are expressed in megabytes.  This is so they
            // all have the same units to help with ordering in a spreadsheet.
            // Otherwise, sorting would not be possible.  This is also why we
            // include the "(MB)" in the report column titles.
            //
            case DetailsView::idCol_AmtUsed:
                pUser->GetQuotaUsed(&llValue);
                goto fmt_byte_count;

            case DetailsView::idCol_Threshold:
                pUser->GetQuotaThreshold(&llValue);
                goto fmt_byte_count;

            case DetailsView::idCol_Limit:
                pUser->GetQuotaLimit(&llValue);
fmt_byte_count:
                //
                // Format the byte count for the requested data type (text vs. numeric).
                //
                switch(pItem->fType)
                {
                    case LVRI_NUMBER:
                        pItem->fType = LVRI_REAL;
                        if (NOLIMIT == llValue)
                            pItem->dblValue = -1.0;        // Indicates to caller "No Limit".
                        else
                            pItem->dblValue = XBytes::ConvertFromBytes(llValue, XBytes::e_Mega);
                        break;
                    case LVRI_TEXT:
                        if (NOLIMIT == llValue)
                            lstrcpyn(pItem->pszText, m_strNoLimit, pItem->cchMaxText);
                        else
                            XBytes::FormatByteCountForDisplay(llValue,
                                                              pItem->pszText,
                                                              pItem->cchMaxText,
                                                              XBytes::e_Mega);
                        //
                        // Fall through.
                        //
                    default:
                        break;
                }
                break;

            case DetailsView::idCol_PctUsed:
            {
                HRESULT hResult = CalcPctQuotaUsed(pUser, &pItem->dwValue);
                //
                // Format the percent value for the requested data type (text vs. numeric).
                // If a percentage can't be calculated (0 denominator), return -2 as an
                // INT value or "N/A" as a text value.
                //
                switch(pItem->fType)
                {
                    case LVRI_NUMBER:
                        pItem->fType = LVRI_INT;
                        if (FAILED(hResult))
                            pItem->dwValue = (DWORD)-2; // Indicates to caller "N/A".
                        break;
                    case LVRI_TEXT:
                        if (FAILED(hResult))
                            lstrcpyn(pItem->pszText, m_strNotApplicable, pItem->cchMaxText);
                        else
                            wnsprintf(pItem->pszText, pItem->cchMaxText, TEXT("%d"), pItem->dwValue);

                    default:
                        break;
                }
                break;
            }

            default:
                bResult = FALSE;
                break;
        }
    }
    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportTitle

    Description: Retrieves a title for a report.  Uses the listview window
        title.

    Arguments:
        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::GetReportTitle(
    LPTSTR pszDest,
    UINT cchDest
    )
{
    //
    // This is simple.  Just use the details view title.
    // FEATURE: Could be enhanced to include the date/time but that will
    //         require localization considerations.
    //
    GetWindowText(m_hwndMain, pszDest, cchDest);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportColHeader

    Description: Retrieves a title for a report column.  Note that the titles
        may differ from those used in the listview.  Specifically for the
        numeric columns.  In the listview, numeric column entries include
        units (bytes, KB, MB etc.).  In a report, these numeric values are
        all expressed in MB.  Therefore, the units must be included in the
        title string.

    Arguments:
        iColId - ID of column requested (idCol_Folder, idCol_Name etc.)

        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::GetReportColHeader(
    UINT iColId,
    LPTSTR pszDest,
    UINT cchDest
    )
{
    //
    // WARNING:  The order of these must match that of the idCol_XXX enumeration
    //           constants in DetailsView.
    //
    UINT rgTitles[] = { IDS_REPORT_HEADER_STATUS,
                        IDS_REPORT_HEADER_FOLDER,
                        IDS_REPORT_HEADER_USERNAME,
                        IDS_REPORT_HEADER_LOGONNAME,
                        IDS_REPORT_HEADER_AMTUSED,
                        IDS_REPORT_HEADER_LIMIT,
                        IDS_REPORT_HEADER_THRESHOLD,
                        IDS_REPORT_HEADER_PCTUSED };

    DBGASSERT((NULL != pszDest));
    DBGASSERT((1 < cchDest));
    CString strHeader(TEXT("..."));

    if (iColId < ARRAYSIZE(rgTitles))
    {
        strHeader.Format(g_hInstDll, rgTitles[iColId]);
    }
    else
    {
        DBGERROR((TEXT("LISTVIEW - Invalid idCol (%d) on header request"), iColId));
    }
    lstrcpyn(pszDest, strHeader, cchDest);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportRowCount

    Description: Retrieves the number of data rows in the listview.

    Arguments: None.

    Returns: Number of rows in the listview.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
DetailsView::GetReportRowCount(VOID)
{
    return ListView_GetSelectedCount(m_hwndListView);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportBinaryRecordSize

    Description: Retrieves the number of bytes in a record formatted as
        binary data.  This should be called before GetReportBinaryRecord to
        determine how to size the destination buffer.

    Arguments:
        iRow - 0-based index of the row in question.

    Returns: Number of bytes required to store the record.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
DetailsView::GetReportBinaryRecordSize(
    UINT iRow
    )
{
    INT cbRecord = 0;

    PDISKQUOTA_USER pUser = NULL;

    DBGASSERT((iRow < m_UserList.Count()));

    if (m_UserList.Retrieve((LPVOID *)&pUser, iRow))
    {
        if (NULL != pUser)
        {
            pUser->GetSidLength((LPDWORD)&cbRecord); // Length of SID field.

            cbRecord += sizeof(DWORD)    +     // Sid-Length field.
                        sizeof(LONGLONG) +     // Quota used field.
                        sizeof(LONGLONG) +     // Quota threshold field.
                        sizeof(LONGLONG);      // Quota limit field.
        }
    }
    return cbRecord;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportBinaryRecord

    Description: Retrieves the information for a single row in the
        details view formatted as binary data.
        The format of the returned record is as follows:

        +------------+---------------------------------------+
        | cbSid (32) |       SID (variable length)           |
        +------------+------------+-------------+------------+
        |    Quota Used (64)      |  Quota Threshold (64)    |
        +------------+------------+-------------+------------+
        |    Quota Limit (64)     |
        +------------+------------+

        (*) The size of each field (bits) is shown in parentheses.


    Arguments:
        iRow - 0-based index of the row in question.

        pbRecord - Address of destination buffer.

        cbRecord - Number of bytes in destination buffer.

    Returns:
        TRUE  = Destination buffer was sufficiently large.
        FALSE = Destination buffer too small or record was invalid.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::GetReportBinaryRecord(
    UINT iRow,
    LPBYTE pbRecord,
    UINT cbRecord
    )
{
    //
    // Create "PMF" (pointer to member function) as a type of pointer
    // to the IDiskQuotaUser::GetQuotaXXXXXX functions.  This allows us
    // to build an array of function pointers and reduce the amount of
    // code required.
    //
    typedef HRESULT(_stdcall IDiskQuotaUser::*PMF)(PLONGLONG);

    PDISKQUOTA_USER pUser = NULL;
    BOOL bResult = FALSE;

    DBGASSERT((iRow < m_UserList.Count()));
    DBGASSERT((NULL != pbRecord));

    if (m_UserList.Retrieve((LPVOID *)&pUser, iRow))
    {
        DWORD cbSid = 0;
        if (NULL != pUser && cbRecord >= sizeof(cbSid))
        {
            //
            // Store the SID-length value first in the record.
            //
            pUser->GetSidLength((LPDWORD)&cbSid);
            *((LPDWORD)pbRecord) = cbSid;

            pbRecord += sizeof(cbSid);
            cbRecord -= sizeof(cbSid);

            //
            // Store the SID value next.
            //
            if (cbRecord >= cbSid && SUCCEEDED(pUser->GetSid(pbRecord, cbRecord)))
            {
                pbRecord += cbSid;
                cbRecord -= cbSid;
                //
                // An array of member function pointers.  Each function
                // retrieves a LONGLONG value from the quota user object.
                // This places the redundant code in a loop.
                //
                // The value order is Quota Used, Quota Threshold, Quota Limit.
                //
                PMF rgpfnQuotaValue[] = {
                    &IDiskQuotaUser::GetQuotaUsed,
                    &IDiskQuotaUser::GetQuotaThreshold,
                    &IDiskQuotaUser::GetQuotaLimit
                    };

                for (INT i = 0; i < ARRAYSIZE(rgpfnQuotaValue); i++)
                {
                    bResult = TRUE;
                    if (cbRecord >= sizeof(LONGLONG))
                    {
                        //
                        // First copy to a stack LONGLONG as it is guaranteed
                        // to be aligned.  Then byte-copy the value to the
                        // output buffer.
                        //        
                        LONGLONG llValue;
                        (pUser->*(rgpfnQuotaValue[i]))(&llValue);
                        CopyMemory(pbRecord, &llValue, sizeof(llValue));
                        pbRecord += sizeof(LONGLONG);
                        cbRecord -= sizeof(LONGLONG);
                    }
                    else
                    {
                        //
                        // Insufficient buffer.
                        //
                        bResult = FALSE;
                        break;
                    }
                }
            }
        }
    }
    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GiveFeedback

    Description: Implementation for IDropSource::GiveFeedback.

    Arguments: See IDropSource::GiveFeedback in SDK.

    Returns: Always returns DRAGDROP_S_USEDEFAULTS.
        We don't have any special cursors for drag/drop.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::GiveFeedback(
    DWORD dwEffect
    )
{
    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DropSource::GiveFeedback")));
    return DRAGDROP_S_USEDEFAULTCURSORS;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::QueryContinueDrag

    Description: Implementation for IDropSource::QueryContinueDrag

    Arguments: See IDropSource::QueryContinueDrag in SDK.

    Returns:
        DRAGDROP_S_CANCEL = User pressed ESC during drag.
        DRAGDROP_S_DROP   = User releases left mouse button.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::QueryContinueDrag(
    BOOL fEscapePressed,
    DWORD grfKeyState
    )
{
    HRESULT hResult = S_OK;

    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DropSource::QueryContinueDrag")));
    if (fEscapePressed)
        hResult = DRAGDROP_S_CANCEL;
    else if (!(m_DropSource.m_grfKeyState & grfKeyState))
        hResult = DRAGDROP_S_DROP;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DragEnter

    Description: Implementation for IDropTarget::DragEnter

    Arguments: See IDropTarget::DragEnter in SDK.

    Returns: See IDropTarget::DragEnter in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DragEnter(
    IDataObject *pDataObject,
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect
    )
{
    BOOL bWillAcceptDrop = FALSE;
    HRESULT hResult = NO_ERROR;
    IEnumFORMATETC *pEnum = NULL;

    *pdwEffect = DROPEFFECT_NONE;

    //
    // Enumerate formats supported by our data object.
    //
    hResult = pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum);
    if (SUCCEEDED(hResult))
    {
        ULONG ulFetched = 0;
        FORMATETC fmt;

        //
        // Search the formats until we find an acceptable match.
        // We only accept our private export format along with
        // CF_HDROP in stream and HGLOBAL media types.
        //
        while(!bWillAcceptDrop && S_OK == pEnum->Next(1, &fmt, &ulFetched))
        {
            if (fmt.cfFormat == DataObject::m_CF_NtDiskQuotaExport || fmt.cfFormat == CF_HDROP)
            {
                if (fmt.tymed & (TYMED_HGLOBAL | TYMED_ISTREAM))
                {
                    bWillAcceptDrop = TRUE;
                }
            }
        }
        pEnum->Release();
    }
    if (SUCCEEDED(hResult))
    {
        hResult = NO_ERROR;
        if (bWillAcceptDrop)
        {
            *pdwEffect = (grfKeyState & MK_CONTROL ? DROPEFFECT_COPY :
                                                     DROPEFFECT_MOVE);
            m_DropTarget.m_pIDataObject = pDataObject;
            m_DropTarget.m_pIDataObject->AddRef();
        }
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DragOver

    Description: Implementation for IDropTarget::DragOver

    Arguments: See IDropTarget::DragOver in SDK.

    Returns: See IDropTarget::DragOver in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DragOver(
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect
    )
{
    if (NULL != m_DropTarget.m_pIDataObject)
    {
        *pdwEffect = (grfKeyState & MK_CONTROL ? DROPEFFECT_COPY :
                                                 DROPEFFECT_MOVE);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }

    return NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DragLeave

    Description: Implementation for IDropTarget::DragLeave

    Arguments: See IDropTarget::DragLeave in SDK.

    Returns: See IDropTarget::DragLeave in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DragLeave(
    VOID
    )
{
    if (NULL != m_DropTarget.m_pIDataObject)
    {
        m_DropTarget.m_pIDataObject->Release();
    }

    return NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Drop

    Description: Implementation for IDropTarget::Drop

    Arguments: See IDropTarget::Drop in SDK.

    Returns: See IDropTarget::Drop in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Drop(
    IDataObject *pDataObject,
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect
    )
{
    HRESULT hResult = E_FAIL;

    *pdwEffect = DROPEFFECT_NONE;

    if (NULL != m_DropTarget.m_pIDataObject)
    {
        DragLeave();

        //
        // Import the quota data from the data object.
        //
        Importer importer(*this);
        hResult = importer.Import(pDataObject);

        if (SUCCEEDED(hResult))
        {
            if (grfKeyState & MK_CONTROL)
            {
                *pdwEffect = DROPEFFECT_COPY;
            }
        }
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetData

    Description: Implementation of IDataObject::GetData

    Arguments: See IDataObject::GetData in SDK.

    Returns: See IDataObject::GetData in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::GetData(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pMedium
    )
{
    HRESULT hResult = E_INVALIDARG;

#if DBG

    TCHAR szCFName[MAX_PATH] = { TEXT('\0') };

    GetClipboardFormatName(pFormatEtc->cfFormat, szCFName, ARRAYSIZE(szCFName));
    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::GetData\nDVA = %d  CF = %d (%s) tymed = %d"),
           pFormatEtc->dwAspect, pFormatEtc->cfFormat,
           szCFName,
           pFormatEtc->tymed));

#endif // DEBUG

    if (NULL != pFormatEtc && NULL != pMedium)
    {
        //
        // See if we support the requested format.
        //
        hResult = m_pDataObject->IsFormatSupported(pFormatEtc);
        if (SUCCEEDED(hResult))
        {
            //
            // Yep, we support it.  Render the data.
            //
            hResult = m_pDataObject->RenderData(pFormatEtc, pMedium);
        }
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetDataHere

    Description: Implementation of IDataObject::GetDataHere

    Arguments: See IDataObject::GetData in SDK.

    Returns: E_NOTIMPL

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::GetDataHere(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pMedium
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::GetDataHere")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::QueryGetData

    Description: Implementation of IDataObject::QueryGetData

    Arguments: See IDataObject::QueryGetData in SDK.

    Returns: See IDataObject::QueryGetData in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::QueryGetData(
    FORMATETC *pFormatEtc
    )
{
    HRESULT hResult = E_UNEXPECTED;

#if DBG

    TCHAR szCFName[MAX_PATH] = { TEXT('\0') };

    GetClipboardFormatName(pFormatEtc->cfFormat, szCFName, ARRAYSIZE(szCFName));
    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::QueryGetData\nDVA = %d  CF = %d (%s) tymed = %d"),
           pFormatEtc->dwAspect, pFormatEtc->cfFormat,
           szCFName,
           pFormatEtc->tymed));

#endif // DEBUG

    if (NULL != pFormatEtc)
    {
        hResult = m_pDataObject->IsFormatSupported(pFormatEtc);
    }
    else
        hResult = E_INVALIDARG;

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetCanonicalFormatEtc

    Description: Implementation of IDataObject::GetCanonicalFormatEtc

    Arguments: See IDataObject::GetCanonicalFormatEtc in SDK.

    Returns: See IDataObject::GetCanonicalFormatEtc in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::GetCanonicalFormatEtc(
    FORMATETC *pFormatEtcIn,
    FORMATETC *pFormatEtcOut
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::GetCanonicalFormatEtc")));

    HRESULT hResult = E_INVALIDARG;

    if (NULL != pFormatEtcIn && NULL != pFormatEtcOut)
    {
        CopyMemory(pFormatEtcOut, pFormatEtcIn, sizeof(*pFormatEtcOut));
        pFormatEtcOut->ptd = NULL;
        hResult = DATA_S_SAMEFORMATETC;
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::SetData

    Description: Implementation of IDataObject::SetData

    Arguments: See IDataObject::SetData in SDK.

    Returns: E_NOTIMPL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::SetData(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pMedium,
    BOOL fRelease
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::SetData")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::EnumFormatEtc

    Description: Implementation of IDataObject::EnumFormatEtc

    Arguments: See IDataObject::EnumFormatEtc in SDK.

    Returns: See IDataObject::GetCanonicalFormatEtc in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::EnumFormatEtc")));

    HRESULT hResult      = E_FAIL;
    EnumFORMATETC *pEnum = NULL;

    switch(dwDirection)
    {
        case DATADIR_GET:
            try
            {
                pEnum = new EnumFORMATETC(m_pDataObject->m_cFormats, m_pDataObject->m_rgFormats);
                hResult = pEnum->QueryInterface(IID_IEnumFORMATETC, (LPVOID *)ppenumFormatEtc);
            }
            catch(CAllocException& e)
            {
                *ppenumFormatEtc = NULL;
                hResult = E_OUTOFMEMORY;
            }
            break;

        case DATADIR_SET:
            //
            // SetData not implemented.
            //
        default:
            *ppenumFormatEtc = NULL;
            break;
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DAdvise

    Description: Implementation of IDataObject::DAdvise

    Arguments: See IDataObject::DAdvise in SDK.

    Returns: E_NOTIMPL

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::DAdvise(
    FORMATETC *pFormatEtc,
    DWORD advf,
    IAdviseSink *pAdvSink,
    DWORD *pdwConnection
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::DAdvise")));
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DUnadvise

    Description: Implementation of IDataObject::DUnadvise

    Arguments: See IDataObject::DUnadvise in SDK.

    Returns: E_NOTIMPL

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::DUnadvise(
    DWORD dwConnection
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::DUnadvise")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::EnumDAdvise

    Description: Implementation of IDataObject::EnumDAdvise

    Arguments: See IDataObject::EnumDAdvise in SDK.

    Returns: E_NOTIMPL

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::EnumDAdvise(
    IEnumSTATDATA **ppenumAdvise
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::EnumDAdvise")));
    return E_NOTIMPL;
}


//
// Number of clipboard formats supported by our data object.
// Change this if you add/remove clipboard formats.  There's an assert
// in the DataObject ctor to ensure this.
//
const INT DetailsView::DataObject::CF_FORMATS_SUPPORTED = 14;
//
// Name of data stream in import/export and dragdrop streams.
//
LPCWSTR DetailsView::DataObject::SZ_EXPORT_STREAM_NAME = L"NT DISKQUOTA IMPORTEXPORT";
LPCTSTR DetailsView::DataObject::SZ_EXPORT_CF_NAME     = TEXT("NT DISKQUTOA IMPORTEXPORT");

//
// The version of export data produced by this module.  This value
// is written into the stream immediately following the GUID.  If the
// format of the export stream is changed, this value should be incremented.
//
const DWORD DetailsView::DataObject::EXPORT_STREAM_VERSION = 1;

CLIPFORMAT DetailsView::DataObject::m_CF_Csv                 = 0; // Comma-separated fields format.
CLIPFORMAT DetailsView::DataObject::m_CF_RichText            = 0; // RTF format.
CLIPFORMAT DetailsView::DataObject::m_CF_NtDiskQuotaExport   = 0; // Internal fmt for import/export.
CLIPFORMAT DetailsView::DataObject::m_CF_FileGroupDescriptor = 0;
CLIPFORMAT DetailsView::DataObject::m_CF_FileContents        = 0;


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::DataObject

    Description: Constructor for implementation of IDataObject.

    Arguments:
        DV - Reference to details view object that contains the data object.

    Returns: Nothing

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::DataObject::DataObject(
    DetailsView& DV
    ) : m_pStg(NULL),
        m_pStm(NULL),
        m_rgFormats(NULL),
        m_cFormats(CF_FORMATS_SUPPORTED),
        m_DV(DV)
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("DetailsView::DataObject::DataObject")));
    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    //
    // Get additional clipboard formats we support.
    //
    if (0 == m_CF_Csv)
    {
        m_CF_Csv               = (CLIPFORMAT)RegisterClipboardFormat(TEXT("Csv"));
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - Csv CF            = %d"), m_CF_Csv));
    }

    if (0 == m_CF_RichText)
    {
        m_CF_RichText          = (CLIPFORMAT)RegisterClipboardFormat(TEXT("Rich Text Format"));
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - RTF CF            = %d"), m_CF_RichText));
    }

    if (0 == m_CF_NtDiskQuotaExport)
    {
        m_CF_NtDiskQuotaExport = (CLIPFORMAT)RegisterClipboardFormat(DataObject::SZ_EXPORT_CF_NAME);
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - NtDiskQuotaExport = %d"), m_CF_NtDiskQuotaExport));
    }

    if (0 == m_CF_FileGroupDescriptor)
    {
        m_CF_FileGroupDescriptor = (CLIPFORMAT)RegisterClipboardFormat(TEXT("FileGroupDescriptorW"));
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - FileGroupDescriptorW = %d"), m_CF_FileGroupDescriptor));
    }

    if (0 == m_CF_FileContents)
    {
        m_CF_FileContents = (CLIPFORMAT)RegisterClipboardFormat(TEXT("FileContents"));
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - FileContents = %d"), m_CF_FileContents));
    }

    //
    // Create the array to hold the FORMATETC structures that describe the
    // formats we support.
    //
    m_rgFormats = new FORMATETC[m_cFormats];

    //
    // Specify all formats and media we support.
    // Place the richest formats first in the array.
    // These are used to initialize the format enumerator when it
    // is requested.
    //
    UINT iFmt = 0;

    SetFormatEtc(m_rgFormats[iFmt++], m_CF_FileGroupDescriptor, TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_FileGroupDescriptor, TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_FileContents,        TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_FileContents,        TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_NtDiskQuotaExport,   TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_NtDiskQuotaExport,   TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_RichText,            TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_RichText,            TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_Csv,                 TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_Csv,                 TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], CF_UNICODETEXT,           TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], CF_UNICODETEXT,           TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], CF_TEXT,                  TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], CF_TEXT,                  TYMED_HGLOBAL);

    //
    // If you hit this, you need to adjust CF_FORMATS_SUPPORTED to match
    // the number of SetFormatEtc statements above.
    // Otherwise, you just overwrote the m_rgFormats[] allocation.
    //
    DBGASSERT((iFmt == m_cFormats));
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::~DataObject

    Description: Destructor for implementation of IDataObject.

    Arguments: None.

    Returns: Nothing

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::DataObject::~DataObject(
    VOID
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("DetailsView::DataObject::~DataObject")));
    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    delete[] m_rgFormats;
    if (NULL != m_pStg)
        m_pStg->Release();
    //
    // NOTE:  m_pStm is released by the data object's recipient
    //        through ReleaseStgMedium.
    //
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::IsFormatSupported

    Description: Determines if a given format is supported by our implementation.

    Arguments:
        pFormatEtc - Address of FORMATETC structure containing request info.

    Returns:
        NO_ERROR       - Supported.
        DV_E_TYMED     - Medium type not supported.
        DV_E_FORMATETC - Clipboard format not supported.
        DV_E_DVASPECT  - Device aspect not supported.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DataObject::IsFormatSupported(
    FORMATETC *pFormatEtc
    )
{
    DBGASSERT((NULL != pFormatEtc));
    HRESULT hResult = E_FAIL;

    if (DVASPECT_CONTENT == pFormatEtc->dwAspect)
    {
        if (CF_TEXT                  == pFormatEtc->cfFormat ||
            CF_UNICODETEXT           == pFormatEtc->cfFormat ||
            m_CF_RichText            == pFormatEtc->cfFormat ||
            m_CF_Csv                 == pFormatEtc->cfFormat ||
            m_CF_NtDiskQuotaExport   == pFormatEtc->cfFormat ||
            m_CF_FileGroupDescriptor == pFormatEtc->cfFormat ||
            m_CF_FileContents        == pFormatEtc->cfFormat)
        {
            if (pFormatEtc->tymed & (TYMED_ISTREAM | TYMED_HGLOBAL))
            {
                hResult = NO_ERROR;
            }
            else
            {
                hResult = DV_E_TYMED;
            }
        }
        else
            hResult = DV_E_FORMATETC;
    }
    else
        hResult = DV_E_DVASPECT;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::CreateRenderStream

    Description: Creates the OLE stream on which the data is to be rendered.

    Arguments:
        tymed - Desired medium type.

        ppStm - Address of IStream pointer variable to receive the stream ptr.

    Returns:
        NO_ERROR       - Success.
        E_INVALIDARG   - Invalid medium type.
        E_OUTOFMEMORY  - Insufficient memory.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/30/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DataObject::CreateRenderStream(
    DWORD tymed,
    IStream **ppStm
    )
{
    HRESULT hResult = NOERROR;

    //
    // Create the Stream.
    //
    if (TYMED_ISTREAM & tymed)
    {
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - CreateRenderStream for ISTREAM")));
        hResult = CreateStreamOnHGlobal(NULL,       // Block of 0 bytes.
                                        TRUE,       // Delete on release.
                                        ppStm);
    }
    else if (TYMED_HGLOBAL & tymed)
    {
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - CreateRenderStream for HGLOBAL")));
        hResult = CreateStreamOnHGlobal(NULL,       // Block of 0 bytes.
                                        TRUE,       // Delete on release.
                                        ppStm);
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::RenderData [private]

    Description: Renders the data in the Details View onto the provided
        stream using the requested clipboard format.

    Arguments:
        pStm - Pointer to output stream.

        cf - Desired clipboard format.

    Returns:
        NO_ERROR         - Success.
        E_FAIL           - General failure.
        STG_E_WRITEFAULT - Media write error.
        STG_E_MEDIUMFULL - Insufficient space on medium.
        E_ACCESSDENIED   - Write access denied.
        E_OUTOFMEMORY    - Insufficient memory.
        E_UNEXPECTED     - Unexpected exception.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/30/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DataObject::RenderData(
    IStream *pStm,
    CLIPFORMAT cf
    )
{
    HRESULT hResult     = NOERROR;
    Renderer *pRenderer = NULL;

    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DetailsView::DataObject::RenderData on stream")));
    try
    {
        //
        // Create the properly-typed rendering object for the requested format.
        //
        switch(cf)
        {
            case CF_TEXT:
                DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is CF_TEXT")));
                pRenderer = new Renderer_TEXT(m_DV);
                break;

            case CF_UNICODETEXT:
                DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is CF_UNICODETEXT")));
                pRenderer = new Renderer_UNICODETEXT(m_DV);
                break;

            default:
                if (m_CF_RichText == cf)
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is RTF")));
                    pRenderer = new Renderer_RTF(m_DV);
                }
                else if (m_CF_Csv == cf)
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is Csv")));
                    pRenderer = new Renderer_Csv(m_DV);
                }
                else if (m_CF_NtDiskQuotaExport == cf)
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is Windows NT Disk Quota ImportExport Format")));
                    pRenderer = new Renderer_Export(m_DV);
                }
                else if (m_CF_FileGroupDescriptor == cf)
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is FileGroupDescriptor")));
                    pRenderer = new Renderer_FileGroupDescriptor(m_DV);
                }
                else if (m_CF_FileContents == cf)
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is FileContents")));
                    pRenderer = new Renderer_FileContents(m_DV);
                }
                else
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Unknown CF format (%d) requested"), cf));
                }
                break;
        }

        if (NULL != pRenderer)
        {
            m_pStm->AddRef();      // Giving stream to renderer.
                                   // Will be released when renderer is destroyed.
            //
            // Render the information onto the stream.
            // This can throw FileError exceptions if we run out of disk
            // space or there's a disk write error.
            //
            pRenderer->Render(m_pStm);
        }
    }
    catch(CFileException& fe)
    {
        switch(fe.Reason())
        {
            case CFileException::write:
                DBGERROR((TEXT("FileWrite error")));
                hResult = E_FAIL;
                break;
            case CFileException::device:
                DBGERROR((TEXT("Disk error")));
                hResult = STG_E_WRITEFAULT;
                break;
            case CFileException::diskfull:
                DBGERROR((TEXT("Disk Full error")));
                hResult = STG_E_MEDIUMFULL;
                break;
            case CFileException::access:
                DBGERROR((TEXT("Access Denied error")));
                hResult = E_ACCESSDENIED;
                break;
            default:
                DBGERROR((TEXT("Other error")));
                hResult = E_FAIL;
                break;
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory")));
        hResult = E_OUTOFMEMORY;
    }

    delete pRenderer;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::RenderData [public]

    Description: Renders the data in the Details View onto the requested
        medium using the requested format.

    Arguments:
        pFormatEtc - Address of FORMATETC structure containing request info.

        pMedium - Address of STGMEDIUM structure containing requested
            medium info.

    Returns:
        NO_ERROR       - Success.
        Can return many other OLE drag/drop error codes.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/10/96    Initial creation.                                    BrianAu
    07/30/97    Reworked.  Moved some code into CreateRenderStream   BrianAu
                and CreateAndRunRenderer.  Makes the function
                more understandable.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DataObject::RenderData(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pMedium
    )
{
    DBGASSERT((NULL != pFormatEtc));
    DBGASSERT((NULL != pMedium));
    DBGASSERT((SUCCEEDED(IsFormatSupported(pFormatEtc))));

    HRESULT hResult     = NOERROR;
    Renderer *pRenderer = NULL;

    DBGPRINT((DM_DRAGDROP, DL_HIGH, TEXT("DetailsView::DataObject::RenderData on medium")));

    //
    // Create the stream we'll render the data onto.
    //
    hResult = CreateRenderStream(pFormatEtc->tymed, &m_pStm);
    if (SUCCEEDED(hResult))
    {
        //
        // Render the data on the stream.
        //
        hResult = RenderData(m_pStm, pFormatEtc->cfFormat);

        if (SUCCEEDED(hResult))
        {
            //
            // If we've made it here, we have a valid drag-drop report on m_pStm.
            // Now set up the stg medium to transfer the rendering.
            //
            if (TYMED_ISTREAM & pFormatEtc->tymed)
            {
                pMedium->pstm           = m_pStm;
                pMedium->tymed          = TYMED_ISTREAM;
                pMedium->pUnkForRelease = NULL;          // Target will free the Stream.
            }
            else if (TYMED_HGLOBAL & pFormatEtc->tymed)
            {
                pMedium->tymed          = TYMED_HGLOBAL;
                pMedium->pUnkForRelease = NULL;          // Target will free the mem.
                hResult = GetHGlobalFromStream(m_pStm,
                                               &pMedium->hGlobal);
            }
            else
            {
                //
                // Call to CreateRenderStream() should have failed if we
                // hit this.
                //
                DBGASSERT((0));
            }
        }
        if (FAILED(hResult))
        {
            DBGERROR((TEXT("DRAGDROP - Error 0x%08X rendering data"), hResult));

            //
            // Something failed after the stream was created.
            // The DetailsView::DataObject dtor DOES NOT release it.
            // It assumes success and assumes the recipient will release it.
            // Release the stream.
            //
            m_pStm->Release();
            //
            // These two statements are redundant since pMedium contains a union.
            // I didn't want any more if(STREAM) else if (HGLOBAL) logic.  In case
            // there's ever a change in structure, this will ensure both possible
            // medium types are null'd out.
            //
            pMedium->pstm    = NULL;
            pMedium->hGlobal = NULL;
        }
    }
    else
    {
        DBGERROR((TEXT("DRAGDROP - Error 0x%08X creating stream"), hResult);)
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::SetFormatEtc [static]

    Description: Helper function to set the members of a FORMATETC
        structure.  Uses defaults for least used members.

    Arguments: See SDK description of FORMATETC.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::SetFormatEtc(
    FORMATETC& fe,
    CLIPFORMAT cfFormat,
    DWORD tymed,
    DWORD dwAspect,
    DVTARGETDEVICE *ptd,
    LONG lindex
    )
{
    fe.cfFormat = cfFormat;
    fe.dwAspect = dwAspect;
    fe.ptd      = ptd;
    fe.tymed    = tymed;
    fe.lindex   = lindex;
};


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::WideToAnsi

    Description: Helper function to convert a wide character string to ANSI.
        The caller must delete the return buffer.

    Arguments:
        pszTextW - UNICODE string to convert.

    Returns: Address of ANSI string.  Caller must delete this.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPSTR
DetailsView::DataObject::WideToAnsi(
    LPCWSTR pszTextW
    )
{
    DBGASSERT((NULL != pszTextW));

    INT cchTextA = WideCharToMultiByte(CP_ACP,
                                       0,
                                       pszTextW,
                                       -1,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL);

    LPSTR pszTextA = new CHAR[cchTextA];

    WideCharToMultiByte(CP_ACP,
                        0,
                        pszTextW,
                        -1,
                        pszTextA,
                        cchTextA,
                        NULL,
                        NULL);
    return pszTextA;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::Renderer::Render

    Description: Render the selected items in the listview on a stream.
        Calls virtual functions defined by derived classes to produce the
        required format.

    Arguments:
        pStm - Address of IStream on which to write output.
            Assumes that this pointer has been AddRef'd by the caller.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::Renderer::Render(
    IStream *pStm
    )
{
    HRESULT hResult = NO_ERROR;
    WCHAR szText[MAX_PATH];
    INT rgColIds[DetailsView::idCol_Last];
    INT cCols = m_DV.GetColumnIds(rgColIds, ARRAYSIZE(rgColIds));
    INT cRows = m_DV.GetReportRowCount();
    INT i, j;
    INT iRow = -1;

    DBGASSERT((NULL != pStm));
    m_Stm.SetStream(pStm);

    //
    // Start the report.
    //
    Begin(cRows, cCols);

    //
    // Add the report title.
    //
    m_DV.GetReportTitle(szText, ARRAYSIZE(szText));
    AddTitle(szText);

    //
    // Add the report column headers.
    //
    BeginHeaders();
    for (i = 0; i < cCols; i++)
    {
        m_DV.GetReportColHeader(rgColIds[i], szText, ARRAYSIZE(szText));
        AddHeader(szText);
        AddHeaderSep();
    }
    EndHeaders();

    //
    // Add the report row/col data.
    //
    for (i = 0; i < cRows; i++)
    {
        iRow = m_DV.GetNextSelectedItemIndex(iRow);
        DBGASSERT((-1 != iRow));
        BeginRow();
        for (j = 0; j < cCols; j++)
        {
            AddRowColData(iRow, rgColIds[j]);
            AddRowColSep();
        }
        EndRow();
    }

    //
    // Terminate the report.
    //
    End();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::Renderer::Stream::Stream

    Description: Constructor for the renderer's private stream object.
        The object is used to encapsulate stream write operations in overloaded
        type-sensitive member functions.

    Arguments:
        pStm - Address of IStream associated with the object.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::DataObject::Renderer::Stream::Stream(
    IStream *pStm
    ) : m_pStm(pStm)
{

#ifdef CLIPBOARD_DEBUG_OUTPUT
    m_pStgDbgOut = NULL;
    m_pStmDbgOut = NULL;
    StgCreateDocfile(TEXT("\\DskquotaClipboard.Out"),
                     STGM_CREATE |
                     STGM_READWRITE |
                     STGM_SHARE_EXCLUSIVE,
                     0,
                     &m_pStgDbgOut);
    if (NULL != m_pStgDbgOut)
    {
        m_pStgDbgOut->CreateStream(TEXT("Clipboard Data"),
                                   STGM_CREATE |
                                   STGM_READWRITE |
                                   STGM_SHARE_EXCLUSIVE,
                                   0, 0,
                                   &m_pStmDbgOut);
    }
#endif // CLIPBOARD_DEBUG_OUTPUT
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::Renderer::Stream::~Stream

    Description: Destructor for the renderer's private stream object.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::DataObject::Renderer::Stream::~Stream(VOID)
{
    if (NULL != m_pStm)
        m_pStm->Release();

#ifdef CLIPBOARD_DEBUG_OUTPUT

    if (NULL != m_pStmDbgOut)
        m_pStmDbgOut->Release();
    if (NULL != m_pStgDbgOut)
        m_pStgDbgOut->Release();

#endif // CLIPBOARD_DEBUG_OUTPUT
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::Renderer::Stream::SetStream

    Description: Associates an IStream pointer with the stream object.
        Releases an existing pointer if one was already assigned.

    Arguments:
        pStm - Address of new IStream to associate with stream object.
            Caller must AddRef IStream pointer before passing to this function.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::Renderer::Stream::SetStream(
    IStream *pStm
    )
{
    DBGASSERT((NULL != pStm));

    if (NULL != m_pStm)
        m_pStm->Release();
    m_pStm = pStm;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::Renderer::Stream::Write

    Description: Set of overloaded functions to handle
        the writing of various types of data to the stream.

    Arguments:
        pbData - Address of BYTE buffer for source data.

        cbData - Number of bytes in pbData[]

        pszTextA - Ansi text string for source data.

        pszTextW - Wide character text string for source data.

        bData - Byte to write to stream.

        chDataW - Wide character to write to stream.

        chDataA - Ansi character to write to stream.

        dwData - DWORD-type data to write to stream.

        dblData - double-type data to write to stream.


    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::Renderer::Stream::Write(
    LPBYTE pbData,
    UINT cbData
    )
{
    DBGASSERT((NULL != pbData));

    ULONG cbWritten = 0;
    HRESULT hr;

    hr = m_pStm->Write(pbData, cbData, &cbWritten);
    if (S_OK != hr)
    {
        DBGERROR((TEXT("Error 0x%08X writing to output stream."), hr));
        CFileException::reason reason = CFileException::write;
        switch(hr)
        {
            case STG_E_ACCESSDENIED:
                reason = CFileException::access;
                break;
            case STG_E_MEDIUMFULL:
                reason = CFileException::diskfull;
                break;
            case STG_E_WRITEFAULT:
                reason = CFileException::device;
                break;
            default:
                //
                // Use default value.
                //
                break;
        }
        throw CFileException(reason, TEXT(""), 0);
    }

#ifdef CLIPBOARD_DEBUG_OUTPUT

    cbWritten = 0;
    if (S_OK != m_pStmDbgOut->Write(pbData, cbData, &cbWritten))
        throw CFileException(CFileException::write, TEXT(""), 0);

#endif  // CLIPBOARD_DEBUG_OUTPUT
}


VOID
DetailsView::DataObject::Renderer::Stream::Write(
    LPCWSTR pszTextW
    )
{
    Write((LPBYTE)pszTextW, lstrlenW(pszTextW) * sizeof(WCHAR));
}

VOID
DetailsView::DataObject::Renderer::Stream::Write(
    LPCSTR pszTextA
    )
{
    Write((LPBYTE)pszTextA, lstrlenA(pszTextA) * sizeof(CHAR));
}


VOID
DetailsView::DataObject::Renderer::Stream::Write(
    BYTE bData
    )
{
    Write((LPBYTE)&bData, sizeof(bData));
}

VOID
DetailsView::DataObject::Renderer::Stream::Write(
    WCHAR chDataW
    )
{
    Write((LPBYTE)&chDataW, sizeof(chDataW));
}


VOID
DetailsView::DataObject::Renderer::Stream::Write(
    CHAR chDataA
    )
{
    Write((LPBYTE)&chDataA, sizeof(chDataA));
}


VOID
DetailsView::DataObject::Renderer::Stream::Write(
    DWORD dwData
    )
{
    Write((LPBYTE)&dwData, sizeof(dwData));
}


VOID
DetailsView::DataObject::Renderer::Stream::Write(
    double dblData
    )
{
    Write((LPBYTE)&dblData, sizeof(dblData));
}


///////////////////////////////////////////////////////////////////////////////
//
// The following section of code contains the different implementations of
// the virtual rendering functions that make each type of rendering object
// unique.  Since they're pretty self-explanatory, I haven't commented each
// function.  It should be obvious as to what they do.
// I have separated each rendering-type section with a banner comment for
// readability.  [brianau]
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// CF_UNICODETEXT
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::Renderer_UNICODETEXT::AddTitle(
    LPCTSTR pszTitle
    )
{
    m_Stm.Write(pszTitle);
    m_Stm.Write(L'\r');
    m_Stm.Write(L'\n');
    m_Stm.Write(L'\r');
    m_Stm.Write(L'\n');
}


VOID
DetailsView::DataObject::Renderer_UNICODETEXT::AddRowColData(
    INT iRow,
    INT idCol
    )
{
    WCHAR szText[MAX_PATH];
    LV_REPORT_ITEM item;
    
    szText[0]       = 0;
    item.fType      = LVRI_TEXT;  // Want text data.
    item.pszText    = szText;
    item.cchMaxText = ARRAYSIZE(szText);

    m_DV.GetReportItem(iRow, idCol, &item);
    m_Stm.Write(szText);
}


///////////////////////////////////////////////////////////////////////////////
// CF_TEXT
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::Renderer_TEXT::AddTitle(
    LPCWSTR pszTitleW
    )
{
    array_autoptr<CHAR> ptrTitleA(DataObject::WideToAnsi(pszTitleW));
    m_Stm.Write(ptrTitleA);
    m_Stm.Write('\r');
    m_Stm.Write('\n');
    m_Stm.Write('\r');
    m_Stm.Write('\n');
}


VOID
DetailsView::DataObject::Renderer_TEXT::AddHeader(
    LPCWSTR pszHeaderW
    )
{
    array_autoptr<CHAR> ptrHeaderA(DataObject::WideToAnsi(pszHeaderW));
    m_Stm.Write(ptrHeaderA);
}


VOID
DetailsView::DataObject::Renderer_TEXT::AddRowColData(
    INT iRow,
    INT idCol
    )
{
    WCHAR szTextW[MAX_PATH];
    LV_REPORT_ITEM item;

    szTextW[0]      = 0;
    item.fType      = LVRI_TEXT;  // Want text data.
    item.pszText    = szTextW;
    item.cchMaxText = ARRAYSIZE(szTextW);

    m_DV.GetReportItem(iRow, idCol, &item);

    array_autoptr<CHAR> ptrTextA(DataObject::WideToAnsi(szTextW));
    m_Stm.Write(ptrTextA);
}


///////////////////////////////////////////////////////////////////////////////
// RTF (Rich Text)
///////////////////////////////////////////////////////////////////////////////
static const INT TWIPS_PER_PT    = 20;
static const INT PTS_PER_INCH    = 72;
static const INT TWIPS_PER_INCH  = PTS_PER_INCH * TWIPS_PER_PT;
static const INT COL_WIDTH_TWIPS = TWIPS_PER_INCH * 5 / 4;       // 1 1/4 inches.

//
// Converts all single backslashes to double backslashes.
// Literal backslashes in RTF must be "\\".
// Caller must delete[] the returned buffer.
//
LPSTR
DetailsView::DataObject::Renderer_RTF::DoubleBackslashes(
    LPSTR pszSrc
    )
{
    DBGASSERT((NULL != pszSrc));

    //
    // Create new string for output.  Size must be double.  Every char
    // could be '\'.
    //
    LPSTR pszFormatted = new CHAR[(lstrlenA(pszSrc) * 2) + 1];
    LPSTR pszDest      = pszFormatted;

    while('\0' != *pszSrc)
    {
        if ('\\' == *pszSrc)
            *pszDest++ = *pszSrc;
        *pszDest++ = *pszSrc++;
    }

    *pszDest = *pszSrc; // Pick up NUL terminator.
    return pszFormatted;
}


VOID
DetailsView::DataObject::Renderer_RTF::Begin(
    INT cRows,
    INT cCols
    )
{
    m_cCols = cCols;
    m_Stm.Write("{\\rtf1 \\sect\\sectd\\lndscpsxn \\par\\pard\\plain ");
}



VOID
DetailsView::DataObject::Renderer_RTF::AddTitle(
    LPCWSTR pszTitleW
    )
{
    array_autoptr<CHAR> ptrTempA(DataObject::WideToAnsi(pszTitleW));
    array_autoptr<CHAR> ptrTitleA(DoubleBackslashes(ptrTempA));      // cvt '\' to "\\"
    m_Stm.Write(ptrTitleA);
}



VOID DetailsView::DataObject::Renderer_RTF::BeginHeaders(
    VOID
    )
{
    m_Stm.Write(" \\par \\par ");   // Hdr preceded by empty row.
    BeginHeaderOrRow();             // Add stuff common to hdr and data rows.
    m_Stm.Write(" \\trhdr ");       // Hdr at top of each page.
    AddCellDefs();                  // Cell size definitions.
}



VOID DetailsView::DataObject::Renderer_RTF::AddCellDefs(
    VOID
    )
{
    char szText[80];
    INT cxTwips = 0;

    for (INT i = 0; i < m_cCols; i++)
    {
        cxTwips += COL_WIDTH_TWIPS;
        wnsprintfA(szText, ARRAYSIZE(szText), "\\cellx%d", cxTwips);
        m_Stm.Write(szText);
    }
    m_Stm.Write(' ');
}


//
// Stuff common to both header row and data rows.
//
VOID DetailsView::DataObject::Renderer_RTF::BeginHeaderOrRow(
    VOID
    )
{
    m_Stm.Write("\\trowd \\pard \\intbl ");
}



VOID
DetailsView::DataObject::Renderer_RTF::AddHeader(
    LPCWSTR pszHeaderW
    )
{
    array_autoptr<CHAR> ptrHeaderA(DataObject::WideToAnsi(pszHeaderW));
    //
    // No need to convert '\' to "\\".  No
    // backslashes in our header text.
    //
    m_Stm.Write(ptrHeaderA);
}


VOID
DetailsView::DataObject::Renderer_RTF::AddRowColData(
    INT iRow,
    INT idCol
    )
{
    WCHAR szTextW[MAX_PATH];
    LV_REPORT_ITEM item;

    szTextW[0]      = 0;
    item.fType      = LVRI_TEXT;  // Want text data.
    item.pszText    = szTextW;
    item.cchMaxText = ARRAYSIZE(szTextW);

    m_DV.GetReportItem(iRow, idCol, &item);

    array_autoptr<CHAR> ptrTempA(DataObject::WideToAnsi(szTextW));
    array_autoptr<CHAR> ptrTextA(DoubleBackslashes(ptrTempA));      // cvt '\' to "\\"
    m_Stm.Write(ptrTextA);
}


///////////////////////////////////////////////////////////////////////////////
// Private import/export format
///////////////////////////////////////////////////////////////////////////////
//
// Assumes that caller AddRef'd IStream pointer.
//
VOID
DetailsView::DataObject::Renderer_Export::Render(
    IStream *pStm
    )
{
    HRESULT hResult = NO_ERROR;
    INT cRows = m_DV.GetReportRowCount();
    INT iRow = -1;

    DBGASSERT((NULL != pStm));
    m_Stm.SetStream(pStm);

    Begin(cRows, 0);

    //
    // Add the export data records.
    //
    for (INT i = 0; i < cRows; i++)
    {
        iRow = m_DV.GetNextSelectedItemIndex(iRow);
        DBGASSERT((-1 != iRow));
        AddBinaryRecord(iRow);
    }

    //
    // Terminate the report.
    //
    End();
}

VOID
DetailsView::DataObject::Renderer_Export::Begin(
    INT cRows,
    INT cCols
    )
{
    //
    // The stream header contains a GUID as a unique identifier followed
    // by a version number.
    //
    m_Stm.Write((LPBYTE)&GUID_NtDiskQuotaStream, sizeof(GUID_NtDiskQuotaStream));
    m_Stm.Write(DataObject::EXPORT_STREAM_VERSION);
    m_Stm.Write((DWORD)cRows);
}


VOID
DetailsView::DataObject::Renderer_Export::AddBinaryRecord(
    INT iRow
    )
{
    INT cbRecord    = m_DV.GetReportBinaryRecordSize(iRow);
    array_autoptr<BYTE> ptrRecord(new BYTE[cbRecord]);
    if (NULL != ptrRecord.get())
    {
        if (m_DV.GetReportBinaryRecord(iRow, ptrRecord, cbRecord))
        {
            m_Stm.Write(ptrRecord, cbRecord);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// CF "FileGroupDescriptor"
//
//
///////////////////////////////////////////////////////////////////////////////

VOID
DetailsView::DataObject::Renderer_FileGroupDescriptor::Begin(
    INT cRows,
    INT cCols
    )
{
    //
    // Build a name for the file we'll create.
    //
    // Vol label?  Filename
    // ----------  -------------------------------------------------------
    //  Yes        "Disk Quota Settings for Volume 'VOL_LABEL'"
    //  No         "Disk Quota Settings for Unlabeled Volume SN 8AB1-DE23"
    //
    // The serial-number format is gross but without a label, we don't have
    // any other distinguishing feature for the volume.  I'd use the
    // display name from the CVolumeID object but in the mounted volume
    // case, it contains backslashes and a colon; both invalid buried in
    // a filename.
    //
    TCHAR szLabel[MAX_VOL_LABEL] = { TEXT('\0') };
    DWORD dwSerialNumber = 0;
    GetVolumeInformation(m_DV.GetVolumeID().ForParsing(),
                         szLabel,
                         ARRAYSIZE(szLabel),
                         &dwSerialNumber,
                         NULL,
                         NULL,
                         NULL,
                         0);

    CString strFileName;
    if (TEXT('\0') != szLabel[0])
    {
        //
        // Volume has a label.
        //
        strFileName.Format(g_hInstDll,
                           IDS_EXPORT_STREAM_FILENAME_TEMPLATE,
                           szLabel);
    }
    else
    {
        //
        // No volume label.
        //
        strFileName.Format(g_hInstDll,
                           IDS_EXPORT_STREAM_FILENAME_TEMPLATE_VOLSN,
                           HIWORD(dwSerialNumber),
                           LOWORD(dwSerialNumber));
    }

    //
    // Create a file group descriptor containing the name we want the
    // shell to use for the file.  The descriptor contains one file
    // description.  That description just contains the file name.
    // All other members are initialized to 0.
    //
    FILEGROUPDESCRIPTORW desc;

    ZeroMemory(&desc, sizeof(desc));
    desc.cItems = 1;
    lstrcpyn(desc.fgd[0].cFileName, strFileName, ARRAYSIZE(desc.fgd[0].cFileName));

    //
    // Write the file group descriptor to the renderer's stream.
    //
    m_Stm.Write((LPBYTE)&desc, sizeof(desc));
}





///////////////////////////////////////////////////////////////////////////////
/*  Function: LVSelection::Add

    Description: Add a user pointer and listview item index to a listview
        selection object.  This object is used to transfer the notion of a
        "selection" to some function.

    Arguments:
        pUser - Address of IDiskQuotaUser interface for a selected user object.

        iItem - Index of selected item in the listview.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
LVSelection::Add(
    PDISKQUOTA_USER pUser,
    INT iItem
    )
{
    DBGASSERT((NULL != pUser));

    ListEntry entry;
    entry.pUser = pUser;
    entry.iItem = iItem;

    m_List.Append((LPVOID)&entry);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: LVSelection::Retrieve

    Description: Retrieves a user pointer and listview item index from a
        listview selection object.

    Arguments:
        i - Index of item.  Use the Count() method to determine how many
            items are in the selection object.

        ppUser - Address of an interface pointer variable to receive the
            IDiskQuotaUser interface for the user object at index 'i'.

        piItem - Address of integer variable to receive the Listview item index
            of the object at index 'i'.

    Returns: TRUE  = Returned information is valid.
             FALSE = Couldn't retrieve entry 'i'.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
LVSelection::Retrieve(
    INT i,
    PDISKQUOTA_USER *ppUser,
    INT *piItem
    )
{
    ListEntry entry;
    if (m_List.Retrieve((LPVOID)&entry, i))
    {
        if (NULL != ppUser)
            *ppUser = entry.pUser;
        if (NULL != piItem)
            *piItem = entry.iItem;
        return TRUE;
    }
    return FALSE;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: ColumnMap::ColumnMap
    Function: ColumnMap::~ColumnMap

    Description: Constructor and Destructor.
        Creates/Destroys a column map.  The column map is used
        to map column ID's (known to the Details View) to listview subitem
        indices.  It is needed to support the addition and deletion of the
        folder name column.

    Arguments:
        cMapSize - Number of entries in the map.  Should be the max number
            of columns possible in the listview.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ColumnMap::ColumnMap(
    UINT cMapSize
    ) : m_pMap(NULL),
        m_cMapSize(cMapSize)
{
    //
    // Can throw OutOfMemory.
    //
    m_pMap     = new INT[m_cMapSize];
    FillMemory(m_pMap, m_cMapSize * sizeof(m_pMap[0]), (BYTE)-1);
}

ColumnMap::~ColumnMap(
    VOID
    )
{
    if (NULL != m_pMap)
        delete[] m_pMap;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ColumnMap::SubItemToId

    Description: Returns a column ID given a listview subitem index.

    Arguments:
        iSubItem - 0-based subitem index of the item to be mapped.

    Returns: Column ID corresponding to subitem.  -1 if the subitem is invalid.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
ColumnMap::SubItemToId(
    INT iSubItem
    ) const
{
    DBGASSERT((iSubItem >= 0 && iSubItem < (INT)m_cMapSize));
    return *(m_pMap + iSubItem);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ColumnMap::IdToSubItem

    Description: Returns a listview subitem index given a column ID.

    Arguments:
        iColId - ID of column. i.e. idCol_Name, idCol_Folder etc.

    Returns: Listview subitem index.  -1 if the column is not currently
        visible.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
ColumnMap::IdToSubItem(
    INT iColId
    ) const
{
    for (INT i = 0; i < (INT)m_cMapSize; i++)
    {
        if (SubItemToId(i) == iColId)
            return i;
    }
    return -1;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ColumnMap::RemoveId

    Description: Removes a mapping for a given listview subitem index.

    Arguments:
        iSubItem - 0-based subitem index of the item to be removed.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/09/96    Initial creation.                                    BrianAu
    11/30/96    Fixed off-by-one error.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ColumnMap::RemoveId(
    INT iSubItem
    )
{
    DBGASSERT((iSubItem >= 0 && iSubItem < (INT)m_cMapSize));
    for (INT i = iSubItem; i < (INT)m_cMapSize - 1; i++)
        *(m_pMap + i) = *(m_pMap + i + 1);
    *(m_pMap + m_cMapSize - 1) = -1;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: ColumnMap::InsertId

    Description: Adds a mapping for a given listview subitem index.
        The mapping is added at the iSubItem location in the map.  All subsequent
        item mappings are shifted down one place.  This is analogous to
        inserting a column into the listview.

    Arguments:
        iSubItem - 0-based subitem index of the item to be removed.

        iColId - ID of column. i.e. idCol_Name, idCol_Folder etc.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/09/96    Initial creation.                                    BrianAu
    11/30/96    Fixed off-by-one error.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ColumnMap::InsertId(
    INT iSubItem,
    INT iColId
    )
{
    DBGASSERT((iSubItem >= 0 && iSubItem < (INT)m_cMapSize));
    for (INT i = m_cMapSize-1; i > iSubItem; i--)
        *(m_pMap + i) = *(m_pMap + i - 1);
    *(m_pMap + iSubItem) = iColId;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::Finder

    Description: Constructs a user finder object.
        The user finder coordinates the activities of finding an item in
        the details listview.

    Arguments:
        DetailsView - Reference to the details view object.

        cMaxMru - Maximum entries allowed in the most-recently-used list.
            This list is maintained in the dropdown combo box in the
            view's toolbar.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::Finder::Finder(
    DetailsView& DetailsView,
    INT cMaxMru
    ) : m_DetailsView(DetailsView),
        m_hwndToolbarCombo(NULL),
        m_cMaxComboEntries(cMaxMru),
        m_pfnOldToolbarComboWndProc(NULL)
{
    //
    // Nothing more to do.
    //
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::ConnectToolbarCombo

    Description: Connects the finder object to the combo box in the view's
        toolbar.  This is necessary because the finder object coordinates
        the contents of the toolbar combo box with the contents of the
        combo box in the "Find User" dialog.  When you enter a name in
        one of the boxes, it is automatically added to the other so they
        appear to be in sync.

        Also subclasses the edit control within the combo box.  This is
        required so that we can intercept VK_RETURN and find the record
        when the user presses [Return].

        Also adds the toolbar combo box as a "tool" to the toolbar.  This
        is so we can get a tooltip for the combo.

    Arguments:
        hwndToolbarCombo - Hwnd of combo box in view's toolbar.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::Finder::ConnectToolbarCombo(
    HWND hwndToolbarCombo
    )
{
    m_hwndToolbarCombo = hwndToolbarCombo;

    //
    // Add the combo box to the toolbar's list of "tools".
    // This will allow us to get a tooltip for the combo box.
    // This code assumes that the combo is a child of the toolbar.
    //
    HWND hwndToolbar = GetParent(hwndToolbarCombo);
    HWND hwndMain    = GetParent(hwndToolbar);
    HWND hwndTooltip = (HWND)SendMessage(hwndToolbar,
                                         TB_GETTOOLTIPS,
                                         0, 0);
    if (NULL != hwndTooltip)
    {
        TOOLINFO ti;

        ti.cbSize   = sizeof(ti);
        ti.uFlags   = TTF_IDISHWND | TTF_CENTERTIP | TTF_SUBCLASS;
        ti.lpszText = (LPTSTR)IDS_TOOLBAR_COMBO;
        ti.hwnd     = hwndMain;
        ti.uId      = (UINT_PTR)hwndToolbarCombo;
        ti.hinst    = g_hInstDll;

        SendMessage(hwndTooltip, TTM_ADDTOOL, 0, (LPARAM)&ti);
    }

    //
    // Subclass the combo box so we can intercept VK_ENTER.
    // This is done so we can respond to VK_ENTER.  Normally combo boxes
    // don't respond to this keystroke.
    //
    HWND hwndComboEdit = NULL;

    //
    // The combo box has two children... an edit control and a listbox control.
    // Find the edit control.
    //
    for (HWND hwndChild =  GetTopWindow(m_hwndToolbarCombo);
         hwndChild      != NULL;
         hwndChild      =  GetNextWindow(hwndChild, GW_HWNDNEXT))
    {
        TCHAR szClassName[20] = { TEXT('\0') };
        GetClassName(hwndChild, szClassName, ARRAYSIZE(szClassName));

        if (0 == lstrcmpi(szClassName, TEXT("Edit")))
        {
            hwndComboEdit = hwndChild;
            break;
        }
    }

    if (NULL != hwndComboEdit)
    {
        //
        // Store the address of the Finder object in the combo box's
        // userdata.  This is so the subclass WndProc (a static function)
        // can access the finder object.
        //
        SetWindowLongPtr(hwndComboEdit, GWLP_USERDATA, (INT_PTR)this);

        //
        // Subclass the combo box's edit control.
        //
        m_pfnOldToolbarComboWndProc = (WNDPROC)GetWindowLongPtr(hwndComboEdit,
                                                                GWLP_WNDPROC);
        SetWindowLongPtr(hwndComboEdit,
                        GWLP_WNDPROC,
                        (INT_PTR)DetailsView::Finder::ToolbarComboSubClassWndProc);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::InvokeFindDialog

    Description: Display the "Find User" dialog.

    Arguments:
        hwndParent - Parent for the dialog.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::Finder::InvokeFindDialog(
    HWND hwndParent
    )
{
    DialogBoxParam(g_hInstDll,
                   MAKEINTRESOURCE(IDD_FINDUSER),
                   hwndParent,
                   DetailsView::Finder::DlgProc,
                   (LPARAM)this);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::DlgProc

    Description: DlgProc for the "Find User" dialog.

    Arguments:
        Standard DlgProc arguments.

    Returns:
        Standard DlgProc return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK
DetailsView::Finder::DlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Get the finder object's "this" ptr from the window's userdata.
    //
    Finder *pThis = (Finder *)GetWindowLongPtr(hwnd, DWLP_USER);
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            //
            // Save the "this" ptr in the window's userdata.
            //
            pThis = (Finder *)lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (INT_PTR)pThis);

            //
            // Set the height of the combo in the dialog.
            // Not sure why, but DevStudio's dialog editor won't let me
            // do this.   Use the same height value we use for the combo
            // in the toolbar.  It's the same contents so the height
            // should be the same.
            //
            HWND hwndCombo = GetDlgItem(hwnd, IDC_CMB_FINDUSER);
            RECT rcCombo;

            GetClientRect(hwndCombo, &rcCombo);
            SetWindowPos(hwndCombo,
                         NULL,
                         0, 0,
                         rcCombo.right - rcCombo.left,
                         CY_TOOLBAR_COMBO,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);

            //
            // Fill the dialog's combo with entries from the toolbar
            // combo.  The toolbar's combo box contains the MRU for finding users.
            //
            pThis->FillDialogCombo(pThis->m_hwndToolbarCombo, GetDlgItem(hwnd, IDC_CMB_FINDUSER));

            return 1;
        }

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    //
                    // User pressed OK button or [Enter].
                    //
                    DBGASSERT((NULL != pThis));
                    if (!pThis->UserNameEntered(GetDlgItem(hwnd, IDC_CMB_FINDUSER)))
                    {
                        //
                        // Record not found so don't close dialog.
                        // UserNameEntered() will display UI to tell the user
                        // that the name wasn't found.  Leave the dialog open
                        // so user can retry with a new name.
                        //
                        break;
                    }

                    //
                    // Fall through...
                    //
                case IDCANCEL:
                    //
                    // User pressed Cancel button or [ESC].
                    //
                    EndDialog(hwnd, 0);
                    break;

                default:
                    break;
            }
            break;
    };
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::FillDialogCombo

    Description: Fill the combo box in the dialog with the contents
        from a second combo box.

    Arguments:
        hwndComboSrc - Hwnd of source combo containing text strings.

        hwndComboDest - Hwnd of combo where strings will be copied to.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::Finder::FillDialogCombo(
    HWND hwndComboSrc,
    HWND hwndComboDest
    )
{
    //
    // Clear out the destination combo.
    //
    SendMessage(hwndComboDest, CB_RESETCONTENT, 0, 0);

    //
    // Copy all contents of the source combo to the destination combo.
    //
    INT cItems = (INT)SendMessage(hwndComboSrc, CB_GETCOUNT, 0, 0);
    if (CB_ERR != cItems)
    {
        for (INT i = 0; i < cItems; i++)
        {
            LPTSTR pszName = NULL;
            INT cchName = (INT)SendMessage(hwndComboSrc, CB_GETLBTEXTLEN, i, 0);
            pszName = new TCHAR[cchName + 1];

            if (NULL != pszName)
            {
                //
                // Remove item from the source combo at index [i] and append
                // it to the destination combo.
                //
                SendMessage(hwndComboSrc,  CB_GETLBTEXT, i, (LPARAM)pszName);
                SendMessage(hwndComboDest, CB_ADDSTRING, 0, (LPARAM)pszName);
                delete[] pszName;
            }
        }
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::ToolbarComboSubclassWndProc

    Description: Subclass window procedure for the "Edit" control that is part
        of the combo contained in the view's toolbar.  We subclass this control
        so that we can intercept VK_RETURN and handle it.  The standard combo
        box just beeps when you press [Enter] in it's edit control.

    Arguments:
        Standard WndProc arguments.

    Returns:
        Standard WndProc return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK
DetailsView::Finder::ToolbarComboSubClassWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Get finder object's "this" ptr from window's userdata.
    //
    Finder *pThis = (Finder *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(uMsg)
    {
        case WM_CHAR:
            switch(wParam)
            {
                case VK_RETURN:
                {
                    //
                    // Tell the finder that a user name was entered in the
                    // combo box.  Pass the hwnd of the combo from which the
                    // name was entered.  Since this message is for the
                    // subclassed edit control (child of the combo), the
                    // parent is the combo box itself.
                    //
                    DBGASSERT((NULL != pThis));
                    HWND hwndCombo = GetParent(hwnd);
                    if (pThis->UserNameEntered(hwndCombo))
                    {
                        //
                        // Record found in view.
                        // Set focus to the main view.
                        // If not found, focus should just stay with the combo
                        // so user can enter another name.
                        //
                        HWND hwndToolbar = GetParent(hwndCombo);
                        SetFocus(GetParent(hwndToolbar));
                    }
                    else
                    {
                        //
                        // Not found in listview.  Focus remains in the combo box
                        // so user can try again with a new name.
                        //
                        SetFocus(hwndCombo);
                    }

                    //
                    // Swallow up the VK_RETURN.
                    // Otherwise, the combo box control beeps.
                    //
                    return 0;
                }

                case VK_ESCAPE:
                {
                    //
                    // Set focus to the main window which will set focus to the
                    // listview.  This gives the keyboard-only user a way to
                    // get back out of the combo box.
                    //
                    HWND hwndCombo = GetParent(hwnd);
                    HWND hwndToolbar = GetParent(hwndCombo);
                    SetFocus(GetParent(hwndToolbar));
                    //
                    // Swallow VK_ESCAPE so combo box doesn't beep.
                    //
                    return 0;
                }
            }
            break;

        default:
            break;
    }
    return CallWindowProc(pThis->m_pfnOldToolbarComboWndProc,
                          hwnd, uMsg, wParam, lParam);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::AddNameToCombo

    Description: Add a name string to one of the Find User combo boxes.
        If the item already exists in the list, it is moved to the top of the
        list.  If the item is not in the list, it is added at the top of the list.
        If the addition of the new item causes the list's entry count to exceed
        a specified maximum value, the last item in the list is removed.

    Arguments:
        hwndCombo - Hwnd for the combo box to which the name is added.

        pszName - Address of name string to add.

        cMaxEntries - Maximum number of entries allowed in combo box.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::Finder::AddNameToCombo(
    HWND hwndCombo,
    LPCTSTR pszName,
    INT cMaxEntries
    )
{
    if (NULL != pszName && TEXT('\0') != *pszName)
    {
        //
        // See if the item already exists in the list.
        //
        INT iItemToDelete = (INT)SendMessage(hwndCombo,
                                             CB_FINDSTRING,
                                             (WPARAM)-1,
                                             (LPARAM)pszName);

        if (CB_ERR == iItemToDelete)
        {
            //
            // Item is not already in the list.  Need to add it.
            // If the list is full, we'll have to drop one off of the end.
            //
            INT cItems = (INT)SendMessage(hwndCombo, CB_GETCOUNT, 0, 0);

            if (CB_ERR != cItems && 0 < cItems && cItems >= cMaxEntries)
            {
                iItemToDelete = cItems - 1;
            }
        }
        if (-1 != iItemToDelete)
        {
            //
            // Need to delete an existing item for one of these reasons:
            //
            //  1. Promoting an existing item to the head of the list.
            //     Delete it from it's previous location.
            //  2. Dropping last item from list.
            //
            SendMessage(hwndCombo, CB_DELETESTRING, iItemToDelete, 0);
        }
        //
        // Add the new item at the head of the list.
        //
        SendMessage(hwndCombo, CB_INSERTSTRING, 0, (LPARAM)pszName);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::UserNameEntered

    Description: A name has been entered from one of the combo boxes.
        1. Retrieve the name from the combo.
        2. See if it's in the listview and if it is, the listview ensures the
           item is visible and selects it.
        3. Update the toobar combo's list with the new item.  This is our MRU
           list.

        Add a name string to one of the Find User combo boxes.
        If the item already exists in the list, it is moved to the top of the
        list.  If the item is not in the list, it is added at the top of the list.
        If the addition of the new item causes the list's entry count to exceed
        a specified maximum value, the last item in the list is removed.

    Arguments:
        hwndCombo - Hwnd for the combo box to which the name is added.

        pszName - Address of name string to add.

        cMaxEntries - Maximum number of entries allowed in combo box.

    Returns:
        TRUE  = User was found in listview.
        FALSE = User was not found in listview.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::Finder::UserNameEntered(
    HWND hwndCombo
    )
{
    TCHAR szName[MAX_PATH]    = { TEXT('\0') };
    BOOL bUserFoundInListView = FALSE;

    //
    // Get the name from the combo edit control.
    //
    if (0 < SendMessage(hwndCombo, WM_GETTEXT, (WPARAM)ARRAYSIZE(szName), (LPARAM)szName))
    {
        //
        // Tell the details view object to highlight this name.
        //
        bUserFoundInListView = m_DetailsView.GotoUserName(szName);

        if (bUserFoundInListView)
        {
            //
            // Add the name to the toolbar combo's listbox.  This becomes
            // our MRU list.  Also make sure the visible name in the combo's
            // edit control is the one last entered.  May have been entered
            // through the "Find User" dialog.
            //
            AddNameToCombo(m_hwndToolbarCombo, szName, m_cMaxComboEntries);
            SendMessage(m_hwndToolbarCombo, WM_SETTEXT, 0, (LPARAM)szName);
        }
        else
        {
            //
            // Display a message box to the user stating that the user couldn't
            // be found in the listview.
            //
            CString strMsg(g_hInstDll, IDS_USER_NOT_FOUND_IN_LISTVIEW, szName);

            DiskQuotaMsgBox(hwndCombo,
                            (LPCTSTR)strMsg,
                            IDS_TITLE_DISK_QUOTA,
                            MB_ICONEXCLAMATION);
        }
    }
    return bUserFoundInListView;
}



DetailsView::Importer::Importer(
    DetailsView& DV
    ) : m_DV(DV),
        m_bUserCancelled(FALSE),
        m_bPromptOnReplace(TRUE),
        m_dlgProgress(IDD_PROGRESS,
                      IDC_PROGRESS_BAR,
                      IDC_TXT_PROGRESS_DESCRIPTION,
                      IDC_TXT_PROGRESS_FILENAME),
        m_hwndParent(m_DV.m_hwndMain),
        m_cImported(0)
{
    if (m_dlgProgress.Create(g_hInstDll, m_hwndParent))
    {
        EnableWindow(m_hwndParent, FALSE);
        m_dlgProgress.SetDescription(MAKEINTRESOURCE(IDS_PROGRESS_IMPORTING));
        m_dlgProgress.Show();
    }
    //
    // Clear any previous undo actions from the view's undo list.
    //
    m_DV.m_pUndoList->Clear();
}

DetailsView::Importer::~Importer(
    VOID
    )
{
    Destroy();
}


VOID
DetailsView::Importer::Destroy(
    VOID
    )
{
    if (NULL != m_hwndParent && !IsWindowEnabled(m_hwndParent))
    {
        EnableWindow(m_hwndParent, TRUE);
    }

    m_dlgProgress.Destroy();

    //
    // Update the view's "Undo" menu and toolbar button based on the current
    // contents of the undo list.
    //
    m_DV.EnableMenuItem_Undo(0 != m_DV.m_pUndoList->Count());
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [IDataObject *]

    Description: Imports user quota records given an IDataObject pointer.
        Called from DetailsView::Drop().

    Arguments:
        pIDataObject - Pointer to IDataObject interface of object containing
            import data.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    IDataObject *pIDataObject
    )
{
    HRESULT hResult = NO_ERROR;
    FORMATETC fmt;
    CStgMedium medium;

    //
    // Array to specify the clipboard formats and media types that
    // we can import from.  Ordered by preference.
    //
    struct
    {
        CLIPFORMAT fmt;
        DWORD tymed;
    } rgFmtMedia[] = {{ DataObject::m_CF_NtDiskQuotaExport, TYMED_ISTREAM},
                      { DataObject::m_CF_NtDiskQuotaExport, TYMED_HGLOBAL},
                      { CF_HDROP,                           TYMED_ISTREAM},
                      { CF_HDROP,                           TYMED_HGLOBAL}};

    DBGASSERT((NULL != pIDataObject));

    hResult = E_FAIL;
    for (INT i = 0; i < ARRAYSIZE(rgFmtMedia); i++)
    {
        //
        // See which of our supported formats/media types the drop
        // source supports.
        //
        DataObject::SetFormatEtc(fmt, rgFmtMedia[i].fmt, rgFmtMedia[i].tymed);

        //
        // NOTE:  I wanted to call QueryGetData to verify a source's support
        //        for a format.  However, it didn't work properly when
        //        pasting an HDROP from the shell.  Calling GetData()
        //        directly results in the proper behavior.
        //
        hResult = pIDataObject->GetData(&fmt, &medium);
        if (SUCCEEDED(hResult))
        {
            break;
        }
    }

    if (SUCCEEDED(hResult))
    {
        //
        // Successfully have dropped data from the source.
        // Import users from it.
        //
        hResult = Import(fmt, medium);
    }
    else
    {
        DBGERROR((TEXT("PasteFromData: Error 0x%08X, Drop source doesn't support our format/media"), hResult));
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [FORMATETC&, STGMEDIUM&]

    Description: Imports one or more users from a storage medium.

    Arguments:
        fmt - Reference to the FORMATETC structure describing the data format.

        medium - Reference to the STGMEDIUM structure describing the medium.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    const FORMATETC& fmt,
    const STGMEDIUM& medium
    )
{
    HRESULT hResult   = E_FAIL;
    IStream *pIStream = NULL;

    if (TYMED_HGLOBAL == medium.tymed)
    {
        //
        // Medium type is an HGLOBAL but our import functions need
        // a stream.
        //
        hResult = CreateStreamOnHGlobal(medium.hGlobal, FALSE, &pIStream);
    }
    else if (TYMED_ISTREAM == medium.tymed)
    {
        pIStream = medium.pstm;
        hResult  = NO_ERROR;
    }
    //
    // OK.  The source can render data in one of our acceptable
    // formats and medium types.  Go ahead and have them render
    // it onto our stream.
    //
    if (NULL != pIStream)
    {
        if (DetailsView::DataObject::m_CF_NtDiskQuotaExport == fmt.cfFormat)
        {
            //
            // Stream contains quota record information directly.
            // Import the records.
            //
            Source src(pIStream);
            Import(src);
        }
        else if (CF_HDROP == fmt.cfFormat)
        {
            //
            // Stream contains names of files that potentially
            // contain quota record information.
            //
            HGLOBAL hDrop;
            hResult = GetHGlobalFromStream(pIStream, &hDrop);
            if (SUCCEEDED(hResult))
            {
                hResult = Import((HDROP)hDrop);
            }
        }
    }
    else
    {
        DBGERROR((TEXT("PasteFromData: GetData failed with error 0x%08X"), hResult));
    }
    return hResult;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [LPCTSTR]

    Description: Imports settings for one or more users from a doc file on
        disk.  The doc file contains the import data directly in the stream.
        After opening and validating the storage and stream, it passes the
        stream to ImportUsersFromStream.

    Arguments:
        pszFilePath - Path to doc file containing import information stream.

        bUserCancelled - Reference to variable that is returned status
            indicating if the user cancelled the import operation.

    Returns:
        NO_ERROR = Success.
        S_FALSE  = Not a doc file.
        STG_E_FILENOTFOUND
        STG_E_OUTOFMEMORY
        STG_E_ACCESSDENIED
        STG_E_INVALIDNAME
        STG_E_TOOMANYOPENFILES

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    LPCTSTR pszFilePath
    )
{
    HRESULT hResult     = NO_ERROR;
    BOOL bStreamFailure = FALSE; // FALSE = Storage failure.

    //
    // Display the filename in the progress dialog.
    //
    m_dlgProgress.SetFileName(pszFilePath);

    //
    // Validate and open the file.
    //
    if (S_OK != StgIsStorageFile(pszFilePath))
    {
        //
        // Not a doc file.  Assume it was created using drag/drop.
        // Map the file into memory and import from that.
        // Contents will be validated during the import process.
        //
        MappedFile file;
        hResult = file.Open(pszFilePath);
        if (SUCCEEDED(hResult))
        {
            //
            // This typecast from __int64 to ULONG is OK. Truncation
            // will not be a problem.  There will be no quota import
            // storages larger than 4GB.
            //
            Source src(file.Base(), (ULONG)file.Size());
            hResult = Import(src);
        }
    }
    else
    {
        IStorage *pStg = NULL;
        //
        // It's a doc file.  Assume it's one created using OnCmdExport().
        // Contents will be validated during the import process.
        //
        hResult = StgOpenStorage(pszFilePath,
                                 NULL,
                                 STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                                 NULL, 0,
                                 &pStg);

        if (SUCCEEDED(hResult))
        {
            //
            // Open the import stream.
            //
            IStream *pIStream;
            hResult = pStg->OpenStream(DetailsView::DataObject::SZ_EXPORT_STREAM_NAME,
                                       NULL,
                                       STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                                       0,
                                       &pIStream);
            if (SUCCEEDED(hResult))
            {

                //
                // Import information contained in the stream.
                //
                Source src(pIStream);
                hResult = Import(src);
                pIStream->Release();
            }
            else
            {
                DBGERROR((TEXT("Import: Error 0x%08X opening stream \"%s\""), hResult, DataObject::SZ_EXPORT_STREAM_NAME));
                //
                // Reporting logic below needs to know if it was a stream or storage
                // failure.
                //
                bStreamFailure = TRUE;
            }
            pStg->Release();
        }
        else
        {
            DBGERROR((TEXT("Import: Error 0x%08X opening storage \"%s\""), hResult, pszFilePath));
        }
    }

    if (FAILED(hResult))
    {
        UINT iMsg = IDS_IMPORT_STREAM_READ_ERROR; // Generic message.

        switch(hResult)
        {
            case STG_E_FILENOTFOUND:
                //
                // Both OpenStream and StgOpenStorage can return
                // STG_E_FILENOTFOUND.  However, they have two completely
                // different meanings from the user's perspective.
                //
                iMsg = bStreamFailure ? IDS_IMPORT_STREAM_INVALID_STREAM :
                                        IDS_IMPORT_STREAM_FILENOTFOUND;
                break;

            case STG_E_ACCESSDENIED:
                iMsg = IDS_IMPORT_STREAM_NOACCESS;
                break;

            case E_OUTOFMEMORY:
            case STG_E_INSUFFICIENTMEMORY:
                iMsg = IDS_IMPORT_STREAM_OUTOFMEMORY;
                break;

            case STG_E_INVALIDNAME:
                iMsg = IDS_IMPORT_STREAM_INVALIDNAME;
                break;

            case STG_E_TOOMANYOPENFILES:
                iMsg = IDS_IMPORT_STREAM_TOOMANYFILES;
                break;

            default:
                break;
        }
        DiskQuotaMsgBox(GetTopmostWindow(),
                        iMsg,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);

    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [HDROP]

    Description: Imports settings from one or more doc files specified
        in a DROPFILES buffer.  This is used when someone drops an export
        file onto the listview.  The doc file names are extracted from
        the HDROP buffer then handed off to ImportUsersFromFile.

    Arguments:
        pIStream - Pointer to IStream containing DROPFILES info.

        bUserCancelled - Reference to variable that is returned status
            indicating if the user cancelled the import operation.


    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    HDROP hDrop
    )
{
    HRESULT hResult = NO_ERROR;
    TCHAR szFile[MAX_PATH];

    DBGASSERT((NULL != hDrop));

    //
    // Get the count of files in the HDROP buffer.
    //
    UINT cFiles = DragQueryFile((HDROP)hDrop, (UINT)-1, NULL, 0);
    if ((UINT)-1 != cFiles)
    {
        //
        // Import users from each file in the HDROP buffer.
        // Bail out if user cancels operation.
        //
        for (INT i = 0; i < (INT)cFiles && !m_bUserCancelled; i++)
        {
            DragQueryFile(hDrop, i, szFile, ARRAYSIZE(szFile));
            hResult = Import(szFile);
        }
    }
    else
    {
        DBGERROR((TEXT("DragQueryFile returned -1")));
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [Source&]

    Description: Imports settings for one or more users from a Source object.
        All import functions eventually get their information into a Source
        object format and call this function.  It then separates out the
        individual user information and calls ImportOneUser() to do the
        actual import.

    Arguments:
        source - Reference to Source containing user import info.

    Returns: Number of users imported.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    Source& source
    )
{
    ULONG cbRead;
    HRESULT hResult = E_FAIL;

    try
    {
        //
        // Read and validate the stream signature.
        // This signature consists of a GUID so that we can validate any
        // stream used for import of quota information.
        //
        GUID guidStreamSignature;
        if (S_OK != source.Read(&guidStreamSignature, sizeof(guidStreamSignature), &cbRead))
            throw CFileException(CFileException::read, TEXT(""), 0);

        if (guidStreamSignature == GUID_NtDiskQuotaStream)
        {
            //
            // Read and validate the stream version.
            // Currently there is only 1 version of stream generated so validation
            // is simple.  If we ever rev the stream format and bump the version
            // to 2, we should still be able to handle version 1 streams.  The
            // only reason to display an error is if we encounter a totally bogus
            // stream version number.
            //
            DWORD nVersion;
            if (S_OK != source.Read(&nVersion, sizeof(nVersion), &cbRead))
                throw CFileException(CFileException::read, TEXT(""), 0);

            if (1 == nVersion)
            {
                INT cRecords;
                //
                // Read the count of records in the stream.
                //
                if (S_OK != source.Read(&cRecords, sizeof(cRecords), &cbRead))
                    throw CFileException(CFileException::read, TEXT(""), 0);

                //
                // Set up the progress bar to represent this stream.
                //
                m_dlgProgress.ProgressBarInit(0, cRecords, 1);

                for (INT i = 0; !m_bUserCancelled && i < cRecords; i++)
                {
                    //
                    // Read each record from the stream.
                    // A record consists of a SID-Length value followed by a SID
                    // then followed by the user's quota amount used, threshold
                    // and limit values.  Abort loop if user cancels the
                    // operation.
                    //
                    DWORD cbSid;
                    LPBYTE pbSid;
                    if (S_OK != source.Read(&cbSid, sizeof(cbSid), &cbRead))
                        throw CFileException(CFileException::read, TEXT(""), 0);

                    pbSid = new BYTE[cbSid];
                    try
                    {
                        if (NULL != pbSid)
                        {
                            PDISKQUOTA_USER pIUser = NULL;
                            LONGLONG llQuotaThreshold;
                            LONGLONG llQuotaLimit;
                            //
                            // Read in the user's SID.
                            //
                            if (S_OK != source.Read(pbSid, cbSid, &cbRead))
                                throw CFileException(CFileException::read, TEXT(""), 0);

                            //
                            // Read in the user's quota amount used.
                            // This isn't used in the import process but it's in
                            // the stream.  Therefore we just dump it into the
                            // threshold buffer.  It will be overwritten.
                            //
                            if (S_OK != source.Read(&llQuotaThreshold, sizeof(llQuotaThreshold), &cbRead))
                                throw CFileException(CFileException::read, TEXT(""), 0);

                            //
                            // Read in the user's quota threshold.
                            //
                            if (S_OK != source.Read(&llQuotaThreshold, sizeof(llQuotaThreshold), &cbRead))
                                throw CFileException(CFileException::read, TEXT(""), 0);

                            //
                            // Read in the user's quota limit.
                            //
                            if (S_OK != source.Read(&llQuotaLimit, sizeof(llQuotaLimit), &cbRead))
                                throw CFileException(CFileException::read, TEXT(""), 0);

                            //
                            // We have one record of data for a user.
                            // Now import it.
                            //
                            hResult = Import(pbSid, llQuotaThreshold, llQuotaLimit);
                            delete[] pbSid;
                        }
                    }
                    catch(CFileException& fe)
                    {
                        DBGERROR((TEXT("Import: File exception caught while reading import data.")));
                        delete[] pbSid;
                        throw;
                    }
                    catch(CAllocException& ae)
                    {
                        DBGERROR((TEXT("Import: Alloc exception caught while reading import data.")));
                        delete[] pbSid;
                        throw;
                    }
                }
            }
            else
            {
                //
                // Invalid stream version.
                // Our code should always be able to handle any version
                // we produce.  This code branch should only handle BOGUS
                // version numbers.  In other words, a message like "Can't
                // understand this version" is not acceptable.
                //
                DBGERROR((TEXT("Import: Invalid stream version (%d)."), nVersion));
                DiskQuotaMsgBox(GetTopmostWindow(),
                                IDS_IMPORT_STREAM_INVALID_STREAM,
                                IDS_TITLE_DISK_QUOTA,
                                MB_ICONERROR | MB_OK);
            }
        }
        else
        {
            //
            // Invalid stream signature.
            //
            DBGERROR((TEXT("Import: Invalid stream signature.")));
            DiskQuotaMsgBox(GetTopmostWindow(),
                            IDS_IMPORT_STREAM_INVALID_STREAM,
                            IDS_TITLE_DISK_QUOTA,
                            MB_ICONERROR | MB_OK);
        }
    }
    catch(CFileException& fe)
    {
        DBGERROR((TEXT("Import: File exception caught while reading import data.")));

        DiskQuotaMsgBox(GetTopmostWindow(),
                        IDS_IMPORT_STREAM_READ_ERROR,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);

        hResult = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [LPBYTE, LONGLONG, LONGLONG]

    Description: Imports a single user into the system given the user's SID
        and quota settings.  This is the single function where all import
        mechanisms end up.  It does the actual importing of the user.

    Arguments:
        pbSid - Address of buffer containing user's SID.

        llQuotaThreshold - User's quota warning threshold setting.

        llQuotaLimit - User's quota limit setting.

    Returns:
        -1 = User pressed "Cancel" in either the "Replace User" dialog or
            in the progress dialog.

         0 = Failed to import user.

         1 = User imported.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    LPBYTE pbSid,
    LONGLONG llQuotaThreshold,
    LONGLONG llQuotaLimit
    )
{
    INT iResult     = 0;
    HRESULT hResult = NO_ERROR;
    PDISKQUOTA_USER pIUser = NULL;
    static BOOL bReplaceExistingUser = FALSE;

    DBGASSERT((NULL != pbSid));

    if (m_bPromptOnReplace)
    {
        //
        // We'll be prompting the user if a record needs replacement.
        // They'll make a choice through the UI.
        // Assume for now that we won't be replacing the record.
        //
        bReplaceExistingUser = FALSE;
    }

    //
    // Add user to volume's quota file.
    //
    hResult = m_DV.m_pQuotaControl->AddUserSid(pbSid,
                                               DISKQUOTA_USERNAME_RESOLVE_SYNC,
                                               &pIUser);
    if (SUCCEEDED(hResult))
    {
        //
        // Either the user was added or already exists.
        //
        BOOL bAddNewUser = (S_FALSE != hResult);

        if (!bAddNewUser)
        {
            //
            // User already exists in the quota file.  Find it's entry
            // in the listview.
            //
            DBGASSERT((NULL != pIUser));
            pIUser->Release();
            INT iItem = m_DV.FindUserBySid(pbSid, &pIUser);

            if (m_bPromptOnReplace)
            {
                TCHAR szLogonName[MAX_USERNAME]   = { TEXT('\0') };
                TCHAR szDisplayName[MAX_USERNAME] = { TEXT('\0') };

                if (-1 != iItem)
                {
                    //
                    // Listview item found.
                    // Get the account's name string so we can ask the user
                    // if they want to replace it's quota settings.
                    //
                    DBGASSERT((NULL != pIUser));
                    pIUser->GetName(NULL, 0,
                                    szLogonName,   ARRAYSIZE(szLogonName),
                                    szDisplayName, ARRAYSIZE(szDisplayName));

                }

                CString strTitle(g_hInstDll, IDS_TITLE_DISK_QUOTA);
                CString strMsg(g_hInstDll,
                               IDS_IMPORT_REPLACE_RECORD,
                               szDisplayName,
                               szLogonName);

                //
                // Ask the user if they want to replace the record's
                // quota settings.
                //
                YesNoToAllDialog ynToAllDlg(IDD_YNTOALL);
                INT_PTR iResponse = ynToAllDlg.CreateAndRun(g_hInstDll,
                                                            GetTopmostWindow(),
                                                            strTitle,
                                                            strMsg);
                //
                // If the "Apply to All" checkbox was selected, we set this flag
                // so that the dialog isn't displayed again until the caller resets
                // m_bPromptOnReplace to TRUE.
                //
                m_bPromptOnReplace = !ynToAllDlg.ApplyToAll();

                switch(iResponse)
                {
                    case IDYES:
                        bReplaceExistingUser = TRUE;
                        break;

                    case IDCANCEL:
                        m_bUserCancelled = TRUE;
                        break;

                    default:
                        break;
                }
            }
        }
        if (bAddNewUser || bReplaceExistingUser)
        {
            DBGASSERT((NULL != pIUser));

            //
            // Write the new quota values because...
            //
            // 1. Added a new user record and setting initial values or...
            // 2. Replacing settings for an existing user.
            //
            if (NULL != pIUser)
            {
                LONGLONG llQuotaThresholdUndo;
                LONGLONG llQuotaLimitUndo;

                if (!bAddNewUser && bReplaceExistingUser)
                {
                    //
                    // Save the current threshold and limit values for "undo".
                    // Only need information for undo if replacing an existing
                    // user's settings.  For performance, only call when we need
                    // the info.
                    //
                    pIUser->GetQuotaThreshold(&llQuotaThresholdUndo);
                    pIUser->GetQuotaLimit(&llQuotaLimitUndo);
                }

                //
                // Set the new threshold and limit values.
                //
                pIUser->SetQuotaThreshold(llQuotaThreshold, TRUE);
                pIUser->SetQuotaLimit(llQuotaLimit, TRUE);

                if (bAddNewUser)
                {
                    //
                    // Add the user to the listview and create an UNDO object for the operation.
                    //
                    m_DV.AddUser(pIUser);
                    pIUser->AddRef();
                    m_DV.m_pQuotaControl->AddRef();

                    autoptr<UndoAdd> ptrUndoAdd = new UndoAdd(pIUser, m_DV.m_pQuotaControl);
                    m_DV.m_pUndoList->Add(ptrUndoAdd);
                    ptrUndoAdd.disown();
                }
                if (!bAddNewUser && bReplaceExistingUser)
                {
                    //
                    // This will update the record to display any changed quota values.
                    // Create an UNDO object for the operation.
                    //
                    m_DV.OnUserNameChanged(pIUser);
                    pIUser->AddRef();

                    autoptr<UndoModify> ptrUndoModify = new UndoModify(pIUser, llQuotaThresholdUndo, llQuotaLimitUndo);
                    m_DV.m_pUndoList->Add(ptrUndoModify);
                    ptrUndoModify.disown();
                }
            }
        }
    }

    if (!m_bUserCancelled)
        m_bUserCancelled = m_dlgProgress.UserCancelled();

    if (SUCCEEDED(hResult))
    {
        m_cImported++;
        m_dlgProgress.ProgressBarAdvance();
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::GetTopmostWindow

    Description: Returns the HWND of the topmost window in the importer UI.
        If the UI's progress dialog is visible, the dialog's HWND is returned.
        Otherwise, the value of m_hwndParent is returned.
        The Importer uses this function to identify what window should be parent
        to any error message boxes.

    Arguments: None.

    Returns: HWND to use for parent of any messages boxes created by the
        Importer.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HWND
DetailsView::Importer::GetTopmostWindow(
    VOID
    )
{
   return m_dlgProgress.m_hWnd ? m_dlgProgress.m_hWnd : m_hwndParent;
}



///////////////////////////////////////////////////////////////////////////////
// The following StreamSource functions implement a layer of abstraction
// between the import function and the source of the import data.  This allows
// me to centralize the actual import processing in a single function
// without consideration of input source.
// There are several Import() overloads but they eventually all call down
// to Import(Source&).  These functions are very simple so I'm not going
// go bother documenting each.  I think it's pretty obvious what they do.
// Do note the use of the virtual constructor technique allowing the user
// to deal only with Source objects and not AnySource, StreamSource or
// MemorySource objects.  This may be unfamiliar to some.
//
// [brianau 7/25/97]
//
///////////////////////////////////////////////////////////////////////////////
//
// Source ---------------------------------------------------------------------
//
DetailsView::Importer::Source::Source(
    IStream *pStm
    ) : m_pTheSource(NULL)
{
    //
    // Create a stream source type object.
    //
    m_pTheSource = new StreamSource(pStm);
}


DetailsView::Importer::Source::Source(
    LPBYTE pb,
    ULONG cbMax
    ) : m_pTheSource(NULL)
{
    //
    // Create a memory source type object.
    //
    m_pTheSource = new MemorySource(pb, cbMax);
}

DetailsView::Importer::Source::~Source(
    VOID
    )
{
    //
    // Note:  Destructors must be virtual for this to work.
    //
    delete m_pTheSource;
}


HRESULT
DetailsView::Importer::Source::Read(
    LPVOID pvOut,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    if (NULL != m_pTheSource)
    {
        //
        // Delegate the read operation to the properly-typed
        // subobject.
        //
        hr = m_pTheSource->Read(pvOut, cb, pcbRead);
    }
    return hr;
}


//
// StreamSource ---------------------------------------------------------------
//
DetailsView::Importer::StreamSource::StreamSource(
    IStream *pStm
    ) : m_pStm(pStm)
{
    //
    // AddRef the stream pointer.
    //
    if (NULL != m_pStm)
        m_pStm->AddRef();
}

DetailsView::Importer::StreamSource::~StreamSource(
    VOID
    )
{
    //
    // Release the stream pointer.
    //
    if (NULL != m_pStm)
        m_pStm->Release();
}

HRESULT
DetailsView::Importer::StreamSource::Read(
    LPVOID pvOut,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = E_FAIL;
    if (NULL != m_pStm)
    {
        //
        // Read data from the stream.
        //
        hr = m_pStm->Read(pvOut, cb, pcbRead);
    }
    return hr;
}


//
// MemorySource ---------------------------------------------------------------
//
DetailsView::Importer::MemorySource::MemorySource(
    LPBYTE pb,
    ULONG cbMax
    ) : m_pb(pb),
        m_cbMax(cbMax)
{

}


HRESULT
DetailsView::Importer::MemorySource::Read(
    LPVOID pvOut,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = E_FAIL;

    if (m_cbMax >= cb)
    {
        //
        // Read data from the memory block.
        //
        CopyMemory(pvOut, m_pb, cb);
        m_pb    += cb;
        m_cbMax -= cb;
        if (NULL != pcbRead)
        {
            *pcbRead = cb;
        }
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\dskquoui.cpp ===
#include "pch.h" // PCH
#pragma hdrstop

#define INITGUIDS
#include "dskquota.h"
#include <gpedit.h>    // Pick up IID_IGPEInformation
#include <shfusion.h>

#include "guidsp.h"    // Private GUIDs.
#include "factory.h"   // Class factory declarations.
#include "registry.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


HINSTANCE     g_hInstDll     = NULL;    // DLL instance handle.
LONG          g_cRefThisDll  = 0;       // DLL reference count.
LONG          g_cLockThisDll = 0;       // DLL lock count.


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllGetClassObject

    Description: Creates instance of DiskQuotaControlClassFactory.

    Arguments:
        rclsid - Reference to class ID that identifies the type of object that the
            class factory will be asked to create.

        riid - Reference to interface ID on the class factory object.

        ppvOut - Destination location for class factory object pointer after 
            instantiation.

    Returns:
        NOERROR                   - Success.
        E_OUTOFMEMORY             - Can't create class factory object.
        E_NOINTERFACE             - Interface not supported.
        E_INVALIDARG              - ppvOut arg is NULL.
        CLASS_E_CLASSNOTAVAILABLE - Class factory not available.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDAPI 
DllGetClassObject(
    REFCLSID rclsid, 
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllGetClassObject")));
    HRESULT hResult = CLASS_E_CLASSNOTAVAILABLE;
    
    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    try
    {
        if (IsEqualIID(rclsid, CLSID_DiskQuotaUI))
        {
            DiskQuotaUIClassFactory *pClassFactory = NULL;

            pClassFactory = new DiskQuotaUIClassFactory;
            hResult = pClassFactory->QueryInterface(riid, ppvOut);
            if (FAILED(hResult))
            {
                delete pClassFactory;
            }
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllCanUnloadNow

    Description: Called by OLE to determine if DLL can be unloaded.

    Arguments: None.

    Returns:
        S_FALSE     - Can't unload.  Ref count or lock count are > 0.
        S_OK        - OK to unload. Ref count and lock count are 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDAPI 
DllCanUnloadNow(
    VOID
    )
{
    DBGPRINT((DM_COM, DL_HIGH, TEXT("DllCanUnloadNow (dskquoui.dll) RefCnt = %d  LockCnt = %d"),
         g_cRefThisDll, g_cLockThisDll));

    return (0 == g_cRefThisDll && 0 == g_cLockThisDll) ? S_OK : S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllRegisterServer

    Description: Create the necessary registry entries for dskquoui.dll
        to operate properly.  This is typically called by REGSVR32.EXE.

    Arguments: None.

    Returns:
        S_OK            - Succeeded.
        SELFREG_E_CLASS - Failed to create one of the registry entries.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DllRegisterServer(
    VOID
    )
{
    HRESULT hResult = CallRegInstall(g_hInstDll, "RegDll");

    if (FAILED(hResult))
    {
        hResult = SELFREG_E_CLASS;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllUnregisterServer

    Description: Remove the necessary registry entries for dskquoui.dll.
        This is typically called by REGSVR32.EXE.

    Arguments: None.

    Returns:
        S_OK            - Succeeded.
        SELFREG_E_CLASS - Failed to remove the CLSID entry.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DllUnregisterServer(
    VOID
    )
{
    HRESULT hResult = CallRegInstall(g_hInstDll, "UnregDll");

    if (FAILED(hResult))
    {
        hResult = SELFREG_E_CLASS;
    }
    return hResult;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: OnProcessAttach

    Description: Handles all tasks associated with a process attaching to 
        the DLL.

        Try to keep processing time to a minimum.

    Arguments:
        hInstDll - The DLL instance handle passed to DllMain.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Something failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
OnProcessAttach(
    HINSTANCE hInstDll
    )
{
    HRESULT hResult = NOERROR;

    //
    // Be specific - you want to use this dll's manifest (in resources at ID 1.)
    //
    SHFusionInitializeFromModuleID(hInstDll, 1);

    //
    // Start IceCAP profiling.
    //
    ICAP_START_ALL;

#if DBG
    DBGMODULE(TEXT("DSKQUOUI"));  // Name of module displayed with messages.
    RegKey key(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
    if (SUCCEEDED(key.Open(KEY_READ)))
    {
        DebugRegParams dp;
        if (SUCCEEDED(key.GetValue(REGSTR_VAL_DEBUGPARAMS, (LPBYTE)&dp, sizeof(dp))))
        {
            DBGPRINTMASK(dp.PrintMask);
            DBGPRINTLEVEL(dp.PrintLevel);
            DBGPRINTVERBOSE(dp.PrintVerbose);
            DBGTRACEMASK(dp.TraceMask);
            DBGTRACELEVEL(dp.TraceLevel);
            DBGTRACEVERBOSE(dp.TraceVerbose);
            DBGTRACEONEXIT(dp.TraceOnExit);
        }
    }
#endif // DBG


    g_hInstDll = hInstDll;
    DisableThreadLibraryCalls(hInstDll);

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: OnProcessDetach

    Description: Handles all tasks associated with a process detaching from 
        the DLL.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Something failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
OnProcessDetach(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    SHFusionUninitialize();

    //
    // Stop IceCAP profiling.
    //
    ICAP_STOP_ALL;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DllMain

    Description: Main entry point for OLE component server.

    Arguments:
        hInstDll - Instance handle of DLL

        fdwReason - Reason DllMain is being called.  Can be at Process attach/
            detach or Thread attach/detach.

        lpdwReserved - Reserved.

    Returns:
        TRUE    - Successful initialization.
        FALSE   - Failed initialization.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/09/96    Moved code associated with process attach and        BrianAu
                detach out to separate functions.
*/
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI 
DllMain(
    HINSTANCE hInstDll, 
    DWORD fdwReason, 
    LPVOID lpvReserved
    )
{
    BOOL bResult = FALSE;

    switch(fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DBGPRINT((DM_COM, DL_HIGH, TEXT("DSKQUOUI - DLL_PROCESS_ATTACH")));
            bResult = SUCCEEDED(OnProcessAttach(hInstDll));
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            bResult = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            DBGPRINT((DM_COM, DL_HIGH, TEXT("DSKQUOUI - DLL_PROCESS_DETACH")));
            bResult = SUCCEEDED(OnProcessDetach());
            break;
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\extinit.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: extinit.cpp

    Description: Implements IShellExtInit for disk quota shell extensions.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "extinit.h"
#include "prshtext.h"
#include "volprop.h"
#include "guidsp.h"

///////////////////////////////////////////////////////////////////////////////
/*  Function: ShellExtInit::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or
        IShellExtInit interface.  Only IID_IUnknown and
        IID_IShellExtInit are recognized.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/25/98    Disabled MMC snapin code.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
ShellExtInit::QueryInterface(
    REFIID riid,
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    try
    {
        if (IID_IUnknown == riid ||
            IID_IShellExtInit == riid)
        {
            *ppvOut = this;
            ((LPUNKNOWN)*ppvOut)->AddRef();
            hResult = NOERROR;
        }
        else if (IID_IShellPropSheetExt == riid)
        {
            //
            // This can throw OutOfMemory.
            //
            hResult = Create_IShellPropSheetExt(riid, ppvOut);
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ShellExtInit::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
ShellExtInit::AddRef(
    VOID
    )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_COM, DL_HIGH, TEXT("ShellExtInit::AddRef, 0x%08X  %d -> %d\n"), this, cRef - 1, cRef ));    
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ShellExtInit::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
ShellExtInit::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_COM, DL_HIGH, TEXT("ShellExtInit::Release, 0x%08X  %d -> %d\n"),
             this, cRef + 1, cRef ));

    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ShellExtInit::Initialize

    Description: Called by the shell to initialize the shell extension.

    Arguments:
        pidlFolder - Pointer to IDL of selected folder.  This NULL for
            property sheet and context menu extensions.

        lpDataObj - Pointer to data object containing list of selected objects.

        hkeyProgID - Registry key for the file object or folder type.

    Returns:
        S_OK    - Success.
        E_FAIL  - Can't initialize extension.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/28/98    Added mounted-volume support.                        BrianAu
                Includes introduction of CVolumeID object.
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
ShellExtInit::Initialize(
    LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT lpDataObj,
    HKEY hkeyProgID)
{
    HRESULT hResult = E_FAIL;
    if (NULL != lpDataObj)
    {
        //
        // First assume it's a normal volume ID (i.e. "C:\").
        // The DataObject will provide CF_HDROP if it is.
        //
        FORMATETC fe = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM medium;
        bool bMountedVol = false;

        hResult = lpDataObj->GetData(&fe, &medium);
        if (FAILED(hResult))
        {
            //
            // Isn't a normal volume name. Maybe it's a mounted volume.
            // Mounted volume names come in on a different clipboard format
            // so we can treat them differently from normal volume
            // names like "C:\".  A mounted volume name will be the path
            // to the folder hosting the mounted volume.
            // For mounted volumes, the DataObject provides CF "MountedVolume".
            //
            fe.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_MOUNTEDVOLUME);
            hResult     = lpDataObj->GetData(&fe, &medium);
            bMountedVol = SUCCEEDED(hResult);
        }

        if (SUCCEEDED(hResult))
        {
            if (1 == DragQueryFile((HDROP)medium.hGlobal, (DWORD)-1, NULL, 0))
            {
                //
                // Retrieve volume ID string passed in from the shell.
                //
                CString strForParsing; // Used for calling Win32 functions.
                CString strForDisplay; // Used for UI display.
                CString strFSPath;     // Used when an FS path is required.
                DragQueryFile((HDROP)medium.hGlobal,
                              0,
                              strForParsing.GetBuffer(MAX_PATH),
                              MAX_PATH);
                strForParsing.ReleaseBuffer();

                if (!bMountedVol)
                {
                    //
                    // If it's a normal volume name like "C:\", just
                    // use that as the display name and FS Path also.
                    //
                    strFSPath = strForDisplay = strForParsing;
                }
                else
                {
                    //
                    // It's a mounted volume so we need to come up with something
                    // better than "\\?\Volume{ <guid> }\" to display.
                    //
                    // The UI spec says the name shall be like this:
                    //
                    //     <label> (<mounted path>)
                    //
                    TCHAR szMountPtGUID[MAX_PATH] = { TEXT('\0') };
                    GetVolumeNameForVolumeMountPoint(strForParsing,
                                                     szMountPtGUID,
                                                     ARRAYSIZE(szMountPtGUID));

                    TCHAR szLabel[MAX_VOL_LABEL]  = { TEXT('\0') };
                    GetVolumeInformation(szMountPtGUID,
                                         szLabel,
                                         ARRAYSIZE(szLabel),
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         0);
                    //
                    // Format display name as:
                    //
                    // "VOL_LABEL (C:\MountDir)" or
                    // "(C:\MountDir)" if no volume label is available.
                    //
                    // First remove any trailing backslash from the original parsing
                    // string.  It was needed for the call to get the volume mount
                    // point but we don't want to display it in the UI.
                    //
                    if (!strForParsing.IsEmpty())
                    {
                        int iLastBS = strForParsing.Last(TEXT('\\'));
                        if (iLastBS == strForParsing.Length() - 1)
                            strForParsing = strForParsing.SubString(0, iLastBS);
                    }
                    strForDisplay.Format(g_hInstDll,
                                         IDS_FMT_MOUNTEDVOL_DISPLAYNAME,
                                         szLabel,
                                         strForParsing.Cstr());
                    //
                    // Remember the "C:\MountDir" form as the "FSPath".
                    //
                    strFSPath = strForParsing;
                    //
                    // From here on out, the mounted volume GUID string
                    // is used for parsing.
                    //
                    strForParsing = szMountPtGUID;
                }

                //
                // Store the parsing and display name strings in our CVolumeID
                // object for convenient packaging.  This way we can pass around
                // one object and the various parts of the UI can use either the
                // parsable or displayable name as they see fit.  Since the
                // CString objects are reference-counted, all the copying doesn't
                // result in duplication of the actual string contents.
                //
                m_idVolume.SetNames(strForParsing, strForDisplay, strFSPath);

                hResult = S_OK;
            }
            ReleaseStgMedium(&medium);
        }
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ShellExtInit::Create_IShellPropSheetExt

    Description: Creates a shell property sheet extension object and returns
        a pointer to it's IShellPropSheetExt interface.

    Arguments:
        riid - Reference to interface IID.

        ppvOut - Address of interface pointer variable to receive interface
            pointer.

    Returns:
        NO_ERROR        - Success.
        E_FAIL          - Extension initialized with something other
                          than the name of a volume or directory.
                          - OR -
                          The volume or directory doesn't support quotas.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/16/96    Initial creation.                                    BrianAu
    10/07/97    Removed "access denied" and "invalid FS Ver" msgs    BrianAu
                from prop sheet page.  Only display page if
                volume supports quotas and quota control object
                can be initialized.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
ShellExtInit::Create_IShellPropSheetExt(
    REFIID riid,
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_FAIL;
    DWORD dwFileSysFlags = 0;
    TCHAR szFileSysName[MAX_PATH];

    if (GetVolumeInformation(m_idVolume.ForParsing(), // Volume id str [in]
                             NULL, 0,           // Don't want volume name
                             NULL,              // Don't want serial no.
                             NULL,              // Don't want max comp length.
                             &dwFileSysFlags,   // File system flags.
                             szFileSysName,
                             ARRAYSIZE(szFileSysName)))
    {
        //
        // Only continue if the volume supports quotas.
        //
        if (0 != (dwFileSysFlags & FILE_VOLUME_QUOTAS))
        {
            DiskQuotaPropSheetExt *pSheetExt = NULL;
            try
            {
                pSheetExt = new VolumePropPage;

                //
                // This can throw OutOfMemory.
                //
                hResult = pSheetExt->Initialize(m_idVolume,
                                                IDD_PROPPAGE_VOLQUOTA,
                                                VolumePropPage::DlgProc);
                if (SUCCEEDED(hResult))
                {
                    hResult = pSheetExt->QueryInterface(riid, ppvOut);
                }
            }
            catch(CAllocException& e)
            {
                hResult = E_OUTOFMEMORY;
            }
            if (FAILED(hResult))
            {
                delete pSheetExt;
                *ppvOut = NULL;
            }
        }
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\extinit.h ===
#ifndef _INC_DSKQUOTA_EXTINIT_H
#define _INC_DSKQUOTA_EXTINIT_H
///////////////////////////////////////////////////////////////////////////////
/*  File: extinit.h

    Description: Contains declarations for disk quota shell extensions.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef _INC_DSKQUOTA_UTILS_H
#   include "utils.h"
#endif

#ifndef _INC_DSKQUOTA_STRCLASS_H
#   include "strclass.h"
#endif

class ShellExtInit : public IShellExtInit
{
    private:
        LONG      m_cRef;
        CVolumeID m_idVolume; // Contains strings for parsing and display.

        HRESULT Create_IShellPropSheetExt(REFIID riid, LPVOID *ppvOut);
        HRESULT Create_ISnapInPropSheetExt(REFIID riid, LPVOID *ppvOut);

    public:
        ShellExtInit(VOID)
            : m_cRef(0) { }

        //
        // IUnknown methods.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IShellExtInit methods.
        //
        STDMETHODIMP
        Initialize(
            LPCITEMIDLIST pidlFolder,
            IDataObject *pDataObj,
            HKEY hkeyProgID);
};



#endif // _INC_DSKQUOTA_EXTINIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\factory.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: factory.cpp

    Description: Contains the member function definitions for class
        DiskQuotaUIClassFactory.  The class factory object generates
        new instances of DiskQuotaControl objects.  The object implements
        IClassFactory.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added shell extension support.                       BrianAu
    02/04/98    Added creation of IComponent.                        BrianAu
    06/25/98    Disabled MMC snapin code.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "factory.h"
#include "extinit.h"
#include "resource.h"
#include "guidsp.h"
//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


extern LONG g_cLockThisDll;  // Supports LockServer().


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUIClassFactory::QueryInterface

    Description: Retrieves a pointer to the IUnknown or IClassFactory 
        interface.  Recoginizes the IID_IUnknown and IID_IClassFactory
        interface IDs.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added IShellPropSheetExt                             BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUIClassFactory::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DiskQuotaUIClassFactory::QueryInterface")));
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;
    if (IID_IUnknown == riid || IID_IClassFactory == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUIClassFactory::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUIClassFactory::AddRef(
   VOID
   )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUIClassFactory::AddRef, 0x%08X  %d -> %d"), this, cRef - 1, cRef ));
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUIClassFactory::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUIClassFactory::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUIClassFactory::Release, 0x%08X  %d -> %d"),
                     this, cRef + 1, cRef));

    if ( 0 == cRef )
    {   
        delete this;
    }
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUIClassFactory::CreateInstance

    Description: Creates a new instance of a DiskQuotaControl object, returning
        a pointer to its IDiskQuotaControl interface.

    Arguments:
        pUnkOuter - Pointer to outer object's IUnknown interface for IUnknown
            delegation in support of aggregation.  Aggregation is not supported
            by IDiskQuotaControl.

        riid - Reference to interface ID being requested.

        ppvOut - Address of interface pointer variable to accept interface
            pointer.

    Returns:
        NO_ERROR              - Success.
        CLASS_E_NOAGGREGATION - Aggregation was requested but is not supported.
        E_OUTOFMEMORY         - Insufficient memory to create new object.
        E_NOINTERFACE         - Requested interface not supported.
        E_INVALIDARG          - ppvOut arg was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added shell extension support.                       BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUIClassFactory::CreateInstance(
    LPUNKNOWN pUnkOuter, 
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DiskQuotaUIClassFactory::CreateInstance")));
    HRESULT hResult = NO_ERROR;

    TCHAR szGUID[MAX_PATH];
    StringFromGUID2(riid, szGUID, ARRAYSIZE(szGUID));
    DBGPRINT((DM_COM, DL_HIGH, TEXT("CreateInstance: %s"), szGUID));

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    try
    {
        if (NULL != pUnkOuter && IID_IUnknown != riid)
        {
            hResult = CLASS_E_NOAGGREGATION;
        }
        else
        {
            ShellExtInit *pExtInit = new ShellExtInit;
            pExtInit->AddRef();
            hResult = pExtInit->QueryInterface(riid, ppvOut);
            pExtInit->Release();
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUIClassFactory::LockServer

    Description: Places/removes a lock on the DLL server.  See OLE 2
        documentation of IClassFactory for details.
        
    Arguments:
        fLock - TRUE = Increment lock count, FALSE = Decrement lock count.

    Returns:
        S_OK    - Success.
        S_FALSE - Lock count is already 0.  Can't be decremented.
        

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUIClassFactory::LockServer(
    BOOL fLock
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DiskQuotaUIClassFactory::LockServer")));
    HRESULT hResult = S_OK;

    if (fLock)
    {
        //
        // Increment the lock count.
        //
        InterlockedIncrement(&g_cLockThisDll);
    }
    else
    {
        //
        // Decrement only if lock count is > 0.
        // Otherwise, it's an error.
        //
        LONG lLock = g_cLockThisDll - 1;
        if (0 <= lLock)
        {
            ASSERT( 0 != g_cLockThisDll );
            InterlockedDecrement(&g_cLockThisDll);
        }
        else
            hResult = S_FALSE;  // Lock count already at 0.
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\factory.h ===
#ifndef _INC_DSKQUOTA_FACTORY_H
#define _INC_DSKQUOTA_FACTORY_H
///////////////////////////////////////////////////////////////////////////////
/*  File: factory.h

    Description: Contains declaration for the class factory object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added shell extension support.                       BrianAu
    02/04/98    Added creation of IComponent.                        BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

class DiskQuotaUIClassFactory : public IClassFactory
{
    public:
        DiskQuotaUIClassFactory(void)
            : m_cRef(0) { }

        //
        // IUnknown methods
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IClassFactory methods
        //
        STDMETHODIMP 
        CreateInstance(
            LPUNKNOWN pUnkOuter, 
            REFIID riid, 
            LPVOID *ppvOut);

        STDMETHODIMP 
        LockServer(
            BOOL fLock);

    private:
        LONG m_cRef;

        //
        // Prevent copying.
        //
        DiskQuotaUIClassFactory(const DiskQuotaUIClassFactory& rhs);
        DiskQuotaUIClassFactory& operator = (const DiskQuotaUIClassFactory& rhs);
};



#endif // _INC_DSKQUOTA_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\dynarray.h ===
#ifndef _INC_DSKQUOTA_DYNARRAY_H
#define _INC_DSKQUOTA_DYNARRAY_H
///////////////////////////////////////////////////////////////////////////////
/*  File: dynarray.h

    Description: Wrapper classes around the DPA_xxxxxxx and DSA_xxxxxx functions 
        provided by the common control's library.  The classes add value by 
        providing multi-threaded protection, iterators and automatic cleanup 
        semantics. 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _WINDOWS_
#   include <windows.h>
#endif
#ifndef _INC_COMMCTRL
#   include <commctrl.h>
#endif
#ifndef _INC_COMCTRLP
#   include <comctrlp.h>
#endif
#ifndef _INC_DSKQUOTA_EXCEPT_H
#   include "except.h"
#endif


///////////////////////////////////////////////////////////////////////////////
// CONTAINER EXCEPTIONS
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// POINTER LIST
///////////////////////////////////////////////////////////////////////////////
class PointerList
{
    private:
        HDPA             m_hdpa;
        CRITICAL_SECTION m_cs;

    public:
        PointerList(INT cItemGrow = 0);

        virtual ~PointerList(void);

        UINT Count(void);

        VOID Insert(LPVOID pvItem, UINT index);
        VOID Insert(LPVOID pvItem)
            { Insert(pvItem, 0); }

        VOID Append(LPVOID pvItem, UINT index)
            { Insert(pvItem, index + 1); }
        VOID Append(LPVOID pvItem);

        BOOL Remove(LPVOID *ppvItem, UINT index);
        BOOL RemoveFirst(LPVOID *ppvItem)
            { return Remove(ppvItem, 0); }
        BOOL RemoveLast(LPVOID *ppvItem);

        BOOL Retrieve(LPVOID *ppvItem, UINT index);
        BOOL RetrieveFirst(LPVOID *ppvItem)
            { return Retrieve(ppvItem, 0); }
        BOOL RetrieveLast(LPVOID *ppvItem);

        BOOL Replace(LPVOID pvItem, UINT index);
        BOOL FindIndex(LPVOID pvItem, INT *pIndex);

        BOOL Sort(PFNDPACOMPARE pfnCompare, LPARAM lParam);
        BOOL Search(LPVOID pvKey,
                    PFNDPACOMPARE pfnCompare, 
                    UINT uOptions = 0, 
                    INT iStart = 0,
                    LPARAM lParam = 0);

        void Lock(void)
            { EnterCriticalSection(&m_cs); }
        void ReleaseLock(void)
            { LeaveCriticalSection(&m_cs); }

        friend class PointerListIterator;
        friend class AutoLock;
};



///////////////////////////////////////////////////////////////////////////////
// POINTER LIST ITERATOR
///////////////////////////////////////////////////////////////////////////////
class PointerListIterator {
    private:
        PointerList *m_pList;    // Pointer to list being iterated.
        INT          m_Index;    // "Current" signed index into list.
             
        HRESULT Advance(LPVOID *ppvOut, BOOL bForward);

    public:
        enum { EndOfList = -1 };

        PointerListIterator(PointerList& List)
            : m_pList(&List), 
              m_Index(0) { }

        PointerListIterator(const PointerListIterator& rhs)
            : m_pList(rhs.m_pList), 
              m_Index(rhs.m_Index) { }

        PointerListIterator& operator = (const PointerListIterator& rhs);

        HRESULT Next(LPVOID *ppvOut)  
            { return Advance(ppvOut, TRUE); }

        HRESULT Prev(LPVOID *ppvOut)  
            { return Advance(ppvOut, FALSE); }

        BOOL AtFirst(void)
            { return m_Index == 0; }

        BOOL AtLast(void)
            { return m_Index >= (INT)m_pList->Count() - 1; }
        
        void GotoFirst(void)
            { m_Index = 0; }

        void GotoLast(void)
            { m_Index = m_pList->Count() - 1; }

        void LockList(void)
            { m_pList->Lock(); }

        void ReleaseListLock(void)
            { m_pList->ReleaseLock(); }
};


///////////////////////////////////////////////////////////////////////////////
// POINTER QUEUE
///////////////////////////////////////////////////////////////////////////////
class PointerQueue : public PointerList
{
    public:
        virtual ~PointerQueue(void) { }

        VOID Add(LPVOID pvItem)
            { PointerList::Append(pvItem); }
        BOOL Remove(LPVOID *ppvItem)
            { return PointerList::RemoveFirst(ppvItem); }
};


///////////////////////////////////////////////////////////////////////////////
// STRUCTURE LIST
//
///////////////////////////////////////////////////////////////////////////////
class StructureList
{
    private:
        HDSA             m_hdsa;
        CRITICAL_SECTION m_cs;

    public:
        StructureList(INT cbItem, INT cItemGrow);

        virtual ~StructureList(void);

        UINT    Count(void);

        VOID Insert(LPVOID pvItem, UINT index);
        VOID Insert(LPVOID pvItem)
            { Insert(pvItem, 0); }

        VOID Append(LPVOID pvItem, UINT index)
            { Insert(pvItem, index + 1); }
        VOID Append(LPVOID pvItem);

        BOOL Remove(LPVOID pvItem, UINT index);
        BOOL RemoveFirst(LPVOID pvItem) 
            { return Remove(pvItem, 0); }
        BOOL RemoveLast(LPVOID pvItem); 

        BOOL Retrieve(LPVOID pvItem, UINT index);
        BOOL RetrieveFirst(LPVOID pvItem) 
            { return Retrieve(pvItem, 0); }
        BOOL RetrieveLast(LPVOID pvItem);

        BOOL Replace(LPVOID pvItem, UINT index);
        VOID Clear(VOID);

        void Lock(void)
            { EnterCriticalSection(&m_cs); }
        void ReleaseLock(void)
            { LeaveCriticalSection(&m_cs); }

        friend class StructureListIterator;
        friend class AutoLock;
};





///////////////////////////////////////////////////////////////////////////////
// STRUCTURE LIST ITERATOR
///////////////////////////////////////////////////////////////////////////////
class StructureListIterator {
    private:
        StructureList *m_pList;    // Pointer to list being iterated.
        INT            m_Index;    // "Current" signed index into list.
             
        HRESULT Advance(LPVOID *ppvOut, BOOL bForward);

    public:
        enum { EndOfList = -1 };

        StructureListIterator(StructureList& List)
            : m_pList(&List), 
              m_Index(0) { }

        StructureListIterator(const StructureListIterator& rhs)
            : m_pList(rhs.m_pList), 
              m_Index(rhs.m_Index) { }

        StructureListIterator& operator = (const StructureListIterator& rhs);

        HRESULT Next(LPVOID *ppvOut)  
            { return Advance(ppvOut, TRUE); }

        HRESULT Prev(LPVOID *ppvOut)  
            { return Advance(ppvOut, FALSE); }

        BOOL AtFirst(void)
            { return m_Index == 0; }

        BOOL AtLast(void)
            { return m_Index >= (INT)m_pList->Count() - 1; }
        
        void GotoFirst(void)
            { m_Index = 0; }

        void GotoLast(void)
            { m_Index = m_pList->Count() - 1; }

        void LockList(void)
            { m_pList->Lock(); }

        void ReleaseListLock(void)
            { m_pList->ReleaseLock(); }
};

///////////////////////////////////////////////////////////////////////////////
// STRUCTURE QUEUE
///////////////////////////////////////////////////////////////////////////////
class StructureQueue : public StructureList
{
    public:
        StructureQueue(INT cbItem, INT cItemGrow)
            : StructureList(cbItem, cItemGrow) { }

        virtual ~StructureQueue(void) { }

        VOID Add(LPVOID pvItem)
            { StructureList::Append(pvItem); }
        BOOL Remove(LPVOID pvItem)
            { return StructureList::RemoveFirst(pvItem); }
};

#endif // _INC_DSKQUOTA_DYNARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\format.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: format.cpp

    Description: Implementation for class EnumFORMATETC.
        Moved from original location in dataobj.cpp (deleted from project).


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "format.h"


EnumFORMATETC::EnumFORMATETC(
    UINT cFormats, 
    LPFORMATETC prgFormats
    ) : m_cRef(0),
        m_cFormats(0),
        m_iCurrent(0),
        m_prgFormats(NULL)
{
    DBGTRACE((DM_DRAGDROP, DL_HIGH, TEXT("EnumFORMATETC::EnumFORMATETC")));
    DBGPRINT((DM_DRAGDROP, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    m_prgFormats = new FORMATETC[m_cFormats = cFormats];

    for (UINT i = 0; i < m_cFormats; i++)
    {
        m_prgFormats[i] = prgFormats[i];
    }
}


EnumFORMATETC::EnumFORMATETC(
    const EnumFORMATETC& ef
    ) : m_cRef(0),
        m_cFormats(ef.m_cFormats),
        m_iCurrent(0),
        m_prgFormats(NULL)
{
    DBGTRACE((DM_DRAGDROP, DL_HIGH, TEXT("EnumFORMATETC::EnumFORMATETC (Copy)")));
    DBGPRINT((DM_DRAGDROP, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    m_prgFormats = new FORMATETC[m_cFormats];

    for (UINT i = 0; i < m_cFormats; i++)
    {
        m_prgFormats[i] = ef.m_prgFormats[i];
    }
}



EnumFORMATETC::~EnumFORMATETC(
    VOID
    )
{
    DBGTRACE((DM_DRAGDROP, DL_HIGH, TEXT("EnumFORMATETC::~EnumFORMATETC")));
    DBGPRINT((DM_DRAGDROP, DL_HIGH, TEXT("\tthis = 0x%08X"), this));
    if (NULL != m_prgFormats)
        delete[] m_prgFormats;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: EnumFORMATETC::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or 
        IEnumFORMATETC interface.  Only IID_IUnknown and 
        IID_IEnumFORMATETC are recognized.  The object referenced by the 
        returned interface pointer is uninitialized.  The recipient of the 
        pointer must call Initialize() before the object is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/25/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
EnumFORMATETC::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IEnumFORMATETC == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: EnumFORMATETC::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/25/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
EnumFORMATETC::AddRef(
    VOID
    )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_COM, DL_HIGH, TEXT("EnumFORMATETC::AddRef, 0x%08X  %d -> %d\n"), this, cRef - 1, cRef ));
    return cRef;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: EnumFORMATETC::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/25/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
EnumFORMATETC::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_COM, DL_HIGH, TEXT("EnumFORMATETC::Release, 0x%08X  %d -> %d\n"),
             this, cRef + 1, cRef));

    if ( 0 == cRef )
    {   
        delete this;
    }
    return cRef;
}


STDMETHODIMP
EnumFORMATETC::Next(
    DWORD cFormats,
    LPFORMATETC pFormats,
    LPDWORD pcReturned
    )
{
    HRESULT hResult = S_OK;

    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("EnumFORMATETC::Next %d"), cFormats));
    DWORD iFormats = 0;
    if (NULL == pFormats)
        return E_INVALIDARG;

    while(cFormats-- > 0)
    {
        if (m_iCurrent < m_cFormats)
        {
            *(pFormats + iFormats++) = m_prgFormats[m_iCurrent++];
        }
        else
        {
            hResult = S_FALSE;
            break;
        }
    }

    if (NULL != pcReturned)
        *pcReturned = iFormats;

    return hResult;
}


STDMETHODIMP
EnumFORMATETC::Skip(
    DWORD cFormats
    )
{
    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("EnumFORMATETC::Skip %d"), cFormats));
    while((cFormats-- > 0) && (m_iCurrent < m_cFormats))
        m_iCurrent++;

    return cFormats == 0 ? S_OK : S_FALSE;
}


STDMETHODIMP 
EnumFORMATETC::Reset(
    VOID
    )
{
    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("EnumFORMATETC::Reset")));
    m_iCurrent = 0;
    return S_OK;
}


STDMETHODIMP 
EnumFORMATETC::Clone(
    IEnumFORMATETC **ppvOut
    )
{
    HRESULT hResult = NO_ERROR;
    try
    {
        EnumFORMATETC *pNew = new EnumFORMATETC(*this);

        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("EnumFORMATETC::Clone")));
        hResult = pNew->QueryInterface(IID_IEnumFORMATETC, (LPVOID *)ppvOut);
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\ownerdlg.h ===
#ifndef _INC_DSKQUOTA_OWNERDLG_H
#define _INC_DSKQUOTA_OWNERDLG_H

#ifndef _INC_DSKQUOTA_PRIVATE_H
#   include "private.h"
#endif

#ifndef _INC_DSKQUOTA_OWNERLST_H
#   include "ownerlst.h"
#endif

class CFileOwnerDialog
{
    public:
        CFileOwnerDialog(HINSTANCE hInstance,
                         HWND hwndParent,
                         LPCTSTR pszVolumeRoot,
                         const CArray<IDiskQuotaUser *>& rgpOwners);

        ~CFileOwnerDialog(void);

        INT_PTR Run(void);

    private:
        //
        // Code in ownerdlg.cpp relies on the values and order of these
        // enumerated constants.
        //
        enum { iLVSUBITEM_FILE = 0,
               iLVSUBITEM_FOLDER,
               iLVSUBITEM_OWNER
             };

        HINSTANCE  m_hInstance;
        HWND       m_hwndParent;
        HWND       m_hwndDlg;
        HWND       m_hwndLV;
        HWND       m_hwndOwnerCombo;
        HWND       m_hwndEditMoveTo;
        int        m_iLastColSorted;
        CPath      m_strVolumeRoot;
        const CArray<IDiskQuotaUser *>& m_rgpOwners; // Ref to existing list.
        COwnerList m_OwnerList;
        bool       m_bSortAscending;
        bool       m_bAbort;
        HANDLE     m_hOwnerListThread;

        static INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnInitDialog(HWND hwnd);
        INT_PTR OnDestroy(HWND hwnd);
        INT_PTR OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
        INT_PTR OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam);
        INT_PTR OnSetCursor(HWND hwnd);
        INT_PTR OnContextMenu(HWND hwndItem, int xPos, int yPos);
        void OnLVN_GetDispInfo(LV_DISPINFO *plvdi);
        void OnLVN_ColumnClick(NM_LISTVIEW *pnmlv);
        void OnLVN_ItemChanged(NM_LISTVIEW *pnmlv);
        void OnLVN_KeyDown(NMLVKEYDOWN *plvkd);
        void InitializeList(const COwnerList& fol, HWND hwndList);
        void FillListView(const COwnerList& fol, HWND hwndList, int iOwner = -1);
        void InitializeOwnerCombo(const COwnerList& fol, HWND hwndCombo);
        void CreateListColumns(HWND hwndList, bool bShowOwner = true);
        HRESULT IsSameVolume(LPCTSTR pszRoot1, LPCTSTR pszRoot2);
        bool BrowseForFolder(HWND hwndParent, CString *pstrFolder);
        bool ShouldEnableControl(UINT idCtl);
        void RemoveListViewItems(HWND hwndLV, const CArray<COwnerListItemHandle>& rgItemHandles);
        void BuildListOfSelectedFiles(HWND hwndLV, DblNulTermList *pList, CArray<COwnerListItemHandle> *prgItemHandles);
        void MoveSelectedFiles(HWND hwndLV, LPCTSTR pszDest);
        void DeleteSelectedFiles(HWND hwndLV);
        void FocusOnSomethingInListview(HWND hwndLV);
        void OnOwnerListComplete(void);

        int FindItemFromHandle(HWND hwndLV, const COwnerListItemHandle& handle);
        HRESULT TakeOwnershipOfSelectedFiles(HWND hwndLV);
        HRESULT GetOwnershipSid(array_autoptr<BYTE> *ptrSid);
        DWORD GetAllowedActions(HWND hwndLV);
        static int CALLBACK CompareLVItems(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
        static int CALLBACK BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);
        static DWORD OwnerListThreadProc(LPVOID pvParam);

        HRESULT
        BuildFileOwnerList(
            LPCTSTR pszVolumeRoot,
            const CArray<IDiskQuotaUser *>& rgpOwners,
            COwnerList *pOwnerList);

        HRESULT
        AddFilesToOwnerList(
            LPCTSTR pszVolumeRoot,
            HANDLE hVolumeRoot,
            IDiskQuotaUser *pOwner,
            COwnerList *pOwnerList);

        NTSTATUS
        OpenNtObject (
            LPCWSTR pszFile,
            HANDLE RelatedObject,
            ULONG CreateOptions,
            ULONG DesiredAccess,
            ULONG ShareAccess,
            ULONG CreateDisposition,
            HANDLE *ph);

};



#endif // _INC_DSKQUOTA_OWNERDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\format.h ===
#ifndef _INC_DSKQUOTA_FORMAT_H
#define _INC_DSKQUOTA_FORMAT_H
///////////////////////////////////////////////////////////////////////////////
/*  File: format.h

    Description: Declaration for class EnumFORMATETC.
        Moved from original location in dataobj.h (deleted from project).


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

class EnumFORMATETC : public IEnumFORMATETC
{
    private:
        LONG        m_cRef;
        UINT        m_cFormats;
        UINT        m_iCurrent;
        LPFORMATETC m_prgFormats;

        //
        // Prevent assignment.
        //
        void operator = (const EnumFORMATETC&);

    public:
        EnumFORMATETC(UINT cFormats, LPFORMATETC prgFormats);
        EnumFORMATETC(const EnumFORMATETC& ef);
        ~EnumFORMATETC(VOID);

        //
        // IUnknown methods.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID riid, 
            LPVOID *ppvOut);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IEnumFORMATETC methods.
        //
        STDMETHODIMP 
        Next(
            DWORD, 
            LPFORMATETC, 
            LPDWORD);

        STDMETHODIMP 
        Skip(
            DWORD);

        STDMETHODIMP 
        Reset(
            VOID);

        STDMETHODIMP 
        Clone(
            IEnumFORMATETC **);
};
        
#endif // _INC_DSKQUOTA_FORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\pch.h ===
#ifndef _INC_DSKQUOTA_PCH_H
#define _INC_DSKQUOTA_PCH_H
///////////////////////////////////////////////////////////////////////////////
/*  File: pch.h

    Description: Precompiled header file for dskquota project.
        Includes all headers that are compiled into the pre-compiled header.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "private.h"
#include "dynarray.h"
#include "..\common\resource.h"

#endif // _INC_DSKQUOTA_PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\ownerlst.cpp ===
#include "pch.h"
#pragma hdrstop

#include "ownerlst.h"


COwnerListEntry::COwnerListEntry(
    IDiskQuotaUser *pOwner
    ) : m_pOwner(pOwner)
{ 
    if (m_pOwner) 
    {
        TCHAR szDisplayName[MAX_PATH] = { TEXT('\0') };
        TCHAR szLogonName[MAX_PATH]   = { TEXT('\0') };
        m_pOwner->AddRef();
        if (SUCCEEDED(m_pOwner->GetName(NULL, 0, 
                                        szLogonName, ARRAYSIZE(szLogonName),
                                        szDisplayName, ARRAYSIZE(szDisplayName))))
        {
            if (TEXT('\0') != szDisplayName[0])
            {
                m_strOwnerName.Format(TEXT("%1 (%2)"), szDisplayName, szLogonName);
            }
            else if (TEXT('\0') != szLogonName[0])
            {
                m_strOwnerName = szLogonName;
            }
            else
            {
                //
                // If the account SID has NOT been resolved to a name, display
                // the SID as a string.  We do the same thing in the Quota Entries
                // view.
                //
                BYTE Sid[MAX_SID_LEN];
                DWORD cchSidStr = MAX_PATH;
                if (SUCCEEDED(m_pOwner->GetSid(Sid, ARRAYSIZE(Sid))))
                {
                    SidToString(Sid, m_strOwnerName.GetBuffer(cchSidStr), &cchSidStr);
                    m_strOwnerName.ReleaseBuffer();
                }
            }
        }
    }    
}


int
COwnerListEntry::AddFile(
    LPCTSTR pszFile,
    bool bDirectory
    )
{
    m_rgFiles.Append(COwnerListFile(pszFile, bDirectory));
    return m_rgFiles.Count() - 1;
}


int
COwnerListEntry::FileCount(
    bool bIncludeDeleted       // optional.  Default = false.
    )
{
    int cFiles = m_rgFiles.Count();
    int n = 0;
    for (int i = 0; i < cFiles; i++)
    {
        if (bIncludeDeleted || !m_rgFiles[i].IsEmpty())
            n++;
    }
    return n;
}


#if DBG
void
COwnerListEntry::Dump(
    void
    ) const
{
    DBGERROR((TEXT("\tm_pOwner........: 0x%08X"), m_pOwner));
    DBGERROR((TEXT("\tm_strOwnerName..: \"%s\""), m_strOwnerName.Cstr()));
    int cFiles = m_rgFiles.Count();
    DBGERROR((TEXT("\tcFiles..........: %d"), cFiles));
    for (int i = 0; i < cFiles; i++)
    {
        DBGERROR((TEXT("\tFile[%3d].......: \"%s\""), i, m_rgFiles[i].Cstr()));
    }
}
#endif // DBG


COwnerList::~COwnerList(
    void
    )
{
    Clear();
}


void
COwnerList::Clear(
    void
    )
{
    int cOwners = m_rgpOwners.Count();
    for (int i = 0; i < cOwners; i++)
    {
        delete m_rgpOwners[i];
        m_rgpOwners[i] = NULL;
    }
    m_rgpOwners.Clear();
}


int
COwnerList::AddOwner(
    IDiskQuotaUser *pOwner
    )
{
    m_rgpOwners.Append(new COwnerListEntry(pOwner));
    return m_rgpOwners.Count() - 1;
}


IDiskQuotaUser *
COwnerList::GetOwner(
    int iOwner
    ) const
{
    //
    // Caller must call Release() when done with returned iface pointer.
    //
    return m_rgpOwners[iOwner]->GetOwner();
}


int 
COwnerList::FileCount(
    int iOwner,
    bool bIncludeDeleted    // optional.  Default = false
    ) const
{
    int cFiles = 0;
    int iFirst = iOwner;
    int iLast  = iOwner;
    if (-1 == iOwner)
    {
        //
        // Count ALL files.
        //
        iFirst = 0;
        iLast = m_rgpOwners.Count() - 1;
    }
    for (int i = iFirst; i <= iLast; i++)
    {
        cFiles += m_rgpOwners[i]->FileCount(bIncludeDeleted);
    }
    return cFiles;
}

#if DBG
void
COwnerList::Dump(
    void
    ) const
{
    int cEntries = m_rgpOwners.Count();
    DBGERROR((TEXT("COwnerList::Dump - %d entries"), cEntries));
    for (int i = 0; i < cEntries; i++)
    {
        DBGERROR((TEXT("COwnerListEntry[%d] ========================="), i));
        m_rgpOwners[i]->Dump();
    }
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\ownerlst.h ===
#ifndef _INC_DSKQUOTA_OWNERLST_H
#define _INC_DSKQUOTA_OWNERLST_H

#ifndef _INC_DSKQUOTA_STRCLASS_H
#   include "strclass.h"
#endif

#ifndef _INC_DSKQUOTA_CARRAY_H
#   include "carray.h"
#endif

#ifndef _INC_DSKQUOTA_H
#   include <dskquota.h>
#endif

//-----------------------------------------------------------------------------
// The following classes are used in managing the list of files owned by
// one or more users selected for deletion from within the details view.
//
//  COwnerList - A list of "owner" objects.  Each representing one of the
//      account selected for deletion from the details view.
//
//  COwnerListEntry - A single entry in the COwnerList container.  Each
//      entry contains a pointer to the IDiskQuotaUser inteface of the
//      file owner and an array of CStrings containing the names of the
//      files owned by that user.  A blank filename is considered "deleted".
//
//  COwnerListFile - A simple derivation from CPath that adds a 'directory'
//      boolean member.  This allows us to easily handle the differences 
//      between files and folders in the UI.  For all intents and purposes,
//      instances of this class can be treated as a simple CPath object.
//
//  COwnerListItemHandle - This is a simple class used to hide the encoding
//      of the owner index and file index in a listview LPARAM value.  The
//      owner index is the index of the LV item's owner in the COwnerList
//      container.  The file index is the index of the item's filename in the
//      owner's COwnerListEntry in the COwnerList container. Perfectly clear,
//      right?  Each listview item's LPARAM contains enough information
//      (iOwner and iFile) to locate the owner and file information in the
//      COwnerList container.  This encoding was done for efficiency reasons.
//      The encoding is currently 10 bits for iOwner (max of 1024) and 22
//      bits for iFile (max of 4 meg).  These values can be adjusted if
//      the balance isn't quite right.
//
//

class COwnerListFile : public CPath
{
    public:
        COwnerListFile(void)
            : m_bDirectory(false) { }

        COwnerListFile(LPCTSTR pszFile, bool bDirectory)
            : CPath(pszFile),
              m_bDirectory(bDirectory) { }

        bool IsDirectory(void) const
            { return m_bDirectory; }

    private:
        bool m_bDirectory;
};

        
class COwnerListEntry
{
    public:
        explicit COwnerListEntry(IDiskQuotaUser *pOwner);
        ~COwnerListEntry(void)
            { if (m_pOwner) m_pOwner->Release(); }

        IDiskQuotaUser* GetOwner(void) const
            { m_pOwner->AddRef(); return m_pOwner; }

        void GetOwnerName(CString *pstrOwner) const
            { *pstrOwner = m_strOwnerName; }

        int AddFile(LPCTSTR pszFile, bool bDirectory);

        void MarkFileDeleted(int iFile)
            { m_rgFiles[iFile].Empty(); }

        bool IsFileDeleted(int iFile) const
            { return !!m_rgFiles[iFile].IsEmpty(); }

        bool IsFileDirectory(int iFile) const
            { return m_rgFiles[iFile].IsDirectory(); }

        void GetFileName(int iFile, CPath *pstrFile) const
            { m_rgFiles[iFile].GetFileSpec(pstrFile); }

        void GetFolderName(int iFile, CPath *pstrFolder) const
            { m_rgFiles[iFile].GetPath(pstrFolder); }

        void GetFileFullPath(int iFile, CPath *pstrFullPath) const
            { *pstrFullPath = m_rgFiles[iFile]; }

        int FileCount(bool bIncludeDeleted = false);

#if DBG
        void Dump(void) const;
#endif

    private:
        IDiskQuotaUser        *m_pOwner;       // Ptr to owner object.
        CString                m_strOwnerName; // Owner's name for display.
        CArray<COwnerListFile> m_rgFiles;      // Filenames for display.

        //
        // Prevent copy.  Array makes it too expensive.
        //
        COwnerListEntry(const COwnerListEntry& rhs);
        COwnerListEntry& operator = (const COwnerListEntry& rhs);
};


class COwnerList
{
    public:
        COwnerList(void) { }
        ~COwnerList(void);

        int AddOwner(IDiskQuotaUser *pOwner);

        IDiskQuotaUser *GetOwner(int iOwner) const;

        void GetOwnerName(int iOwner, CString *pstrOwner) const
            { m_rgpOwners[iOwner]->GetOwnerName(pstrOwner); }

        int AddFile(int iOwner, LPCTSTR pszFile, bool bDirectory)
            { return m_rgpOwners[iOwner]->AddFile(pszFile, bDirectory); }

        void MarkFileDeleted(int iOwner, int iFile)
            { m_rgpOwners[iOwner]->MarkFileDeleted(iFile); }

        bool IsFileDeleted(int iOwner, int iFile) const
            { return m_rgpOwners[iOwner]->IsFileDeleted(iFile); }

        bool IsFileDirectory(int iOwner, int iFile) const
            { return m_rgpOwners[iOwner]->IsFileDirectory(iFile); }

        void GetFileName(int iOwner, int iFile, CPath *pstrFile) const
            { m_rgpOwners[iOwner]->GetFileName(iFile, pstrFile); }

        void GetFolderName(int iOwner, int iFile, CPath *pstrFolder) const
            { m_rgpOwners[iOwner]->GetFolderName(iFile, pstrFolder); }

        void GetFileFullPath(int iOwner, int iFile, CPath *pstrFullPath) const
            { m_rgpOwners[iOwner]->GetFileFullPath(iFile, pstrFullPath); }

        void Clear(void);

        int FileCount(int iOwner = -1, bool bIncludeDeleted = false) const;

        int OwnerCount(void) const
            { return m_rgpOwners.Count(); }

#if DBG
        void Dump(void) const;
#endif

    private:
        CArray<COwnerListEntry *> m_rgpOwners;

        //
        // Prevent copy.
        //
        COwnerList(const COwnerList& rhs);
        COwnerList& operator = (const COwnerList& rhs);
};



class COwnerListItemHandle
{
    public:
        explicit COwnerListItemHandle(int iOwner = -1, int iFile = -1)
            : m_handle((iOwner & MASK) | ((iFile << SHIFT) & ~MASK)) { }

        COwnerListItemHandle(LPARAM lParam)
            : m_handle(lParam) { }

        operator LPARAM() const
            { return m_handle; }

        int OwnerIndex(void) const
            { return int(m_handle & MASK); }

        int FileIndex(void) const
            { return int((m_handle >> SHIFT) & (~MASK >> SHIFT)); }

    private:
        LPARAM m_handle;

        enum { MASK = 0x3FF, SHIFT = 10 };
};



#endif // _INC_DSKQUOTA_OWNERLST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\progress.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: progress.cpp

    Description: Implements the various flavors of progress dialogs used
        in the quota UI.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "progress.h"
#include "resource.h"


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::SendToProgressBar [inline]

    Description: Inline function that sends a message to the dialog's
        progress bar control.  If there is no progress bar control, the
        function returns FALSE.

    Arguments: Standard Win32 message arguments.

    Returns:
        If progress bar window exists, returns the result of SendMessage.
        Otherwise, returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
inline INT_PTR
ProgressDialog::SendToProgressBar(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (NULL != m_hwndProgressBar)
        return SendMessage(m_hwndProgressBar, uMsg, wParam, lParam);
    else
        return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::ProgressDialog

    Description: Class constructor for progress dialog base class.

    Arguments:
        idDialogTemplate - ID number for the dialog's resource template.

        idProgressBar - ID number for the progress bar control.

        idTxtDescription - ID number for text description in dialog.

        idTxtFileName - ID number for file name field in dialog.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ProgressDialog::ProgressDialog(
    UINT idDialogTemplate,
    UINT idProgressBar,
    UINT idTxtDescription,
    UINT idTxtFileName
    ) : m_idDialogTemplate(idDialogTemplate),
        m_idProgressBar(idProgressBar),
        m_idTxtDescription(idTxtDescription),
        m_idTxtFileName(idTxtFileName),
        m_hWnd(NULL),
        m_bUserCancelled(FALSE)
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("ProgressDialog::ProgressDialog")));
    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("\tthis = 0x%08X"), this));
    //
    // Do nothing.
    //
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::~ProgressDialog

    Description: Class destructor for progress dialog base class.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ProgressDialog::~ProgressDialog(
    VOID
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("ProgressDialog::~ProgressDialog")));
    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("\tthis = 0x%08X"), this));
    //
    // Call the Destroy() function to destroy the progress dialog window.
    //
    Destroy();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::Create

    Description: Creates the dialog.

    Arguments:
        hInstance - Instance handle for the DLL containing the dialog
            resource template.

        hwndParent - Parent window for dialog.

    Returns:
        TRUE  = Dialog was created.
        FALSE = Dialog was not created.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
ProgressDialog::Create(
    HINSTANCE hInstance,
    HWND hwndParent
    )
{
    m_hWnd = CreateDialogParam(hInstance,
                               MAKEINTRESOURCE(m_idDialogTemplate),
                               hwndParent,
                               DlgProc,
                               (LPARAM)this);
    if (NULL != m_hWnd)
    {
        m_hwndProgressBar = GetDlgItem(m_hWnd, m_idProgressBar);
        DBGASSERT((NULL != m_hwndProgressBar));
    }
    return (NULL != m_hWnd);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::Destroy

    Description: Destroys the dialog window.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::Destroy(
    VOID
    )
{
    //
    // Note that m_hWnd is set to NULL in OnDestroy().
    //
    if (NULL != m_hWnd)
        DestroyWindow(m_hWnd);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::DlgProc [static]

    Description: Message procedure for the dialog.

    Arguments: Standard Win32 message proc arguments.

    Returns: Standard Win32 message proc return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK
ProgressDialog::DlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Retrieve the dialog object's ptr from the window's userdata.
    // Place there in response to WM_INITDIALOG.
    //
    ProgressDialog *pThis = (ProgressDialog *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(uMsg)
    {
        case WM_INITDIALOG:
            //
            // Store "this" ptr in window's userdata.
            //
            SetWindowLongPtr(hwnd, DWLP_USER, (INT_PTR)lParam);
            pThis = (ProgressDialog *)lParam;
            //
            // Description text control is hidden by default.
            // Calling SetDescription() will show it.
            //
            ShowWindow(GetDlgItem(hwnd, pThis->m_idTxtDescription), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, pThis->m_idTxtFileName),    SW_HIDE);
            //
            // Center dialog in it's parent.
            //
            ::CenterPopupWindow(hwnd);
            //
            // Let derived classes respond to WM_INITDIALOG.
            //
            return pThis->OnInitDialog(hwnd, wParam, lParam);

        case WM_DESTROY:
            //
            // Let derived classes respond to WM_DESTROY.
            //
            return pThis->OnDestroy(hwnd);

        case WM_COMMAND:
            if (IDCANCEL == LOWORD(wParam))
            {
                //
                // User pressed "Cancel" button.
                // Set the "User cancelled" flag and let derived
                // classes respond to the cancellation.
                //
                pThis->m_bUserCancelled = TRUE;
                return pThis->OnCancel(hwnd, wParam, lParam);
            }
            break;

    }
    if (NULL != pThis)
    {
        //
        // Let derived classes respond to any message if they wish.
        // Note that only WM_INITDIALOG, WM_DESTROY and the "user cancelled"
        // events are the only special cases.
        //
        return pThis->HandleMessage(hwnd, uMsg, wParam, lParam);
    }
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::HandleMessage

    Description: Base class implementation of virtual function.  Derived
        classes can provide an implementation to handle any message other than
        WM_INITDIALOG or WM_DESTROY.  These two messages have their own
        virtual message handlers.

    Arguments: Standard Win32 message proc arguments.

    Returns: Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
ProgressDialog::HandleMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::OnInitDialog

    Description: Base class implementation of virtual function.  Called
        when the base class receives WM_INITDIALOG.  Derived classes can
        provide an implementation if they wish to perform some operation
        in response to WM_INITDIALOG.

    Arguments:
        hwnd - Dialog window handle.

        wParam, lParam - Standard Win32 message proc arguments.

    Returns: Always returns TRUE so that USER will set the control focus.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
ProgressDialog::OnInitDialog(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::OnDestroy

    Description: Base class implementation of virtual function.  Called
        when the base class receives WM_DESTROY.  Derived classes can
        provide an implementation if they wish to perform some operation
        in response to WM_DESTROY.  Before returning, any derived implementation
        must call the base class implementation so that m_hWnd is properly
        set to NULL.

    Arguments:
        hwnd - Dialog window handle.

    Returns: Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
ProgressDialog::OnDestroy(
    HWND hwnd
    )
{
    m_hWnd = NULL;
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::OnCancel

    Description: Base class implementation of virtual function.  Called
        when the user presses the "Cancel" button in the dialog.  This
        implementation assumes that the Cancel button is assigned the ID
        of IDCANCEL (standard).

    Arguments:
        hwnd - Dialog window handle.

        wParam, lParam - Standard Win32 message proc arguments.

    Returns: Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
ProgressDialog::OnCancel(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::FlushMessages

    Description: While the dialog is active, call this periodically so that
        the thread is able to properly update the dialog and respond to the
        user pressing "Cancel".

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::FlushMessages(
    VOID
    )
{
    if (NULL != m_hWnd)
    {
        //
        // Process messages for the dialog's parent and all of it's children.
        //
        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE) &&
               WM_QUIT != msg.message)
        {
            GetMessage(&msg, NULL, 0, 0);
            if (!IsDialogMessage(m_hWnd, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::SetTitle

    Description: Sets the title string in the dialog.

    Arguments:
        pszTitle - Address of title string.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::SetTitle(
    LPCTSTR pszTitle
    )
{
    DBGASSERT((NULL != pszTitle));
    if (NULL != m_hWnd)
    {
        if (0 == ((DWORD_PTR)pszTitle & ~0xffff))
        {
            TCHAR szText[MAX_PATH] = { TEXT('\0') };
            LoadString(g_hInstDll, (DWORD)((DWORD_PTR)pszTitle), szText, ARRAYSIZE(szText));
            pszTitle = szText;
        }
        SetWindowText(m_hWnd, pszTitle);
        FlushMessages();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::SetDescription

    Description: Sets the progress description string in the dialog.

    Arguments:
        pszDescription - Address of description string.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::SetDescription(
    LPCTSTR pszDescription
    )
{
    DBGASSERT((NULL != pszDescription));
    if (NULL != m_hWnd)
    {
        if (0 == ((DWORD_PTR)pszDescription & ~0xffff))
        {
            TCHAR szText[MAX_PATH] = { TEXT('\0') };
            LoadString(g_hInstDll, (DWORD)((DWORD_PTR)pszDescription), szText, ARRAYSIZE(szText));
            pszDescription = szText;
        }
        SetWindowText(GetDlgItem(m_hWnd, m_idTxtDescription), pszDescription);
        //
        // Description control is by default hidden.
        //
        ShowWindow(GetDlgItem(m_hWnd, m_idTxtDescription), SW_NORMAL);
        FlushMessages();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::SetFileName

    Description: Sets the file name description string in the dialog.
        If the file name is too long, it is formatted with ellipses to
        fit in the space provided.

    Arguments:
        pszFileName - Address of file name string.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::SetFileName(
    LPCTSTR pszFileName
    )
{
    DBGASSERT((NULL != pszFileName));
    if (NULL != m_hWnd)
    {
        HWND hwndCtl   = GetDlgItem(m_hWnd, m_idTxtFileName);
        HDC hdc        = GetDC(hwndCtl);
        RECT rc;
        LPTSTR pszText = StringDup(pszFileName);

        if (NULL != pszText)
        {
            GetClientRect(hwndCtl, &rc);

            DrawText(hdc,
                     pszText,
                     -1,
                     &rc,
                     DT_CENTER |
                     DT_PATH_ELLIPSIS |
                     DT_MODIFYSTRING);

            SetWindowText(hwndCtl, pszText);
            delete[] pszText;

            //
            // FileName control is by default hidden.
            //
            ShowWindow(hwndCtl, SW_NORMAL);
        }
        FlushMessages();
        ReleaseDC(hwndCtl, hdc);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::ProgressBarInit

    Description: Initializes the progress bar control with range and step
        values.  If this function is not called, the progress bar defaults
        to:
            iMin  =   0
            iMax  = 100
            iStep =  10

    Arguments:
        iMin - Minimum range value.

        iMax - Maximum range value.

        iStep - Amount bar advances each time PBM_STEPIT is received.

    Returns:
        TRUE  = Progress bar control accepted settings.
        FALSE = Progress bar rejected settings.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
ProgressDialog::ProgressBarInit(
    UINT iMin,
    UINT iMax,
    UINT iStep
    )
{
    BOOL bResult = FALSE;

    if (0 != SendToProgressBar(PBM_SETSTEP,  iStep, 0))
        bResult = (0 != SendToProgressBar(PBM_SETRANGE, 0, MAKELPARAM(iMin, iMax)));

    FlushMessages();
    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::ProgressBarReset

    Description: Resets the progres bar position at 0.

    Arguments: None.

    Returns:  Previous "position" of progress bar.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
ProgressDialog::ProgressBarReset(
    VOID
    )
{
    UINT iReturn = (UINT)ProgressBarSetPosition(0);
    FlushMessages();
    return iReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::ProgressBarAdvance

    Description: Advances the progress bar a given number of counts.

    Arguments:
        iDelta - Number of counts to advance.  If -1, the bar is advanced
            by the step value supplied in ProgressBarInit.

    Returns:  Previous "position" of progress bar.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
ProgressDialog::ProgressBarAdvance(
    UINT iDelta
    )
{
    UINT iReturn;
    if ((UINT)-1 == iDelta)
        iReturn = (UINT)SendToProgressBar(PBM_STEPIT, 0, 0);
    else
        iReturn = (UINT)SendToProgressBar(PBM_DELTAPOS, (WPARAM)iDelta, 0);

    FlushMessages();

    return iReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::ProgressBarSetPosition

    Description: Advances the progress bar to a specific position.

    Arguments:
        iPosition - Specific position count.

    Returns:  Previous "position" of progress bar.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
ProgressDialog::ProgressBarSetPosition(
    UINT iPosition
    )
{
    UINT iReturn = (UINT)SendToProgressBar(PBM_SETPOS, (WPARAM)iPosition, 0);
    FlushMessages();
    return iReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::Show

    Description: Makes the progress dialog visible.

    Arguments: None.

    Returns:  Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::Show(
    VOID
    )
{
    if (NULL != m_hWnd)
    {
        ShowWindow(m_hWnd, SW_SHOWNORMAL);
        FlushMessages();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::Hide

    Description: Hides the progress dialog.

    Arguments: None.

    Returns:  Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::Hide(
    VOID
    )
{
    if (NULL != m_hWnd)
    {
        ShowWindow(m_hWnd, SW_HIDE);
        FlushMessages();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\ownerdlg.cpp ===
#include "pch.h"
#pragma hdrstop

#include "ownerdlg.h"
#include "ownerlst.h"
#include "resource.h"
#include "uihelp.h"
#include "uiutils.h"

//
// Private message used to indicate that the owner list thread
// has completed it's work.  
//
const UINT PWM_OWNERLIST_COMPLETE = WM_USER + 1;
//
// Mask bits indicating what operations are allowed for a given
// file selection set in the listview.
//
const DWORD ACTION_NONE          = 0x00000000;
const DWORD ACTION_TAKEOWNERSHIP = 0x00000001;
const DWORD ACTION_MOVE          = 0x00000002;
const DWORD ACTION_DELETE        = 0x00000004;
const DWORD ACTION_ANY           = 0x00000007;

const static DWORD rgFileOwnerDialogHelpIDs[] =
{
    IDC_CMB_OWNERDLG_OWNERS,       IDH_CMB_OWNERDLG_OWNERS,
    IDC_LV_OWNERDLG,               IDH_LV_OWNERDLG,
    IDC_BTN_OWNERDLG_DELETE,       IDH_BTN_OWNERDLG_DELETE,
    IDC_BTN_OWNERDLG_MOVETO,       IDH_BTN_OWNERDLG_MOVETO,
    IDC_BTN_OWNERDLG_TAKE,         IDH_BTN_OWNERDLG_TAKE,
    IDC_BTN_OWNERDLG_BROWSE,       IDH_BTN_OWNERDLG_BROWSE,
    IDC_EDIT_OWNERDLG_MOVETO,      IDH_EDIT_OWNERDLG_MOVETO,
    IDC_CBX_OWNERDLG_EXCLUDEDIRS,  IDH_CBX_OWNERDLG_EXCLUDEDIRS,
    IDC_CBX_OWNERDLG_EXCLUDEFILES, IDH_CBX_OWNERDLG_EXCLUDEFILES,
    0,0
};


CFileOwnerDialog::CFileOwnerDialog(HINSTANCE hInstance,
    HWND hwndParent,
    LPCTSTR pszVolumeRoot,
    const CArray<IDiskQuotaUser *>& rgpOwners
    ) : m_hInstance(hInstance),
        m_hwndParent(hwndParent),
        m_hwndDlg(NULL),
        m_hwndLV(NULL),
        m_hwndOwnerCombo(NULL),
        m_hwndEditMoveTo(NULL),
        m_iLastColSorted(-1),
        m_bSortAscending(true),
        m_bAbort(false),
        m_hOwnerListThread(NULL),
        m_rgpOwners(rgpOwners),
        m_strVolumeRoot(pszVolumeRoot)
{
}

CFileOwnerDialog::~CFileOwnerDialog(
    void
    )
{
    if (NULL != m_hOwnerListThread)
    {
        CloseHandle(m_hOwnerListThread);
    }
}


INT_PTR
CFileOwnerDialog::Run(
    void
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("CFileOwnerDialog::Run")));
    return DialogBoxParam(m_hInstance,
                          MAKEINTRESOURCE(IDD_OWNERSANDFILES),
                          m_hwndParent,
                          DlgProc,
                          (LPARAM)this);
}


INT_PTR CALLBACK
CFileOwnerDialog::DlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Retrieve the dialog object's ptr from the window's userdata.
    // Place there in response to WM_INITDIALOG.
    //
    CFileOwnerDialog *pThis = (CFileOwnerDialog *)GetWindowLongPtr(hwnd, DWLP_USER);

    try
    {
        switch(uMsg)
        {
            case WM_INITDIALOG:
                //
                // Store "this" ptr in window's userdata.
                //
                SetWindowLongPtr(hwnd, DWLP_USER, (INT_PTR)lParam);
                pThis = (CFileOwnerDialog *)lParam;
                //
                // Save the HWND in our object.  We'll need it later.
                //
                pThis->m_hwndDlg = hwnd;
                return pThis->OnInitDialog(hwnd);

            case WM_DESTROY:
                return pThis->OnDestroy(hwnd);

            case WM_COMMAND:
                return pThis->OnCommand(hwnd, wParam, lParam);

            case WM_NOTIFY:
                return pThis->OnNotify(hwnd, wParam, lParam);

            case WM_CONTEXTMENU:
                return pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
                break;

            case PWM_OWNERLIST_COMPLETE:
                pThis->OnOwnerListComplete();
                break;

            case WM_SETCURSOR:
                return pThis->OnSetCursor(hwnd);
                break;

            case WM_HELP:
                WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, STR_DSKQUOUI_HELPFILE,
                            HELP_WM_HELP, (DWORD_PTR)(LPTSTR) rgFileOwnerDialogHelpIDs);
                return TRUE;
        }
    }
    catch(CAllocException& me)
    {
        //
        // Announce any out-of-memory errors associated with running the dlg.
        //
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return FALSE;
}


INT_PTR
CFileOwnerDialog::OnInitDialog(
    HWND hwnd
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("CFileOwnerDialog::OnInitDialog")));

    //
    // Save HWNDs of controls we'll need later.
    //
    m_hwndLV         = GetDlgItem(hwnd, IDC_LV_OWNERDLG);
    m_hwndOwnerCombo = GetDlgItem(hwnd, IDC_CMB_OWNERDLG_OWNERS);
    m_hwndEditMoveTo = GetDlgItem(hwnd, IDC_EDIT_OWNERDLG_MOVETO);
    //
    // We want these controls to be disabled until the owner list
    // has been populated.
    //
    EnableWindow(m_hwndLV, FALSE);
    EnableWindow(m_hwndOwnerCombo, FALSE);
    EnableWindow(m_hwndEditMoveTo, FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_BTN_OWNERDLG_BROWSE), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_CBX_OWNERDLG_EXCLUDEDIRS), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_CBX_OWNERDLG_EXCLUDEFILES), FALSE);
    //
    // Build the list of owners and filenames on the volume.
    // This can take a while depending on how many owners
    // are in m_rgpOwners, the size of the volume and how many
    // files each owner owns.  First clear the owner list in case Run()
    // is being called multiple times on the same dialog object.
    // Note that we build this list on a background thread so that
    // we don't block the UI while it's building.
    //
    m_OwnerList.Clear();
    DWORD idThread;
    m_hOwnerListThread = CreateThread(NULL,
                                      0,
                                      OwnerListThreadProc,
                                      this,
                                      0,
                                      &idThread);
    return TRUE;
}


INT_PTR
CFileOwnerDialog::OnSetCursor(
    HWND hwnd
    )
{
    if (m_hOwnerListThread && (WAIT_TIMEOUT == WaitForSingleObject(m_hOwnerListThread, 0)))
    {
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        return TRUE;
    }
    return FALSE;
}


INT_PTR
CFileOwnerDialog::OnDestroy(
    HWND hwnd
    )
{
    m_bAbort = true;
    if (NULL != m_hOwnerListThread)
    {
        WaitForSingleObject(m_hOwnerListThread, INFINITE);
    }
    return TRUE;
}


DWORD
CFileOwnerDialog::OwnerListThreadProc(  // [static]
    LPVOID pvParam
    )
{
    CFileOwnerDialog *pThis = (CFileOwnerDialog *)pvParam;
    
    pThis->BuildFileOwnerList(pThis->m_strVolumeRoot,
                              pThis->m_rgpOwners,
                             &(pThis->m_OwnerList));

    PostMessage(pThis->m_hwndDlg, PWM_OWNERLIST_COMPLETE, 0, 0);
    return 0;
}

//
// Called in response to PWM_OWNERLIST_COMPLETE which is posted
// to the dialog when the OwnerListThreadProc has completed
// it's processing.
//
void
CFileOwnerDialog::OnOwnerListComplete(
    void
    )
{
    //
    // Set the message in the top of the dialog.
    //
    CString s(m_hInstance, IDS_FMT_OWNERDLG_HEADER, m_OwnerList.OwnerCount());
    SetWindowText(GetDlgItem(m_hwndDlg, IDC_TXT_OWNERDLG_HEADER), s);
    //
    // Populate the listview and owner combo.
    //
    InitializeList(m_OwnerList, m_hwndLV);
    InitializeOwnerCombo(m_OwnerList, m_hwndOwnerCombo);
    //
    // Now we can enable the controls we disabled in OnInitDialog().
    //
    EnableWindow(m_hwndLV, TRUE);
    EnableWindow(m_hwndOwnerCombo, TRUE);
    EnableWindow(m_hwndEditMoveTo, TRUE);
    EnableWindow(GetDlgItem(m_hwndDlg, IDC_BTN_OWNERDLG_BROWSE), TRUE);
    EnableWindow(GetDlgItem(m_hwndDlg, IDC_CBX_OWNERDLG_EXCLUDEDIRS), TRUE);
    EnableWindow(GetDlgItem(m_hwndDlg, IDC_CBX_OWNERDLG_EXCLUDEFILES), TRUE);

}



INT_PTR
CFileOwnerDialog::OnCommand(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bResult     = TRUE; // Assume not handled.
    WORD wID         = LOWORD(wParam);
    WORD wNotifyCode = HIWORD(wParam);
    HWND hCtl        = (HWND)lParam;

    switch(wID)
    {
        case IDCANCEL:
            EndDialog(hwnd, 0);
            bResult = FALSE;
            break;

        case IDC_CMB_OWNERDLG_OWNERS:
            if (CBN_SELCHANGE == wNotifyCode)
            {
                int iOwner = ComboBox_GetCurSel(m_hwndOwnerCombo);
                if (1 < m_OwnerList.OwnerCount())
                {
                    //
                    // Owner list contains more than one owner.  The combo
                    // contains a leading "All owners" entry.
                    //
                    iOwner--;
                }

                DBGASSERT((-1 <= iOwner));
                CAutoSetRedraw autoredraw(m_hwndLV, false);
                //
                // Only show "owner" column if user has selected "all owners" combo item.
                //
                CreateListColumns(m_hwndLV, -1 == iOwner);
                FillListView(m_OwnerList, m_hwndLV, iOwner);
            }
            bResult = FALSE;
            break;

        case IDC_BTN_OWNERDLG_BROWSE:
        {
            CString s;
            if (BrowseForFolder(hwnd, &s))
                SetWindowText(m_hwndEditMoveTo, s);
            break;
        }

        case IDC_BTN_OWNERDLG_DELETE:
            DeleteSelectedFiles(m_hwndLV);
            bResult = FALSE;
            break;

        case IDC_BTN_OWNERDLG_MOVETO:
        {
            CPath strDest;
            CPath strRoot;
            int cchEdit = Edit_GetTextLength(m_hwndEditMoveTo);
            Edit_GetText(m_hwndEditMoveTo,
                         strDest.GetBuffer(cchEdit + 1),
                         cchEdit + 1);
            strDest.ReleaseBuffer();
            strDest.Trim();
            strDest.GetRoot(&strRoot);

            HRESULT hr = IsSameVolume(strRoot, m_strVolumeRoot);
            if (S_OK == hr)
            {
                //
                // Don't let operator move files to a folder
                // on the same volume.
                //
                DiskQuotaMsgBox(m_hwndDlg,
                                IDS_ERROR_MOVETO_SAMEVOL,
                                IDS_TITLE_DISK_QUOTA,
                                MB_ICONINFORMATION | MB_OK);

                SetWindowText(m_hwndEditMoveTo, strDest);
                SetFocus(m_hwndEditMoveTo);
            }
            else if (S_FALSE == hr)
            {
                //
                // Eveything looks OK.  Try to move the files.
                //
                MoveSelectedFiles(m_hwndLV, strDest);
            }
            else
            {
                DBGERROR((TEXT("TakeOwnershipOfSelectedFiles failed with hr = 0x%08X"), hr));
            }
            bResult = FALSE;
            break;
        }

        case IDC_BTN_OWNERDLG_TAKE:
        {
            HRESULT hr = TakeOwnershipOfSelectedFiles(m_hwndLV);
            if (FAILED(hr))
            {
                DBGERROR((TEXT("TakeOwnershipOfSelectedFiles failed with hr = 0x%08X"), hr));
            }
            break;
        }

        case IDC_EDIT_OWNERDLG_MOVETO:
            if (EN_UPDATE == wNotifyCode)
            {
                //
                // Disable the "Move" button if the destination edit field
                // is blank.
                //
                HWND hwnd    = GetDlgItem(m_hwndDlg, IDC_BTN_OWNERDLG_MOVETO);
                bool bEnable = ShouldEnableControl(IDC_BTN_OWNERDLG_MOVETO);
                if (bEnable != boolify(IsWindowEnabled(hwnd)))
                {
                    EnableWindow(hwnd, bEnable);
                }
            }
            break;

        case IDC_CBX_OWNERDLG_EXCLUDEFILES:
        case IDC_CBX_OWNERDLG_EXCLUDEDIRS:
            if (BN_CLICKED == wNotifyCode)
            {
                //
                // The allowable states for these two checkboxes are:
                //
                //   Excl Files      Excl Dirs
                //   --------------- ----------------
                //   Checked         Unchecked
                //   Unchecked       Checked
                //   Unchecked       Unchecked
                //
                // It makes no sense to have both checkboxes checked. 
                // This would cause the list to be empty and might 
                // generate user confusion.
                //
                if (IsDlgButtonChecked(m_hwndDlg, wID))
                {
                    UINT idOther = IDC_CBX_OWNERDLG_EXCLUDEFILES;
                    if (IDC_CBX_OWNERDLG_EXCLUDEFILES == wID)
                    {
                        idOther = IDC_CBX_OWNERDLG_EXCLUDEDIRS;
                    }
                    CheckDlgButton(m_hwndDlg, idOther, BST_UNCHECKED);
                }
                FillListView(m_OwnerList, m_hwndLV, ComboBox_GetCurSel(m_hwndOwnerCombo) - 1);
            }
            break;
    }
    return bResult;
}


INT_PTR
CFileOwnerDialog::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem,
            UseWindowsHelp(idCtl) ? NULL : STR_DSKQUOUI_HELPFILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)((LPTSTR)rgFileOwnerDialogHelpIDs));

    return FALSE;
}


//
// Determine what actions are allowed for the current selection.
//
DWORD 
CFileOwnerDialog::GetAllowedActions(
    HWND hwndLV
    )
{
    CArray<COwnerListItemHandle> rgItemHandles;

    BuildListOfSelectedFiles(hwndLV, NULL, &rgItemHandles);
    if (0 != rgItemHandles.Count())
    {
        const int cHandles = rgItemHandles.Count();
        for(int i = 0; i < cHandles; i++)
        {
            COwnerListItemHandle handle = rgItemHandles[i];
            int iOwner = handle.OwnerIndex();
            int iFile  = handle.FileIndex();
            if (m_OwnerList.IsFileDirectory(iOwner, iFile))
            {
                //
                // If any directory exists in the selection,
                // "take ownership" is the only allowed action.
                //
                return ACTION_TAKEOWNERSHIP;
            }
        }
    }
    return ACTION_ANY;
}


//
// Determine if one of the move/delete/take buttons should be enabled
// or disabled.
//
bool
CFileOwnerDialog::ShouldEnableControl(
    UINT idCtl
    )
{
    bool bEnable = true;
    int cLVSel = ListView_GetSelectedCount(m_hwndLV);
    DWORD actions = GetAllowedActions(m_hwndLV);
    
    switch(idCtl)
    {
        case IDC_BTN_OWNERDLG_DELETE:
            bEnable = (0 != (ACTION_DELETE & actions)) && (0 < cLVSel);
            break;
            
        case IDC_BTN_OWNERDLG_TAKE:
            bEnable = (0 != (ACTION_TAKEOWNERSHIP & actions)) && (0 < cLVSel);
            break;

        case IDC_BTN_OWNERDLG_MOVETO:
            bEnable = (0 != (ACTION_MOVE & actions));
            if (bEnable && 0 < cLVSel)
            {
                CPath s;
                int cch = Edit_GetTextLength(m_hwndEditMoveTo);
                Edit_GetText(m_hwndEditMoveTo, s.GetBuffer(cch + 1), cch + 1);
                s.ReleaseBuffer();
                s.Trim();
                bEnable = 0 < s.Length();
            }
            break;

        case IDC_BTN_OWNERDLG_BROWSE:
        case IDC_EDIT_OWNERDLG_MOVETO:
            bEnable = (0 != (ACTION_MOVE & actions));
            break;

        default:
            break;
    }
    return bEnable;
}


INT_PTR
CFileOwnerDialog::OnNotify(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bResult = TRUE;
    LPNMHDR pnm  = (LPNMHDR)lParam;

    switch(pnm->code)
    {
        case LVN_GETDISPINFO:
            OnLVN_GetDispInfo((LV_DISPINFO *)lParam);
            break;

        case LVN_COLUMNCLICK:
            OnLVN_ColumnClick((NM_LISTVIEW *)lParam);
            break;

        case LVN_ITEMCHANGED:
            OnLVN_ItemChanged((NM_LISTVIEW *)lParam);
            break;

        case LVN_KEYDOWN:
            OnLVN_KeyDown((NMLVKEYDOWN *)lParam);
            break;

        default:
            break;
    }

    return bResult;
}


void
CFileOwnerDialog::OnLVN_GetDispInfo(
    LV_DISPINFO *plvdi
    )
{
    static CPath strPath;
    static CString strOwner;

    COwnerListItemHandle hItem(plvdi->item.lParam);
    int iOwner = hItem.OwnerIndex();
    int iFile  = hItem.FileIndex();

    if (LVIF_TEXT & plvdi->item.mask)
    {
        switch(plvdi->item.iSubItem)
        {
            case iLVSUBITEM_FILE:
            {
                CPath s;
                m_OwnerList.GetFileName(iOwner, iFile, &s);
                if (m_OwnerList.IsFileDirectory(iOwner, iFile))
                {
                    strPath.Format(m_hInstance, IDS_FMT_OWNERDLG_FOLDERNAME, s.Cstr());
                }
                else
                {
                    strPath = s;
                }
                plvdi->item.pszText = (LPTSTR)strPath.Cstr();
            }
            break;

            case iLVSUBITEM_FOLDER:
                m_OwnerList.GetFolderName(iOwner, iFile, &strPath);
                plvdi->item.pszText = (LPTSTR)strPath.Cstr();
                break;

            case iLVSUBITEM_OWNER:
                m_OwnerList.GetOwnerName(iOwner, &strOwner);
                plvdi->item.pszText = (LPTSTR)strOwner.Cstr();
                break;
        }
    }

    if (LVIF_IMAGE & plvdi->item.mask)
    {
        //
        // Not displaying any images.  This is just a placeholder.
        // Should be optimized out by compiler.
        //
    }
}


int CALLBACK
CFileOwnerDialog::CompareLVItems(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    CFileOwnerDialog *pdlg = reinterpret_cast<CFileOwnerDialog *>(lParamSort);
    int diff = 0;
    try
    {
        COwnerListItemHandle h1(lParam1);
        COwnerListItemHandle h2(lParam2);
        int iOwner1 = h1.OwnerIndex();
        int iOwner2 = h2.OwnerIndex();
        int iFile1  = h1.FileIndex();
        int iFile2  = h2.FileIndex();
        static CPath s1, s2;

        //
        // This array controls the comparison column IDs used when
        // values for the selected column are equal.  These should
        // remain in order of the iLVSUBITEM_xxxxx enumeration with
        // respect to the first element in each row.
        //
        static const int rgColComp[3][3] = {
            { iLVSUBITEM_FILE,   iLVSUBITEM_FOLDER, iLVSUBITEM_OWNER  },
            { iLVSUBITEM_FOLDER, iLVSUBITEM_FILE,   iLVSUBITEM_OWNER  },
            { iLVSUBITEM_OWNER,  iLVSUBITEM_FILE,   iLVSUBITEM_FOLDER }
                                           };
        int iCompare = 0;
        while(0 == diff && iCompare < ARRAYSIZE(rgColComp))
        {
            switch(rgColComp[pdlg->m_iLastColSorted][iCompare++])
            {
                case iLVSUBITEM_FILE:
                    pdlg->m_OwnerList.GetFileName(iOwner1, iFile1, &s1);
                    pdlg->m_OwnerList.GetFileName(iOwner2, iFile2, &s2);
                    break;

                case iLVSUBITEM_FOLDER:
                    pdlg->m_OwnerList.GetFolderName(iOwner1, iFile1, &s1);
                    pdlg->m_OwnerList.GetFolderName(iOwner2, iFile2, &s2);
                    break;

                case iLVSUBITEM_OWNER:
                    //
                    // Can use CPath (s1 and s2) in place of CString arg since
                    // CPath is derived from CString.
                    //
                    pdlg->m_OwnerList.GetOwnerName(iOwner1, &s1);
                    pdlg->m_OwnerList.GetOwnerName(iOwner2, &s2);
                    break;

                default:
                    //
                    // If you hit this, you need to update this function
                    // to handle the new column you've added to the listview.
                    //
                    DBGASSERT((false));
                    break;
            }
            diff = s1.Compare(s2);
        }
        //
        // Don't need contents of static strings between function invocations.
        // The strings are static to avoid repeated construction/destruction.
        // It's only a minor optimization.
        //
        s1.Empty();
        s2.Empty();
    }
    catch(CAllocException& e)
    {
        //
        // Do nothing.  Just return diff "as is".
        // Don't want to throw an exception back into comctl32.
        //
    }
    return pdlg->m_bSortAscending ? diff : -1 * diff;
}


void
CFileOwnerDialog::OnLVN_ColumnClick(
    NM_LISTVIEW *pnmlv
    )
{
    DBGTRACE((DM_VIEW, DL_LOW, TEXT("CFileOwnerDialog::OnLVN_ColumnClick")));

    if (m_iLastColSorted != pnmlv->iSubItem)
    {
        m_bSortAscending = true;
        m_iLastColSorted = pnmlv->iSubItem;
    }
    else
    {
        m_bSortAscending = !m_bSortAscending;
    }

    ListView_SortItems(m_hwndLV, CompareLVItems, LPARAM(this));
}


//
// Called whenever a listview item has changed state.
// I'm using this to update the "enabledness" of the
// dialog buttons.  If there's nothing selected in the listview,
// the move/delete/take buttons are disabled.
//
void
CFileOwnerDialog::OnLVN_ItemChanged(
    NM_LISTVIEW *pnmlv
    )
{
    static const int rgCtls[] = { IDC_BTN_OWNERDLG_DELETE,
                                  IDC_BTN_OWNERDLG_TAKE,
                                  IDC_BTN_OWNERDLG_MOVETO,
                                  IDC_BTN_OWNERDLG_BROWSE,
                                  IDC_EDIT_OWNERDLG_MOVETO};

    //
    // LVN_ITEMCHANGED is sent multiple times when you move the
    // highlight bar in a listview.
    // Only run this code when the "focused" state bit is set
    // for the "new state".  This should be the last call in
    // the series.
    //
    if (LVIS_FOCUSED & pnmlv->uNewState)
    {
        for (int i = 0; i < ARRAYSIZE(rgCtls); i++)
        {
            HWND hwnd    = GetDlgItem(m_hwndDlg, rgCtls[i]);
            bool bEnable = ShouldEnableControl(rgCtls[i]);
            if (bEnable != boolify(IsWindowEnabled(hwnd)))
            {
                EnableWindow(hwnd, bEnable);
            }
        }
    }
}


void
CFileOwnerDialog::OnLVN_KeyDown(
    NMLVKEYDOWN *plvkd
    )
{
    if (VK_DELETE == plvkd->wVKey)
    {
        DeleteSelectedFiles(m_hwndLV);
        FocusOnSomethingInListview(m_hwndLV);
    }
}



void
CFileOwnerDialog::FocusOnSomethingInListview(
    HWND hwndLV
    )
{
    //
    // Focus on something.
    //
    int iFocus = ListView_GetNextItem(hwndLV, -1, LVNI_FOCUSED);
    if (-1 == iFocus)
        iFocus = 0;

    ListView_SetItemState(hwndLV, iFocus, LVIS_FOCUSED | LVIS_SELECTED,
                                          LVIS_FOCUSED | LVIS_SELECTED);
}


//
// Creates the listview columns and populates the listview
// with filenames.
//
void
CFileOwnerDialog::InitializeList(
    const COwnerList& fol,  // file & owner list
    HWND hwndList
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::InitializeList")));

    CreateListColumns(hwndList, 1 < m_OwnerList.OwnerCount());
    FillListView(fol, hwndList);
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);
}


void
CFileOwnerDialog::CreateListColumns(
    HWND hwndList,
    bool bShowOwner    // Default is true.
    )
{
    //
    // Clear out the listview and header.
    //
    ListView_DeleteAllItems(hwndList);
    HWND hwndHeader = ListView_GetHeader(hwndList);
    if (NULL != hwndHeader)
    {
        while(0 < Header_GetItemCount(hwndHeader))
            ListView_DeleteColumn(hwndList, 0);
    }

    //
    // Create the header titles.
    //
    CString strFile(m_hInstance,   IDS_OWNERDLG_HDR_FILE);
    CString strFolder(m_hInstance, IDS_OWNERDLG_HDR_FOLDER);
    CString strOwner(m_hInstance,  IDS_OWNERDLG_HDR_OWNER);

    //
    // FEATURE:  Should probably allow for vertical scroll bar also.
    //
    RECT rcList;
    GetClientRect(hwndList, &rcList);
    int cxCol = (rcList.right - rcList.left) / (bShowOwner ? 3 : 2);

#define LVCOLMASK (LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM)

    LV_COLUMN rgCols[] = {
         { LVCOLMASK, LVCFMT_LEFT, cxCol, strFile,   0, iLVSUBITEM_FILE   },
         { LVCOLMASK, LVCFMT_LEFT, cxCol, strFolder, 0, iLVSUBITEM_FOLDER },
         { LVCOLMASK, LVCFMT_LEFT, cxCol, strOwner,  0, iLVSUBITEM_OWNER  }
                         };
    //
    // Add the columns to the listview.
    //
    int cCols = bShowOwner ? ARRAYSIZE(rgCols) : ARRAYSIZE(rgCols) - 1;
    for (INT i = 0; i < cCols; i++)
    {
        if (-1 == ListView_InsertColumn(hwndList, i, &rgCols[i]))
        {
            DBGERROR((TEXT("CFileOwnerDialog::CreateListColumns failed to add column %d"), i));
        }
    }
}


void
CFileOwnerDialog::FillListView(
    const COwnerList& fol,  // file & owner list
    HWND hwndList,
    int iOwner              // default is -1 (all owners)
    )
{
    ListView_DeleteAllItems(hwndList);

    LV_ITEM item;
    item.iSubItem  = 0;
    item.mask      = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE | LVIF_PARAM;
    item.state     = 0;
    item.stateMask = 0;
    item.pszText   = LPSTR_TEXTCALLBACK;
    item.iImage    = I_IMAGECALLBACK;

    int iFirst = iOwner;
    int iLast  = iOwner;
    if (-1 == iOwner)
    {
        iFirst = 0;
        iLast  = fol.OwnerCount() - 1;
    }
    int iItem = 0;
    const bool bExclFiles = IsDlgButtonChecked(m_hwndDlg, IDC_CBX_OWNERDLG_EXCLUDEFILES);
    const bool bExclDirs  = IsDlgButtonChecked(m_hwndDlg, IDC_CBX_OWNERDLG_EXCLUDEDIRS);
    //
    // WARNING:  Reusing formal arg iOwner.  It's safe to do, but you
    //           should be aware that I'm doing it.
    //
    for (iOwner = iFirst; iOwner <= iLast; iOwner++)
    {
        int cFiles = fol.FileCount(iOwner, true);
        for (int iFile = 0; iFile < cFiles; iFile++)
        {
            bool bDirectory = fol.IsFileDirectory(iOwner, iFile);
            bool bFile      = !bDirectory;

            if ((bDirectory && !bExclDirs) || (bFile && !bExclFiles))
            {
                if (!fol.IsFileDeleted(iOwner, iFile))
                {
                    item.lParam = COwnerListItemHandle(iOwner, iFile);
                    item.iItem  = iItem++;
                    if (-1 == ListView_InsertItem(hwndList, &item))
                        DBGERROR((TEXT("Error adding LV item for owner %d, file %d"), iOwner, iFile));
                }
            }
        }
    }
}


void
CFileOwnerDialog::InitializeOwnerCombo(
    const COwnerList& fol,  // file & owner list
    HWND hwndCombo
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::InitializeList")));

    int iSelected = ComboBox_GetCurSel(hwndCombo);
    ComboBox_ResetContent(hwndCombo);

    CString s, s2;
    int cOwners = fol.OwnerCount();
    if (1 < cOwners)
    {
        //
        // Add "all owners" entry.
        //
        s.Format(m_hInstance, IDS_FMT_ALLOWNERS, fol.FileCount());
        ComboBox_InsertString(hwndCombo, -1, s);
    }

    for (int iOwner = 0; iOwner < cOwners; iOwner++)
    {
        fol.GetOwnerName(iOwner, &s2);
        s.Format(m_hInstance, IDS_FMT_OWNER, s2.Cstr(), fol.FileCount(iOwner));
        ComboBox_InsertString(hwndCombo, -1, s);
    }

    ComboBox_SetCurSel(hwndCombo, CB_ERR != iSelected ? iSelected : 0);

    //
    // Set the max height of the owner combo
    //
    RECT rcCombo;
    GetClientRect(m_hwndOwnerCombo, &rcCombo);
    SetWindowPos(m_hwndOwnerCombo,
                 NULL,
                 0, 0,
                 rcCombo.right - rcCombo.left,
                 200,
                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);
}


//
// Determine if two volume root strings refer to the same volume.
// With volume mount points, "C:\" and "D:\DriveC" could refer to the
// same physical volume.  To differentiate we need to examine the unique
// volume name GUID strings.
//
HRESULT 
CFileOwnerDialog::IsSameVolume(
    LPCTSTR pszRoot1,
    LPCTSTR pszRoot2
    )
{
    TCHAR szVolGUID1[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    HRESULT hr = S_FALSE;

    //
    // GetVolumeNameForVolumeMountPoint requires trailing backslash on paths.
    //
    lstrcpyn(szTemp, pszRoot1, ARRAYSIZE(szTemp));
    if (!PathAddBackslash(szTemp))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        if (GetVolumeNameForVolumeMountPoint(szTemp, szVolGUID1, ARRAYSIZE(szVolGUID1)))
        {
            TCHAR szVolGUID2[MAX_PATH];
            lstrcpyn(szTemp, pszRoot2, ARRAYSIZE(szTemp));
            if (!PathAddBackslash(szTemp))
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                if (GetVolumeNameForVolumeMountPoint(szTemp, szVolGUID2, ARRAYSIZE(szVolGUID2)))
                {
                    if (0 == lstrcmpi(szVolGUID1, szVolGUID2))
                        hr = S_OK;
                }
            }
        }
    }
    return hr;
}

//
// Let the user browse for a folder.
// The selected folder path is returned in *pstrFolder.
//
bool
CFileOwnerDialog::BrowseForFolder(
    HWND hwndParent,
    CString *pstrFolder
    )
{
    bool bResult = false;
    BROWSEINFO bi;
    ZeroMemory(&bi, sizeof(bi));

    CString strTitle(m_hInstance, IDS_BROWSEFORFOLDER);

    bi.hwndOwner      = hwndParent;
    bi.pidlRoot       = NULL;       // Start at desktop.
    bi.pszDisplayName = NULL;
    bi.lpszTitle      = strTitle.Cstr();
    //
    // FEATURE:  Setting the BIF_EDITBOX flag causes SHBrowseForFolder to invoke
    //          autocomplete through SHAutoComplete (in shlwapi).  SHAutoComplete
    //          loads browseui.dll to implement the autocomplete feature.  The bad
    //          part is that SHAutoComplete also unloads browseui.dll before it
    //          returns, resulting in calls to the unloaded WndProc.  I've notified
    //          ReinerF about this.  Turning off the BIF_EDITBOX bit prevents
    //          autocomplete from being used and thus prevents the problem.
    //          I want the edit box.  Turn it back on once they fix this bug.
    //
    //          brianau [1/30/97]
    //
    bi.ulFlags        = BIF_RETURNONLYFSDIRS; // | BIF_EDITBOX;
    bi.lpfn           = BrowseForFolderCallback;
    bi.lParam         = (LPARAM)pstrFolder;
    bi.iImage         = 0;

    bResult = boolify(SHBrowseForFolder(&bi));
    return bResult;
}


//
// Callback called by SHBrowseForFolder.  Writes selected folder path
// to CString object who's pointer is passed in lpData arg.
//
int
CFileOwnerDialog::BrowseForFolderCallback(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::BrowseForFolderCallback")));
    CString *pstrFolder = (CString *)lpData;

    if (BFFM_SELCHANGED == uMsg)
    {
        SHGetPathFromIDList((LPCITEMIDLIST)lParam, pstrFolder->GetBuffer(MAX_PATH));
        pstrFolder->ReleaseBuffer();
    }
    return 0;
}


//
// Builds a double-nul terminated list of file paths from the listview
// along with an array of "item handle" objects that acts as a cross-
// reference between the list items, items in the listview and items
// in the file owner list.  Each handle contains an owner index and
// file index into the file owner list.  Each handle is also the value
// stored as the lParam in the listview items.
// Both pList and prgItemHandles arguments are optional.  Although,
// calling with neither non-null is sort of useless.
//
void
CFileOwnerDialog::BuildListOfSelectedFiles(
    HWND hwndLV,
    DblNulTermList *pList,
    CArray<COwnerListItemHandle> *prgItemHandles
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::BuildListOfSelectedFiles")));
    int iItem = -1;
    CPath strPath;
    LV_ITEM item;

    if (NULL != prgItemHandles)
        prgItemHandles->Clear();
    while(-1 != (iItem = ListView_GetNextItem(hwndLV, iItem, LVNI_SELECTED)))
    {
        item.iSubItem = 0;
        item.iItem    = iItem;
        item.mask     = LVIF_PARAM;
        if (-1 != ListView_GetItem(hwndLV, &item))
        {
            COwnerListItemHandle hItem(item.lParam);
            m_OwnerList.GetFileFullPath(hItem.OwnerIndex(),
                                        hItem.FileIndex(),
                                        &strPath);
            if (pList)
                pList->AddString(strPath);
            if (prgItemHandles)
                prgItemHandles->Append(hItem);
        }
    }
}



//
// Given an item "handle", find it's entry in the listview.
//
int
CFileOwnerDialog::FindItemFromHandle(
    HWND hwndLV,
    const COwnerListItemHandle& handle
    )
{
    LV_FINDINFO lvfi;
    lvfi.flags  = LVFI_PARAM;
    lvfi.lParam = handle;
    return ListView_FindItem(hwndLV, -1, &lvfi);
}


//
// Scans an array of item handles and removes all corresponding
// items from the listview.
//
void
CFileOwnerDialog::RemoveListViewItems(
    HWND hwndLV,
    const CArray<COwnerListItemHandle>& rgItemHandles
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::RemoveListViewItems")));
    LV_ITEM item;
    CPath strPath;

    CAutoSetRedraw autoredraw(hwndLV, false);
    int cHandles = rgItemHandles.Count();
    for (int iHandle = 0; iHandle < cHandles; iHandle++)
    {
        COwnerListItemHandle handle = rgItemHandles[iHandle];
        int iItem = FindItemFromHandle(hwndLV, handle);
        if (-1 != iItem)
        {
            int iOwner = handle.OwnerIndex();
            int iFile  = handle.FileIndex();
            m_OwnerList.GetFileFullPath(iOwner, iFile, &strPath);

            if ((DWORD)-1 == GetFileAttributes(strPath))
            {
                //
                // File doesn't exist any more.
                // Delete from the listview.
                // Mark it as "deleted" in the ownerlist container.
                //
                ListView_DeleteItem(hwndLV, iItem);
                m_OwnerList.MarkFileDeleted(iOwner, iFile);
                DBGPRINT((DM_VIEW, DL_LOW, TEXT("Removed item %d \"%s\""),
                         iItem, strPath.Cstr()));
            }
        }
    }
    //
    // Refresh the owner combo to update the file counts.
    //
    InitializeOwnerCombo(m_OwnerList, m_hwndOwnerCombo);
}


//
// Delete the files selected in the listview.
// Files deleted are removed from the listview.
//
void
CFileOwnerDialog::DeleteSelectedFiles(
    HWND hwndLV
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::DeleteSelectedFiles")));
    DblNulTermList list(1024);  // 1024 is the buffer growth size in chars.
    CArray<COwnerListItemHandle> rgItemHandles;

    BuildListOfSelectedFiles(hwndLV, &list, &rgItemHandles);
    if (0 < list.Count())
    {
        SHFILEOPSTRUCT fo;
        fo.hwnd   = m_hwndDlg;
        fo.wFunc  = FO_DELETE;
        fo.pFrom  = list;
        fo.pTo    = NULL;
        fo.fFlags = 0;

        if (0 != SHFileOperation(&fo))
        {
            DBGERROR((TEXT("SHFileOperation [FO_DELETE] failed")));
        }
        //
        // Remove listview items if their files were really deleted.
        //
        RemoveListViewItems(hwndLV, rgItemHandles);
    }
}


//
// Move the selected files to a new location.
// Moved files are removed from the listview.
//
void
CFileOwnerDialog::MoveSelectedFiles(
    HWND hwndLV,
    LPCTSTR pszDest
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::DeleteSelectedFiles")));
    DblNulTermList list(1024);  // 1024 is the buffer growth size in chars.
    CArray<COwnerListItemHandle> rgItemHandles;

    BuildListOfSelectedFiles(hwndLV, &list, &rgItemHandles);
    if (0 < list.Count())
    {
        CPath strDest(pszDest);
        if (1 == list.Count())
        {
            //
            // If we have only a single file we MUST create a fully-qualified
            // path to the destination file.  Oddities in the shell's move/copy
            // engine won't let us pass merely a destination folder in the
            // case where that folder doesn't exist.  If we give the full path
            // including filename we'll get the "folder doesn't exist, create
            // now?" messagebox as we would expect.  If we're moving multiple
            // files the shell accepts a single directory path.
            //
            LPCTSTR psz;
            DblNulTermListIter iter(list);
            if (iter.Next(&psz))
            {
                CPath strSrc(psz);           // Copy the source
                CPath strFile;               
                strSrc.GetFileSpec(&strFile);// Extract the filename.
                strDest.Append(strFile);     // Append to the dest path.
            }
        }
            
        SHFILEOPSTRUCT fo;
        fo.hwnd   = m_hwndDlg;
        fo.wFunc  = FO_MOVE;
        fo.pFrom  = list;
        fo.pTo    = strDest;
        fo.fFlags = FOF_RENAMEONCOLLISION;

        if (0 != SHFileOperation(&fo))
        {
            DBGERROR((TEXT("SHFileOperation [FO_MOVE] failed")));
        }
        //
        // Remove listview items if their file was really deleted.
        //
        RemoveListViewItems(hwndLV, rgItemHandles);
    }
}


//
// Get the SID to use for taking ownership of files.
// First try to get the first group SID with the SE_GROUP_OWNER attribute.
// If none found, use the operator's account SID.  The SID is in a
// dynamic buffer attached to the ptrSid autoptr argument.
//
HRESULT
CFileOwnerDialog::GetOwnershipSid(
    array_autoptr<BYTE> *ptrSid
    )
{
    HRESULT hr  = E_FAIL;
    DWORD dwErr = 0;

    //
    // Get the token handle. First try the thread token then the process
    // token.  If these fail we return early.  No sense in continuing
    // on if we can't get a user token.
    //
    CWin32Handle hToken;
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_READ,
                         TRUE,
                         hToken.HandlePtr()))
    {
        if (ERROR_NO_TOKEN == GetLastError())
        {
            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_READ,
                                  hToken.HandlePtr()))
            {
                dwErr = GetLastError();
                DBGERROR((TEXT("Error %d opening process token"), dwErr));
                return HRESULT_FROM_WIN32(dwErr);
            }
        }
        else
        {
            dwErr = GetLastError();
            DBGERROR((TEXT("Error %d opening thread token"), dwErr));
            return HRESULT_FROM_WIN32(dwErr);
        }
    }

    //
    // Get the required size of the group token information buffer.
    //
    array_autoptr<BYTE> ptrTokenInfo;
    DWORD cbTokenInfo = 0;

    if (!GetTokenInformation(hToken,
                             TokenGroups,
                             NULL,
                             cbTokenInfo,
                             &cbTokenInfo))
    {
        dwErr = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == dwErr)
        {
            ptrTokenInfo = new BYTE[cbTokenInfo];
        }
        else
        {
            dwErr = GetLastError();
            DBGERROR((TEXT("Error %d getting TokenGroups info [for size]"), dwErr));
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }

    //
    // Get the group token information.
    //
    if (NULL != ptrTokenInfo.get())
    {
        if (!GetTokenInformation(hToken,
                                 TokenGroups,
                                 ptrTokenInfo.get(),
                                 cbTokenInfo,
                                 &cbTokenInfo))
        {
            dwErr = GetLastError();
            DBGERROR((TEXT("Error %d getting TokenGroups info"), dwErr));
            hr = HRESULT_FROM_WIN32(dwErr);
        }
        else
        {
            //
            // Extract the first SID with the GROUP_OWNER bit set.
            //
            TOKEN_GROUPS *ptg = (TOKEN_GROUPS *)ptrTokenInfo.get();
            DBGASSERT((NULL != ptg));
            for (DWORD i = 0; i < ptg->GroupCount; i++)
            {
                SID_AND_ATTRIBUTES *psa = (SID_AND_ATTRIBUTES *)&ptg->Groups[i];
                DBGASSERT((NULL != psa));
                if (SE_GROUP_OWNER & psa->Attributes)
                {
                    int cbSid = GetLengthSid(psa->Sid);
                    *ptrSid = new BYTE[cbSid];
                    CopySid(cbSid, ptrSid->get(), psa->Sid);
                    hr = NOERROR;
                    break;
                }
            }
        }
    }

    if (FAILED(hr))
    {
        //
        // Didn't find a SID from the group information.
        // Use the operator's SID.
        //
        cbTokenInfo = 0;
        if (!GetTokenInformation(hToken,
                                 TokenUser,
                                 NULL,
                                 cbTokenInfo,
                                 &cbTokenInfo))
        {
            dwErr = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == dwErr)
            {
                ptrTokenInfo = new BYTE[cbTokenInfo];
            }
            else
            {
                DBGERROR((TEXT("Error %d getting TokenUser info [for size]"), dwErr));
                hr = HRESULT_FROM_WIN32(dwErr);
            }
        }

        if (SUCCEEDED(hr))
        {
            //
            // Get the user token information.
            //
            if (!GetTokenInformation(hToken,
                                     TokenUser,
                                     ptrTokenInfo.get(),
                                     cbTokenInfo,
                                     &cbTokenInfo))
            {
                dwErr = GetLastError();
                DBGERROR((TEXT("Error %d getting TokenUser info"), dwErr));
                hr = HRESULT_FROM_WIN32(dwErr);
            }
            else
            {
                SID_AND_ATTRIBUTES *psa = (SID_AND_ATTRIBUTES *)ptrTokenInfo.get();
                DBGASSERT((NULL != psa));
                int cbSid = GetLengthSid(psa->Sid);
                *ptrSid = new BYTE[cbSid];
                CopySid(cbSid, ptrSid->get(), psa->Sid);
                hr = NOERROR;
            }
        }
    }
    if (SUCCEEDED(hr) && NULL != ptrSid->get() && !IsValidSid(ptrSid->get()))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
    }
    return hr;
}


//
// Transfers ownership of selected files in the listview to the
// currently logged-on user.
//
HRESULT
CFileOwnerDialog::TakeOwnershipOfSelectedFiles(
    HWND hwndLV
    )
{
    HRESULT hr = NOERROR;
    DWORD dwErr = 0;
    CArray<COwnerListItemHandle> rgItemHandles;
    
    BuildListOfSelectedFiles(hwndLV, NULL, &rgItemHandles);
    if (0 == rgItemHandles.Count())
        return S_OK;

    array_autoptr<BYTE> ptrSid;
    hr = GetOwnershipSid(&ptrSid);
    if (FAILED(hr))
        return hr;

    CPath strFile;
    int cHandles = rgItemHandles.Count();
    for (int i = 0; i < cHandles; i++)
    {
        COwnerListItemHandle handle = rgItemHandles[i];
        int iItem = FindItemFromHandle(hwndLV, handle);
        if (-1 != iItem)
        {
            SECURITY_DESCRIPTOR sd;
            if (InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
            {
                int iOwner = handle.OwnerIndex();
                int iFile  = handle.FileIndex();
                m_OwnerList.GetFileFullPath(iOwner, iFile, &strFile);
                if (SetSecurityDescriptorOwner(&sd, ptrSid.get(), FALSE))
                {
                    if (SetFileSecurity(strFile, OWNER_SECURITY_INFORMATION, &sd))
                    {
                        ListView_DeleteItem(hwndLV, iItem);
                        m_OwnerList.MarkFileDeleted(iOwner, iFile);
                    }
                    else
                    {
                        dwErr = GetLastError();
                        DBGERROR((TEXT("Error %d setting new owner for \"%s\""),
                                 dwErr, strFile.Cstr()));
                        hr = HRESULT_FROM_WIN32(dwErr);
                    }
                }
                else
                {
                    dwErr = GetLastError();
                    DBGERROR((TEXT("Error %d setting security descriptor owner"), dwErr));
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
            }
            else
            {
                dwErr = GetLastError();
                DBGERROR((TEXT("Error %d initing security descriptor"), GetLastError()));
                hr = HRESULT_FROM_WIN32(dwErr);
            }
        }
        else
        {
            DBGERROR((TEXT("Can't find listview item for owner %d, file %d"),
                     handle.OwnerIndex(), handle.FileIndex()));
        }
    }
    //
    // Refresh the owner combo with the new file counts.
    //
    InitializeOwnerCombo(m_OwnerList, m_hwndOwnerCombo);
    return hr;
}



//
// The original code for listing files owned by a user was
// contributed by MarkZ.  I made some minor modifications
// to fit it into the diskquota project and make it more
// exception safe.
//
inline VOID *
Add2Ptr(VOID *pv, ULONG cb)
{
    return((BYTE *) pv + cb);
}

inline ULONG
QuadAlign( ULONG Value )
{
    return (Value + 7) & ~7;
}


//
// Add files owned by a particular user on a particular volume.
//
HRESULT
CFileOwnerDialog::AddFilesToOwnerList(
    LPCTSTR pszVolumeRoot,
    HANDLE hVolumeRoot,
    IDiskQuotaUser *pOwner,
    COwnerList *pOwnerList
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::AddFilesToOwnerList")));
    DBGASSERT((NULL != hVolumeRoot));
    DBGASSERT((NULL != pOwner));
    DBGASSERT((NULL != pOwnerList));

    struct
    {
        ULONG Restart;
        BYTE Sid[MAX_SID_LEN];
    }FsCtlInput;

    NTSTATUS status = ERROR_SUCCESS;

    if (m_bAbort)
    {
        return S_OK;
    }

    //
    // Get owner's SID.
    //
    HRESULT hr = pOwner->GetSid(FsCtlInput.Sid, sizeof(FsCtlInput.Sid));
    if (FAILED(hr))
    {
        DBGERROR((TEXT("IDiskQuotaUser::GetSid failed with hr = 0x%08X"), hr));
        return hr;
    }

    //
    // Add the owner to the owner-file list.
    //
    int iOwner = pOwnerList->AddOwner(pOwner);

    IO_STATUS_BLOCK iosb;
    FsCtlInput.Restart = 1;
    BYTE Output[1024];
    bool bPathIsRemote = false;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;

    //
    // Determine if the volume is a remote device.  This will affect
    // our handling of the paths returned by NtQueryInformationFile.
    //
    status = NtQueryVolumeInformationFile(
                    hVolumeRoot,
                    &iosb,
                    &DeviceInfo,
                    sizeof(DeviceInfo),
                    FileFsDeviceInformation);
                    
    if (NT_SUCCESS(status))
    {
        bPathIsRemote = (FILE_REMOTE_DEVICE == DeviceInfo.Characteristics);
    }

    while (!m_bAbort)
    {
        status = NtFsControlFile(hVolumeRoot,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &iosb,
                                 FSCTL_FIND_FILES_BY_SID,
                                 &FsCtlInput,
                                 sizeof(FsCtlInput),
                                 Output,
                                 sizeof(Output));

        FsCtlInput.Restart = 0;

        if (!NT_SUCCESS(status) && STATUS_BUFFER_OVERFLOW != status)
        {
            DBGERROR((TEXT("NtFsControlFile failed with status 0x%08X"), status));
            return HRESULT_FROM_NT(status);
        }

        if (0 == iosb.Information)
        {
            //
            // No more data.
            //
            break;
        }

        PFILE_NAME_INFORMATION pFileNameInfo = (PFILE_NAME_INFORMATION)Output;

        while (!m_bAbort && ((PBYTE)pFileNameInfo < Output + iosb.Information))
        {
            ULONG Length = sizeof(FILE_NAME_INFORMATION) - sizeof(WCHAR) +
                           pFileNameInfo->FileNameLength;

            CNtHandle hChild;
            WCHAR szChild[MAX_PATH];
            ULONG cbWrite = min(pFileNameInfo->FileNameLength, sizeof(szChild));

            RtlMoveMemory(szChild, pFileNameInfo->FileName, cbWrite);
                          
            szChild[cbWrite / sizeof(WCHAR)] = L'\0';
            status = OpenNtObject(szChild,
                                  hVolumeRoot,
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                                  FILE_READ_ATTRIBUTES,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  FILE_OPEN,
                                  hChild.HandlePtr());

            if (!NT_SUCCESS(status))
            {
                DBGERROR((TEXT("Unable to open file \"%s\".  Status = 0x%08X"),
                         szChild, status));
            }
            else if (!m_bAbort)
            {
                //
                // Directory entries get a slightly different treatment so
                // we need to know if an entry is a directory or not.
                //
                bool bIsDirectory = false;
                IO_STATUS_BLOCK iosb2;
                FILE_BASIC_INFORMATION fbi;
                status = NtQueryInformationFile(hChild,
                                                &iosb2,
                                                &fbi,
                                                sizeof(fbi),
                                                FileBasicInformation);
                if (!NT_SUCCESS(status))
                {
                    DBGERROR((TEXT("NtQueryInformationFile failed with status 0x%08X for \"%s\""),
                              status, szChild));
                }
                else if (0 != (FILE_ATTRIBUTE_DIRECTORY & fbi.FileAttributes))
                {
                    bIsDirectory = true;
                }
                
                //
                // Get the file's name (full path).
                //
                WCHAR szFile[MAX_PATH + 10];
                status = NtQueryInformationFile(hChild,
                                                &iosb2,
                                                szFile,
                                                sizeof(szFile),
                                                FileNameInformation);

                if (!NT_SUCCESS(status))
                {
                    DBGERROR((TEXT("NtQueryInformation file failed with status 0x%08X for \"%s\""),
                              status, szChild));
                }
                else if (!m_bAbort)
                {
                    PFILE_NAME_INFORMATION pfn = (PFILE_NAME_INFORMATION)szFile;
                    pfn->FileName[pfn->FileNameLength / sizeof(WCHAR)] = L'\0';
                    CPath path;

                    //
                    // If the path is remote, NtQueryInformationFile returns
                    // a string like this:
                    //
                    //  \server\share\dir1\dir2\file.ext
                    //
                    // If the path is local, NtQueryInformationFile returns
                    // a string like this:
                    //
                    //  \dir1\dir2\file.ext
                    //
                    // For remote paths we merely prepend a '\' to create a
                    // valid UNC path.  For local paths we prepend the local
                    // drive specification.
                    //
                    if (bPathIsRemote)
                    {
                        path = L"\\";
                        path += CString(pfn->FileName);
                    }
                    else
                    {
                        path = pszVolumeRoot;
                        path.Append(pfn->FileName);
                    }
                    DBGPRINT((DM_VIEW, DL_LOW, TEXT("Adding \"%s\""), path.Cstr()));
                    pOwnerList->AddFile(iOwner, path, bIsDirectory);
                }
            }
            hChild.Close();

            pFileNameInfo =
                (PFILE_NAME_INFORMATION) Add2Ptr(pFileNameInfo, QuadAlign(Length));
        }
    }
    return NOERROR;
}


//
// Build a list of files owned by a set of users on a particular volume.
// pszVolumeRoot is the volume root directory (i.e. "C:\").
// rgpOwners is an array of user object pointers, one for each owner.
// pOwnerList is the container where the resulting filenames are placed.
// Calls AddFilesToOwnerList() for each owner in rgpOwners.
//
HRESULT
CFileOwnerDialog::BuildFileOwnerList(
    LPCTSTR pszVolumeRoot,
    const CArray<IDiskQuotaUser *>& rgpOwners,
    COwnerList *pOwnerList
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::BuildFileOwnerList")));
    HRESULT hr = NOERROR;
    CNtHandle hVolumeRoot;
    NTSTATUS status = OpenNtObject(pszVolumeRoot,
                                   NULL,
                                   FILE_SYNCHRONOUS_IO_NONALERT,
                                   FILE_READ_ATTRIBUTES,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   FILE_OPEN,
                                   hVolumeRoot.HandlePtr());

    if (!NT_SUCCESS(status))
        return HRESULT_FROM_NT(status);

    int cOwners = rgpOwners.Count();
    for (int i = 0; i < cOwners && !m_bAbort; i++)
    {
        hr = AddFilesToOwnerList(pszVolumeRoot, hVolumeRoot, rgpOwners[i], pOwnerList);
    }
    return hr;
}


//
// MarkZ had this function in his original implementation so I just
// kept it.  I did need to fix a bug in the original code.  He was
// calling RtlFreeHeap() on str.Buffer for all cases.  This is was
// not applicable in the RtlInitUnicodeString() case where the
// unicode string is merely bound to the pszFile argument.
//
NTSTATUS
CFileOwnerDialog::OpenNtObject (
    LPCWSTR pszFile,
    HANDLE RelatedObject,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;
    bool bFreeString = false;

    if (NULL == RelatedObject)
    {
        RtlDosPathNameToNtPathName_U(pszFile, &str, NULL, NULL);
        bFreeString = true;
    }
    else
    {
        //
        // This just attaches pszFile to the rtl string.
        // We don't free it.
        //
        RtlInitUnicodeString(&str, pszFile);
    }

    InitializeObjectAttributes(&oa,
                               &str,
                               OBJ_CASE_INSENSITIVE,
                               RelatedObject,
                               NULL);

    status = NtCreateFile(ph,
                          DesiredAccess | SYNCHRONIZE,
                          &oa,
                          &isb,
                          NULL,                   // pallocationsize (none!)
                          FILE_ATTRIBUTE_NORMAL,
                          ShareAccess,
                          CreateDisposition,
                          CreateOptions,
                          NULL,                   // EA buffer (none!)
                          0);

    if (bFreeString)
        RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\progress.h ===
#ifndef _INC_DSKQUOTA_PROGRESS_H
#define _INC_DSKQUOTA_PROGRESS_H
///////////////////////////////////////////////////////////////////////////////
/*  File: progress.h

    Description: Declarations for class ProgressDialog.  Any derivative
        classes should also be declared here.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
class ProgressDialog
{
    private:
        UINT   m_idDialogTemplate;
        UINT   m_idProgressBar;
        UINT   m_idTxtDescription;
        UINT   m_idTxtFileName;
        HWND   m_hwndProgressBar;
        BOOL   m_bUserCancelled;

        static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
        INT_PTR SendToProgressBar(UINT, WPARAM, LPARAM);

    protected:

        virtual INT_PTR HandleMessage(HWND, UINT, WPARAM, LPARAM);
        virtual INT_PTR OnInitDialog(HWND, WPARAM, LPARAM);
        virtual INT_PTR OnDestroy(HWND);
        virtual INT_PTR OnCancel(HWND, WPARAM, LPARAM);

    public:
        HWND m_hWnd;

        ProgressDialog(UINT idDialogTemplate,
                       UINT idProgressBar,
                       UINT idTxtDescription,
                       UINT idTxtFileName);

        ~ProgressDialog(VOID);

        UINT DialogID(VOID)
            { return m_idDialogTemplate; }

        BOOL UserCancelled(VOID)
            { return m_bUserCancelled; }

        virtual BOOL Create(HINSTANCE hInstance, HWND hwndParent);
        virtual VOID Destroy(VOID);
        virtual BOOL ProgressBarInit(UINT iMin, UINT iMax, UINT iStep);
        virtual UINT ProgressBarReset(VOID);
        virtual UINT ProgressBarAdvance(UINT iDelta = (UINT)-1);
        virtual UINT ProgressBarSetPosition(UINT iPosition);
        virtual VOID FlushMessages(VOID);
        virtual VOID SetTitle(LPCTSTR pszTitle);
        virtual VOID SetDescription(LPCTSTR pszDescription);
        virtual VOID SetFileName(LPCTSTR pszFileName);
        virtual VOID Show(VOID);
        virtual VOID Hide(VOID);
};

#endif // _INC_DSKQUOTA_PROGRESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\prshtext.h ===
#ifndef _INC_DSKQUOTA_PRSHTEXT_H
#define _INC_DSKQUOTA_PRSHTEXT_H
///////////////////////////////////////////////////////////////////////////////
/*  File: prshtext.h

    Description: DSKQUOTA property sheet extention declaration.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/25/98    Disabled snapin code with #ifdef POLICY_MMC_SNAPIN.  BrianAu
                Switching to ADM-file approach to entering policy
                data.  Keeping snapin code available in case
                we decide to switch back at a later time.
    06/27/98    Added support for mounted volumes.                   BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif

#ifndef _INC_DSKQUOTA_POLICY_H
#   include "policy.h"
#endif

//
// Base class for all DiskQuotaControl property sheet extensions.
//
class DiskQuotaPropSheetExt : public IShellPropSheetExt
{
    private:
        LONG               m_cRef;
        DWORD              m_dwDlgTemplateID;
        DLGPROC            m_lpfnDlgProc;

        static UINT CALLBACK 
        DiskQuotaPropSheetExt::PropSheetPageCallback(
            HWND hwnd,	
            UINT uMsg,	
            LPPROPSHEETPAGE ppsp);

        //
        // Prevent copying.
        //
        DiskQuotaPropSheetExt(const DiskQuotaPropSheetExt&);
        DiskQuotaPropSheetExt& operator = (const DiskQuotaPropSheetExt&);

    protected:
        CVolumeID          m_idVolume;
        HPROPSHEETPAGE     m_hPage;
        PDISKQUOTA_CONTROL m_pQuotaControl;
        INT                m_cOleInitialized;

        //
        // Subclasses can act on these notifications if they wish.
        // These are called from PropSheetPageCallback().
        //
        virtual UINT OnPropSheetPageCreate(LPPROPSHEETPAGE ppsp) 
            { return 1; }
        virtual VOID OnPropSheetPageRelease(LPPROPSHEETPAGE ppsp) { }

        HRESULT GetQuotaController(IDiskQuotaControl **ppqc);


    public:
        DiskQuotaPropSheetExt(VOID);
  
        //
        // Need to call subclass destructor when Release() 
        // destroys "this".
        //
        virtual ~DiskQuotaPropSheetExt(VOID);

        HRESULT Initialize(const CVolumeID& idVolume, 
                           DWORD dwDlgTemplateID,
                           DLGPROC lpfnDlgProc);

        //
        // IUnknown methods.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IShellPropSheetInit methods.
        //
        STDMETHODIMP
        AddPages(
            LPFNADDPROPSHEETPAGE lpfnAddPage,
            LPARAM lParam);

        STDMETHODIMP
        ReplacePage(
            UINT uPageID,
            LPFNADDPROPSHEETPAGE lpfnAddPage,
            LPARAM lParam)
                { return E_NOTIMPL; }
};

#endif // _INC_DSKQUOTA_PRSHTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\prshtext.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: prshtext.cpp

    Description: DSKQUOTA property sheet extention implementation.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    07/03/97    Added m_hrInitialization member.                     BrianAu
    01/23/98    Removed m_hrInitialization member.                   BrianAu
    06/25/98    Disabled snapin code with #ifdef POLICY_MMC_SNAPIN.  BrianAu
                Switching to ADM-file approach to entering policy
                data.  Keeping snapin code available in case
                we decide to switch back at a later time.
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"  // PCH
#pragma hdrstop

#include "dskquota.h"
#include "prshtext.h" 
#include "guidsp.h"

extern LONG g_cLockThisDll;


DiskQuotaPropSheetExt::DiskQuotaPropSheetExt(
    VOID
    ) : m_cRef(0),
        m_dwDlgTemplateID(0),
        m_lpfnDlgProc(NULL),
        m_hPage(NULL),
        m_pQuotaControl(NULL),
        m_cOleInitialized(0)
{
    DBGTRACE((DM_PRSHTEXT, DL_HIGH, TEXT("DiskQuotaPropSheetExt::DiskQuotaPropSheetExt")));
    InterlockedIncrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::~DiskQuotaPropSheetExt

    Description: Destructor for the property sheet extension class.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaPropSheetExt::~DiskQuotaPropSheetExt(VOID)
{
    DBGTRACE((DM_PRSHTEXT, DL_HIGH, TEXT("DiskQuotaPropSheetExt::~DiskQuotaPropSheetExt")));

    if (NULL != m_pQuotaControl)
    {
        m_pQuotaControl->Release();
        m_pQuotaControl = NULL;
    }

    //
    // Call OleUninitialize for each time OleInitialize was called in Initialize().
    //
    while(0 != m_cOleInitialized--)
    {
        DBGASSERT((0 <= m_cOleInitialized)); // Make sure we don't go negative.
        CoUninitialize();
    }

    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown
        and IShellPropSheetExt interfaces.  

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaPropSheetExt::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IShellPropSheetExt == riid)
    {
        *ppvOut = this;
    }

    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaPropSheetExt::AddRef(
    VOID
    )
{
    ULONG cRef = InterlockedIncrement(&m_cRef);
    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaPropSheetExt::AddRef, 0x%08X  %d -> %d\n"), this, cRef - 1, cRef ));
    return cRef;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaPropSheetExt::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaPropSheetExt::Release, 0x%08X  %d -> %d\n"),
             this, cRef + 1, cRef));

    if ( 0 == cRef )
    {   
        delete this;
    }
    return cRef;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::Initialize

    Description: Initializes a new property sheet extension object.

    Arguments:
        idVolume - Reference to a CVolumeID object containing both parsable
                   and displayable names for the volume.  In the case of
                   normal volumes, this is the same string.  In the case
                   of mounted volumes, it may not be depending on what's
                   provided by the OS for the mounted volume.  Most mounted
                   volumes have names like "\\?\Volume{ GUID }\".

        dwDlgTemplateID - Resource ID for the dialog template to use for the
            property sheet.

        lpfnDlgProc - Address of dialog's window message procedure.

    Returns:
        NO_ERROR            - Success.
        ERROR_ACCESS_DENIED (hr) - Read access denied to the device.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/27/98    Replaced volume name arg with CVolumeID arg to       BrianAu
                support mounted volumes.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaPropSheetExt::Initialize(
    const CVolumeID& idVolume,
    DWORD dwDlgTemplateID,
    DLGPROC lpfnDlgProc
    )
{
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != lpfnDlgProc));
    DBGASSERT((0    != dwDlgTemplateID));

    m_idVolume        = idVolume;
    m_dwDlgTemplateID = dwDlgTemplateID;
    m_lpfnDlgProc     = lpfnDlgProc;

    //
    // Volume parsing name will be blank for a snap-in prop page since
    // it isn't displayed on behalf of any particular volume.
    //
    if (!m_idVolume.ForParsing().IsEmpty())
    {
        hResult = CoInitialize(NULL);
        if (SUCCEEDED(hResult))
        {
            IDiskQuotaControl *pqc;
            m_cOleInitialized++;  // Need to call OleUninitialize once more in dtor.

            //
            // Validate that we can use quotas by instantiating the quota control
            // object.  If this fails the user probably doesn't have access
            // to manipulate quotas.
            //
            hResult = GetQuotaController(&pqc);
            if (SUCCEEDED(hResult))
            {
                pqc->Release();
                //
                // Also release the cached m_pQuotaControl ptr.  
                // We don't want to hold open a handle to the volume if our
                // page is not active.
                //
                m_pQuotaControl->Release();
                m_pQuotaControl = NULL;
            }
        }
    }

    return hResult;
}

//
// Get a pointer to the IDiskQuotaControl interface.
// If the cached m_pQuotaControl ptr is non-NULL we merely AddRef this
// and return it to the caller. Otherwise we CoCreate a new controller,
// cache the pointer in m_pQuotaControl and return that.
// 
// History:  
//  Originally we opened the controller in ::Initialize() and cached
//  the pointer in m_pQuotaControl.  The controller remained alive 
//  until the prop SHEET was destroyed.  This was holding open a handle
//  to the volume device which prevented the disk checking function 
//  on the "Tools" page from accessing the volume.  Therefore I 
//  changed the code so that now we call GetQuotaController whenever
//  we want an IDiskQuotaControl pointer.  The caller releases that
//  ptr when done with it.  Whenever the prop page becomes inactive
//  we release the cached m_pQuotaControl.  This ensures that the 
//  code has the volume open only when the page is active.
//  [brianau - 5/21/99]
//  
//
HRESULT
DiskQuotaPropSheetExt::GetQuotaController(
    IDiskQuotaControl **ppqc
    )
{
    HRESULT hr = NOERROR;

    *ppqc = NULL;
    if (NULL == m_pQuotaControl)
    {
        //
        // No cached ptr.  Create a new controller.
        //
        hr = CoCreateInstance(CLSID_DiskQuotaControl,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDiskQuotaControl,
                              (LPVOID *)&m_pQuotaControl);

        if (SUCCEEDED(hr))
        {
            hr = m_pQuotaControl->Initialize(m_idVolume.ForParsing(), TRUE);
            if (FAILED(hr))
            {
                m_pQuotaControl->Release();
                m_pQuotaControl = NULL;
            }
        }
    }

    if (NULL != m_pQuotaControl)
    {
        //
        // Ptr is cached.  Merely addref and return it.
        //
        *ppqc = m_pQuotaControl;
        static_cast<IUnknown *>(*ppqc)->AddRef();
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::AddPages

    Description: Called by the shell when a page is to be added to the property
        sheet.

    Arguments:
        lpfnAddPage - Address of a callback function provided by the shell 
            that is to be called if the property page creation succedes.

        lParam - Parameter to pass to lpfnAddPage function.

    Returns:
        NO_ERROR            - Success.
        E_FAIL              - Failed to create or add page.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaPropSheetExt::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam
    )
{
    HRESULT hResult = E_FAIL; // Assume failure.

    PROPSHEETPAGE psp;

    psp.dwSize          = sizeof(psp);
    psp.dwFlags         = PSP_USECALLBACK | PSP_USEREFPARENT;
    psp.hInstance       = g_hInstDll;
    psp.pszTemplate     = MAKEINTRESOURCE(m_dwDlgTemplateID);
    psp.hIcon           = NULL;
    psp.pszTitle        = NULL;
    psp.pfnDlgProc      = m_lpfnDlgProc;
    psp.lParam          = (LPARAM)this;
    psp.pcRefParent     = (UINT *)& g_cRefThisDll;
    psp.pfnCallback     = (LPFNPSPCALLBACK)PropSheetPageCallback;

    m_hPage = CreatePropertySheetPage(&psp);
    if (NULL != m_hPage)
    {
        if (!lpfnAddPage(m_hPage, lParam))
        {
            DBGERROR((TEXT("PRSHTEXT - Failed to add page.\n")));
            DestroyPropertySheetPage(m_hPage);
            m_hPage = NULL;
        }
    }
    else
    {
        DBGERROR((TEXT("PRSHTEXT - CreatePropertySheetPage failed.\n")));
    }
    if (NULL != m_hPage)
    {
        //
        // Incr ref count to keep the extension object alive.
        // The shell will release it as soon as the page is created.
        // We'll release it on PSPCB_RELEASE in PropSheetPageCallback.
        //
        AddRef();
        hResult = NO_ERROR;
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::PropSheetPageCallback

    Description: Called by the property sheet code when the property page
        is being created and again when it is being destroyed.  This gives the
        page a chance to act at these critical points.  We primarily use it
        to call Release() on the page extension which calls the virtual
        destructor, ultimately destroying the VolumePropPage or FolderPropPage
        object.

    Arguments:
        hwnd - Always NULL (according to SDK docs).

        uMsg - PSPCB_CREATE  = Creating page.
               PSPCB_RELEASE = Destroying page.

        ppsp - Pointer to the PROPSHEETPAGE structure for the page.

    Returns:
        Return value is ignore when uMsg is PSPCB_RELEASE.
        On PSPCB_CREATE, returning 0 instructs the PropertySheet to NOT
            display the page.  1 means OK to display page.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/12/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT CALLBACK 
DiskQuotaPropSheetExt::PropSheetPageCallback(
    HWND hwnd,	
    UINT uMsg,	
    LPPROPSHEETPAGE ppsp	
    )
{
    UINT uReturn = 1;
    DiskQuotaPropSheetExt *pThis = (DiskQuotaPropSheetExt *)ppsp->lParam;
    DBGASSERT((NULL != pThis));

    switch(uMsg)
    {
        case PSPCB_CREATE:
            //
            // uReturn == 0 means Don't create the prop page.
            //
            uReturn = pThis->OnPropSheetPageCreate(ppsp);
            break;

        case PSPCB_RELEASE:
            //
            // uReturn is ignored for this uMsg.
            //
            pThis->OnPropSheetPageRelease(ppsp);
            //
            // This will release the extension and call the virtual
            // destructor (which will destroy the prop page object).
            //
            pThis->Release();
            break;
    }
    return uReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\uiutils.h ===
#ifndef __INC_DSKQUOTA_UIUTILS_H
#define __INC_DSKQUOTA_UIUTILS_H

//
// Simple class for automating the display and resetting of a wait cursor.
//
class CAutoWaitCursor
{
    public:
        CAutoWaitCursor(void)
            : m_hCursor(SetCursor(LoadCursor(NULL, IDC_WAIT)))
            { ShowCursor(TRUE); }

        ~CAutoWaitCursor(void)
            { Reset(); }

        void Reset(void);

    private:
        HCURSOR m_hCursor;
};

bool UseWindowsHelp(int idCtl);

#endif //__INC_DSKQUOTA_UIUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\uiutils.cpp ===
#include "pch.h"
#pragma hdrstop

#include "uiutils.h"

void
CAutoWaitCursor::Reset(
    void
    )
{
    ShowCursor(FALSE);
    if (NULL != m_hCursor)
        SetCursor(m_hCursor);
    m_hCursor = NULL;
}


bool UseWindowsHelp(int idCtl)
{
    bool bUseWindowsHelp = false;
    switch(idCtl)
    {
        case IDOK:
        case IDCANCEL:
        case IDC_STATIC:
            bUseWindowsHelp = true;
            break;

        default:
            break;
    }
    return bUseWindowsHelp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dskquoui.rc
//
#define IDM_LISTVIEW_MENU               105
#define IDD_PROPPAGE_USERQUOTA          106
#define IDD_PROPPAGE_VOLQUOTA           107
#define IDM_CONTEXT_MENU                114
#define IDI_QUOTA                       117
#define IDI_SINGLE_USER                 130
#define IDI_MULTI_USER                  131
#define IDI_OKBUBBLE                    132
#define IDI_WARNERR                     134
#define IDR_KBDACCEL                    140
#define IDD_FINDUSER                    146
#define IDD_PROGRESS                    147
#define IDD_YNTOALL                     149
#define IDI_QUOTA_OPEN                  150
#define IDD_PROPPAGE_POLICY             151
#define IDD_OWNERSANDFILES              152
#define IDD_ADDUSER                     154
#define IDC_TOOLBAR                     500
#define IDC_TOOLBAR_COMBO               502
#define IDC_TXT_QUOTA_STATUS            1001
#define IDC_CBX_ENABLE_QUOTA            1002
#define IDC_CBX_DENY_LIMIT              1005
#define IDC_RBN_DEF_NOLIMIT             1006
#define IDC_RBN_DEF_LIMIT               1007
#define IDC_EDIT_DEF_LIMIT              1008
#define IDC_EDIT_DEF_THRESHOLD          1009
#define IDC_BTN_DETAILS                 1012
#define IDC_BTN_EVENTLOG                1013
#define IDC_TXT_WARN_LEVEL              1017
#define IDC_GRP_ACTIONS                 1019
#define IDC_TXT_USERNAME                1020
#define IDC_GRP_DEFAULTS                1021
#define IDC_TXT_SPACEUSED               1023
#define IDC_TXT_SPACEREMAINING          1025
#define IDC_EDIT_USER_LIMIT             1026
#define IDC_EDIT_USER_THRESHOLD         1027
#define IDC_RBN_USER_LIMIT              1028
#define IDC_RBN_USER_NOLIMIT            1029
#define IDC_CMB_DEF_LIMIT               1037
#define IDC_CMB_DEF_THRESHOLD           1038
#define IDC_CMB_USER_LIMIT              1040
#define IDC_CMB_USER_THRESHOLD          1041
#define IDC_ICON_USER                   1043
#define IDC_ICON_USERSTATUS             1044
#define IDC_TRAFFIC_LIGHT               1045
#define IDR_AVI_TRAFFIC                 1046
#define IDC_CMB_FINDUSER                1047
#define IDC_TXT_FINDUSER                1048
#define IDC_PROGRESS_BAR                1049
#define IDC_CBX_YNTOALL                 1051
#define IDC_TXT_YNTOALL                 1052
#define IDC_TXT_PROGRESS_DESCRIPTION    1054
#define IDC_TXT_PROGRESS_FILENAME       1055
#define IDC_TXT_QUOTA_STATUS_LABEL      1064
#define IDC_LV_OWNERDLG                 1071
#define IDC_CMB_OWNERDLG_OWNERS         1073
#define IDC_RBN_POLICY_FIXED            1076
#define IDC_RBN_POLICY_REMOVABLE        1077
#define IDC_BTN_OWNERDLG_DELETE         1079
#define IDC_BTN_OWNERDLG_TAKE           1080
#define IDC_BTN_OWNERDLG_MOVETO         1081
#define IDC_BTN_OWNERDLG_BROWSE         1082
#define IDC_EDIT_OWNERDLG_MOVETO        1083
#define IDC_TXT_OWNERDLG_HEADER         1084
#define IDC_CBX_LOG_OVERLIMIT           1088
#define IDC_CBX_LOG_OVERWARNING         1089
#define IDC_TXT_DEFAULTS                1090
#define IDC_TXT_LOGGING                 1091
#define IDC_LBL_SPACEUSED               1092
#define IDC_LBL_SPACEREMAINING          1093
#define IDC_STATIC2                     1094
#define IDC_CBX_OWNERDLG_EXCLUDEFILES   1095
#define IDC_CBX_OWNERDLG_EXCLUDEDIRS    1096
#define IDM_QUOTA_NEW                   40001
#define IDM_QUOTA_EDIT                  40002
#define IDM_VIEW_TOOLBAR                40003
#define IDM_VIEW_STATUSBAR              40004
#define IDM_VIEW_ARRANGE_BYNAME         40010
#define IDM_VIEW_ARRANGE_BYUSED         40011
#define IDM_VIEW_ARRANGE_BYLIMIT        40012
#define IDM_VIEW_ARRANGE_BYTHRESHOLD    40013
#define IDM_VIEW_ARRANGE_BYPERCENT      40014
#define IDM_VIEW_REFRESH                40015
#define IDM_QUOTA_PROPERTIES            40016
#define IDM_QUOTA_CLOSE                 40017
#define IDM_HELP_TOPICS                 40018
#define IDM_HELP_ABOUT                  40019
#define IDM_EDIT_SELECTALL              40020
#define IDM_EDIT_INVERTSELECTION        40021
#define IDM_VIEW_SHOWFOLDER             40025
#define IDM_QUOTA_DELETE                40026
#define IDM_HELP_ABOUTNT                40027
#define IDM_VIEW_ARRANGE_BYFOLDER       40035
#define IDM_VIEW_ARRANGE_BYSTATUS       40036
#define IDM_DEBUG_DUMP                  40038
#define IDM_CLEAR_CACHE                 40039
#define IDM_EDIT_UNDO                   40040
#define IDM_EDIT_COPY                   40041
#define IDM_EDIT_FIND                   40042
#define IDM_EDIT_FIND_LIST              40043
#define IDM_QUOTA_IMPORT                40044
#define IDM_QUOTA_EXPORT                40045
#define IDS_WINDOWS                     40500
#define IDS_TOOLBAR_COMBO               40517
#define IDS_PROGRESS_IMPORTING          40518
#define IDS_PROGRESS_DELETING           40519
#define IDS_STATUS_OK                   40523
#define IDS_STATUS_WARNING              40524
#define IDS_STATUS_OVERLIMIT            40525
#define IDS_STATUS_UNKNOWN              40526
#define IDS_STATUS_DISABLED             40527
#define IDS_STATUS_ACTIVE               40528
#define IDS_STATUS_REBUILDING           40530
#define IDS_TITLE_DISK_QUOTA            40531
#define IDS_TITLE_COL_FOLDER            40532
#define IDS_TITLE_COL_USERNAME          40533
#define IDS_TITLE_COL_STATUS            40534
#define IDS_TITLE_COL_AMTUSED           40535
#define IDS_TITLE_COL_PCTUSED           40536
#define IDS_TITLE_COL_LIMIT             40537
#define IDS_TITLE_COL_THRESHOLD         40538
#define IDS_REPORT_HEADER_FOLDER        40539
#define IDS_REPORT_HEADER_USERNAME      40540
#define IDS_REPORT_HEADER_STATUS        40541
#define IDS_REPORT_HEADER_AMTUSED       40542
#define IDS_REPORT_HEADER_LIMIT         40543
#define IDS_REPORT_HEADER_THRESHOLD     40544
#define IDS_REPORT_HEADER_PCTUSED       40545
#define IDS_QUOTA_USED_SINGLEUSER       40546
#define IDS_TITLE_MULTIUSER             40547
#define IDS_TITLE_EDIT_USER             40548
#define IDS_TITLE_ADD_USER              40549
#define IDS_NOADD_EXISTING_USER         40550
#define IDS_NOADD_UNKNOWN_USER          40551
#define IDS_STATUSBAR_ITEMCOUNT         40554
#define IDS_STATUSBAR_ITEMCOUNT_STALE   40555
#define IDS_TITLE_MAINWINDOW            40556
#define IDS_USER_ACCOUNT_UNAVAILABLE    40557
#define IDS_USER_ACCOUNT_UNRESOLVED     40558
#define IDS_USER_ACCOUNT_UNKNOWN        40559
#define IDS_USER_ACCOUNT_INVALID        40560
#define IDS_USER_ACCOUNT_DELETED        40561
#define IDS_NOT_APPLICABLE              40562
#define IDS_DISABLE_QUOTA_WARNING       40564
#define IDS_ENABLE_QUOTA_WARNING        40565
#define IDS_OUTOFMEMORY                 40566
#define IDS_UNKNOWN_EXCEPTION           40567
#define IDS_UNKNOWN_ERROR               40568
#define IDS_NO_WRITE_ACCESS             40569
#define IDS_WRITE_ERROR                 40570
#define IDS_CANNOT_DELETE_USER          40571
#define IDS_CANNOT_DELETE_USERS         40572
#define IDS_ERROR_DELETE_USER           40573
#define IDS_ERROR_FILE_NOT_FOUND        40574
#define IDS_ERROR_FILE_CORRUPT          40575
#define IDS_ERROR_DDE_EXECUTE           40576
#define IDS_CONFIRM_DELETE_USER         40577
#define IDS_APPLY_SETTINGS_ERROR        40578
#define IDS_CANT_SET_ADMIN_LIMIT        40582
#define IDS_CANT_DELETE_ADMIN_RECORD    40583
#define IDS_USER_NOT_FOUND_IN_LISTVIEW  40584
#define IDS_EXPORT_STREAM_FAILED        40585
#define IDS_EXPORT_STREAM_NOACCESS      40586
#define IDS_EXPORT_STREAM_OUTOFMEMORY   40587
#define IDS_EXPORT_STREAM_INVALIDNAME   40588
#define IDS_EXPORT_STREAM_TOOMANYFILES  40589
#define IDS_EXPORT_STREAM_FILENAME_TEMPLATE 40590
#define IDS_IMPORT_STREAM_INVALID_STREAM 40591
#define IDS_IMPORT_STREAM_READ_ERROR    40592
#define IDS_IMPORT_STREAM_NOACCESS      40593
#define IDS_IMPORT_STREAM_OUTOFMEMORY   40594
#define IDS_IMPORT_STREAM_INVALIDNAME   40595
#define IDS_IMPORT_STREAM_TOOMANYFILES  40596
#define IDS_IMPORT_STREAM_FILENOTFOUND  40597
#define IDS_IMPORT_REPLACE_RECORD       40598
#define IDS_TT_QUOTA_NEW                40599
#define IDS_TT_QUOTA_DELETE             40600
#define IDS_TT_QUOTA_PROPERTIES         40601
#define IDS_TT_EDIT_UNDO                40602
#define IDS_TT_EDIT_FIND                40603
#define IDS_TITLE_EDIT_MULTIUSER        40605
#define IDS_TITLE_GENERAL               40606
#define IDS_TITLE_GETUSER_DIALOG        40607
#define IDS_FMT_ERR_ADDUSER             40608
#define IDS_MULTIPLE                    40609
#define IDS_PROGRESS_ADDUSER            40610
#define IDS_SNAPIN_COLUMN               40611
#define IDS_SNAPIN_RESULTNAME           40613
#define IDS_SNAPIN_SCOPENAME            40614
#define IDS_SNAPIN_NAME                 40615
#define IDS_VERB_OPEN                   40616
#define IDS_SNAPIN_POLICYDLG_TITLE      40617
#define IDS_OWNERDLG_HDR_FILE           40618
#define IDS_OWNERDLG_HDR_FOLDER         40619
#define IDS_OWNERDLG_HDR_OWNER          40620
#define IDS_FMT_ALLOWNERS               40621
#define IDS_FMT_OWNER                   40622
#define IDS_FMT_OWNERDLG_HEADER         40623
#define IDS_BROWSEFORFOLDER             40624
#define IDS_ERROR_MOVETO_SAMEVOL        40625
#define IDS_FMT_DISPLAY_LOGON_CONTAINER 40626
#define IDS_FMT_LOGON_CONTAINER         40627
#define IDS_FMT_DISPLAY_LOGON           40629
#define IDS_TITLE_COL_LOGONNAME         40630
#define IDS_REPORT_HEADER_LOGONNAME     40631
#define IDM_VIEW_ARRANGE_BYLOGONNAME    40632
#define IDS_PROGRESS_SEARCHINGFORFILES  40633
#define IDS_FMT_ERR_WARNOVERLIMIT       40634
#define IDS_FMT_MOUNTEDVOL_DISPLAYNAME  40636
#define IDS_EXPORT_STREAM_FILENAME_TEMPLATE_VOLSN 40637
#define IDS_DLGTITLE_IMPORT             40638
#define IDS_DLGTITLE_EXPORT             40639
#define IDS_FMT_OWNERDLG_FOLDERNAME     40640

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        155
#define _APS_NEXT_COMMAND_VALUE         40047
#define _APS_NEXT_CONTROL_VALUE         1096
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\undo.h ===
#ifndef _INC_DSKQUOTA_UNDO_H
#define _INC_DSKQUOTA_UNDO_H
///////////////////////////////////////////////////////////////////////////////
/*  File: undo.h

    Description: Declarations for classes associated with the "undo" feature.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_DYNARRAY_H
#   include "dynarray.h"
#endif

class UndoList;  // Fwd decl.

//
// Virtual base class for all undo actions.
// UndoList maintains a list of these.
//
class UndoAction
{
    protected:
        PDISKQUOTA_CONTROL m_pQuotaControl; // Ptr to quota control object.
        PDISKQUOTA_USER m_pUser;            // User object affected by action.
        UndoList     *m_pUndoList;          // Containing undo list object.
        LONGLONG      m_llLimit;            // User object's previous quota limit.
        LONGLONG      m_llThreshold;        // Previous quota threshold.

    public:
        UndoAction(PDISKQUOTA_USER pUser, LONGLONG llThreshold, LONGLONG llLimit,
                   PDISKQUOTA_CONTROL pQuotaControl = NULL);
        ~UndoAction(VOID);

        virtual HRESULT Undo(VOID) = 0;

        VOID SetUndoList(UndoList *pUndoList)
            { m_pUndoList = pUndoList; }
};


//
// Class for restoring a deleted record.
//
class UndoDelete : public UndoAction
{
    public:
        UndoDelete(
            PDISKQUOTA_USER pUser,
            LONGLONG llThreshold,
            LONGLONG llLimit
            ) : UndoAction(pUser, llThreshold, llLimit) { }

        HRESULT Undo(VOID);
};


//
// Class for restoring a newly added record (delete it).
//
class UndoAdd : public UndoAction
{
    public:
        UndoAdd(
            PDISKQUOTA_USER pUser,
            PDISKQUOTA_CONTROL pQuotaControl
            ) : UndoAction(pUser, 0, 0, pQuotaControl) { }

        HRESULT Undo(VOID);
};


//
// Class for restoring a record's previous settings.
//
class UndoModify : public UndoAction
{
    public:
        UndoModify(
            PDISKQUOTA_USER pUser,
            LONGLONG llThreshold,
            LONGLONG llLimit
            ) : UndoAction(pUser, llThreshold, llLimit) { }

        HRESULT Undo(VOID);
};


//
// Container for a set of undo actions.
//
class UndoList
{
    private:
        PointerList        m_hList;         // List of undo action object ptrs.
        PointerList       *m_pUserList;     // List of quota user object ptrs.
        HWND               m_hwndListView;  // Listview we'll update.

    public:
        UndoList(PointerList *pUserList, HWND hwndListView)
            : m_pUserList(pUserList),
              m_hwndListView(hwndListView) { }

        ~UndoList(VOID);

        VOID Add(UndoAction *pAction)
            { 
                pAction->SetUndoList(this), 
                m_hList.Append((LPVOID)pAction); 
            }

        HWND GetListViewHwnd(VOID)
            { return m_hwndListView; }

        PointerList *GetUserList(VOID)
            { return m_pUserList; }
        
        VOID Undo(VOID);

        VOID Clear(VOID);

        INT Count(VOID)
            { return m_hList.Count(); }
};



    

#endif // _INC_DSKQUOTA_UNDO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\uihelp.h ===
#ifndef __UIHELP_H
#define __UIHELP_H

const TCHAR STR_DSKQUOUI_HELPFILE_HTML[]  = TEXT("DSKQUOUI.CHM > windefault");
const TCHAR STR_DSKQUOUI_HTMLHELP_TOPIC[] = TEXT("nt_diskquota_overview.htm");
const TCHAR STR_DSKQUOUI_HELPFILE[]       = TEXT("DSKQUOUI.HLP");

#define IDH_QUOTA_FIRST  (0x00000000)

//
//-----------------------------------------------------------------------------
// Volume property page IDD_PROPPAGE_VOLQUOTA
//-----------------------------------------------------------------------------
//
// The colors of the traffic light indicate the state of the volume's
// quota system.  
//
//  RED     = Quotas are not enabled on the volume.
//  YELLOW  = Quota information is being rebuilt on the volume.  Quotas
//            are not active.
//  GREEN   = Quotas are enabled on the volume.
//  
#define IDH_TRAFFIC_LIGHT           (IDH_QUOTA_FIRST +  0)
//
// Describes the status of the volume's quota system.
//
#define IDH_TXT_QUOTA_STATUS        (IDH_QUOTA_FIRST +  1)
//
// Check this to enable quotas on the volume.  Uncheck it to disable quotas.
//
#define IDH_CBX_ENABLE_QUOTA        (IDH_QUOTA_FIRST +  2)
//
// Check this to deny users disk space when they exceed their quota
// limit on the volume.
//
#define IDH_CBX_DENY_LIMIT          (IDH_QUOTA_FIRST +  4)
//
// Check this to automatically assign unlimited quota to new volume users.
//
#define IDH_RBN_DEF_NO_LIMIT        (IDH_QUOTA_FIRST +  5)
//
// Check this to automatically assign a quota limit to new volume users.
//
#define IDH_RBN_DEF_LIMIT           (IDH_QUOTA_FIRST +  6)
//
// Enter a quota limit to be automatically assigned to new volume users.
// For example: to assign 20 megabytes, enter 20 and select "MB" in the
// drop-down list.
//
#define IDH_EDIT_DEF_LIMIT          (IDH_QUOTA_FIRST +  7)
//
// Enter a quota warning threshold to be automatically assigned to new volume 
// users.  For example: to assign 18 megabytes, enter 18 and select "MB" in the
// drop-down list.
//
#define IDH_EDIT_DEF_THRESHOLD      (IDH_QUOTA_FIRST +  8)
//
// Select a unit of storage to apply to the quota limit value.  
// For example:  to assign 20 megabytes, enter 20 in the edit box and select
// "MB" in the drop-down list.
//
#define IDH_CMB_DEF_LIMIT           (IDH_QUOTA_FIRST +  9)
//
// Select a unit of storage to apply to the quota warning threshold value.  
// For example:  to assign 18 megabytes, enter 18 in the edit box and select
// "MB" in the drop-down list.
//
#define IDH_CMB_DEF_THRESHOLD       (IDH_QUOTA_FIRST + 10)
//
// Displays per-user quota information for the volume.
//
#define IDH_BTN_DETAILS             (IDH_QUOTA_FIRST + 11)
//
// Opens the Window NT Event Viewer.
//
#define IDH_BTN_EVENTLOG            (IDH_QUOTA_FIRST + 12)
//
// These items control how Windows NT responds when users exceed their
// warning threshold or quota limit values.
//
#define IDH_GRP_ACTIONS             (IDH_QUOTA_FIRST + 13)
//
// These items define default quota values automatically applied to new users 
// of the volume.
//
#define IDH_GRP_DEFAULTS            (IDH_QUOTA_FIRST + 14)

//-----------------------------------------------------------------------------
// User property page IDD_PROPPAGE_USERQUOTA
//-----------------------------------------------------------------------------
//
// Show the account name for the volume user.
//
#define IDH_TXT_USERNAME            (IDH_QUOTA_FIRST + 15)
//
// The number of bytes occupied by the user's data on the volume.
//
#define IDH_TXT_SPACEUSED           (IDH_QUOTA_FIRST + 16)
//
// The number of bytes available to the user on the volume.
//
#define IDH_TXT_SPACEREMAINING      (IDH_QUOTA_FIRST + 17)
//
// Indicates if the user's disk usage is under the warning threshold, over 
// the warning threshold or over the quota limit.
//
#define IDH_ICON_USERSTATUS         (IDH_QUOTA_FIRST + 18)
//
// These items define quota warning threshold and limit values for the user.
//
#define IDH_GRP_SETTINGS            (IDH_QUOTA_FIRST + 19)
//
// Check this to assign unlimited quota to the user.
//
#define IDH_RBN_USER_NOLIMIT        (IDH_QUOTA_FIRST + 20)
//
// Check this to assign a quota warning threshold and limit value to the user.
//
#define IDH_RBN_USER_LIMIT          (IDH_QUOTA_FIRST + 21)
//
// Enter a quota warning threshold to be assigned to the user. For example: 
// to assign 18 megabytes, enter 18 and select "MB" in the drop-down list.
//
// FEATURE:  This could be a duplicate of IDH_EDIT_DEF_THRESHOLD
//
#define IDH_EDIT_USER_THRESHOLD     (IDH_QUOTA_FIRST + 22)
//
// Enter a quota limit value to be assigned to the user. For example: 
// to assign 20 megabytes, enter 20 and select "MB" in the drop-down list.
//
// FEATURE:  This could be a duplicate of IDH_EDIT_DEF_LIMIT
//
#define IDH_EDIT_USER_LIMIT         (IDH_QUOTA_FIRST + 23)
//
// Select a unit of storage to apply to the quota limit value.  
// For example:  to assign 20 megabytes, enter 20 in the edit box and select
// "MB" in the drop-down list.
//
// FEATURE:  This could be a duplicate of IDH_CMB_DEF_THRESHOLD
//
#define IDH_CMB_USER_LIMIT          (IDH_QUOTA_FIRST + 24)
//
// Select a unit of storage to apply to the quota warning threshold value.  
// For example:  to assign 18 megabytes, enter 18 in the edit box and select
// "MB" in the drop-down list.
//
// FEATURE:  This could be a duplicate of IDH_CMB_DEF_THRESHOLD
//
#define IDH_CMB_USER_THRESHOLD      (IDH_QUOTA_FIRST + 25)
//
// Show the domain/folder name for the volume user.
//
#define IDH_EDIT_DOMAINNAME         (IDH_QUOTA_FIRST + 26)

//-----------------------------------------------------------------------------
// File Owner dialog IDD_OWNERSANDFILES
//-----------------------------------------------------------------------------
//
// Select the owner of files to display in the list.
//
#define IDH_CMB_OWNERDLG_OWNERS     (IDH_QUOTA_FIRST + 27)
//
// List of files owned by selected user.
//
#define IDH_LV_OWNERDLG             (IDH_QUOTA_FIRST + 28)
//
// Permanently deletes from disk those files selected in the list.
//
#define IDH_BTN_OWNERDLG_DELETE     (IDH_QUOTA_FIRST + 29)
//
// Moves files selected in the list to another location.
//
#define IDH_BTN_OWNERDLG_MOVETO     (IDH_QUOTA_FIRST + 30)
//
// Transfers ownership of selected files to the logged-on user.
//
#define IDH_BTN_OWNERDLG_TAKE       (IDH_QUOTA_FIRST + 31)
//
// Displays a dialog for choosing a destination folder.
//
#define IDH_BTN_OWNERDLG_BROWSE     (IDH_QUOTA_FIRST + 32)
//
// Enter path to a destination folder.
//
#define IDH_EDIT_OWNERDLG_MOVETO    (IDH_QUOTA_FIRST + 33)
//
// Specifies whether to display only the folders owned by the specified user.
//
#define IDH_CBX_OWNERDLG_EXCLUDEFILES    (IDH_QUOTA_FIRST + 34)
//
// Specifies whether to display only the files owned by the specified user.
//
#define IDH_CBX_OWNERDLG_EXCLUDEDIRS     (IDH_QUOTA_FIRST + 35)
//
//-----------------------------------------------------------------------------
// These IDs are for controls on the volume prop page.  They were
// added late in the project and I didn't reserve any ranges for
// each page like I should have [brianau - 11/27/98]
//-----------------------------------------------------------------------------
//
// Check this to generate an event log entry when a user's disk space usage
// exceeds their assigned disk quota warning level.
//
#define IDH_CBX_LOG_OVERWARNING     (IDH_QUOTA_FIRST + 36)
//
// Check this to generate an event log entry when a user's disk space usage
// exceeds their assigned disk quota limit.
//
#define IDH_CBX_LOG_OVERLIMIT       (IDH_QUOTA_FIRST + 37)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\undo.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: undo.cpp

    Description: Definitions for classes associated with the "undo" feature.
        A client first creates an UndoList object.  Whenever an "undoable" 
        action is performed in the quota UI (modification/deletion), an
        undo action object is created and added to the UndoList object.  
        Each type of undo action object knows what is has to do to reverse
        the effects of the original operation.  When the client wants to 
        reverse the effects of all operations on the undo list, it merely
        commands the UndoList object to "Undo".  To clear the undo list,
        a client calls UndoList::Clear().


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "undo.h"


///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoAction::UndoAction
    Function: UndoAction::~UndoAction

    Description: Constructor and Destructor

    Arguments: 
        pUser - Address of IDiskQuotaUser interface for user associated
            with this undo action.

        llThreshold - Quota threshold value to be restored if action is 
            undone.

        llLimit - Quota limit value to be restored if action is undone.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UndoAction::UndoAction(
    PDISKQUOTA_USER pUser,
    LONGLONG llThreshold,
    LONGLONG llLimit,
    PDISKQUOTA_CONTROL pQuotaControl
    ) : m_pUser(pUser),
        m_pUndoList(NULL),
        m_pQuotaControl(pQuotaControl)
{
    DBGTRACE((DM_UNDO, DL_HIGH, TEXT("UndoAction::UndoAction")));
    DBGPRINT((DM_UNDO, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    DBGASSERT((NULL != m_pUser));
    m_llThreshold = llThreshold;
    m_llLimit     = llLimit;
}


UndoAction::~UndoAction(
    VOID
    )
{
    DBGTRACE((DM_UNDO, DL_HIGH, TEXT("UndoAction::~UndoAction")));
    DBGPRINT((DM_UNDO, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    if (NULL != m_pUser)
        m_pUser->Release();  // Release from Undo list.
    if (NULL != m_pQuotaControl)
        m_pQuotaControl->Release();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoList::~UndoList

    Description: Destructor.  Destroys all undo action objects in the 
        undo list object.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UndoList::~UndoList(
    VOID
    )
{
    Clear();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoList::Clears

    Description: Destroys all undo action objects in the 
        undo list object.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID UndoList::Clear(
    VOID
    )
{
    UndoAction *pAction = NULL;

    DBGPRINT((DM_UNDO, DL_MID, TEXT("UNDO - Cleared undo list")));
    m_hList.Lock();
    while(m_hList.RemoveFirst((LPVOID *)&pAction))
    {
        DBGASSERT((NULL != pAction));
        delete pAction;
    }
    m_hList.ReleaseLock();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoList::Undo

    Description: Iterates through all undo action objects and commands each
        to perform it's undo action.  Once the action is performed, the
        undo action object is destroyed.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID UndoList::Undo(
    VOID
    )
{
    UndoAction *pAction = NULL;

    DBGPRINT((DM_UNDO, DL_MID, TEXT("UNDO - Undoing undo list")));

    //
    // Disable redraw on the listview so that we only update once.
    //
    CAutoSetRedraw autoredraw(m_hwndListView, false);
    m_hList.Lock();
    while(m_hList.RemoveFirst((LPVOID *)&pAction))
    {
        DBGASSERT((NULL != pAction));
        pAction->Undo();
        delete pAction;
    }
    m_hList.ReleaseLock();
    InvalidateRect(m_hwndListView, NULL, FALSE);
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoDelete::Undo

    Description: Reverses the deletion of a user quota record.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UndoDelete::Undo(
    VOID
    )
{
    DBGPRINT((DM_UNDO, DL_MID, TEXT("UNDO - Undoing deletion")));

    HRESULT hResult = NO_ERROR;

    //
    // Just restore the quota settings.
    //
    hResult = m_pUser->SetQuotaLimit(m_llLimit, TRUE);
    hResult = m_pUser->SetQuotaThreshold(m_llThreshold, TRUE);

    if (SUCCEEDED(hResult))
    {
        //
        // Add the entry back into the listview.
        //
        HWND hwndListView      = m_pUndoList->GetListViewHwnd();
        PointerList *pUserList = m_pUndoList->GetUserList();

        LV_ITEM item;

        item.mask       = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;
        item.state      = 0;
        item.stateMask  = 0;
        item.iSubItem   = 0;
        item.pszText    = LPSTR_TEXTCALLBACK;
        item.iImage     = I_IMAGECALLBACK;
        item.iItem      = 0;

        pUserList->Insert((LPVOID)m_pUser);
        if (-1 != ListView_InsertItem(hwndListView, &item))
        {
            m_pUser->AddRef();
        }
        else
            hResult = E_FAIL;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoAdd::Undo

    Description: Reverses the addition of a user quota record by marking it
        for deletion.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/27/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UndoAdd::Undo(
    VOID
    )
{
    DBGPRINT((DM_UNDO, DL_MID, TEXT("UNDO - Undoing addition")));

    DBGASSERT((NULL != m_pQuotaControl));
    DBGASSERT((NULL != m_pUser));

    HRESULT hResult = m_pQuotaControl->DeleteUser(m_pUser);

    if (SUCCEEDED(hResult))
    {
        INT iItem;
        LV_FINDINFO fi;
        HWND hwndListView = m_pUndoList->GetListViewHwnd();
        PointerList *pUserList = m_pUndoList->GetUserList();

        fi.flags  = LVFI_PARAM;
        fi.lParam = (LPARAM)m_pUser;

        iItem = ListView_FindItem(hwndListView, -1, &fi);
        if (-1 != iItem)
        {
            PDISKQUOTA_USER pIUserToDelete = NULL;

            //
            // Delete the entry from the list view.
            //
            ListView_DeleteItem(hwndListView, iItem);

            //
            // Delete the entry from the user list.
            //
            pUserList->Remove((LPVOID *)&pIUserToDelete, iItem);


            pIUserToDelete->Release();  // Release from listview.
        }
        else
        {
            DBGERROR((TEXT("UndoAdd::Undo - Didn't find user in listview.")));
        }
    }
    else
    {
        DBGERROR((TEXT("UndoAdd::Undo - Error 0x%08X deleting user 0x%08X"),
                 hResult, m_pUser));
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoModify::Undo

    Description: Reverses the modification of a user quota record.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UndoModify::Undo(
    VOID
    )
{
    DBGPRINT((DM_UNDO, DL_MID, TEXT("UNDO - Undoing modification")));

    HRESULT hResult = NO_ERROR;
    //
    // Restore the user's quota settings.
    //
    hResult = m_pUser->SetQuotaLimit(m_llLimit, TRUE);
    hResult = m_pUser->SetQuotaThreshold(m_llThreshold, TRUE);

    if (SUCCEEDED(hResult))
    {
        //
        // Locate the corresponding listview item and update it.
        //
        HWND hwndListView      = m_pUndoList->GetListViewHwnd();
        PointerList *pUserList = m_pUndoList->GetUserList();

        DBGASSERT((NULL != hwndListView));
        INT iItem = -1;

        if (pUserList->FindIndex((LPVOID)m_pUser, &iItem))
            ListView_Update(hwndListView, iItem);
        else
            hResult = E_FAIL;
    }
    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\userprop.h ===
#ifndef __DSKQUOTA_USER_PROPSHEET_H
#define __DSKQUOTA_USER_PROPSHEET_H
///////////////////////////////////////////////////////////////////////////////
/*  File: userprop.h

    Description: Provides declarations for quota user property page.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/25/98    Replaced AddUserPropSheet with AddUserDialog.        BrianAu
                Now that we're getting user info from the DS
                object picker, the prop sheet idea doesn't work
                so well.  A std dialog is better.
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_USER_H
#   include "user.h"
#endif
#ifndef _INC_DSKQUOTA_UNDO_H
#   include "undo.h"
#endif
#ifndef _INC_DSKQUOTA_DETAILS_H
#   include "details.h"    // For LVSelection
#endif
#ifndef __OBJSEL_H_
#   include <objsel.h>
#endif

#include "resource.h"

//
// User property page.
//
class UserPropSheet
{
    private:
        enum { iICON_USER_SINGLE,
               iICON_USER_MULTIPLE,
               cUSER_ICONS };

        enum { iICON_STATUS_OK,
               iICON_STATUS_OVER_THRESHOLD,
               iICON_STATUS_OVER_LIMIT,
               cSTATUS_ICONS };

        //
        // Prevent copying.
        //
        UserPropSheet(const UserPropSheet&);
        void operator = (const UserPropSheet&);

        LONGLONG           m_cVolumeMaxBytes;
        LONGLONG           m_llQuotaUsed;
        LONGLONG           m_llQuotaLimit;
        LONGLONG           m_llQuotaThreshold;
        int                m_idCtlNextFocus;
        PDISKQUOTA_CONTROL m_pQuotaControl;
        UndoList&          m_UndoList;
        LVSelection&       m_LVSelection;
        HWND               m_hWndParent;
        CVolumeID          m_idVolume;
        CString            m_strPageTitle;
        BOOL               m_bIsDirty;
        BOOL               m_bHomogeneousSelection;      // All selected, same limit/threshold.
        HICON              m_hIconUser[cUSER_ICONS];     // 0=Single, 1=Multi-user.
        HICON              m_hIconStatus[cSTATUS_ICONS]; // 0=OK,1=Warn,2=Error
        XBytes            *m_pxbQuotaLimit;
        XBytes            *m_pxbQuotaThreshold;

        static INT_PTR OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnHelp(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnContextMenu(HWND hwndItem, int xPos, int yPos);

        //
        // PSN_xxxx handlers.
        //
        INT_PTR OnSheetNotifyApply(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnSheetNotifyKillActive(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnSheetNotifySetActive(HWND hDlg, WPARAM wParam, LPARAM lParam);

        //
        // EN_xxxx handlers.
        //
        INT_PTR OnEditNotifyUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnEditNotifyKillFocus(HWND hDlg, WPARAM wParam, LPARAM lParam);

        //
        // CBN_xxxx handlers.
        //
        INT_PTR OnComboNotifySelChange(HWND hDlg, WPARAM wParam, LPARAM lParam);

        HRESULT UpdateControls(HWND hDlg) const;
        HRESULT InitializeControls(HWND hDlg);
        HRESULT RefreshCachedUserQuotaInfo(VOID);
        HRESULT ApplySettings(HWND hDlg, bool bUndo = true);
        HRESULT RefreshCachedQuotaInfo(VOID);

        VOID UpdateSpaceUsed(HWND hDlg, LONGLONG iUsed, LONGLONG iLimit, INT cUsers);
        VOID UpdateUserName(HWND hDlg, PDISKQUOTA_USER pUser);
        VOID UpdateUserName(HWND hDlg, INT cUsers);
        VOID UpdateUserStatusIcon(HWND hDlg, LONGLONG iUsed, LONGLONG iThreshold, LONGLONG iLimit);

        INT QueryUserIcon(HWND hDlg) const;
        INT QueryUserStatusIcon(HWND hDlg) const;

    public:
        //
        // Prop sheet for editing users.
        //
        UserPropSheet(PDISKQUOTA_CONTROL pQuotaControl,
                      const CVolumeID& idVolume,
                      HWND hWndParent,
                      LVSelection& LVSelection,
                      UndoList& UndoList);

        ~UserPropSheet(VOID);

        HRESULT Run(VOID);

        //
        // Dialog Proc callback.
        //
        static INT_PTR APIENTRY DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

#endif // __DSKQUOTA_USER_PROPSHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\volprop.h ===
#ifndef _INC_DSKQUOTA_VOLPROP_H
#define _INC_DSKQUOTA_VOLPROP_H
///////////////////////////////////////////////////////////////////////////////
/*  File: volprop.h

    Description: Provides declarations for quota property pages.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_PRSHTEXT_H
#   include "prshtext.h"
#endif
#ifndef _INC_DSKQUOTA_DETAILS_H
#   include "details.h"
#endif

#include "resource.h"


const DWORD IDT_STATUS_UPDATE              = 1;
const DWORD STATUS_UPDATE_TIMER_PERIOD     = 2000; // Update every 2 sec.

#define TLM_SETSTATE (WM_USER + 100)  // TLM = Traffic Light Message.

//
// Volume property page.
//
class VolumePropPage : public DiskQuotaPropSheetExt
{
    protected:
            class TrafficLight
            {
                private:
                    HWND m_hwndAnimateCtl;
                    INT m_idAviClipRes;

                    //
                    // Prevent copy.
                    //
                    TrafficLight(const TrafficLight& rhs);
                    TrafficLight& operator = (const TrafficLight& rhs);

                public:
                    TrafficLight(VOID)
                        : m_hwndAnimateCtl(NULL),
                          m_idAviClipRes(-1)
                          { }

                    TrafficLight(HWND hwndAnimateCtl, INT idAviClipRes)
                        : m_hwndAnimateCtl(hwndAnimateCtl),
                          m_idAviClipRes(idAviClipRes)
                    {
                        Initialize(hwndAnimateCtl, idAviClipRes);
                    }

                    VOID Initialize(HWND hwndAnimateCtl, INT idAviClipRes);

                    ~TrafficLight(VOID)
                        { Animate_Close(m_hwndAnimateCtl); }

                    enum { YELLOW, OFF, RED, GREEN, FLASHING_YELLOW };

                    VOID Show(INT eShow);

                    INT_PTR ForwardMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
            };

        DWORD          m_dwQuotaState;
        DWORD          m_dwQuotaLogFlags;
        LONGLONG       m_llDefaultQuotaThreshold;
        LONGLONG       m_llDefaultQuotaLimit;
        UINT64         m_cVolumeMaxBytes;
        UINT_PTR       m_idStatusUpdateTimer;
        DWORD          m_dwLastStatusMsgID;
        int            m_idCtlNextFocus;
        DetailsView   *m_pDetailsView;
        XBytes        *m_pxbDefaultLimit;
        XBytes        *m_pxbDefaultThreshold;
        TrafficLight  m_TrafficLight;


        virtual INT_PTR OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

        INT_PTR OnContextMenu(HWND hwndItem, int xPos, int yPos);
        INT_PTR OnHelp(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnTimer(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnButtonDetails(HWND hDlg, WPARAM wParam, LPARAM lParam);

        //
        // PSN_xxxx handlers.
        //
        virtual INT_PTR OnSheetNotifyApply(HWND hDlg, WPARAM wParam, LPARAM lParam);
        virtual INT_PTR OnSheetNotifyKillActive(HWND hDlg, WPARAM wParam, LPARAM lParam);
        virtual INT_PTR OnSheetNotifyReset(HWND hDlg, WPARAM wParam, LPARAM lParam);
        virtual INT_PTR OnSheetNotifySetActive(HWND hDlg, WPARAM wParam, LPARAM lParam);

        //
        // EN_xxxx handlers.
        //
        INT_PTR OnEditNotifyUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnEditNotifyKillFocus(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnEditNotifySetFocus(HWND hDlg, WPARAM wParam, LPARAM lParam);

        //
        // CBN_xxxx handlers.
        //
        INT_PTR OnComboNotifySelChange(HWND hDlg, WPARAM wParam, LPARAM lParam);


        HRESULT UpdateControls(HWND hDlg) const;
        HRESULT InitializeControls(HWND hDlg);
        HRESULT EnableControls(HWND hDlg);
        HRESULT RefreshCachedVolumeQuotaInfo(VOID);
        HRESULT ApplySettings(HWND hDlg);
        HRESULT QuotaStateFromControls(HWND hDlg, LPDWORD pdwState) const;
        HRESULT LogFlagsFromControls(HWND hDlg, LPDWORD pdwLogFlags) const;
        BOOL ActivateExistingDetailsView(VOID) const;
        bool SetByPolicy(LPCTSTR pszPolicyValue);

        HRESULT UpdateStatusIndicators(HWND hDlg);

        VOID SetStatusUpdateTimer(HWND hDlg)
            {
                if (0 == m_idStatusUpdateTimer)
                    m_idStatusUpdateTimer = SetTimer(hDlg,
                                                     IDT_STATUS_UPDATE,
                                                     STATUS_UPDATE_TIMER_PERIOD,
                                                     NULL);
            }
        VOID KillStatusUpdateTimer(HWND hDlg)
            {
                if (0 != m_idStatusUpdateTimer)
                {
                    KillTimer(hDlg, m_idStatusUpdateTimer);
                    m_idStatusUpdateTimer = 0;
                }
            }

        //
        // Prevent copy.
        //
        VolumePropPage(const VolumePropPage& rhs);
        VolumePropPage& operator = (const VolumePropPage& rhs);

    public:
        VolumePropPage(VOID);
        ~VolumePropPage(VOID);

        //
        // Dialog Proc callback.
        //
        static INT_PTR APIENTRY DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
};



#ifdef PER_DIRECTORY_QUOTAS
//
// Folder property page.
//
class FolderPropPage : public DiskQuotaPropSheetExt
{
//
// This class has not been implemented.
// At some future date, we may implement per-directory quota management.
// If such support is required, look at class VolumePropPage.
// You should be able to provide a similar implementation only with
// directory-specific features.  All features common to volumes and
// directories are in class DiskQuotaPropSheetExt.
//
    public:
        //
        // Dialog Proc callback.
        //
        static INT_PTR APIENTRY DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
            { return FALSE; }
};


#endif // PER_DIRECTORY_QUOTAS




#endif // __DSKQUOTA_PROPSHEET_EXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\yntoall.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: yntoall.cpp

    Description: Implements the YesNoToAll dialog.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "yntoall.h"
#include "resource.h"



///////////////////////////////////////////////////////////////////////////////
/*  Function: YesNoToAllDialog::YesNoToAllDialog

    Description: Class constructor.

    Arguments:
        idDialogTemplate - ID number for the dialog's resource template.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
YesNoToAllDialog::YesNoToAllDialog(
    UINT idDialogTemplate
    ) : m_idDialogTemplate(idDialogTemplate),
        m_hwndCbxApplyToAll(NULL),
        m_hwndTxtMsg(NULL),
        m_bApplyToAll(FALSE),
        m_pszTitle(NULL),
        m_pszText(NULL)
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("YesNoToAllDialog::YesNoToAllDialog")));
    //
    // Do nothing.
    //
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: YesNoToAllDialog::~YesNoToAllDialog

    Description: Class destructor.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
YesNoToAllDialog::~YesNoToAllDialog(
    VOID
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("YesNoToAllDialog::YesNoToAllDialog")));
    //
    // Call the Destroy() function to destroy the progress dialog window.
    //
    delete[] m_pszTitle;
    delete[] m_pszText;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: YesNoToAllDialog::Create

    Description: Creates the dialog.

    Arguments:
        hInstance - Instance handle for the DLL containing the dialog
            resource template.

        hwndParent - Parent window for dialog.

        lpszTitle - Title for dialog.

        lpszText - Text message for dialog.

    Returns:
        TRUE  = Dialog was created.
        FALSE = Dialog was not created.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
YesNoToAllDialog::CreateAndRun(
    HINSTANCE hInstance,
    HWND hwndParent,
    LPCTSTR pszTitle,
    LPCTSTR pszText
    )
{
    DBGASSERT((NULL != pszTitle));
    DBGASSERT((NULL != pszText));

    //
    // Set these in member variables so that the text can be set in the
    // dialog in response to WM_INITDIALOG.
    //
    m_pszTitle = StringDup(pszTitle);
    m_pszText  = StringDup(pszText);

    return DialogBoxParam(hInstance,
                          MAKEINTRESOURCE(m_idDialogTemplate),
                          hwndParent,
                          DlgProc,
                          (LPARAM)this);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: YesNoToAllDialog::DlgProc [static]

    Description: Message procedure for the dialog.

    Arguments: Standard Win32 message proc arguments.

    Returns: Standard Win32 message proc return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK
YesNoToAllDialog::DlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Retrieve the dialog object's ptr from the window's userdata.
    // Place there in response to WM_INITDIALOG.
    //
    YesNoToAllDialog *pThis = (YesNoToAllDialog *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(uMsg)
    {
        case WM_INITDIALOG:
            //
            // Store "this" ptr in window's userdata.
            //
            SetWindowLongPtr(hwnd, DWLP_USER, (INT_PTR)lParam);
            pThis = (YesNoToAllDialog *)lParam;

            //
            // Center popup on the desktop.
            //
            ::CenterPopupWindow(hwnd, GetDesktopWindow());
            pThis->m_hwndTxtMsg        = GetDlgItem(hwnd, IDC_TXT_YNTOALL);
            pThis->m_hwndCbxApplyToAll = GetDlgItem(hwnd, IDC_CBX_YNTOALL);
            SetWindowText(pThis->m_hwndTxtMsg, pThis->m_pszText);
            SetWindowText(hwnd, pThis->m_pszTitle);
            SendMessage(pThis->m_hwndCbxApplyToAll,
                        BM_SETCHECK,
                        pThis->m_bApplyToAll ? (WPARAM)BST_CHECKED : (WPARAM)BST_UNCHECKED,
                        0);

            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDCANCEL:
                case IDYES:
                case IDNO:
                    DBGASSERT((NULL != pThis));
                    pThis->m_bApplyToAll = (BST_CHECKED == SendMessage(pThis->m_hwndCbxApplyToAll, BM_GETCHECK, 0, 0));
                    EndDialog(hwnd, LOWORD(wParam));
                    break;
            }
            break;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\yntoall.h ===
#ifndef _INC_DSKQUOTA_YNTOALL_H
#define _INC_DSKQUOTA_YNTOALL_H
///////////////////////////////////////////////////////////////////////////////
/*  File: yntoall.h

    Description: Declarations for class YesNoToAllDialog.
        This class provides a simple message box that includes an
        "apply to all" checkbox.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
class YesNoToAllDialog
{
    private:
        UINT   m_idDialogTemplate;
        HWND   m_hwndCbxApplyToAll;
        HWND   m_hwndTxtMsg;
        LPTSTR m_pszTitle;
        LPTSTR m_pszText;
        BOOL   m_bApplyToAll;

        static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);

    public:
        YesNoToAllDialog(UINT idDialogTemplate);
        ~YesNoToAllDialog(VOID);

        BOOL ApplyToAll(VOID)
            { return m_bApplyToAll; }

        INT_PTR CreateAndRun(HINSTANCE hInstance, HWND hwndParent, LPCTSTR pszTitle, LPCTSTR pszText);
};

#endif // _INC_DSKQUOTA_YNTOALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\volprop.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: volprop.cpp

    Description: Provides implementations for quota property pages.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    08/01/97    Removed IDC_CBX_WARN_THRESHOLD from UI.              BrianAu
    11/27/98    Added logging checkboxes back in.                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "dskquota.h"
#include "volprop.h"
#include "uihelp.h"
#include "registry.h"
#include "guidsp.h"
#include "uiutils.h"

//
// Context help IDs.
//
#pragma data_seg(".text", "CODE")
const static DWORD rgVolumePropPageHelpIDs[] =
{
    IDC_TRAFFIC_LIGHT,          IDH_TRAFFIC_LIGHT,
    IDC_TXT_QUOTA_STATUS,       IDH_TXT_QUOTA_STATUS,
    IDC_TXT_QUOTA_STATUS_LABEL, DWORD(-1),
    IDC_CBX_ENABLE_QUOTA,       IDH_CBX_ENABLE_QUOTA,
    IDC_CBX_DENY_LIMIT,         IDH_CBX_DENY_LIMIT,
    IDC_RBN_DEF_NOLIMIT,        IDH_RBN_DEF_NO_LIMIT,
    IDC_RBN_DEF_LIMIT,          IDH_RBN_DEF_LIMIT,
    IDC_EDIT_DEF_LIMIT,         IDH_EDIT_DEF_LIMIT,
    IDC_EDIT_DEF_THRESHOLD,     IDH_EDIT_DEF_THRESHOLD,
    IDC_CMB_DEF_LIMIT,          IDH_CMB_DEF_LIMIT,
    IDC_CMB_DEF_THRESHOLD,      IDH_CMB_DEF_THRESHOLD,
    IDC_BTN_DETAILS,            IDH_BTN_DETAILS,
    IDC_BTN_EVENTLOG,           IDH_BTN_EVENTLOG,
    IDC_CBX_LOG_OVERWARNING,    IDH_CBX_LOG_OVERWARNING,
    IDC_CBX_LOG_OVERLIMIT,      IDH_CBX_LOG_OVERLIMIT,
    IDC_TXT_DEFAULTS,           IDH_GRP_DEFAULTS,
    IDC_TXT_LOGGING,            DWORD(-1),
    IDC_TXT_WARN_LEVEL,         DWORD(-1),
    0,0
};


#pragma data_seg()

extern TCHAR c_szWndClassDetailsView[]; // defined in details.cpp

/*
// NOTE:  This code has been disabled.
//          I've left in case we decide to launch the event viewer from
//          the volume prop page again. [brianau - 3/23/98]
//
const TCHAR c_szVerbOpen[]          = TEXT("Open");
const TCHAR c_szManagementConsole[] = TEXT("MMC.EXE");
const TCHAR c_szMMCInitFile[]       = TEXT("%SystemRoot%\\System32\\EVENTVWR.MSC");
*/


#define VPPM_FOCUS_ON_THRESHOLDEDIT  (WM_USER + 1)


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::VolumePropPage

    Description: Constructor for a volume property page object.
        Initializes the members that hold volume quota data.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VolumePropPage::VolumePropPage(VOID)
    : m_dwQuotaState(0),
      m_dwQuotaLogFlags(0),
      m_idStatusUpdateTimer(0),
      m_dwLastStatusMsgID(0),
      m_cVolumeMaxBytes(NOLIMIT),
      m_pxbDefaultLimit(NULL),
      m_pxbDefaultThreshold(NULL),
      m_llDefaultQuotaThreshold(0),
      m_llDefaultQuotaLimit(0),
      m_idCtlNextFocus(-1)
{

}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::~VolumePropPage

    Description: Destructor for a volume property page object.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VolumePropPage::~VolumePropPage(
    VOID
    )
{
    delete m_pxbDefaultLimit;
    delete m_pxbDefaultThreshold;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::DlgProc

    Description: Static method called by windows to process messages for the
        property page dialog.  Since it's static, we have to save the "this"
        pointer in the window's USERDATA.

    Arguments: Standard WndProc-type arguments.

    Returns: Standard WndProc-type return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY
VolumePropPage::DlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR bResult = FALSE;

    //
    // Retrieve the "this" pointer from the dialog's userdata.
    // It was placed there in OnInitDialog().
    //
    VolumePropPage *pThis = (VolumePropPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    try
    {
        switch(message)
        {
            case WM_INITDIALOG:
            {
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_INITDIALOG")));
                PROPSHEETPAGE *pPage = (PROPSHEETPAGE *)lParam;
                pThis = (VolumePropPage *)pPage->lParam;

                DBGASSERT((NULL != pThis));
                //
                // pThis pointer AddRef'd in AddPages().
                // Save it in the window's userdata.
                //
                SetWindowLongPtr(hDlg, DWLP_USER, (INT_PTR)pThis);
                bResult = pThis->OnInitDialog(hDlg, wParam, lParam);
                break;
            }

            case WM_SYSCOLORCHANGE:
                bResult = pThis->m_TrafficLight.ForwardMessage(message, wParam, lParam);
                break;

            case WM_NOTIFY:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY")));
                bResult = pThis->OnNotify(hDlg, wParam, lParam);
                break;

            case WM_COMMAND:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_COMMAND")));
                bResult = pThis->OnCommand(hDlg, wParam, lParam);
                break;

            case WM_HELP:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_HELP")));
                bResult = pThis->OnHelp(hDlg, wParam, lParam);
                break;

            case WM_CONTEXTMENU:
                bResult = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
                break;

            case WM_DESTROY:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_DESTROY")));
                pThis->KillStatusUpdateTimer(hDlg);
                //
                // Nothing to do.
                //
                break;

            case WM_TIMER:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_TIMER")));
                bResult = pThis->OnTimer(hDlg, wParam, lParam);
                break;

            case VPPM_FOCUS_ON_THRESHOLDEDIT:
                //
                // This is sort of a hack because of the way the prop sheet
                // code in comctl32 sets focus after a page has returned
                // PSNRET_INVALID.  It automatically activates the problem
                // page and sets focus to the FIRST control in the tab order.
                // Since the only failure we generate is from the threshold
                // exceeding the limit, I want to return focus to the threshold
                // edit control so that the user can directly change the offending
                // value.  Posting this custom message was the only way I
                // could get this to work. [brianau].
                //
                SetFocus((HWND)lParam);
                SendMessage((HWND)lParam, EM_SETSEL, 0, -1);
                break;

            default:
                break;
        }
    }
    catch(CAllocException& me)
    {
        //
        // Announce any out-of-memory errors associated with running the
        // volume Quota property page.
        //
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return bResult;
}






///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnInitDialog

    Description: Handler for WM_INITDIALOG.

    Arguments:
        hDlg - Dialog window handle.

        wParam - Handle of control to receive focus if we return FALSE.

        lParam - Pointer to PROPSHEETPAGE structure for the property page.

    Returns:
        TRUE  = Tells windows to assign focus to the control in wParam.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    02/10/98    Converted from static to a virtual function to       BrianAu
                support addition of SnapInVolPropPage class.
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnInitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hResult = NO_ERROR;
    DWORD dwSectorsPerCluster = 0;
    DWORD dwBytesPerSector    = 0;
    DWORD dwFreeClusters      = 0;
    DWORD dwTotalClusters     = 0;

    //
    // Load the volume's quota information into member variables.
    //
    hResult = RefreshCachedVolumeQuotaInfo();

    //
    // Calculate the volume's size.
    // We'll use this to limit user threshold and quota limit entries.
    //
    if (GetDiskFreeSpace(m_idVolume.ForParsing(),
                         &dwSectorsPerCluster,
                         &dwBytesPerSector,
                         &dwFreeClusters,
                         &dwTotalClusters))
    {
        m_cVolumeMaxBytes = (UINT64)dwSectorsPerCluster *
                            (UINT64)dwBytesPerSector *
                            (UINT64)dwTotalClusters;
    }

    //
    // Create the XBytes objects to manage the relationship between the
    // limit/threshold edit controls and their combo boxes.
    //
    m_pxbDefaultLimit     = new XBytes(hDlg,
                                       IDC_EDIT_DEF_LIMIT,
                                       IDC_CMB_DEF_LIMIT,
                                       m_llDefaultQuotaLimit);
    m_pxbDefaultThreshold = new XBytes(hDlg,
                                       IDC_EDIT_DEF_THRESHOLD,
                                       IDC_CMB_DEF_THRESHOLD,
                                       m_llDefaultQuotaThreshold);

    m_TrafficLight.Initialize(GetDlgItem(hDlg, IDC_TRAFFIC_LIGHT), IDR_AVI_TRAFFIC);

    InitializeControls(hDlg);

    return TRUE;  // Set focus to default control.
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnCommand

    Description: Handler for WM_COMMAND.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of selected control and notification code.

        lParam - HWND of selected control.

    Returns:
        TRUE  = Message wasn't handled.
        FALSE = Message was handled.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    08/01/97    Removed IDC_CBX_WARN_THRESHOLD from UI.              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR bResult = TRUE;
    DWORD dwCtlId        = LOWORD(wParam);
    HWND hWndCtl         = (HWND)lParam;
    DWORD dwNotifyCode   = HIWORD(wParam);
    BOOL bIsChecked      = FALSE;
    BOOL bEnableApplyBtn = FALSE;

    switch(dwCtlId)
    {
        case IDC_CBX_ENABLE_QUOTA:
        {
            //
            // This is executed when the user checks or unchecks the
            // "Enable quota management checkbox.
            //
            bIsChecked = IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA);
            //
            // Remember: Limit/Threshold Edit and combo boxes are enabled/disabled
            //           through XBytes::SetBytes().
            //
            m_pxbDefaultLimit->SetBytes(m_llDefaultQuotaLimit);
            m_pxbDefaultThreshold->SetBytes(m_llDefaultQuotaThreshold);

            CheckDlgButton(hDlg, IDC_RBN_DEF_NOLIMIT, NOLIMIT == m_pxbDefaultLimit->GetBytes());
            CheckDlgButton(hDlg, IDC_RBN_DEF_LIMIT,   BST_CHECKED != IsDlgButtonChecked(hDlg, IDC_RBN_DEF_NOLIMIT));
            CheckDlgButton(hDlg, IDC_CBX_DENY_LIMIT,  bIsChecked && DISKQUOTA_IS_ENFORCED(m_dwQuotaState));
            CheckDlgButton(hDlg,
                           IDC_CBX_LOG_OVERWARNING,
                           bIsChecked &&
                           DISKQUOTA_IS_LOGGED_USER_THRESHOLD(m_dwQuotaLogFlags));
            CheckDlgButton(hDlg,
                           IDC_CBX_LOG_OVERLIMIT,
                           bIsChecked &&
                           DISKQUOTA_IS_LOGGED_USER_LIMIT(m_dwQuotaLogFlags));

            EnableControls(hDlg);

            bEnableApplyBtn = TRUE;
            bResult = FALSE;
            break;
        }

        case IDC_CBX_DENY_LIMIT:
            bResult = FALSE;
            bEnableApplyBtn = TRUE;
            break;

        case IDC_RBN_DEF_NOLIMIT:
            DBGASSERT((IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA)));

            if (m_pxbDefaultLimit->IsEnabled())
            {
                m_pxbDefaultThreshold->SetBytes(NOLIMIT);
                m_pxbDefaultLimit->SetBytes(NOLIMIT);
                bEnableApplyBtn = TRUE;
            }
            bResult = FALSE;
            break;

        case IDC_RBN_DEF_LIMIT:
            //
            // If the original threshold was -1 (no limit), set to 0.
            // Otherwise, set to the original value.
            //
            DBGASSERT((IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA)));
            if (!m_pxbDefaultLimit->IsEnabled())
            {
                m_pxbDefaultLimit->SetBytes(NOLIMIT == m_llDefaultQuotaLimit ?
                                            0 : m_llDefaultQuotaLimit);
                m_pxbDefaultThreshold->SetBytes(NOLIMIT == m_llDefaultQuotaThreshold ?
                                                0 : m_llDefaultQuotaThreshold);


                EnableControls(hDlg);
                bEnableApplyBtn = TRUE;
            }
            bResult = FALSE;
            break;

        case IDC_EDIT_DEF_LIMIT:
        case IDC_EDIT_DEF_THRESHOLD:
            switch(dwNotifyCode)
            {
                case EN_UPDATE:
                    DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc; WM_COMMAND, EN_CHANGE")));
                    bResult = OnEditNotifyUpdate(hDlg, wParam, lParam);
                    bEnableApplyBtn = TRUE;
                    break;

                case EN_KILLFOCUS:
                    DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc; WM_COMMAND, EN_KILLFOCUS")));
                    bResult = OnEditNotifyKillFocus(hDlg, wParam, lParam);
                    break;

                case EN_SETFOCUS:
                    DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc; WM_COMMAND, EN_SETFOCUS")));
                    bResult = OnEditNotifySetFocus(hDlg, wParam, lParam);
                    break;

                default:
                    break;
            }
            break;

        case IDC_CMB_DEF_LIMIT:
        case IDC_CMB_DEF_THRESHOLD:
            switch(dwNotifyCode)
            {
                case CBN_SELCHANGE:
                    DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_COMMAND, CBN_CHANGE")));
                    bResult = OnComboNotifySelChange(hDlg, wParam, lParam);
                    bEnableApplyBtn = TRUE;
                    break;

                default:
                    break;
            }
            break;

        case IDC_BTN_DETAILS:
            bResult = OnButtonDetails(hDlg, wParam, lParam);
            break;

        case IDC_CBX_LOG_OVERLIMIT:
        case IDC_CBX_LOG_OVERWARNING:
            bEnableApplyBtn = TRUE;
            break;

/*
//
// NOTE: This code disabled until we decide to launch the event viewer
//         from the volume prop page.  Probably won't happen because we
//         can't define a quota-specific error type for NT events.
//         If we can't filter an event viewer list on quota-only events,
//         there's not much use in getting to the event viewer from here.
//         [brianau - 3/23/98]
//
        case IDC_BTN_EVENTLOG:
            bResult = OnButtonEventLog(hDlg, wParam, lParam);
            break;
*/

        default:
            break;
    }

    if (bEnableApplyBtn)
        PropSheet_Changed(GetParent(hDlg), hDlg);

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnNotify

    Description: Handler for WM_NOTIFY.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of selected control and notification code.

        lParam - HWND of selected control.

    Returns:
        TRUE  = Message wasn't handled.
        FALSE = Message was handled.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnNotify(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGTRACE((DM_VPROP, DL_MID, TEXT("VolumePropPage::OnNotify")));
    INT_PTR bResult = TRUE;

    switch(((NMHDR *)lParam)->code)
    {
        case PSN_SETACTIVE:
            DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY, PSN_SETACTIVE")));
            bResult = OnSheetNotifySetActive(hDlg, wParam, lParam);
            break;

        case PSN_APPLY:
            DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY, PSN_APPLY")));
            bResult = OnSheetNotifyApply(hDlg, wParam, lParam);
            break;

        case PSN_KILLACTIVE:
            DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY, PSN_KILLACTIVE")));
            bResult = OnSheetNotifyKillActive(hDlg, wParam, lParam);
            break;

        case PSN_RESET:
            DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY, PSN_RESET")));
            bResult = OnSheetNotifyReset(hDlg, wParam, lParam);
            break;

        default:
            break;
    }
    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnSheetNotifySetActive

    Description: Handler for WM_NOTIFY - PSN_SETACTIVE.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        FALSE = Accept activation.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnSheetNotifySetActive(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("VolumePropPage::OnSheetNotifySetActive")));

    //
    // Update the status text and set the status update timer.
    //
    UpdateStatusIndicators(hDlg);
    SetStatusUpdateTimer(hDlg);

    if (IDC_EDIT_DEF_THRESHOLD == m_idCtlNextFocus)
    {
        //
        // Focus is being set as a result of an invalid entry
        // in the warning level field.  Force input focus to the
        // field and select the entire contents.  User can then just
        // enter a new value.
        //
        PostMessage(hDlg,
                    VPPM_FOCUS_ON_THRESHOLDEDIT,
                    0,
                    (LPARAM)GetDlgItem(hDlg, IDC_EDIT_DEF_THRESHOLD));

        m_idCtlNextFocus = -1;
    }

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnSheetNotifyApply

    Description: Handler for WM_NOTIFY - PSN_APPLY.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        TRUE = PSN return value set using SetWindowLong.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnSheetNotifyApply(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("VolumePropPage::OnSheetNotifyApply")));
    HRESULT hResult  = NO_ERROR;
    LONG dwPSNReturn = PSNRET_NOERROR;
    INT idMsg        = -1;

    if (!IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA) &&
        !DISKQUOTA_IS_DISABLED(m_dwQuotaState))
    {
        idMsg = IDS_DISABLE_QUOTA_WARNING;
    }
    else if (IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA) &&
        DISKQUOTA_IS_DISABLED(m_dwQuotaState))
    {
        idMsg = IDS_ENABLE_QUOTA_WARNING;
    }

    if (-1 != idMsg)
    {
        //
        // User wants to disable or enable quotas.
        // Warn about what this means and let them know that
        // re-activation of quotas requires a quota file rebuild.
        //
        if (IDCANCEL == DiskQuotaMsgBox(hDlg,
                                        idMsg,
                                        IDS_TITLE_DISK_QUOTA,
                                        MB_ICONWARNING | MB_OKCANCEL))
        {
            //
            // User decided to not continue the action.
            // Restore the checkbox to it's previous setting and abort the
            // settings change.
            // Sending the message to our DlgProc resets the dependent controls
            // to their proper states.
            //
            CheckDlgButton(hDlg,
                           IDC_CBX_ENABLE_QUOTA,
                           !IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA));

            SendMessage(hDlg,
                        WM_COMMAND,
                        (WPARAM)MAKELONG((WORD)IDC_CBX_ENABLE_QUOTA, (WORD)0),
                        (LPARAM)GetDlgItem(hDlg, IDC_CBX_ENABLE_QUOTA));

            dwPSNReturn = PSNRET_INVALID;
        }
    }

    if (PSNRET_NOERROR == dwPSNReturn)
    {
        //
        // We need to do this because if you activate the apply button
        // with Alt-A we receive PSN_APPLY before EN_KILLFOCUS.
        //
        m_pxbDefaultThreshold->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_DEF_THRESHOLD));
        m_pxbDefaultLimit->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_DEF_LIMIT));

        //
        // Ensure warning threshold is not above limit.
        //
        INT64 iThreshold = m_pxbDefaultThreshold->GetBytes();
        INT64 iLimit     = m_pxbDefaultLimit->GetBytes();

        if (iThreshold > iLimit)
        {
            TCHAR szLimit[40], szThreshold[40];
            XBytes::FormatByteCountForDisplay(iLimit, szLimit, ARRAYSIZE(szLimit));
            XBytes::FormatByteCountForDisplay(iThreshold, szThreshold, ARRAYSIZE(szThreshold));

            CString s(g_hInstDll, IDS_FMT_ERR_WARNOVERLIMIT, szThreshold, szLimit, szLimit);
            switch(DiskQuotaMsgBox(hDlg, s, IDS_TITLE_DISK_QUOTA, MB_ICONWARNING | MB_YESNO))
            {
                case IDYES:
                    m_pxbDefaultThreshold->SetBytes(iLimit);
                    break;

                case IDNO:
                    m_idCtlNextFocus = IDC_EDIT_DEF_THRESHOLD;
                    dwPSNReturn = PSNRET_INVALID;
                    break;
            }
        }
    }

    if (PSNRET_NOERROR == dwPSNReturn)
    {
        hResult = ApplySettings(hDlg);
        if (FAILED(hResult))
        {
             DiskQuotaMsgBox(hDlg,
                             IDS_APPLY_SETTINGS_ERROR,
                             IDS_TITLE_DISK_QUOTA,
                             MB_ICONERROR | MB_OK);
            dwPSNReturn = PSNRET_INVALID;
            InitializeControls(hDlg);
        }
    }

    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, dwPSNReturn);

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnSheetNotifyKillActive

    Description: Handler for WM_NOTIFY - PSN_KILLACTIVE.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        TRUE  = Invalid data entered.  Don't kill page.
        FALSE = All data is valid.  Ok to kill page.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnSheetNotifyKillActive(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("VolumePropPage::OnSheetNotifyKillActive")));
    BOOL bAllDataIsValid = TRUE;

    if (bAllDataIsValid)
    {
        KillStatusUpdateTimer(hDlg);
    }

    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, !bAllDataIsValid);

    //
    // Must release quota controller whenever the sheet is deactivated.
    // Without this we were holding open a handle to the volume.  This prevented
    // the disk check utility ("Tools" page) from accessing the volume.
    // Whenever we need an IDiskQuotaControl ptr we call GetQuotaController which
    // will create a new controller if necessary.
    //
    if (NULL != m_pQuotaControl)
    {
        m_pQuotaControl->Release();
        m_pQuotaControl = NULL;
    }

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnSheetNotifyReset

    Description: Handler for WM_NOTIFY - PSN_RESET.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        No return value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnSheetNotifyReset(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("VolumePropPage::OnSheetNotifyReset")));
    HRESULT hResult = NO_ERROR;

    //
    // Nothing to do right now.
    //

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnHelp

    Description: Handler for WM_HELP.  Displays context sensitive help.

    Arguments:
        lParam - Pointer to a HELPINFO structure.

    Returns: TRUE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnHelp(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, STR_DSKQUOUI_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) rgVolumePropPageHelpIDs);
    return TRUE;
}


INT_PTR
VolumePropPage::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem,
            UseWindowsHelp(idCtl) ? NULL : STR_DSKQUOUI_HELPFILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)((LPTSTR)rgVolumePropPageHelpIDs));

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnTimer

    Description: Handler for WM_TIMER.  Updates the quota status text and
        traffic light.

    Arguments:
        wParam - Timer ID.

    Returns: FALSE (0);

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnTimer(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (wParam == m_idStatusUpdateTimer)
    {
        UpdateStatusIndicators(hDlg);
    }

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnEditNotifyUpdate

    Description: Handler for WM_COMMAND, EN_UPDATE.
        Called whenever a character is entered in an edit control.

    Arguments:

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnEditNotifyUpdate(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *rgpxb[2] = { m_pxbDefaultLimit, m_pxbDefaultThreshold };
    const int iLIMIT     = 0;
    const int iTHRESHOLD = 1;
    int iCurrent         = iLIMIT;

    if (IDC_EDIT_DEF_THRESHOLD == LOWORD(wParam))
        iCurrent = iTHRESHOLD;

    if (NULL != rgpxb[iCurrent])
        rgpxb[iCurrent]->OnEditNotifyUpdate(lParam);

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnEditNotifyKillFocus

    Description: Handler for WM_COMMAND, EN_KILLFOCUS.
        Called whenever focus leaves an edit control.
        Validates the value in the edit control and adjusts it if necessary.

    Arguments:

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
    11/12/98    Added code to call XBytes::OnEditKillFocus.          BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnEditNotifyKillFocus(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *rgpxb[2] = { m_pxbDefaultLimit, m_pxbDefaultThreshold };
    const int iLIMIT     = 0;
    const int iTHRESHOLD = 1;
    int iCurrent         = iLIMIT;

    if (IDC_EDIT_DEF_THRESHOLD == LOWORD(wParam))
        iCurrent = iTHRESHOLD;

    if (NULL != rgpxb[iCurrent])
        rgpxb[iCurrent]->OnEditKillFocus(lParam);

    return FALSE;
}


INT_PTR
VolumePropPage::OnEditNotifySetFocus(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Nothing to do.
    // FEATURE:  Delete this method?
    //
    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnComboNotifySelChange

    Description: Handler for WM_COMMAND, CBN_SELCHANGE.
        Called whenever the user selects the combo box.

    Arguments: Std DlgProc args.

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnComboNotifySelChange(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *rgpxb[2] = { m_pxbDefaultLimit, m_pxbDefaultThreshold };
    const int iLIMIT     = 0;
    const int iTHRESHOLD = 1;
    int iCurrent         = iLIMIT;

    if (IDC_CMB_DEF_THRESHOLD == LOWORD(wParam))
        iCurrent = iTHRESHOLD;

    if (NULL != rgpxb[iCurrent])
        rgpxb[iCurrent]->OnComboNotifySelChange(lParam);

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnButtonDetails

    Description: Called when the user selects the "Details" button.
        If a details view is already active for this prop page, it is brought
        to the foreground.  If no details view is already active, a new one
        is created.

    Arguments: Standard DlgProc arguments.

    Returns:

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnButtonDetails(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (!ActivateExistingDetailsView())
    {
        //
        // This property page doesn't have an active details view.
        // Create one.  Note:  If something fails in the details view
        // creation, it isn't displayed.  The DetailsView code is
        // responsible for reporting any errors to the user.
        //
        // NOTE:  The VolumePropPage object never calls "delete"
        //        on the pDetailsView pointer.  The details view
        //        object must live on it's own (modeless) after it is created.
        //        If the VolumePropPage object (this object) is still alive
        //        when the details view object is destroyed, it will receive a
        //        WM_DETAILS_VIEW_DESTROYED message from the view object.  That's
        //        why we pass the hDlg in this constructor.  When this message
        //        is received, we set m_pDetailsView to NULL so that OnButtonDetails
        //        will know to create a new view object.
        //
        DetailsView *pDetailsView = new DetailsView;

        if (!pDetailsView->Initialize(m_idVolume))
        {
            //
            // Something failed.  Either out of memory or the view's thread
            // couldn't start.  Either way, the view won't run.
            // Need to call delete to clean up any partially-completed initialization.
            //
            delete pDetailsView;
        }
    }
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::ActivateExistingDetailsView

    Description: Called by OnButtonDetails to see if there's already a details
                 view active for this volume.  If there is, open it.

    Arguments: None.

    Returns:
        TRUE  = Existing details view was found and promoted to the foreground.
        FALSE = Either no existing view was found or an existing one could
                not be promoted to the foreground.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/25/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
VolumePropPage::ActivateExistingDetailsView(
    VOID
    ) const
{
    BOOL bResult = FALSE;
    CString strVolDisplayName;
    DetailsView::CreateVolumeDisplayName(m_idVolume, &strVolDisplayName);

    CString strDetailsViewTitle(g_hInstDll, IDS_TITLE_MAINWINDOW, (LPCTSTR)strVolDisplayName);

    HWND hwndDetailsView = FindWindow(c_szWndClassDetailsView,
                                      strDetailsViewTitle);

    if (NULL != hwndDetailsView)
    {
        //
        // Restore the details view and bring it to the front.
        //
        ShowWindow(hwndDetailsView, SW_RESTORE);
        bResult = SetForegroundWindow(hwndDetailsView);
    }

    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::ApplySettings

    Description: Applies the current settings to the volume if they have
        changed from the original settings.

    Arguments:
        hDlg - Dialog window handle.

    Returns:
        NO_ERROR            - Success.
        E_INVALIDARG        - One of the settings was invalid.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        E_FAIL              - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::ApplySettings(
    HWND hDlg
    )
{
    HRESULT hResult         = NO_ERROR;
    DWORD dwStateSetting    = 0;
    DWORD dwLogFlagSettings = m_dwQuotaLogFlags;
    BOOL  bTranslated       = FALSE;
    LONGLONG llThreshold;
    LONGLONG llLimit;
    IDiskQuotaControl *pqc;

    hResult = GetQuotaController(&pqc);
    if (SUCCEEDED(hResult))
    {
        //
        // Set quota state if changed.
        //
        QuotaStateFromControls(hDlg, &dwStateSetting);
        if (dwStateSetting != (m_dwQuotaState & DISKQUOTA_STATE_MASK))
        {
            hResult = pqc->SetQuotaState(dwStateSetting);
            if (FAILED(hResult))
                goto apply_failed;

            m_dwQuotaState = dwStateSetting;
        }

        //
        // Set quota log flags if changed.
        //
        LogFlagsFromControls(hDlg, &dwLogFlagSettings);
        if (dwLogFlagSettings != m_dwQuotaLogFlags)
        {
            hResult = pqc->SetQuotaLogFlags(dwLogFlagSettings);
            if (FAILED(hResult))
                goto apply_failed;

            m_dwQuotaLogFlags = dwLogFlagSettings;
        }

        //
        // Get current default quota threshold and limit values.
        //
        if (IsDlgButtonChecked(hDlg, IDC_RBN_DEF_NOLIMIT))
        {
            llThreshold = NOLIMIT;
            llLimit     = NOLIMIT;
        }
        else
        {
            llThreshold = m_pxbDefaultThreshold->GetBytes();
            llLimit     = m_pxbDefaultLimit->GetBytes();
        }

        //
        // Set default quota threshold if changed.
        //
        if (llThreshold != m_llDefaultQuotaThreshold)
        {
            hResult = pqc->SetDefaultQuotaThreshold(llThreshold);
            if (FAILED(hResult))
                goto apply_failed;

            m_llDefaultQuotaThreshold = llThreshold;
        }

        //
        // Set default quota limit if changed.
        //
        if (llLimit != m_llDefaultQuotaLimit)
        {
            hResult = pqc->SetDefaultQuotaLimit(llLimit);
            if (FAILED(hResult))
                goto apply_failed;

            m_llDefaultQuotaLimit = llLimit;
        }

apply_failed:

        pqc->Release();
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::RefreshCachedVolumeInfo

    Description: Reads the volume's quota information and stores it in
        member variables.

    Arguments: None.

    Returns:
        NO_ERROR            - Success.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        E_FAIL              - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::RefreshCachedVolumeQuotaInfo(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    IDiskQuotaControl *pqc;

    hResult = GetQuotaController(&pqc);
    if (SUCCEEDED(hResult))
    {
        //
        // Read quota state.
        //
        hResult = pqc->GetQuotaState(&m_dwQuotaState);
        if (FAILED(hResult))
            goto refresh_vol_info_failed;

        //
        // Read quota log flags.
        //
        hResult = pqc->GetQuotaLogFlags(&m_dwQuotaLogFlags);
        if (FAILED(hResult))
            goto refresh_vol_info_failed;

        //
        // Read default quota threshold.
        //
        hResult = pqc->GetDefaultQuotaThreshold(&m_llDefaultQuotaThreshold);
        if (FAILED(hResult))
            goto refresh_vol_info_failed;

        //
        // Read default quota limit.
        //
        hResult = pqc->GetDefaultQuotaLimit(&m_llDefaultQuotaLimit);

refresh_vol_info_failed:

        pqc->Release();
    }

    return hResult;
}


//
// Determine if a given disk quota policy value is set.
//
bool
VolumePropPage::SetByPolicy(
    LPCTSTR pszPolicyValue
    )
{
    DWORD dwData;
    DWORD dwType;
    DWORD cbData = sizeof(dwData);

    return (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                        REGSTR_KEY_POLICYDATA,
                                        pszPolicyValue,
                                        &dwType,
                                        &dwData,
                                        &cbData));
}                                         


HRESULT
VolumePropPage::EnableControls(
    HWND hwndDlg
    )
{    
    BOOL bQuotaEnabled = (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CBX_ENABLE_QUOTA));
    BOOL bEnable;

    //
    // "Enable quota management" checkbox.
    //
    //  Policy   Quota Enabled     Ctl Enabled
    //    0            0                1
    //    0            1                1
    //    1            0                0
    //    1            1                0
    //
    EnableWindow(GetDlgItem(hwndDlg, IDC_CBX_ENABLE_QUOTA), 
                 !SetByPolicy(REGSTR_VAL_POLICY_ENABLE));
    //
    // "Deny disk space..." checkbox.
    //
    //  Policy   Quota Enabled     Ctl Enabled
    //    0            0                0
    //    0            1                1
    //    1            0                0
    //    1            1                0
    //
    EnableWindow(GetDlgItem(hwndDlg, IDC_CBX_DENY_LIMIT), 
                 bQuotaEnabled && !SetByPolicy(REGSTR_VAL_POLICY_ENFORCE));
    //                 
    // Log event checkboxes
    //
    //  Policy   Quota Enabled     Ctl Enabled
    //    0            0                0
    //    0            1                1
    //    1            0                0
    //    1            1                0
    //
    EnableWindow(GetDlgItem(hwndDlg, IDC_CBX_LOG_OVERLIMIT),
                 bQuotaEnabled && !SetByPolicy(REGSTR_VAL_POLICY_LOGLIMIT));

    EnableWindow(GetDlgItem(hwndDlg, IDC_CBX_LOG_OVERWARNING),
                 bQuotaEnabled && !SetByPolicy(REGSTR_VAL_POLICY_LOGTHRESHOLD));

    //
    // "Do not limit disk usage" radio button
    // "Limit disk space to" radio button
    //
    //  Policy    Quota Enabled     No Limit    Ctl Enabled
    //    0            0               0            0
    //    0            0               1            0
    //    0            1               0            0
    //    0            1               1            1
    //    1            0               0            0
    //    1            0               1            0
    //    1            1               0            0
    //    1            1               1            0
    //
    bEnable = bQuotaEnabled && !SetByPolicy(REGSTR_VAL_POLICY_LIMIT);
              
    EnableWindow(GetDlgItem(hwndDlg, IDC_RBN_DEF_NOLIMIT),    bEnable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_RBN_DEF_LIMIT),      bEnable);
    //
    //  "Limit disk space" edit and combo controls.
    //
    //  Policy    Quota Enabled     No Limit    Ctl Enabled
    //    0            0               0            0
    //    0            0               1            0
    //    0            1               0            1
    //    0            1               1            0
    //    1            0               0            0
    //    1            0               1            0
    //    1            1               0            0
    //    1            1               1            0
    //
    bEnable = bQuotaEnabled && 
              !SetByPolicy(REGSTR_VAL_POLICY_LIMIT) &&
              NOLIMIT != m_pxbDefaultLimit->GetBytes();

    EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT_DEF_LIMIT),     bEnable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_CMB_DEF_LIMIT),      bEnable);

    bEnable = bQuotaEnabled && 
              !SetByPolicy(REGSTR_VAL_POLICY_THRESHOLD) &&
              NOLIMIT != m_pxbDefaultThreshold->GetBytes();

    EnableWindow(GetDlgItem(hwndDlg, IDC_TXT_WARN_LEVEL),     bEnable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT_DEF_THRESHOLD), bEnable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_CMB_DEF_THRESHOLD),  bEnable);
    //
    // Miscellaneous text controls.
    //
    //  Quota Enabled     Ctl Enabled
    //        0                0
    //        1                1
    //
    EnableWindow(GetDlgItem(hwndDlg, IDC_TXT_DEFAULTS), bQuotaEnabled);
    EnableWindow(GetDlgItem(hwndDlg, IDC_TXT_LOGGING),  bQuotaEnabled);

    return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::InitializeControls

    Description: Initializes the page controls based on the volume's
        quota settings.

    Arguments:
        hDlg - Dialog window handle.

    Returns:
        NO_ERROR - Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    08/01/97    Removed IDC_CBX_WARN_THRESHOLD from UI.              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::InitializeControls(
    HWND hDlg
    )
{
    BOOL bQuotaEnabled  = !(DISKQUOTA_IS_DISABLED(m_dwQuotaState));
    BOOL bUnlimited     = (NOLIMIT == m_llDefaultQuotaLimit);

    CheckDlgButton(hDlg,
                   IDC_CBX_ENABLE_QUOTA,
                   bQuotaEnabled);

    CheckDlgButton(hDlg,
                   IDC_CBX_DENY_LIMIT,
                   DISKQUOTA_IS_ENFORCED(m_dwQuotaState));

    CheckDlgButton(hDlg,
                   IDC_CBX_LOG_OVERWARNING,
                   !DISKQUOTA_IS_DISABLED(m_dwQuotaState) &&
                   DISKQUOTA_IS_LOGGED_USER_THRESHOLD(m_dwQuotaLogFlags));

    CheckDlgButton(hDlg,
                   IDC_CBX_LOG_OVERLIMIT,
                   !DISKQUOTA_IS_DISABLED(m_dwQuotaState) &&
                   DISKQUOTA_IS_LOGGED_USER_LIMIT(m_dwQuotaLogFlags));

    CheckDlgButton(hDlg, IDC_RBN_DEF_NOLIMIT,  bUnlimited);
    CheckDlgButton(hDlg, IDC_RBN_DEF_LIMIT,   !bUnlimited);

    EnableControls(hDlg);

    return NO_ERROR;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::UpdateStatusIndicators
    Description: Updates the "Status" text message at the top of the property
        page according to the actual quota system state.  Also updates the
        traffic light AVI clip.

    Arguments:
        hDlg - Dialog handle.

    Returns:
        Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/18/96    Initial creation.                                    BrianAu
    08/28/96    Added stoplight icon.                                BrianAu
    09/10/96    Converted stoplight from an icon to an AVI clip.     BrianAu
                Call it a traffic light now.
    07/14/97    Removed distinct "enforce" and "tracking" messages   BrianAu
                and replaced with a single "active" message.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::UpdateStatusIndicators(
    HWND hDlg
    )
{
    HRESULT hResult = NO_ERROR;
    DWORD dwMsgID   = IDS_STATUS_UNKNOWN;
    IDiskQuotaControl *pqc;

    hResult = GetQuotaController(&pqc);
    if (SUCCEEDED(hResult))
    {
        //
        // Update cached state information.
        //
        hResult = pqc->GetQuotaState(&m_dwQuotaState);
        pqc->Release();
        pqc = NULL;

    }
    if (SUCCEEDED(hResult))
    {
        //
        // Figure out what message to display.
        // "Rebuilding" overrides any other state.
        //
        if (DISKQUOTA_FILE_REBUILDING(m_dwQuotaState))
        {
            dwMsgID = IDS_STATUS_REBUILDING;
        }
        else switch(m_dwQuotaState & DISKQUOTA_STATE_MASK)
        {
            case DISKQUOTA_STATE_DISABLED:
                dwMsgID = IDS_STATUS_DISABLED;
                break;
            case DISKQUOTA_STATE_TRACK:
            case DISKQUOTA_STATE_ENFORCE:
                dwMsgID = IDS_STATUS_ACTIVE;
                break;
            default:
                break;
        }
    }

    if (dwMsgID != m_dwLastStatusMsgID)
    {
        //
        // Format the status text and configure the traffic light.
        //
        // Traffic light states:
        // RED             = Quotas disabled.
        // GREEN           = Quotas enabled.
        // Flashing YELLOW = Quota file is rebuilding.
        //
        INT iTrafficLightState = TrafficLight::GREEN;

        if (DISKQUOTA_FILE_REBUILDING(m_dwQuotaState))
            iTrafficLightState = TrafficLight::FLASHING_YELLOW;
        else if (DISKQUOTA_IS_DISABLED(m_dwQuotaState))
            iTrafficLightState = TrafficLight::RED;

        m_TrafficLight.Show(iTrafficLightState);

        CString strStatus(g_hInstDll, dwMsgID);
        SetWindowText(GetDlgItem(hDlg, IDC_TXT_QUOTA_STATUS), strStatus);

        m_dwLastStatusMsgID = dwMsgID;
        //
        // Re-initialize the controls based on the new state.
        //
        InitializeControls(hDlg);
    }

    return NO_ERROR;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::QuotaStateFromControls

    Description: Determines the quota state from the states of the individual
        controls on the page.

    Arguments:
        hDlg - Dialog's window handle.

        pdwState - Address of DWORD variable to receive state bits.

    Returns:
        Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::QuotaStateFromControls(
    HWND hDlg,
    LPDWORD pdwState
    ) const
{
    DBGASSERT((NULL != pdwState));

    //
    // Set quota state if changed.
    //
    if (IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA))
    {
        if (IsDlgButtonChecked(hDlg, IDC_CBX_DENY_LIMIT))
        {
            *pdwState = DISKQUOTA_STATE_ENFORCE;
        }
        else
            *pdwState = DISKQUOTA_STATE_TRACK;
    }
    else
        *pdwState = DISKQUOTA_STATE_DISABLED;

    return NO_ERROR;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::LogFlagsFromControls

    Description: Determines the log flags state from the states of the
        individual controls on the page.

    Arguments:
        hDlg - Dialog's window handle.

        pdwLogFlags - Address of DWORD variable to receive flag bits.

    Returns:
        Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/19/96    Initial creation.                                    BrianAu
    08/01/97    Removed IDC_CBX_WARN_THRESHOLD from UI.              BrianAu
    11/20/98    Added "log over limit" and "log over warning"        BrianAu
                controls.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::LogFlagsFromControls(
    HWND hDlg,
    LPDWORD pdwLogFlags
    ) const
{
    DBGASSERT((NULL != pdwLogFlags));
    DISKQUOTA_SET_LOG_USER_LIMIT(*pdwLogFlags,
                                 IsDlgButtonChecked(hDlg, IDC_CBX_LOG_OVERLIMIT));

    DISKQUOTA_SET_LOG_USER_THRESHOLD(*pdwLogFlags,
                                     IsDlgButtonChecked(hDlg, IDC_CBX_LOG_OVERWARNING));

    return NO_ERROR;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::TrafficLight::Initialize

    Description: Initializes the traffic light by opening the AVI clip.

    Arguments:
        hwndAnimateCtl - Handle to the animation control in the dialog.

        idAviClipRes - Resource ID of the AVI clip resource.

    Returns: Nothing.  If the thing doesn't load, it just won't play.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
VolumePropPage::TrafficLight::Initialize(
    HWND hwndAnimateCtl,
    INT idAviClipRes
    )
{
    DBGASSERT((NULL != hwndAnimateCtl));

    m_hwndAnimateCtl = hwndAnimateCtl;
    m_idAviClipRes   = idAviClipRes;

    Animate_Open(m_hwndAnimateCtl, MAKEINTRESOURCE(idAviClipRes));
//
// See note in TrafficLight::Show below.
//
//    Animate_SetFrameTime(m_hwndAnimateCtl, GetCaretBlinkTime());
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::TrafficLight::Show

    Description: Shows the traffic light in one of it's states.

    Arguments:
        eShow - One of the following enumerated constant values:

            OFF, YELLOW, RED, GREEN, FLASHING_YELLOW.

        NOTE:   THIS IS VERY IMPORTANT!!!

                The definitions of these constants MUST match as follows
                with the frame numbers in the AVI clip TRAFFIC.AVI.  If
                you change either, it won't work.

                Frame  Constant         Value
                ------ ---------------- ------
                  0     OFF               0
                  1     YELLOW            1
                  2     RED               2
                  3     GREEN             3
                N/A     FLASHING_YELLOW   4

                Flashing yellow is created by playing frames 0 and 1
                repeatedly.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
VolumePropPage::TrafficLight::Show(
    INT eShow
    )
{
    switch(eShow)
    {
        case OFF:
        case YELLOW:
        case RED:
        case GREEN:
            Animate_Seek(m_hwndAnimateCtl, eShow);
            break;

        case FLASHING_YELLOW:
            Animate_Seek(m_hwndAnimateCtl, YELLOW);
//
// NOTE:
//
// The common control guys didn't want me to add the ACM_SETFRAMETIME
// message so we can't vary the rate of the animation.  Since we can't
// have a fixed-rate blinking control, I'm just fixing the traffic light
// at yellow rather than flashing.  If we can ever add the frame time
// modification message to the animation control, we can activate
// this functionality.  A flashing light isn't worth the trouble of
// a unique implementation.  I really wanted this.  It looks cool.
//
// FEATURE:  If we have time.  Make this work without the animation control.
//          Note that I tried just setting the icon.  But since the volume
//          status checking is done on the same thread that processes the
//          STM_SETICON messgae, flashing of the icon is erratic.
//
//            Animate_Play(m_hwndAnimateCtl, YELLOW, OFF, (UINT)-1);
            break;

        default:
            break;
    }
}


INT_PTR
VolumePropPage::TrafficLight::ForwardMessage(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return SendMessage(m_hwndAnimateCtl, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\dskquota\ui\userprop.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: userprop.cpp

    Description: Provides implementations for quota user property page.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/25/98    Replaced AddUserPropSheet with AddUserDialog.        BrianAu
                Now that we're getting user info from the DS
                object picker, the prop sheet idea doesn't work
                so well.  A std dialog is better.
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include <lm.h>
#include "undo.h"
#include "userprop.h"
#include "userbat.h"
#include "uihelp.h"
#include "progress.h"
#include "uiutils.h"

//
// Context help IDs.
//
#pragma data_seg(".text", "CODE")
const static DWORD rgUserPropSheetHelpIDs[] =
{
    IDC_ICON_USER,               DWORD(-1),
    IDC_STATIC2,                 DWORD(-1),
    IDC_TXT_USERNAME,            IDH_TXT_USERNAME,
    IDC_TXT_SPACEUSED,           IDH_TXT_SPACEUSED,
    IDC_TXT_SPACEREMAINING,      IDH_TXT_SPACEREMAINING,
    IDC_LBL_SPACEUSED,           DWORD(-1),
    IDC_LBL_SPACEREMAINING,      DWORD(-1),
    IDC_ICON_USERSTATUS,         IDH_ICON_USERSTATUS,
    IDC_RBN_USER_NOLIMIT,        IDH_RBN_USER_NOLIMIT,
    IDC_RBN_USER_LIMIT,          IDH_RBN_USER_LIMIT,
    IDC_TXT_WARN_LEVEL,          DWORD(-1),
    IDC_EDIT_USER_LIMIT,         IDH_EDIT_USER_LIMIT,
    IDC_EDIT_USER_THRESHOLD,     IDH_EDIT_USER_THRESHOLD,
    IDC_CMB_USER_LIMIT,          IDH_CMB_USER_LIMIT,
    IDC_CMB_USER_THRESHOLD,      IDH_CMB_USER_THRESHOLD,
    0,0
};

#pragma data_seg()


//
// Messages for querying property page for icon images.
//
#define DQM_QUERY_STATUS_ICON      (WM_USER + 1)
#define DQM_QUERY_USER_ICON        (WM_USER + 2)
#define DQM_ENABLE_APPLY_BUTTON    (WM_USER + 3)

///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::UserPropSheet

    Description: Constructor for a user property sheet object.
        Initializes the members that hold user quota data.

    Arguments: None.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UserPropSheet::UserPropSheet(
    PDISKQUOTA_CONTROL pQuotaControl,
    const CVolumeID& idVolume,
    HWND hWndParent,
    LVSelection& LVSel,
    UndoList& UndoList
    ) : m_cVolumeMaxBytes(0),
        m_pQuotaControl(pQuotaControl),
        m_UndoList(UndoList),
        m_LVSelection(LVSel),
        m_hWndParent(hWndParent),
        m_bIsDirty(FALSE),
        m_bHomogeneousSelection(TRUE),  // Assume selection is homogeneous.
        m_pxbQuotaLimit(NULL),
        m_pxbQuotaThreshold(NULL),
        m_idVolume(idVolume),
        m_strPageTitle(g_hInstDll, IDS_TITLE_GENERAL),
        m_idCtlNextFocus(-1)
{
    DBGASSERT((NULL != m_pQuotaControl));
    DBGASSERT((NULL != m_hWndParent));
    DBGTRACE((DM_UPROP, DL_HIGH, TEXT("UserPropSheet::UserPropSheet")));

    m_llQuotaUsed      = 0;
    m_llQuotaLimit     = 0;
    m_llQuotaThreshold = 0;

    DBGASSERT((0 == iICON_USER_SINGLE));
    DBGASSERT((1 == iICON_USER_MULTIPLE));
    m_hIconUser[0]     = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_SINGLE_USER));
    m_hIconUser[1]     = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_MULTI_USER));

    DBGASSERT((0 == iICON_STATUS_OK));
    DBGASSERT((1 == iICON_STATUS_OVER_THRESHOLD));
    DBGASSERT((2 == iICON_STATUS_OVER_LIMIT));
    m_hIconStatus[0]   = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_OKBUBBLE));
    m_hIconStatus[1]   = LoadIcon(NULL, IDI_WARNING);
    m_hIconStatus[2]   = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_WARNERR));
}



UserPropSheet::~UserPropSheet(
    VOID
    )
{
    DBGTRACE((DM_UPROP, DL_HIGH, TEXT("UserPropSheet::~UserPropSheet")));
    INT i = 0;

    if (NULL != m_pQuotaControl)
        m_pQuotaControl->Release();

    if (NULL != m_pxbQuotaLimit)
        delete m_pxbQuotaLimit;
    if (NULL != m_pxbQuotaThreshold)
        delete m_pxbQuotaThreshold;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::Run

    Description: Creates and runs the property sheet dialog.
        This is the only method a client needs to call once the object
        is created.

    Arguments: None.

    Returns:
        NO_ERROR
        E_FAIL      - Couldn't create property sheet.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UserPropSheet::Run(
    VOID
    )
{
    HRESULT hResult = NO_ERROR; // Assume success.

    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;

    ZeroMemory(&psh, sizeof(psh));
    ZeroMemory(&psp, sizeof(psp));

    //
    // Define page.
    //
    psp.dwSize          = sizeof(PROPSHEETPAGE);
    psp.dwFlags         = PSP_USEREFPARENT | PSP_USETITLE;
    psp.hInstance       = g_hInstDll;
    psp.pszTemplate     = MAKEINTRESOURCE(IDD_PROPPAGE_USERQUOTA);
    psp.pszTitle        = (LPCTSTR)m_strPageTitle;
    psp.pfnDlgProc      = DlgProc;
    psp.lParam          = (LPARAM)this;
    psp.pcRefParent     = (UINT *)& g_cRefThisDll;

    //
    // Define sheet.
    //
    psh.dwSize          = sizeof(PROPSHEETHEADER);
    psh.dwFlags         = PSH_PROPSHEETPAGE;
    psh.hwndParent      = m_hWndParent;
    psh.hInstance       = g_hInstDll;
    psh.pszIcon         = NULL;
    psh.pszCaption      = NULL;
    psh.nPages          = 1;
    psh.nStartPage      = 0;
    psh.ppsp            = (LPCPROPSHEETPAGE)&psp;

    if (0 <= PropertySheet(&psh))
        hResult = E_FAIL;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::DlgProc

    Description: Static method called by windows to process messages for the
        property page dialog.  Since it's static, we have to save the "this"
        pointer in the window's USERDATA.

    Arguments: Standard WndProc-type arguments.

    Returns: Standard WndProc-type return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY
UserPropSheet::DlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR bResult = FALSE;

    //
    // Retrieve the "this" pointer from the dialog's userdata.
    // It was placed there in OnInitDialog().
    //
    UserPropSheet *pThis = (UserPropSheet *)GetWindowLongPtr(hDlg, DWLP_USER);

    try
    {
        switch(message)
        {
            case WM_INITDIALOG:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_INITDIALOG")));
                bResult = OnInitDialog(hDlg, wParam, lParam);
                break;

            case WM_NOTIFY:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY")));
                bResult = pThis->OnNotify(hDlg, wParam, lParam);
                break;

            case WM_COMMAND:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_COMMAND")));
                bResult = pThis->OnCommand(hDlg, wParam, lParam);
                break;

            case WM_HELP:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_HELP")));
                bResult = pThis->OnHelp(hDlg, wParam, lParam);
                break;

            case WM_CONTEXTMENU:
                bResult = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
                break;

            case WM_DESTROY:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_DESTROY")));
                break;

            case WM_CLOSE:
            case WM_ENDSESSION:
                DestroyWindow(hDlg);
                break;

            case DQM_ENABLE_APPLY_BUTTON:
                pThis->m_bIsDirty = TRUE;
                bResult = PropSheet_Changed(GetParent(hDlg), hDlg);
                break;

            //
            // These two icon query messages are for automated testing
            // of the UI.
            //
            case DQM_QUERY_USER_ICON:
                bResult = pThis->QueryUserIcon(hDlg);
                break;

            case DQM_QUERY_STATUS_ICON:
                bResult = pThis->QueryUserStatusIcon(hDlg);
                break;

            default:
                break;
        }

    }
    catch(CAllocException& e)
    {
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnInitDialog

    Description: Handler for WM_INITDIALOG.  Retrieves the "this" pointer from
        the PROPSHEETPAGE structure (pointed to by lParam) and saves it in
        the window's USERDATA.

    Arguments:
        hDlg - Dialog window handle.

        wParam - Handle of control to receive focus if we return FALSE.

        lParam - Pointer to PROPSHEETPAGE structure for the property page.

    Returns:
        TRUE  = Tells windows to assign focus to the control in wParam.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnInitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hResult = NO_ERROR;

    PROPSHEETPAGE *pPage = (PROPSHEETPAGE *)lParam;
    UserPropSheet *pThis = (UserPropSheet *)pPage->lParam;
    DWORD dwSectorsPerCluster = 0;
    DWORD dwBytesPerSector    = 0;
    DWORD dwFreeClusters      = 0;
    DWORD dwTotalClusters     = 0;

    DBGASSERT((NULL != pThis));

    //
    // Save "this" in the window's userdata.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, (INT_PTR)pThis);

    //
    // Read quota info from NTFS.
    // For single selection, we cache the selected user's info.
    // For multi selection, we cache the defaults for the volume.
    // If adding a new user (count == 0), we also use the defaults for the
    // volume.
    //
    pThis->RefreshCachedQuotaInfo();

    //
    // Calculate the volume's size.
    // We'll use this to limit user threshold and quota limit entries.
    //
    if (GetDiskFreeSpace(pThis->m_idVolume.ForParsing(),
                         &dwSectorsPerCluster,
                         &dwBytesPerSector,
                         &dwFreeClusters,
                         &dwTotalClusters))
    {
        pThis->m_cVolumeMaxBytes = (LONGLONG)dwSectorsPerCluster *
                                   (LONGLONG)dwBytesPerSector *
                                   (LONGLONG)dwTotalClusters;
    }

    pThis->m_pxbQuotaLimit     = new XBytes(hDlg,
                                            IDC_EDIT_USER_LIMIT,
                                            IDC_CMB_USER_LIMIT,
                                            pThis->m_llQuotaLimit);
    pThis->m_pxbQuotaThreshold = new XBytes(hDlg,
                                            IDC_EDIT_USER_THRESHOLD,
                                            IDC_CMB_USER_THRESHOLD,
                                            pThis->m_llQuotaThreshold);

    pThis->InitializeControls(hDlg);

    return TRUE;  // Set focus to default control.
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::RefreshCachedQuotaInfo

    Description: Reads the quota limit, threshold and used values from the
        property sheet's user object.  If multiple users are selected,
        only the first one is read.

    Arguments: None.

    Returns: Result of read operation.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UserPropSheet::RefreshCachedQuotaInfo(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;
    PDISKQUOTA_USER pUser = NULL;
    INT cSelectedUsers = m_LVSelection.Count();

    m_LVSelection.Retrieve(0, &pUser);

    //
    // Read quota threshold.  Multi-user selections use the volume's default.
    //
    if (1 == cSelectedUsers)
    {
        hResult = pUser->GetQuotaThreshold(&m_llQuotaThreshold);
    }
    else
    {
        hResult = m_pQuotaControl->GetDefaultQuotaThreshold(&m_llQuotaThreshold);
    }
    if (FAILED(hResult))
        goto refresh_quota_info_failed;

    //
    // Read quota limit.  Multi-user selections use the volume's default.
    //
    if (1 == cSelectedUsers)
    {
        hResult = pUser->GetQuotaLimit(&m_llQuotaLimit);
    }
    else
    {
        hResult = m_pQuotaControl->GetDefaultQuotaLimit(&m_llQuotaLimit);
    }
    if (FAILED(hResult))
        goto refresh_quota_info_failed;


    //
    // Read quota used.
    //
    if (1 == cSelectedUsers)
    {
        hResult = pUser->GetQuotaUsed(&m_llQuotaUsed);
    }
    else
    {
        m_llQuotaUsed = 0;
    }

refresh_quota_info_failed:
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnCommand

    Description: Handler for WM_COMMAND.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of selected control and notification code.

        lParam - HWND of selected control.

    Returns:
        TRUE  = Message wasn't handled.
        FALSE = Message was handled.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD dwCtlId        = LOWORD(wParam);
    HWND hWndCtl         = (HWND)lParam;
    DWORD dwNotifyCode   = HIWORD(wParam);
    INT_PTR bResult      = FALSE;

    switch(dwCtlId)
    {
        case IDC_TXT_USERNAME:
            if (EN_SETFOCUS == dwNotifyCode && IDC_EDIT_USER_THRESHOLD == m_idCtlNextFocus)
            {
                //
                // Focus is being set as a result of an invalid entry
                // in the warning level field.  Force input focus to the
                // field and select the entire contents.  User can then just
                // enter a new value.
                //
                SetFocus(GetDlgItem(hDlg, IDC_EDIT_USER_THRESHOLD));
                SendDlgItemMessage(hDlg, IDC_EDIT_USER_THRESHOLD, EM_SETSEL, 0, -1);
                m_idCtlNextFocus = -1;
            }
            break;

        case IDC_RBN_USER_NOLIMIT:
            if (m_pxbQuotaThreshold->IsEnabled())
            {
                //
                // This is simple.  Just set both the limit and threshold controls
                // to "no limit".
                //
                m_pxbQuotaThreshold->SetBytes(NOLIMIT);
                m_pxbQuotaLimit->SetBytes(NOLIMIT);
                m_bIsDirty = TRUE;
            }
            break;

        case IDC_RBN_USER_LIMIT:
        {
            LONGLONG llValue;

            //
            // This handler needs some logic.  We have to handle several
            // scenarios/rules with this one.
            // 1. Single vs. Multiple selection.
            // 2. Single selection for Administrator account.
            // 3. Multi selection homogeneous/heterogenous with respect to
            //    quota limit and threshold values.
            // 4. Can't display "No Limit" in edit controls when they're active.
            // 5. Use volume defaults for new user and hetergenous multi-select.
            //
            if (!m_pxbQuotaThreshold->IsEnabled())
            {
                enum use_types { USE_CACHED, USE_VOLDEF, USE_NOLIMIT };

                INT iUseAsValue = USE_CACHED;
                INT cSelected   = m_LVSelection.Count();

                ///////////////////////////////////////////////////////////////
                // First set the quota limit controls.
                ///////////////////////////////////////////////////////////////
                if (0 == cSelected)                     // Adding new user...
                {
                    iUseAsValue = USE_VOLDEF;
                }
                else if (1 == cSelected)                // One user selected...
                {
                    PDISKQUOTA_USER pUser = NULL;
                    m_LVSelection.Retrieve(0, &pUser);
                    if (UserIsAdministrator(pUser))
                    {
                        //
                        // If user is administrator, the limit is always "No Limit".
                        // This will disable the "Limit" controls and prevent
                        // user from setting a limit on this account.
                        //
                        iUseAsValue = USE_NOLIMIT;
                    }
                    else if (NOLIMIT == m_llQuotaLimit)
                    {
                        //
                        // Account isn't Administrator AND the limit is NOLIMIT.
                        // Use the volume's default "new user" limit value.
                        //
                        iUseAsValue = USE_VOLDEF;
                    }
                }
                else if (!m_bHomogeneousSelection || NOLIMIT == m_llQuotaLimit) // Multiple user.
                {
                    //
                    // Multiple non-homogeneous users get the volume's default limit.
                    // Multiple homogeneous users get their current cached setting unless
                    // the cached setting is NOLIMIT; in which case, they get the
                    // volume's defaults.
                    //
                    iUseAsValue = USE_VOLDEF;
                }

                //
                // Set the proper quota limit value in the edit/combo box control.
                //
                llValue = 0;
                switch(iUseAsValue)
                {
                    case USE_VOLDEF:
                        m_pQuotaControl->GetDefaultQuotaLimit(&llValue);
                        //
                        // If default is NOLIMIT, display 0 MB.  We can't display an
                        // "editable" No Limit in the edit control.  Only numbers.
                        //
                        if (NOLIMIT == llValue)
                            llValue = 0;
                        break;

                    case USE_NOLIMIT:
                        llValue = NOLIMIT;
                        break;

                    case USE_CACHED:
                        llValue = m_llQuotaLimit;
                        break;
                }

                m_pxbQuotaLimit->SetBytes(llValue);


                ///////////////////////////////////////////////////////////////
                // Now the threshold controls...
                ///////////////////////////////////////////////////////////////
                llValue = 0;
                iUseAsValue       = USE_CACHED;
                if (0 == cSelected)
                {
                    iUseAsValue = USE_VOLDEF;
                }
                else if (1 == cSelected)
                {
                    if (NOLIMIT == m_llQuotaThreshold)
                    {
                        iUseAsValue = USE_VOLDEF;
                    }
                }
                else if (!m_bHomogeneousSelection || NOLIMIT == m_llQuotaThreshold)
                {
                    iUseAsValue = USE_VOLDEF;
                }

                //
                // Set the proper quota threshold value in the edit/combo box control.
                //
                switch(iUseAsValue)
                {
                    case USE_VOLDEF:
                        m_pQuotaControl->GetDefaultQuotaThreshold(&llValue);
                        //
                        // If default is NOLIMIT, display 0 MB.  We can't display an
                        // "editable" No Limit in the edit control.  Only numbers.
                        //
                        if (NOLIMIT == llValue)
                            llValue = 0;
                        break;

                    case USE_NOLIMIT:
                        llValue = NOLIMIT;
                        break;

                    case USE_CACHED:
                        llValue = m_llQuotaThreshold;
                        break;
                }

                m_pxbQuotaThreshold->SetBytes(llValue);

                m_bIsDirty = TRUE;
            }
            break;
        }

        case IDC_EDIT_USER_LIMIT:
        case IDC_EDIT_USER_THRESHOLD:
            switch(dwNotifyCode)
            {
                case EN_UPDATE:
                    DBGPRINT((DM_WND, DL_MID, TEXT("OnCommand, EN_CHANGE")));
                    bResult = OnEditNotifyUpdate(hDlg, wParam, lParam);
                    m_bIsDirty = TRUE;
                    break;

                case EN_KILLFOCUS:
                    DBGPRINT((DM_WND, DL_MID, TEXT("OnCommand, EN_KILLFOCUS")));
                    bResult = OnEditNotifyKillFocus(hDlg, wParam, lParam);
                    break;

                default:
                    break;
            }
            break;

        case IDC_CMB_USER_LIMIT:
        case IDC_CMB_USER_THRESHOLD:
            switch(dwNotifyCode)
            {
                case CBN_SELCHANGE:
                    DBGPRINT((DM_WND, DL_MID, TEXT("OnCommand, CBN_CHANGE")));
                    bResult = OnComboNotifySelChange(hDlg, wParam, lParam);
                    m_bIsDirty = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default:
            bResult = TRUE;  // Didn't handle message.
            break;
    }


    if (m_bIsDirty)
        PropSheet_Changed(GetParent(hDlg), hDlg);

    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnNotify

    Description: Handler for WM_NOTIFY.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of selected control and notification code.

        lParam - HWND of selected control.

    Returns:
        TRUE  = Message wasn't handled.
        FALSE = Message was handled.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnNotify(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR bResult = FALSE;

    switch(((NMHDR *)lParam)->code)
    {
        case PSN_SETACTIVE:
            DBGPRINT((DM_WND, DL_MID, TEXT("OnNotify, PSN_SETACTIVE")));
            bResult = OnSheetNotifySetActive(hDlg, wParam, lParam);
            break;

        case PSN_APPLY:
            DBGPRINT((DM_WND, DL_MID, TEXT("OnNotify, PSN_APPLY")));
            bResult = OnSheetNotifyApply(hDlg, wParam, lParam);
            break;

        case PSN_KILLACTIVE:
            DBGPRINT((DM_WND, DL_MID, TEXT("OnNotify, PSN_KILLACTIVE")));
            bResult = OnSheetNotifyKillActive(hDlg, wParam, lParam);
            break;

        case PSN_RESET:
            DBGPRINT((DM_WND, DL_MID, TEXT("OnNotify, PSN_RESET")));
            //
            // Fall through.
            //
        default:
            break;
    }
    return bResult;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnSheetNotifySetActive

    Description: Handler for WM_NOTIFY - PSN_SETACTIVE.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        FALSE = Accept activation.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnSheetNotifySetActive(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnSheetNotifyApply

    Description: Handler for WM_NOTIFY - PSN_APPLY.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        TRUE = PSN return value set using SetWindowLong.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnSheetNotifyApply(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hResult  = NO_ERROR;
    LONG dwPSNReturn = PSNRET_NOERROR;

    //
    // Only apply settings if the "Apply" button is enabled indicating
    // that something has been changed.  No need to apply unchanged
    // settings when the OK button is pressed.
    //
    if (m_bIsDirty)
    {
        if (PSNRET_NOERROR == dwPSNReturn)
        {
            //
            // We need to do this because if you activate the apply button
            // with Alt-A we receive PSN_APPLY before EN_KILLFOCUS.
            //
            m_pxbQuotaThreshold->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_USER_THRESHOLD));
            m_pxbQuotaLimit->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_USER_LIMIT));

            //
            // Ensure warning threshold is not above limit.
            //
            INT64 iThreshold = m_pxbQuotaThreshold->GetBytes();
            INT64 iLimit     = m_pxbQuotaLimit->GetBytes();

            if (NOLIMIT != iLimit && iThreshold > iLimit)
            {
                TCHAR szLimit[40], szThreshold[40];
                XBytes::FormatByteCountForDisplay(iLimit, szLimit, ARRAYSIZE(szLimit));
                XBytes::FormatByteCountForDisplay(iThreshold, szThreshold, ARRAYSIZE(szThreshold));

                CString s(g_hInstDll, IDS_FMT_ERR_WARNOVERLIMIT, szThreshold, szLimit, szLimit);
                switch(DiskQuotaMsgBox(hDlg, s, IDS_TITLE_DISK_QUOTA, MB_ICONWARNING | MB_YESNO))
                {
                    case IDYES:
                        m_pxbQuotaThreshold->SetBytes(iLimit);
                        break;

                    case IDNO:
                        //
                        // This m_idCtlNextFocus hack stuff is here because I can't get
                        // the @#$%! prop sheet to return focus to the threshold control.
                        // The only way I've been able to get this to happen is to
                        // cache this ID value then on the EN_SETFOCUS generated when
                        // the page is activated, set focus to the control.
                        // Gross but it works without too much hassle. [brianau]
                        //
                        m_idCtlNextFocus = IDC_EDIT_USER_THRESHOLD;
                        dwPSNReturn = PSNRET_INVALID;
                        break;
                }
            }
        }
        if (PSNRET_NOERROR == dwPSNReturn)
        {
            hResult = ApplySettings(hDlg);
            if (FAILED(hResult))
            {
                INT idMsg   = IDS_UNKNOWN_ERROR;
                UINT uFlags = MB_OK;
                switch(hResult)
                {
                    case E_FAIL:
                        idMsg = IDS_WRITE_ERROR;
                        uFlags |= MB_ICONERROR;
                        break;

                    default:
                        switch(HRESULT_CODE(hResult))
                        {

//                      case ERROR_USER_EXISTS:
//                          idMsg = IDS_NOADD_EXISTING_USER;
//                          uFlags |= MB_ICONWARNING;
//                          break;
//
// FEATURE:  Still valid?  [brianau - 5/27/98]
//
                            case ERROR_NO_SUCH_USER:
                                idMsg = IDS_NOADD_UNKNOWN_USER;
                                uFlags |= MB_ICONWARNING;
                                break;

                            case ERROR_ACCESS_DENIED:
                                idMsg  = IDS_NO_WRITE_ACCESS;
                                uFlags |= MB_ICONWARNING;
                                break;

                            default:
                            uFlags |= MB_ICONERROR;
                            break;
                        }
                        break;
                }

                DiskQuotaMsgBox(GetDesktopWindow(),
                                idMsg,
                                IDS_TITLE_DISK_QUOTA,
                                uFlags);

                dwPSNReturn = PSNRET_INVALID;
            }
            else
            {
                m_bIsDirty = FALSE;
            }
        }
    }

    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, dwPSNReturn);

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnSheetNotifyKillActive

    Description: Handler for WM_NOTIFY - PSN_KILLACTIVE.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        TRUE  = Invalid data entered.  Don't kill page.
        FALSE = All data is valid.  Ok to kill page.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnSheetNotifyKillActive(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bAllDataIsValid = TRUE;

    //
    // No sheet-level validation performed at this time.
    //
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, !bAllDataIsValid);

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnHelp

    Description: Handler for WM_HELP.  Displays context sensitive help.

    Arguments:
        lParam - Pointer to a HELPINFO structure.

    Returns: TRUE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnHelp(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, STR_DSKQUOUI_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) rgUserPropSheetHelpIDs);
    return TRUE;
}


INT_PTR
UserPropSheet::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem,
            UseWindowsHelp(idCtl) ? NULL : STR_DSKQUOUI_HELPFILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)((LPTSTR)rgUserPropSheetHelpIDs));

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropPage::OnEditNotifyUpdate

    Description: Handler for WM_COMMAND, EN_UPDATE.
        Called whenever a character is entered in an edit control.

    Arguments:

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/03/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnEditNotifyUpdate(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *pxb = NULL;

    switch(LOWORD(wParam))
    {
        case IDC_EDIT_USER_LIMIT:
            pxb = m_pxbQuotaLimit;
            break;

        case IDC_EDIT_USER_THRESHOLD:
            pxb = m_pxbQuotaThreshold;
            break;

        default:
            break;
    }

    if (NULL != pxb)
        pxb->OnEditNotifyUpdate(lParam);

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnEditNotifyKillFocus

    Description: Handler for WM_COMMAND, EN_KILLFOCUS.
        Called whenever focus leaves an edit control.
        Validates the value in the edit control and adjusts it if necessary.

    Arguments:

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnEditNotifyKillFocus(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *pxb = NULL;

    switch(LOWORD(wParam))
    {
        case IDC_EDIT_USER_LIMIT:
            pxb = m_pxbQuotaLimit;
            break;

        case IDC_EDIT_USER_THRESHOLD:
            pxb = m_pxbQuotaThreshold;
            break;

        default:
            break;
    }

    if (NULL != pxb)
        pxb->OnEditKillFocus(lParam);

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropPage::OnComboNotifySelChange

    Description: Handler for WM_COMMAND, CBN_SELCHANGE.
        Called whenever the user selects the combo box.

    Arguments: Std DlgProc args.

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/03/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnComboNotifySelChange(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *pxb = NULL;

    switch(LOWORD(wParam))
    {
        case IDC_CMB_USER_LIMIT:
            pxb = m_pxbQuotaLimit;
            break;

        case IDC_CMB_USER_THRESHOLD:
            pxb = m_pxbQuotaThreshold;
            break;

        default:
            break;
    }
    if (NULL != pxb)
       pxb->OnComboNotifySelChange(lParam);

    return FALSE;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::ApplySettings

    Description: Applies the current settings to the user's quota information
        if they have not changed from the original settings.

    Arguments:
        hDlg - Dialog window handle.

    Returns:
        NO_ERROR            - Success.
        E_INVALIDARG        - One of the settings was invalid.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        E_FAIL              - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    01/24/98    Added bUndo argument.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UserPropSheet::ApplySettings(
    HWND hDlg,
    bool bUndo    // Default == true.
    )
{
    HRESULT hResult         = NO_ERROR;
    BOOL  bTranslated       = FALSE;
    com_autoptr<DISKQUOTA_USER> ptrUser;
    UINT cUsers             = m_LVSelection.Count();
    UINT i                  = 0;
    LONGLONG llThreshold;
    LONGLONG llLimit;
    CAutoSetRedraw autoredraw(m_hWndParent);

    if (bUndo)
        m_UndoList.Clear();  // Clear current undo list.

    //
    // Determine what threshold and limit to apply.
    //
    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RBN_USER_NOLIMIT))
    {
        llThreshold = NOLIMIT;
        llLimit     = NOLIMIT;
    }
    else
    {
        llThreshold = m_pxbQuotaThreshold->GetBytes();
        llLimit     = m_pxbQuotaLimit->GetBytes();
    }

    if (cUsers > 1)
    {
        //
        // Create batch object and do batch update for multiple users.
        //
        com_autoptr<DISKQUOTA_USER_BATCH> ptrBatch;

        hResult = m_pQuotaControl->CreateUserBatch(ptrBatch.getaddr());
        if (SUCCEEDED(hResult))
        {
            for (i = 0; i < cUsers; i++)
            {
                m_LVSelection.Retrieve(i, ptrUser.getaddr());
                if (bUndo)
                {
                    //
                    // Add an entry to the undo list.
                    //
                    LONGLONG LimitUndo;
                    LONGLONG ThresholdUndo;
                    ptrUser->GetQuotaThreshold(&ThresholdUndo);
                    ptrUser->GetQuotaLimit(&LimitUndo);
                    //
                    // Use a local autoptr to ensure proper release of
                    // iface in case adding to the undo list throws an exception.
                    // On success, disown the real ptr so that the object
                    // stays with the undo list.
                    //
                    com_autoptr<DISKQUOTA_USER> ptrQuotaUser(ptrUser);
                    ptrUser->AddRef();
                    m_UndoList.Add(new UndoModify(ptrUser, ThresholdUndo, LimitUndo));
                    ptrQuotaUser.disown();
                }

                ptrUser->SetQuotaThreshold(llThreshold, FALSE);

                if (UserIsAdministrator(ptrUser) && NOLIMIT != llLimit)
                {
                    //
                    // User is the Administrator account AND
                    // We're trying to set the limit to something other than NOLIMIT.
                    // Can't set a limit on the administrator account.
                    //
                    DiskQuotaMsgBox(GetDesktopWindow(),
                                    IDS_CANT_SET_ADMIN_LIMIT,
                                    IDS_TITLE_DISK_QUOTA,
                                    MB_ICONWARNING | MB_OK);
                }
                else
                {
                    //
                    // OK to set quota limit.
                    //
                    ptrUser->SetQuotaLimit(llLimit, FALSE);
                }

                ptrBatch->Add(ptrUser);
            }

            hResult = ptrBatch->FlushToDisk();
        }
    }
    else
    {
        //
        // Do single user update or add new user.
        //
        m_LVSelection.Retrieve(0, ptrUser.getaddr());
        DBGASSERT((NULL != ptrUser.get()));

        if (bUndo)
        {
            //
            // Add an entry to the undo list.
            //
            LONGLONG LimitUndo;
            LONGLONG ThresholdUndo;
            ptrUser->GetQuotaThreshold(&ThresholdUndo);
            ptrUser->GetQuotaLimit(&LimitUndo);
            //
            // Use local autoptr to ensure proper release of iface ptr if
            // an exception is thrown.  Disown real ptr on success.
            //
            com_autoptr<DISKQUOTA_USER> ptrQuotaUser(ptrUser);
            ptrUser->AddRef();
            m_UndoList.Add(new UndoModify(ptrUser, ThresholdUndo, LimitUndo));
            ptrQuotaUser.disown();
        }

        if (llThreshold != m_llQuotaThreshold)
        {
            hResult = ptrUser->SetQuotaThreshold(llThreshold, TRUE);

            if (FAILED(hResult))
                goto apply_failed;

            m_llQuotaThreshold = llThreshold;
        }

        if (llLimit != m_llQuotaLimit)
        {
            hResult = ptrUser->SetQuotaLimit(llLimit, TRUE);
            if (FAILED(hResult))
                goto apply_failed;

            m_llQuotaLimit = llLimit;
        }

        //
        // Update the user's status icon and %used to reflect the new settings.
        //
        UpdateUserStatusIcon(hDlg,
                             m_llQuotaUsed,
                             m_llQuotaThreshold,
                             m_llQuotaLimit);

        UpdateSpaceUsed(hDlg,
                        m_llQuotaUsed,
                        m_llQuotaLimit,
                        1);
    }

    //
    // Update the listview item(s) so the user sees a visual response to
    // pressing the "Apply" button.
    //
    autoredraw.Set(false);
    for (i = 0; i < cUsers; i++)
    {
        INT iItem = 0;
        m_LVSelection.Retrieve(i, &iItem);
        ListView_Update(m_hWndParent, iItem);
    }
    autoredraw.Set(true);
    InvalidateRect(m_hWndParent, NULL, FALSE);

apply_failed:

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::InitializeControls

    Description: Initializes the page controls based on the user's
        quota settings.

    Arguments:
        hDlg - Dialog window handle.

    Returns:
        NO_ERROR - Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UserPropSheet::InitializeControls(
    HWND hDlg
    )
{
    PDISKQUOTA_USER pUser = NULL;
    UINT cUsers           = m_LVSelection.Count();

    if (1 == cUsers)
    {
        //
        // Initialize controls for a single user.
        //
        m_LVSelection.Retrieve(0, &pUser);

        //
        // Configure the Limit/NoLimit radio buttons.
        // Must examine the current threshold rather than the limit because of the
        // special-case for the Administrator account.  That account can have a
        // threshold value but quota limit must always be "No Limit".
        //
        CheckDlgButton(hDlg, IDC_RBN_USER_LIMIT,   NOLIMIT != m_llQuotaThreshold);
        CheckDlgButton(hDlg, IDC_RBN_USER_NOLIMIT, NOLIMIT == m_llQuotaThreshold);
        if (UserIsAdministrator(pUser))
        {
            //
            // Override initialization of Quota Limit control with "No Limit".
            //
            m_pxbQuotaLimit->SetBytes(NOLIMIT);
        }

        //
        // Note that the XBytes controls have already been set for single-user.
        // See OnInitDialog().
        //

        //
        // Configure the remaining dialog controls.
        //
        UpdateUserName(hDlg, pUser);
        UpdateSpaceUsed(hDlg, m_llQuotaUsed, m_llQuotaLimit, cUsers);
        UpdateUserStatusIcon(hDlg,
                             m_llQuotaUsed,
                             m_llQuotaThreshold,
                             m_llQuotaLimit);
    }
    else
    {
        //
        // Initialize controls for multiple users.
        //
        LONGLONG llLimit         = 0;
        LONGLONG llLastLimit     = 0;
        LONGLONG llThreshold     = 0;
        LONGLONG llLastThreshold = 0;
        LONGLONG llUsed          = 0;
        LONGLONG llTotalUsed     = 0;

        //
        // Add up the total usage by all users.
        //
        for (UINT i = 0; i < cUsers; i++)
        {
            m_LVSelection.Retrieve(i, &pUser);
            pUser->GetQuotaLimit(&llLimit);
            pUser->GetQuotaThreshold(&llThreshold);
            pUser->GetQuotaUsed(&llUsed);

            llTotalUsed += llUsed;
            if (m_bHomogeneousSelection)
            {
                //
                // Determine if at least one user has a different
                // threshold or limit. If all are the same, we can display
                // the values in the edit controls.  Otherwise, we default
                // to "No Limit".  Radio buttons don't provide an
                // indeterminate state like checkboxes.
                //
                if (i > 0 &&
                    (llLimit != llLastLimit ||
                     llThreshold != llLastThreshold))
                {
                    m_bHomogeneousSelection = FALSE;
                }
                else
                {
                    llLastLimit     = llLimit;
                    llLastThreshold = llThreshold;
                }
            }
        }

        //
        // If all selected objects have the same limit and threshold,
        // set the cached data to represent multiple-selection.
        // If any one is different, we stick with the volume's default
        // values set in RefreshCachedQuotaInfo().
        //
        if (m_bHomogeneousSelection)
        {
            m_llQuotaThreshold = llLastThreshold;
            m_llQuotaLimit     = llLastLimit;
        }
        else
        {
            //
            // Since not all selected users have the same limit/thresold,
            // the number we're displaying will be a change for at least
            // one user.  Activate the "Apply" button.
            //
            //
            PostMessage(hDlg, DQM_ENABLE_APPLY_BUTTON, 0, 0);
        }

        m_pxbQuotaThreshold->SetBytes(m_llQuotaThreshold);
        m_pxbQuotaLimit->SetBytes(m_llQuotaLimit);

        //
        // Configure the Limit/NoLimit radio buttons.
        //
        CheckDlgButton(hDlg,
                       IDC_RBN_USER_NOLIMIT,
                       NOLIMIT == m_llQuotaThreshold);
        CheckDlgButton(hDlg,
                       IDC_RBN_USER_LIMIT,
                       NOLIMIT != m_llQuotaThreshold);

        UpdateUserName(hDlg, cUsers);
        UpdateSpaceUsed(hDlg, llTotalUsed, NOLIMIT, cUsers);
        //
        // Don't display any user status icon for multi-users.
        //
    }


    //
    // If "No Limit" radio button is checked, set limit and threshold controls
    // to the "No Limit" state (disabled and displaying "No Limit" text).
    // This may override any setting we made above.
    //
    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RBN_USER_NOLIMIT))
    {
        m_pxbQuotaThreshold->SetBytes(NOLIMIT);
        m_pxbQuotaLimit->SetBytes(NOLIMIT);
    }

    //
    // Set user icon.
    //
    SendMessage(GetDlgItem(hDlg, IDC_ICON_USER),
                STM_SETICON,
                (WPARAM)m_hIconUser[1 == cUsers ? iICON_USER_SINGLE :
                                                  iICON_USER_MULTIPLE],
                0);

    //
    // Force the property sheet to disable the "Apply" button.
    // The way I have set up the "Apply" enabling logic through OnCommand(),
    // merely initializing the edit controls on the page causes the Apply
    // button to become enabled.  Since the user hasn't changed anything
    // yet, it should be disabled.
    //
    m_bIsDirty = FALSE;
    PropSheet_UnChanged(GetParent(hDlg), hDlg);

    return NO_ERROR;
}





///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::QueryUserStatusIcon


    Description: This function is provided for automated testing of the UI.
        It is used by test scripts to determine which user status icon is
        currently displayed.

    Arguments:
        hDlg - Dialog handle.


    Returns: -1 = No icon displayed.
              0 = "Everything OK" icon.
              1 = Threshold exceded icon.
              2 = Limit exceded icon.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
UserPropSheet::QueryUserStatusIcon(
    HWND hDlg
    ) const
{
    HICON hicon = (HICON)SendMessage(GetDlgItem(hDlg, IDC_ICON_USERSTATUS),
                                    STM_GETICON,
                                    0, 0);

    for (UINT i = 0; i < cSTATUS_ICONS; i++)
    {
        if (hicon == m_hIconStatus[i])
            return i;
    }
    return -1;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::QueryUserIcon


    Description: This function is provided for automated testing of the UI.
        It is used by test scripts to determine which user status icon is
        currently displayed.

    Arguments:
        hDlg - Dialog handle.


    Returns: -1 = No icon displayed.
              0 = Single-user icon.
              1 = Multi-user icon.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
UserPropSheet::QueryUserIcon(
    HWND hDlg
    ) const
{
    HICON hicon = (HICON)SendMessage(GetDlgItem(hDlg, IDC_ICON_USER),
                                     STM_GETICON,
                                     0, 0);

    for (UINT i = 0; i < cUSER_ICONS; i++)
    {
        if (hicon == m_hIconUser[i])
            return i;
    }
    return -1;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::UpdateUserStatusIcon

    Description: Updates the quota status icon in the dialog box.  This icon
        must match the icon displayed in the listview for the selected user.

    Arguments:
        hDlg - Dialog handle.

        iUsed - Quota bytes charged to user.

        iThreshold - Quota warning threshold (bytes).

        iLimit - User's quota limit.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
UserPropSheet::UpdateUserStatusIcon(
    HWND hDlg,
    LONGLONG iUsed,
    LONGLONG iThreshold,
    LONGLONG iLimit
    )
{
    //
    // Set the user status icon if user is exceding the
    // quota threshold or the limit.  This is the same icon that is
    // displayed in the listview status column.  This logic must
    // mirror that used in DetailsView::GetDispInfo_Image().
    //
    INT iIcon = iICON_STATUS_OK;
    if (NOLIMIT != iLimit && iUsed > iLimit)
    {
        iIcon = iICON_STATUS_OVER_LIMIT;
    }
    else if (NOLIMIT != iThreshold && iUsed > iThreshold)
    {
        iIcon = iICON_STATUS_OVER_THRESHOLD;
    }

    SendMessage(GetDlgItem(hDlg, IDC_ICON_USERSTATUS),
                STM_SETICON,
                (WPARAM)m_hIconStatus[iIcon],
                0);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::UpdateUserName

    Description: Updates the Domain\Name text with the user's domain name
        and account name strings.  This method is called for a single-user
        selection.

        Also sets the property sheet title text.

    Arguments:
        hDlg - Dialog handle.

        pUser - Address of user's IDiskQuotaUser interface.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    08/05/97    Added code to set prop sheet title text.             BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
UserPropSheet::UpdateUserName(
    HWND hDlg,
    PDISKQUOTA_USER pUser
    )
{
    DBGASSERT((NULL != pUser));
    //
    // Display the user name, or some status text
    // if the name hasn't been resolved.
    //
    CString strLogonName;
    DWORD dwAccountStatus = 0;

    pUser->GetAccountStatus(&dwAccountStatus);

    if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
    {
        //
        // User account name has been resolved.  Display it.
        //
        TCHAR szLogonName[MAX_USERNAME];
        TCHAR szDisplayName[MAX_FULL_USERNAME];

        pUser->GetName(NULL, 0,
                       szLogonName, ARRAYSIZE(szLogonName),
                       szDisplayName, ARRAYSIZE(szDisplayName));

        if (TEXT('\0') != szLogonName[0])
        {
            if (TEXT('\0') != szDisplayName[0])
            {
                strLogonName.Format(g_hInstDll,
                                    IDS_FMT_DISPLAY_LOGON,
                                    szDisplayName,
                                    szLogonName);
            }
            else
            {
                strLogonName = szLogonName;
            }
        }
    }
    else
    {
        //
        // User account name has not been resolved or cannot
        // be resolved for some reason.  Display appropriate
        // status text.  This is the same text displayed in the
        // listview when the user's name has not been resolved.
        //
        INT idText = IDS_USER_ACCOUNT_UNKNOWN;

        switch(dwAccountStatus)
        {
            case DISKQUOTA_USER_ACCOUNT_UNAVAILABLE:
                idText = IDS_USER_ACCOUNT_UNAVAILABLE;
                break;

            case DISKQUOTA_USER_ACCOUNT_DELETED:
                idText = IDS_USER_ACCOUNT_DELETED;
                break;

            case DISKQUOTA_USER_ACCOUNT_INVALID:
                idText = IDS_USER_ACCOUNT_INVALID;
                break;

            case DISKQUOTA_USER_ACCOUNT_UNRESOLVED:
                idText = IDS_USER_ACCOUNT_UNRESOLVED;
                break;

            case DISKQUOTA_USER_ACCOUNT_UNKNOWN:
            default:
                break;
        }
        strLogonName.Format(g_hInstDll, idText);
    }
    SetDlgItemText(hDlg, IDC_TXT_USERNAME, strLogonName);

    //
    // Format and draw the prop sheet title string.
    //
    CString strSheetTitle(g_hInstDll,
                          IDS_TITLE_EDIT_USER,
                          (LPCTSTR)strLogonName);

    PropSheet_SetTitle(GetParent(hDlg), 0, (LPCTSTR)strSheetTitle);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::UpdateUserName

    Description: Replaces the user Domain\Name text with a message showing
        how many users are selected.   This is used for multi-user selections
        where no single user name is applicable.

        Also sets the property sheet title text.

    Arguments:
        hDlg - Dialog handle.

        cUsers - Number of users represented in the property dialog.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    08/05/97    Added code to set prop sheet title text.             BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
UserPropSheet::UpdateUserName(
    HWND hDlg,
    INT cUsers
    )
{
    //
    // Hide name edit control.  Can't display names for all users.
    // Display "Multiple Quota Users." instead.
    //
    CString strText(g_hInstDll, IDS_TITLE_MULTIUSER, cUsers);
    SetDlgItemText(hDlg, IDC_TXT_USERNAME, strText);

    //
    // Set the title of the property sheet.
    //
    CString strSheetTitle(g_hInstDll, IDS_TITLE_EDIT_MULTIUSER);
    PropSheet_SetTitle(GetParent(hDlg), 0, (LPCTSTR)strSheetTitle);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::UpdateSpaceUsed

    Description: Updates the "space used" and "remaining" fields on the user
        property sheet.

    Arguments:
        hDlg - Dialog handle.

        iUsed - Quota bytes charged to user(s).

        iLimit - User's quota limit.

        cUsers - Number of users represented in the property dialog.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
UserPropSheet::UpdateSpaceUsed(
    HWND hDlg,
    LONGLONG iUsed,
    LONGLONG iLimit,
    INT cUsers
    )
{
    TCHAR szText[80];

    //
    // Display - Used: 999XB (99%)
    //
    XBytes::FormatByteCountForDisplay(iUsed,
                                      szText, ARRAYSIZE(szText));
    CString strText(szText);
    if (1 == cUsers)
    {
        //
        // Only single-user page gets (99%) appended.
        // Pct quota is meaningless for multiple users.
        //
        if (0 != iLimit && NOLIMIT != iLimit)
        {
            UINT iPct = (INT)((iUsed * 100) / iLimit);

            strText.Format(g_hInstDll,
                           IDS_QUOTA_USED_SINGLEUSER,
                           szText,
                           iPct);
        }
    }

    SetDlgItemText(hDlg,
                  IDC_TXT_SPACEUSED,
                  strText);


    //
    // Display - Remaining: 999XB
    //
    strText = szText;
    if (NOLIMIT != iLimit)
    {
        LONGLONG iAmount = 0;

        if (iUsed <= iLimit)
            iAmount = iLimit - iUsed;

        XBytes::FormatByteCountForDisplay(iAmount,
                                          strText.GetBuffer(80), 80);
        strText.ReleaseBuffer();
    }
    else
    {
        //
        // Display "N/A" if limit is NOLIMIT.
        //
        strText.Format(g_hInstDll, IDS_NOT_APPLICABLE);
    }

    SetDlgItemText(hDlg,
                   IDC_TXT_SPACEREMAINING,
                   strText);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\encrypt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	EFSADU.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\encrypt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EFSADU.rc
//
#define IDS_DETAILWINTITLE              2
#define IDS_NOINFO                      4
#define IDS_ERRORMEM                    5
#define IDS_ADDUSERERR                  6
#define IDS_REMOVEUSERERR               7
#define IDS_CERTFILEFILTER              8
#define IDS_CERTFILEOPENERR             9
#define IDS_CERTFILEFORMATERR           10
#define IDS_UNKNOWNUSER                 11
#define IDS_ADDUSERDENIED               12
#define IDS_NOCERTNAME                  13
#define IDS_REMOVEUSERDENIED            14
#define IDS_NORECINFO                   15
#define IDS_DLGTITLE                    16
#define IDS_DISPTEXT                    17
#define IDS_NOREMOVEALL                 18
#define IDS_NOADDUSERDIR                19
#define IDS_COULDNOTVERIFYCERT          20
#define IDS_ACCEPTSELFCERT              21
#define IDS_ADDEFSEKUFAIL               22
#define IDS_INTERNALERROR               23
#define IDS_USERCOLTITLE                24
#define IDS_CERTCOLTITLE                25
#define IDS_RECCOLTITLE                 26
#define IDS_NOCERTORKEY                 27
#define IDS_NOCRNTCERT                  28
#define IDS_CERTNOTINMY                 29
#define IDS_NOOBJECT                    30
#define IDS_NOTENCRYPTED                31
#define IDD_ENCRYPT_DETAILS             101
#define IDD_COMPLETION                  102
#define IDD_LOCATING                    103
#define IDD_WELCOME                     104
#define IDC_REMOVE                      1002
#define IDC_ADD                         1013
#define IDC_LISTUSER                    1017
#define IDC_LISTRA                      1018
#define IDC_BACKUP                      1019

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\encrypt\efsadu.h ===
// EFSADU.h : main header file for the EFSADU DLL
//

#if !defined(AFX_EFSADU_H__15788838_4F37_11D1_BB5D_00A0C906345D__INCLUDED_)
#define AFX_EFSADU_H__15788838_4F37_11D1_BB5D_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CEFSADUApp
// See EFSADU.cpp for the implementation of this class
//

class CEFSADUApp : public CWinApp
{
public:
	CEFSADUApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEFSADUApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CEFSADUApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EFSADU_H__15788838_4F37_11D1_BB5D_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\encrypt\efsadu.cpp ===
// EFSADU.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "EFSADU.h"
#include "userlist.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CEFSADUApp

BEGIN_MESSAGE_MAP(CEFSADUApp, CWinApp)
	//{{AFX_MSG_MAP(CEFSADUApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEFSADUApp construction

CEFSADUApp::CEFSADUApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance

}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEFSADUApp object

CEFSADUApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\encrypt\efsui.h ===
/*
Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    efsui.h

Abstract:

    Header file for Encryped File System UI

*/

// Brings up the encryption details page
STDAPI_(void) EfsDetail(HWND hwndParent, LPCWSTR FileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\encrypt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1578883A_4F37_11D1_BB5D_00A0C906345D__INCLUDED_)
#define AFX_STDAFX_H__1578883A_4F37_11D1_BB5D_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
// #include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
// #include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1578883A_4F37_11D1_BB5D_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\encrypt\userlist.h ===
#if !defined(AFX_USERLIST_H__3A1CD0AB_4FC3_11D1_BB5D_00A0C906345D__INCLUDED_)
#define AFX_USERLIST_H__3A1CD0AB_4FC3_11D1_BB5D_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// USERLIST.h : header file
//

#include "users.h"
#include "lmcons.h"
#include "dns.h"
#include "ntdsapi.h"
#include <wincrypt.h>

/////////////////////////////////////////////////////////////////////////////
// USERLIST dialog

class USERLIST : public CDialog
{
// Construction
public:
	USERLIST(CWnd* pParent = NULL);   // standard constructor
	USERLIST(LPCTSTR FileName, CWnd* pParent = NULL); 
	DWORD ApplyChanges(LPCTSTR FileName);

    DWORD    AddNewUsers(CUsers &NewUsers);

// Dialog Data
	//{{AFX_DATA(USERLIST)
	enum { IDD = IDD_ENCRYPT_DETAILS };
	CButton	m_BackupButton;
	CListCtrl	m_RecoveryListCtrl;
	CListCtrl	m_UserListCtrl;
	CButton	m_AddButton;
	CButton	m_RemoveButton;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(USERLIST)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(USERLIST)
	afx_msg void OnRemove();
	virtual void OnCancel();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnAdd();
	afx_msg void OnSetfocusListuser(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusListuser(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedListuser(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusListra(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnBackup();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void ShowBackup();
	DWORD TryGetBetterNameInCert(PEFS_HASH_BLOB HashData, LPTSTR *UserName);
	void SetUpListBox(BOOL *Enable);
	void ShowRemove(void);
    DWORD GetCertNameFromCertContext(PCCERT_CONTEXT CertContext, LPTSTR * UserDispName);
    DWORD CertInStore(HCERTSTORE *pStores, DWORD StoreNum, PCCERT_CONTEXT selectedCert);
    CString m_FileName;
    CUsers m_Users;
    CUsers m_Recs;
    LONG   m_CurrentUsers;
    CERT_CHAIN_PARA m_CertChainPara;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_USERLIST_H__3A1CD0AB_4FC3_11D1_BB5D_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\encrypt\userlist.cpp ===
// USERLIST.cpp : implementation file
//

#include "stdafx.h"
#include "EFSADU.h"
#include "USERLIST.h"
#include "cryptui.h"
#include "objsel.h"
#include <winefs.h>
#include "efsui.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define OTHERPEOPLE  L"AddressBook"
#define TRUSTEDPEOPLE L"TrustedPeople"

#define KEYPATH  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\EFS\\CurrentKeys")
#define CERT_HASH TEXT("CertificateHash")

LPSTR   EfsOidlpstr  = szOID_KP_EFS;


PCCERT_CONTEXT GetCertInMyStore(PCRYPT_HASH_BLOB pHashBlob);

PCRYPT_KEY_PROV_INFO GetKeyProvInfo(PCCERT_CONTEXT pCertContext);

BOOLEAN CertHasKey(PCCERT_CONTEXT pCertContext);

/////////////////////////////////////////////////////////////////////////////
// USERLIST dialog


USERLIST::USERLIST(CWnd* pParent /*=NULL*/)
	: CDialog(USERLIST::IDD, pParent)
{
	//{{AFX_DATA_INIT(USERLIST)
	//}}AFX_DATA_INIT
}

USERLIST::USERLIST(LPCTSTR FileName, CWnd* pParent /*=NULL*/)
	: CDialog(USERLIST::IDD, pParent)
{
    m_FileName = FileName;
}


void USERLIST::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(USERLIST)
	DDX_Control(pDX, IDC_BACKUP, m_BackupButton);
	DDX_Control(pDX, IDC_LISTRA, m_RecoveryListCtrl);
	DDX_Control(pDX, IDC_LISTUSER, m_UserListCtrl);
	DDX_Control(pDX, IDC_ADD, m_AddButton);
	DDX_Control(pDX, IDC_REMOVE, m_RemoveButton);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(USERLIST, CDialog)
	//{{AFX_MSG_MAP(USERLIST)
	ON_BN_CLICKED(IDC_REMOVE, OnRemove)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_NOTIFY(NM_SETFOCUS, IDC_LISTUSER, OnSetfocusListuser)
	ON_NOTIFY(NM_KILLFOCUS, IDC_LISTUSER, OnKillfocusListuser)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LISTUSER, OnItemchangedListuser)
	ON_NOTIFY(NM_SETFOCUS, IDC_LISTRA, OnSetfocusListra)
	ON_BN_CLICKED(IDC_BACKUP, OnBackup)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// USERLIST message handlers

void USERLIST::OnRemove()
{
	int     ItemPos;
    BOOL    NoAction = FALSE;
    CString NoCertName;

    try{
        NoCertName.LoadString(IDS_NOCERTNAME);
    }
    catch(...){
        NoAction = TRUE;
    }

    if (NoAction){
        return;
    }

	ItemPos = m_UserListCtrl.GetNextItem( -1, LVNI_SELECTED );
    while ( ItemPos != -1 ){

        CString CertName;
        LPTSTR  pCertName;


        CertName = m_UserListCtrl.GetItemText( ItemPos, 0 );
        if ( !CertName.Compare(NoCertName) ){
            pCertName = NULL;            
        } else {
            pCertName = CertName.GetBuffer(CertName.GetLength() + 1);
        }

        m_Users.Remove( pCertName);
        m_UserListCtrl.DeleteItem( ItemPos );
        if (pCertName){
            CertName.ReleaseBuffer();
        }

        //
        // Because we have deleted the item. We have to start from -1 again.
        //

        ItemPos = m_UserListCtrl.GetNextItem( -1, LVNI_SELECTED );

    }

    m_AddButton.SetFocus();

}

void USERLIST::OnCancel()
{
	// TODO: Add extra cleanup here
	
	CDialog::OnCancel();
}

void USERLIST::OnOK()
{
	// TODO: Add extra validation here

    LONG NoUsersToAdd =  m_Users.GetUserAddedCnt();
    LONG NoUsersToRemove = m_Users.GetUserRemovedCnt();

    if ( (NoUsersToRemove - NoUsersToAdd) >= m_CurrentUsers) {

        //
        // All the users are going to be removed from the file. Do not allow.
        //

        CString ErrMsg;

        if (ErrMsg.LoadString(IDS_NOREMOVEALL)){
            MessageBox(ErrMsg);
        }
        return;
    }
	
	CDialog::OnOK();
}

STDAPI_(void) EfsDetail(HWND hwndParent, LPCWSTR FileName)
{
    INT_PTR RetCode;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD FileAttributes = GetFileAttributes(FileName);

    if ( (-1 != FileAttributes) && ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY)){

        CString ErrMsg;

        if (ErrMsg.LoadString(IDS_NOADDUSERDIR)){
            MessageBox(hwndParent, ErrMsg, NULL, MB_OK);
        }
        return;
    }

    CWnd cwnd;
    cwnd.FromHandle(hwndParent);

    USERLIST DetailDialog(FileName, &cwnd);

    RetCode = DetailDialog.DoModal();
    if ( IDOK == RetCode ){

        //
        // Commit the change
        //

        DetailDialog.ApplyChanges( FileName );

    } else if (IDCANCEL == RetCode) {

        //
        // Nothing needs to be done
        //

    }

}

BOOL WINAPI EfsFilter(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData
)
{
    BOOL disp = FALSE;
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbUsage = 0;


    if ( CertVerifyTimeValidity(
            NULL,
            pCertContext->pCertInfo
            )){

        return disp;

    }
    if (CertGetEnhancedKeyUsage(
            pCertContext,
            0,
            NULL,                                   
            &cbUsage) && 0 != cbUsage){

        pUsage = (PCERT_ENHKEY_USAGE) new BYTE[cbUsage];

        if (pUsage){

            if (CertGetEnhancedKeyUsage(
                    pCertContext,
                    0,
                    pUsage,
                    &cbUsage)){

                //
                // Search for EFS usage
                //

                DWORD cUsages = pUsage->cUsageIdentifier;
                while (cUsages){
                    if (!strcmp(szOID_KP_EFS, pUsage->rgpszUsageIdentifier[cUsages-1])){
                        disp = TRUE;
                        break;
                    }
                    cUsages--;
                } 


            }

            delete [] pUsage;

        }
    }

    return disp;

}


BOOL USERLIST::OnInitDialog()
{
    CDialog::OnInitDialog();
    CString WinTitle;
    RECT    ListRect;
    DWORD   ColWidth;
    CString ColName;
    CString ColCert;
    CString RecName;

    LPTSTR  UserCertName = NULL;
    BOOL    EnableAddButton = FALSE;
    PENCRYPTION_CERTIFICATE_HASH_LIST pUsers = NULL;
	PENCRYPTION_CERTIFICATE_HASH_LIST pRecs = NULL;

    try {

        DWORD RetCode;

        AfxFormatString1( WinTitle, IDS_DETAILWINTITLE, m_FileName );
        SetWindowText( WinTitle );

        m_CertChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
        m_CertChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

        //
        // Check EFS EKU
        //

        m_CertChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        m_CertChainPara.RequestedUsage.Usage.rgpszUsageIdentifier=&EfsOidlpstr;

        m_UserListCtrl.GetClientRect(&ListRect);
        ColName.LoadString(IDS_USERCOLTITLE);
        ColCert.LoadString(IDS_CERTCOLTITLE);
        RecName.LoadString(IDS_RECCOLTITLE);
        ColWidth = ( ListRect.right - ListRect.left  ) / 4;
        m_UserListCtrl.InsertColumn(0, ColName, LVCFMT_LEFT, ColWidth*3 );
        m_UserListCtrl.InsertColumn(1, ColCert, LVCFMT_LEFT, ColWidth );

        m_RecoveryListCtrl.GetClientRect(&ListRect);
        ColWidth = ( ListRect.right - ListRect.left  ) / 4;
        m_RecoveryListCtrl.InsertColumn(0, RecName, LVCFMT_LEFT, ColWidth*3 );
        m_RecoveryListCtrl.InsertColumn(1, ColCert, LVCFMT_LEFT, ColWidth );

        RetCode = QueryUsersOnEncryptedFile( (LPWSTR)(LPCWSTR) m_FileName, &pUsers);
        if ( !RetCode ){

			RetCode = QueryRecoveryAgentsOnEncryptedFile( (LPWSTR)(LPCWSTR) m_FileName, &pRecs);

			if ( !RetCode ){

				//
				// Got the info about the encrypted file
				//


				DWORD   NUsers = pUsers->nCert_Hash;
                BOOL    RecDone = FALSE;
                PENCRYPTION_CERTIFICATE_HASH_LIST pCertHashList = pUsers;

                m_CurrentUsers = (LONG) NUsers;

				//
				// Get all the users
				//

				while ( NUsers > 0 ){


					UserCertName = new TCHAR[_tcslen(pCertHashList->pUsers[NUsers - 1]->lpDisplayInformation) + 1];
					if (UserCertName){
						_tcscpy(UserCertName, pCertHashList->pUsers[NUsers - 1]->lpDisplayInformation);
					} else {
						AfxThrowMemoryException( );
					}

					//
					// We got the user name
					//

                    if (RecDone){
					    RetCode = m_Recs.Add(
											    UserCertName,
											    pCertHashList->pUsers[NUsers - 1]->pHash,
											    NULL
											    );
                    } else {

                        //
                        // Try to get a better name from the cert
                        //

                        LPTSTR UserName;

                        RetCode = TryGetBetterNameInCert(pCertHashList->pUsers[NUsers - 1]->pHash, &UserName);
                        if (ERROR_SUCCESS == RetCode){

                            //
                            // We get a better name from the certs
                            //

                            delete [] UserCertName;
                            UserCertName = UserName; 

                        }

					    RetCode = m_Users.Add(
											    UserCertName,
											    pCertHashList->pUsers[NUsers - 1]->pHash,
											    NULL
											    );
                    }

					if ( NO_ERROR != RetCode ) {
						delete [] UserCertName;
						UserCertName = NULL;
					}

					NUsers--;
                    if (NUsers == 0 && !RecDone){

                        //
                        // Let's deal with the recovery agents.
                        //

                        RecDone = TRUE;
                        pCertHashList = pRecs;
                        NUsers = pRecs->nCert_Hash;
                    }
				}


                if ( pRecs ){
	                FreeEncryptionCertificateHashList( pRecs );
	                pRecs = NULL;
                }

				//
				// In memory intial list established
				//

				SetUpListBox(&EnableAddButton);
            } else {

                //
                // Cannot get recovery info
                //
                CString ErrMsg;

                if (ErrMsg.LoadString(IDS_NORECINFO)){
                    MessageBox(ErrMsg);
                }

            }

            if ( pUsers ){
	            FreeEncryptionCertificateHashList( pUsers );
	            pUsers = NULL;
            } 

        } else {

            //
            // Cannot get user info
            //

            CString ErrMsg;

            if (ErrMsg.LoadString(IDS_NOINFO)){
                MessageBox(ErrMsg);
            }
        }

    }
     catch (...) {
        //
        // The exception mostly is caused by out of memory.
        // We can not prevent the page to be displayed from this routine,
        // So we just go ahead with empty list
        //

        m_UserListCtrl.DeleteAllItems( );
        m_RecoveryListCtrl.DeleteAllItems( );


        //
        // Delete works even if UserCertName == NULL
        //

        delete [] UserCertName;
        if ( pUsers ){
            FreeEncryptionCertificateHashList( pUsers );
        }
        if ( pRecs ){
            FreeEncryptionCertificateHashList( pRecs );
        }

    }

    m_RemoveButton.EnableWindow( FALSE );
    if ( !EnableAddButton ){
        m_AddButton.EnableWindow( FALSE );
    }
    ShowBackup();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void USERLIST::ShowRemove()
{
    if (m_UserListCtrl.GetSelectedCount() > 0){

        //
        // Enable the Remove Button
        //

        m_RemoveButton.EnableWindow( TRUE );

    } else {
        
        //
        // Disable the Remove Button
        //

        m_RemoveButton.EnableWindow( FALSE );

    }
}

DWORD
USERLIST::ApplyChanges(
    LPCTSTR FileName
    )
{
    DWORD RetCode = NO_ERROR;
    DWORD NoUsersToRemove;
    DWORD NoUsersToAdd;
    DWORD RemoveUserIndex;
    DWORD AddUserIndex;
    PENCRYPTION_CERTIFICATE_HASH_LIST RemoveUserList = NULL;
    PENCRYPTION_CERTIFICATE_LIST AddUserList = NULL;
    PVOID   EnumHandle;


    //
    //  Get all the users to be added or removed first
    //

    NoUsersToAdd =  m_Users.GetUserAddedCnt();
    NoUsersToRemove = m_Users.GetUserRemovedCnt();

    if ( (NoUsersToAdd == 0) && (NoUsersToRemove == 0)){
        return NO_ERROR;
    }

    if ( NoUsersToAdd ) {

        //
        // At least one user is to be added
        //

        DWORD   BytesToAllocate;

        BytesToAllocate = sizeof ( ENCRYPTION_CERTIFICATE_LIST ) +
                                       NoUsersToAdd  * sizeof ( PENCRYPTION_CERTIFICATE ) +
                                       NoUsersToAdd * sizeof (ENCRYPTION_CERTIFICATE);
        AddUserList = (PENCRYPTION_CERTIFICATE_LIST) new BYTE[BytesToAllocate];
        if ( NULL == AddUserList ){

            //
            // Out of memory. Try our best to display the error message.
            //

            try {

                CString ErrMsg;

                if (ErrMsg.LoadString(IDS_ERRORMEM)){
                    ::MessageBox(NULL, ErrMsg, NULL, MB_OK);
                }
            }
            catch (...) {
            }

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        AddUserList->nUsers = NoUsersToAdd;
        AddUserList->pUsers = (PENCRYPTION_CERTIFICATE *)(((PBYTE) AddUserList) +
                    sizeof ( ENCRYPTION_CERTIFICATE_LIST ));
    }

    if ( NoUsersToRemove ){

            //
            // At least one user is to be removed
            //

        DWORD   BytesToAllocate;

        BytesToAllocate = sizeof ( ENCRYPTION_CERTIFICATE_HASH_LIST ) +
                                       NoUsersToRemove  * sizeof ( PENCRYPTION_CERTIFICATE_HASH) +
                                       NoUsersToRemove * sizeof (ENCRYPTION_CERTIFICATE_HASH);


        RemoveUserList = (PENCRYPTION_CERTIFICATE_HASH_LIST) new BYTE[BytesToAllocate];
        if ( NULL == RemoveUserList ){

            //
            // Out of memory. Try our best to display the error message.
            //

            if (AddUserList){
                delete [] AddUserList;
                AddUserList = NULL;
            }

            try {

                CString ErrMsg;

                if (ErrMsg.LoadString(IDS_ERRORMEM)){
                    ::MessageBox(NULL, ErrMsg, NULL, MB_OK);
                }
            }
            catch (...) {
            }

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RemoveUserList->nCert_Hash = NoUsersToRemove;
        RemoveUserList->pUsers =  (PENCRYPTION_CERTIFICATE_HASH *)(((PBYTE) RemoveUserList) +
                    sizeof ( ENCRYPTION_CERTIFICATE_HASH_LIST ));
    }

    EnumHandle = m_Users.StartEnum();
    RemoveUserIndex = 0;
    AddUserIndex = 0;
    while ( EnumHandle ){

        DWORD   Flag;
        PSID         UserSid;
        PVOID      CertData;
        LPTSTR   UserName;

        EnumHandle = m_Users.GetNextChangedUser(
                                    EnumHandle,
                                    &UserName,
                                    &UserSid,
                                    &CertData,
                                    &Flag
                                    );

        if ( Flag ){

            //
            // We get our changed user
            //

            if ( Flag & USERADDED ){

                ASSERT( AddUserList );

                //
                // Add the user to the adding list
                //

                PENCRYPTION_CERTIFICATE   EfsCert;

                ASSERT (AddUserIndex < NoUsersToAdd);

                EfsCert= (PENCRYPTION_CERTIFICATE)(((PBYTE) AddUserList) +
                            sizeof ( ENCRYPTION_CERTIFICATE_LIST ) +
                            NoUsersToAdd  * sizeof ( PENCRYPTION_CERTIFICATE) +
                            AddUserIndex * sizeof (ENCRYPTION_CERTIFICATE));

                AddUserList->pUsers[AddUserIndex] = EfsCert;
                EfsCert->pUserSid =  (SID *) UserSid;
                EfsCert->cbTotalLength = sizeof (ENCRYPTION_CERTIFICATE);
                EfsCert->pCertBlob = (PEFS_CERTIFICATE_BLOB) CertData;

                AddUserIndex++;

            } else if ( Flag & USERREMOVED ) {

                ASSERT (RemoveUserList);

                //
                // Add the user to the removing list
                //

                PENCRYPTION_CERTIFICATE_HASH    EfsCertHash;

                ASSERT (RemoveUserIndex < NoUsersToRemove);

                EfsCertHash= (PENCRYPTION_CERTIFICATE_HASH)(((PBYTE) RemoveUserList) +
                            sizeof ( ENCRYPTION_CERTIFICATE_HASH_LIST ) +
                            NoUsersToRemove   * sizeof ( PENCRYPTION_CERTIFICATE_HASH) +
                            RemoveUserIndex * sizeof (ENCRYPTION_CERTIFICATE_HASH));

                RemoveUserList->pUsers[RemoveUserIndex] = EfsCertHash;
                EfsCertHash->cbTotalLength = sizeof (ENCRYPTION_CERTIFICATE_HASH);
                EfsCertHash->pUserSid = (SID *)UserSid;
                EfsCertHash->pHash = (PEFS_HASH_BLOB) CertData;
                EfsCertHash->lpDisplayInformation = NULL;

                RemoveUserIndex++;
            } else {
                ASSERT(FALSE);
            }

        }

    }

    ASSERT(RemoveUserIndex == NoUsersToRemove);
    ASSERT(AddUserIndex == NoUsersToAdd);

    if ( AddUserIndex && AddUserList ){

        //
        // Add the user to the file list
        //

        RetCode = AddUsersToEncryptedFile(FileName, AddUserList);
        if ( NO_ERROR != RetCode ){

            CString ErrMsg;
            TCHAR   ErrCode[16];

            if (ERROR_ACCESS_DENIED != RetCode) {
                _ltot(RetCode, ErrCode, 10 );
                AfxFormatString1( ErrMsg, IDS_ADDUSERERR, ErrCode );
            } else {
                ErrMsg.LoadString(IDS_ADDUSERDENIED);
            }

            MessageBox(ErrMsg);

        }

    }

    if ( RemoveUserIndex && RemoveUserList){

        //
        // Remove the user from the list
        //

        DWORD RetCodeBak = RetCode;

        RetCode = RemoveUsersFromEncryptedFile(FileName, RemoveUserList);
        if ( NO_ERROR != RetCode ){

            CString ErrMsg;
            TCHAR   ErrCode[16];

            if (ERROR_ACCESS_DENIED != RetCode) {
                _ltot(RetCode, ErrCode, 10 );
                AfxFormatString1( ErrMsg, IDS_REMOVEUSERERR, ErrCode );
            } else {
                ErrMsg.LoadString(IDS_REMOVEUSERDENIED);
            }

            MessageBox(ErrMsg);

        } else {

            //
            // Reflect the error happened
            //

            RetCode = RetCodeBak;
        }

    }

    if (AddUserList){
        delete [] AddUserList;
    }
    if (RemoveUserList){
        delete [] RemoveUserList;
    }

    return RetCode;
}

DWORD
USERLIST::AddNewUsers(CUsers &NewUser)
{
    DWORD RetCode = ERROR_SUCCESS;

    m_UserListCtrl.DeleteAllItems( );
    RetCode = m_Users.Add(NewUser);
    SetUpListBox(NULL);

    return RetCode;
}


void USERLIST::SetUpListBox(BOOL *EnableAdd)
{
    PVOID   EnumHandle;

    try{
        CString NoCertName;

        NoCertName.LoadString(IDS_NOCERTNAME);

        if (EnumHandle = m_Users.StartEnum()){

            LV_ITEM fillItem;

            fillItem.mask = LVIF_TEXT;


            //
            // At least one user is available
            //
            while ( EnumHandle ){
                CString CertName;
                CString CertHash;

                fillItem.iItem = 0;
                fillItem.iSubItem = 0;

                EnumHandle = m_Users.GetNextUser(EnumHandle, CertName, CertHash);
                if (!EnumHandle && CertName.IsEmpty() && CertHash.IsEmpty()) {
                    //
                    // No more items.
                    //

                    break;

                }
                if (CertName.IsEmpty()){
                    fillItem.pszText = NoCertName.GetBuffer(NoCertName.GetLength() + 1);
                } else {
                    fillItem.pszText = CertName.GetBuffer(CertName.GetLength() + 1);
                }

                //
                // Add the user to the list
                //

                fillItem.iItem = m_UserListCtrl.InsertItem(&fillItem);

                if (CertName.IsEmpty()){
                    NoCertName.ReleaseBuffer();
                } else {
                    CertName.ReleaseBuffer();
                }

                if ( fillItem.iItem != -1 ){
                    if ( EnableAdd ){
                        *EnableAdd = TRUE;
                    }

                    if (CertHash.IsEmpty()){
                        fillItem.pszText = NULL;
                    } else {
                        fillItem.pszText = CertHash.GetBuffer(CertHash.GetLength() + 1);
                    }

                    fillItem.iSubItem = 1;
                    m_UserListCtrl.SetItem(&fillItem);
                    
                    if (!CertHash.IsEmpty()){
                        CertHash.ReleaseBuffer();
                    }
                }
              
            }
        }

        if (EnableAdd){

            //
            // From the dialog init. Do the Rec list as well
            //

            if (EnumHandle = m_Recs.StartEnum()){

                LV_ITEM fillItem;

                fillItem.mask = LVIF_TEXT;

                //
                // At least one user is available
                //

                while ( EnumHandle ){

                    CString CertName;
                    CString CertHash;

                    fillItem.iItem = 0;
                    fillItem.iSubItem = 0;

                    EnumHandle = m_Recs.GetNextUser(EnumHandle, CertName, CertHash);

                    if (!EnumHandle && CertName.IsEmpty() && CertHash.IsEmpty()) {
                        //
                        // No more items.
                        //
    
                        break;
    
                    }
                    //
                    // Add the agent to the list
                    //

                    if (CertName.IsEmpty()){
                        fillItem.pszText = NoCertName.GetBuffer(NoCertName.GetLength() + 1);
                    } else {
                        fillItem.pszText = CertName.GetBuffer(CertName.GetLength() + 1);
                    }

                    fillItem.iItem = m_RecoveryListCtrl.InsertItem(&fillItem);

                    if (CertName.IsEmpty()){
                        NoCertName.ReleaseBuffer();
                    } else {
                        CertName.ReleaseBuffer();
                    }

                    if ( fillItem.iItem != -1 ){

                        if (CertHash.IsEmpty()){
                            fillItem.pszText = NULL;
                        } else {
                            fillItem.pszText = CertHash.GetBuffer(CertHash.GetLength() + 1);
                        }

                        fillItem.iSubItem = 1;
                        m_RecoveryListCtrl.SetItem(&fillItem);
                    
                        if (!CertHash.IsEmpty()){
                            CertHash.ReleaseBuffer();
                        }
                    }

               }
            }
        }
    }
    catch(...){
        m_UserListCtrl.DeleteAllItems( );
        m_RecoveryListCtrl.DeleteAllItems( );
        if ( EnableAdd ){
            *EnableAdd = FALSE;
        }
    }

}

DWORD
USERLIST::GetCertNameFromCertContext(
    PCCERT_CONTEXT CertContext,
    LPTSTR * UserDispName
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get the user name from the certificate
// Arguments:
//      CertContext -- Cert Context
//      UserCertName -- User Common Name
//                                  ( Caller is responsible to delete this memory using delete [] )
//  Return Value:
//      ERROR_SUCCESS if succeed.
//      If No Name found. "USER_UNKNOWN is returned".
//
//////////////////////////////////////////////////////////////////////
{
    DWORD   NameLength;
    DWORD   UserNameBufLen = 0;
    DWORD   BlobLen = 0;
    PCERT_EXTENSION AlterNameExt = NULL;
    BOOL    b;
    LPTSTR  DNSName = NULL;
    LPTSTR  UPNName = NULL;
    LPTSTR  CommonName = NULL;

    if ( NULL == UserDispName ){
        return ERROR_SUCCESS;
    }

    *UserDispName = NULL;

    AlterNameExt = CertFindExtension(
            szOID_SUBJECT_ALT_NAME2,
            CertContext->pCertInfo->cExtension,
            CertContext->pCertInfo->rgExtension
            );

    if (AlterNameExt){

        //
        // Find the alternative name
        //

        b = CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                szOID_SUBJECT_ALT_NAME ,
                AlterNameExt->Value.pbData,
                AlterNameExt->Value.cbData,
                0,
                NULL,
                &BlobLen
                );
        if (b){

            //
            // Let's decode it
            //

            CERT_ALT_NAME_INFO *AltNameInfo = NULL;

            AltNameInfo = (CERT_ALT_NAME_INFO *) new BYTE[BlobLen];

            if (AltNameInfo){

                b = CryptDecodeObject(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        szOID_SUBJECT_ALT_NAME,
                        AlterNameExt->Value.pbData,
                        AlterNameExt->Value.cbData,
                        0,
                        AltNameInfo,
                        &BlobLen
                        );
                if (b){

                    //
                    // Now search for the UPN, SPN, DNS, EFS name
                    //

                    DWORD   cAltEntry = AltNameInfo->cAltEntry;
                    DWORD   ii = 0;

                    while (ii < cAltEntry){
                        if ((AltNameInfo->rgAltEntry[ii].dwAltNameChoice == CERT_ALT_NAME_OTHER_NAME ) &&
                             !strcmp(szOID_NT_PRINCIPAL_NAME, AltNameInfo->rgAltEntry[ii].pOtherName->pszObjId)
                            ){

                            //
                            // We found the UPN name
                            //

                            CERT_NAME_VALUE* CertUPNName = NULL;

                            b = CryptDecodeObject(
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    X509_UNICODE_ANY_STRING,
                                    AltNameInfo->rgAltEntry[ii].pOtherName->Value.pbData,
                                    AltNameInfo->rgAltEntry[ii].pOtherName->Value.cbData,
                                    0,
                                    NULL,
                                    &BlobLen
                                    );
                            if (b){

                                CertUPNName = (CERT_NAME_VALUE *) new BYTE[BlobLen];
                                if (CertUPNName){
                                    b = CryptDecodeObject(
                                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameInfo->rgAltEntry[ii].pOtherName->Value.pbData,
                                            AltNameInfo->rgAltEntry[ii].pOtherName->Value.cbData,
                                            0,
                                            CertUPNName,
                                            &BlobLen
                                            );
                                    if (b){
                                        UPNName = (LPTSTR)new BYTE[CertUPNName->Value.cbData + sizeof(WCHAR)];
                                        if (UPNName){
                                            wcscpy(UPNName, (LPCTSTR) CertUPNName->Value.pbData);
                                        }
                                    }
                                    delete [] CertUPNName;
                                    if (UPNName){

                                        //
                                        // Got the UPN name. Stop searching.
                                        //
                                        break;
                                    }
                                }
                            }

                                            
                        } else {

                            //
                            // Check for other alternative name
                            //

                            if (AltNameInfo->rgAltEntry[ii].dwAltNameChoice == CERT_ALT_NAME_DNS_NAME){
                                DNSName = AltNameInfo->rgAltEntry[ii].pwszDNSName;
                            } 

                        }

                        ii++;

                    }

                    if ( NULL == UPNName ){

                        //
                        // No UPN name, let's get the other option
                        //

                        if (DNSName){
                            UPNName = (LPTSTR)new TCHAR[wcslen( DNSName ) + 1];
                            if (UPNName){
                                wcscpy(UPNName, DNSName);
                            }
                        }

                    }
                }
                delete [] AltNameInfo;
            }

        }
    }


    NameLength = CertGetNameString(
                                CertContext,
                                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                0,
                                NULL,
                                NULL,
                                0
                                );

    if ( NameLength > 1){

        //
        // The display name exist. Go get the display name.
        //

        CommonName = new TCHAR[NameLength];
        if ( NULL == CommonName ){
            if (UPNName){
                delete [] UPNName;
            }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        UserNameBufLen = NameLength;
        NameLength = CertGetNameString(
                                    CertContext,
                                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                    0,
                                    NULL,
                                    CommonName,
                                    UserNameBufLen
                                    );

        ASSERT (NameLength == UserNameBufLen);

    } 


    if (CommonName || UPNName){

        NameLength = 3;
        if (CommonName){
            NameLength += wcslen(CommonName);
        }
        if (UPNName){
            NameLength += wcslen(UPNName);
        }
        

        *UserDispName = new TCHAR[NameLength];
        if (CommonName){
            wcscpy(*UserDispName, CommonName);
            if (UPNName){
                wcscat(*UserDispName, L"(");
                wcscat(*UserDispName, UPNName);
                wcscat(*UserDispName, L")");
            }
        } else {
            wcscpy(*UserDispName, UPNName);
        }

        if (CommonName){
            delete [] CommonName;
        }
        if (UPNName){
            delete [] UPNName;
        }
        return ERROR_SUCCESS;
    } 

    try {

        CString UnknownCertName;

        UnknownCertName.LoadString(IDS_NOCERTNAME);

        UserNameBufLen = UnknownCertName.GetLength();

        *UserDispName = new TCHAR[UserNameBufLen + 1];
        _tcscpy( *UserDispName, UnknownCertName);

    }
    catch (...){
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return ERROR_SUCCESS;

}

void USERLIST::OnAdd() 
{
    CRYPTUI_SELECTCERTIFICATE_STRUCTW cryptUI;
    HCERTSTORE otherStore;
    HCERTSTORE trustedStore;
    HCERTSTORE memStore;
    HCERTSTORE localStore[2];
    PCCERT_CONTEXT selectedCert;
    CString DlgTitle;
    CString DispText;
    LPTSTR  UserDispName;
    HRESULT hr;
    DWORD   rc;
    DWORD   StoreNum = 0;
    DWORD   StoreIndex = 0xffffffff;
    BOOL    EfsEkuExist = FALSE;
    DWORD   ii;
    BOOL    ContinueProcess = TRUE;

    otherStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                            OTHERPEOPLE
                            );

    trustedStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                            TRUSTEDPEOPLE
                            );

    if (otherStore) {
        localStore[0] = otherStore;
        StoreNum++;
    }
    if (trustedStore) {
        localStore[StoreNum] = trustedStore;
        StoreNum++;
    }

    memStore = CertOpenStore(
                         CERT_STORE_PROV_MEMORY,
                         0,
                         0,
                         CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                         NULL
                         );
    if (!memStore) {

        CString ErrMsg;
        TCHAR   ErrCode[16];
        

        _ltot(GetLastError(), ErrCode, 10 );
        AfxFormatString1( ErrMsg, IDS_INTERNALERROR, ErrCode );
        MessageBox(ErrMsg);

        if (otherStore) {
            CertCloseStore( otherStore, 0 );
        }
        if (trustedStore) {
            CertCloseStore( trustedStore, 0 );
        }
        return;
    }

    //
    // Let's put it into a memory store to eliminate the redundancy
    //

    ii = 0;
    while ( (ii < StoreNum) && ContinueProcess ) {

        PCCERT_CONTEXT pCertContext = NULL;

        while (pCertContext = CertEnumCertificatesInStore(
                              localStore[ii],              
                              pCertContext     
                              ))  {

            if (!CertAddCertificateLinkToStore(
                      memStore,                
                      pCertContext,          
                      CERT_STORE_ADD_USE_EXISTING,               
                      NULL         
                      )){

                CString ErrMsg;
                TCHAR   ErrCode[16];
                
        
                _ltot(GetLastError(), ErrCode, 10 );
                AfxFormatString1( ErrMsg, IDS_INTERNALERROR, ErrCode );
                MessageBox(ErrMsg);
                ContinueProcess = FALSE;
                break;
            }

        } 
        ii++;
    }

    if (!ContinueProcess) {
        if (otherStore) {
            CertCloseStore( otherStore, 0 );
        }
        if (trustedStore) {
            CertCloseStore( trustedStore, 0 );
        }
        CertCloseStore( memStore, 0 );
        return;
    }

    if (StoreNum != 0) {
        RtlZeroMemory(&cryptUI, sizeof (CRYPTUI_SELECTCERTIFICATE_STRUCTW));
        cryptUI.dwSize = sizeof (CRYPTUI_SELECTCERTIFICATE_STRUCTW);
	    cryptUI.dwFlags = CRYPTUI_SELECTCERT_ADDFROMDS;
        cryptUI.cDisplayStores = 1; 
        cryptUI.rghDisplayStores = &memStore;
        cryptUI.pFilterCallback = EfsFilter;
        cryptUI.dwDontUseColumn = CRYPTUI_SELECT_LOCATION_COLUMN | CRYPTUI_SELECT_ISSUEDBY_COLUMN | CRYPTUI_SELECT_INTENDEDUSE_COLUMN;
        if (DlgTitle.LoadString(IDS_DLGTITLE)){
            cryptUI.szTitle = (LPCWSTR) DlgTitle.GetBuffer(DlgTitle.GetLength() + 1);
        }
        if (DispText.LoadString(IDS_DISPTEXT)){
            cryptUI.szDisplayString = (LPCWSTR) DispText.GetBuffer(DispText.GetLength() + 1);
        }
        selectedCert = CryptUIDlgSelectCertificateW(&cryptUI);
        if ( selectedCert ){

            PCCERT_CHAIN_CONTEXT pChainContext;

            //
            // Let's first see if the cert is from DS, if Yes, add the EFS EKU first if no EKU.
            //

            StoreIndex = CertInStore(localStore, StoreNum, selectedCert);

            if (StoreIndex >= StoreNum){

                //
                // The cert is not in the local stores. Let's see if we need add the EKU or not. 
                //

                EfsEkuExist = EfsFilter(selectedCert, NULL, NULL);
                if (!EfsEkuExist) {

                    //
                    // Let's add the EFS EKU
                    //

                    CTL_USAGE    EfsEkuUsage;
                    DWORD        cbEncoded;
                    void         *pbEncoded;
                    CRYPT_DATA_BLOB EfsEkuBlob;

                    EfsEkuUsage.cUsageIdentifier = 1; // Only adding EFS EKU
                    EfsEkuUsage.rgpszUsageIdentifier = &EfsOidlpstr;
                    if(!CryptEncodeObjectEx(
                            X509_ASN_ENCODING,
                            szOID_ENHANCED_KEY_USAGE,
                            &EfsEkuUsage,
		                    CRYPT_ENCODE_ALLOC_FLAG,
		                    NULL, // Use LocalFree
                            &pbEncoded,
                            &cbEncoded
                        )){

                        //
                        // Failed to encode the EFS EKU
                        //
                        CString ErrMsg;
                        TCHAR   ErrCode[16];
                        
            
                        ContinueProcess = FALSE;
                        _ltot(GetLastError(), ErrCode, 10 );
                        AfxFormatString1( ErrMsg, IDS_ADDEFSEKUFAIL, ErrCode );
                        MessageBox(ErrMsg);


                    } else {
                        //
                        // Now let's add the EKU to the cert
                        //

                        EfsEkuBlob.cbData=cbEncoded;
                        EfsEkuBlob.pbData=(BYTE *)pbEncoded;
                        
                        if(!CertSetCertificateContextProperty(
                                selectedCert,
                                CERT_ENHKEY_USAGE_PROP_ID,
                                0,
                                &EfsEkuBlob)){
    
                            //
                            // Failed to add the EFS EKU
                            //
    
                            CString ErrMsg;
                            TCHAR   ErrCode[16];
                            
                
                            ContinueProcess = FALSE;
                            _ltot(GetLastError(), ErrCode, 10 );
                            AfxFormatString1( ErrMsg, IDS_ADDEFSEKUFAIL, ErrCode );
                            MessageBox(ErrMsg);
    
    
                        }
                    }


                }


            }

            //
            // Let's validate the cert first
            //

            if (ContinueProcess && CertGetCertificateChain (
                                        HCCE_CURRENT_USER,
                                        selectedCert,
                                        NULL,
                                        NULL,
                                        &m_CertChainPara,
                                        CERT_CHAIN_REVOCATION_CHECK_CHAIN,
                                        NULL,
                                        &pChainContext
                                        )) {

                PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[ 0 ];
                PCERT_CHAIN_ELEMENT pElement = pChain->rgpElement[ 0 ];
                BOOL bSelfSigned = pElement->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED;
                BOOL ContinueAdd = TRUE;

                DWORD dwErrorStatus = pChainContext->TrustStatus.dwErrorStatus;


                if (0 == (dwErrorStatus & ~CERT_TRUST_REVOCATION_STATUS_UNKNOWN)) {

                    

                    //
                    // The validation succeed. If the cert is from the DS (not in the store we opened), we will put it
                    // in the my Other People's store
                    //

                    
                    if (StoreIndex >= StoreNum) {

                        //
                        // The cert is not in our local stores. Add it to the other people
                        //

                        if (otherStore) {
                            if(!CertAddCertificateContextToStore(
                                   otherStore,
                                   selectedCert,
                                   CERT_STORE_ADD_NEW,
                                   NULL) ) {
                
                                //
                                // The error code is only for debug.
                                // If we failed to add the cert to other People store,
                                // it is fine to continue
                                //

                                rc = GetLastError();
                
                            }
                        }

                    }

                } else {

                    //
                    // The cert validation failed, as the user if we will accept the cert. If yes, the cert
                    // will be added to my TrustedPeople.
                    //

                    // (((dwErrorStatus & ~CERT_TRUST_REVOCATION_STATUS_UNKNOWN) == CERT_TRUST_IS_UNTRUSTED_ROOT) && bSelfSigned) {

                    if (bSelfSigned && !(dwErrorStatus & (CERT_TRUST_IS_NOT_TIME_VALID |
                                                          CERT_TRUST_IS_NOT_SIGNATURE_VALID | 
                                                          CERT_TRUST_IS_NOT_VALID_FOR_USAGE))){
                        //
                        // A self signed cert. Ask the user if he would like to accept.
                        // If it is already in the trusted store, we can skip the pop up.
                        //


                        DWORD   StoreIndex;


                        if (trustedStore) {
                            StoreIndex = CertInStore(&trustedStore, 1, selectedCert);
                        }

                        if (StoreIndex >= 1) {

                            CString ErrMsg;
                            TCHAR   ErrCode[16];
                            int     buttonID;

                            _ltot(GetLastError(), ErrCode, 10 );
                            AfxFormatString1( ErrMsg, IDS_ACCEPTSELFCERT, ErrCode );
                            buttonID = MessageBox(ErrMsg, NULL, MB_ICONQUESTION | MB_YESNO);
                            if (IDYES == buttonID) {
    
                                //
                                // User Accepted the cert.
                                //
                                if (trustedStore) {
                                    if(!CertAddCertificateContextToStore(
                                           trustedStore,
                                           selectedCert,
                                           CERT_STORE_ADD_NEW,
                                           NULL) ) {
                        
                                        //
                                        // The error code is only for debug.
                                        // If we failed to add the cert to other People store,
                                        // it is fine to continue
                                        //
        
                                        rc = GetLastError();
                        
                                    }
                                }
    
                            } else {
    
                                //
                                // User declined the cert.
                                //
    
                                ContinueAdd = FALSE;
                            }
                        }
                

                    } else {

                        //
                        //  Let's get the error code of the chain building.
                        //

                        CERT_CHAIN_POLICY_PARA PolicyPara;
                        CERT_CHAIN_POLICY_STATUS PolicyStatus;

                        ContinueAdd = FALSE;

                        RtlZeroMemory(&PolicyPara, sizeof(CERT_CHAIN_POLICY_PARA));
                        RtlZeroMemory(&PolicyStatus, sizeof(CERT_CHAIN_POLICY_STATUS));

                        PolicyPara.cbSize = sizeof(CERT_CHAIN_POLICY_PARA);
                        PolicyStatus.cbSize = sizeof(CERT_CHAIN_POLICY_STATUS);

                        if (CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_BASE,
                            pChainContext,
                            &PolicyPara,
                            &PolicyStatus
                            ) && PolicyStatus.dwError ) {

                            //
                            // Display the error to the user.
                            //

                            DWORD len;
                            LPWSTR DisplayBuffer;
                        
                            len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    NULL, PolicyStatus.dwError, 0,
                                    (LPWSTR)&DisplayBuffer, 0, NULL);
    
    
                            if (len && DisplayBuffer) {
    
                                MessageBox(DisplayBuffer);
        
                                LocalFree(DisplayBuffer);
                            }
                        }
                        

                    }


                }

                CertFreeCertificateChain( pChainContext );

                if (ContinueAdd) {
                    hr = GetCertNameFromCertContext(selectedCert, &UserDispName);
                    if ( ERROR_SUCCESS == hr ){
        
                        EFS_CERTIFICATE_BLOB CertBlob;
        
                        CertBlob.cbData = selectedCert->cbCertEncoded;
                        CertBlob.pbData = selectedCert->pbCertEncoded;
                        CertBlob.dwCertEncodingType = selectedCert->dwCertEncodingType;
                        hr = m_Users.Add(
                                        UserDispName,
                                        (PVOID)&CertBlob,
                                        NULL,
                                        USERADDED,
                                        (PVOID)selectedCert
                                        );
        
                        if ( (ERROR_SUCCESS != hr) && (CRYPT_E_EXISTS != hr) ){
        
                            //
                            // Error in adding the user
                            //
        
                            CertFreeCertificateContext(selectedCert);
                            selectedCert = NULL;
        
                        } else {

                            //
                            // We could just insert the items here to improve the performace.
                            // But we don't have the time right now. We could fix this later
                            // if performance is a problem here.
                            //

                            m_UserListCtrl.DeleteAllItems( );
                            SetUpListBox(NULL);

                            if ( hr == ERROR_SUCCESS ){

                                //
                                // UserDispName is used in m_Users.Add
                                //

                                UserDispName = NULL;
                            }

/* This is the old code when we have the single list.        
                            //
                            // Add the user to the list box.
                            //
                            if ( hr == ERROR_SUCCESS ){
                                
                               if (m_UsersList.AddString(UserDispName) < 0){
        
                                    //
                                    // Error to add to the list box
                                    //
        
                                    m_Users.Remove(UserDispName);
                                }

                                UserDispName = NULL;
        
                            } else {
        
                                //
                                // Let's check if we need to add this to the list box.
                                //
                                if (m_UsersList.FindStringExact( 0, UserDispName ) < 0){
        
                                    //
                                    // Not found
                                    //
                                    
                                    if (m_UsersList.AddString(UserDispName) < 0){
        
                                        //
                                        // Error to add to the list box
                                        //
        
                                        m_Users.Remove(UserDispName);
                                    }
        
                                }
                                
                            }
*/
                        }
                        if (UserDispName){
                            delete [] UserDispName; 
                        }
        
                    } else {
                        CertFreeCertificateContext(selectedCert);
                    }
                }
            } else {

                CString ErrMsg;
                TCHAR   ErrCode[16];

                CertFreeCertificateContext(selectedCert);
        
                if (ContinueProcess) {

                    //
                    // The error has not been processed.
                    //

                    _ltot(GetLastError(), ErrCode, 10 );
                    AfxFormatString1( ErrMsg, IDS_COULDNOTVERIFYCERT, ErrCode );
                    MessageBox(ErrMsg);
                }
        
            }

        } 
        
        if (!DlgTitle.IsEmpty()){
            DlgTitle.ReleaseBuffer();
        }
        if (!DispText.IsEmpty()){
            DispText.ReleaseBuffer();
        }
        if (otherStore) {
            CertCloseStore( otherStore, 0 );
        }
        if (trustedStore) {
            CertCloseStore( trustedStore, 0 );
        }
    }

    CertCloseStore( memStore, 0 );

    return;
}

DWORD USERLIST::TryGetBetterNameInCert(PEFS_HASH_BLOB HashData, LPTSTR *UserName)
{

    HCERTSTORE localStore;
    PCCERT_CONTEXT pCertContext;
    DWORD   retCode;


    //
    // We will add the remote case later
    //

    localStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                            TRUSTEDPEOPLE
                            );

    if (localStore != NULL) {

        //
        // Let's try to the cert in the store
        //
        pCertContext = CertFindCertificateInStore( localStore,
                                                   CRYPT_ASN_ENCODING,
                                                   0,
                                                   CERT_FIND_HASH,
                                                   (CRYPT_HASH_BLOB *)HashData,
                                                   NULL
                                                   );
        if ( pCertContext ){

            retCode = GetCertNameFromCertContext(
                            pCertContext,
                            UserName
                            );
            CertFreeCertificateContext(pCertContext);

        }
	else { 
	    retCode = GetLastError();
	}

        CertCloseStore( localStore, 0 );

    } else {

        retCode = GetLastError();

    }   
    
    return retCode;

}

DWORD USERLIST::CertInStore(HCERTSTORE *pStores, DWORD StoreNum, PCCERT_CONTEXT selectedCert)
{
    DWORD ii = 0;
    PCCERT_CONTEXT pCert = NULL;

    while (ii < StoreNum) {
        pCert = CertFindCertificateInStore(
                    pStores[ii],
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    0,
                    CERT_FIND_EXISTING,
                    selectedCert,
                    pCert
                    );
        if (pCert) {

            //
            // We found it.
            //
            CertFreeCertificateContext(pCert);
            break;
        }
        ii++;
    }

    return ii; 
}

void USERLIST::OnSetfocusListuser(NMHDR* pNMHDR, LRESULT* pResult) 
{
    int ItemPos;

    ShowRemove();
    ShowBackup();


    ItemPos = m_UserListCtrl.GetNextItem( -1, LVNI_SELECTED );
    if ( ItemPos == -1 ){
         m_UserListCtrl.SetItem(0, 0, LVIF_STATE, NULL, 0, LVIS_SELECTED, LVIS_SELECTED, 0);

    }
	
	*pResult = 0;
}

void USERLIST::OnKillfocusListuser(NMHDR* pNMHDR, LRESULT* pResult) 
{

    ShowRemove();
    ShowBackup();
	
	*pResult = 0;

}

void USERLIST::OnItemchangedListuser(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    ShowRemove();
    ShowBackup();
	
	*pResult = 0;
}

void USERLIST::OnSetfocusListra(NMHDR* pNMHDR, LRESULT* pResult) 
{
    int ItemPos;

    ItemPos = m_RecoveryListCtrl.GetNextItem( -1, LVNI_SELECTED );
    if ( ItemPos == -1 ){
        if (m_RecoveryListCtrl.GetItemCount( ) > 0){
            m_RecoveryListCtrl.SetItem(0, 0, LVIF_STATE, NULL, 0, LVIS_SELECTED, LVIS_SELECTED, 0);
        }

    }
	
	*pResult = 0;
}

void USERLIST::OnBackup() 
{

    int ItemPos;
    DWORD rc;
    PCRYPT_HASH_BLOB pHashBlob;
    PCCERT_CONTEXT pCertContext = NULL;
    PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = NULL;

    HCRYPTKEY  hLocalKey = 0;
    HCRYPTPROV hLocalProv = 0;

    BOOLEAN ValidCertFound = FALSE;

    BOOL    NoAction = FALSE;
    CString NoCertName;

    try{
        NoCertName.LoadString(IDS_NOCERTNAME);
    }
    catch(...){
        NoAction = TRUE;
    }

    if (NoAction){
        return;
    }

    //
    // Get the selected item first
    //


	ItemPos = m_UserListCtrl.GetNextItem( -1, LVNI_SELECTED );
    if ( ItemPos != -1 ){

        //
        // Get the hash
        //

        CString CertName;
        LPTSTR  pCertName;
        BOOLEAN ReleaseCertContext = FALSE;


        CertName = m_UserListCtrl.GetItemText( ItemPos, 0 );
        if ( !CertName.Compare(NoCertName) ){
            pCertName = NULL;            
        } else {
            pCertName = CertName.GetBuffer(CertName.GetLength() + 1);
        }

        rc = m_Users.GetCertInfo(
                        pCertName,
                        (PVOID *) &pHashBlob,
                        (PVOID *) &pCertContext
                        );

        if (pCertName){
            CertName.ReleaseBuffer();
        }

        if (rc == ERROR_SUCCESS) {

            if (pCertContext == NULL) {

                //
                //  We don't have the cert context. Try to create one
                //

                pCertContext = GetCertInMyStore(pHashBlob);

                if (pCertContext) {

                    ReleaseCertContext = TRUE;

                } else {

                    rc = GetLastError();

                }

            }

            //
            // We should have the cert context now
            //

            if (pCertContext) {

                //
                //  Now try to get the keys.
                //

                ValidCertFound = CertHasKey(pCertContext);

                if (ValidCertFound) {

                    BOOL bRet;
    
                    //
                    // Now do the export
                    //

                    CRYPTUI_WIZ_EXPORT_INFO myWizardInfo;

                    RtlZeroMemory(&myWizardInfo, sizeof (CRYPTUI_WIZ_EXPORT_INFO));
                    myWizardInfo.dwSize = sizeof(CRYPTUI_WIZ_EXPORT_INFO);
                    myWizardInfo.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
                    myWizardInfo.pCertContext = pCertContext;


                    bRet = CryptUIWizExport(
                               CRYPTUI_WIZ_EXPORT_PRIVATE_KEY | CRYPTUI_WIZ_EXPORT_NO_DELETE_PRIVATE_KEY,
                               NULL,
                               NULL,
                               &myWizardInfo,
                               NULL
                               );
                    if (!bRet) {

                        //
                        // Give the error message
                        //
    
                        rc = GetLastError();

                        if (ERROR_CANCELLED != rc) {

                            CString ErrMsg;
                            TCHAR   ErrCode[16];
    
                            _ltot(rc, ErrCode, 10 );
                            AfxFormatString1( ErrMsg, IDS_NOCERTORKEY, ErrCode );
                
                            MessageBox(ErrMsg);
                        }
                    }
    
                } else {

                    //
                    // Give the error message
                    //

                    CString ErrMsg;
                    TCHAR   ErrCode[16];

                    rc = GetLastError();
        
                    _ltot(rc, ErrCode, 10 );
                    AfxFormatString1( ErrMsg, IDS_NOCERTORKEY, ErrCode );
        
                    MessageBox(ErrMsg);

                }

                if (ReleaseCertContext) {
                    CertFreeCertificateContext( pCertContext );
                }

            } else {

                //
                // The cert is not available
                //
                //
                // Give the error message
                //

                CString ErrMsg;
                TCHAR   ErrCode[16];
    
                _ltot(rc, ErrCode, 10 );
                AfxFormatString1( ErrMsg, IDS_NOCERTORKEY, ErrCode );
    
                MessageBox(ErrMsg);

            }

        } else {

            //
            // We should not come here. The user were added by us. We expect to find him in our list.
            //

            ASSERT(FALSE);
            return;
        }
    }
	
}

void USERLIST::ShowBackup()
{
    if (m_UserListCtrl.GetSelectedCount() == 1){

        //
        // Enable the Backup Button
        //

        m_BackupButton.EnableWindow( TRUE );

    } else {
        
        //
        // Disable the Backup Button
        //

        m_BackupButton.EnableWindow( FALSE );

    }

}

PCCERT_CONTEXT
GetCertInMyStore(
    PCRYPT_HASH_BLOB pHashBlob
    )
{
    
    DWORD      rc = ERROR_SUCCESS;
    HCERTSTORE myStore;
    PCCERT_CONTEXT pCertContext = NULL;

    myStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                0,       // dwEncodingType
                0,       // hCryptProv,
                CERT_SYSTEM_STORE_CURRENT_USER,
                L"My"
                );

    if (myStore != NULL) {

        //
        // Let's try to get the cert in the store
        //
        pCertContext = CertFindCertificateInStore( myStore,
                                                   CRYPT_ASN_ENCODING,
                                                   0,
                                                   CERT_FIND_HASH,
                                                   pHashBlob,
                                                   NULL
                                                   );

        if (pCertContext == NULL) {

            rc = GetLastError();

        }

        CertCloseStore( myStore, 0 );

        if (rc != ERROR_SUCCESS) {
            SetLastError(rc);
        }

    } 

    return pCertContext;
    
}

PCRYPT_KEY_PROV_INFO
GetKeyProvInfo(
    PCCERT_CONTEXT pCertContext
    )
{

    DWORD cbData = 0;
    BOOL b;
    PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = NULL;

    b = CertGetCertificateContextProperty(
             pCertContext,
             CERT_KEY_PROV_INFO_PROP_ID,
             NULL,
             &cbData
             );

    if (b) {

        pCryptKeyProvInfo = (PCRYPT_KEY_PROV_INFO) new BYTE[cbData];

        if (pCryptKeyProvInfo != NULL) {

            b = CertGetCertificateContextProperty(
                     pCertContext,
                     CERT_KEY_PROV_INFO_PROP_ID,
                     pCryptKeyProvInfo,
                     &cbData
                     );

            if (!b) {

                delete [] pCryptKeyProvInfo;
                pCryptKeyProvInfo = NULL;
            }

        } else {

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    return ( pCryptKeyProvInfo );
}

BOOLEAN
CertHasKey(
    PCCERT_CONTEXT pCertContext
    )
{

    PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = NULL;
    DWORD  rc = ERROR_SUCCESS;

    HCRYPTKEY  hLocalKey = 0;
    HCRYPTPROV hLocalProv = 0;

    BOOLEAN ValidCertFound = FALSE;

    pCryptKeyProvInfo = GetKeyProvInfo( pCertContext );
    if (pCryptKeyProvInfo) {

        if (CryptAcquireContext( &hLocalProv, pCryptKeyProvInfo->pwszContainerName, pCryptKeyProvInfo->pwszProvName, PROV_RSA_FULL, CRYPT_SILENT)) {
    
            if (CryptGetUserKey(hLocalProv, AT_KEYEXCHANGE, &hLocalKey)) {

                //
                // We found the key. Let's add the cert to Memory store
                //

                ValidCertFound = TRUE;
                CryptDestroyKey( hLocalKey );

            } else {

                rc = GetLastError();

            }

            CryptReleaseContext( hLocalProv, 0 );

        } else {

            rc = GetLastError();

        }

        delete [] pCryptKeyProvInfo;

    } 

    if (rc != ERROR_SUCCESS) {
        SetLastError(rc);
    }
    return ValidCertFound;

}

void CALLBACK
BackCurrentEfsCert(
    HWND hwnd,
    HINSTANCE hinst,
    LPWSTR lpszCmdLine,
    int nCmdShow
    )
{

    DWORD RetCode;
    HKEY hRegKey = NULL;
    CRYPT_HASH_BLOB HashBlob;
    PCCERT_CONTEXT pCertContext=NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    RetCode = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                KEYPATH,
                0,
                GENERIC_READ,
                &hRegKey
                );

    if (RetCode == ERROR_SUCCESS) {

        DWORD Type;

        RetCode = RegQueryValueEx(
                hRegKey,
                CERT_HASH,
                NULL,
                &Type,
                NULL,
                &(HashBlob.cbData)
                );

        if (RetCode == ERROR_SUCCESS) {

            //
            // Query out the thumbprint, find the cert, and return the key information.
            //

            if ( HashBlob.pbData = (PBYTE) malloc(HashBlob.cbData) ) {

                RetCode = RegQueryValueEx(
                        hRegKey,
                        CERT_HASH,
                        NULL,
                        &Type,
                        HashBlob.pbData,
                        &(HashBlob.cbData)
                        );

                if (RetCode == ERROR_SUCCESS) {

                    //
                    //  We get the cert hash.
                    //

                    pCertContext = GetCertInMyStore(&HashBlob);
                    if (pCertContext != NULL) {

                        BOOLEAN ValidCertFound;

                        //
                        //  Let's try to see if keys are available
                        //

                        ValidCertFound = CertHasKey(pCertContext);

                        if (ValidCertFound) {
                            BOOL bRet;
            
                            //
                            // Now do the export
                            //
        
                            CRYPTUI_WIZ_EXPORT_INFO myWizardInfo;
        
                            RtlZeroMemory(&myWizardInfo, sizeof (CRYPTUI_WIZ_EXPORT_INFO));
                            myWizardInfo.dwSize = sizeof(CRYPTUI_WIZ_EXPORT_INFO);
                            myWizardInfo.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
                            myWizardInfo.pCertContext = pCertContext;
        
        
                            if (!CryptUIWizExport(
                                       CRYPTUI_WIZ_EXPORT_PRIVATE_KEY | CRYPTUI_WIZ_EXPORT_NO_DELETE_PRIVATE_KEY,
                                       NULL,
                                       NULL,
                                       &myWizardInfo,
                                       NULL
                                       )){

                                RetCode = GetLastError();

                                if (ERROR_CANCELLED != RetCode) {

                                    CString ErrMsg;
                                    TCHAR   ErrCode[16];
                            
                                    _ltot(RetCode, ErrCode, 10 );
                            
                                    AfxFormatString1( ErrMsg, IDS_NOCERTORKEY, ErrCode );
                            
                                    MessageBox(hwnd, ErrMsg, NULL, MB_OK);
                                }
                            }
        
                        } else {

                            //
                            // Cert has no key.
                            //

                            RetCode = GetLastError();

                            CString ErrMsg;
                            TCHAR   ErrCode[16];
                    
                            _ltot(RetCode, ErrCode, 10 );
                    
                            AfxFormatString1( ErrMsg, IDS_NOCERTORKEY, ErrCode );
                    
                            MessageBox(hwnd, ErrMsg, NULL, MB_OK);
                            

                        }

                        CertFreeCertificateContext( pCertContext );
                        pCertContext = NULL;

                    } else {

                        //
                        // Cert not find in MY store
                        //

                        RetCode = GetLastError();

                        CString ErrMsg;
                        TCHAR   ErrCode[16];
                
                        _ltot(RetCode, ErrCode, 10 );
                
                        AfxFormatString1( ErrMsg, IDS_CERTNOTINMY, ErrCode );
                
                        MessageBox(hwnd, ErrMsg, NULL, MB_OK);

                    }
                } else {

                    //
                    //  Error in read EFS current key. Not likely to happen.
                    //

                    CString ErrMsg;
                    TCHAR   ErrCode[16];
            
                    _ltot(RetCode, ErrCode, 10 );
            
                    AfxFormatString1( ErrMsg, IDS_NOCRNTCERT, ErrCode );
            
                    MessageBox(hwnd, ErrMsg, NULL, MB_OK);

                }

                free(HashBlob.pbData);

            } else {

                //
                // Out of memory
                //

                CString ErrMsg;

                if (ErrMsg.LoadString(IDS_ERRORMEM)){
                    MessageBox(hwnd, ErrMsg, NULL, MB_OK);
                }

            }
        } else {

        //
        //  No current EFS Cert
        //

            CString ErrMsg;
            TCHAR   ErrCode[16];
    
            _ltot(RetCode, ErrCode, 10 );
    
            AfxFormatString1( ErrMsg, IDS_NOCRNTCERT, ErrCode );
    
            MessageBox(hwnd, ErrMsg, NULL, MB_OK);
        }

        //
        // Close the key handle
        //

        RegCloseKey( hRegKey );

    } else {

        //
        //  No current EFS Cert
        //

        CString ErrMsg;
        TCHAR   ErrCode[16];

        _ltot(RetCode, ErrCode, 10 );

        AfxFormatString1( ErrMsg, IDS_NOCRNTCERT, ErrCode );

        MessageBox(hwnd, ErrMsg, NULL, MB_OK);

    }

}


void CALLBACK
AddUserToObjectW(
    HWND hwnd,
    HINSTANCE hinst,
    LPWSTR lpszCmdLine,
    int nCmdShow
    )
{

    DWORD FileAttributes = GetFileAttributes(lpszCmdLine);

    if ((-1 == FileAttributes) || (!(FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) || ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY))) {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        if (-1 == FileAttributes) {
            CString ErrMsg;
    
            if (ErrMsg.LoadString(IDS_NOOBJECT)){
                MessageBox(hwnd, ErrMsg, NULL, MB_OK);
            }
            return;
        }
        if ( !(FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)){
    
            CString ErrMsg;
    
            if (ErrMsg.LoadString(IDS_NOTENCRYPTED)){
                MessageBox(hwnd, ErrMsg, NULL, MB_OK);
            }
            return;
        }
        if ( (FileAttributes & FILE_ATTRIBUTE_DIRECTORY)){
    
            CString ErrMsg;
    
            if (ErrMsg.LoadString(IDS_NOADDUSERDIR)){
                MessageBox(hwnd, ErrMsg, NULL, MB_OK);
            }
            return;
        }
    }
    
    EfsDetail(hwnd, lpszCmdLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\carddll\back.h ===
#ifdef WINVER_2
typedef BITMAP BMP;
#else
typedef BITMAPINFOHEADER BMP;
#endif

#ifdef WINVER_2
#define DyBmp(bmp) ((int) bmp.bmHeight)
#define DxBmp(bmp) ((int) bmp.bmWidth)
#define CplnBmp(bmp) (bmp.bmPlanes)
#define OfsBits(bgnd) (sizeof(BMPHDR)+sizeof(BMP))
#define CbLine(bgnd) (bgnd.bm.bmWidthBytes)
#else
#define DyBmp(bmp) ((int) bmp.biHeight)
#define DxBmp(bmp) ((int) bmp.biWidth)
#define CplnBmp(bmp) 1
#define OfsBits(bgnd) (bgnd.dwOfsBits)
#define CbLine(bgnd) (bgnd.cbLine)
#endif


#ifdef WINVER_2
typedef INT BMPHDR;
#else
typedef BITMAPFILEHEADER BMPHDR;
#endif


typedef struct _bgnd
	{
	PT ptOrg;
	OFSTRUCT of;
	BMP bm;
#ifdef WINVER_3
	// must folow a bm
	BYTE rgRGB[64];  // bug: wont work with >16 color bmps
	INT cbLine;
	LONG dwOfsBits;
#endif
	BOOL fUseBitmap;
	DY dyBand;
	INT ibndMac;
	HANDLE *rghbnd;
	} BGND;





/* PUBLIC routines */



BOOL FInitBgnd(CHAR *szFile);
BOOL FDestroyBgnd();
BOOL FGetBgndFile(CHAR *sz);
VOID DrawBgnd(X xLeft, Y yTop, X xRight, Y yBot);
VOID SetBgndOrg();



/* Macros */

extern BGND bgnd;

#define FUseBitmapBgnd() (bgnd.fUseBitmap)


#define BFT_BITMAP 0x4d42   /* 'BM' */
#define ISDIB(bft) ((bft) == BFT_BITMAP)
#define WIDTHBYTES(i)   ((i+31)/32*4)      /* ULONG aligned ! */
WORD        DibNumColors(VOID FAR * pv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\encrypt\users.h ===
// Users.h: interface for the CUsers class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_)
#define AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <winefs.h>

#define USERINFILE  1
#define USERADDED   2
#define USERREMOVED 4

typedef struct USERSONFILE {
    USERSONFILE *       Next;
    DWORD               Flag; // If the item is added, removed or existed in the file
    PVOID               Cert; // Either the hash or the Blob
    PVOID               Context; // Cert Context. To be released when the item is deleted.
    LPTSTR              UserName;
    PSID                UserSid;
} USERSONFILE, *PUSERSONFILE;

//
// This class supports single thread only.
//

class CUsers  
{
public:
	CUsers();
	virtual ~CUsers();

public:
	void Clear(void);
	DWORD GetUserRemovedCnt();

	DWORD GetUserAddedCnt();

    DWORD   Add(
                LPTSTR UserName,
                PVOID UserCert, 
                PSID UserSid = NULL, 
                DWORD Flag = USERINFILE,
                PVOID Context = NULL
              );

    DWORD   Add( CUsers &NewUsers );

    PUSERSONFILE RemoveItemFromHead(void);

    DWORD   Remove(
                LPCTSTR UserName
                );
 
    PVOID   StartEnum();

    PVOID   GetNextUser(
                PVOID Token, 
                CString &UserName,
                CString &CertHash
                );

	PVOID GetNextChangedUser(
                PVOID Token, 
                LPTSTR *UserName,
                PSID *UserSid, 
                PVOID *CertData, 
                DWORD *Flag
                );

	void ConvertHashToStr(
                PBYTE pHashData,
                DWORD cbData,
                LPWSTR OutHashStr
                );

    DWORD   GetCertInfo(
                LPCTSTR UserName,
                PVOID *CertData,
                PVOID *CertContext
                );
    

private:
	DWORD m_UserAddedCnt;
	DWORD m_UserRemovedCnt;
    PUSERSONFILE    m_UsersRoot;

};

#endif // !defined(AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\carddll\cdt.h ===
#define CLOADMAX	5

/* Command ids */
#define IDACLUBS	 1
#define ID2CLUBS	 2
#define ID3CLUBS	 3
#define ID4CLUBS	 4
#define ID5CLUBS	 5
#define ID6CLUBS	 6
#define ID7CLUBS	 7
#define ID8CLUBS	 8
#define ID9CLUBS	 9
#define IDTCLUBS	 10
#define IDJCLUBS	 11
#define IDQCLUBS	 12
#define IDKCLUBS	 13

#define IDADIAMONDS	 14
#define ID2DIAMONDS	 15
#define ID3DIAMONDS	 16
#define ID4DIAMONDS	 17
#define ID5DIAMONDS	 18
#define ID6DIAMONDS	 19
#define ID7DIAMONDS	 20
#define ID8DIAMONDS	 21
#define ID9DIAMONDS	 22
#define IDTDIAMONDS	 23
#define IDJDIAMONDS	 24
#define IDQDIAMONDS	 25
#define IDKDIAMONDS	 26

#define IDAHEARTS	 27
#define ID2HEARTS	 28
#define ID3HEARTS	 29
#define ID4HEARTS	 30
#define ID5HEARTS	 31
#define ID6HEARTS	 32
#define ID7HEARTS	 33
#define ID8HEARTS	 34
#define ID9HEARTS	 35
#define IDTHEARTS	 36
#define IDJHEARTS	 37
#define IDQHEARTS	 38
#define IDKHEARTS	 39

#define IDASPADES	 40
#define ID2SPADES	 41
#define ID3SPADES	 42
#define ID4SPADES	 43
#define ID5SPADES	 44
#define ID6SPADES	 45
#define ID7SPADES	 46
#define ID8SPADES	 47
#define ID9SPADES	 48
#define IDTSPADES	 49
#define IDJSPADES	 50
#define IDQSPADES	 51
#define IDKSPADES	 52

#define IDGHOST	53

#define IDFACEDOWN1 	54
#define IDFACEDOWN2 	55
#define IDFACEDOWN3 	56
#define IDFACEDOWN4 	57
#define IDFACEDOWN5 	58
#define IDFACEDOWN6 	59
#define IDFACEDOWN7 	60
#define IDFACEDOWN8 	61
#define IDFACEDOWN9 	62
#define IDFACEDOWN10 	63
#define IDFACEDOWN11 	64
#define IDFACEDOWN12	   65

#define IDFACEDOWNFIRST IDFACEDOWN1
#define IDFACEDOWNLAST IDFACEDOWN12

#define IDX 67
#define IDO 68
#define IDMAX IDDECK



/* internal ID's for animation */

#define IDASLIME1 678
#define IDASLIME2 679

#define IDAKASTL1 680

#define IDAFLIPE1 681
#define IDAFLIPE2 682


#define IDABROBOT1 683
#define IDABROBOT2 684


/* Red non-face card frame */
#define IDFRAME 999


#define FACEUP		0
#define FACEDOWN	1   /* for compatibility with old apps, use IDFACEDOWNFIRST..IDFACEDOWNLAST */
#define HILITE		2
#define GHOST		3
#define REMOVE		4
#define INVISIBLEGHOST 5
#define DECKX		6
#define DECKO		7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\carddll\cards.h ===
/* Type def's needed if your using the card DLL */

typedef enum { faceup = 0,
               facedown = 1,
               hilite = 2,
               ghost = 3,
               remove = 4
             } cardMode;

typedef enum { club = 0,
               diamond = 1,
               heart = 2,
               spade = 3
             } cardSuit;

typedef enum { ace = 0,
               two = 1,
               three = 2,
               four = 3,
               five = 4,
               six = 5,
               seven = 6,
               eight = 7,
               nine = 8,
               ten = 9,
               jack = 10,
               queen = 11,
               king = 12
             } cardRank;

/* Commonly needed macros for card games. */

#define CardIndex(suit, rank)    ((rank) << 2 + (suit))
#define CardSuit(index)          ((index) & 3)
#define CardRank(index)          ((index) >> 2)
#define SameSuit(index1, index2) (CardSuit((index1)) == CardSuit((index2)))
#define SameRank(index1, index2) (CardRank((index1)) == CardRank((index2)))

#define ACELOW    13
#define ACEHIGH   14
#define IndexValue(index, acerank)  (CardRank(index) % (acerank))
//-protect-#define RanksHigher(index1, index2, acerank)
//        (IndexValue((index1), (acerank)) > IndexValue((index2), (acerank)))

/* Function prototypes for API resolved in the cards DLL */

BOOL  APIENTRY cdtInit(INT FAR *width, INT FAR *height);
BOOL  APIENTRY cdtDraw(HDC hDC, INT x, INT y,
                        INT crd, cardMode mode, DWORD rgbBgnd);
BOOL  APIENTRY cdtTerm(VOID);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\carddll\cards.c ===
#include <windows.h>
#include <port1632.h>
#include "std.h"
#include "crd.h"
#include "back.h"
#include "debug.h"

#ifdef DEBUG
#undef Assert
#define Assert(f) { if (!(f)) { char s[80]; wsprintf(s, "CARDS.DLL: %s(%d)", (LPSTR) __FILE__, __LINE__); MessageBox(NULL, s, "Assert Failure", MB_OK); return FALSE; } }
#endif

VOID SaveCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy);
VOID RestoreCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy);

static HBITMAP HbmFromCd(INT cd);
BOOL   FLoadBack(INT cd);


VOID MyDeleteHbm(HBITMAP hbm);


typedef struct
{
    INT id;
    DX  dx;
    DY     dy;
} SPR;

#define isprMax 4

typedef struct
{
    INT cdBase;
    DX dxspr;
    DY dyspr;
    INT isprMac;
    SPR rgspr[isprMax];
} ANI;
    
// we removed the older card decks that required Animation. The new
// card deck doesn't involve any animation.

#define ianiMax 0

static INT        cLoaded = 0;
static HBITMAP    hbmCard[52] =
    {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
static HBITMAP    hbmGhost = NULL;
static HBITMAP    hbmBack = NULL;
static HBITMAP    hbmDeckX = NULL;
static HBITMAP    hbmDeckO = NULL;
static INT        idback = 0;
static INT        dxCard, dyCard;
static INT        cInits = 0;

HANDLE    hinstApp;

/****** L I B  M A I N ******/

/* Called once to  initialize data */
/* Determines if display is color and remembers the hInstance for the DLL */

INT  APIENTRY LibMain(HANDLE hInst, ULONG ul_reason_being_called, LPVOID lpReserved)
{

    hinstApp = hInst;
    
    return 1;
    UNREFERENCED_PARAMETER(ul_reason_being_called);
    UNREFERENCED_PARAMETER(lpReserved);
}


BOOL FInRange(INT w, INT wFirst, INT wLast)
{
    Assert(wFirst <= wLast);
    return(w >= wFirst && w <= wLast);
}

BOOL  APIENTRY cdtInit(INT FAR *pdxCard, INT FAR *pdyCard)
/*
 * Parameters:
 *    pdxCard, pdyCard
 *            Far pointers to ints where card size will be placed
 *
 * Returns:
 *    True when successful, False when it can't find one of the standard
 *    bitmaps.
 */
{
    BITMAP   bmCard;
    HDC      hdc;

    if (cInits++ != 0)
    {
        *pdxCard = dxCard;
        *pdyCard = dyCard;
        return fTrue;
    }
    hbmGhost = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDGHOST));
    hbmDeckX = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDX));
    hbmDeckO = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDO));
    if(hbmGhost == NULL || hbmDeckX == NULL || hbmDeckO == NULL)
        goto Fail;
    GetObject( hbmGhost, sizeof( BITMAP), (LPSTR)&bmCard);
    dxCard = *pdxCard = bmCard.bmWidth;
    dyCard = *pdyCard = bmCard.bmHeight;
    return fTrue;
Fail:
    MyDeleteHbm(hbmGhost);
    MyDeleteHbm(hbmDeckX);
    MyDeleteHbm(hbmDeckO);
    return fFalse;
    UNREFERENCED_PARAMETER(hdc);
}




BOOL  APIENTRY cdtDrawExt(HDC hdc, INT x, INT y, INT dx, INT dy,
                        			INT cd, INT mode, DWORD rgbBgnd)
/*
 * Parameters:
 *    hdc      HDC to window to draw cards on
 *    x, y    Where you'd like them
 * dx,dy card extents
 *    cd        Card to be drawn
 *    mode    Way you want it drawn (or with MINLONG if to be fast)
 *
 * Returns:
 *    True if card successfully drawn, False otherwise
 */
{
    static HBITMAP        hbmSav;
    HDC          hdcMemory;
    DWORD        dwRop = 0;
    HBRUSH       hbr;
    PT           pt;
    POINT        ptReal;
    LONG         rgRGB[12];
    DWORD        dwOldBknd;
    BOOL         bFast=FALSE;    // true if we shouldn't save corners

    if( mode & MINLONG )
    {
        mode= mode + MINLONG;
        bFast= TRUE;
    }

    Assert(hdc != NULL);
    switch (mode)
    {
        default:
            Assert(fFalse);
            break;
        case FACEUP:
            hbmSav = HbmFromCd(cd);
            dwRop = SRCCOPY;
            rgbBgnd = RGB(255,255,255);
            break;
        case FACEDOWN:
            if(!FLoadBack(cd))
                return fFalse;
            hbmSav = hbmBack;
            dwRop = SRCCOPY;
            break;
        case REMOVE:
        case GHOST:
            hbr = CreateSolidBrush( rgbBgnd);
            if(hbr == NULL)
                return fFalse;
            /* *(LONG *)&pt = +++GetDCOrg - NO 32BIT FORM(probably can noop)+++(hdc); */
            //guess again! -- 12-Jul-1994 JonPa
            GetDCOrgEx(hdc, &ptReal);
            pt.x = ptReal.x;
            pt.y = ptReal.y;

            (VOID)MSetBrushOrg( hdc, pt.x, pt.y);
            MUnrealizeObject( hbr);
            if((hbr = SelectObject( hdc, hbr)) != NULL)
            {
                PatBlt(hdc, x, y, dx, dy, PATCOPY);
                hbr = SelectObject( hdc, hbr);
            }
            if (hbr)
                DeleteObject( hbr);
            if(mode == REMOVE)
                return fTrue;
            Assert(mode == GHOST);
             // default: fall thru

        case INVISIBLEGHOST:
            hbmSav = hbmGhost;
            dwRop = SRCAND;
            break;

        case DECKX:
            hbmSav = hbmDeckX;
            dwRop = SRCCOPY;
            break;
        case DECKO:
            hbmSav = hbmDeckO;
            dwRop = SRCCOPY;
            break;
            
        case HILITE:
            hbmSav = HbmFromCd( cd);
            dwRop = NOTSRCCOPY;
            break;
    }
    if (hbmSav == NULL)
        return fFalse;
    else
    {
        hdcMemory = CreateCompatibleDC( hdc);
        if(hdcMemory == NULL)
            return fFalse;

        if((hbmSav = SelectObject( hdcMemory, hbmSav)) != NULL)
        {
            dwOldBknd = SetBkColor(hdc, rgbBgnd);
            if( !bFast )
                SaveCorners(hdc, rgRGB, x, y, dx, dy);
            if(dx != dxCard || dy != dyCard)
                StretchBlt(hdc, x, y, dx, dy, hdcMemory, 0, 0, dxCard, dyCard, dwRop);
            else
                BitBlt( hdc, x, y, dxCard, dyCard, hdcMemory, 0, 0, dwRop);

            SelectObject( hdcMemory, hbmSav);
            /* draw the border for the red cards */
            if(mode == FACEUP)
                {
                INT icd;

                icd = RaFromCd(cd) % 13 + SuFromCd(cd) * 13+1;
                if((icd >= IDADIAMONDS && icd <= IDTDIAMONDS) ||
                    (icd >= IDAHEARTS && icd <= IDTHEARTS))
                    {
                    PatBlt(hdc, x+2, y, dx-4, 1, BLACKNESS);  // top
                    PatBlt(hdc, x+dx-1, y+2, 1, dy-4, BLACKNESS); // right
                    PatBlt(hdc, x+2, y+dy-1, dx-4, 1, BLACKNESS); // bottom
                    PatBlt(hdc, x, y+2, 1, dy-4, BLACKNESS); // left
                    SetPixel(hdc, x+1, y+1, 0L); // top left
                    SetPixel(hdc, x+dx-2, y+1, 0L); // top right
                    SetPixel(hdc, x+dx-2, y+dy-2, 0L); // bot right
                    SetPixel(hdc, x+1, y+dy-2, 0L);    // bot left
                    }    			
                }

            if( !bFast )
                RestoreCorners(hdc, rgRGB, x, y, dx, dy);

            SetBkColor(hdc, dwOldBknd);
        }
        DeleteDC( hdcMemory);
        return fTrue;
    }
}




BOOL  APIENTRY cdtDraw(HDC hdc, INT x, INT y, INT cd, INT mode, DWORD rgbBgnd)
/*
 * Parameters:
 *    hdc        HDC to window to draw cards on
 *    x, y    Where you'd like them
 *    cd        Card to be drawn
 *    mode    Way you want it drawn
 *
 * Returns:
 *    True if card successfully drawn, False otherwise
 */
{

    return cdtDrawExt(hdc, x, y, dxCard, dyCard, cd, mode, rgbBgnd);
}



VOID SaveCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy)
{
    if(dx != dxCard || dy != dyCard)
        return;
    
    // Upper Left
    rgRGB[0] = GetPixel(hdc, x, y);
    rgRGB[1] = GetPixel(hdc, x+1, y);
    rgRGB[2] = GetPixel(hdc, x, y+1);

    // Upper Right
    x += dx -1;
    rgRGB[3] = GetPixel(hdc, x, y);
    rgRGB[4] = GetPixel(hdc, x-1, y);
    rgRGB[5] = GetPixel(hdc, x, y+1);

    // Lower Right
    y += dy-1;
    rgRGB[6] = GetPixel(hdc, x, y);
    rgRGB[7] = GetPixel(hdc, x, y-1);
    rgRGB[8] = GetPixel(hdc, x-1, y);

    // Lower Left
    x -= dx-1;
    rgRGB[9] = GetPixel(hdc, x, y);
    rgRGB[10] = GetPixel(hdc, x+1, y);
    rgRGB[11] = GetPixel(hdc, x, y-1);

}






BOOL  APIENTRY cdtAnimate(HDC hdc, INT cd, INT x, INT y, INT ispr)
{
    INT iani;
    ANI *pani;
    SPR *pspr;
    HBITMAP hbm;
    HDC hdcMem;
    X xSrc;
    Y ySrc;

    // remove animation as we are removing those card decks but just in case
    // someone calls this function, don't do anything.
    return fTrue;

#ifdef UNUSEDCODE 
    if(ispr < 0)        
        return fFalse;
    Assert(hdc != NULL);
    for(iani = 0; iani < ianiMax; iani++)
    {
        if(cd == rgani[iani].cdBase)
        {
            pani = &rgani[iani];
            if(ispr < pani->isprMac)
            {
                pspr = &pani->rgspr[ispr];
                Assert(pspr->id != 0);
                if(pspr->id == cd)
                {
                    xSrc = pspr->dx;
                    ySrc = pspr->dy;
                }
                else
                    xSrc = ySrc = 0;

                hbm = LoadBitmap(hinstApp, MAKEINTRESOURCE(pspr->id));
                if(hbm == NULL)
                    return fFalse;

                hdcMem = CreateCompatibleDC(hdc);
                if(hdcMem == NULL)
                {
                    DeleteObject(hbm);
                    return fFalse;
                }

                if((hbm = SelectObject(hdcMem, hbm)) != NULL)
                {
                    BitBlt(hdc, x+pspr->dx, y+pspr->dy, pani->dxspr, pani->dyspr,
                        hdcMem, xSrc, ySrc, SRCCOPY);
                    DeleteObject(SelectObject(hdcMem, hbm));
                }
                DeleteDC(hdcMem);
                return fTrue;
            }
        }
    }
    return fFalse;

#endif

}



VOID RestoreCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy)
{
    if(dx != dxCard || dy != dyCard)
        return;

    // Upper Left
    SetPixel(hdc, x, y, rgRGB[0]);
    SetPixel(hdc, x+1, y, rgRGB[1]);
    SetPixel(hdc, x, y+1, rgRGB[2]);

    // Upper Right
    x += dx-1;
    SetPixel(hdc, x, y, rgRGB[3]);
    SetPixel(hdc, x-1, y, rgRGB[4]);
    SetPixel(hdc, x, y+1, rgRGB[5]);

    // Lower Right
    y += dy-1;
    SetPixel(hdc, x, y, rgRGB[6]);
    SetPixel(hdc, x, y-1, rgRGB[7]);
    SetPixel(hdc, x-1, y, rgRGB[8]);

    // Lower Left
    x -= dx-1;
    SetPixel(hdc, x, y, rgRGB[9]);
    SetPixel(hdc, x+1, y, rgRGB[10]);
    SetPixel(hdc, x, y-1, rgRGB[11]);
}




/* loads global bitmap hbmBack */
BOOL FLoadBack(INT idbackNew)
    {
    extern HBITMAP hbmBack;
    extern INT idback;
    CHAR szPath[64];
    INT fh;
    CHAR *pch;

    Assert(FInRange(idbackNew, IDFACEDOWNFIRST, IDFACEDOWNLAST));

    if(idback != idbackNew)
        {
        MyDeleteHbm(hbmBack);
        if((hbmBack = LoadBitmap(hinstApp, MAKEINTRESOURCE(idbackNew))) != NULL)
            idback = idbackNew;
        else
            idback = 0;
        }
    return idback != 0;
    UNREFERENCED_PARAMETER(pch);
    UNREFERENCED_PARAMETER(szPath);
    UNREFERENCED_PARAMETER(fh);
    }



static HBITMAP HbmFromCd(INT cd)
    {
    static INT    iNext = 0;
    INT            icd;

    if (hbmCard[cd] == NULL)
        {
        if (cLoaded >= CLOADMAX)
            {
            for (; hbmCard[iNext] == NULL;
                iNext = (iNext == 51) ? 0 : iNext + 1);
            DeleteObject( hbmCard[iNext]);
            hbmCard[iNext] = NULL;
            cLoaded--;
            }

        icd = RaFromCd(cd) % 13 + SuFromCd(cd) * 13;
        while ((hbmCard[cd]=LoadBitmap(hinstApp,MAKEINTRESOURCE(icd+1)))
                == NULL)
            {
            if (cLoaded == 0)
                return NULL;
            else
                {
                for (; hbmCard[iNext] == NULL;
                    iNext = (iNext == 51) ? 0 : iNext + 1);
                DeleteObject( hbmCard[iNext]);
                hbmCard[iNext] = NULL;
                cLoaded--;
                }
            }
        cLoaded++;
        }
    return hbmCard[cd];
    }


VOID MyDeleteHbm(HBITMAP hbm)    
    {
    if(hbm != NULL)
        DeleteObject(hbm);
    }

VOID  APIENTRY cdtTerm()
/*
 * Free up space if it's time to do so.
 *
 * Parameters:
 *    none
 *
 * Returns:
 *    nothing
 */
    {
    INT    i;

    if (--cInits > 0)
        return;
    for (i = 0; i < 52; i++)
        MyDeleteHbm(hbmCard[i]);
    MyDeleteHbm(hbmGhost);
    MyDeleteHbm(hbmBack);
    MyDeleteHbm(hbmDeckX);
    MyDeleteHbm(hbmDeckO);
    }

INT  APIENTRY WEP(INT nCmd)
{
    return 1;
    UNREFERENCED_PARAMETER(nCmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\carddll\crd.h ===
#include "cdt.h"


typedef INT CD;

// CaRD struct, this is what a card be
typedef struct _crd
	{
	unsigned cd  : 15;		// card # (1..52)
	unsigned fUp : 1;		// is this card up/down
	PT pt;				// upper-left corner of card
	} CRD;




/* WARNING: Order of su's is assumed */
#define suClub 0
#define suDiamond 1
#define suHeart 2
#define suSpade 3
#define suMax 4
#define suFirst suClub

#define raAce 0
#define raDeuce 1
#define raTres 2
#define raFour 3
#define raFive 4
#define raSix 5
#define raSeven 6
#define raEight 7
#define raNine 8
#define raTen 9
#define raJack 10
#define raQueen 11
#define raKing 12
#define raMax 13
#define raNil 15
#define raFirst raAce

typedef INT RA;
typedef INT SU;

#define cdNil 0x3c


#define cIDFACEDOWN (IDFACEDOWNLAST-IDFACEDOWNFIRST+1)

#define SuFromCd(cd) ((cd)&0x03)
#define RaFromCd(cd) ((cd)>>2)
#define Cd(ra, su) (((ra)<<2)|(su))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\encrypt\users.cpp ===
// Users.cpp: implementation of the CUsers class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "efsadu.h"
#include "Users.h"
#include <wincrypt.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUsers::CUsers()
{
    m_UsersRoot = NULL;
	m_UserAddedCnt = 0;
	m_UserRemovedCnt = 0;
}

//////////////////////////////////////////////////////////////////////
// Walk through the chain to free the memory
//////////////////////////////////////////////////////////////////////

CUsers::~CUsers()
{
    Clear();
}

PUSERSONFILE
CUsers::RemoveItemFromHead(void)
{
    PUSERSONFILE PItem = m_UsersRoot;
    if (m_UsersRoot){
        m_UsersRoot = m_UsersRoot->Next;
        if ((PItem->Flag & USERADDED) && !(PItem->Flag & USERREMOVED)){
            m_UserAddedCnt--;
        }
        if ((PItem->Flag & USERINFILE) && (PItem->Flag & USERREMOVED)){
            m_UserRemovedCnt--;
        }
    }
    return PItem;
}

DWORD
CUsers::Add( CUsers &NewUsers )
{
    PUSERSONFILE NewItem;

    while (NewItem = NewUsers.RemoveItemFromHead()){
        PUSERSONFILE    TmpItem = m_UsersRoot;
        
        while ( TmpItem ){

            if ((NewItem->UserName && TmpItem->UserName && !_tcsicmp(NewItem->UserName, TmpItem->UserName)) ||
                 ((NULL == NewItem->UserName) && (TmpItem->UserName == NULL))){

                //
                // User exist
                //

                if ( TmpItem->Flag & USERREMOVED ){

                    if ( TmpItem->Flag & USERADDED ){

                        ASSERT(!(TmpItem->Flag & USERINFILE));

                        //
                        //    User added and removed
                        //
                        m_UserAddedCnt++;

                    } else if ( TmpItem->Flag & USERINFILE ){

                        //
                        //    User added and removed
                        //
                        m_UserRemovedCnt--;

                    }
                    TmpItem->Flag &= ~USERREMOVED;
                }

                //
                // The caller will count on CUsers to release the memory
                //

                if (NewItem->UserName){
                    delete [] NewItem->UserName;
                }
                if ( NewItem->Context ) {
                    CertFreeCertificateContext((PCCERT_CONTEXT)NewItem->Context);
                }
                delete [] NewItem->Cert;
                if (NewItem->UserSid){
                    delete [] NewItem->UserSid;
                }
                delete NewItem;
                NewItem = NULL;                
                break;
            }
            TmpItem = TmpItem->Next;
        }

        if (NewItem ){ 
            //
            // New item. Insert into the head.
            //

            NewItem->Next = m_UsersRoot;
            m_UsersRoot = NewItem;
            m_UserAddedCnt++;
        }

    }

    return ERROR_SUCCESS;
}

DWORD
CUsers::Add(
    LPTSTR UserName,
    PVOID UserCert, 
    PSID UserSid, /* = NULL */
    DWORD Flag, /* = USERINFILE */
    PVOID Context /* = NULL */
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Create an item for a user
// Arguments:
//      UserName -- User's name
//      UserCert -- User's certificate blob or hash
//      UserSid -- User's ID. Can be NULL
//      Flag -- Indicate if the item is existing in the file, to be added or removed
//  Return Value:
//      NO_ERROR if succeed.
//      Will throw exception if memory allocation fails. ( From new.)
// 
//////////////////////////////////////////////////////////////////////
{

    PUSERSONFILE UserItem;
    PUSERSONFILE TmpUserItem = m_UsersRoot;
    PEFS_CERTIFICATE_BLOB CertBlob;
    PEFS_HASH_BLOB  CertHashBlob;
    DWORD   CertSize;
    DWORD   SidSize;

    if ( !UserCert ){
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT ( (( Flag & USERADDED ) || ( Flag & USERINFILE )) &&
                       ( (Flag & (USERADDED | USERINFILE)) != (USERADDED | USERINFILE)));


    //
    // If the user already in the memory, no new item is to be created except for unknown user
    //

    while ( TmpUserItem ){
        if ( (UserName && TmpUserItem->UserName && !_tcsicmp(UserName, TmpUserItem->UserName)) ||
              ((NULL == UserName) && (TmpUserItem->UserName == NULL))){

            //
            // User exist
            //

            if ( TmpUserItem->Flag & USERREMOVED ){

                if ( TmpUserItem->Flag & USERADDED ){

                    ASSERT(!(TmpUserItem->Flag & USERINFILE));

                    //
                    //    User added and removed
                    //
                    m_UserAddedCnt++;

                } else if ( TmpUserItem->Flag & USERINFILE ){

                    //
                    //    User added and removed
                    //
                    m_UserRemovedCnt--;

                }
                TmpUserItem->Flag &= ~USERREMOVED;
            }

            //
            // The caller will count on CUsers to release 
            // the context if the call returns CRYPT_E_EXISTS. This is just for
            // performance reason.
            //
/*
            if (UserName){
                delete [] UserName;
            }
*/
            if ( Context ) {
                CertFreeCertificateContext((PCCERT_CONTEXT)Context);
                Context = NULL;
            }
            return CRYPT_E_EXISTS;
        }
        TmpUserItem = TmpUserItem->Next;
    }
    
    try {
        UserItem = new USERSONFILE;
        if ( NULL == UserItem ){
            AfxThrowMemoryException( );
        }

        UserItem->Next = NULL;

        //
        // In case exception raised, we can call delete.
        // Delete NULL is OK, but random data is not OK.
        //

        UserItem->UserSid = NULL;
        UserItem->Cert = NULL;
        UserItem->Context = NULL;

        if ( UserSid ){
            SidSize = GetLengthSid( UserSid );
            if (  SidSize > 0 ){
                UserItem->UserSid = new BYTE[SidSize];
                if ( NULL == UserItem->UserSid ){
                    AfxThrowMemoryException( );
                }
                if ( !CopySid(SidSize, UserItem->UserSid, UserSid)){
                    delete [] UserItem->UserSid;
                    delete UserItem;
                    return GetLastError();
                }
                
            } else {
                delete UserItem;
                return GetLastError();
            }
        } else {
            UserItem->UserSid = NULL;
        }
 
        if ( Flag & USERINFILE ){

            //
            // The info is from the file. Use the hash structure
            //

            CertHashBlob = ( PEFS_HASH_BLOB ) UserCert;
            CertSize = sizeof(EFS_HASH_BLOB) + CertHashBlob->cbData;
            UserItem->Cert = new BYTE[CertSize];
            if ( NULL == UserItem->Cert ){
                AfxThrowMemoryException( );
            }
            ((PEFS_HASH_BLOB)UserItem->Cert)->cbData = CertHashBlob->cbData;
            ((PEFS_HASH_BLOB)UserItem->Cert)->pbData = (PBYTE)(UserItem->Cert) + sizeof(EFS_HASH_BLOB);
            memcpy(((PEFS_HASH_BLOB)UserItem->Cert)->pbData, 
                   CertHashBlob->pbData,
                   CertHashBlob->cbData
                  );
        } else {

            //
            // The info is from the user picked cert. Use Cert Blob structure
            //

            CertBlob = ( PEFS_CERTIFICATE_BLOB ) UserCert;
            CertSize = sizeof(EFS_CERTIFICATE_BLOB) + CertBlob->cbData;
            UserItem->Cert = new BYTE[CertSize];
            if ( NULL == UserItem->Cert ){
                AfxThrowMemoryException( );
            }
            ((PEFS_CERTIFICATE_BLOB)UserItem->Cert)->cbData = CertBlob->cbData;
            ((PEFS_CERTIFICATE_BLOB)UserItem->Cert)->dwCertEncodingType = CertBlob->dwCertEncodingType;
            ((PEFS_CERTIFICATE_BLOB)UserItem->Cert)->pbData = (PBYTE)(UserItem->Cert) + sizeof(EFS_CERTIFICATE_BLOB);
            memcpy(((PEFS_CERTIFICATE_BLOB)UserItem->Cert)->pbData, 
                   CertBlob->pbData,
                   CertBlob->cbData
                  );

        }
 
        UserItem->UserName = UserName;
        UserItem->Context = Context;
        UserItem->Flag = Flag;
        if ( Flag & USERADDED ){
            m_UserAddedCnt ++;
        }
    }
    catch (...) {
        delete [] UserItem->UserSid;
        delete [] UserItem->Cert;
        delete UserItem;
        AfxThrowMemoryException( );
        return ERROR_NOT_ENOUGH_MEMORY; 
    }

    //
    // Add to the head
    //

    if ( NULL != m_UsersRoot ){
        UserItem->Next = m_UsersRoot;
    }
    m_UsersRoot = UserItem;

    return NO_ERROR;
}

DWORD
CUsers::Remove(
    LPCTSTR UserName
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Remove a user from the list. Actually just mark for remove.
// Arguments:
//      UserName -- User's name
//  Return Value:
//      NO_ERROR if succeed.
//      ERROR_NOT_FOUND if the user cannot be found.
// 
//////////////////////////////////////////////////////////////////////
{
    PUSERSONFILE TmpUserItem = m_UsersRoot;

    BOOL    UserMatched =FALSE;

    while ( TmpUserItem ){
        if (((NULL==UserName) && ( NULL == TmpUserItem->UserName)) || 
            ( UserName && TmpUserItem->UserName && !_tcsicmp(UserName, TmpUserItem->UserName))){

            //
            // User exist, mark it for remove
            //

            if ( TmpUserItem->Flag & USERINFILE ){
                m_UserRemovedCnt++;
            } else if ( TmpUserItem->Flag & USERADDED ) {
                m_UserAddedCnt--;
            }
            TmpUserItem->Flag |= USERREMOVED;
            return NO_ERROR;
        }
        TmpUserItem = TmpUserItem->Next;
    }
    return ERROR_NOT_FOUND;
}


DWORD   
CUsers::GetCertInfo(
    LPCTSTR UserName,
    PVOID *CertData,
    PVOID *CertContext
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get user's cert related value
// Arguments:
//      UserName -- User's name whose cert is to be found
//      CertData -- Certificate Thumbprinter or cert blob
//      CertContext -- Cert context 
// Return Value:
//      Win32 Error
// 
//////////////////////////////////////////////////////////////////////
{

    PUSERSONFILE TmpUserItem = m_UsersRoot;

    BOOL    UserMatched =FALSE;

    if ((CertData == NULL) || (CertContext == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    while ( TmpUserItem ){
        if (((NULL==UserName) && ( NULL == TmpUserItem->UserName)) || 
            ( UserName && TmpUserItem->UserName && !_tcsicmp(UserName, TmpUserItem->UserName))){

            //
            // User exist, return the interested data
            //

            *CertData = TmpUserItem->Cert;
            *CertContext = TmpUserItem->Context;

            return ERROR_SUCCESS;
        }
        TmpUserItem = TmpUserItem->Next;
    }
    return ERROR_NOT_FOUND;
}

PVOID
CUsers::StartEnum()
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Prepare for GetNextUser
// Arguments:
//
//  Return Value:
//      A pointer used for GetNextUser
// 
//////////////////////////////////////////////////////////////////////
{
    return ((PVOID)m_UsersRoot);
}

PVOID
CUsers::GetNextUser(
    PVOID Token, 
    CString &UserName,
    CString &CertHash
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get next user in the list.(Not removed).
// Arguments:
//      UserName -- Next User's name
//      CertHash -- Certificate Thumbprinter
//      Token -- A pointer returned by previous GetNextUser or StartEnum. 
// Return Value:
//      A pointer for GetNextUser()
// 
//////////////////////////////////////////////////////////////////////
{

    PUSERSONFILE   TmpItem = (PUSERSONFILE) Token;
    PVOID   RetPointer = NULL;

    while ( TmpItem ){

        if ( TmpItem->Flag & USERREMOVED ){
            TmpItem = TmpItem->Next;
            continue;
        }

        try{    
            LPWSTR     HashString = NULL;

            UserName = TmpItem->UserName;

            if (TmpItem->Flag & USERINFILE){

                PEFS_HASH_BLOB UserHashBlob;

                UserHashBlob = (PEFS_HASH_BLOB)TmpItem->Cert;
                HashString = new WCHAR[((((UserHashBlob->cbData + 1)/2) * 5) + 1)];
                if (HashString) {
                    ConvertHashToStr(UserHashBlob->pbData, UserHashBlob->cbData, HashString);
                }

            } else if ( TmpItem->Context ){

                DWORD cbHash;
                PBYTE pbHash;

                if (CertGetCertificateContextProperty(
                             (PCCERT_CONTEXT)TmpItem->Context,
                             CERT_HASH_PROP_ID,
                             NULL,
                             &cbHash
                             )) {

                    pbHash = (PBYTE)new BYTE[cbHash];

                    if (pbHash != NULL) {

                        if (CertGetCertificateContextProperty(
                                     (PCCERT_CONTEXT)TmpItem->Context,
                                     CERT_HASH_PROP_ID,
                                     pbHash,
                                     &cbHash
                                     )) {

                            HashString = new WCHAR[((((cbHash + 1)/2) * 5) + 1)];
                            if (HashString) {
                                ConvertHashToStr(pbHash, cbHash, HashString);
                            }
                        }
                      
                        delete [] pbHash;

                    }
                }

            }
            
            CertHash = HashString;
            if (HashString){
                delete [] HashString;
            }
            RetPointer = TmpItem->Next;
        }
        catch (...){

            //
            // Out of memory
            //

            TmpItem = NULL;
            RetPointer = NULL;
        }
        break;
    }

    if ( NULL == TmpItem ){
        UserName.Empty();
        CertHash.Empty();
    }
    return RetPointer;

}

DWORD CUsers::GetUserAddedCnt()
{
    return m_UserAddedCnt;
}

DWORD CUsers::GetUserRemovedCnt()
{
    return m_UserRemovedCnt;
}

PVOID
CUsers::GetNextChangedUser(
    PVOID Token, 
    LPTSTR * UserName,
    PSID * UserSid, 
    PVOID * CertData, 
    DWORD * Flag
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get the info for changed users. This method is not well behaved in the
//  sense of OOP. It exposes internal pointers to the ouside world. The gain
//  is performance. At this moment, CUsers is a supporting class and used only
//  by USERLIST and CAddSheet (single thread). We can make USERLIST a 
//  friend of CUsers if such concerns are raised in the future or reimplement this. 
//  The same issue applies to the enumerate methods.
//
// Arguments:
//      Token -- A pointer to the item returned in previous GetNextChangedUser or StartEnum.
//      UserName -- User's name
//      CertData -- User's certificate blob or hash
//      UserSid -- User's ID. Can be NULL
//      Flag -- Indicate if the item is existing in the file, to be added or removed
//  Return Value:
//      Next item pointer.
// 
//////////////////////////////////////////////////////////////////////
{
    BOOL    ChangedUserFound = FALSE;

    while ( Token ){

        *Flag = ((PUSERSONFILE) Token)->Flag;

        if ( ( *Flag & USERADDED ) && !( *Flag & USERREMOVED )){

            //
            // The user is to to be added to the file
            //

            *Flag = USERADDED;
            ChangedUserFound = TRUE;

        } else if ( ( *Flag & USERREMOVED ) && ( *Flag & USERINFILE)){

            //
            // The user is to be removed from the file
            //

            *Flag = USERREMOVED;
            ChangedUserFound = TRUE;

        }

        if ( ChangedUserFound ){

            *UserName = ((PUSERSONFILE) Token)->UserName;
            *UserSid = ((PUSERSONFILE) Token)->UserSid;
            *CertData = ((PUSERSONFILE) Token)->Cert;
            return ((PUSERSONFILE) Token)->Next;

        } else {

            Token = ((PUSERSONFILE) Token)->Next;

        }

    }

    *UserName = NULL;
    *UserSid = NULL;
    *CertData = NULL;
    *Flag = 0;
    return NULL;
}

void CUsers::Clear()
{

    PUSERSONFILE TmpUserItem = m_UsersRoot;
    while (TmpUserItem){
        m_UsersRoot = TmpUserItem->Next;
        delete [] TmpUserItem->UserName;
        delete [] TmpUserItem->Cert;
        if (TmpUserItem->UserSid){
            delete [] TmpUserItem->UserSid;
        }
        if (TmpUserItem->Context){
            CertFreeCertificateContext((PCCERT_CONTEXT)TmpUserItem->Context);
        }
        delete TmpUserItem;
        TmpUserItem = m_UsersRoot;
    }

    m_UsersRoot = NULL;
	m_UserAddedCnt = 0;
	m_UserRemovedCnt = 0;

}

void CUsers::ConvertHashToStr(
    PBYTE pHashData,
    DWORD cbData,
    LPWSTR OutHashStr
    )
{

    DWORD Index = 0;
    BOOLEAN NoLastZero = FALSE;

    for (; Index < cbData; Index+=2) {

        BYTE HashByteLow = pHashData[Index] & 0x0f;
        BYTE HashByteHigh = (pHashData[Index] & 0xf0) >> 4;

        OutHashStr[Index * 5/2] = HashByteHigh > 9 ? (WCHAR)(HashByteHigh - 9 + 0x40): (WCHAR)(HashByteHigh + 0x30);
        OutHashStr[Index * 5/2 + 1] = HashByteLow > 9 ? (WCHAR)(HashByteLow - 9 + 0x40): (WCHAR)(HashByteLow + 0x30);

        if (Index + 1 < cbData) {
            HashByteLow = pHashData[Index+1] & 0x0f;
            HashByteHigh = (pHashData[Index+1] & 0xf0) >> 4;
    
            OutHashStr[Index * 5/2 + 2] = HashByteHigh > 9 ? (WCHAR)(HashByteHigh - 9 + 0x40): (WCHAR)(HashByteHigh + 0x30);
            OutHashStr[Index * 5/2 + 3] = HashByteLow > 9 ? (WCHAR)(HashByteLow - 9 + 0x40): (WCHAR)(HashByteLow + 0x30);
    
            OutHashStr[Index * 5/2 + 4] = L' ';

        } else {
            OutHashStr[Index * 5/2 + 2] = 0;
            NoLastZero = TRUE;
        }

    }

    if (!NoLastZero) {
        OutHashStr[Index*5/2] = 0;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\carddll\debug.h ===
typedef struct
	{
	VOID *pgmcol;
	WORD lvl;
	WORD msg;
	WORD wp1;
	WORD wp2;
	WORD wResult;
	} MDBG;



#define imdbgMax 500



VOID InitDebug();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\freecell\dialog.c ===
/****************************************************************************

Dialog.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32

Contains dialog box callback procedures.

****************************************************************************/

#include "freecell.h"
#include "freecons.h"


static void CentreDialog(HWND hDlg);


/****************************************************************************

MoveColDlg

If there is ambiguity about whether the user intends to move a single card
or a column to an empty column, this dialog lets the user decide.

The return code in EndDialog tells the caller the user's choice:
    -1      user chose cancel
    FALSE   user chose to move a single card
    TRUE    user chose to move a column

****************************************************************************/

INT_PTR  APIENTRY MoveColDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:                 
            CentreDialog(hDlg);
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDCANCEL:
                    EndDialog(hDlg, -1);
                    return TRUE;
                    break;

                case IDC_SINGLE:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
                    break;

                case IDC_MOVECOL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;
            }
            break;
    }
    return FALSE;                             /* Didn't process a message    */
}


/****************************************************************************

GameNumDlg

The variable gamenumber must be set with a default value before this
dialog is invoked.  That number is placed in an edit box where the user
can accept it by pressing Enter or change it.  EndDialog returns TRUE
if the user chose a valid number (1 to MAXGAMENUMBER) and FALSE otherwise.

****************************************************************************/

INT_PTR  APIENTRY GameNumDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    // For context sensitive help
    static DWORD aIds[] = {     
        IDC_GAMENUM,        IDH_GAMENUM,        
        0,0 }; 

    switch (message) {
        case WM_INITDIALOG:                     // set default gamenumber
            CentreDialog(hDlg);
            SetDlgItemInt(hDlg, IDC_GAMENUM, gamenumber, FALSE);
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDCANCEL:
                    gamenumber = CANCELGAME;
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDOK:
                    gamenumber = (int) GetDlgItemInt(hDlg, IDC_GAMENUM, NULL, TRUE);

                    // negative #s are special cases -- unwinnable shuffles

                    if (gamenumber < -2 || gamenumber > MAXGAMENUMBER)
                        gamenumber = 0;
                    EndDialog(hDlg, gamenumber != 0);
                    return TRUE;
            }
            break;

         // context sensitive help.
        case WM_HELP: 
            WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("freecell.hlp"), 
            HELP_WM_HELP, (ULONG_PTR) aIds);         
            break;  

        case WM_CONTEXTMENU: 
            WinHelp((HWND) wParam, TEXT("freecell.hlp"), HELP_CONTEXTMENU, 
            (ULONG_PTR) aIds);         
            break;   

    }
    return FALSE;
}


/****************************************************************************

YouWinDlg(HWND, unsigned, UINT, LONG)

****************************************************************************/

INT_PTR  APIENTRY YouWinDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND    hSelect;                // handle to check box

    switch (message) {
        case WM_INITDIALOG:                 // initialize checkbox
            hSelect = GetDlgItem(hDlg, IDC_YWSELECT);
            SendMessage(hSelect, BM_SETCHECK, bSelecting, 0);
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDYES:
                    hSelect = GetDlgItem(hDlg, IDC_YWSELECT);
                    bSelecting = (BOOL) SendMessage(hSelect, BM_GETCHECK, 0, 0);
                    EndDialog(hDlg, IDYES);
                    return TRUE;

                case IDNO:
                case IDCANCEL:
                    EndDialog(hDlg, IDNO);
                    return TRUE;
            }
            break;
    }
    return FALSE;                           // didn't process a message
}


/****************************************************************************

YouLoseDlg

The user can choose to play a new game (same shuffle or new shuffle) or not.

****************************************************************************/

INT_PTR  APIENTRY YouLoseDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND    hSameGame;              // handle to check box
    BOOL    bSame;                  // value of check box

    switch (message) {
        case WM_INITDIALOG:
            CentreDialog(hDlg);
            bGameInProgress = FALSE;
            UpdateLossCount();
            hSameGame = GetDlgItem(hDlg, IDC_YLSAME);
            SendMessage(hSameGame, BM_SETCHECK, TRUE, 0);   // default to same
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDYES:
                case IDOK:
                    hSameGame = GetDlgItem(hDlg, IDC_YLSAME);
                    bSame = (BOOL) SendMessage(hSameGame, BM_GETCHECK, 0, 0);
                    if (bSame)
                        PostMessage(hMainWnd,WM_COMMAND,IDM_RESTART,gamenumber);
                    else
                    {
                        if (bSelecting)
                            PostMessage(hMainWnd, WM_COMMAND, IDM_SELECT, 0);
                        else
                            PostMessage(hMainWnd, WM_COMMAND, IDM_NEWGAME, 0);
                    }
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDNO:
                case IDCANCEL:
                    gamenumber = 0;
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }
            break;
    }
    return FALSE;
}


#define ARRAYSIZE(a) ( sizeof(a) / sizeof(a[0]) )

/****************************************************************************

StatsDlg

This dialog box shows current wins and losses, as well as total stats
including data from .ini file.

The IDC_CLEAR message clears out the entire section from the .ini file.

****************************************************************************/

INT_PTR  APIENTRY StatsDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND    hText;                      // handle to text control with stats
    UINT    cTLost, cTWon;              // total losses and wins
    UINT    cTLosses, cTWins;           // streaks
    UINT    wPct;                       // winning % this session
    UINT    wTPct;                      // winning % including .ini data
    UINT    wStreak;                    // current streak amount
    UINT    wSType;                     // current streak type
    TCHAR   sbuffer[40];                // streak buffer
    int     nResp;                      // messagebox response
    TCHAR   buffer[256];                // extra buffer needed for loadingstrings.
    LONG    lRegResult;                 // used to store return code from registry call

    // for context sensitive help
    static DWORD aIds[] = {     
        IDC_CLEAR,        IDH_CLEAR,
        IDC_STEXT1,       IDH_STEXT1,
        IDC_STEXT2,       IDH_STEXT2,
        IDC_STEXT3,       IDH_STEXT3,
        0,0 }; 


    switch (message) {
        case WM_INITDIALOG:
            CentreDialog(hDlg);
            wPct = CalcPercentage(cWins, cLosses);

            /* Get cT... data from the registry */

            lRegResult = REGOPEN

            if (ERROR_SUCCESS == lRegResult)
            {
                cTLost = GetInt(pszLost, 0);
                cTWon  = GetInt(pszWon, 0);

                wTPct  = CalcPercentage(cTWon, cTLost);

                cTLosses = GetInt(pszLosses, 0);
                cTWins   = GetInt(pszWins, 0);

                wStreak = GetInt(pszStreak, 0);
                if (wStreak != 0)
                {
                    wSType = GetInt(pszSType, 0);

                    if (wStreak == 1)
                    {
                        LoadString(hInst, (wSType == WON ? IDS_1WIN : IDS_1LOSS),
                                    sbuffer, ARRAYSIZE(sbuffer));
                    }
                    else
                    {
                        LoadString(hInst, (wSType == WON ? IDS_WINS : IDS_LOSSES),
                                    smallbuf, SMALL);
                        wsprintf(sbuffer, smallbuf, wStreak);
                    }
                }
                else
                    wsprintf(sbuffer, TEXT("%u"), 0);

                // set the dialog text.
                LoadString(hInst, IDS_STATS1, buffer, ARRAYSIZE(buffer));
                wsprintf(bigbuf, buffer, wPct, cWins, cLosses);
                hText = GetDlgItem(hDlg, IDC_STEXT1);
                SetWindowText(hText, bigbuf);

                LoadString(hInst, IDS_STATS2, buffer, ARRAYSIZE(buffer));
                wsprintf(bigbuf, buffer, wTPct, cTWon, cTLost);
                hText = GetDlgItem(hDlg, IDC_STEXT2);
                SetWindowText(hText, bigbuf);

                LoadString(hInst, IDS_STATS3, buffer, ARRAYSIZE(buffer));
                wsprintf(bigbuf, buffer, cTWins, cTLosses, (LPTSTR) sbuffer);
                hText = GetDlgItem(hDlg, IDC_STEXT3);
                SetWindowText(hText, bigbuf);


                REGCLOSE;
            }
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDC_CLEAR:
                    LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                    LoadString(hInst, IDS_RU_SURE, bigbuf, BIG);
                    MessageBeep(MB_ICONQUESTION);
                    nResp = MessageBox(hDlg, bigbuf, smallbuf,
                                       MB_YESNO | MB_ICONQUESTION);
                    if (nResp == IDNO)
                        break;

                    lRegResult = REGOPEN

                    if (ERROR_SUCCESS == lRegResult)
                    {
                        DeleteValue(pszWon);
                        DeleteValue(pszLost);
                        DeleteValue(pszWins);
                        DeleteValue(pszLosses);
                        DeleteValue(pszStreak);
                        DeleteValue(pszSType);
                        REGCLOSE
                    }

                    cWins = 0;
                    cLosses = 0;
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }
            break;
        
        // context sensitive help.
        case WM_HELP: 
            WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("freecell.hlp"), 
            HELP_WM_HELP, (ULONG_PTR) aIds);         
            break;  

        case WM_CONTEXTMENU: 
            WinHelp((HWND) wParam, TEXT("freecell.hlp"), HELP_CONTEXTMENU, 
            (ULONG_PTR) aIds);         
            break;   

    }
    return FALSE;
}


/****************************************************************************

CalcPercentage

Percentage is rounded off, but never up to 100.

****************************************************************************/

UINT CalcPercentage(UINT cWins, UINT cLosses)
{
    UINT    wPct = 0;
    UINT    lDenom;         // denominator

    lDenom = cWins + cLosses;

    if (lDenom != 0L)
        wPct = (((cWins * 200) + lDenom) / (2 * lDenom));

    if (wPct >= 100 && cLosses != 0)
        wPct = 99;

    return wPct;
}


/****************************************************************************

GetHelpFileName()

Puts the full path name of the helpfile in bigbuf
side effect: contents of bigbuf are altered

****************************************************************************/

CHAR *GetHelpFileName()
{
    CHAR    *psz;               // used to construct pathname

    psz = bighelpbuf + GetModuleFileNameA(hInst, bighelpbuf, BIG-1);

    if (psz - bighelpbuf > 4)
    {
        while (*psz != '.')
            --psz;
    }

    strcpy(psz, ".chm");
       
    return bighelpbuf;
}


/****************************************************************************

Options Dlg

****************************************************************************/

INT_PTR OptionsDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND    hMessages;          // handle to messages checkbox
    HWND    hQuick;             // quick checkbox
    HWND    hDblClick;          // double click checkbox


    // For context sensitive help
    static DWORD aIds[] = {     
        IDC_MESSAGES,       IDH_OPTIONS_MESSAGES,     
        IDC_QUICK,          IDH_OPTIONS_QUICK,     
        IDC_DBLCLICK,       IDH_OPTIONS_DBLCLICK,         
        0,0 }; 


    switch (message) {
        case WM_INITDIALOG:
            CentreDialog(hDlg);
            hMessages = GetDlgItem(hDlg, IDC_MESSAGES);
            SendMessage(hMessages, BM_SETCHECK, bMessages, 0);

            hQuick = GetDlgItem(hDlg, IDC_QUICK);
            SendMessage(hQuick, BM_SETCHECK, bFastMode, 0);

            hDblClick = GetDlgItem(hDlg, IDC_DBLCLICK);
            SendMessage(hDblClick, BM_SETCHECK, bDblClick, 0);

            return TRUE;

        case WM_COMMAND:
            switch (wParam) {
                case IDYES:
                case IDOK:
                    hMessages = GetDlgItem(hDlg, IDC_MESSAGES);
                    bMessages = (BOOL)SendMessage(hMessages, BM_GETCHECK, 0, 0);

                    hQuick = GetDlgItem(hDlg, IDC_QUICK);
                    bFastMode = (BOOL)SendMessage(hQuick, BM_GETCHECK, 0, 0);

                    hDblClick = GetDlgItem(hDlg, IDC_DBLCLICK);
                    bDblClick = (BOOL)SendMessage(hDblClick, BM_GETCHECK, 0, 0);

                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDNO:
                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }
            break;

        // context sensitive help.
        case WM_HELP: 
            WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("freecell.hlp"), 
            HELP_WM_HELP, (ULONG_PTR) aIds);         
            break;  

        case WM_CONTEXTMENU: 
            WinHelp((HWND) wParam, TEXT("freecell.hlp"), HELP_CONTEXTMENU, 
            (ULONG_PTR) aIds);         
            break;   

    }
    return FALSE;
}



/****************************************************************************

ReadOptions and WriteOptions retrieve and update .ini file

****************************************************************************/

VOID ReadOptions()
{
    LONG lRegResult = REGOPEN

    if (ERROR_SUCCESS == lRegResult)
    {
        bMessages = GetInt(pszMessages, TRUE);
        bFastMode = GetInt(pszQuick, FALSE);
        bDblClick = GetInt(pszDblClick, TRUE);
        REGCLOSE
    }
}


VOID WriteOptions()
{
    LONG lRegResult = REGOPEN

    if (ERROR_SUCCESS == lRegResult)
    {
        if (bMessages)
            DeleteValue(pszMessages);
        else
            SetInt(pszMessages, 0);

        if (bFastMode)
            SetInt(pszQuick, 1);
        else
            DeleteValue(pszQuick);

        if (bDblClick)
            DeleteValue(pszDblClick);
        else
            SetInt(pszDblClick, 0);

        RegFlushKey(hkey);

        REGCLOSE
    }
}


/****************************************************************************

Registry helper functions

These all assume that REGOPEN has been called first.
Remember to REGCLOSE when you're done.
DeleteValue is implemented as a macro.

****************************************************************************/

int GetInt(const TCHAR *pszValue, int nDefault)
{
    DWORD       dwType = REG_BINARY;
    DWORD       dwSize = sizeof(LONG_PTR);
    LONG_PTR    dwNumber, ret;

    if (!hkey)
	return nDefault;

    ret = RegQueryValueEx(hkey, pszValue, 0, &dwType, (LPBYTE)&dwNumber,
                &dwSize);

    if (ret)
        return nDefault;

    return (int)dwNumber;
}

long SetInt(const TCHAR *pszValue, int n)
{
    long dwNumber = (long)n;
    if (hkey)
    	return RegSetValueEx(hkey, pszValue, 0, REG_BINARY,
                (unsigned char *)&dwNumber, sizeof(dwNumber));
    else
	return 1;
}


/****************************************************************************

CentreDialog

****************************************************************************/
void CentreDialog(HWND hDlg)
{
    RECT rcDlg, rcMainWnd, rcOffset;

    GetClientRect(hMainWnd, &rcMainWnd);
    GetClientRect(hDlg, &rcDlg);
    GetWindowRect(hMainWnd, &rcOffset);
    rcOffset.top += GetSystemMetrics(SM_CYCAPTION);
    rcOffset.top += GetSystemMetrics(SM_CYMENU);

    SetWindowPos(hDlg, 0,
        ((rcMainWnd.right - rcDlg.right) / 2) + rcOffset.left,
        ((rcMainWnd.bottom - rcDlg.bottom) / 2) + rcOffset.top,
        0, 0, SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\carddll\std.h ===
#include <memory.h>


typedef INT X;
typedef INT Y;
typedef INT DX;
typedef INT DY;


#define fTrue	1
#define fFalse 0

// PoinT structure 
typedef struct _pt
	{
	X x;
	Y y;
	} PT;



// DEL structure
typedef struct _del
	{
	DX dx;
	DY dy;
	} DEL;


// ReCt structure 
typedef struct _rc
	{
	X xLeft;
	Y yTop;
	X xRight;
	Y yBot;
	} RC;


#ifdef DEBUG
#define VSZASSERT static char *vszAssert = __FILE__;
#define Assert(f) { if (!(f)) { AssertFailed(vszAssert, __LINE__); } } 
#define SideAssert(f) { if (!(f)) { AssertFailed(vszAssert, __LINE__); } } 
#else
#define Assert(f)
#define SideAssert(f) (f)
#define VSZASSERT
#endif



VOID *PAlloc(INT cb);
VOID FreeP();

INT CchString();
CHAR *PszCopy(CHAR *pszFrom, CHAR *rgchTo);
INT CchSzLen(CHAR *sz);
INT CchLpszLen(CHAR FAR *lpsz);
INT CchDecodeInt(CHAR *rgch, INT w);
VOID Error(CHAR *sz);
VOID ErrorIds(INT ids);
INT WMin(INT w1, INT w2);
INT WMax(INT w1, INT w2);
INT WParseLpch(CHAR FAR **plpch);
BOOL FInRange(INT w, INT wFirst, INT wLast);
INT PegRange(INT w, INT wFirst, INT wLast);
VOID NYI();
INT CchString(CHAR *sz, INT ids);
VOID InvertRc(RC *prc);
VOID OffsetPt(PT *ppt, DEL *pdel, PT *pptDest);
BOOL FRectAllVisible(HDC hdc, RC *prc);



#ifdef DEBUG
VOID AssertFailed(CHAR *szFile, INT li);
#endif

#define bltb(pb1, pb2, cb) memcpy(pb2, pb1, cb)
/*
short  APIENTRY MulDiv(short, short, short);
*/


extern HWND hwndApp;
extern HANDLE hinstApp;



BOOL FWriteIniString(INT idsTopic, INT idsItem, CHAR *szValue);
BOOL FWriteIniInt(INT idsTopic, INT idsItem, INT w);
BOOL FGetIniString(INT idsTopic, INT idsItem, CHAR *sz, CHAR *szDefault, INT cchMax);
INT GetIniInt(INT idsTopic, INT idsItem, INT wDefault);



VOID CrdRcFromPt(PT *ppt, RC *prc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\freecell\display.c ===
/****************************************************************************

Display.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32


Contains routines dealing with pixels and card shuffling.

****************************************************************************/

#include "freecell.h"
#include "freecons.h"
#include <assert.h>
#include <stdlib.h>                     // rand() prototype
#include <time.h>

// This static data has to do with positions of the cards on the screen.
// See CalcOffsets() below for descriptions.  Note that wOffset[TOPROW]
// is the left edge of the leftmose home cell.

static UINT wOffset[MAXCOL];        // left edge of column n (n from 1 to 8)
static UINT wIconOffset;            // left edge of icon (btwn home & free)
static UINT wVSpace;                // vert space between home and columns
static UINT wUpdateCol, wUpdatePos; // card user chose to transfer FROM
static BOOL bCardRevealed;          // right mouse button show a card?

#define BGND    (255)               // used for cdtDrawExt
#define ICONY   ((dyCrd - ICONHEIGHT) / 3)


/****************************************************************************

CalcOffsets

This function determines the locations where cards are drawn.

****************************************************************************/

VOID CalcOffsets(HWND hWnd)
{
    RECT rect;
    UINT i;
    UINT leftedge;
    BOOL bEGAmode = FALSE;

    if (GetSystemMetrics(SM_CYSCREEN) <= 350)   // EGA
        bEGAmode = TRUE;

    GetClientRect(hWnd, &rect);

    wOffset[TOPROW] = rect.right - (4 * dxCrd);         // home cells

    leftedge = (rect.right - ((MAXCOL-1) * dxCrd)) / MAXCOL;
    for (i = 1; i < MAXCOL; i++)
        wOffset[i] = leftedge + (((i-1) * (rect.right-leftedge)) / (MAXCOL-1));

    /* place icon half way between free cells and home cells */

    wIconOffset = (rect.right-ICONWIDTH) / 2;

    if (bEGAmode)
        wVSpace = 4;
    else
        wVSpace = 10;

    /* dyTops is the vertical space between stacked cards.  To fit the
       theoretical maximum, the formula is dyTops = (dyCrd * 9) / 50.
       A compromise is used to make the cards easier to see.  It is possible,
       therefore, that some stacks could get long enough for the bottom
       cards no to be visible.  The situation for EGA is worse, as cards
       are both closer together, and more likely to fall off the bottom.
       An alternative is to squish the bitmaps dyCrd = (35 * dyCrd) / 48. */

    dyTops = (dyCrd * 9) / 46;      // space between tops of cards in columns

    if (bEGAmode)
        dyTops = (dyTops * 4) / 5;
}


/****************************************************************************

ShuffleDeck

If seed is non-zero, that number is used as rand() seed to shuffle
deck.  Otherwise, a seed is generated and presented to the user who
may change it in a dialog box.

****************************************************************************/

VOID ShuffleDeck(HWND hWnd, UINT_PTR seed)
{
    UINT i, j;                      // generic counters
    UINT col, pos;
    UINT wLeft = 52;                // cards left to be chosen in shuffle
    CARD deck[52];                  // deck of 52 unique cards

    if (seed == 0)                // if user must select seed
    {
        gamenumber = GenerateRandomGameNum();

         /* Keep calling GameNumDlg until valid number chosen. */

        while (!DialogBox(hInst, TEXT("GameNum"), hWnd, GameNumDlg))
        {
        }

        if (gamenumber == CANCELGAME)       // if user chose CANCEL button
            return;
    }
    else
    {
        gamenumber = (INT) seed;
    }

    LoadString(hInst, IDS_APPNAME2, bigbuf, BIG);
    wsprintf(smallbuf, bigbuf, gamenumber);
    SetWindowText(hWnd, smallbuf);

    for (col = 0; col < MAXCOL; col++)          // clear the deck
    {
        for (pos = 0; pos < MAXPOS; pos++)
        {
            card[col][pos] = EMPTY;
        }
    }

    /* shuffle cards */

    for (i = 0; i < 52; i++)            // put unique card in each deck loc.
    {
        deck[i] = i;
    }

    if (gamenumber == -1)               // special unwinnable shuffle
    {
        i = 0;

        for (pos = 0; pos < 7; pos++)
        {
            for (col = 1; col < 5; col++)
            {
                card[col][pos] = i++;
            }

            i+= 4;
        }

        for (pos = 0; pos < 6; pos++)
        {
            i -= 12;

            for (col = 5; col < 9; col++)
            {
                card[col][pos] = i++;
            }
        }
    }
    else if (gamenumber == -2)
    {
        i = 3;

        for (col = 1; col < 5; col++)
        {
            card[col][0] = i--;
        }

        i = 51;

        for (pos = 1; pos < 7; pos++)
        {
            for (col = 1; col < 5; col++)
            {
                card[col][pos] = i--;
            }
        }

        for (pos = 0; pos < 6; pos++)
        {
            for (col = 5; col < 9; col++)
            {
                card[col][pos] = i--;
            }
        }
    }
    else
    {

        //
        // Caution:
        //	This shuffle algorithm has been published to people all around. The intention
        //	was to let people track the games by game numbers. So far all the games between
        //	1 and 32767 except one have been proved to have a winning solution. Do not change
        //	the shuffling algorithm else you will incur the wrath of people who have invested
        //	a huge amount of time solving these games.
        //	

        //	The game number can now be upto a million as the srand takes an integer but the
        //	the random value generated by rand() is only from 0 to 32767.
        //

        srand(gamenumber);
        for (i = 0; i < 52; i++)
        {
            j = rand() % wLeft;
            wLeft --;
            card[(i%8)+1][i/8] = deck[j];
            deck[j] = deck[wLeft];
        }
    }
}


/****************************************************************************

PaintMainWindow

This function is called in response to WM_PAINT.

****************************************************************************/

VOID PaintMainWindow(HWND hWnd)
{
    PAINTSTRUCT ps;
    UINT    col, pos;
    UINT    y;              // y location of icon
    CARD    c;
    INT     mode;           // mode to draw card (FACEUP or HILITE)
    HCURSOR hCursor;        // original cursor
    HPEN    hOldPen;

    BeginPaint(hWnd, &ps);

    /* Draw icon with 3D box around it. */

    y = ICONY;

    hOldPen = SelectObject(ps.hdc, hBrightPen);
    MoveToEx(ps.hdc, wIconOffset-3, y + ICONHEIGHT + 1, NULL);
    LineTo(ps.hdc, wIconOffset-3, y-3);
    LineTo(ps.hdc, wIconOffset+ICONWIDTH + 2, y-3);

    SelectObject(ps.hdc, GetStockObject(BLACK_PEN));
    MoveToEx(ps.hdc, wIconOffset + ICONWIDTH + 2, y-2, NULL);
    LineTo(ps.hdc, wIconOffset + ICONWIDTH + 2, y + ICONHEIGHT + 2);
    LineTo(ps.hdc, wIconOffset - 3, y + ICONHEIGHT + 2);

    DrawKing(ps.hdc, SAME, TRUE);

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    /* Top row first */

    for (pos = 0; pos < 8; pos++)
    {
        mode = FACEUP;
        if ((c = card[TOPROW][pos]) == EMPTY)
            c = IDGHOST;
        else if (wMouseMode == TO && pos == wFromPos && TOPROW == wFromCol)
            mode = HILITE;

        DrawCard(ps.hdc, TOPROW, pos, c, mode);
    }

    /* Then, the 8 columns */

    for (col = 1; col < MAXCOL; col++)
    {
        for (pos = 0; pos < MAXPOS; pos++)
        {
            if ((c = card[col][pos]) == EMPTY)
                break;

            if (wMouseMode == TO && pos == wFromPos && col == wFromCol)
                mode = HILITE;
            else
                mode = FACEUP;

            DrawCard(ps.hdc, col, pos, c, mode);
        }
    }

    if (bWonState)
        Payoff(ps.hdc);

    ShowCursor(FALSE);
    SetCursor(hCursor);
    SelectObject(ps.hdc, hOldPen);
    EndPaint(hWnd, &ps);
    DisplayCardCount(hWnd);
}


/****************************************************************************

DrawCard

This function takes a card value and position (in col and pos),
converts it to x and y, and displays it in the specified mode.

****************************************************************************/

VOID DrawCard(HDC hDC, UINT col, UINT pos, CARD card, INT mode)
{
    UINT    x, y;
    HDC     hMemDC;
    HBITMAP hOldBitmap;

    Card2Point(col, pos, &x, &y);
    if (card == IDGHOST && hBM_Ghost)
    {
        hMemDC = CreateCompatibleDC(hDC);
        if (hMemDC)
        {
            hOldBitmap = SelectObject(hMemDC, hBM_Ghost);
            BitBlt(hDC, x, y, dxCrd, dyCrd, hMemDC, 0, 0, SRCCOPY);
            SelectObject(hMemDC, hOldBitmap);
            DeleteDC(hMemDC);
        }
    }
    else
        cdtDrawExt(hDC, x, y, dxCrd, dyCrd, card, mode, BGND);
}

VOID DrawCardMem(HDC hMemDC, CARD card, INT mode)
{
    cdtDrawExt(hMemDC, 0, 0-dyTops, dxCrd, dyCrd, card, mode, BGND);
}


/****************************************************************************

RevealCard

When the user chooses a hidden card by clicking the right mouse button,
this function displays the entire card bitmap.

****************************************************************************/

VOID RevealCard(HWND hWnd, UINT x, UINT y)
{
    UINT col, pos;
    HDC  hDC;

    bCardRevealed = FALSE;              // no card revealed yet
    if (Point2Card(x, y, &col, &pos))
    {
        wUpdateCol = col;               // save for RestoreColumn()
        wUpdatePos = pos;
    }
    else
        return;                         // not a card

    if (col == 0 || pos == (MAXPOS-1))
        return;

    if (card[col][pos+1] == EMPTY)
        return;

    hDC = GetDC(hWnd);
    DrawCard(hDC, col, pos, card[col][pos], FACEUP);
    ReleaseDC(hWnd, hDC);
    bCardRevealed = TRUE;               // ok, card has been revealed
}


/****************************************************************************

RestoreColumn

After RevealCard has messed up a column by revealing a hidden card,
this routine patches it up again by redisplaying all the cards from
the revealed card down to the bottom of the column.  If the bottom card
is selected for a move, it is correctly shown hilighted.

****************************************************************************/

VOID RestoreColumn(HWND hWnd)
{
    HDC     hDC;
    UINT    pos;
    UINT    lastpos = EMPTY;    // last pos in column (for HILITE mode)
    INT     mode;               // HILITE or FACEUP

    if (!bCardRevealed)
        return;

    if (wMouseMode == TO)
        lastpos = FindLastPos(wUpdateCol);

    hDC = GetDC(hWnd);
    mode = FACEUP;
    for (pos = (wUpdatePos + 1); pos < MAXPOS; pos++)
    {
        if (card[wUpdateCol][pos] == EMPTY)
            break;

        if (wMouseMode == TO && pos == lastpos && wUpdateCol == wFromCol)
            mode = HILITE;

        DrawCard(hDC, wUpdateCol, pos, card[wUpdateCol][pos], mode);
    }
    ReleaseDC(hWnd, hDC);
}


/****************************************************************************

Point2Card

Given an x,y location (typically a mouse click) this function returns
the column and position of that card through pointers.  The function
return value is TRUE if it found a card, and FALSE otherwise.

****************************************************************************/

BOOL Point2Card(UINT x, UINT y, UINT *col, UINT *pos)
{
    if (y < dyCrd)                          // TOPROW
    {
        if (x < (UINT) (4 * dxCrd))         // free cells
        {
            *col = TOPROW;
            *pos = x / dxCrd;
            return TRUE;
        }
        else if (x < wOffset[TOPROW])       // between free cells & home cells
            return FALSE;

        x -= wOffset[TOPROW];
        if (x < (UINT) (4 * dxCrd))         // home cells
        {
            *col = TOPROW;
            *pos = (x / dxCrd) + 4;
            return TRUE;
        }
        else                                // right of home cells
            return FALSE;
    }

    if (y < (dyCrd + wVSpace))              // above column cards
        return FALSE;

    if (x < wOffset[1])                     // left of column 1
        return FALSE;

    *col = (x - wOffset[1]) / (wOffset[2] - wOffset[1]);
    (*col)++;

    if (x > (wOffset[*col] + dxCrd))
        return FALSE;               // between columns

    y -= (dyCrd + wVSpace);

    *pos = min((y / dyTops), MAXPOS);

    if (card[*col][0] == EMPTY)
        return FALSE;               // empty column

    if (*pos < (MAXPOS-1))
    {
        if (card[*col][(*pos)+1] != EMPTY)  // if partially hidden card...
            return TRUE;                    // we're done
    }

    while (card[*col][*pos] == EMPTY)
        (*pos)--;

    if (y > ((*pos * dyTops) + dyCrd))
        return FALSE;                       // below last card in column
    else
        return TRUE;
}


/****************************************************************************

Card2Point

Given a column and position, this function returns the x and y pixel
location of the upper left hand corner of the card.

****************************************************************************/

VOID Card2Point(UINT col, UINT pos, UINT *x, UINT *y)
{
    assert(col <= MAXCOL);
    assert(pos <= MAXPOS);

    if (col == TOPROW)      // column 0 is really the top row of 8 slots
    {
        *y = 0;
        *x = pos * dxCrd;
        if (pos > 3)
            *x += wOffset[TOPROW] - (4 * dxCrd);
    }
    else
    {
        *x = wOffset[col];
        *y = dyCrd + wVSpace + (pos * dyTops);
    }
}


/****************************************************************************

DisplayCardCount

This function displays wCardCount (the number of cards not in home cells)
at the right edge of the menu bar.  If necessary, the old value is erased.

****************************************************************************/

VOID DisplayCardCount(HWND hWnd)
{
    RECT rect;                          // client rect
    HDC  hDC;
    TCHAR buffer[25];                   // current value in ASCII stored here
    TCHAR oldbuffer[25];                // previous value in ASCII
    UINT xLoc;                          // x pixel loction for count
    UINT wCount;                        // temp wCardCount holder
    static UINT yLoc = 0;               // y pixel location for count
    static UINT wOldCount = 0;          // previous count value
    HFONT hOldFont = NULL;
    SIZE  size;


    if (IsIconic(hWnd))                 // don't draw on icon!
        return;

    hDC = GetWindowDC(hWnd);                // get DC for entire window
    if (!hDC)
        return;

    SetBkColor(hDC, GetSysColor(COLOR_MENU));

     if (hMenuFont)
        hOldFont = SelectObject(hDC, hMenuFont);

    wCount = wCardCount;
    if (wCount == 0xFFFF)                   // decremented past 0?
        wCount = 0;

    LoadString(hInst, IDS_CARDSLEFT, smallbuf, SMALL);
    wsprintf(buffer, smallbuf, wCount);

    if (yLoc == 0)                          // needs to be set only once
    {
        TEXTMETRIC  tm;
        int         offset;

        GetTextMetrics(hDC, &tm);
        offset = (GetSystemMetrics(SM_CYMENU) - tm.tmHeight) / 2;

        yLoc = GetSystemMetrics(SM_CYFRAME)         // sizing frame
         + GetSystemMetrics(SM_CYCAPTION)           // height of caption
         + offset;
    }

    GetClientRect(hWnd, &rect);
    GetTextExtentPoint32(hDC, buffer, lstrlen(buffer), &size);
    xLoc = rect.right - size.cx;

    if (xLoc > xOldLoc)                     // need to erase old score?
    {
        SetTextColor(hDC, GetSysColor(COLOR_MENU));     // background colour
        wsprintf(oldbuffer, smallbuf, wOldCount);
        TextOut(hDC, xOldLoc, yLoc, oldbuffer, lstrlen(buffer));
    }
    SetTextColor(hDC, GetSysColor(COLOR_MENUTEXT));
    TextOut(hDC, xLoc, yLoc, buffer, lstrlen(buffer));

    xOldLoc = xLoc;
    wOldCount = wCount;

    if (hMenuFont)
        SelectObject(hDC, hOldFont);

    ReleaseDC(hWnd, hDC);
}


/****************************************************************************

Payoff

Draws the Big King when you win the game.

****************************************************************************/

VOID Payoff(HDC hDC)
{
    HDC     hMemDC;             // bitmap memory DC
    HBITMAP hBitmap;
    HBITMAP hOldBitmap;
    INT     xStretch = 320;     // stretched size of bitmap
    INT     yStretch = 320;

    if (GetSystemMetrics(SM_CYSCREEN) <= 350)   // EGA
    {
        xStretch = 32 * 8;
        yStretch = 32 * 6;
    }

    DrawKing(hDC, NONE, TRUE);

    hMemDC = CreateCompatibleDC(hDC);
    if (!hMemDC)
        return;

    hBitmap = LoadBitmap(hInst, TEXT("KingSmile"));

    if (hBitmap)
    {
        hOldBitmap = SelectObject(hMemDC, hBitmap);
        StretchBlt(hDC, 10, dyCrd + 10, xStretch, yStretch, hMemDC, 0, 0,
                   BMWIDTH, BMHEIGHT, SRCCOPY);
        SelectObject(hMemDC, hOldBitmap);
        DeleteObject(hBitmap);
    }
    DeleteDC(hMemDC);
}


/****************************************************************************

DrawKing

Draws the small king in the box between the free and home cells.
If state is SAME, the previous bitmap is displayed.  If bDraw is
FALSE, oldstate is updated, but the bitmap is not displayed.

****************************************************************************/

VOID DrawKing(HDC hDC, UINT state, BOOL bDraw)
{
    HDC     hMemDC;                     // bitmap memory DC
    HBITMAP hBitmap;
    HBITMAP hOldBitmap;
    static  UINT oldstate = RIGHT;      // previous state -- RIGHT is default
    HBRUSH  hOldBrush;

    if (state == oldstate)
        return;

    if (state == SAME)
        state = oldstate;

    if (!bDraw)
    {
        oldstate = state;
        return;
    }

    hMemDC = CreateCompatibleDC(hDC);
    if (!hMemDC)
        return;

    if (state == RIGHT)
        hBitmap = LoadBitmap(hInst, TEXT("KingBitmap"));
    else if (state == LEFT)
        hBitmap = LoadBitmap(hInst, TEXT("KingLeft"));
    else if (state == SMILE)
        hBitmap = LoadBitmap(hInst, TEXT("KingSmile"));
    else        // NONE
        hBitmap = CreateCompatibleBitmap(hDC, BMWIDTH, BMHEIGHT);

    if (hBitmap)
    {
        hOldBitmap = SelectObject(hMemDC, hBitmap);
        if (state == NONE)
        {
            hOldBrush = SelectObject(hMemDC, hBgndBrush);
            PatBlt(hMemDC, 0, 0, BMWIDTH, BMHEIGHT, PATCOPY);
            SelectObject(hMemDC, hOldBrush);
        }
        BitBlt(hDC,wIconOffset,ICONY,BMWIDTH,BMHEIGHT,hMemDC,0,0,SRCCOPY);
        SelectObject(hMemDC, hOldBitmap);
        DeleteObject(hBitmap);
    }
    DeleteDC(hMemDC);
    oldstate = state;
}


/****************************************************************************

GenerateRandomGameNum

returns a UINT from 1 to MAXGAMENUBMER

****************************************************************************/


UINT GenerateRandomGameNum()
{
    UINT wGameNum;

    srand((unsigned int)time(NULL));
    rand();
    rand();
    wGameNum = rand();
    while (wGameNum < 1 || wGameNum > MAXGAMENUMBER)
        wGameNum = rand();
    return wGameNum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\freecell\game.c ===
/****************************************************************************

Game.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32


Routines for playing the game are here and in game2.c

****************************************************************************/


#include "freecell.h"
#include "freecons.h"
#include <assert.h>
#include <memory.h>


/****************************************************************************

SetFromLoc

User clicks to select card to transfer FROM.

****************************************************************************/

VOID SetFromLoc(HWND hWnd, UINT x, UINT y)
{
    HDC  hDC;
    UINT col, pos;

    wFromCol = EMPTY;                       // assume we didn't find a card
    wFromPos = EMPTY;

    cUndo = 0;
    EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_GRAYED);

    if (Point2Card(x, y, &col, &pos))
    {

        if (col == TOPROW)
        {
            if (card[TOPROW][pos] == EMPTY || pos > 3)
                return;
        }
        else
        {
            pos = FindLastPos(col);
            if (pos == EMPTY)               // empty column
                return;
        }
    }
    else
        return;

    wFromCol = col;                     // ok, we have a card
    wFromPos = pos;
    wMouseMode = TO;
    hDC = GetDC(hWnd);
    DrawCard(hDC, col, pos, card[col][pos], HILITE);
    if (col == TOPROW && pos < 4)
        DrawKing(hDC, LEFT, TRUE);
    ReleaseDC(hWnd, hDC);
}


/****************************************************************************

ProcessMoveRequest

After user has selected a FROM card with SetFromLoc() above, he then
chooses a TO location with the mouse which this function processes.

Note that the layout of the cards (the card array) is copied into
an array called shadow.  This is so queued move requests can be determined
before we commit to moving the cards.

****************************************************************************/

VOID ProcessMoveRequest(HWND hWnd, UINT x, UINT y)
{
    UINT tcol, tpos;        // location to move selected card TO
    UINT freecells;         // number of free cells unoccupied
    UINT trans;             // number of cards requested transfer requires
    UINT maxtrans;          // MaxTransfer() number
    INT  i;                 // index
    TCHAR buffer[160];      // extra buffer needed for MessageBox

    assert(wFromCol != EMPTY);

    /* Make copy of card[][] in shadow[][] */

    memcpy(&(shadow[0][0]), &(card[0][0]), sizeof(card));

    Point2Card(x, y, &tcol, &tpos);     // determine requested TO loc.

    if (tcol >= MAXCOL)                 // if illegal move selected...
    {
        tpos = wFromPos;                // cancel it.
        tcol = wFromCol;
    }

    if (tcol == TOPROW)                 // if moving to top row
    {
        if (tpos > 7)                   // illegal move...
        {
            tpos = wFromPos;            // so cancel it.
            tcol = wFromCol;
        }
    }
    else                                // if moving to a column...
    {
        tpos = FindLastPos(tcol);       // find end of column
        if (tpos == EMPTY)              // if column is empty...
            tpos = 0;                   // move to top of column.
    }

    /* if moving between non-empty columns */

    if (wFromCol != TOPROW && tcol != TOPROW && card[tcol][0] != EMPTY)
    {
        freecells = 0;                          // count free freecells
        for (i = 0; i < 4; i++)
            if (card[TOPROW][i] == EMPTY)
                freecells++;

        trans = NumberToTransfer(wFromCol, tcol);   // how many required?
        DEBUGMSG(TEXT("trans is %u  "), trans);
        DEBUGMSG(TEXT("and MaxTransfer() is %u\r\n"), MaxTransfer());

        if (trans > 0)                              // legal move?
        {
            maxtrans = MaxTransfer();
            if (trans <= maxtrans)                  // enough free cells?
            {
                MultiMove(wFromCol, tcol);
            }
            else if (bMessages)
            {
                LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                LoadString(hInst, IDS_TOOFEWFREE, buffer, sizeof(buffer)/sizeof(TCHAR));
                wsprintf(bigbuf, buffer, trans, maxtrans);
                MessageBeep(MB_ICONINFORMATION);
                MessageBox(hWnd, bigbuf, smallbuf, MB_ICONINFORMATION);

                /* illegal move, so deselect that card */

                QueueTransfer(wFromCol, wFromPos, wFromCol, wFromPos);
            }
            else
                return;
        }
        else
        {
            if (bMessages)
            {
                LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                LoadString(hInst, IDS_ILLEGAL, bigbuf, BIG);
                MessageBeep(MB_ICONINFORMATION);
                MessageBox(hWnd, bigbuf, smallbuf, MB_ICONINFORMATION);
                // deselect
                QueueTransfer(wFromCol, wFromPos, wFromCol, wFromPos);
            }
            else
                return;
        }
    }
    else        // else move involves TOPROW or move to empty column
    {
        bMoveCol = 0;
        if (IsValidMove(hWnd, tcol, tpos))
        {
            if (bMoveCol)                       // user selected move column?
                MoveCol(wFromCol, tcol);
            else
                QueueTransfer(wFromCol, wFromPos, tcol, tpos);
        }
        else
        {
            if (bMessages && (bMoveCol != -1))  // user did not select Cancel
            {
                LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                LoadString(hInst, IDS_ILLEGAL, bigbuf, BIG);
                MessageBeep(MB_ICONINFORMATION);
                MessageBox(hWnd, bigbuf, smallbuf, MB_ICONINFORMATION);
                // deselect
                QueueTransfer(wFromCol, wFromPos, wFromCol, wFromPos);
            }
            else if (bMoveCol == -1)            // user selected cancel
            {
                // deselect
                QueueTransfer(wFromCol, wFromPos, wFromCol, wFromPos);
            }
            else
                return;
        }
    }

    Cleanup();              // queue transfers of unneeded cards
    MoveCards(hWnd);        // start transferring queued cards
    wMouseMode = FROM;      // next mouse click chooses FROM card
}


/****************************************************************************

ProcessDoubleClick

Double clicking on card in a column moves it to the first free cell found.
After finding the free cell, this routine is identical to ProcessMoveRequest.

****************************************************************************/

BOOL ProcessDoubleClick(HWND hWnd)
{
    UINT freecell = EMPTY;          // assume none found
    INT  i;                         // counter

    for (i = 3; i >= 0; i--)            // look for free cell;
        if (card[TOPROW][i] == EMPTY)
            freecell = (UINT) i;

    if (freecell == EMPTY)              // if none found
        return FALSE;

    memcpy(&(shadow[0][0]), &(card[0][0]), sizeof(card));

    wFromPos = FindLastPos(wFromCol);
    QueueTransfer(wFromCol, wFromPos, TOPROW, freecell);
    Cleanup();
    MoveCards(hWnd);
    wMouseMode = FROM;
    return TRUE;
}


/****************************************************************************

IsValidMove

This function determines if moving from wFromCol,wFromPos to tcol,tpos
is valid.  It can assume wFromCol and tcol are not both non-empty columns.
In other words, except for moves to empty columns, it is concerned with
moving only one card.

If the move is to an empty column, the user can select if he wants to move
one card or as much of the column as possible.

****************************************************************************/

BOOL IsValidMove(HWND hWnd, UINT tcol, UINT tpos)
{
    CARD    fcard, tcard;           // card values (0 to 51)
    UINT    trans;                  // num cards required for transfer
    UINT    freecells;              // num of unoccupied free cells
    UINT    pos;

    DEBUGMSG(TEXT("IVM: tpos is %d\r\n"), tpos);
    assert (tpos < MAXPOS);

    bMoveCol = FALSE;               // assume FALSE

    /* allow cancel move from top row. */

    if (wFromCol == TOPROW && tcol == TOPROW && wFromPos == tpos)
        return TRUE;

    fcard = card[wFromCol][wFromPos];
    tcard = card[tcol][tpos];

    /* transfer to empty column */

    if ((wFromCol != TOPROW) && (tcol != TOPROW) && (card[tcol][0] == EMPTY))
    {
        trans = NumberToTransfer(wFromCol, tcol);   // how many required?
        freecells = 0;
        for (pos = 0; pos < 4; pos++)               // count free cells
            if (card[TOPROW][pos] == EMPTY)
                freecells++;

        if (freecells == 0 && trans > 1)            // no freecells anyway
            trans = 1;

        if (trans == 0)                             // if no valid move
            return FALSE;
        else if (trans == 1)                        // if only 1 card can move
            return TRUE;

        /* If multiple cards can move, user must disambiguate request. */

        bMoveCol = (BOOL) DialogBox(hInst, TEXT("MoveCol"), hWnd, MoveColDlg);

        if (bMoveCol == -1)         // CANCEL chosen
            return FALSE;

        return TRUE;
    }

    if (tcol == TOPROW)
    {
        if (tpos < 4)               // free cells
        {
            if (tcard == EMPTY)
                return TRUE;
            else
                return FALSE;
        }
        else                        // home cells
        {
            if (VALUE(fcard) == ACE && tcard == EMPTY)      // ace on new pile
                return TRUE;

            else if (SUIT(fcard) == SUIT(tcard))            // same suit
            {
                if (VALUE(fcard) == (VALUE(tcard) + 1))     // next card
                    return TRUE;
                else
                    return FALSE;
            }
            return FALSE;
        }
    }
    else                                // tcol is not TOPROW
    {
        if (card[tcol][0] == EMPTY)     // top of empty column always ok
            return TRUE;

        return FitsUnder(fcard, tcard);
    }
}


/****************************************************************************

Cleanup

This function checks if exposed cards (cards in home cells or bottoms
of columns) are no longer needed (Useless.)

When it finds cards it doesn't need, it queues them for transfer.  It
keeps looking until an entire pass finds no new useless cards.

****************************************************************************/

VOID Cleanup()
{
    UINT    col, pos;
    UINT    i;                      // counter
    CARD    c;
    BOOL    bMore = TRUE;           // assume we need another pass

    while (bMore)
    {
        bMore = FALSE;

        for (pos = 0; pos < 4; pos++)       // do TOPROW first
        {
            c = card[TOPROW][pos];
            if (Useless(c))                 // if card is discardable
            {
                bMore = TRUE;                       // need another pass

                /* If this is the first card of this suit, we need to
                   determine which home cell it can use.  */

                if (homesuit[SUIT(c)] == EMPTY)
                {
                    i = 4;
                    while (card[TOPROW][i] != EMPTY)
                        i++;
                    homesuit[SUIT(c)] = i;
                }
                QueueTransfer(TOPROW, pos, TOPROW, homesuit[SUIT(c)]);
            }
        }

        for (col = 1; col <= 8; col++)          // do columns next
        {
            pos = FindLastPos(col);
            if (pos != EMPTY)
            {
                c = card[col][pos];
                if (Useless(c))
                {
                    bMore = TRUE;
                    if (homesuit[SUIT(c)] == EMPTY)
                    {
                        i = 4;
                        while (card[TOPROW][i] != EMPTY)
                            i++;
                        homesuit[SUIT(c)] = i;
                    }
                    QueueTransfer(col, pos, TOPROW, homesuit[SUIT(c)]);
                }
            }
        }
    }
}


/****************************************************************************

Useless

returns TRUE if a card can be safely discarded (no existing cards could
possibly play on it.)

Note that the lines identified with // *** are required in the 32 bit version
since EMPTY == 0xFFFF is not longer equal to -1 as was the case in 16 bit

****************************************************************************/

BOOL Useless(CARD c)
{
    CARD limit;                     // top home card of this suit

    if (c == EMPTY)
        return FALSE;               // no card to discard

    if (bCheating == CHEAT_WIN)
        return TRUE;

    if (VALUE(c) == ACE)
        return TRUE;                // ACEs can always be cleaned up

    else if (VALUE(c) == DEUCE)     // DEUCEs need only check if ACE is up
    {
        if (home[SUIT(c)] == ACE)
            return TRUE;
        else
            return FALSE;
    }
    else                            // else check both cards that can play on it
    {
        limit = VALUE(c) - 1;
        if (home[SUIT(c)] != limit) // is this the next card?
            return FALSE;

        if (COLOUR(c) == RED)
        {
            if (home[CLUB] == EMPTY || home[SPADE] == EMPTY)  // ***
                return FALSE;
            else
                return (home[CLUB] >= limit && home[SPADE] >= limit);
        }
        else
        {
            if (home[DIAMOND] == EMPTY || home[HEART] == EMPTY)   // ***
                return FALSE;
            else
                return (home[DIAMOND] >= limit && home[HEART] >= limit);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\freecell\freecons.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**        Copyright(c) Microsoft Corp., 1991, 1992, 1993                 **/
/***************************************************************************/

//  Defined constants for FreeCell

#define IDM_ABOUT       101
#define IDM_NEWGAME     102
#define IDM_SELECT      103
#define IDM_MOVECARD    104
#define IDM_STATS       105
#define IDM_HELP        106
#define IDM_RESTART     107
#define IDM_EXIT        108
#define IDM_OPTIONS     109
#define IDM_HOWTOPLAY   110
#define IDM_HELPONHELP  111
#define IDM_FAKETIMER   112
#define IDM_CHEAT       114
#define IDM_UNDO        115

#define IDC_MOVECOL     201
#define IDC_SINGLE      202
#define IDC_GAMENUM     203
#define IDC_YLSAME      205
#define IDC_STEXT       206
#define IDC_CLEAR       207
#define IDC_YWSELECT    208
#define IDC_MESSAGES    209
#define IDC_QUICK       210
#define IDC_DBLCLICK    211
#define IDC_STEXT1      212
#define IDC_STEXT2      213
#define IDC_STEXT3      214

#define IDS_APPNAME     301
#define IDS_CREDITS     302
#define IDS_APPNAME2    303
#define IDS_MEMORY      304
#define IDS_RESIGN      305
#define IDS_ILLEGAL     306
#define IDS_TOOFEWFREE  307
#define IDS_CARDSLEFT   308
#define IDS_RU_SURE     309
#define IDS_1WIN        310
#define IDS_1LOSS       311
#define IDS_WINS        312
#define IDS_LOSSES      313
#define IDS_HELP1       314
#define IDS_HELP2       315
#define IDS_STREAK      316
#define IDS_STYPE       317
#define IDS_FULLNAME    318
#define IDS_STATS1      319
#define IDS_STATS2      320
#define IDS_STATS3      321

#define DLG_MOVECOL     500
#define DLG_GAMENUM     501
#define DLG_YOULOSE     502
#define DLG_YOUWIN      503
#define DLG_STATS       504
#define DLG_OPTIONS     505

#define ID_ICON_MAIN    601


#define IDH_OPTIONS_MESSAGES  1001   
#define IDH_OPTIONS_QUICK     1002
#define IDH_OPTIONS_DBLCLICK  1003
#define IDH_GAMENUM           1004
#define IDH_CLEAR             1005
#define IDH_STEXT1            1006
#define IDH_STEXT2            1007
#define IDH_STEXT3            1008
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\freecell\freecell.h ===
/****************************************************************************

FREECELL.H

June 91, JimH     initial code
Oct  91, JimH     port to Win32


Main header file for Windows Free Cell.  Constants are in freecons.h

****************************************************************************/

#include <windows.h>
#include <port1632.h>

#define     WINHEIGHT     480
#define     WINWIDTH      640

#define     FACEUP          0               // card mode
#define     FACEDOWN        1
#define     HILITE          2
#define     GHOST           3
#define     REMOVE          4
#define     INVISIBLEGHOST  5
#define     DECKX           6
#define     DECKO           7

#define     EMPTY  0xFFFFFFFF
#define     IDGHOST        52               // eg, empty free cell

#define     MAXPOS         21
#define     MAXCOL          9               // includes top row as column 0

#define     MAXMOVELIST   150               // size of movelist array

#define     TOPROW          0               // column 0 is really the top row

#define     BLACK           0               // COLOUR(card)
#define     RED             1

#define     ACE             0               // VALUE(card)
#define     DEUCE           1

#define     CLUB            0               // SUIT(card)
#define     DIAMOND         1
#define     HEART           2
#define     SPADE           3

#define     FROM            0               // wMouseMode
#define     TO              1

#define     ICONWIDTH      32               // in pixels
#define     ICONHEIGHT     32

#define     BIG           128               // str buf sizes
#define     SMALL          32

#define     MAXGAMENUMBER   1000000
#define     CANCELGAME      (MAXGAMENUMBER + 1)

#define     NONE            0               // king bitmap identifiers
#define     SAME            1
#define     RIGHT           2
#define     LEFT            3
#define     SMILE           4

#define     BMWIDTH        32               // bitmap width
#define     BMHEIGHT       32               // bitmap height

#define     LOST            0               // used for streaks
#define     WON             1

#define     FLASH_TIMER     2               // timer id for main window flash
#define     FLASH_INTERVAL  400             // flash timer interval
#define     FLIP_TIMER      3               // timer id for flipping column
#define     FLIP_INTERVAL   300

#define     CHEAT_LOSE      1               // used with bCheating
#define     CHEAT_WIN       2


/* Macros */

#define     SUIT(card)      ((card) % 4)
#define     VALUE(card)     ((card) / 4)
#define     COLOUR(card)    (SUIT(card) == 1 || SUIT(card) == 2)

#define     REGOPEN         RegCreateKey(HKEY_CURRENT_USER, pszRegPath, &hkey);
#define     REGCLOSE        RegCloseKey(hkey);
#define     DeleteValue(v)  RegDeleteValue(hkey, v)


/* Types */

typedef INT     CARD;

typedef struct {                // movelist made up of these
      UINT  fcol;
      UINT  fpos;
      UINT  tcol;
      UINT  tpos;
   } MOVE;


/* Callback function prototypes */

// INT  PASCAL MMain(HANDLE, HANDLE, LPSTR, INT);
LRESULT APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);

INT_PTR  APIENTRY About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY GameNumDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY MoveColDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY StatsDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY YouLoseDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY YouWinDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY OptionsDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);


/* Functions imported from cards.dll */

BOOL  APIENTRY cdtInit(UINT FAR *pdxCard, UINT FAR *pdyCard);
BOOL  APIENTRY cdtDraw(HDC hdc, INT x, INT y, INT cd, INT mode, DWORD rgbBgnd);
BOOL  APIENTRY cdtDrawExt(HDC hdc, INT x, INT y, INT dx, INT dy, INT cd,
                           INT mode, DWORD rgbBgnd);
BOOL  APIENTRY cdtTerm(VOID);

/* Other function prototypes */

VOID CalcOffsets(HWND hWnd);
UINT CalcPercentage(UINT cWins, UINT cLosses);
VOID Card2Point(UINT col, UINT pos, UINT *x, UINT *y);
VOID Cleanup(VOID);
VOID CreateMenuFont(VOID);
VOID DisplayCardCount(HWND hWnd);
VOID DrawCard(HDC hDC, UINT col, UINT pos, CARD c, INT mode);
VOID DrawCardMem(HDC hMemDC, CARD c, INT mode);
VOID DrawKing(HDC hDC, UINT state, BOOL bDraw);
UINT FindLastPos(UINT col);
BOOL FitsUnder(CARD fcard, CARD tcard);
VOID Flash(HWND hWnd);
VOID Flip(HWND hWnd);
UINT GenerateRandomGameNum(VOID);
CHAR *GetHelpFileName(VOID);
INT  GetInt(CONST TCHAR *pszValue, INT nDefault);
VOID Glide(HWND hWnd, UINT fcol, UINT fpos, UINT tcol, UINT tpos);
VOID GlideStep(HDC hDC, UINT x1, UINT y1, UINT x2, UINT y2);
BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, INT nCmdShow);
VOID IsGameLost(HWND hWnd);
BOOL IsValidMove(HWND hWnd, UINT tcol, UINT tpos);
VOID KeyboardInput(HWND hWnd, UINT keycode);
UINT MaxTransfer(VOID);
UINT MaxTransfer2(UINT freecells, UINT freecols);
VOID MoveCards(HWND hWnd);
VOID MoveCol(UINT fcol, UINT tcol);
VOID MultiMove(UINT fcol, UINT tcol);
UINT NumberToTransfer(UINT fcol, UINT tcol);
VOID PaintMainWindow(HWND hWnd);
VOID Payoff(HDC hDC);
BOOL Point2Card(UINT x, UINT y, UINT *col, UINT *pos);
BOOL ProcessDoubleClick(HWND hWnd);
VOID ProcessMoveRequest(HWND hWnd, UINT x, UINT y);
VOID ProcessTimer(HWND hWnd);
VOID QueueTransfer(UINT fcol, UINT fpos, UINT tcol, UINT tpos);
VOID ReadOptions(VOID);
VOID RestoreColumn(HWND hWnd);
VOID RevealCard(HWND hWnd, UINT x, UINT y);
VOID SetCursorShape(HWND hWnd, UINT x, UINT y);
VOID SetFromLoc(HWND hWnd, UINT x, UINT y);
LONG SetInt(CONST TCHAR *pszValue, INT n);
VOID ShuffleDeck(HWND hWnd, UINT_PTR seed);
VOID StartMoving(HWND hWnd);
VOID Transfer(HWND hWnd, UINT fcol, UINT fpos, UINT tcol, UINT tpos);
VOID Undo(HWND hWnd);
VOID UpdateLossCount(VOID);
BOOL Useless(CARD c);
VOID WMCreate(HWND hWnd);
VOID WriteOptions(VOID);


/* Global variables */

TCHAR   bigbuf[BIG];            // general purpose LoadString() buffer
CHAR    bighelpbuf[BIG];        // general purpose char buffer.
BOOL    bCheating;              // hit magic key to win?
BOOL    bDblClick;              // honor double click?
BOOL    bFastMode;              // hidden option, don't do glides?
BOOL    bFlipping;              // currently flipping cards in a column?
BOOL    bGameInProgress;        // true if game is in progress
BOOL    bMessages;              // are "helpful" MessageBoxen shown?
BOOL    bMonochrome;            // 2 colour display?
BOOL    bMoveCol;               // did user request column move (or 1 card)?
BOOL    bSelecting;             // is user selecting game numbers?
BOOL    bWonState;              // TRUE if game won and new game not started
UINT    dxCrd, dyCrd;           // extents of card bitmaps in pixels
CARD    card[MAXCOL][MAXPOS];   // current layout of cards
INT     cFlashes;               // count of main window flashes remaining
UINT    cGames;                 // number of games played in current session
UINT    cLosses;                // number of losses in current session
UINT    cWins;                  // number of wins in current session
UINT    cMoves;                 // number of moves in this game
UINT    dyTops;                 // vert space between cards in columns
CARD    shadow[MAXCOL][MAXPOS]; // shadows card array for multi-moves & cleanup
INT     gamenumber;             // current game number (rand seed)
HBITMAP hBM_Ghost;              // bitmap for ghost (empty) free/home cells
HBITMAP hBM_Bgnd1;              // screen under source location
HBITMAP hBM_Bgnd2;              // screen under destination location
HBITMAP hBM_Fgnd;               // bitmap that moves across screen
HICON   hIconMain;              // the main freecell icon.
HKEY    hkey;                   // registry key
HPEN    hBrightPen;             // 3D highlight colour
HANDLE  hInst;                  // current instance
HWND    hMainWnd;               // hWnd for main window
HFONT   hMenuFont;              // for Cards Left display
CARD    home[4];                // card on top of home pile for this suit
CARD    homesuit[4];            // suit for each home pile
HBRUSH  hBgndBrush;             // green background brush
UINT_PTR idTimer;               // flash timer id
UINT    moveindex;              // index to end of movelist
MOVE    movelist[MAXMOVELIST];  // compacted list of pending moves for timer
INT     oldgamenumber;          // previous game (repeats don't count in score)
TCHAR   *pszIni;                // .ini filename
TCHAR   smallbuf[SMALL];        // generic small buffer for LoadString()
TCHAR   titlebuf[BIG];          // a buffer used to store the window title.
UINT    wCardCount;             // cards not yet in home cells (0 == win)
UINT    wFromCol;               // col user has selected to transfer from
UINT    wFromPos;               // pos "
UINT    wMouseMode;             // selecting place to transfer FROM or TO
UINT    xOldLoc;                // previous location of cards left text
INT     cUndo;                  // number of cards to undo

/* registry value names */

extern CONST TCHAR pszRegPath[];
extern CONST TCHAR pszWon[];
extern CONST TCHAR pszLost[];
extern CONST TCHAR pszWins[];
extern CONST TCHAR pszLosses[];
extern CONST TCHAR pszStreak[];
extern CONST TCHAR pszSType[];
extern CONST TCHAR pszMessages[];
extern CONST TCHAR pszQuick[];
extern CONST TCHAR pszDblClick[];
extern CONST TCHAR pszAlreadyPlayed[];


/* TRACE mechanism */

#if    0
TCHAR    szDebugBuffer[256];
#define DEBUGMSG(parm1,parm2)\
    { wsprintf(szDebugBuffer,parm1,parm2);\
     OutputDebugString(szDebugBuffer); }

#define  assert(p)   { if (!(p)) {wsprintf(szDebugBuffer, TEXT("assert: %s %d\r\n"),\
                      __FILE__, __LINE__); OutputDebugString(szDebugBuffer);}}

#else
#define DEBUGMSG(parm1,parm2)
#endif

#define SPY(parm1)              // not used in NT version
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\freecell\game2.c ===
/****************************************************************************

Game2.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32


Routines for playing the game are here and in game.c

****************************************************************************/

#include "freecell.h"
#include "freecons.h"
#include <assert.h>
#include <ctype.h>                  // for isdigit()


static HCURSOR  hFlipCursor;

/******************************************************************************

MaxTransfer

This function and the recursive MaxTransfer2 determine the maximum
number of cards that could be transfered given the current number
of free cells and empty columns.

******************************************************************************/

UINT MaxTransfer()
{
    UINT freecells = 0;
    UINT freecols  = 0;
    UINT col, pos;

    for (pos = 0; pos < 4; pos++)               // count free cells
        if (card[TOPROW][pos] == EMPTY)
            freecells++;

    for (col = 1; col <= 8; col++)              // count empty columns
        if (card[col][0] == EMPTY)
            freecols++;

    return MaxTransfer2(freecells, freecols);
}

UINT MaxTransfer2(UINT freecells, UINT freecols)
{
   if (freecols == 0)
      return(freecells + 1);
   return(freecells + 1 + MaxTransfer2(freecells, freecols-1));
}


/******************************************************************************

NumberToTransfer

Given a from column and a to column, this function returns the number of
cards required to do the transfer, or 0 if there is no legal move.

If the transfer is from a column to an empty column, this function returns
the maximum number of cards that could transfer.

******************************************************************************/

UINT NumberToTransfer(UINT fcol, UINT tcol)
{
    UINT fpos, tpos;
    CARD tcard;                         // card to transfer onto
    UINT number = 0;                    // the returned result

    assert(fcol > 0 && fcol < 9);
    assert(tcol > 0 && tcol < 9);
    assert(card[fcol][0] != EMPTY);

    if (fcol == tcol)
        return  1;                      // cancellation takes one move

    fpos = FindLastPos(fcol);

    if (card[tcol][0] == EMPTY)         // if transfer to empty column
    {
        while (fpos > 0)
        {
            if (!FitsUnder(card[fcol][fpos], card[fcol][fpos-1]))
                break;
            fpos--;
            number++;
        }
        return (number+1);
    }
    else
    {
        tpos = FindLastPos(tcol);
        tcard = card[tcol][tpos];
        for (;;)
        {
            number++;
            if (FitsUnder(card[fcol][fpos], tcard))
                return number;
            if (fpos == 0)
                return 0;
            if (!FitsUnder(card[fcol][fpos], card[fcol][fpos-1]))
                return 0;
            fpos--;
        }
    }
}


/******************************************************************************

FitsUnder

returns TRUE if fcard fits under tcard

******************************************************************************/

BOOL FitsUnder(CARD fcard, CARD tcard)
{
    if ((VALUE(tcard) - VALUE(fcard)) != 1)
        return FALSE;

    if (COLOUR(fcard) == COLOUR(tcard))
        return FALSE;

    return TRUE;
}



/******************************************************************************

IsGameLost

If there are legal moves remaining, the game is not lost and this function
returns without doing anything.

Otherwise, it pops up the YouLose dialog box.

******************************************************************************/

VOID IsGameLost(HWND hWnd)
{
    UINT    col, pos;
    UINT    fcol, tcol;
    CARD    lastcard[MAXCOL];       // array of cards at bottoms of columns
    CARD    c;
    UINT    cMoves = 0;             // count of legal moves remaining

    if (bCheating == CHEAT_LOSE)
        goto cheatloselabel;

    for (pos = 0; pos < 4; pos++)           // any free cells?
        if (card[TOPROW][pos] == EMPTY)
            return;

    for (col = 1; col < MAXCOL; col++)      // any free columns?
        if (card[col][0] == EMPTY)
            return;

    /* Do the bottom cards of any column fit in the home cells? */

    for (col = 1; col < MAXCOL; col++)
    {
        lastcard[col] = card[col][FindLastPos(col)];
        c = lastcard[col];
        if (VALUE(c) == ACE)
            cMoves++;
        if (home[SUIT(c)] == (VALUE(c) - 1))    // fits in home cell?
            cMoves++;
    }

    /* Do any of the cards in the free cells fit in the home cells? */

    for (pos = 0; pos < 4; pos++)
    {
        c = card[TOPROW][pos];
        if (home[SUIT(c)] == (VALUE(c) - 1))
            cMoves++;
    }

    /* Do any of the cards in the free cells fit under a column? */

    for (pos = 0; pos < 4; pos++)
        for (col = 1; col < MAXCOL; col++)
            if (FitsUnder(card[TOPROW][pos], lastcard[col]))
                cMoves++;

    /* Do any of the bottom cards fit under any other bottom card? */

    for (fcol = 1; fcol < MAXCOL; fcol++)
        for (tcol = 1; tcol < MAXCOL; tcol++)
            if (tcol != fcol)
                if (FitsUnder(lastcard[fcol], lastcard[tcol]))
                    cMoves++;

    if (cMoves > 0)
    {
        if (cMoves == 1)                    // one move left
        {
            cFlashes = 4;                   // flash this many times

            if (idTimer != 0)
                KillTimer(hWnd, FLASH_TIMER);

            idTimer = SetTimer(hWnd, FLASH_TIMER, FLASH_INTERVAL, NULL);
        }
        return;
    }

    /* We've tried everything.  There are no more legal moves. */

  cheatloselabel:
    cUndo = 0;
    EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_GRAYED);
    DialogBox(hInst, TEXT("YouLose"), hWnd, YouLoseDlg);
    gamenumber = 0;                         // cancel mouse activity
    bCheating = FALSE;
}


/****************************************************************************

FindLastPos

returns position of last card in column, or EMPTY if column is empty.

****************************************************************************/

UINT FindLastPos(UINT col)
{
    UINT pos = 0;

    if (col > 9)
        return EMPTY;

    while (card[col][pos] != EMPTY)
        pos++;
    pos--;

    return pos;
}



/******************************************************************************

UpdateLossCount

If game is lost, update statistics.

******************************************************************************/

VOID UpdateLossCount()
{
    int     cLifetimeLosses;        // includes .ini stats
    int     wStreak, wSType;        // streak length and type
    int     wLosses;                // record loss streak
    LONG    lRegResult;             // used to store return code from registry call

    // repeats and negative (unwinnable) games don't count

    if ((gamenumber > 0) && (gamenumber != oldgamenumber))
    {
        lRegResult = REGOPEN

        if (ERROR_SUCCESS == lRegResult)
        {
            cLifetimeLosses = GetInt(pszLost, 0);
            cLifetimeLosses++;
            cLosses++;
            cGames++;
            SetInt(pszLost, cLifetimeLosses);
            wSType = GetInt(pszSType, WON);
            if (wSType == WON)
            {
                SetInt(pszSType, LOST);
                wStreak = 1;
                SetInt(pszStreak, wStreak);
            }
            else
            {
                wStreak = GetInt(pszStreak, 0);
                wStreak++;
                SetInt(pszStreak, wStreak);
            }

            wLosses = GetInt(pszLosses, 0);
            if (wLosses < wStreak)  // if new record
            {
                wLosses = wStreak;
                SetInt(pszLosses, wLosses);
            }

            REGCLOSE
        }
    }
    oldgamenumber = gamenumber;
}


/******************************************************************************

KeyboardInput

Handles keyboard input from the main message loop.  Only digits are considered.
This function works by simulating mouse clicks for each digit pressed.

Note that when you have selected a card in a free cell, but you want to
select another card, you press '0' again.  This function sends (not posts,
sends so that bMessages can be turned off) a mouse click to deselect that
card, and then looks if there is another card in free cells to the right,
and if so, selects it.

******************************************************************************/

VOID KeyboardInput(HWND hWnd, UINT keycode)
{
    UINT    x, y;
    UINT    col = TOPROW;
    UINT    pos = 0;
    BOOL    bSave;              // save status of bMessages;
    CARD    c;

    if (!isdigit(keycode))
        return;

    switch (keycode) {

        case '0':                               // free cell
            if (wMouseMode == FROM)             // select a card to transfer
            {
                for (pos = 0; pos < 4; pos++)
                    if (card[TOPROW][pos] != EMPTY)
                        break;
                if (pos == 4)                   // no card to select
                    return;
            }
            else                                // transfer TO free cell
            {
                if (wFromCol == TOPROW)         // pick new free cell
                {
                    /* Turn off messages so deselection moves don't complain
                       if there is only one move left. */

                    bSave = bMessages;
                    bMessages = FALSE;

                    /* deselect current selection */

                    Card2Point(TOPROW, wFromPos, &x, &y);
                    SendMessage(hWnd, WM_LBUTTONDOWN, 0,
                                MAKELONG((WORD)x, (WORD)y));

                    /* find next non-empty free cell */

                    for (pos = wFromPos+1; pos < 4; pos++)
                    {
                        if (card[TOPROW][pos] != EMPTY)
                            break;
                    }

                    bMessages = bSave;
                    if (pos == 4)       // none found, so leave deselected
                        return;
                }
                else                    // transfer from a column, not TOPROW
                {
                    for (pos = 0; pos < 4; pos++)
                        if (card[TOPROW][pos] == EMPTY)
                            break;

                    if (pos == 4)       // no empty freecells
                        pos = 0;        // force an error message
                }
            }
            break;

        case '9':                           // home cell
            if (wMouseMode == FROM)         // can't move from home cell
                return;

            c = card[wFromCol][wFromPos];
            pos = homesuit[SUIT(c)];
            if (pos == EMPTY)               // no home suit so can't do anything
                pos = 4;                    // force error
            break;

        default:                            // columns 1 to 8
            col = keycode - '0';
            break;
    }

    if (col == wFromCol && wMouseMode == TO && col > 0 && col < 9 &&
        card[col][1] != EMPTY)
    {
        bFlipping = (BOOL) SetTimer(hWnd, FLIP_TIMER, FLIP_INTERVAL, NULL);
    }

    if (bFlipping)
    {
        hFlipCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        ShowCursor(TRUE);
        Flip(hWnd);         // do first card manually
    }
    else
    {
        Card2Point(col, pos, &x, &y);
        PostMessage(hWnd, WM_LBUTTONDOWN, 0,
                    MAKELONG((WORD)x, (WORD)y));
    }
}


/******************************************************************************

Flash

This function is called by the FLASH_TIMER to flash main window.

******************************************************************************/

VOID Flash(HWND hWnd)
{
    FlashWindow(hWnd, TRUE);
    cFlashes--;

    if (cFlashes <= 0)
    {
        FlashWindow(hWnd, FALSE);
        KillTimer(hWnd, FLASH_TIMER);
        idTimer = 0;
    }
}


/******************************************************************************

Flip

This function is called by the FLIP_TIMER to flip cards through in one
column.  It is used for keyboard players who want to reveal hidden cards.

******************************************************************************/

VOID Flip(HWND hWnd)
{
    HDC     hDC;
    UINT    x, y;
    static  UINT    pos = 0;

    hDC = GetDC(hWnd);
    DrawCard(hDC, wFromCol, pos, card[wFromCol][pos], FACEUP);
    pos++;
    if (card[wFromCol][pos] == EMPTY)
    {
        pos = 0;
        KillTimer(hWnd, FLIP_TIMER);
        bFlipping = FALSE;
        ShowCursor(FALSE);
        SetCursor(hFlipCursor);

        /* cancel move */

        Card2Point(wFromCol, pos, &x, &y);
        PostMessage(hWnd, WM_LBUTTONDOWN, 0,
                    MAKELONG((WORD)x, (WORD)y));
    }
    ReleaseDC(hWnd, hDC);
}


/******************************************************************************

Undo

Undo last move

******************************************************************************/

VOID Undo(HWND hWnd)
{
    int   i;

    if (cUndo == 0)
        return;

    SetCursor(LoadCursor(NULL, IDC_WAIT));  // set cursor to hourglass
    SetCapture(hWnd);
    ShowCursor(TRUE);

    for (i = cUndo-1; i >= 0; i--)
    {
        CARD c;
        int fcol, fpos, tcol, tpos;

        fcol = movelist[i].tcol;
        fpos = movelist[i].tpos;
        tcol = movelist[i].fcol;
        tpos = movelist[i].fpos;

        if (fcol != TOPROW && fcol == tcol)     // no move so exit
            break;

        if (fcol != TOPROW)
            fpos = FindLastPos(fcol);

        if (tcol != TOPROW)
            tpos = FindLastPos(tcol) + 1;

        Glide(hWnd, fcol, fpos, tcol, tpos);    // send the card on its way

        c = card[fcol][fpos];

        if (fcol == TOPROW && fpos > 3)         // if from home cell
        {
            wCardCount++;
            DisplayCardCount(hWnd);             // update display

            home[SUIT(c)]--;

            if (VALUE(c) == ACE)
            {
                card[fcol][fpos] = EMPTY;
                homesuit[SUIT(c)] = EMPTY;
            }
            else
            {
                card[fcol][fpos] -= 4;
            }
        }
        else
            card[fcol][fpos] = EMPTY;

        card[tcol][tpos] = c;
    }

    cUndo = 0;
    EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_GRAYED);

    ShowCursor(FALSE);
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    ReleaseCapture();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\freecell\glide.c ===
/****************************************************************************

Glide.c

June 91, JimH     initial code
Oct 91,  JimH     port to Win32


Routines for gliding cards are here.  There is only one public entry point
to these routines, the function Glide().

The glide speed can be altered by changing STEPSIZE.  A large number (like
37) makes for fast glides.

****************************************************************************/

#include "freecell.h"
#include "freecons.h"
#include <math.h>               // for labs()


#define STEPSIZE    37          // size of glide steps in pixels
#define BGND        255         // used for cdtDrawExt

static  HDC     hMemB1, hMemB2, hMemF;  // mem DC associated with above bitmaps
static  HBITMAP hOB1, hOB2, hOF;        // old bitmaps in above mem DCs
static  UINT    dwPixel[12];            // corner pixels that are saved/restored
static  HRGN    hRgn, hRgn1, hRgn2;     // hRgn1 is source, hRgn2 is destination


static  VOID GlideInit(HWND hWnd, UINT fcol, UINT tcol);
static  INT  IntSqrt(INT square);
static  VOID SaveCorners(HDC hDC, UINT x, UINT y);
static  VOID RestoreCorners(HDC hDC, UINT x, UINT y);


/******************************************************************************

Glide

Given a from and to location, this function animates the movement of
the card.

******************************************************************************/

VOID Glide(HWND hWnd, UINT fcol, UINT fpos, UINT tcol, UINT tpos)
{
    HDC     hDC;
    INT     dx, dy;             // total distance card travels
    UINT    x1, y1, x2, y2;     // start and end locations for each step
    UINT    xStart, yStart;     // beginning position
    UINT    xEnd =0, yEnd = 0;  // destination position
    INT     i;
    INT     distance;           // distance card travles +/- 3 pixels
    INT     steps;              // number of steps card takes in glide total
    BOOL    bSaved = FALSE;     // corner pixels saved?

    if (fcol != tcol || fpos != tpos)               // if card moves
    {
        hDC = GetDC(hWnd);
        hMemB1 = CreateCompatibleDC(hDC);           // memory DCs for bitmaps
        hMemB2 = CreateCompatibleDC(hDC);
        hMemF  = CreateCompatibleDC(hDC);

        hRgn1 = CreateRectRgn(1, 1, 2, 2);
        hRgn2 = CreateRectRgn(1, 1, 2, 2);
        hRgn  = CreateRectRgn(1, 1, 2, 2);

        if (hMemB1 && hMemB2 && hMemF && hRgn1 && hRgn2 && hRgn)
        {
            hOB1 =   SelectObject(hMemB1, hBM_Bgnd1);
            hOB2 =   SelectObject(hMemB2, hBM_Bgnd2);
            hOF  =   SelectObject(hMemF,  hBM_Fgnd);

            GlideInit(hWnd, fcol, fpos);      // set up hBM_Bgnd1 and hBM_Fgnd

            Card2Point(fcol, fpos, &xStart, &yStart);
            Card2Point(tcol, tpos, &xEnd, &yEnd);
            SaveCorners(hDC, xEnd, yEnd);
            bSaved = TRUE;

            /* Determine how far to travel and how many steps to take. */

            x1 = xStart;
            y1 = yStart;
            dx = xEnd - xStart;
            dy = yEnd - yStart;
            distance = IntSqrt(dx*dx + dy*dy);

            if (bFastMode)
                steps = 1;
            else
                steps = distance / STEPSIZE;

            /* Determine intermediate glide locations.  Long arithmetic is
               needed to prevent overflows. */ 

            for (i = 1; i < steps; i++)
            {
                x2 = xStart + ((i * dx) / steps);
                y2 = yStart + ((i * dy) / steps);
                GlideStep(hDC, x1, y1, x2, y2);
                x1 = x2;
                y1 = y2;
            }

            /* Erase last background manually -- DrawCard will do last card. */

            BitBlt(hMemB1, xEnd-x1, yEnd-y1, dxCrd, dyCrd, hMemF,0,0,SRCCOPY);
            BitBlt(hDC, x1, y1, dxCrd, dyCrd, hMemB1, 0, 0, SRCCOPY);

            /* Select original bitmaps so mem DCs can be destroyed. */

            SelectObject(hMemB1, hOB1);
            SelectObject(hMemB2, hOB2);
            SelectObject(hMemF, hOF);
        }
        else
        {
            LoadString(hInst, IDS_MEMORY, bigbuf, BIG);
            LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
            MessageBeep(MB_ICONHAND);
            MessageBox(hWnd, bigbuf, smallbuf, MB_OK | MB_ICONHAND);
            moveindex = 0;      // don't try moving more cards
            PostQuitMessage(0);
        }

        DeleteDC(hMemB1);
        DeleteDC(hMemB2);
        DeleteDC(hMemF);
        ReleaseDC(hWnd, hDC);

        DeleteObject(hRgn);
        DeleteObject(hRgn1);
        DeleteObject(hRgn2);
    }

    /* Draw last card with DrawCard so end result guaranteed correct. */

    hDC = GetDC(hWnd);
    DrawCard(hDC, tcol, tpos, card[fcol][fpos], FACEUP);
    if (bSaved)
        RestoreCorners(hDC, xEnd, yEnd);
    ReleaseDC(hWnd, hDC);
}


/******************************************************************************

GlideInit

Blt what is under the card source location into hMemB1, and the
card to be moved into hMemF.

******************************************************************************/

VOID GlideInit(HWND hWnd, UINT fcol, UINT fpos)
{
    if (fcol == TOPROW)     // if it's top row, background is ghost bitmap.
    {
        if (fpos > 3 && VALUE(card[fcol][fpos]) != ACE)
        {
            HDC     hDC;
            UINT    x, y;

            hDC = GetDC(hWnd);
            Card2Point(fcol, fpos, &x, &y);
            SaveCorners(hDC, x, y);
            cdtDrawExt(hMemB1,0,0,dxCrd,dyCrd,card[fcol][fpos]-4,FACEUP,BGND);
            RestoreCorners(hMemB1, 0, 0);
            ReleaseDC(hWnd, hDC);
        }
        else
        {
            SelectObject(hMemB2, hBM_Ghost);
            BitBlt(hMemB1, 0, 0, dxCrd, dyCrd, hMemB2, 0, 0, SRCCOPY);
            SelectObject(hMemB2, hBM_Bgnd2);
        }
    }
    else    // else background contains bottom part of card above.
    {
        SelectObject(hMemB1, hBgndBrush);
        PatBlt(hMemB1, 0, 0, dxCrd, dyCrd, PATCOPY);

        if (fpos != 0)
        {
            cdtDrawExt(hMemB1, 0, 0-dyTops, dxCrd, dyCrd, card[fcol][fpos-1],
                        FACEUP, BGND);
        }
    }

    /* Foreground bitmap is just the card to be moved. */

    cdtDrawExt(hMemF, 0, 0, dxCrd, dyCrd, card[fcol][fpos], FACEUP, 0);
}



/******************************************************************************

GlideStep

This routine gets called once for each step in the glide animation.  On
input, it needs the screen under the source in hMemB1, and the card to be
moved in hMemF.  It calculates the screen under the destination itself and
blts it into hMemB2.  At the end of the animation, it moves hMemB2 into
hMemB1 so it can be call again immediately with new coordinates.

******************************************************************************/

VOID GlideStep(HDC hDC, UINT x1, UINT y1, UINT x2, UINT y2)
{
    HDC     hMemTemp;               // used to swap mem DCs.

    SetRectRgn(hRgn1, x1, y1, x1+dxCrd, y1+dyCrd);
    SetRectRgn(hRgn2, x2, y2, x2+dxCrd, y2+dyCrd);

    /* create background of new location by combing screen background
       plus overlap from old background */

    BitBlt(hMemB2, 0, 0, dxCrd, dyCrd, hDC, x2, y2, SRCCOPY);
    BitBlt(hMemB2, x1-x2, y1-y2, dxCrd, dyCrd, hMemB1, 0, 0, SRCCOPY);

    /* Draw old background and then draw card  */

    CombineRgn(hRgn, hRgn1, hRgn2, RGN_DIFF);  // part of hRgn1 not in hRgn2
    SelectObject(hDC, hRgn);
    BitBlt(hDC, x1, y1, dxCrd, dyCrd, hMemB1, 0, 0, SRCCOPY);
    SelectObject(hDC, hRgn2);
    BitBlt(hDC, x2, y2, dxCrd, dyCrd, hMemF, 0, 0, SRCCOPY);

    /* copy new background to old background, or rather, accomplish the
       same effect by swapping the associated memory device contexts. */

    hMemTemp = hMemB1;
    hMemB1 = hMemB2;
    hMemB2 = hMemTemp;
}


/******************************************************************************

IntSqrt

Newton's method to find a quick close-enough square root without pulling
in the floating point libraries.

f(x)  == x*x - square == 0
f'(x) == 2x

******************************************************************************/

INT IntSqrt(INT square)
{
    INT guess, lastguess;

    lastguess = square;
    guess = min(square / 2, 1024);

    while (abs(guess-lastguess) > 3)         // 3 is close enough
    {
        lastguess = guess;
        guess -= ((guess * guess) - square) / (2 * guess);
    }

    return guess;
}



/******************************************************************************

SaveCorners
RestoreCorners

based on similar routines in cards.dll

******************************************************************************/

VOID SaveCorners(HDC hDC, UINT x, UINT y)
{
    // Upper Left
    dwPixel[0] = GetPixel(hDC, x, y);
    dwPixel[1] = GetPixel(hDC, x+1, y);
    dwPixel[2] = GetPixel(hDC, x, y+1);

    // Upper Right
    x += dxCrd -1;
    dwPixel[3] = GetPixel(hDC, x, y);
    dwPixel[4] = GetPixel(hDC, x-1, y);
    dwPixel[5] = GetPixel(hDC, x, y+1);

    // Lower Right
    y += dyCrd-1;
    dwPixel[6] = GetPixel(hDC, x, y);
    dwPixel[7] = GetPixel(hDC, x, y-1);
    dwPixel[8] = GetPixel(hDC, x-1, y);

    // Lower Left
    x -= dxCrd-1;
    dwPixel[9] = GetPixel(hDC, x, y);
    dwPixel[10] = GetPixel(hDC, x+1, y);
    dwPixel[11] = GetPixel(hDC, x, y-1);
}

VOID RestoreCorners(HDC hDC, UINT x, UINT y)
{
    // Upper Left
    SetPixel(hDC, x, y, dwPixel[0]);
    SetPixel(hDC, x+1, y, dwPixel[1]);
    SetPixel(hDC, x, y+1, dwPixel[2]);

    // Upper Right
    x += dxCrd-1;
    SetPixel(hDC, x, y, dwPixel[3]);
    SetPixel(hDC, x-1, y, dwPixel[4]);
    SetPixel(hDC, x, y+1, dwPixel[5]);

    // Lower Right
    y += dyCrd-1;
    SetPixel(hDC, x, y, dwPixel[6]);
    SetPixel(hDC, x, y-1, dwPixel[7]);
    SetPixel(hDC, x-1, y, dwPixel[8]);

    // Lower Left
    x -= dxCrd-1;
    SetPixel(hDC, x, y, dwPixel[9]);
    SetPixel(hDC, x+1, y, dwPixel[10]);
    SetPixel(hDC, x, y-1, dwPixel[11]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\pegged\pegged.h ===
#define	IDM_NEW	1
#define	IDM_UNDO	2
#define	IDM_CROSS	3
#define	IDM_PLUS	4
#define	IDM_FIREPLACE	5
#define	IDM_UPARROW	6
#define	IDM_PYRAMID	7
#define	IDM_DIAMOND	8
#define	IDM_SOLITAIRE	9
#define	IDM_HINT	10
#define	IDM_ABOUT	11
#define	IDM_ICONIZE	12
#define	IDM_EXIT	13
#define	IDM_INDEX	14
#define	IDM_HOWTO	15
#define	IDM_COMMANDS	16
#define	IDM_USING	17
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\freecell\freecell.c ===
/****************************************************************************

Freecell.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32


Main source module for Windows Free Cell.
Contains WinMain, initialization routines, and MainWndProc.


Design notes:

Note that although this program uses some of the mapping macros,
this version of the code is 32 bit only!  See Wep2 sources for
16 bit sources.

The current layout of the cards is kept in the array card[MAXCOL][MAXPOS].
In this scheme, column 0 is actually the top row.  In this "column", pos
0 to 3 are the free cells, and 4 to 7 are the home cells.  The other
columns numbered 1 to 8 are the stacked card columns.

See PaintMainWindow() for some details on changing the display for EGA.

A previous version of Free Cell used a timer for multi-card moves.
WM_FAKETIMER messages are now sent manually to accomplish the same thing.

****************************************************************************/

#include "freecell.h"
#include "freecons.h"
#include <shellapi.h>
#include <regstr.h>
#include <htmlhelp.h>   // for HtmlHelp()
#include <commctrl.h>   // for fusion classes.


/* Registry strings -- do not translate */

CONST TCHAR pszRegPath[]  = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\FreeCell");
CONST TCHAR pszWon[]      = TEXT("won");
CONST TCHAR pszLost[]     = TEXT("lost");
CONST TCHAR pszWins[]     = TEXT("wins");
CONST TCHAR pszLosses[]   = TEXT("losses");
CONST TCHAR pszStreak[]   = TEXT("streak");
CONST TCHAR pszSType[]    = TEXT("stype");
CONST TCHAR pszMessages[] = TEXT("messages");
CONST TCHAR pszQuick[]    = TEXT("quick");
CONST TCHAR pszDblClick[] = TEXT("dblclick");
CONST TCHAR pszAlreadyPlayed[] = TEXT("AlreadyPlayed");


#define  WTSIZE     50              // window text size in characters

void _setargv() { }     // reduces size of C runtimes
void _setenvp() { }

/****************************************************************************

WinMain(HANDLE, HANDLE, LPSTR, int)

****************************************************************************/

MMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow) /* { */
    MSG msg;                            // message
    HANDLE  hAccel;                     // LifeMenu accelerators

    if (!hPrevInstance)                 // Other instances of app running?
        if (!InitApplication(hInstance))    // Initialize shared things
            return FALSE;                   // Exits if unable to initialize

    if (!InitInstance(hInstance, nCmdShow))
        return FALSE;

    hAccel = LoadAccelerators(hInstance, TEXT("FreeMenu"));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(hMainWnd, hAccel, &msg))
        {
            TranslateMessage(&msg);    // Translates virtual key codes
            DispatchMessage(&msg);     // Dispatches message to window
        }
    }
    DEBUGMSG(TEXT("----  Free Cell Terminated ----\n\r"),0);
    return (INT) msg.wParam;             /* Returns the value from PostQuitMessage */
}


/****************************************************************************

InitApplication(HANDLE hInstance)

****************************************************************************/

BOOL InitApplication(HANDLE hInstance)
{
    WNDCLASS    wc;
    HDC         hIC;            // information context
    INITCOMMONCONTROLSEX icc;   // common control registration.


    DEBUGMSG(TEXT("----  Free Cell Initiated  ----\n\r"),0);

    /* Check if monochrome */

    hIC = CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL);
    if (GetDeviceCaps(hIC, NUMCOLORS) == 2)
    {
        bMonochrome = TRUE;
        /* BrightPen is not so bright in mono. */
        hBrightPen = CreatePen(PS_SOLID, 1, RGB(  0,   0,   0));
        hBgndBrush = CreateSolidBrush(RGB(255, 255, 255));
    }
    else
    {
        bMonochrome = FALSE;
        hBrightPen = CreatePen(PS_SOLID, 1, RGB(0, 255, 0));
        hBgndBrush = CreateSolidBrush(RGB(0, 127, 0));      // green background
    }
    DeleteDC(hIC);

    // Create the freecell icon
    hIconMain = LoadIcon(hInstance, MAKEINTRESOURCE(ID_ICON_MAIN));

    // Register the common controls.
    icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icc.dwICC  = ICC_ANIMATE_CLASS | ICC_BAR_CLASSES | ICC_COOL_CLASSES | ICC_HOTKEY_CLASS | ICC_LISTVIEW_CLASSES | 
                 ICC_PAGESCROLLER_CLASS | ICC_PROGRESS_CLASS | ICC_TAB_CLASSES | ICC_UPDOWN_CLASS | ICC_USEREX_CLASSES;
    InitCommonControlsEx(&icc);

    wc.style = CS_DBLCLKS;              // allow double clicks
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = hIconMain;
    wc.hCursor = NULL;
    wc.hbrBackground = hBgndBrush;
    wc.lpszMenuName =  TEXT("FreeMenu");
    wc.lpszClassName = TEXT("FreeWClass");

    return RegisterClass(&wc);
}


/****************************************************************************

InitInstance(HANDLE hInstance, int nCmdShow)

****************************************************************************/

BOOL InitInstance(HANDLE hInstance, INT nCmdShow)
{
    HWND        hWnd;               // Main window handle.
    UINT        col, pos;
    INT         nWindowHeight;
    UINT        wAlreadyPlayed;     // have we already updated the registry ?
    UINT        cTLost, cTWon;      // total losses and wins
    UINT        cTLosses, cTWins;   // streaks
    UINT        wStreak;            // current streak amount
    UINT        wSType;             // current streak type
    LONG        lRegResult;                 // used to store return code from registry call


    if (!hBrightPen || !hBgndBrush)
        return FALSE;

    /* Initialize some global variables */

    for (col = 0; col < MAXCOL; col++)          // clear the deck
        for (pos = 0; pos < MAXPOS; pos++)
            card[col][pos] = EMPTY;

    hInst = hInstance;
    cWins = 0;
    cLosses = 0;
    cGames = 0;
    cUndo = 0;
    gamenumber = 0;             // so no cards are drawn in main wnd
    oldgamenumber = 0;          // this is first game and will count
    hMenuFont = 0;

    bWonState = FALSE;
    bGameInProgress = FALSE;
    bCheating = FALSE;
    bFastMode = FALSE;
    bFlipping = FALSE;
    pszIni = TEXT("entpack.ini");
    bDblClick = TRUE;
    bMessages = FALSE;

    /* for VGA or smaller, window will just fit inside screen */

    nWindowHeight = min(WINHEIGHT, GetSystemMetrics(SM_CYSCREEN));

    /* Create a main window for this application instance.  */

    LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
    hWnd = CreateWindow(
        TEXT("FreeWClass"),             // See RegisterClass() call.
        smallbuf,                       // Text for window title bar.
        WS_OVERLAPPEDWINDOW,            // Window style.
        CW_USEDEFAULT,                  // Default horizontal position.
        CW_USEDEFAULT,                  // Default vertical position.
        WINWIDTH,                       //         width.
        nWindowHeight,                  //         height.
        NULL,                           // Overlapped windows have no parent.
        NULL,                           // Use the window class menu.
        hInstance,                      // This instance owns this window.
        NULL                            // Pointer not needed.
    );

    /* If window could not be created, return "failure" */

    if (!hWnd)
        return FALSE;
    hMainWnd = hWnd;

    /* Make the window visible; update its client area; and return "success" */

    ShowWindow(hWnd, nCmdShow);     // Show the window
    UpdateWindow(hWnd);             // Sends WM_PAINT message


    // Do the transfer of stats from the .ini file to the
    // registry (for people migrating from NT 4.0 freecell to NT 5.0)

    lRegResult = REGOPEN

    if (ERROR_SUCCESS == lRegResult)
    {
        wAlreadyPlayed = GetInt(pszAlreadyPlayed, 0);

        // If this is the first time we are playing 
        // update the registry with the stats from the .ini file.
        if (!wAlreadyPlayed)
        {
            LoadString(hInst, IDS_APPNAME, bigbuf, BIG);

            // Read the stats from the .ini file. (if present)
            // If we can't read the stats, default value is zero.
            cTLost = GetPrivateProfileInt(bigbuf, TEXT("lost"), 0, pszIni);
            cTWon  = GetPrivateProfileInt(bigbuf, TEXT("won"), 0, pszIni);

            cTLosses = GetPrivateProfileInt(bigbuf, TEXT("losses"), 0, pszIni);
            cTWins   = GetPrivateProfileInt(bigbuf, TEXT("wins"), 0, pszIni);

            wStreak = GetPrivateProfileInt(bigbuf, TEXT("streak"), 0, pszIni);
            wSType = GetPrivateProfileInt(bigbuf, TEXT("stype"), 0, pszIni);

            // Copy the stats from the .ini file to the registry.
            SetInt(pszLost, cTLost);
            SetInt(pszWon, cTWon);
            SetInt(pszLosses, cTLosses);
            SetInt(pszWins, cTWins);
            SetInt(pszStreak, wStreak);
            SetInt(pszSType, wSType);

            // Set the already-played flag to 1.
            SetInt(pszAlreadyPlayed, 1);
        }

        REGCLOSE;
    }

    return TRUE;                    // Returns the value from PostQuitMessage
}


/****************************************************************************

MainWndProc(HWND, unsigned, UINT, LONG)

****************************************************************************/

LRESULT APIENTRY MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT     i;                      // generic counter
    int     nResp;                  // messagebox response
    UINT    col, pos;
    UINT    wCheck;                 // for checking IDM_MESSAGES menu item
    HDC     hDC;
    POINT   FAR *MMInfo;            // for GetMinMaxInfo
    HBRUSH  hOldBrush;
    RECT    rect;
    HMENU   hMenu;
    static  BOOL bEatNextMouseHit = FALSE;  // is next hit only for activation?

    switch (message) {
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDM_ABOUT:
                    LoadString(hInst, IDS_FULLNAME, bigbuf, BIG);
                    LoadString(hInst, IDS_CREDITS, smallbuf, SMALL);
                    ShellAbout(hWnd, (LPCTSTR)bigbuf, (LPCTSTR)smallbuf, hIconMain);
                               
                    break;


                case IDM_EXIT:
                    SendMessage(hWnd, WM_CLOSE, 0, 0);
                    break;

                case IDM_NEWGAME:
                    lParam = GenerateRandomGameNum();
                case IDM_SELECT:
                case IDM_RESTART:
                    if (bGameInProgress)
                    {
                        LoadString(hInst, IDS_RESIGN, bigbuf, BIG);
                        LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                        MessageBeep(MB_ICONQUESTION);
                        if (IDNO == MessageBox(hWnd, bigbuf, smallbuf,
                                                 MB_YESNO | MB_ICONQUESTION))
                        {
                            break;
                        }
                        UpdateLossCount();
                    }

                    if (wParam == IDM_RESTART)
                    {
                        if (bGameInProgress)
                            lParam = gamenumber;
                        else
                            lParam = oldgamenumber;
                    }
                    else if (wParam == IDM_SELECT)
                        lParam = 0L;

                    if (wParam == IDM_NEWGAME)
                        bSelecting = FALSE;
                    else if (wParam == IDM_SELECT)
                        bSelecting = TRUE;

                    bGameInProgress = FALSE;
                    wFromCol = EMPTY;               // no FROM selected
                    wMouseMode = FROM;              // FROM selected next
                    moveindex = 0;                  // no queued moves
                    for (i = 0; i < 4; i++)         // nothing in home cells
                    {
                        homesuit[i] = EMPTY;
                        home[i] = EMPTY;
                    }
                    ShuffleDeck(hWnd, lParam);
                    if (gamenumber == CANCELGAME)
                        break;

                    InvalidateRect(hWnd, NULL, TRUE);
                    wCardCount = 52;
                    bGameInProgress = TRUE;
                    hMenu = GetMenu(hWnd);
                    EnableMenuItem(hMenu, IDM_RESTART, MF_ENABLED);
                    DisplayCardCount(hWnd);
                    hDC = GetDC(hWnd);
                    DrawKing(hDC, RIGHT, FALSE);
                    bWonState = FALSE;
                    ReleaseDC(hWnd, hDC);
                    break;

                case IDM_STATS:
                    DialogBox(hInst, TEXT("Stats"), hWnd, StatsDlg);
                    break;

                case IDM_OPTIONS:
                    DialogBox(hInst, MAKEINTRESOURCE(DLG_OPTIONS), hWnd, OptionsDlg);
                    break;

                case IDM_HELP:
                    HtmlHelpA(GetDesktopWindow(), GetHelpFileName(), HH_DISPLAY_TOPIC, 0);
                    break;

                case IDM_HOWTOPLAY:
                    HtmlHelpA(GetDesktopWindow(), GetHelpFileName(), HH_DISPLAY_INDEX, 0);                    
                    break;

                case IDM_HELPONHELP:
                    HtmlHelpA(GetDesktopWindow(), "NTHelp.chm", HH_DISPLAY_TOPIC, 0);
                    break;

                case IDM_UNDO:
                    Undo(hWnd);
                    break;

                 /* Hidden options -- these strings need not be translated */

                case IDM_CHEAT:
                    i = MessageBox(hWnd, TEXT("Choose Abort to Win,\n")
                                   TEXT("Retry to Lose,\nor Ignore to Cancel."),
                                   TEXT("User-Friendly User Interface"),
                                   MB_ABORTRETRYIGNORE | MB_ICONQUESTION);
                    if (i == IDABORT)
                        bCheating = CHEAT_WIN;
                    else if (i == IDRETRY)
                        bCheating = CHEAT_LOSE;
                    else
                        bCheating = FALSE;
                    break;

                default:
                    return DefWindowProc(hWnd, message, wParam, lParam);
            }
            break;

        case WM_CLOSE:
            if (bGameInProgress)        // did user quit mid-game?
            {
                LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                LoadString(hInst, IDS_RESIGN, bigbuf, BIG);
                MessageBeep(MB_ICONQUESTION);
                nResp = MessageBox(hWnd, bigbuf, smallbuf,
                                   MB_YESNO | MB_ICONQUESTION);
                if (nResp == IDNO)
                    break;

                UpdateLossCount();
            }

            WriteOptions();
            return DefWindowProc(hWnd, message, wParam, lParam);

        case WM_CREATE:
            WMCreate(hWnd);
            break;

        case WM_DESTROY:
            if (hBgndBrush)
                DeleteObject(hBgndBrush);
            if (hBrightPen)
                DeleteObject(hBrightPen);
            if (hBM_Fgnd)
                DeleteObject(hBM_Fgnd);
            if (hBM_Bgnd1)
                DeleteObject(hBM_Bgnd1);
            if (hBM_Bgnd2)
                DeleteObject(hBM_Bgnd2);
            if (hBM_Ghost)
                DeleteObject(hBM_Ghost);
            if (hMenuFont)
                DeleteObject(hMenuFont);

            cdtTerm();
            PostQuitMessage(0);
            break;

        case WM_PAINT:
            PaintMainWindow(hWnd);
            break;

        case WM_SIZE:
            DrawMenuBar(hWnd);              // fixes overlapping score on menu
            xOldLoc = 30000;                // force cards left to redraw
            DisplayCardCount(hWnd);         // must update if size changes
            break;

        /***** NOTE: WM_LBUTTONDBLCLK falls through to WM_LBUTTONDOWN ****/

        /* Double clicking works by simulating a move to a free cell.  On
           the off cycle (that is, when wMouseMode == FROM) the double
           click is processed as a single click to cancel the move, and a
           second double click message is posted. */

        case WM_LBUTTONDBLCLK:
            if (moveindex != 0)     // no mouse hit while cards moving
                break;

            if (gamenumber == 0)
                break;

            if (bFlipping)
                break;

             if (bDblClick && wFromCol > TOPROW && wFromCol < MAXCOL)
            {
                if (wMouseMode == TO)
                {
                    Point2Card(LOWORD(lParam), HIWORD(lParam), &col, &pos);
                    if (col == wFromCol)
                        if (ProcessDoubleClick(hWnd))   // if card moved ok
                            break;
                }
                else
                    PostMessage(hWnd, message, wParam, lParam);
            }

        case WM_LBUTTONDOWN:
            if (bEatNextMouseHit)       // is this only window activation?
            {
                bEatNextMouseHit = FALSE;
                break;
            }
            bEatNextMouseHit = FALSE;

            if (bFlipping)          // cards flipping for keyboard players
                break;

            if (moveindex != 0)     // no mouse hit while cards moving
                break;

            if (gamenumber == 0)
                break;

            if (wMouseMode == FROM)
                SetFromLoc(hWnd, LOWORD(lParam), HIWORD(lParam));
            else
                ProcessMoveRequest(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;


        case WM_RBUTTONDOWN:
            SetCapture(hWnd);
            if (bFlipping)
                break;

            if (gamenumber != 0)
                RevealCard(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_RBUTTONUP:
            ReleaseCapture();
            RestoreColumn(hWnd);
            break;

        case WM_MOUSEACTIVATE:                  // app is being activated,
            if (LOWORD(lParam) == HTCLIENT)     // so don't try new cell on
                bEatNextMouseHit = TRUE;        // clicked location
            break;

        case WM_MOUSEMOVE:
            SetCursorShape(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_MOVE:                           // card count erases when moved
            DisplayCardCount(hWnd);
            return (DefWindowProc(hWnd, message, wParam, lParam));

        case WM_GETMINMAXINFO:
            if (GetSystemMetrics(SM_CXSCREEN) > 640)    // skip if VGA
            {
                MMInfo = (POINT FAR *) lParam;  // see SDK ref
                if (MMInfo[4].x > WINWIDTH)
                    MMInfo[4].x = WINWIDTH;     // set max window width to 640
            }
            else
                return DefWindowProc(hWnd, message, wParam, lParam);

            break;

        case WM_CHAR:
            if (!bFlipping)
                KeyboardInput(hWnd, (UINT) wParam);
            break;

        case WM_TIMER:                          // flash main window
            if (wParam == FLASH_TIMER)
                Flash(hWnd);
            else
                Flip(hWnd);
            break;       

        default:                                // Passes it on if unproccessed
            return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}


/****************************************************************************

WMCreate

Handles WM_CREATE message in main window.

****************************************************************************/

VOID WMCreate(HWND hWnd)
{
    BOOL    bResult;                // result of cards.dll initialization
    HDC     hDC;
    HDC     hMemDC;
    HBITMAP hOldBitmap;
    HBRUSH  hOldBrush;
    HPEN    hOldPen;

    /* initialize cards.dll */


	bResult = cdtInit(&dxCrd, &dyCrd);

    CalcOffsets(hWnd);

    hDC = GetDC(hWnd);
    hMemDC = CreateCompatibleDC(hDC);
    hBM_Fgnd  = CreateCompatibleBitmap(hDC, dxCrd, dyCrd);
    hBM_Bgnd1 = CreateCompatibleBitmap(hDC, dxCrd, dyCrd);
    hBM_Bgnd2 = CreateCompatibleBitmap(hDC, dxCrd, dyCrd);
    hBM_Ghost = CreateCompatibleBitmap(hDC, dxCrd, dyCrd);
    if (hBM_Ghost)          // if memory allocation succeeded
    {
        hOldBitmap = SelectObject(hMemDC, hBM_Ghost);
        hOldBrush  = SelectObject(hMemDC, hBgndBrush);
        PatBlt(hMemDC, 0, 0, dxCrd, dyCrd, PATCOPY);

        hOldPen = SelectObject(hMemDC, GetStockObject(BLACK_PEN));
        MoveToEx(hMemDC, 0, dyCrd-2, NULL);
        LineTo(hMemDC, 0, 0);
        LineTo(hMemDC, dxCrd-1, 0);

        SelectObject(hMemDC, hBrightPen);
        MoveToEx(hMemDC, dxCrd-1, 1, NULL);
        LineTo(hMemDC, dxCrd-1, dyCrd-1);
        LineTo(hMemDC, 0, dyCrd-1);

        SelectObject(hMemDC, hOldPen);
        SelectObject(hMemDC, hOldBitmap);
        SelectObject(hMemDC, hOldBrush);
    }
    DeleteDC(hMemDC);
    ReleaseDC(hWnd, hDC);

    if (!bResult || !hBM_Fgnd || !hBM_Bgnd1 || !hBM_Bgnd2)
    {
        LoadString(hInst, IDS_MEMORY, bigbuf, BIG);
        LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
        MessageBeep(MB_ICONHAND);
        MessageBox(hWnd, bigbuf, smallbuf, MB_OK | MB_ICONHAND);
        PostQuitMessage(0);
        return;
    }

    ReadOptions();

    CreateMenuFont();
}


/****************************************************************************

CreateMenuFont

Makes a copy of the menu font and puts the handle in hMenuFont

****************************************************************************/

VOID CreateMenuFont()
{
    LOGFONT lf;                         // description of menu font
    NONCLIENTMETRICS ncm;

    hMenuFont = 0;
    ncm.cbSize = sizeof(ncm);

    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
        return;

    lf.lfHeight         = (int)ncm.lfMenuFont.lfHeight;
    lf.lfWidth          = (int)ncm.lfMenuFont.lfWidth;
    lf.lfEscapement     = (int)ncm.lfMenuFont.lfEscapement;
    lf.lfOrientation    = (int)ncm.lfMenuFont.lfOrientation;
    lf.lfWeight         = (int)ncm.lfMenuFont.lfWeight;
    lf.lfItalic         = ncm.lfMenuFont.lfItalic;
    lf.lfUnderline      = ncm.lfMenuFont.lfUnderline;
    lf.lfStrikeOut      = ncm.lfMenuFont.lfStrikeOut;
    lf.lfCharSet        = ncm.lfMenuFont.lfCharSet;
    lf.lfOutPrecision   = ncm.lfMenuFont.lfOutPrecision;
    lf.lfClipPrecision  = ncm.lfMenuFont.lfClipPrecision;
    lf.lfQuality        = ncm.lfMenuFont.lfQuality;
    lf.lfPitchAndFamily = ncm.lfMenuFont.lfPitchAndFamily;
    lstrcpyn(lf.lfFaceName, ncm.lfMenuFont.lfFaceName, LF_FACESIZE);

    hMenuFont = CreateFontIndirect(&lf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\pegged\pegged.c ===
/* Pegged.C -- Windows Game*/
/* (c) By Mike Blaylock - 1989, 1990 */



#include "windows.h"
#include <port1632.h>
#include "math.h"
#include "pegged.h"

#define DIVISIONS 7
#define ICON_NAME "Pegged"
#define HELP_FILE "pegged.hlp"

VOID checkfvmove();
VOID checkfanymoves();

VOID  APIENTRY AboutWEP(HWND, HICON, LPSTR, LPSTR);

RECT r;
INT prevxorg, prevyorg;
INT prevwidth, prevheight;

HWND        hWnd ;



HANDLE hAccTable;
INT m = 0, nDefault = 3;
LONG_PTR prevwarea, newarea;
INT xPrevpoint, yPrevpoint, xLeft, yTop;
WPARAM wprevmenuitem;

HANDLE hPeggedIcon;

HANDLE hBitmap, hWBitmap ,  hIntBitmap, hOldWBitmap, hOldIntBitmap,
 hBoardBitmap, hOldBoardBitmap, htmpBitmap, hWtmpBitmap ,  hInttmpBitmap,
 hOldWtmpBitmap, hOldInttmpBitmap, hBoardtmpBitmap, hOldBoardtmpBitmap;


INT icross = 1, iplus = 0, ifireplace = 0, ipyramid = 0, ilamp
= 0, idiamond = 0,  iuparrow = 0, isolitaire = 0, fanymoremoves
= 0, ntotal = 0, fignorelbutton = 0, fmousefocusd = 0;

INT ffirst = 1, foomed = 0;


LPSTR lpszCommands[10], lpszHowToPlay[10];
LONG lPrevSizeParam ;

struct {
    INT xsource;
    INT ysource;
    INT xdest;
    INT ydest;
    INT xjumped;
    INT yjumped;
}  move[34];

LRESULT APIENTRY WndProc (HWND, UINT, WPARAM, LPARAM) ;

CHAR szAppName [] = "Pegged";
static BOOL bState [DIVISIONS][DIVISIONS];

HDC hDC, hMemDC, hMemwinDC, hIntDC, hBoardDC, htmpMemDC, htmpMemwinDC,
 htmpIntDC, htmpBoardDC;
HBRUSH  hLtgrybrush, hDkgrybrush, hYbrush, hBbrush, hBlkbrush,
hGbrush, hMedgrybrush;
HPEN hWpen, hLtwpen, hBlkpen, hDkgrypen, hThkdkgrypen, hMedgrypen,
 hLtgrypen;
INT first = 1, fhitbutton = 0, fmovingchip = 0, fvalidmove = 0,
 fcanundo = 0, foom = 0, foomonsize = 0;
INT ixdownblock, iydownblock, ixupblock, iyupblock, ixkilledblock,
 iykilledblock, ixjumpedblock, iyjumpedblock, ixprevsource, iyprevsource,
 ixprevdest, iyprevdest, ixprevkilled, iyprevkilled;



MMain(hInstance, hPrevInstance, lpszCmdLine, nCmdShow)
/* { */
    /*     HWND        hWnd ;*/
    MSG         msg ;
    WNDCLASS    wndclass ;
    static INT xScreen, yScreen, xSize, ySize;

    /*multinst.c */

    if (hPrevInstance)
    {

	hWnd = FindWindow(szAppName, NULL);
	SendMessage(hWnd, WM_SYSCOMMAND, SC_RESTORE, (LONG) 0);
	hWnd = GetLastActivePopup(hWnd);
	BringWindowToTop(hWnd);
	return FALSE;
    }


    if (!hPrevInstance)
    {
	wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
	wndclass.lpfnWndProc   = WndProc ;
	wndclass.cbClsExtra    = 0 ;
	wndclass.cbWndExtra    = 0 ;
	wndclass.hInstance     = hInstance ;
	wndclass.hIcon = LoadIcon(hInstance, (LPSTR) ICON_NAME);
	hPeggedIcon = wndclass.hIcon;
	wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
	wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
	wndclass.lpszMenuName  = szAppName ;
	wndclass.lpszClassName = szAppName ;

	if (!RegisterClass (&wndclass))
	    return FALSE ;
    }


    xScreen = GetSystemMetrics(SM_CXSCREEN);
    yScreen = GetSystemMetrics(SM_CYSCREEN);
    if (xScreen > yScreen)
    {
	xSize = (xScreen / 8) * 3;
	ySize = xSize;
    } else
    {
	ySize = (yScreen / 8) * 3;
	xSize = ySize;
    }


    hWnd = CreateWindow (szAppName, "Pegged",
    WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX,
			     (xScreen-xSize)
     / 2, (yScreen-ySize)
     / 2,
    xSize, ySize,
    NULL, NULL, hInstance, NULL) ;

    ShowWindow (hWnd, nCmdShow) ;
    UpdateWindow (hWnd) ;
    hAccTable = LoadAccelerators(hInstance, "MainAcc");

    while (GetMessage (&msg, NULL, 0, 0)
    )
    if (!TranslateAccelerator(hWnd, hAccTable, &msg)
    )
    {
	{
	TranslateMessage (&msg) ;
	DispatchMessage (&msg) ;
    }


    }


    return (INT) msg.wParam ;
    }


LRESULT  APIENTRY WndProc (
HWND          hWnd,
UINT         iMessage,
WPARAM       wParam,
LPARAM       lParam)
{


    static INT xBlock, xsizedBlock, yBlock, ysizedBlock, xEdge,
         yEdge, xShadow, yShadow, xHalf, yHalf, winxEdge, winyEdge;
    HDC hDC;
    PAINTSTRUCT ps;
    RECT rect;
    LONG xul, yul;
    INT x, y, j, k;

    static INT  xClient, xsizedClient, yClient, ysizedClient,
         xCenter, yCenter, oldxCenter, oldyCenter, xTotal, yTotal,
        xRadius, yRadius, xMove, yMove, xPixel, yPixel, i;
    INT xPoint, yPoint, xUp, yUp;
    SHORT         nScale;
    BOOL bShow;


    MSG message;
    HMENU hMenu;


    switch (iMessage) {
    case WM_INITMENUPOPUP:
	if (m)
	    EnableMenuItem((HMENU)wParam, IDM_UNDO, MF_ENABLED);
	else
	    EnableMenuItem((HMENU)wParam, IDM_UNDO, MF_GRAYED);
	break;


    case WM_COMMAND:
	switch (GET_WM_COMMAND_ID(wParam, lParam)) {
	case IDM_NEW:
	    m = 0;
	    hDC = GetDC(hWnd);

	    if (isolitaire) {
		for (j = 0; j < 7; ++j)
		    for (k = 0; k < 7; ++k) {
			if ((j > 1 && j < 5) || (k > 1 && k < 5))
			    if (!(j == 3 && k == 3))
				bState[j][k] = 1;
			    else
				bState[j][k] = 0;
		    }
	    }

	    if (icross) {
		bState[0][2] = 0;
		bState[0][3] = 0;
		bState[0][4] = 0;
		bState[1][2] = 0;
		bState[1][3] = 0;
		bState[1][4] = 0;
		bState[2][0] = 0;
		bState[2][1] = 0;
		bState[2][2] = 1;
		bState[2][3] = 0;
		bState[2][4] = 0;
		bState[2][5] = 0;
		bState[2][6] = 0;
		bState[3][0] = 0;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 1;
		bState[3][4] = 1;
		bState[3][5] = 0;
		bState[3][6] = 0;
		bState[4][0] = 0;
		bState[4][1] = 0;
		bState[4][2] = 1;
		bState[4][3] = 0;
		bState[4][4] = 0;
		bState[4][5] = 0;
		bState[4][6] = 0;
		bState[5][2] = 0;
		bState[5][3] = 0;
		bState[5][4] = 0;
		bState[6][2] = 0;
		bState[6][3] = 0;
		bState[6][4] = 0;
	    }

	    if (iuparrow) {
		bState[0][2] = 0;
		bState[0][3] = 0;
		bState[0][4] = 0;
		bState[1][2] = 1;
		bState[1][3] = 0;
		bState[1][4] = 0;
		bState[2][0] = 0;
		bState[2][1] = 1;
		bState[2][2] = 1;
		bState[2][3] = 0;
		bState[2][4] = 0;
		bState[2][5] = 1;
		bState[2][6] = 1;
		bState[3][0] = 1;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 1;
		bState[3][4] = 1;
		bState[3][5] = 1;
		bState[3][6] = 1;
		bState[4][0] = 0;
		bState[4][1] = 1;
		bState[4][2] = 1;
		bState[4][3] = 0;
		bState[4][4] = 0;
		bState[4][5] = 1;
		bState[4][6] = 1;
		bState[5][2] = 1;
		bState[5][3] = 0;
		bState[5][4] = 0;
		bState[6][2] = 0;
		bState[6][3] = 0;
		bState[6][4] = 0;


	    }

	    if (iplus) {
		bState[0][2] = 0;
		bState[0][3] = 0;
		bState[0][4] = 0;
		bState[1][2] = 0;
		bState[1][3] = 1;
		bState[1][4] = 0;
		bState[2][0] = 0;
		bState[2][1] = 0;
		bState[2][2] = 0;
		bState[2][3] = 1;
		bState[2][4] = 0;
		bState[2][5] = 0;
		bState[2][6] = 0;
		bState[3][0] = 0;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 1;
		bState[3][4] = 1;
		bState[3][5] = 1;
		bState[3][6] = 0;
		bState[4][0] = 0;
		bState[4][1] = 0;
		bState[4][2] = 0;
		bState[4][3] = 1;
		bState[4][4] = 0;
		bState[4][5] = 0;
		bState[4][6] = 0;
		bState[5][2] = 0;
		bState[5][3] = 1;
		bState[5][4] = 0;
		bState[6][2] = 0;
		bState[6][3] = 0;
		bState[6][4] = 0;

	    }

	    if (ifireplace) {
		bState[0][2] = 0;
		bState[0][3] = 0;
		bState[0][4] = 0;
		bState[1][2] = 0;
		bState[1][3] = 0;
		bState[1][4] = 0;
		bState[2][0] = 1;
		bState[2][1] = 1;
		bState[2][2] = 1;
		bState[2][3] = 1;
		bState[2][4] = 0;
		bState[2][5] = 0;
		bState[2][6] = 0;
		bState[3][0] = 1;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 0;
		bState[3][4] = 0;
		bState[3][5] = 0;
		bState[3][6] = 0;
		bState[4][0] = 1;
		bState[4][1] = 1;
		bState[4][2] = 1;
		bState[4][3] = 1;
		bState[4][4] = 0;
		bState[4][5] = 0;
		bState[4][6] = 0;
		bState[5][2] = 0;
		bState[5][3] = 0;
		bState[5][4] = 0;
		bState[6][2] = 0;
		bState[6][3] = 0;
		bState[6][4] = 0;



	    }



	    if (ipyramid) {
		bState[0][2] = 0;
		bState[0][3] = 0;
		bState[0][4] = 1;
		bState[1][2] = 0;
		bState[1][3] = 1;
		bState[1][4] = 1;
		bState[2][0] = 0;
		bState[2][1] = 0;
		bState[2][2] = 1;
		bState[2][3] = 1;
		bState[2][4] = 1;
		bState[2][5] = 0;
		bState[2][6] = 0;
		bState[3][0] = 0;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 1;
		bState[3][4] = 1;
		bState[3][5] = 0;
		bState[3][6] = 0;
		bState[4][0] = 0;
		bState[4][1] = 0;
		bState[4][2] = 1;
		bState[4][3] = 1;
		bState[4][4] = 1;
		bState[4][5] = 0;
		bState[4][6] = 0;
		bState[5][2] = 0;
		bState[5][3] = 1;
		bState[5][4] = 1;
		bState[6][2] = 0;
		bState[6][3] = 0;
		bState[6][4] = 1;




	    }

	    if (idiamond) {
		bState[0][2] = 0;
		bState[0][3] = 1;
		bState[0][4] = 0;
		bState[1][2] = 1;
		bState[1][3] = 1;
		bState[1][4] = 1;
		bState[2][0] = 0;
		bState[2][1] = 1;
		bState[2][2] = 1;
		bState[2][3] = 1;
		bState[2][4] = 1;
		bState[2][5] = 1;
		bState[2][6] = 0;
		bState[3][0] = 1;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 0;
		bState[3][4] = 1;
		bState[3][5] = 1;
		bState[3][6] = 1;
		bState[4][0] = 0;
		bState[4][1] = 1;
		bState[4][2] = 1;
		bState[4][3] = 1;
		bState[4][4] = 1;
		bState[4][5] = 1;
		bState[4][6] = 0;
		bState[5][2] = 1;
		bState[5][3] = 1;
		bState[5][4] = 1;
		bState[6][2] = 0;
		bState[6][3] = 1;
		bState[6][4] = 0;


	    }


	    /******Erase all the chips *************************************/

	    for (x = 0; x < DIVISIONS; x++)
		for (y = 0; y < DIVISIONS; y++) {
		    if ((x > 1 && x < 5) || (y > 1 && y < 5)) {
			BitBlt(hDC, xBlock * x + winxEdge, yBlock
			    *y + winyEdge, xBlock, yBlock, hBoardDC,
			     xBlock * x + winxEdge, yBlock * y + winyEdge,
			     SRCCOPY);
		    }
		}
	    /*************************************************************/



	    /********* Put chips where they go *****************************/
	    for (x = 0; x < DIVISIONS; x++)
		for (y = 0; y < DIVISIONS; y++) {
		    if (bState[x][y]) {


			SelectObject(hDC, hDkgrypen);
			SelectObject(hDC, hDkgrybrush);
			Ellipse(hDC, x * xBlock + xEdge + xShadow +
			    winxEdge, y * yBlock + yEdge + yShadow +
			    winyEdge, (x + 1) * xBlock - xEdge + xShadow +
			    winxEdge,  (y + 1) * yBlock - yEdge + yShadow +
			    winyEdge);

			SelectObject(hDC, hBlkpen);
			SelectObject(hDC, hBbrush);
			Ellipse(hDC, x * xBlock + xEdge + winxEdge,
			     y * yBlock + yEdge + winyEdge, (x + 1) *
			    xBlock - xEdge + winxEdge,  (y + 1) * yBlock -
			    yEdge + winyEdge);

			SelectObject(hDC, hWpen);
			Arc(hDC, x * xBlock + xEdge + xShadow +
			    winxEdge, y * yBlock + yEdge + yShadow +
			    winyEdge, (x + 1) * xBlock - xEdge - xShadow +
			    winxEdge,  (y + 1) * yBlock - yEdge - yShadow +
			    winyEdge , x * xBlock + xHalf + winxEdge ,
			     y * yBlock + yShadow + winyEdge, x * xBlock
			    + xShadow + winxEdge, y * yBlock + yHalf +
			    winyEdge);



		    }
		}
	    /***************************************************************/

	    BitBlt(hMemwinDC, 0, 0, xClient, yClient, hDC, 0, 0,
	         SRCCOPY);


	    ReleaseDC(hWnd, hDC);

	    break;

	case IDM_UNDO:
	    if (m) {
		--m;
		/*put a chip back in the original location */
		hDC = GetDC(hWnd);
		/*erase the destination chip on screen*/
		BitBlt(hDC, move[m].xdest * xBlock + winxEdge,
		    move[m].ydest * yBlock + winyEdge, xBlock, yBlock,
		     hBoardDC, move[m].xdest * xBlock + winxEdge, move[m].ydest
		    *yBlock + winyEdge , SRCCOPY);

		/*Erase the destination chip on the memdc */
		SelectObject(hMemwinDC, hWBitmap);
		BitBlt(hMemwinDC, move[m].xdest * xBlock + winxEdge,
		     move[m].ydest * yBlock + winyEdge, xBlock, yBlock,
		     hBoardDC, move[m].xdest * xBlock + winxEdge, move[m].ydest
		    *yBlock + winyEdge , SRCCOPY);

		/*Put back the jumped chip on the screen*/

		x = move[m].xjumped;
		y = move[m].yjumped;

		SelectObject(hDC, hDkgrypen);
		SelectObject(hDC, hDkgrybrush);
		Ellipse(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge + xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge + yShadow + winyEdge);
		SelectObject(hDC, hBlkpen);
		SelectObject(hDC, hBbrush);
		Ellipse(hDC, x * xBlock + xEdge + winxEdge, y *
		    yBlock + yEdge + winyEdge, (x + 1) * xBlock - xEdge +
		    winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

		SelectObject(hDC, hWpen);
		Arc(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge - yShadow + winyEdge , x *
		    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
		    winyEdge, x * xBlock + xShadow + winxEdge, y *
		    yBlock + yHalf + winyEdge);




		/* Put back the jumped chip in the memdc */
		SelectObject(hMemwinDC, hWBitmap);
		BitBlt(hMemwinDC, move[m].xjumped * xBlock + winxEdge,
		     move[m].yjumped * yBlock + winyEdge, xBlock, yBlock,
		     hDC, move[m].xjumped * xBlock + winxEdge, move[m].yjumped
		    *yBlock + winyEdge , SRCCOPY);



		/*Put back the source chip on the screen*/

		x = move[m].xsource;
		y = move[m].ysource;


		SelectObject(hDC, hDkgrypen);
		SelectObject(hDC, hDkgrybrush);
		Ellipse(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge + xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge + yShadow + winyEdge);
		SelectObject(hDC, hBlkpen);
		SelectObject(hDC, hBbrush);
		Ellipse(hDC, x * xBlock + xEdge + winxEdge, y *
		    yBlock + yEdge + winyEdge, (x + 1) * xBlock - xEdge +
		    winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

		SelectObject(hDC, hWpen);
		Arc(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge - yShadow + winyEdge , x *
		    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
		    winyEdge, x * xBlock + xShadow + winxEdge, y *
		    yBlock + yHalf + winyEdge);



		/* Put back the source chip in the memdc */
		SelectObject(hMemwinDC, hWBitmap);
		BitBlt(hMemwinDC, move[m].xsource * xBlock + winxEdge,
		     move[m].ysource * yBlock + winyEdge, xBlock, yBlock,
		     hDC, move[m].xsource * xBlock + winxEdge, move[m].ysource
		    *yBlock + winyEdge , SRCCOPY);

		/*Restore the matrix to previous state*/

		bState[move[m].xsource][move[m].ysource] = 1;
		bState[move[m].xjumped][move[m].yjumped] = 1;
		bState[move[m].xdest][move[m].ydest] = 0;


		ReleaseDC(hWnd, hDC);


	    } else
		MessageBox(hWnd, "Can't Backup", szAppName, MB_ICONASTERISK |
		    MB_OK);
	    break;



	case IDM_CROSS:
	    icross = 1;
	    iplus = 0;
	    ifireplace = 0;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 0;
	    isolitaire = 0;

	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, IDM_CROSS, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);

	    break;

	case IDM_PLUS:

	    iplus = 1;
	    icross = 0;
	    ifireplace = 0;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 0;
	    isolitaire = 0;

	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);

	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);


	    break;

	case IDM_FIREPLACE:

	    iplus = 0;
	    icross = 0;
	    ifireplace = 1;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 0;
	    isolitaire = 0;

	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);


	    break;

	case IDM_UPARROW:
	    iplus = 0;
	    icross = 0;
	    ifireplace = 0;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 1;
	    isolitaire = 0;

	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);



	    break;

	case IDM_DIAMOND:
	    iplus = 0;
	    icross = 0;
	    ifireplace = 0;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 1;
	    iuparrow = 0;
	    isolitaire = 0;
	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);

	    break;

	case IDM_PYRAMID:
	    iplus = 0;
	    icross = 0;
	    ifireplace = 0;
	    ipyramid = 1;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 0;
	    isolitaire = 0;
	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);

	    break;

	case IDM_SOLITAIRE:
	    iplus = 0;
	    icross = 0;
	    ifireplace = 0;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 0;
	    isolitaire = 1;
	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);


	    break;
	case IDM_ABOUT:
            AboutWEP(hWnd, hPeggedIcon  , "Pegged!   Version 1.0",
                 "by Mike Blaylock");

	    /*
	     MessageBox(hWnd,"Pegged\n\nA Windows Solitaire Game\n\nCopyright 1989-90\n\nby Mike Blaylock\n\nAlpha v1.011",szAppName, MB_ICONASTERISK | MB_OK);
*/
	    break;

	case IDM_INDEX:
	    WinHelp(hWnd, HELP_FILE, HELP_INDEX, (ULONG_PTR) NULL);
	    break;

	case IDM_HOWTO:
	    WinHelp(hWnd, HELP_FILE, HELP_KEY, (ULONG_PTR) "How To Play");
	    break;

	case IDM_COMMANDS:
	    WinHelp(hWnd, HELP_FILE, HELP_KEY, (ULONG_PTR) "Commands");
	    break;

	case IDM_USING:
	    WinHelp(hWnd, HELP_FILE, HELP_HELPONHELP, (ULONG_PTR) NULL);
	    break;


	case IDM_ICONIZE:
	    ShowWindow(hWnd, SW_MINIMIZE);
	    break;

	case IDM_EXIT:
	    DestroyWindow(hWnd);
	    break;


	default:
	    break;

	}
	break;


    case WM_CREATE:

	hDC = GetDC (hWnd) ;


	xPixel = GetDeviceCaps (hDC, ASPECTX) ;
	yPixel = GetDeviceCaps (hDC, ASPECTY) ;
	hWpen = CreatePen(0, 2, RGB(255, 255, 255));
	hLtwpen = CreatePen(0, 1, RGB(255, 255, 255));


	hMedgrypen = CreatePen(0, 1, RGB (128, 128, 128));

	hDkgrypen = CreatePen(0, 1, RGB (64, 64, 64));
	hThkdkgrypen = CreatePen(0, 2, RGB (64, 64, 64));
	hMedgrybrush = CreateSolidBrush(RGB (128, 128, 128));
	hDkgrybrush = CreateSolidBrush(RGB (64, 64, 64));

	hBlkpen = GetStockObject(BLACK_PEN);
	hBbrush = CreateSolidBrush (RGB (0, 0, 255));
	hBlkbrush = CreateSolidBrush(RGB (0, 0, 0));
	hGbrush = CreateSolidBrush (RGB (0, 64, 0));
	hLtgrybrush = CreateSolidBrush (RGB (192, 192, 192));
	hLtgrypen = CreatePen(0, 1, RGB (192, 192, 192));
	hYbrush = CreateSolidBrush (RGB (255, 255, 0));
	nDefault = 3;
	hMenu = GetMenu(hWnd);
	wprevmenuitem = GetPrivateProfileInt((LPSTR)"Pegged", (LPSTR)"Option",
	     nDefault, (LPSTR)"entpack.ini");
	CheckMenuItem(hMenu, (WORD)wprevmenuitem
	    , MF_CHECKED);

	icross = 0;
	iplus = 0;
	ifireplace = 0;
	ipyramid = 0;
	idiamond = 0;
	iuparrow = 0;
	isolitaire = 0;

	switch (wprevmenuitem) {

	case 3:
	    icross = 1;
	    break;

	case 4:
	    iplus = 1;
	    break;

	case 5:
	    ifireplace = 1;
	    break;

	case 6:
	    iuparrow = 1;
	    break;

	case 7:
	    ipyramid = 1;
	    break;

	case 8:
	    idiamond = 1;
	    break;

	case 9:
	    isolitaire = 1;
	    break;

	default:
	    icross = 1;
	    break;

	}

	PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);




	ffirst = 1;

	ReleaseDC (hWnd, hDC) ;
	break ;

    case WM_SIZE:



	foom = 0;
	hDC = GetDC (hWnd) ;

        MGetViewportOrg(hDC, &xLeft, &yTop);

        newarea = (LONG)LOWORD(lParam) * (LONG)HIWORD(lParam);


	if (ffirst) {

	    xBlock = LOWORD (lParam) / (DIVISIONS + 2);
	    yBlock = HIWORD (lParam) / (DIVISIONS + 2);
	    xClient = LOWORD (lParam);
	    yClient = HIWORD (lParam);
	    xEdge = xBlock / 4;
	    yEdge = yBlock / 4;
	    xShadow = xBlock / 10;
	    yShadow = yBlock / 10;
	    xHalf = xBlock / 2;
	    yHalf = yBlock / 2;
	    winxEdge = xBlock;
	    winyEdge = yBlock;


	    if (!(hIntDC = CreateCompatibleDC(hDC))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }

	    if (!(hBoardBitmap = CreateCompatibleBitmap(hDC, xClient,
	         yClient))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }



	    if (!(hIntBitmap = CreateCompatibleBitmap(hDC, xBlock
	        *4, yBlock * 4))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }

	    if (!(hMemwinDC = CreateCompatibleDC(hDC))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }

	    if (!(hBoardDC = CreateCompatibleDC(hDC))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }

	    if (!(hWBitmap = CreateCompatibleBitmap(hDC, xClient,
	         yClient))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }


	    hOldIntBitmap = SelectObject(hIntDC, hIntBitmap);
	    hOldWBitmap = SelectObject(hMemwinDC, hWBitmap);
	    hOldBoardBitmap = SelectObject(hBoardDC, hBoardBitmap);


	}

	xsizedClient = LOWORD (lParam);
	ysizedClient = HIWORD (lParam);
	xsizedBlock = LOWORD (lParam) / (DIVISIONS + 2);
	ysizedBlock = HIWORD (lParam) / (DIVISIONS + 2);


	/*If we are actually sizing and not simply being restored from running OOM on a previous size attempt, see if there is enough memory for all the new bitmaps for the new size by trying to create temporary versions of all the bitmaps and DC's*/

	if ((!foomonsize) && (newarea > prevwarea) && (!ffirst)) {
	    if (!(hBoardtmpBitmap = CreateCompatibleBitmap(hDC,
	         xsizedClient, ysizedClient))) {
		foomonsize = 1;

	    }

	    if (!foomonsize)
		if (!(htmpBoardDC = CreateCompatibleDC(hDC))) {
		    foomonsize = 1;
		    DeleteObject(hBoardtmpBitmap);
		}

	    if (!foomonsize)
		if (!(hWtmpBitmap = CreateCompatibleBitmap(hDC,
		     xsizedClient, ysizedClient))) {
		    foomonsize = 1;
		    SelectObject(htmpBoardDC, hBoardtmpBitmap);
		    DeleteDC(htmpBoardDC);
		    DeleteObject(hBoardtmpBitmap);

		}


	    if (!foomonsize)
		if (!(htmpMemwinDC = CreateCompatibleDC(hDC))) {
		    foomonsize = 1;
		    SelectObject(htmpBoardDC, hBoardtmpBitmap);
		    DeleteDC(htmpBoardDC);
		    DeleteObject(hBoardtmpBitmap);
		    DeleteObject(hWtmpBitmap);
		}

	    if (!foomonsize)
		if (!(hInttmpBitmap = CreateCompatibleBitmap(hDC,
		     xsizedBlock * 4, ysizedBlock * 4))) {
		    foomonsize = 1;
		    SelectObject(htmpBoardDC, hBoardtmpBitmap);
		    DeleteDC(htmpBoardDC);
		    DeleteObject(hBoardtmpBitmap);
		    SelectObject(htmpMemwinDC, hWtmpBitmap);
		    DeleteDC(htmpMemwinDC);
		    DeleteObject(hWtmpBitmap);

		}

	    if (!foomonsize)
		if (!(htmpIntDC = CreateCompatibleDC(hDC))) {
		    foomonsize = 1;
		    SelectObject(htmpBoardDC, hBoardtmpBitmap);
		    DeleteDC(htmpBoardDC);
		    DeleteObject(hBoardtmpBitmap);
		    SelectObject(htmpMemwinDC, hWtmpBitmap);
		    DeleteDC(htmpMemwinDC);
		    DeleteObject(hWtmpBitmap);
		    DeleteObject(hInttmpBitmap);
		}


	    if (foomonsize)
		foomed = 1;




	    /*If there isn't enough memory do a MoveWindow to the old size, and break*/
	    if (foomonsize) {
		ReleaseDC(hWnd, hDC);
		MoveWindow(hWnd, prevxorg, prevyorg, prevwidth,
		     prevheight, TRUE);
		break;
	    }
	        /*If there IS enough memory, destroy the temp bitmaps and DC's and continue*/
	    else
	     {
		SelectObject(htmpBoardDC, hBoardtmpBitmap);
		DeleteDC(htmpBoardDC);
		DeleteObject(hBoardtmpBitmap);
		SelectObject(htmpMemwinDC, hWtmpBitmap);
		DeleteDC(htmpMemwinDC);
		DeleteObject(hWtmpBitmap);
		SelectObject(htmpIntDC, hInttmpBitmap);
		DeleteDC(htmpIntDC);
		DeleteObject(hInttmpBitmap);
	    }

	}/*End if not previous foomonsize and sizing smaller and not first time*/


	if ((!ffirst) && (!foomonsize))/*if this isn't the first start and we're not restoring from previous failed size */ {
	    SelectObject(hBoardDC, hOldBoardBitmap);
	    DeleteDC(hBoardDC);
	}

	if ((!ffirst) && (!foomonsize)) {
	    SelectObject(hIntDC, hOldIntBitmap);
	    DeleteDC(hIntDC);
	}

	if ((!ffirst) && (!foomonsize)) {
	    SelectObject(hMemwinDC, hOldWBitmap);
	    DeleteDC(hMemwinDC);
	}

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hWBitmap);

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hOldWBitmap);

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hIntBitmap);

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hOldIntBitmap);

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hBoardBitmap);

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hOldBoardBitmap);


	if ((!ffirst) && (!foomonsize)) /*this assumes the test for enough memory works and update the size of the client area*/ {

	    xBlock = LOWORD (lParam) / (DIVISIONS + 2);
	    yBlock = HIWORD (lParam) / (DIVISIONS + 2);
	    xClient = LOWORD (lParam);
	    yClient = HIWORD (lParam);
	    xEdge = xBlock / 4;
	    yEdge = yBlock / 4;
	    xShadow = xBlock / 10;
	    yShadow = yBlock / 10;
	    xHalf = xBlock / 2;
	    yHalf = yBlock / 2;
	    winxEdge = xBlock;
	    winyEdge = yBlock;

	}

	if ((!ffirst) && (!foomonsize))
	    if (!(hBoardBitmap = CreateCompatibleBitmap(hDC, xClient,
	         yClient))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;
	    }

	if ((!ffirst) && (!foomonsize))
	    if (!(hBoardDC = CreateCompatibleDC(hDC))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;

	    }

	if ((!ffirst) && (!foomonsize))
	    if (!(hMemwinDC = CreateCompatibleDC(hDC))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;

	    }

	if ((!ffirst) && (!foomonsize))
	    if (!(hWBitmap = CreateCompatibleBitmap(hDC, xClient,
	         yClient))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;

	    }


	if ((!ffirst) && (!foomonsize))
	    if (!(hIntDC = CreateCompatibleDC(hDC))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;

	    }

	if ((!ffirst) && (!foomonsize))
	    if (!(hIntBitmap = CreateCompatibleBitmap(hDC, xBlock
	        *4, yBlock * 4))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;

	    }

	if ((!ffirst) && (!foomonsize))
	    hOldBoardBitmap = SelectObject(hBoardDC, hBoardBitmap);

	if ((!ffirst) && (!foomonsize))
	    hOldIntBitmap = SelectObject(hIntDC, hIntBitmap);

	if ((!ffirst) && (!foomonsize))
	    hOldWBitmap = SelectObject(hMemwinDC, hWBitmap);

	foomonsize = 0;

	ffirst = 0;

	/*
	** We've successfully created all the bitmaps so this size
	** can be done without running out of memory.  Therefore, we'll
	** record the current size of the window in case it has to be
	** restored on a subsequent OOM due to a sizing of the window
	*/



	GetWindowRect(hWnd, (LPRECT) & r);
	prevxorg = r.left;
	prevyorg = r.top;
	prevwidth = max(r.right, r.left) - min(r.right, r.left);
	prevheight = max(r.bottom, r.top) - min(r.bottom, r.top);
	prevwarea = (LONG)LOWORD(lParam) * (LONG)HIWORD(lParam);

	ReleaseDC(hWnd, hDC);
	break ;

    case WM_MOVE:
	GetWindowRect(hWnd, (LPRECT) & r);
	prevxorg = r.left;
	prevyorg = r.top;
	break;



    case WM_MOUSEACTIVATE:
	fmousefocusd = 1;
	break;

    case WM_ERASEBKGND:
	if (fmousefocusd)
	    fignorelbutton = 1;
	break;

    case WM_LBUTTONDOWN:
	/*If we just got the erasebackground message due to activation via a mouse click, ignore all lbuttondowns until the window is painted */
	if (fignorelbutton == 1)
	    break;
	else
	    fmousefocusd = 0;

	hDC = GetDC(hWnd);

	xPoint = LOWORD(lParam);
	yPoint = HIWORD(lParam);

	if (foom == 1) {
	    MessageBox(hWnd, "Out of Memory", szAppName, MB_ICONASTERISK |
	        MB_OK);
	} else

	 {
	    /*If the mouse is clicked in to the left or above or to the right of or below the game board, we have to ignore*/
	    if (xPoint > winxEdge && yPoint > winyEdge && xPoint
	        < xBlock * 8 && yPoint < yBlock * 8) {
		ixdownblock = (xPoint / xBlock) - 1;
		iydownblock = (yPoint / yBlock) - 1;
	    } else
	     {
		ReleaseDC(hWnd, hDC);
		break;
	    }
	    /*check to see if the mouse location is on a chip*/

	    /* if it is on a chip, allow it to be moved*/
	    if (bState[ixdownblock][iydownblock]) {

		if ((ixdownblock > 1 && ixdownblock < 5) || (iydownblock
		    > 1 && iydownblock < 5)) {

		    BitBlt(hDC, ixdownblock * xBlock + winxEdge,
		         iydownblock * yBlock + winyEdge, xBlock, yBlock,
		         hBoardDC, ixdownblock * xBlock + winxEdge,
		         iydownblock * yBlock + winyEdge, SRCCOPY);
		    SelectObject(hMemwinDC, hWBitmap);
		    BitBlt(hMemwinDC, ixdownblock * xBlock + winxEdge,
		         iydownblock * yBlock + winyEdge, xBlock, yBlock,
		         hBoardDC, ixdownblock * xBlock + winxEdge,
		         iydownblock * yBlock + winyEdge, SRCCOPY);


		    fmovingchip = 1;

		    /*Capture all mouse messages */
		    SetCapture(hWnd);

		    /*erase the mouse cursor too */
		    bShow = 0;
		    ShowCursor(bShow);
		    SelectObject(hIntDC, hIntBitmap);
		    BitBlt(hIntDC, 0, 0, xBlock * 4, yBlock * 4,
		        hMemwinDC, xPoint - 2 * xBlock, yPoint - 2
		        *yBlock, SRCCOPY);

		    /* commented out the use of shadow while moving chips
		    SelectObject(hIntDC,hMedgrypen);
		    SelectObject(hIntDC,hMedgrybrush);
		    Ellipse(hIntDC,xBlock+xBlock/2+xEdge+2*xShadow, yBlock+yBlock/2+yEdge+2*yShadow, 2*xBlock+xBlock/2-xEdge+2*xShadow, 2*yBlock+yBlock/2-yEdge+2*yShadow);
		    */

		    SelectObject(hIntDC, hBlkpen);
		    SelectObject(hIntDC, hBbrush);
		    Ellipse(hIntDC, xBlock + xBlock / 2 + xEdge,
		         yBlock + yBlock / 2 + yEdge, 2 * xBlock +
		        xBlock / 2 - xEdge, 2 * yBlock + yBlock / 2
		        -yEdge);


		    SelectObject(hIntDC, hWpen);
		    Arc(hIntDC, xBlock + xBlock / 2 + xEdge + xShadow,
		         yBlock + yBlock / 2 + yEdge + yShadow, 2 *
		        xBlock + xBlock / 2 - xEdge - xShadow, 2 *
		        yBlock + yBlock / 2 - yEdge - yShadow, xBlock
		        + xBlock / 2 + xHalf, yBlock + yBlock / 2 +
		        yShadow, xBlock + xBlock / 2 + xShadow, yBlock
		        + yBlock / 2 + yHalf);

		    xPrevpoint = xPoint;
		    yPrevpoint = yPoint;
		}
	    }

	}
	ReleaseDC(hWnd, hDC);


	break;

    case WM_MOUSEMOVE:
	xPoint = LOWORD(lParam);
	yPoint = HIWORD(lParam);
	if (fmovingchip) {

	    if (xPoint > xLeft + xClient || xPoint < xLeft || yPoint
	        > yClient + yTop || yPoint < yTop) {
		/*  Do what we would do if it wasn't a valid destination .  This fixes the problem where moving the mouse outside the window causes us to lose the mouse cursor forever*/
		bShow = 1;
		ShowCursor(bShow);
		fmovingchip = 0;
		ReleaseCapture();
		x = ixdownblock;
		y = iydownblock;
		SelectObject(hMemwinDC, hWBitmap);

		SelectObject(hMemwinDC, hDkgrypen);
		SelectObject(hMemwinDC, hDkgrybrush);
		Ellipse(hMemwinDC, x * xBlock + xEdge + xShadow +
		    winxEdge, y * yBlock + yEdge + yShadow + winyEdge,
		     (x + 1) * xBlock - xEdge + xShadow + winxEdge,
		      (y + 1) * yBlock - yEdge + yShadow + winyEdge);

		SelectObject(hMemwinDC, hBlkpen);
		SelectObject(hMemwinDC, hBbrush);
		Ellipse(hMemwinDC, x * xBlock + xEdge + winxEdge,
		     y * yBlock + yEdge + winyEdge, (x + 1) * xBlock -
		    xEdge + winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

		SelectObject(hMemwinDC, hWpen);
		Arc(hMemwinDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge - yShadow + winyEdge , x *
		    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
		    winyEdge, x * xBlock + xShadow + winxEdge, y *
		    yBlock + yHalf + winyEdge);



		hDC = GetDC(hWnd);

		BitBlt(hDC, 0, 0, xClient, yClient, hMemwinDC,
		    0, 0, SRCCOPY);
		ReleaseDC(hWnd, hDC);

	    }

	}
	/*check if a chip is in a move state */
	if (fmovingchip) {
	    /* if it is, bitblt as the mouse moves */

	    hDC = GetDC(hWnd);

	    /* if we are moving the mouse too fast, we have to erase the old ellipse manually */
	    if ((xPrevpoint > xPoint + xBlock) || (xPoint > xPrevpoint
	        + xBlock) || (yPrevpoint > yPoint + yBlock) || (yPoint
	        > yBlock + yPrevpoint)) {
                SelectObject(hIntDC, hIntBitmap);
                BitBlt(hIntDC, 0, 0, xBlock * 2, yBlock * 2, hMemwinDC,
		     xPrevpoint - xBlock, yPrevpoint - yBlock, SRCCOPY);

		BitBlt(hDC, xPrevpoint - xBlock, yPrevpoint - yBlock,
                     xBlock * 2, yBlock * 2, hIntDC, 0, 0, SRCCOPY);
            }



            SelectObject(hIntDC, hIntBitmap);
            BitBlt(hIntDC, 0, 0, xBlock * 4, yBlock * 4, hMemwinDC,
	         xPoint - 2 * xBlock, yPoint - 2 * yBlock, SRCCOPY);

	    /* Commented out shadow while moving *****
	    SelectObject(hIntDC,hmedgrypen);
	    SelectObject(hIntDC,hMedgrybrush);
	    Ellipse(hIntDC,xBlock+xBlock/2+xEdge+2*xShadow, yBlock+yBlock/2+yEdge+2*yShadow, 2*xBlock+xBlock/2-xEdge+2*xShadow, 2*yBlock+yBlock/2-yEdge+2*yShadow);

	    */

	    SelectObject(hIntDC, hBlkpen);
	    SelectObject(hIntDC, hBbrush);
	    Ellipse(hIntDC, xBlock + xBlock / 2 + xEdge, yBlock
	        + yBlock / 2 + yEdge, 2 * xBlock + xBlock / 2 - xEdge,
	         2 * yBlock + yBlock / 2 - yEdge);

	    SelectObject(hIntDC, hWpen);
	    Arc(hIntDC, xBlock + xBlock / 2 + xEdge + xShadow,
	        yBlock + yBlock / 2 + yEdge + yShadow, 2 * xBlock +
	        xBlock / 2 - xEdge - xShadow, 2 * yBlock + yBlock /
	        2 - yEdge - yShadow, xBlock + xBlock / 2 + xHalf, yBlock
	        + yBlock / 2 + yShadow, xBlock + xBlock / 2 + xShadow,
	         yBlock + yBlock / 2 + yHalf);


            BitBlt(hDC, xPoint - 2 * xBlock, yPoint - 2 * yBlock,
	         xBlock * 4, yBlock * 4, hIntDC, 0, 0, SRCCOPY);

	    ReleaseDC(hWnd, hDC);
	    xPrevpoint = xPoint;
	    yPrevpoint = yPoint;
	}

	break ;


    case WM_LBUTTONUP:
	xUp = LOWORD (lParam);
	yUp = HIWORD (lParam);


	/* if we were in a button move state */

	if (fmovingchip) {

	    ixupblock = xUp / xBlock - 1;
	    iyupblock = yUp / yBlock - 1;
	    ReleaseCapture();
	    checkfvmove();



	    /*and if it was a valid destination */

	    if ((!bState[ixupblock][iyupblock]) && (!(ixupblock
	        < 2 && iyupblock < 2)) && (!(ixupblock > 4 && iyupblock
	        > 4)) && (!(ixupblock < 2 && iyupblock > 4)) && (!(ixupblock
	        > 4 && iyupblock < 2)) && fvalidmove &&  ( xUp > winxEdge) &&
	        ( yUp > winyEdge) &&
	        ( xUp < xBlock * 8) &&
	        ( yUp < yBlock * 8)
	        ) {
		/*
		** adjust the chip in the valid destination rectangle
		** on the screen and on the memory device context, erase
		** the chip that was jumped- on the screen and in the
		** WinMemDC,set fmovingchip to false, and check to see
		** if there are any more valid moves.  If t here aren't,
		** message and show score
		*/

		hDC = GetDC(hWnd);


		/*erase the chip at its current location*/
		BitBlt(hDC, xUp - xBlock / 2 , yUp - yBlock / 2 ,
		     xBlock, yBlock, hMemwinDC, xUp - xBlock / 2 ,
		    yUp - yBlock / 2 , SRCCOPY);

		/*center the chip at the new destination */
		x = ixupblock;
		y = iyupblock;



                /* Draw the peg at its new location */
		SelectObject(hDC, hDkgrypen);
		SelectObject(hDC, hDkgrybrush);
		Ellipse(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge + xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge + yShadow + winyEdge);

		SelectObject(hDC, hBlkpen);
		SelectObject(hDC, hBbrush);
		Ellipse(hDC, x * xBlock + xEdge + winxEdge, y *
		    yBlock + yEdge + winyEdge, (x + 1) * xBlock - xEdge +
		    winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

		SelectObject(hDC, hWpen);
		Arc(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge - yShadow + winyEdge , x *
		    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
		    winyEdge, x * xBlock + xShadow + winxEdge, y *
		    yBlock + yHalf + winyEdge);




		/*erase the jumped chip */
		BitBlt(hDC, xBlock * ixkilledblock + winxEdge,
		    yBlock * iykilledblock + winyEdge, xBlock, yBlock,
		     hBoardDC, xBlock * ixkilledblock + winxEdge, yBlock
		    *iykilledblock + winyEdge , SRCCOPY);
		ReleaseDC(hWnd, hDC);



                /*center the chip in the memory dc as well*/
#ifdef OLDWAY
		SelectObject(hMemwinDC, hWBitmap);
		BitBlt(hMemwinDC, xBlock * ixupblock + winxEdge,
		     yBlock * iyupblock + winyEdge, xBlock, yBlock,
		     hDC, xBlock * ixupblock + winxEdge, yBlock * iyupblock +
		    winyEdge , SRCCOPY);
#endif


                /* Draw the peg at its new location in the memory DC*/
                SelectObject(hMemwinDC, hDkgrypen);
                SelectObject(hMemwinDC, hDkgrybrush);
                Ellipse(hMemwinDC, x * xBlock + xEdge + xShadow + winxEdge,
                     y * yBlock + yEdge + yShadow + winyEdge, (x +
                    1) * xBlock - xEdge + xShadow + winxEdge,  (y +
                    1) * yBlock - yEdge + yShadow + winyEdge);

                SelectObject(hMemwinDC, hBlkpen);
                SelectObject(hMemwinDC, hBbrush);
                Ellipse(hMemwinDC, x * xBlock + xEdge + winxEdge, y *
                    yBlock + yEdge + winyEdge, (x + 1) * xBlock - xEdge +
                    winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

                SelectObject(hMemwinDC, hWpen);
                Arc(hMemwinDC, x * xBlock + xEdge + xShadow + winxEdge,
                     y * yBlock + yEdge + yShadow + winyEdge, (x +
                    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
                    1) * yBlock - yEdge - yShadow + winyEdge , x *
                    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
                    winyEdge, x * xBlock + xShadow + winxEdge, y *
                    yBlock + yHalf + winyEdge);




		/*erase the jumped chip in memory DC*/
		BitBlt(hMemwinDC, xBlock * ixkilledblock + winxEdge,
		     yBlock * iykilledblock + winyEdge, xBlock, yBlock,
		     hBoardDC, xBlock * ixkilledblock + winxEdge, yBlock
		    *iykilledblock + winyEdge , SRCCOPY);




		/*update the data structure */

		bState[ixdownblock][iydownblock] = 0;

		bState[ixupblock][iyupblock] = 1;

		bState[ixkilledblock][iykilledblock] = 0;

		/*record move in array list */
		move[m].xsource = ixdownblock;
		move[m].ysource = iydownblock;
		move[m].xdest = ixupblock;
		move[m].ydest = iyupblock;
		move[m].xjumped = ixkilledblock;
		move[m].yjumped = iykilledblock;
		++m;
		/*
		ixvdownblock=ixdownblock;
		ixvupblock=ixupblock;
		ixvkilledblock=ixkilledblock;
		*/


		/* Check if there are anymore valid moves*/
		bShow = 1;
		ShowCursor(bShow);

		fanymoremoves = 0;
		checkfanymoves();
		if (fanymoremoves == 0) {/* if there aren't - declare game at an end and score */

		    /*add up the remaining chips*/
		    ntotal = 0;
		    for (j = 0; j < 7; ++j)
			for (k = 0; k < 7; ++k)
			    ntotal += bState[j][k];

		    if (ntotal > 1)
			MessageBox(hWnd, "Game Over", szAppName,
			     MB_ICONASTERISK | MB_OK);
		    else
			MessageBox(hWnd, "You Win!", szAppName,
			     MB_ICONASTERISK | MB_OK);


		}



	    }
	        else /*it wasn't a valid destination */ {
		/*put a chip back in the original location */
		hDC = GetDC(hWnd);
		/*erase the current chip on screen*/
		BitBlt(hDC, xUp - xBlock / 2 , yUp - yBlock / 2 ,
		     xBlock, yBlock, hMemwinDC, xUp - xBlock / 2 ,
		    yUp - yBlock / 2 , SRCCOPY);

		/*Draw the chip back at the original location*/
		x = ixdownblock;
		y = iydownblock;


		SelectObject(hDC, hDkgrypen);
		SelectObject(hDC, hDkgrybrush);
		Ellipse(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge + xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge + yShadow + winyEdge);

		SelectObject(hDC, hBlkpen);
		SelectObject(hDC, hBbrush);
		Ellipse(hDC, x * xBlock + xEdge + winxEdge, y *
		    yBlock + yEdge + winyEdge, (x + 1) * xBlock - xEdge +
		    winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

		SelectObject(hDC, hWpen);
		Arc(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge - yShadow + winyEdge , x *
		    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
		    winyEdge, x * xBlock + xShadow + winxEdge, y *
		    yBlock + yHalf + winyEdge);

		SelectObject(hMemwinDC, hWBitmap);
		BitBlt(hMemwinDC, ixdownblock * xBlock + winxEdge,
		     iydownblock * yBlock + winyEdge, xBlock, yBlock,
		     hDC, ixdownblock * xBlock + winxEdge, iydownblock
		    *yBlock + winyEdge , SRCCOPY);

		bShow = 1;
		ShowCursor(bShow);

		ReleaseDC(hWnd, hDC);
	    }

	    fmovingchip = 0;

	    fvalidmove = 0;


	}


	/*
	** if we aren't at a valid destination, take the chip back to
	** the original rectangle in the window DC, restore the original
	** whole-window-Mem-DC as well,and restore the destination area,
	** and show an error message, and set fmovingchip to false
	*/

	break;

    case WM_PAINT:

	hDC = BeginPaint (hWnd, &ps);

	/*Draw the board with holes in it in memory*/

	SelectObject(hDC, hLtgrypen);
	SelectObject(hDC, hLtgrybrush);
	Rectangle(hDC, 0, 0, xClient, yClient);

	SelectObject(hMemwinDC, hWBitmap);





	SelectObject(hMemwinDC, hBlkpen);
	SelectObject(hMemwinDC, hLtgrybrush);
	Rectangle(hMemwinDC, 0, 0, xClient, yClient);

	/*Draw shadows on playing board on right and bottom edges*/
	SelectObject(hMemwinDC, hThkdkgrypen);
	(VOID)MMoveTo(hMemwinDC, winxEdge + 1, yBlock * 5 + winyEdge
	    + 1);
	LineTo(hMemwinDC, xBlock * 2 + winxEdge - 1, yBlock * 5 +
	    winyEdge + 1);

	(VOID)MMoveTo(hMemwinDC, xBlock * 2 + winxEdge, yBlock
	    *7 + winyEdge + 1);
	LineTo(hMemwinDC, xBlock * 5 + winxEdge, yBlock * 7 + winyEdge
	    + 1);

	(VOID)MMoveTo(hMemwinDC, xBlock * 5 + winxEdge + 1, yBlock
	    *7 + winyEdge + 1);
	LineTo(hMemwinDC, xBlock * 5 + winxEdge + 1, yBlock * 5 +
	    winyEdge + 1);

	(VOID)MMoveTo(hMemwinDC, xBlock * 5 + winxEdge + 1, yBlock
	    *5 + winyEdge + 1);
	LineTo(hMemwinDC, xBlock * 7 + winxEdge + 1, yBlock * 5 +
	    winyEdge + 1);

	(VOID)MMoveTo(hMemwinDC, xBlock * 5 + winxEdge + 1, yBlock
	    *2 + winyEdge - 1);
	LineTo(hMemwinDC, xBlock * 5 + winxEdge + 1, winyEdge);

	(VOID)MMoveTo(hMemwinDC, xBlock * 7 + winxEdge + 1, yBlock
	    *2 + winyEdge + 1);
	LineTo(hMemwinDC, xBlock * 7 + winxEdge + 1, yBlock * 5 +
	    winyEdge + 1);

	SelectObject(hMemwinDC, hWpen);

	(VOID)MMoveTo(hMemwinDC, winxEdge - 1, yBlock * 2 + winyEdge);
	LineTo(hMemwinDC, winxEdge - 1, yBlock * 5 + winyEdge -
	    1);

	(VOID)MMoveTo(hMemwinDC, winxEdge, yBlock * 2 - 1 + winyEdge);
	LineTo(hMemwinDC, xBlock * 2 - 1 + winxEdge, yBlock * 2
	    -1 + winyEdge);

	(VOID)MMoveTo(hMemwinDC, xBlock * 2 - 1 + winxEdge, yBlock
	    *2 + winyEdge - 1);
	LineTo(hMemwinDC, xBlock * 2 - 1 + winxEdge, yBlock * 0 +
	    winyEdge);

	(VOID)MMoveTo(hMemwinDC, xBlock * 2 + winxEdge, winyEdge -
	    1);
	LineTo(hMemwinDC, xBlock * 5 - 1 + winxEdge, winyEdge -
	    1);

	(VOID)MMoveTo(hMemwinDC, xBlock * 5 + 2 + winxEdge, yBlock
	    *2 - 1 + winyEdge);
	LineTo(hMemwinDC, xBlock * 7 + winxEdge, yBlock * 2 - 1 +
	    winyEdge);

	(VOID)MMoveTo(hMemwinDC, xBlock * 2 - 1 + winxEdge, yBlock
	    *5 + 1 + winyEdge);
	LineTo(hMemwinDC, xBlock * 2 - 1 + winxEdge, yBlock * 7 -
	    1 + winyEdge);

	/* Draw the holes*/

	SelectObject(hMemwinDC, hBlkpen);
	for (x = 0; x < DIVISIONS; x++)
	    for (y = 0; y < DIVISIONS; y++) {
		if ((x > 1 && x < 5) || (y > 1 && y < 5)) {

		    Arc(hMemwinDC, x * xBlock + xEdge + winxEdge,
		         y * yBlock + yEdge + winyEdge, (x + 1) * xBlock
		        -xEdge + winxEdge, (y + 1) * yBlock - yEdge +
		        winyEdge, (x + 1) * xBlock - 3 * xEdge / 2 +
		        winxEdge, y * yBlock + 3 * yEdge / 2 + winyEdge,
		         x * xBlock + 3 * xEdge / 2 + winxEdge, (y
		        + 1) * yBlock - 3 * yEdge / 2 + winyEdge);

		}
	    }


	SelectObject(hMemwinDC, hLtwpen);

	for (x = 0; x < DIVISIONS; x++)
	    for (y = 0; y < DIVISIONS; y++) {
		if ((x > 1 && x < 5) || (y > 1 && y < 5)) {
		    Arc(hMemwinDC, x * xBlock + xEdge + winxEdge,
		         y * yBlock + yEdge + winyEdge, (x + 1) * xBlock
		        -xEdge + winxEdge, (y + 1) * yBlock - yEdge +
		        winyEdge, x * xBlock + 3 * xEdge / 2 + winxEdge,
		         (y + 1) * yBlock - 3 * yEdge / 2 + winyEdge,
		         (x + 1) * xBlock - 3 * xEdge / 2 + winxEdge,
		         y * yBlock + 3 * yEdge / 2 + winyEdge);

		}
	    }


	BitBlt(hDC, 0, 0, xClient, yClient, hMemwinDC , 0, 0, SRCCOPY);

	/*Get a picture of an empty board*/
	SelectObject(hBoardDC, hBoardBitmap);
	BitBlt(hBoardDC, 0, 0, xClient, yClient, hMemwinDC , 0,
	     0, SRCCOPY);




	for (x = 0; x < DIVISIONS; x++)
	    for (y = 0; y < DIVISIONS; y++) {
		if (bState[x][y]) {


		    SelectObject(hDC, hDkgrypen);
		    SelectObject(hDC, hDkgrybrush);
		    Ellipse(hDC, x * xBlock + xEdge + xShadow +
		        winxEdge, y * yBlock + yEdge + yShadow + winyEdge,
		         (x + 1) * xBlock - xEdge + xShadow + winxEdge,
		          (y + 1) * yBlock - yEdge + yShadow + winyEdge);

		    SelectObject(hDC, hBlkpen);
		    SelectObject(hDC, hBbrush);
		    Ellipse(hDC, x * xBlock + xEdge + winxEdge,
		         y * yBlock + yEdge + winyEdge, (x + 1) * xBlock -
		        xEdge + winxEdge,  (y + 1) * yBlock - yEdge +
		        winyEdge);

		    SelectObject(hDC, hWpen);
		    Arc(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		         y * yBlock + yEdge + yShadow + winyEdge, (x
		        + 1) * xBlock - xEdge - xShadow + winxEdge,
		          (y + 1) * yBlock - yEdge - yShadow + winyEdge ,
		         x * xBlock + xHalf + winxEdge , y * yBlock +
		        yShadow + winyEdge, x * xBlock + xShadow +
		        winxEdge, y * yBlock + yHalf + winyEdge);

		}
	    }

	BitBlt(hMemwinDC, 0, 0, xClient, yClient, hDC, 0, 0, SRCCOPY);


	EndPaint(hWnd, &ps);
	fignorelbutton = 0;
	fmousefocusd = 0;

	if (foomed) {
	    MessageBox(hWnd, "Not Enough Memory to Re-size Window",
	         szAppName, MB_ICONASTERISK | MB_OK);
	    foomed = 0;
	}

	break;

    case WM_DESTROY:
	if (hBitmap)
	    DeleteObject (hBitmap) ;
	KillTimer (hWnd, 1) ;


	SelectObject(hIntDC, hOldIntBitmap);
	DeleteDC(hIntDC);

	SelectObject(hMemwinDC, hOldWBitmap);
	DeleteDC(hMemwinDC);

	SelectObject(hBoardDC, hOldBoardBitmap);
	DeleteDC(hBoardDC);

	DeleteObject(hBoardBitmap);
	DeleteObject(hOldBoardBitmap);

	DeleteObject(hWBitmap);
	DeleteObject(hOldWBitmap);


	DeleteObject(hIntBitmap);
	DeleteObject(hOldIntBitmap);

	DeleteObject(hBbrush);
	DeleteObject(hBlkpen);
	DeleteObject(hBlkbrush);
	DeleteObject(hDkgrybrush);
	DeleteObject(hDkgrypen);
	DeleteObject(hGbrush);
	DeleteObject(hMedgrypen);
	DeleteObject(hMedgrybrush);
	DeleteObject(hLtgrybrush);
	DeleteObject(hLtgrypen);
	DeleteObject(hLtwpen);

	DeleteObject(hThkdkgrypen);
	DeleteObject(hWpen);
	DeleteObject(hYbrush);

	WinHelp(hWnd, HELP_FILE, HELP_QUIT, (ULONG_PTR) NULL);

	switch (wprevmenuitem) {
	case 3:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR) "Option",
	         (LPSTR)"3", (LPSTR)"entpack.ini"  );
	    break;

	case 4:
	    WritePrivateProfileString( (LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR) "4", (LPSTR)"entpack.ini"  );
	    break;

	case 5:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"5", (LPSTR)"entpack.ini"  );
	    break;

	case 6:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"6", (LPSTR)"entpack.ini"  );
	    break;

	case 7:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"7", (LPSTR)"entpack.ini");
	    break;

	case 8:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"8", (LPSTR)"entpack.ini");
	    break;

	case 9:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"9", (LPSTR)"entpack.ini");
	    break;

	default:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"3", (LPSTR)"entpack.ini"  );
	    break;
	}
	PostQuitMessage (0) ;
	break ;

    default:
	return DefWindowProc (hWnd, iMessage, wParam, lParam) ;
    }
    return 0L ;
}


VOID checkfvmove()


{
    if (ixupblock == ixdownblock)
	if ((iyupblock == iydownblock - 2) || (iyupblock == iydownblock +
	    2)) {
	    ixjumpedblock = ixupblock;
	    if (iyupblock == iydownblock - 2)
		iyjumpedblock = iydownblock - 1;
	    if (iyupblock == iydownblock + 2)
		iyjumpedblock = iydownblock + 1;

	    if (bState[ixjumpedblock][iyjumpedblock]) {
		fvalidmove = 1;
		ixkilledblock = ixupblock;
		if (iyupblock == iydownblock - 2)
		    iykilledblock = iydownblock - 1;
		if (iyupblock == iydownblock + 2)
		    iykilledblock = iydownblock + 1;
	    }
	}
    if (iyupblock == iydownblock)
	if ((ixupblock == ixdownblock - 2) || (ixupblock == ixdownblock +
	    2)) {
	    iyjumpedblock = iyupblock;
	    if (ixupblock == ixdownblock - 2)
		ixjumpedblock = ixdownblock - 1;
	    if (ixupblock == ixdownblock + 2)
		ixjumpedblock = ixdownblock + 1;


	    if (bState[ixjumpedblock][iyjumpedblock]) {
		fvalidmove = 1;
		iykilledblock = iyupblock;
		if (ixupblock == ixdownblock - 2)
		    ixkilledblock = ixdownblock - 1;
		if (ixupblock == ixdownblock + 2)
		    ixkilledblock = ixdownblock + 1;
	    }
	}
    return;


}


VOID checkfanymoves()
{
    /*corners*/
    if (bState[2][0]) {
	if (bState[3][0])
	    if (!bState[4][0])
		fanymoremoves = 1;
	if (bState[2][1])
	    if (!bState[2][2])
		fanymoremoves = 1;
    }


    if (bState[4][0]) {
	if (bState[3][0])
	    if (!bState[2][0])
		fanymoremoves = 1;
	if (bState[4][1])
	    if (!bState[4][2])
		fanymoremoves = 1;
    }

    if (bState[0][2]) {
	if (bState[1][2])
	    if (!bState[2][2])
		fanymoremoves = 1;
	if (bState[0][3])
	    if (!bState[0][4])
		fanymoremoves = 1;
    }


    if (bState[0][4]) {
	if (bState[0][3])
	    if (!bState[0][2])
		fanymoremoves = 1;
	if (bState[1][4])
	    if (!bState[2][4])
		fanymoremoves = 1;
    }

    if (bState[2][6]) {
	if (bState[3][6])
	    if (!bState[4][6])
		fanymoremoves = 1;
	if (bState[2][5])
	    if (!bState[2][4])
		fanymoremoves = 1;
    }

    if (bState[4][6]) {
	if (bState[3][6])
	    if (!bState[2][6])
		fanymoremoves = 1;
	if (bState[4][5])
	    if (!bState[4][4])
		fanymoremoves = 1;
    }

    if (bState[6][4]) {
	if (bState[5][4])
	    if (!bState[4][4])
		fanymoremoves = 1;
	if (bState[6][3])
	    if (!bState[6][2])
		fanymoremoves = 1;
    }

    if (bState[6][2]) {
	if (bState[5][2])
	    if (!bState[4][2])
		fanymoremoves = 1;
	if (bState[6][3])
	    if (!bState[6][4])
		fanymoremoves = 1;
    }

    /* center ends */

    if (bState[3][0]) {
	if (bState[3][1])
	    if (!bState[3][2])
		fanymoremoves = 1;
    }

    if (bState[0][3]) {
	if (bState[1][3])
	    if (!bState[2][3])
		fanymoremoves = 1;
    }

    if (bState[3][6]) {
	if (bState[3][5])
	    if (!bState[3][4])
		fanymoremoves = 1;
    }

    if (bState[6][3]) {
	if (bState[5][3])
	    if (!bState[4][3])
		fanymoremoves = 1;
    }

    /*center sides */
    if (bState[2][1]) {
	if (bState[3][1])
	    if (!bState[4][1])
		fanymoremoves = 1;
	if (bState[2][2])
	    if (!bState[2][3])
		fanymoremoves = 1;
    }

    if (bState[1][2]) {
	if (bState[2][2])
	    if (!bState[3][2])
		fanymoremoves = 1;
	if (bState[1][3])
	    if (!bState[1][4])
		fanymoremoves = 1;
    }
    if (bState[1][4]) {
	if (bState[2][4])
	    if (!bState[3][4])
		fanymoremoves = 1;
	if (bState[1][3])
	    if (!bState[1][2])
		fanymoremoves = 1;
    }
    if (bState[2][5]) {
	if (bState[3][5])
	    if (!bState[4][5])
		fanymoremoves = 1;
	if (bState[2][4])
	    if (!bState[2][3])
		fanymoremoves = 1;
    }
    if (bState[4][5]) {
	if (bState[3][5])
	    if (!bState[2][5])
		fanymoremoves = 1;
	if (bState[4][4])
	    if (!bState[4][3])
		fanymoremoves = 1;
    }
    if (bState[5][4]) {
	if (bState[4][4])
	    if (!bState[3][4])
		fanymoremoves = 1;
	if (bState[5][3])
	    if (!bState[5][2])
		fanymoremoves = 1;
    }
    if (bState[5][2]) {
	if (bState[4][2])
	    if (!bState[3][2])
		fanymoremoves = 1;
	if (bState[5][3])
	    if (!bState[5][4])
		fanymoremoves = 1;
    }
    if (bState[4][1]) {
	if (bState[3][1])
	    if (!bState[2][1])
		fanymoremoves = 1;
	if (bState[4][2])
	    if (!bState[4][3])
		fanymoremoves = 1;
    }

    /* inside center arms */

    if (bState[3][1]) {
	if (bState[3][2])
	    if (!bState[3][3])
		fanymoremoves = 1;
    }

    if (bState[1][3]) {
	if (bState[2][3])
	    if (!bState[3][3])
		fanymoremoves = 1;
    }

    if (bState[3][5]) {
	if (bState[3][4])
	    if (!bState[3][3])
		fanymoremoves = 1;
    }

    if (bState[5][3]) {
	if (bState[4][3])
	    if (!bState[3][3])
		fanymoremoves = 1;
    }


    /*Center 9 squares */
    if (bState[2][2]) {
	if (bState[1][2])
	    if (!bState[0][2])
		fanymoremoves = 1;
	if (bState[3][2])
	    if (!bState[4][2])
		fanymoremoves = 1;
	if (bState[2][1])
	    if (!bState[2][0])
		fanymoremoves = 1;
	if (bState[2][3])
	    if (!bState[2][4])
		fanymoremoves = 1;
    }
    if (bState[3][2]) {
	if (bState[2][2])
	    if (!bState[2][1])
		fanymoremoves = 1;
	if (bState[4][2])
	    if (!bState[5][2])
		fanymoremoves = 1;
	if (bState[3][1])
	    if (!bState[3][0])
		fanymoremoves = 1;
	if (bState[3][3])
	    if (!bState[3][4])
		fanymoremoves = 1;
    }
    if (bState[4][2]) {
	if (bState[3][2])
	    if (!bState[2][2])
		fanymoremoves = 1;
	if (bState[5][2])
	    if (!bState[6][2])
		fanymoremoves = 1;
	if (bState[4][1])
	    if (!bState[4][0])
		fanymoremoves = 1;
	if (bState[4][3])
	    if (!bState[4][4])
		fanymoremoves = 1;
    }
    if (bState[2][3]) {
	if (bState[1][3])
	    if (!bState[0][3])
		fanymoremoves = 1;
	if (bState[3][3])
	    if (!bState[4][3])
		fanymoremoves = 1;
	if (bState[2][2])
	    if (!bState[2][1])
		fanymoremoves = 1;
	if (bState[2][4])
	    if (!bState[2][5])
		fanymoremoves = 1;
    }
    if (bState[2][4]) {
	if (bState[1][4])
	    if (!bState[0][4])
		fanymoremoves = 1;
	if (bState[3][4])
	    if (!bState[4][4])
		fanymoremoves = 1;
	if (bState[2][3])
	    if (!bState[2][2])
		fanymoremoves = 1;
	if (bState[2][5])
	    if (!bState[2][6])
		fanymoremoves = 1;
    }
    if (bState[3][4]) {
	if (bState[2][4])
	    if (!bState[1][4])
		fanymoremoves = 1;
	if (bState[4][4])
	    if (!bState[5][4])
		fanymoremoves = 1;
	if (bState[3][3])
	    if (!bState[3][2])
		fanymoremoves = 1;
	if (bState[3][5])
	    if (!bState[3][6])
		fanymoremoves = 1;
    }
    if (bState[4][4]) {
	if (bState[3][4])
	    if (!bState[2][4])
		fanymoremoves = 1;
	if (bState[5][4])
	    if (!bState[6][4])
		fanymoremoves = 1;
	if (bState[4][3])
	    if (!bState[4][2])
		fanymoremoves = 1;
	if (bState[4][5])
	    if (!bState[4][6])
		fanymoremoves = 1;
    }
    if (bState[4][3]) {
	if (bState[3][3])
	    if (!bState[2][3])
		fanymoremoves = 1;
	if (bState[5][3])
	    if (!bState[6][3])
		fanymoremoves = 1;
	if (bState[4][2])
	    if (!bState[4][1])
		fanymoremoves = 1;
	if (bState[4][4])
	    if (!bState[4][5])
		fanymoremoves = 1;
    }
    if (bState[3][3]) {
	if (bState[2][3])
	    if (!bState[1][3])
		fanymoremoves = 1;
	if (bState[4][3])
	    if (!bState[5][3])
		fanymoremoves = 1;
	if (bState[3][2])
	    if (!bState[3][1])
		fanymoremoves = 1;
	if (bState[3][4])
	    if (!bState[3][5])
		fanymoremoves = 1;
    }







}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\freecell\transfer.c ===
/****************************************************************************

Transfer.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32

Routines for transfering cards and queing cards for transfer are here.

****************************************************************************/

#include "freecell.h"
#include "freecons.h"
#include <assert.h>
#include <memory.h>


/****************************************************************************

Transfer

This function actually moves the cards.  It both updates the card array,
and draws the bitmaps.  Note that it moves only one card per call.

****************************************************************************/

VOID Transfer(HWND hWnd, UINT fcol, UINT fpos, UINT tcol, UINT tpos)
{
    CARD    c;
    HDC     hDC;

    DEBUGMSG(TEXT("Transfer request from (%u, "), fcol);
    DEBUGMSG(TEXT("%u) to ("), fpos);
    DEBUGMSG(TEXT("%u, "), tcol);
    DEBUGMSG(TEXT("%u)\r\n"), tpos);

    assert(fpos < MAXPOS);
    assert(tpos < MAXPOS);

    UpdateWindow(hWnd);     // ensure cards are drawn before animation starts

    if (fcol == TOPROW)     // can't transfer FROM home cells
    {
        if ((fpos > 3) || (card[TOPROW][fpos] == IDGHOST))
            return;
    }
    else
    {
        if ((fpos = FindLastPos(fcol)) == EMPTY)    // or from empty column
            return;

        if (fcol == tcol)               // click and release on same column
        {
            hDC = GetDC(hWnd);
            DrawCard(hDC, fcol, fpos, card[fcol][fpos], FACEUP);
            ReleaseDC(hWnd, hDC);
            return;
        }
    }

    if (tcol == TOPROW)
    {
        if (tpos > 3)                       // if move to home cell
        {
            wCardCount--;
            DisplayCardCount(hWnd);         // update display
            c = card[fcol][fpos];
            home[SUIT(c)] = VALUE(c);       // new card at top of home[suit]
        }
    }
    else
        tpos = FindLastPos(tcol) + 1;       // bottom of column

    Glide(hWnd, fcol, fpos, tcol, tpos);    // send the card on its way

    c = card[fcol][fpos];
    card[fcol][fpos] = EMPTY;
    card[tcol][tpos] = c;

    /* If ACE being moved to home cell, update homesuit array. */

    if (VALUE(c) == ACE && tcol == TOPROW && tpos > 3)
        homesuit[SUIT(c)] = tpos;

    if (tcol == TOPROW)
    {
        hDC = GetDC(hWnd);
        DrawKing(hDC, tpos < 4 ? LEFT : RIGHT, TRUE);
        ReleaseDC(hWnd, hDC);
    }
}


/******************************************************************************

MoveCol

User has requested a multi-card move to an empty column

******************************************************************************/

VOID MoveCol(UINT fcol, UINT tcol)
{
    UINT freecells;                     // number of free cells
    CARD free[4];                       // locations of free cells
    UINT trans;                         // number to transfer
    INT  i;                             // counter

    assert(fcol != TOPROW);
    assert(tcol != TOPROW);
    assert(card[fcol][0] != EMPTY);

    /* Count number of free cells and put locations in free[] */

    freecells = 0;
    for (i = 0; i < 4; i++)
    {
        if (card[TOPROW][i] == EMPTY)
        {
            free[freecells] = i;
            freecells++;
        }
    }

    /* Find number of cards to transfer */

    if (fcol == TOPROW || tcol == TOPROW)
        trans = 1;
    else
        trans = NumberToTransfer(fcol, tcol);

    if (trans > (freecells+1))                    // don't transfer too many
        trans = freecells+1;

    /* Move to free cells */

    trans--;
    for (i = 0; i < (INT)trans; i++)
        QueueTransfer(fcol, 0, TOPROW, free[i]);

    /* Transfer last card directly */

    QueueTransfer(fcol, 0, tcol, 0);

    /* transfer from free cells to column */

    for (i = trans-1; i >= 0; i--)
        QueueTransfer(TOPROW, free[i], tcol, 0);
}


/******************************************************************************

MultiMove

User has chosen to move from one non-empty column to another.

******************************************************************************/

VOID MultiMove(UINT fcol, UINT tcol)
{
    CARD free[4];                       // locations of free cells
    UINT freecol[MAXCOL];               // locations of free columns
    UINT freecells;                     // number of free cells
    UINT trans;                         // number to transfer
    UINT col, pos;
    INT  i;                             // counter

    assert(fcol != TOPROW);
    assert(tcol != TOPROW);
    assert(card[fcol][0] != EMPTY);

    /* Count number of free cells and put locations in free[] */

    freecells = 0;
    for (pos = 0; pos < 4; pos++)
    {
        if (card[TOPROW][pos] == EMPTY)
        {
            free[freecells] = pos;
            freecells++;
        }
    }

    /* Find the number of cards to move.  If the number is too big to
       move all at once, push partial results into available columns. */

    trans = NumberToTransfer(fcol, tcol);
    if (trans > (freecells+1))
    {
        i = 0;
        for (col = 1; col < MAXCOL; col++)
            if (card[col][0] == EMPTY)
                freecol[i++] = col;

        /* transfer into free columns until direct transfer can be made */

        i = 0;
        while (trans > (freecells + 1))
        {
            MoveCol(fcol, freecol[i]);
            trans -= (freecells + 1);
            i++;
        }

        MoveCol(fcol, tcol);                    // do last transfer directly

        for (i--; i >= 0; i--)                  // gather cards in free cells
            MoveCol(freecol[i], tcol);
    }
    else                                        // else all one MoveCol()
    {
        MoveCol(fcol, tcol);
    }
}


/****************************************************************************

QueueTransfer

In order that multi-card moves happen slowly enough for the user to
watch, they are not moved as soon as they are calculated.  Instead,
they first are queued using this function into the movelist array.

After the request is queued, the card array is updated to reflect the
request.  This is ok because the card array is saved away in shadow
temporarily.  The same logic as in Transfer() is used to update card.

****************************************************************************/

VOID QueueTransfer(UINT fcol, UINT fpos, UINT tcol, UINT tpos)
{
    CARD    c;
    MOVE    move;

    assert(moveindex < MAXMOVELIST);
    assert(fpos < MAXPOS);
    assert(tpos < MAXPOS);

    move.fcol = fcol;               // package move request into MOVE type
    move.fpos = fpos;
    move.tcol = tcol;
    move.tpos = tpos;
    movelist[moveindex++] = move;   // store request in array and update index

    /* Now update card array if necessary. */

    if (fcol == TOPROW)
    {
        if ((fpos > 3) || (card[TOPROW][fpos] == IDGHOST))
            return;
    }
    else
    {
        if ((fpos = FindLastPos(fcol)) == EMPTY)
            return;

        if (fcol == tcol)               // click and release on same column
            return;
    }

    if (tcol == TOPROW)
    {
        if (tpos > 3)
        {
            c = card[fcol][fpos];
            home[SUIT(c)] = VALUE(c);
        }
    }
    else
        tpos = FindLastPos(tcol) + 1;

    c = card[fcol][fpos];
    card[fcol][fpos] = EMPTY;
    card[tcol][tpos] = c;

    if (VALUE(c) == ACE && tcol == TOPROW && tpos > 3)
        homesuit[SUIT(c)] = tpos;
}


/******************************************************************************

MoveCards

If there are queued transfer requests, this function moves them.

******************************************************************************/

VOID MoveCards(HWND hWnd)
{
    UINT     i;

    if (moveindex == 0)             // if there are no queued requests
        return;

    /* restore card to its state before requests got queued. */

    memcpy(&(card[0][0]), &(shadow[0][0]), sizeof(card));

    SetCursor(LoadCursor(NULL, IDC_WAIT));  // set cursor to hourglass
    SetCapture(hWnd);
    ShowCursor(TRUE);

    for (i = 0; i < moveindex; i++)
        Transfer(hWnd, movelist[i].fcol, movelist[i].fpos,
                    movelist[i].tcol, movelist[i].tpos);

    if ((moveindex > 1) || (movelist[0].fcol != movelist[0].tcol))
    {
        cUndo = moveindex;
        EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_ENABLED);
    }
    else
    {
        cUndo = 0;
        EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_GRAYED);
    }

    moveindex = 0;                      // no cards left to move

    ShowCursor(FALSE);
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    ReleaseCapture();

    if (wCardCount == 0)                // if game is won
    {
        INT     cLifetimeWins;          // wins including .ini stats
        INT     wStreak, wSType;        // streak length and type
        INT     wWins;                  // record win streak
        INT_PTR nResponse;              // dialog box response
        HDC     hDC;
        LONG    lRegResult;

        cUndo = 0;
        EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_GRAYED);

        lRegResult = REGOPEN

        if (ERROR_SUCCESS == lRegResult)
        {
            bGameInProgress = FALSE;
            bCheating = FALSE;
            cLifetimeWins = GetInt(pszWon, 0);

            if (gamenumber != oldgamenumber)    // repeats don't count
            {
                cLifetimeWins++;
                cWins++;
                cGames++;
                SetInt(pszWon, cLifetimeWins);
                wSType = GetInt(pszSType, LOST);
                if (wSType == LOST)
                {
                    SetInt(pszSType, WON);
                    wStreak = 1;
                    SetInt(pszStreak, 1);
                }
                else
                {
                    wStreak = GetInt(pszStreak, 0);
                    wStreak++;
                    SetInt(pszStreak, wStreak);
                }

                wWins = GetInt(pszWins, 0);
                if (wWins < wStreak)    // if new record
                {
                    wWins = wStreak;
                    SetInt(pszWins, wWins);
                }
            }

            REGCLOSE
        }

        hDC = GetDC(hWnd);
        Payoff(hDC);
        ReleaseDC(hWnd, hDC);

        bWonState = TRUE;
        nResponse = DialogBox(hInst, TEXT("YouWin"), hWnd, YouWinDlg);

        if (nResponse == IDYES)
            PostMessage(hWnd, WM_COMMAND,
                        bSelecting ? IDM_SELECT : IDM_NEWGAME, 0);

        oldgamenumber = gamenumber;
        gamenumber = 0;                 // turn off mouse handling
    }
    else
        IsGameLost(hWnd);               // check for game lost
}


/******************************************************************************

SetCursorShape

This function is called in response to WM_MOUSEMOVE.  If the current pointer
position represents a legal move, the cursor shape changes to indicate this.

******************************************************************************/

VOID SetCursorShape(HWND hWnd, UINT x, UINT y)
{
    UINT    tcol = 0, tpos = 0;
    UINT    trans;              // number of cards required to transfer
    BOOL    bFound;             // is cursor over card?
    HDC     hDC;

    /* If we're flipping, cursor is always an hourglass. */

    if (bFlipping)
    {
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        return;
    }

    bFound = Point2Card(x, y, &tcol, &tpos);

    if (bFound && tcol == TOPROW)
    {
        hDC = GetDC(hWnd);

        if (tpos < 4)
            DrawKing(hDC, LEFT, TRUE);
        else
            DrawKing(hDC, RIGHT, TRUE);

        ReleaseDC(hWnd, hDC);
    }

    /* Unless we're chosing a move target, cursor is just an arrow. */

    if (wMouseMode != TO)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return;
    }

    /* If we're not on a card, check if we're pointing to an empty
       column (up arrow), otherwise arrow. */

    if (!bFound)
    {
        if ((tcol > 0 && tcol < 9) && (card[tcol][0] == EMPTY))
            SetCursor(LoadCursor(NULL, IDC_UPARROW));
        else
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        return;
    }

    if (tcol != TOPROW)
        tpos = FindLastPos(tcol);

    /* Check for cancel request. */

    if (wFromCol == tcol && wFromPos == tpos)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return;
    }

    /* Check moves from or to the top row. */

    if (wFromCol == TOPROW || tcol == TOPROW)
    {
        if (IsValidMove(hWnd, tcol, tpos))
        {
            if (tcol == TOPROW)
                SetCursor(LoadCursor(NULL, IDC_UPARROW));
            else
                SetCursor(LoadCursor(hInst, TEXT("DownArrow")));
        }
        else
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        return;
    }

    /* Check moves between columns. */

    trans = NumberToTransfer(wFromCol, tcol);   // how many required?

    if ((trans > 0) && (trans <= MaxTransfer()))
        SetCursor(LoadCursor(hInst, TEXT("DownArrow")));
    else
        SetCursor(LoadCursor(NULL, IDC_ARROW));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\context.h ===
#define HLP_INDEX     0x0000
#define HLP_HOWTOPLAY 0x0001
#define HLP_COMMANDS  0x0002
#define HLP_KEYBOARD  0x0003
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\grafix.h ===
/******************/
/* file: grafix.h */
/******************/

/*** Bitmaps ***/

#define dxBlk 16
#define dyBlk 16

#define dxLed 13
#define dyLed 23

#define dxButton 24
#define dyButton 24

#define dxFudge 2

#define dxLeftSpace 12
#define dxRightSpace 12
#define dyTopSpace 12
#define dyBottomSpace 12

#define dxGridOff dxLeftSpace
#define dyGridOff (dyTopLed+dyLed+16)

#define dxLeftBomb  (dxLeftSpace + 5)
#define dxRightTime (dxRightSpace + 5)
#define dyTopLed    (dyTopSpace + 4)


/*** Macros ***/

#ifdef DEBUG

//-protect-#define Oops(szMsg)
//	MessageBox(NULL, szMsg, "Oops", MB_OK | MB_ICONHAND)

#else
#define Oops(szMsg)
#endif



/*** Routines ***/

BOOL FInitLocal(VOID);
VOID CleanUp(VOID);

VOID DrawBlk(HDC, INT, INT);
VOID DisplayBlk(INT, INT);

VOID DrawButton(HDC, INT);
VOID DisplayButton(INT);
VOID DrawGrid(HDC);
VOID DisplayGrid(VOID);
VOID DrawBombCount(HDC);
VOID DisplayBombCount(VOID);
VOID DrawTime(HDC);
VOID DisplayTime(VOID);
VOID DrawScreen(HDC);
VOID DisplayScreen(VOID);

BOOL FLoadBitmaps(VOID);
VOID FreeBitmaps(VOID);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\main.h ===
/* MINE HEADER FILE */

#ifdef DEBUG
#define CHEAT
#endif

#ifdef BETA_VERSION
#define NOSERVER
#define EXPIRE
#endif

#define FAST

/*** Standard Stuff ***/

#define REGISTER register

#define fTrue	TRUE
#define fFalse	FALSE

#define hNil	NULL

#define cchMsgMax  128
#define cchMaxPathname 250


#define ID_TIMER 1


#define fmenuAlwaysOn 0x00
#define fmenuOff      0x01
#define fmenuOn       0x02

#define FMenuSwitchable()   (Preferences.fMenu != fmenuAlwaysOn)
#define FMenuOn()          ((Preferences.fMenu &  0x01) == 0)

#define fCalc    0x01
#define fResize  0x02
#define fDisplay 0x04


#define xBoxFromXpos(x) ( ((x)-(dxGridOff-dxBlk)) >> 4)
#define yBoxFromYpos(y) ( ((y)-(dyGridOff-dyBlk)) >> 4)

// This is the place where the winmine info gets stored in registry.
#define SZWINMINEREG   TEXT("Software\\Microsoft\\winmine")


/* if we have too few boxes, the title gets clipped */
#define MINWIDTH 9  
#define DEFWIDTH 9
#define MINHEIGHT 9
#define DEFHEIGHT 9


VOID AdjustWindow(INT);
VOID FixMenus(VOID);
VOID DoEnterName(VOID);
VOID DoDisplayBest(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\menu.inc ===
/* WinMine Menus */

ID_MENU MENU
BEGIN

 POPUP     "&Game"
 BEGIN	
 MENUITEM  "&New\tF2",        IDM_NEW
 MENUITEM  SEPARATOR
 MENUITEM  "&Beginner",       IDM_BEGIN
 MENUITEM  "&Intermediate",   IDM_INTER
 MENUITEM  "&Expert",         IDM_EXPERT
 MENUITEM  "&Custom..."       IDM_CUSTOM
 MENUITEM  SEPARATOR
 MENUITEM  "&Marks (?)",      IDM_MARK
 MENUITEM  "Co&lor",          IDM_COLOR
 MENUITEM  "&Sound",          IDM_SOUND
 MENUITEM  SEPARATOR
 MENUITEM  "Best &Times..."   IDM_BEST
 MENUITEM  SEPARATOR
 MENUITEM  "E&xit",           IDM_EXIT
 END	
 	
 POPUP     "&Help"
 BEGIN	
 MENUITEM  "&Contents\tF1",             IDM_HELP
 MENUITEM  "&Search for Help on..."     IDM_HOW2PLAY
 MENUITEM  "Using &Help",               IDM_HELP_HELP
 MENUITEM  SEPARATOR
 MENUITEM  "&About Minesweeper...",     IDM_HELP_ABOUT
 END

END


ID_MENU_ACCEL ACCELERATORS
BEGIN
VK_F1, IDM_HELP,  VIRTKEY
VK_F2, IDM_NEW,   VIRTKEY
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\pref.c ===
/****************/
/* file: pref.c */
/****************/

#define _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "main.h"
#include "res.h"
#include "rtns.h"
#include "grafix.h"
#include "pref.h"
#include "sound.h"

BOOL fUpdateIni = fFalse;
HKEY g_hReg;

extern TCHAR szDefaultName[];
extern INT xBoxMac;
extern INT yBoxMac;

extern PREF Preferences;

TCHAR * rgszPref[iszPrefMax] =
{
TEXT("Difficulty"),
TEXT("Mines"     ),
TEXT("Height"    ),
TEXT("Width"     ),
TEXT("Xpos"      ),
TEXT("Ypos"      ),
TEXT("Sound"     ),
TEXT("Mark"      ),
TEXT("Menu"      ),
TEXT("Tick"      ),
TEXT("Color"     ),
TEXT("Time1"     ),
TEXT("Name1"     ),
TEXT("Time2"     ),
TEXT("Name2"     ),
TEXT("Time3"     ),
TEXT("Name3"     ),
TEXT("AlreadyPlayed")
};


/****** PREFERENCES ******/

INT ReadInt(INT iszPref, INT valDefault, INT valMin, INT valMax)
{
DWORD dwIntRead;
DWORD dwSizeOfData = sizeof(INT);


    // If value not present, return default value.
    if (RegQueryValueEx(g_hReg, rgszPref[iszPref], NULL, NULL, (LPBYTE) &dwIntRead, 
                        &dwSizeOfData) != ERROR_SUCCESS)
        return valDefault;

    return max(valMin, min(valMax, (INT) dwIntRead));
}

#define ReadBool(iszPref, valDefault) ReadInt(iszPref, valDefault, 0, 1)


VOID ReadSz(INT iszPref, TCHAR FAR * szRet)
{
DWORD dwSizeOfData = cchNameMax * sizeof(TCHAR);

    // If string not present, return default string.
    if (RegQueryValueEx(g_hReg, rgszPref[iszPref], NULL, NULL, (LPBYTE) szRet, 
                        &dwSizeOfData) != ERROR_SUCCESS)
        lstrcpy(szRet, szDefaultName) ;

    return;
}


VOID ReadPreferences(VOID)
{
DWORD dwDisposition;


	// Open the registry key; if it fails, there is not much we can do about it.
	RegCreateKeyEx(HKEY_CURRENT_USER, SZWINMINEREG, 0, NULL, 0, KEY_READ, NULL, 
				   &g_hReg, &dwDisposition);
  
	yBoxMac= Preferences.Height= ReadInt(iszPrefHeight,MINHEIGHT,DEFHEIGHT,25);

	xBoxMac= Preferences.Width= ReadInt(iszPrefWidth,MINWIDTH,DEFWIDTH,30);

	Preferences.wGameType = (WORD)ReadInt(iszPrefGame,wGameBegin, wGameBegin, wGameExpert+1);
	Preferences.Mines    = ReadInt(iszPrefMines, 10, 10, 999);
	Preferences.xWindow  = ReadInt(iszPrefxWindow, 80, 0, 1024);
	Preferences.yWindow  = ReadInt(iszPrefyWindow, 80, 0, 1024);

	Preferences.fSound = ReadInt(iszPrefSound, 0, 0, fsoundOn);
	Preferences.fMark  = ReadBool(iszPrefMark,  fTrue);
	Preferences.fTick  = ReadBool(iszPrefTick,  fFalse);
	Preferences.fMenu  = ReadInt(iszPrefMenu,  fmenuAlwaysOn, fmenuAlwaysOn, fmenuOn);
	
	Preferences.rgTime[wGameBegin]  = ReadInt(iszPrefBeginTime, 999, 0, 999);
	Preferences.rgTime[wGameInter]  = ReadInt(iszPrefInterTime, 999, 0, 999);
	Preferences.rgTime[wGameExpert] = ReadInt(iszPrefExpertTime, 999, 0, 999);

	ReadSz(iszPrefBeginName, Preferences.szBegin);
	ReadSz(iszPrefInterName, Preferences.szInter);
	ReadSz(iszPrefExpertName, Preferences.szExpert);

    // set the color preference so we will use the right bitmaps
    // numcolors may return -1 on true color devices
	{
	HDC hDC = GetDC(GetDesktopWindow());
	Preferences.fColor  = ReadBool(iszPrefColor, (GetDeviceCaps(hDC, NUMCOLORS) != 2));
	ReleaseDC(GetDesktopWindow(),hDC);
	}

	if (FSoundOn())
		Preferences.fSound = FInitTunes();

	RegCloseKey(g_hReg);

}
	

VOID WriteInt(INT iszPref, INT val)
{

    // No check for return value for if it fails, can't do anything
    // to rectify the situation.
    RegSetValueEx(g_hReg, rgszPref[iszPref], 0, REG_DWORD, (LPBYTE) &val, sizeof(val));

    return;

}


VOID WriteSz(INT iszPref, TCHAR FAR * sz)
{
    // No check for return value for if it fails, can't do anything
    // to rectify the situation.
    RegSetValueEx(g_hReg, rgszPref[iszPref], 0, REG_SZ, (LPBYTE) sz, 
                  sizeof(TCHAR) * (lstrlen(sz)+1));

    return;
}


VOID WritePreferences(VOID)
{
DWORD dwDisposition;

	// Open the registry key; if it fails, there is not much we can do about it.
	RegCreateKeyEx(HKEY_CURRENT_USER, SZWINMINEREG, 0, NULL, 0, KEY_WRITE, NULL, 
				   &g_hReg, &dwDisposition);


	WriteInt(iszPrefGame,   Preferences.wGameType);
	WriteInt(iszPrefHeight, Preferences.Height);
	WriteInt(iszPrefWidth,  Preferences.Width);
	WriteInt(iszPrefMines,  Preferences.Mines);
	WriteInt(iszPrefMark,   Preferences.fMark);
	WriteInt(iszPrefAlreadyPlayed, 1);

#ifdef WRITE_HIDDEN
	WriteInt(iszPrefMenu,   Preferences.fMenu);
	WriteInt(iszPrefTick,   Preferences.fTick);
#endif
	WriteInt(iszPrefColor,  Preferences.fColor);
	WriteInt(iszPrefSound,  Preferences.fSound);
	WriteInt(iszPrefxWindow,Preferences.xWindow);
	WriteInt(iszPrefyWindow,Preferences.yWindow);

	WriteInt(iszPrefBeginTime,  Preferences.rgTime[wGameBegin]);
	WriteInt(iszPrefInterTime,  Preferences.rgTime[wGameInter]);
	WriteInt(iszPrefExpertTime, Preferences.rgTime[wGameExpert]);

	WriteSz(iszPrefBeginName,   Preferences.szBegin);
	WriteSz(iszPrefInterName,   Preferences.szInter);
	WriteSz(iszPrefExpertName,  Preferences.szExpert);

	RegCloseKey(g_hReg);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\res.h ===
/* MINE Resources */

#define ID_ICON_MAIN    100

#define ID_BMP_BLOCKS   410
#define ID_BAW_BLOCKS   411
#define ID_BMP_LED      420
#define ID_BAW_LED      421
#define ID_BMP_BUTTON   430
#define ID_BAW_BUTTON   431

#define ID_TUNE_TICK    432
#define ID_TUNE_WON     433  
#define ID_TUNE_LOST    434


/* Preferences Dialog */

#define ID_DLG_PREF     80

#define ID_BTN_OK       100
#define ID_BTN_CANCEL   109

#define ID_TXT_MINES    111
#define ID_TXT_HEIGHT   112
#define ID_TXT_WIDTH    113

#define ID_EDIT_HEIGHT  141
#define ID_EDIT_WIDTH   142
#define ID_EDIT_MINES   143

#define ID_TXT_CUST     151


#define ID_DLG_ENTER    600
#define ID_TEXT_BEST    601
#define ID_EDIT_NAME    602

#define ID_DLG_BEST     700
#define ID_TIME_BEGIN   701
#define ID_NAME_BEGIN   702
#define ID_TIME_INTER   703
#define ID_NAME_INTER   704
#define ID_TIME_EXPERT  705
#define ID_NAME_EXPERT  706
#define ID_BTN_RESET    707
#define ID_STEXT1       708
#define ID_STEXT2       709
#define ID_STEXT3       710


/* Menus */

#define ID_MENU         500
#define ID_MENU_ACCEL   501
							 	
#define IDM_NEW         510
#define IDM_EXIT        512

#define IDM_SKILL       520
#define IDM_BEGIN       521
#define IDM_INTER       522
#define IDM_EXPERT      523
#define IDM_CUSTOM      524
#define IDM_SOUND       526
#define IDM_MARK        527
#define IDM_BEST        528
#define IDM_COLOR       529

#define IDM_HELP        590
#define IDM_HOW2PLAY    591
#define IDM_HELP_HELP   592
#define IDM_HELP_ABOUT  593

#define ID_GAMENAME       1
#define ID_ERR_TITLE      3
#define ID_ERR_TIMER      4
#define ID_ERR_MEM        5
#define ID_ERR_UNKNOWN    6
#define ID_NAME_DEFAULT   8
#define ID_MSG_SEC        7
#define ID_MSG_BEGIN      9
#define ID_MSG_INTER     10
#define ID_MSG_EXPERT    11
#define ID_MSG_VERSION   12
#define ID_MSG_CREDIT    13

#define ID_ERR_MAX      999

// for context sensitive help
#define IDH_PREF_EDIT_HEIGHT 1000
#define IDH_PREF_EDIT_WIDTH  1001
#define IDH_PREF_EDIT_MINES  1002
#define IDH_BEST_BTN_RESET   1003
#define IDH_STEXT            1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\grafix.c ===
/*************/
/* grafwin.c */
/*************/

#define _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "main.h"
#include "res.h"
#include "grafix.h"
#include "rtns.h"
#include "sound.h"
#include "pref.h"


INT rgDibOff[iBlkMax];
INT rgDibLedOff[iLedMax];
INT rgDibButton[iButtonMax];

LPSTR  lpDibBlks;
LPSTR  lpDibLed;
LPSTR  lpDibButton;

HANDLE hResBlks;
HANDLE hResLed;
HANDLE hResButton;

HPEN hGrayPen = NULL;

//
//   MEM: make an array of memory bitmaps for storing DIBs
//

HDC          MemBlkDc[iBlkMax];
HBITMAP      MemBlkBitmap[iBlkMax];

//
//   end MEM:
//

extern INT dypCaption;
extern INT dypMenu;
extern INT dypBorder;
extern INT dxpBorder;


/*** External Data ***/

extern HWND   hwndMain;
extern HANDLE hInst;

extern PREF   Preferences;
extern CHAR   rgBlk[cBlkMax];

extern INT dxWindow;
extern INT dyWindow;
extern INT fStatus;

extern INT cSec;
extern INT cBombLeft;
extern INT cBoxVisit;
extern INT xBoxMac;
extern INT yBoxMac;

extern INT iButtonCur;



/****** F I N I T  L O C A L ******/

BOOL FInitLocal(VOID)
{
        if (!FLoadBitmaps())
                return fFalse;

        ClearField();

        return fTrue;
}



HANDLE HFindBitmap(INT id)
{
        return FindResource(hInst, MAKEINTRESOURCE(id+(!Preferences.fColor)), RT_BITMAP);
}

INT CbBitmap(INT x, INT y)
{
        x *= (Preferences.fColor ? 4 : 1);              /* Convert pixels to bits */
        return (y * ( ((x+31) >> 5) << 2));             /* Bytes on 32 byte boundary */
}


/****** F L O A D  B I T M A P S ******/

BOOL FLoadBitmaps(VOID)
{
        HANDLE hResInfo;
        REGISTER INT i;
        INT cbDibHeader;
        INT cb;

        HDC hDC;

        // initialize all the bitmaps to NULL.
        hResBlks = hResLed = hResButton = NULL;

        hResInfo   = HFindBitmap(ID_BMP_BLOCKS);
        if (hResInfo)
            hResBlks   = LoadResource(hInst, hResInfo);

        hResInfo   = HFindBitmap(ID_BMP_LED);
        if (hResInfo)
            hResLed    = LoadResource(hInst, hResInfo);

        hResInfo   = HFindBitmap(ID_BMP_BUTTON);
        if (hResInfo)
            hResButton = LoadResource(hInst, hResInfo);

        if (hResBlks == NULL || hResLed == NULL || hResButton == NULL)
                return fFalse;

        lpDibBlks  = LockResource(hResBlks);
        lpDibLed   = LockResource(hResLed);
        lpDibButton= LockResource(hResButton);

        if (!Preferences.fColor)
                hGrayPen = GetStockObject(BLACK_PEN);
        else
                hGrayPen = CreatePen(PS_SOLID, 1, RGB(128, 128, 128));

        cbDibHeader = sizeof(BITMAPINFOHEADER) + (Preferences.fColor ? 16*4 : 2*4);

        cb = CbBitmap(dxBlk, dyBlk);
        for (i = 0 ; i < iBlkMax; i++)
                rgDibOff[i]    = cbDibHeader + (i * cb);

        cb = CbBitmap(dxLed, dyLed);
        for (i = 0 ; i < iLedMax; i++)
                rgDibLedOff[i] = cbDibHeader + (i * cb);

        cb = CbBitmap(dxButton, dyButton);
        for (i = 0 ; i < iButtonMax; i++)
                rgDibButton[i] = cbDibHeader + (i * cb);


        //
        //   MEM: move each Blk DIB to a memory BitMap
        //

        hDC = GetDC(hwndMain);

        for (i = 0 ; i < iBlkMax; i++) {

           //
           // Create a device context compatible with the device's active
           // display for each of these bitmaps.
           //

           MemBlkDc[i] = CreateCompatibleDC(hDC);
           if (MemBlkDc[i] == (HDC)NULL) {
              OutputDebugStringA("FLoad failed to create compatible dc\n");
           }

           //
           // create the bitmap for the above memory DC and selct this bitmap.
           //
           // we really only need 1 bitmap and 1 dc as they have done before!
           //

           MemBlkBitmap[i] = CreateCompatibleBitmap(hDC,dxBlk,dxBlk);
           if (MemBlkBitmap[i] == (HBITMAP)NULL) {
              OutputDebugStringA("Failed to create Bitmap\n");
           }

           SelectObject(MemBlkDc[i],MemBlkBitmap[i]);

           //
           //   copy the bits from the DIB into this bitmap
           //

           SetDIBitsToDevice(MemBlkDc[i],
                             0,
                             0,
                             dxBlk,
                             dyBlk,
                             0,
                             0,
                             0,
                             dyBlk,
                             lpDibBlks + rgDibOff[i],
                             (LPBITMAPINFO) lpDibBlks,
                             DIB_RGB_COLORS);

        }

        ReleaseDC(hwndMain, hDC);
        return fTrue;

}

VOID FreeBitmaps(VOID)
{
        int i;
        if (hGrayPen != NULL)
                DeleteObject(hGrayPen);

        UnlockResource(hResBlks);
        UnlockResource(hResLed);
        UnlockResource(hResButton);

        for (i = 0 ; i < iBlkMax; i++) {
           DeleteDC(MemBlkDc[i]);
           DeleteObject(MemBlkBitmap[i]);
        }


}


/****** C L E A N  U P ******/

VOID CleanUp(VOID)
{
        FreeBitmaps();
        EndTunes();
}



/****** D R A W  B L K ******/

VOID DrawBlk(HDC hDC, INT x, INT y)
{
        BitBlt(hDC,
               (x<<4)+(dxGridOff-dxBlk),
               (y<<4)+(dyGridOff-dyBlk),
               dxBlk,
               dyBlk,
               MemBlkDc[iBLK(x,y)],
               0,
               0,
               SRCCOPY);
}


VOID DisplayBlk(INT x, INT y)
{
        HDC hDC = GetDC(hwndMain);
        BitBlt(hDC,
               (x<<4)+(dxGridOff-dxBlk),
               (y<<4)+(dyGridOff-dyBlk),
               dxBlk,
               dyBlk,
               MemBlkDc[iBLK(x,y)],
               0,
               0,
               SRCCOPY);

        ReleaseDC(hwndMain, hDC);
}


/****** D R A W  G R I D ******/

VOID DrawGrid(HDC hDC)
{
                REGISTER        INT   x;
                REGISTER        INT   y;
                INT dx;
                INT dy;

                dy = dyGridOff;

                for (y=1; y <= yBoxMac; y++, dy += dyBlk)
                        {
                        dx = dxGridOff;
                        for (x=1; x <= xBoxMac; x++, dx += dxBlk)
                                {
                                   BitBlt(hDC,
                                          dx,
                                          dy,
                                          dxBlk,
                                          dyBlk,
                                          MemBlkDc[iBLK(x,y)],
                                          0,
                                          0,
                                          SRCCOPY);
                                }
                        }
}

VOID DisplayGrid(VOID)
{
        HDC hDC = GetDC(hwndMain);
        DrawGrid(hDC);
        ReleaseDC(hwndMain, hDC);
}


/****** D R A W  L E D ******/

VOID DrawLed(HDC hDC, INT x, INT iLed)
{
        SetDIBitsToDevice(hDC, x, dyTopLed, dxLed, dyLed, 0, 0, 0, dyLed,
                lpDibLed + rgDibLedOff[iLed], (LPBITMAPINFO) lpDibLed, DIB_RGB_COLORS);
}


/****** D R A W  B O M B  C O U N T ******/

VOID DrawBombCount(HDC hDC)
{
        INT iLed;
        INT cBombs;

        DWORD dwDCLayout = GetLayout(hDC);

        if (dwDCLayout & LAYOUT_RTL) {
           SetLayout(hDC , 0); // Turn off mirroring before painting.
        }

        if (cBombLeft < 0)
                {
                iLed = iLedNegative;
                cBombs = (-cBombLeft) % 100;
                }
        else
                {
                iLed = cBombLeft / 100;
                cBombs = cBombLeft % 100;
                }

        DrawLed(hDC, dxLeftBomb, iLed);
        DrawLed(hDC, dxLeftBomb+dxLed, cBombs/10);
        DrawLed(hDC, dxLeftBomb+dxLed+dxLed, cBombs % 10);

        if (dwDCLayout & LAYOUT_RTL) {
           SetLayout(hDC , dwDCLayout); // Turn on the mirroring again.
        }
}

VOID DisplayBombCount(VOID)
{
        HDC hDC = GetDC(hwndMain);
        DrawBombCount(hDC);
        ReleaseDC(hwndMain, hDC);
}


/****** D R A W  T I M E ******/

VOID DrawTime(HDC hDC)
{
        INT iLed = cSec;
        DWORD dwDCLayout = GetLayout(hDC);

        if (dwDCLayout & LAYOUT_RTL) {
           SetLayout(hDC , 0); // Turn off mirroring before painting.
        }

        DrawLed(hDC, dxWindow-(dxRightTime+3*dxLed+dxpBorder), iLed/100);       /* OverFlow ? */
        DrawLed(hDC, dxWindow-(dxRightTime+2*dxLed+dxpBorder),(iLed %= 100)/10 );
        DrawLed(hDC, dxWindow-(dxRightTime+  dxLed+dxpBorder), iLed % 10);

        if (dwDCLayout & LAYOUT_RTL) {
           SetLayout(hDC , dwDCLayout); // Turn on the mirroring again.
        }
}

VOID DisplayTime(VOID)
{
        HDC hDC = GetDC(hwndMain);
        DrawTime(hDC);
        ReleaseDC(hwndMain, hDC);
}


/****** D R A W  B U T T O N ******/

VOID DrawButton(HDC hDC, INT iButton)
{
        SetDIBitsToDevice(hDC, (dxWindow-dxButton)>>1, dyTopLed, dxButton, dyButton, 0, 0, 0, dyButton,
                lpDibButton + rgDibButton[iButton], (LPBITMAPINFO) lpDibButton, DIB_RGB_COLORS);
}

VOID DisplayButton(INT iButton)
{
        HDC hDC = GetDC(hwndMain);
        DrawButton(hDC, iButton);
        ReleaseDC(hwndMain, hDC);
}



/****** S E T  T H E  P E N ******/

VOID SetThePen(HDC hDC, INT fNormal)
{
        if (fNormal & 1)
                SetROP2(hDC, R2_WHITE);
        else
                {
                SetROP2(hDC, R2_COPYPEN);
                SelectObject(hDC, hGrayPen);
                }
}


/****** D R A W  B O R D E R ******/

/* 0 - white, gray
   1 - gray,  white
        2 - white, white
        3 - grey,  grey
*/

VOID DrawBorder(HDC hDC, INT x1, INT y1, INT x2, INT y2, INT width, INT fNormal)
{
        INT i = 0;

        SetThePen(hDC, fNormal);

        while (i++ < width)
                {
                (VOID)MMoveTo(hDC, x1, --y2);
                LineTo(hDC, x1++, y1);
                LineTo(hDC, x2--, y1++);
                }

        if (fNormal < 2)
                SetThePen(hDC, fNormal ^ 1);

        while (--i)
                {
                (VOID)MMoveTo(hDC, x1--,  ++y2);
                LineTo(hDC, ++x2, y2);
                LineTo(hDC, x2, --y1);
                }
}

VOID DrawBackground(HDC hDC)
{
        INT x, y;

        x = dxWindow-1;
        y = dyWindow-1;
        DrawBorder(hDC, 0, 0, x, y, 3, 1);

        x -= (dxRightSpace -3);
        y -= (dyBottomSpace-3);
        DrawBorder(hDC, dxGridOff-3, dyGridOff-3, x, y, 3, 0);
        DrawBorder(hDC, dxGridOff-3, dyTopSpace-3, x, dyTopLed+dyLed+(dyBottomSpace-6), 2, 0);

        x = dxLeftBomb+dxLed*3;
        y = dyTopLed+dyLed;
        DrawBorder(hDC, dxLeftBomb-1, dyTopLed-1, x, y, 1, 0);

        x = dxWindow-(dxRightTime+3*dxLed+dxpBorder+1);
        DrawBorder(hDC, x, dyTopLed-1, x+(dxLed*3+1), y, 1, 0);

        x = ((dxWindow-dxButton)>>1)-1;
        DrawBorder(hDC, x, dyTopLed-1, x+dxButton+1, dyTopLed+dyButton, 1, 2);
}


/****** D R A W  S C R E E N ******/

VOID DrawScreen(HDC hDC)
{
        DrawBackground(hDC);
        DrawBombCount(hDC);
        DrawButton(hDC, iButtonCur);
        DrawTime(hDC);
        DrawGrid(hDC);
}

VOID DisplayScreen(VOID)
{
        HDC hDC = GetDC(hwndMain);
        DrawScreen(hDC);
        ReleaseDC(hwndMain, hDC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\pref.h ===
/**********/
/* pref.h */
/**********/

#define cchNameMax 32

typedef struct
{
	WORD  wGameType;
	INT   Mines;
	INT   Height;
	INT   Width;
	INT   xWindow;
	INT   yWindow;
	INT   fSound;
	BOOL  fMark;
	BOOL  fTick;
	BOOL  fMenu;
	BOOL  fColor;
	INT   rgTime[3];
	TCHAR szBegin[cchNameMax];
	TCHAR szInter[cchNameMax];
	TCHAR szExpert[cchNameMax];
} PREF;


#define iszPrefGame    0
#define iszPrefMines   1
#define iszPrefHeight  2
#define iszPrefWidth   3
#define iszPrefxWindow 4
#define iszPrefyWindow 5
#define iszPrefSound   6
#define iszPrefMark    7
#define iszPrefMenu    8
#define iszPrefTick    9
#define iszPrefColor   10
#define iszPrefBeginTime   11
#define iszPrefBeginName   12
#define iszPrefInterTime   13
#define iszPrefInterName   14
#define iszPrefExpertTime  15
#define iszPrefExpertName  16
#define iszPrefAlreadyPlayed 17


#define iszPrefMax 18


VOID ReadPreferences(VOID);
VOID WritePreferences(VOID);
INT  ReadInt(INT, INT, INT, INT);
VOID ReadSz(INT, TCHAR FAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\util.h ===
/**********/
/* util.h */
/**********/

#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))

VOID InitConst(VOID);
VOID LoadSz(WORD, TCHAR *, DWORD);
VOID ReportErr(WORD);
INT  Rnd(INT);

INT  GetDlgInt(HWND, INT, INT, INT);

VOID DoHelp(WORD, UINT);
VOID DoAbout(VOID);

VOID CheckEm(WORD, BOOL);
VOID SetMenuBar(INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\sound.h ===
/*****************/
/* file: sound.h */
/*****************/

#define TUNE_TICK      1
#define TUNE_WINGAME   2
#define TUNE_LOSEGAME  3

#define fsoundOn  3
#define fsoundOff 2

#define FSoundSwitchable()  (Preferences.fSound > 1)
#define FSoundOn()          (Preferences.fSound == fsoundOn)

INT  FInitTunes(VOID);
VOID PlayTune(INT);
VOID EndTunes(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\sound.c ===
/***********/
/* sound.c */
/***********/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>
#include <mmsystem.h>

#include "main.h"
#include "sound.h"
#include "rtns.h"
#include "pref.h"
#include "res.h"

extern HANDLE hInst;
extern PREF Preferences;



/****** F I N I T  T U N E S ******/

INT FInitTunes( VOID )
{
	// Even if the user has chosen the sound option
	// but does not have sound playing capabilities,
	// put the sound off.
	if ( PlaySound(NULL, NULL, SND_PURGE)  == FALSE)
		return fsoundOff;
	
	return fsoundOn;
}



/****** E N D  T U N E S ******/

VOID EndTunes(VOID)
{
	// Just stop the tune ..
	if (FSoundOn())
	{
		PlaySound(NULL, NULL, SND_PURGE);
	}
}



/****** P L A Y  T U N E ******/

VOID PlayTune(INT tune)
{

    if (!FSoundOn())
        return;

	// Play the appropriate .wav file.
	switch (tune)
	{
	case TUNE_TICK:
        PlaySound(MAKEINTRESOURCE(ID_TUNE_TICK), hInst, SND_RESOURCE | SND_ASYNC);
		break;

	case TUNE_WINGAME:
	    PlaySound(MAKEINTRESOURCE(ID_TUNE_WON), hInst, SND_RESOURCE | SND_ASYNC); 
		break;

	case TUNE_LOSEGAME:
	    PlaySound(MAKEINTRESOURCE(ID_TUNE_LOST), hInst, SND_RESOURCE | SND_ASYNC);
		break;

	default:
#ifdef DEBUG
		Oops(TEXT("Invalid Tune"));
#endif
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\strings.inc ===
/* strings.inc */

STRINGTABLE
  BEGIN
    ID_GAMENAME      "Minesweeper"
    ID_ERR_TITLE     "Minesweeper Error"
    ID_ERR_TIMER,    "Unable to allocate a timer.  Please exit some of your applications and try again."
    ID_ERR_UNKNOWN,  "Error: %d"
    ID_ERR_MEM,      "Out of Memory"
    ID_NAME_DEFAULT, "Anonymous"
    ID_MSG_SEC,      "%d seconds"
    ID_MSG_BEGIN,    "You have the fastest time\rfor beginner level.\rPlease enter your name."
    ID_MSG_INTER,    "You have the fastest time\rfor intermediate level.\rPlease enter your name."
    ID_MSG_EXPERT,   "You have the fastest time\rfor expert level.\rPlease enter your name."
    ID_MSG_VERSION,  "Minesweeper"
    ID_MSG_CREDIT,   "by Robert Donner and Curt Johnson"
  END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\rtns.h ===
/****************/
/* file: rtns.h */
/****************/

/*** Bitmaps ***/


/* Blocks */

#define iBlkBlank    0
#define iBlk1        1
#define iBlk2        2
#define iBlk8        8
#define iBlkGuessDn  9
#define iBlkBombDn  10
#define iBlkWrong   11
#define iBlkExplode 12
#define iBlkGuessUp 13
#define iBlkBombUp  14
#define iBlkBlankUp 15

#define iBlkMax 16

#define MaskBomb  0x80
#define MaskVisit 0x40
#define MaskFlags 0xE0
#define MaskData  0x1F

#define NOTMaskBomb 0x7F

#define cBlkMax (27*32)


/* Leds */

#define iLed0         0
#define iLed1         1
#define iLed9         9
#define iLedBlank    10
#define iLedNegative 11

#define iLedMax 12


/* Buttons */

#define iButtonHappy   0
#define iButtonCaution 1
#define iButtonLose    2
#define iButtonWin     3
#define iButtonDown    4

#define iButtonMax 5



#define wGameBegin  0
#define wGameInter  1
#define wGameExpert 2
#define wGameOther  3



/*** Macros ***/

#define fInRange(x,y)   (((x)>0) && ((y)>0) && ((x)<=xBoxMac) && ((y)<=yBoxMac))

#define IBLK(x,y)    (rgBlk[ ((y)<<5) + (x)])
#define iBLK(x,y)    ( (IBLK(x,y) & MaskData) )

#define SetBorder(x,y) (IBLK(x,y) =  iBlkMax)
#define fBORDER(x,y)   (IBLK(x,y) == iBlkMax)

#define SetBomb(x,y)   (IBLK(x,y) |= MaskBomb)
#define ClearBomb(x,y) (IBLK(x,y) &= NOTMaskBomb)
#define fISBOMB(x,y)   ((IBLK(x,y) & MaskBomb) != 0)

#define SetVisit(x,y)  (IBLK(x,y) |= MaskVisit)
#define fVISIT(x,y)    ((IBLK(x,y) & MaskVisit) != 0)

#define fGUESSBOMB(x,y)  (iBLK(x,y) == iBlkBombUp)
#define fGUESSMARK(x,y)  (iBLK(x,y) == iBlkGuessUp)
#define SetBlk(x,y,blk)  (IBLK(x,y) = (char) ((IBLK(x,y) & MaskFlags) | blk))


/*** Status Stuff ***/

#define fPlay      0x01		/* ON if playing game, OFF if game over */
#define fPause     0x02		/* ON if paused */
#define fPanic     0x04		/* ON if panic  */
#define fIcon      0x08    /* ON if iconic */
#define fDemo      0x10		/* ON if demo   */

#define fStatusIcon    (fStatus & fIcon)
#define fStatusPlay    (fStatus & fPlay)
#define fStatusPanic   (fStatus & fPanic)
#define fStatusPause   (fStatus & fPause)
#define fStatusDemo    (fStatus & fDemo)

#define SetStatusPlay  (fStatus = fPlay)
#define SetStatusPause (fStatus |= fPause)
#define SetStatusPanic (fStatus |= fPanic)
#define SetStatusIcon  (fStatus |= fIcon)
#define SetStatusDemo  (fStatus = fDemo)

#define ClrStatusPlay  (fStatus &= 0xFE)
#define ClrStatusPause (fStatus &= 0xFD)
#define ClrStatusPanic (fStatus &= 0xFB)
#define ClrStatusIcon  (fStatus &= 0xF7)
#define ClrStatusDemo  (fStatus &= 0xEF)

#define fLose  fFalse
#define fWin   fTrue


typedef INT BLK;



/*** Routines ***/

VOID StartGame(VOID);
VOID StopGame(VOID);
VOID DoTimer(VOID);

VOID TrackMouse(INT, INT);
VOID DoButton1Up(VOID);
VOID MakeGuess(INT, INT);

VOID PauseGame(VOID);
VOID ResumeGame(VOID);
VOID ClearField(VOID);

VOID CalcFrameRect(VOID);
VOID UpdateBombCount(INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\rtns.c ===
/**********/
/* mine.c */
/**********/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "res.h"
#include "main.h"
#include "rtns.h"
#include "util.h"
#include "grafix.h"
#include "sound.h"
#include "pref.h"


/*** External Data ***/

extern HWND   hwndMain;

/*** Global/Local Variables ***/


PREF    Preferences;

INT     xBoxMac;                        /* Current width of field        */
INT     yBoxMac;                        /* Current height of field       */

INT     dxWindow;               /* current width of window */
INT     dyWindow;

INT wGameType;          /* Type of game */
INT iButtonCur = iButtonHappy;

INT     cBombStart;             /* Count of bombs in field       */
INT     cBombLeft;              /* Count of bomb locations left  */
INT     cBoxVisit;              /* Count of boxes visited        */
INT     cBoxVisitMac;   /* count of boxes need to visit */

INT     cSec;                           /* Count of seconds remaining    */


BOOL  fTimer = fFalse;
BOOL  fOldTimerStatus = fFalse;

INT     xCur = -1;      /* Current position of down box */
INT     yCur = -1;

CHAR rgBlk[cBlkMax];


#define iStepMax 100

INT rgStepX[iStepMax];
INT rgStepY[iStepMax];

INT iStepMac;



/*** Global/External Variables ***/

extern BOOL fBlock;


extern INT fStatus;




/****** F  C H E C K  W I N ******/

/* Return TRUE if player won the game */

#if 0

BOOL fCheckWin(VOID)
{
        if (cBombLeft)
                return (fFalse);
        else
                return ((cBoxVisit + cBombStart) == (xBoxMac*yBoxMac));

}

#else

#define fCheckWin()     (cBoxVisit == cBoxVisitMac)

#endif



/****** C H A N G E  B L K ******/

VOID ChangeBlk(INT x, INT y, INT iBlk)
{

        SetBlk(x,y, iBlk);

        DisplayBlk(x,y);
}


/****** C L E A R  F I E L D ******/

VOID ClearField(VOID)
{
        REGISTER i;

        for (i = cBlkMax; i-- != 0; )                   /* zero all of data */
                rgBlk[i] = (CHAR) iBlkBlankUp;

        for (i = xBoxMac+2; i-- != 0; ) /* initialize border */
                {
                SetBorder(i,0);
                SetBorder(i,yBoxMac+1);
                }
        for (i = yBoxMac+2; i-- != 0;)
                {
                SetBorder(0,i);
                SetBorder(xBoxMac+1,i);
                }
}



/******* C O U N T  B O M B S *******/

/* Count the bombs surrounding the point */

INT CountBombs(INT xCenter, INT yCenter)
{
        REGISTER INT    x;
        REGISTER INT    y;
        INT     cBombs = 0;

        for(y = yCenter-1; y <= yCenter+1; y++)
                for(x = xCenter-1; x <= xCenter+1; x++)
                        if(fISBOMB(x,y))
                                cBombs++;

        return(cBombs);
}


/****** S H O W  B O M B S ******/

/* Display hidden bombs and wrong bomb guesses */

VOID ShowBombs(INT iBlk)
{
        REGISTER INT    x;
        REGISTER INT    y;

        for(y = 1; y <= yBoxMac; y++)
                {
                for(x = 1; x <= xBoxMac; x++)
                        {
                        if (!fVISIT(x,y))
                                {
                                if (fISBOMB(x,y))
                                        {
                                        if (!fGUESSBOMB(x,y) )
                                                SetBlk(x,y, iBlk);
                                        }
                                else if (fGUESSBOMB(x,y))
                                        SetBlk(x,y, iBlkWrong);
                                }
                        }
                }

        DisplayGrid();
}



/****** G A M E  O V E R ******/

VOID GameOver(BOOL fWinLose)
{
        fTimer = fFalse;
        DisplayButton(iButtonCur = fWinLose ? iButtonWin : iButtonLose);
        ShowBombs(fWinLose ? iBlkBombUp : iBlkBombDn);
        if (fWinLose && (cBombLeft != 0))
                UpdateBombCount(-cBombLeft);
        PlayTune(fWinLose ? TUNE_WINGAME : TUNE_LOSEGAME);
        SetStatusDemo;

        if (fWinLose && (Preferences.wGameType != wGameOther)
                && (cSec < Preferences.rgTime[Preferences.wGameType]))
                {
                Preferences.rgTime[Preferences.wGameType] = cSec;
                DoEnterName();
                DoDisplayBest();
                }
}


/****** D O  T I M E R ******/

VOID DoTimer(VOID)
{
        if (fTimer && (cSec < 999))
                {
                cSec++;
                DisplayTime();
                PlayTune(TUNE_TICK);
                }
}



/****** S T E P  X Y ******/

VOID StepXY(INT x, INT y)
{
        INT cBombs;
        INT iBlk = (y<<5) + x;
        BLK blk = rgBlk[iBlk];

        if ( (blk & MaskVisit) ||
                  ((blk &= MaskData) == iBlkMax) ||
                  (blk == iBlkBombUp) )
                return;

        cBoxVisit++;
        rgBlk[iBlk] = (CHAR) (MaskVisit | (cBombs = CountBombs(x,y)));

//
//      SetDIBitsToDevice(hDCCapture,
//              (x<<4)+(dxGridOff-dxBlk), (y<<4)+(dyGridOff-dyBlk),
//              dxBlk, dyBlk, 0, 0, 0, dyBlk,
//              lpDibBlks + rgDibOff[cBombs],
//              (LPBITMAPINFO) lpDibBlks, DIB_RGB_COLORS);
//
        DisplayBlk(x,y);

        if (cBombs != 0)
                return;

        rgStepX[iStepMac] = x;
        rgStepY[iStepMac] = y;

        if (++iStepMac == iStepMax)
                iStepMac = 0;
}


/****** S T E P  B O X ******/

VOID StepBox(INT x, INT y)
{
        INT iStepCur = 0;

        iStepMac = 1;


        StepXY(x,y);

        if (++iStepCur != iStepMac)

                while (iStepCur != iStepMac)
                        {
                        x = rgStepX[iStepCur];
                        y = rgStepY[iStepCur];

                        StepXY(x-1, --y);
                        StepXY(x,   y);
                        StepXY(x+1, y);

                        StepXY(x-1, ++y);
                        StepXY(x+1, y);

                        StepXY(x-1, ++y);
                        StepXY(x,   y);
                        StepXY(x+1, y);

                        if (++iStepCur == iStepMax)
                                iStepCur = 0;
                        }


}


/****** S T E P  S Q U A R E ******/

/* Step on a single square */

VOID StepSquare(INT x, INT y)
{
        if (fISBOMB(x,y))
                {
                if (cBoxVisit == 0)
                        {
                        INT xT, yT;
                        for (yT = 1; yT < yBoxMac; yT++)
                                for (xT = 1; xT < xBoxMac; xT++)
                                        if (!fISBOMB(xT,yT))
                                                {
                                                IBLK(x,y) = (CHAR) iBlkBlankUp; /* Move bomb out of way */
                                                SetBomb(xT, yT);
                                                StepBox(x,y);
                                                return;
                                                }
                        }
                else
                        {
                        ChangeBlk(x, y, MaskVisit | iBlkExplode);
                        GameOver(fLose);
                        }
                }
        else
                {
                StepBox(x,y);

                if (fCheckWin())
                        GameOver(fWin);
                }
}


/******* C O U N T  M A R K S *******/

/* Count the bomb marks surrounding the point */

INT CountMarks(INT xCenter, INT yCenter)
{
        REGISTER INT    x;
        REGISTER INT    y;
        INT     cBombs = 0;

        for(y = yCenter-1; y <= yCenter+1; y++)
                for(x = xCenter-1; x <= xCenter+1; x++)
                        if (fGUESSBOMB(x,y))
                                cBombs++;

        return(cBombs);
}



/****** S T E P  B L O C K ******/

/* Step in a block around a single square */

VOID StepBlock(INT xCenter, INT yCenter)
{
        REGISTER INT    x;
        REGISTER INT    y;
        BOOL fGameOver = fFalse;

        if (  (!fVISIT(xCenter,yCenter))
/*                      || fGUESSBOMB(xCenter,yCenter) */
                        || (iBLK(xCenter,yCenter) != CountMarks(xCenter,yCenter)) )
                                {
                                /* not a safe thing to do */
                                TrackMouse(-2, -2);     /* pop up the blocks */
                                return;
                                }

        for(y=yCenter-1; y<=yCenter+1; y++)
                for(x=xCenter-1; x<=xCenter+1; x++)
                        {
                        if (!fGUESSBOMB(x,y) && fISBOMB(x,y))
                                {
                                fGameOver = fTrue;
                                ChangeBlk(x, y, MaskVisit | iBlkExplode);
                                }
                        else
                                StepBox(x,y);
                        }

        if (fGameOver)
                GameOver(fLose);
        else if (fCheckWin())
                GameOver(fWin);
}


/****** S T A R T  G A M E *******/

VOID StartGame(VOID)
{
        BOOL fAdjust;
        INT     x;
        INT     y;

        fTimer = fFalse;

        fAdjust = (Preferences.Width != xBoxMac || Preferences.Height != yBoxMac)
                ? (fResize | fDisplay) : fDisplay;

        xBoxMac = Preferences.Width;
        yBoxMac = Preferences.Height;

        ClearField();
        iButtonCur = iButtonHappy;

        cBombStart = Preferences.Mines;

        do
                {
                do
                        {
                        x = Rnd(xBoxMac) + 1;
                        y = Rnd(yBoxMac) + 1;
                        }
                while ( fISBOMB(x,y) );

                SetBomb(x,y);
                }
        while(--cBombStart);

        cSec   = 0;
        cBombLeft = cBombStart = Preferences.Mines;
        cBoxVisit = 0;
        cBoxVisitMac = (xBoxMac * yBoxMac) - cBombLeft;
        SetStatusPlay;

        UpdateBombCount(0);

        AdjustWindow(fAdjust);
}


#define fValidStep(x,y)  (! (fVISIT(x,y) || fGUESSBOMB(x,y)) )



/****** P U S H  B O X ******/

VOID PushBoxDown(INT x, INT y)
{
        BLK iBlk = iBLK(x,y);

        if (iBlk == iBlkGuessUp)
                iBlk = iBlkGuessDn;
        else if (iBlk == iBlkBlankUp)
                iBlk = iBlkBlank;

        SetBlk(x,y,iBlk);
}


/****** P O P  B O X  U P ******/

VOID PopBoxUp(INT x, INT y)
{
        BLK iBlk = iBLK(x,y);

        if (iBlk == iBlkGuessDn)
                iBlk = iBlkGuessUp;
        else if (iBlk == iBlkBlank)
                iBlk = iBlkBlankUp;

        SetBlk(x,y,iBlk);
}



/****** T R A C K  M O U S E ******/

VOID TrackMouse(INT xNew, INT yNew)
{
        if((xNew == xCur) && (yNew == yCur))
                return;

        {
        INT xOld = xCur;
        INT yOld = yCur;

        xCur = xNew;
        yCur = yNew;

        if (fBlock)
                {
                INT x;
                INT y;
                BOOL fValidNew = fInRange(xNew, yNew);
                BOOL fValidOld = fInRange(xOld, yOld);

                INT yOldMin = max(yOld-1,1);
                INT yOldMax = min(yOld+1,yBoxMac);
                INT yCurMin = max(yCur-1,1);
                INT yCurMax = min(yCur+1,yBoxMac);
                INT xOldMin = max(xOld-1,1);
                INT xOldMax = min(xOld+1,xBoxMac);
                INT xCurMin = max(xCur-1,1);
                INT xCurMax = min(xCur+1,xBoxMac);


                if (fValidOld)
                        for (y=yOldMin; y<=yOldMax; y++)
                                for (x=xOldMin; x<=xOldMax; x++)
                                        if (!fVISIT(x,y))
                                                PopBoxUp(x, y);

                if (fValidNew)
                        for (y=yCurMin; y<=yCurMax; y++)
                                for (x=xCurMin; x<=xCurMax; x++)
                                        if (!fVISIT(x,y))
                                                PushBoxDown(x, y);

                if (fValidOld)
                        for (y=yOldMin; y<=yOldMax; y++)
                                for (x=xOldMin; x<=xOldMax; x++)
                                        DisplayBlk(x, y);

                if (fValidNew)
                        for (y=yCurMin; y<=yCurMax; y++)
                                for (x=xCurMin; x<=xCurMax; x++)
                                        DisplayBlk(x, y);
                }
        else
                {
                if (fInRange(xOld, yOld) && !fVISIT(xOld,yOld) )
                        {
                        PopBoxUp(xOld, yOld);
                        DisplayBlk(xOld, yOld);
                        }
                if (fInRange(xNew, yNew) && fValidStep(xNew, yNew))
                        {
                        PushBoxDown(xCur, yCur);
                        DisplayBlk(xCur, yCur);
                        }
                }
        }
}





/****** M A K E  G U E S S ******/

VOID MakeGuess(INT x, INT y)
{
        BLK     iBlk;

        if(fInRange(x,y))
                {
                if(!fVISIT(x,y))
                        {
                        if(fGUESSBOMB(x,y))
                                {
                                if (Preferences.fMark)
                                        iBlk = iBlkGuessUp;
                                else
                                        iBlk = iBlkBlankUp;
                                UpdateBombCount(+1);
                                }
                        else if(fGUESSMARK(x,y))
                                {
                                iBlk = iBlkBlankUp;
                                }
                        else
                                {
                                iBlk = iBlkBombUp;
                                UpdateBombCount(-1);
                                }

                        ChangeBlk(x,y, iBlk);

                        if (fGUESSBOMB(x,y) && fCheckWin())
                                GameOver(fWin);
                        }
                }
}

/****** D O  B U T T O N  1  U P ******/

VOID DoButton1Up(VOID)
{
        if (fInRange(xCur, yCur))
                {

                if ((cBoxVisit == 0) && (cSec == 0))
                        {
                        PlayTune(TUNE_TICK);
                        cSec++;
                        DisplayTime();
                        fTimer = fTrue;

                        // Start the timer now. If we had started it earlier,
                        // the interval between tick 1 and 2 is not correct.
                        if (SetTimer(hwndMain, ID_TIMER, 1000 , NULL) == 0)
		                    {
		                    ReportErr(ID_ERR_TIMER);
		                    }
                        }

                if (!fStatusPlay)
                        xCur = yCur = -2;

                if (fBlock)
                        StepBlock(xCur, yCur);
                else
                        if (fValidStep(xCur, yCur))
                                StepSquare(xCur, yCur);
                }

        DisplayButton(iButtonCur);
}


/****** P A U S E  G A M E ******/

VOID PauseGame(VOID)
{
        EndTunes();
        // remember the oldtimer status.

	if (!fStatusPause)
        	fOldTimerStatus = fTimer;
        if (fStatusPlay)
                fTimer = fFalse;

        SetStatusPause;
}


/****** R E S U M E  G A M E ******/

VOID ResumeGame(VOID)
{
        // restore to the old timer status.
        if (fStatusPlay)
                fTimer = fOldTimerStatus;

        ClrStatusPause;
}


/****** U P D A T E  B O M B  C O U N T ******/

VOID UpdateBombCount(INT BombAdjust)
{
        cBombLeft += BombAdjust;
        DisplayBombCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\winmine.c ===
/****************************************************************************

    PROGRAM: WinMine  (a.k.a. Mines, BombSquad, MineSweeper...)

****************************************************************************/

#define _WINDOWS
#include <windows.h>
#include <port1632.h>
#include <htmlhelp.h>   // for HtmlHelp()
#include <commctrl.h>   // for fusion classes.

#include "main.h"
#include "rtns.h"
#include "grafix.h"
#include "res.h"
#include "pref.h"
#include "util.h"
#include "sound.h"
#include "context.h"
#include "string.h"
#include "stdio.h"
#include "dos.h"

#ifndef WM_ENTERMENULOOP
#define WM_ENTERMENULOOP 0x0211
#define WM_EXITMENULOOP  0x0212
#endif

BOOL bInitMinimized;  /* Bug #13328: HACK!  Don't permit MoveWindow or  */
                      /* InvalidateRect when initially minimized.       */
                      /* 19 September 1991   Clark R. Cyr               */

HANDLE hInst;
HWND   hwndMain;
HMENU  hMenu;

// Icon handles to load the winmine icon.
HICON   hIconMain;

BOOL fButton1Down = fFalse;
BOOL fBlock       = fFalse;
BOOL fIgnoreClick = fFalse;

INT dypCaption;
INT dypMenu;
INT dypBorder;
INT dxpBorder;

INT  fStatus = (fDemo + fIcon);
BOOL fLocalPause = fFalse;

TCHAR szClass[cchNameMax];
#define szWindowTitle szClass

TCHAR szTime[cchNameMax];
TCHAR szDefaultName[cchNameMax];


extern BOOL fUpdateIni;

extern INT xCur;
extern INT yCur;
extern INT iButtonCur;

extern INT xBoxMac;
extern INT yBoxMac;

extern PREF Preferences;
extern INT  cBoxVisit;

INT dxWindow;
INT dyWindow;
INT dypCaption;
INT dypMenu;
INT dypAdjust;


INT idRadCurr = 0;

#define iPrefMax 3
#define idRadMax 3

INT	rgPrefEditID[iPrefMax] =
	{ID_EDIT_MINES, ID_EDIT_HEIGHT, ID_EDIT_WIDTH};

INT	rgLevelData[idRadMax][iPrefMax] = {
	{10, MINHEIGHT,  MINWIDTH, },
	{40, 16, 16,},
	{99, 16, 30,}
	};


#ifndef DEBUG
#define XYZZY
#define cchXYZZY 5
INT     iXYZZY = 0;
TCHAR   szXYZZY[cchXYZZY+1] = TEXT("XYZZY");
extern  CHAR rgBlk[cBlkMax];
#endif


LRESULT  APIENTRY MainWndProc(HWND,  UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY PrefDlgProc(HWND,  UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY BestDlgProc(HWND,  UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY EnterDlgProc(HWND,  UINT, WPARAM, LPARAM);





/****** W I N  M A I N ******/

MMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
/* { */
	MSG msg;
	HANDLE hAccel;

	hInst = hInstance;

	InitConst();

    bInitMinimized = (nCmdShow == SW_SHOWMINNOACTIVE) ||
                     (nCmdShow == SW_SHOWMINIMIZED) ;

#ifdef WIN16
	if (hPrevInstance)
		{
		HWND hWnd = FindWindow(szClass, NULL);
		hWnd = GetLastActivePopup(hWnd);
		BringWindowToTop(hWnd);
		if (!bInitMinimized && IsIconic(hWnd))
			SendMessage(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
		return fFalse;
		}
#endif

#ifdef NOSERVER		/*** Not in final release ***/
	{
	TCHAR  szFile[256];

	GetModuleFileName(hInst, szFile, 250);

	if (szFile[0] > TEXT('C'))
		{
		szFile[0] = TEXT('X');
		if (!lstrcmp(szFile, TEXT("X:\\WINGAMES\\WINMINE\\WINMINE.EXE")))
			{
			MessageBox(GetFocus(),
				TEXT("Please copy winmine.exe and aboutwep.dll to your machine and run it from there."),
				TEXT("NO NO NO NO NO"),
				MB_OK);
			return fFalse;
			}
		}
	}
#endif


#ifdef EXPIRE			/*** Not in final release ***/
	{
	struct dosdate_t ddt;

	_dos_getdate(&ddt);

	if ((ddt.month + ddt.year*12) > (9 + 1990*12))
		{
		MessageBox(GetFocus(),
			TEXT("This game has expired. Please obtain an official copy from the Windows Entertainment Package."),
			TEXT("SORRY"),
			MB_OK);
		return fFalse;
		}
	}
#endif


	{
	WNDCLASS  wc;
	INITCOMMONCONTROLSEX icc;   // common control registration.

	// Register the common controls.
	icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icc.dwICC  = ICC_ANIMATE_CLASS | ICC_BAR_CLASSES | ICC_COOL_CLASSES | ICC_HOTKEY_CLASS | ICC_LISTVIEW_CLASSES | 
			ICC_PAGESCROLLER_CLASS | ICC_PROGRESS_CLASS | ICC_TAB_CLASSES | ICC_UPDOWN_CLASS | ICC_USEREX_CLASSES;
	InitCommonControlsEx(&icc);


	hIconMain = LoadIcon(hInst, MAKEINTRESOURCE(ID_ICON_MAIN));

	wc.style = 0;
	wc.lpfnWndProc   = MainWndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hInst;
	wc.hIcon         = hIconMain;
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(LTGRAY_BRUSH);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = szClass;

	if (!RegisterClass(&wc))
		return fFalse;
	}

	hMenu = LoadMenu(hInst, MAKEINTRESOURCE(ID_MENU));
	hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(ID_MENU_ACCEL));


	ReadPreferences();

	hwndMain = CreateWindow( szClass, szWindowTitle,
                WS_OVERLAPPED | WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU, 
                Preferences.xWindow-dxpBorder, Preferences.yWindow-dypAdjust,
		dxWindow+dxpBorder, dyWindow +dypAdjust,
		NULL, NULL, hInst, NULL);

	if (!hwndMain)
		{
		ReportErr(1000);
		return fFalse;
		}

	AdjustWindow(fCalc);


	if (!FInitLocal())
		{
		ReportErr(ID_ERR_MEM);
		return fFalse;
		}

	SetMenuBar(Preferences.fMenu);

	StartGame();

	ShowWindow(hwndMain, SW_SHOWNORMAL);
	UpdateWindow(hwndMain);

    bInitMinimized = FALSE;

	while (GetMessage(&msg, NULL, 0, 0))
		{
		if (!TranslateAccelerator(hwndMain, hAccel, &msg))
			{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			}
		}

	CleanUp();

    if (fUpdateIni)
        WritePreferences();

	return ((INT) msg.wParam);
}


/****** F  L O C A L  B U T T O N ******/

BOOL FLocalButton(LPARAM lParam)
{
	BOOL fDown = fTrue;
	RECT rcCapt;
	MSG msg;

	msg.pt.x = LOWORD(lParam);
	msg.pt.y = HIWORD(lParam);

	rcCapt.right  = dxButton + (rcCapt.left = (dxWindow-dxButton) >> 1);
	rcCapt.bottom = dyButton +	(rcCapt.top = dyTopLed);

	if (!PtInRect(&rcCapt, msg.pt))
		return fFalse;

	SetCapture(hwndMain);

	DisplayButton(iButtonDown);

	MapWindowPoints(hwndMain , NULL , (LPPOINT) &rcCapt , 2);

	while (fTrue)
		{
      if (PeekMessage(&msg, hwndMain, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
			{

		switch (msg.message)
			{
	   case WM_LBUTTONUP:
			if (fDown)
				{
				if (PtInRect(&rcCapt, msg.pt))
					{
					DisplayButton(iButtonCur = iButtonHappy);
					StartGame();
					}
				}
			ReleaseCapture();
			return fTrue;

	   case WM_MOUSEMOVE:
			if (PtInRect(&rcCapt, msg.pt))
		   	{
				if (!fDown)
					{
               fDown = fTrue;
					DisplayButton(iButtonDown);
					}
				}
			else
				{
				if (fDown)
					{
               fDown = fFalse;
					DisplayButton(iButtonCur);
					}
				}
		default:
			;
			}	/* switch */
		}	

    	}	/* while */
}



/****** F I X  M E N U S ******/

VOID FixMenus(VOID)
{
	CheckEm(IDM_BEGIN,  Preferences.wGameType == wGameBegin);
	CheckEm(IDM_INTER,  Preferences.wGameType == wGameInter);
	CheckEm(IDM_EXPERT, Preferences.wGameType == wGameExpert);
	CheckEm(IDM_CUSTOM, Preferences.wGameType == wGameOther);

	CheckEm(IDM_COLOR,  Preferences.fColor);
	CheckEm(IDM_MARK,   Preferences.fMark);
	CheckEm(IDM_SOUND,  Preferences.fSound);
}



/****** D O  P R E F ******/

VOID DoPref(VOID)
{

	DialogBox(hInst, MAKEINTRESOURCE(ID_DLG_PREF), hwndMain, PrefDlgProc);

    Preferences.wGameType = wGameOther;
	FixMenus();
	fUpdateIni = fTrue;
	StartGame();
}


/****** D O  E N T E R  N A M E ******/

VOID DoEnterName(VOID)
{
	DialogBox(hInst, MAKEINTRESOURCE(ID_DLG_ENTER), hwndMain, EnterDlgProc);
	fUpdateIni = fTrue;
}


/****** D O  D I S P L A Y  B E S T ******/

VOID DoDisplayBest(VOID)
{
	DialogBox(hInst, MAKEINTRESOURCE(ID_DLG_BEST), hwndMain, BestDlgProc);
}

				
/****** M A I N  W N D  P R O C ******/

LRESULT  APIENTRY MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{

	switch (message)
		{
	case WM_WINDOWPOSCHANGED:
		if (!fStatusIcon)
			{
			Preferences.xWindow = ((LPWINDOWPOS) (lParam))->x;
			Preferences.yWindow = ((LPWINDOWPOS) (lParam))->y;
			}	
		break;

	case WM_SYSCOMMAND:
		switch (wParam & 0xFFF0)
			{
		case SC_MINIMIZE:

            		PauseGame();
			SetStatusPause;
			SetStatusIcon;
			break;
			
		case SC_RESTORE:
			ClrStatusPause;
			ClrStatusIcon;
			ResumeGame();

//Japan Bug fix: 1/19/93 Enable the first click after restoring from icon.
			fIgnoreClick = fFalse;
			break;

		default:
			break;
			}
			
		break;


	case WM_COMMAND:
	    {
	    switch(GET_WM_COMMAND_ID(wParam, lParam)) {

	    case IDM_NEW:
		    StartGame();
		    break;
						
	    /** IDM_NEW **/
	    case IDM_EXIT:
		    ShowWindow(hwndMain, SW_HIDE);
#ifdef ORGCODE
		    goto LExit;
#else
            SendMessage(hwndMain, WM_SYSCOMMAND, SC_CLOSE, 0);
            return(0);
#endif
	    /** IDM_SKILL **/
	    case IDM_BEGIN:
	    case IDM_INTER:
	    case IDM_EXPERT:
		    Preferences.wGameType = (WORD)(GET_WM_COMMAND_ID(wParam, lParam) - IDM_BEGIN);
		    Preferences.Mines  = rgLevelData[Preferences.wGameType][0];
		    Preferences.Height = rgLevelData[Preferences.wGameType][1];
		    Preferences.Width  = rgLevelData[Preferences.wGameType][2];
		    StartGame();
		    goto LUpdateMenu;

	    case IDM_CUSTOM:
		    DoPref();
		    break;

	    /** IDM_OPTIONS **/
	    case IDM_SOUND:
		    if (Preferences.fSound)
			    {
			    EndTunes();
			    Preferences.fSound = fFalse;
			    }
		    else
			    {
			    Preferences.fSound = FInitTunes();
			    }
		    goto LUpdateMenu;

	    case IDM_COLOR:
		    Preferences.fColor = !Preferences.fColor;
		    FreeBitmaps();
		    if (!FLoadBitmaps())
			    {
			    ReportErr(ID_ERR_MEM);
#ifdef ORGCODE
			    goto LExit;
#else
                SendMessage(hwndMain, WM_SYSCOMMAND, SC_CLOSE, 0);
                return(0);
#endif
			    }
		    DisplayScreen();
		    goto LUpdateMenu;

	    case IDM_MARK:
		    Preferences.fMark = !Preferences.fMark;
	    /* IE	goto LUpdateMenu;	*/

    LUpdateMenu:
		    fUpdateIni = fTrue;
		    SetMenuBar(Preferences.fMenu);
		    break;

	    case IDM_BEST:
		    DoDisplayBest();
		    break;


	    /** IDM_HELP **/
	    case IDM_HELP:
		    DoHelp(HELP_INDEX, HH_DISPLAY_TOPIC);
		    break;

	    case IDM_HOW2PLAY:
		    DoHelp(HELP_CONTEXT, HH_DISPLAY_INDEX);
		    break;

	    case IDM_HELP_HELP:
		    DoHelp(HELP_HELPONHELP, HH_DISPLAY_TOPIC);
		    break;

	    case IDM_HELP_ABOUT:
		    DoAbout();
		    return 0;

	    default:
		    break;
	    }

	} /**** END OF MENUS ****/

		break;



	case WM_KEYDOWN:
		switch (wParam)
			{

#if 0
		case VK_F1:
			DoHelp(HELP_INDEX, 0L);
			break;

		case VK_F2:
			StartGame();
			break;

		case VK_F3:
			break;

#endif
		case VK_F4:
			if (FSoundSwitchable())
				if (FSoundOn())
					{
					EndTunes();
					Preferences.fSound = fsoundOff;
					}
				else
					Preferences.fSound = FInitTunes();
			break;

		case VK_F5:
			if (FMenuSwitchable())
				SetMenuBar(fmenuOff);
			break;

		case VK_F6:
			if (FMenuSwitchable())
				SetMenuBar(fmenuOn);
			break;

#ifdef XYZZY
		case VK_SHIFT:
			if (iXYZZY >= cchXYZZY)
				iXYZZY ^= 20;
			break;

		default:
			if (iXYZZY < cchXYZZY)
				iXYZZY = (szXYZZY[iXYZZY] == (TCHAR) wParam) ? iXYZZY+1 : 0;
			break;

#else
		default:
			break;
#endif
			}	
		break;

/*  	case WM_QUERYENDSESSION:    SHOULDNT BE USED (JAP)*/

	case WM_DESTROY:
//LExit:
        KillTimer(hwndMain, ID_TIMER);
    	PostQuitMessage(0);
	    break;

	case WM_MBUTTONDOWN:
		if (fIgnoreClick)
			{
			fIgnoreClick = fFalse;
			return 0;
			}

		if (!fStatusPlay)
			break;

		fBlock = fTrue;
		goto LBigStep;

	case WM_LBUTTONDOWN:

		if (fIgnoreClick)
			{
			fIgnoreClick = fFalse;
			return 0;
			}

		if (FLocalButton(lParam))
			return 0;

		if (!fStatusPlay)
			break;
		fBlock = (wParam & (MK_SHIFT | MK_RBUTTON)) ? fTrue : fFalse;

LBigStep:
		SetCapture(hWnd);
		fButton1Down = fTrue;

		xCur = -1;
		yCur = -1;
		DisplayButton(iButtonCaution);

	case WM_MOUSEMOVE:
		if (fButton1Down)
			{
			if (fStatus & fPlay)
				TrackMouse(xBoxFromXpos(LOWORD(lParam)), yBoxFromYpos(HIWORD(lParam)) );
			else
				goto LFixTimeOut;
			}
#ifdef XYZZY
        //
        // This is the cheat:
        // If you hold down the shift key and type 'XYZZY'
        // then when you hold down the control key, to upper
        // left hand corner pixel will show the state of the
        // mine field under the mouse.  Oh. joy.  I can win.
        //
		else if (iXYZZY != 0)
			if (((iXYZZY == cchXYZZY) && (wParam & MK_CONTROL))
			   ||(iXYZZY > cchXYZZY))
			{
			xCur = xBoxFromXpos(LOWORD(lParam));
			yCur = yBoxFromYpos(HIWORD(lParam));
			if (fInRange(xCur, yCur))
				{
                HDC hDC = GetDC(NULL);                
				SetPixel(hDC, 0, 0, fISBOMB(xCur, yCur) ? 0L : 0x00FFFFFFL);
				ReleaseDC(NULL, hDC);
				}
			}
#endif
		break;

	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_LBUTTONUP:
		if (fButton1Down)
			{
LFixTimeOut:
			fButton1Down = fFalse;
			ReleaseCapture();
			if (fStatus & fPlay)
				DoButton1Up();
			else
				TrackMouse(-2,-2);
			}
		break;

	case WM_RBUTTONDOWN:
		if (fIgnoreClick)
			{
			fIgnoreClick = fFalse;
			return 0;
			}

		if(!fStatusPlay)
			break;

		if (fButton1Down)
			{
			TrackMouse(-3,-3);
			fBlock = fTrue;
			PostMessage(hwndMain, WM_MOUSEMOVE, wParam, lParam);
			}
		else if (wParam & MK_LBUTTON)
			goto LBigStep;
		else if (!fLocalPause)
			MakeGuess(xBoxFromXpos(LOWORD(lParam)), yBoxFromYpos(HIWORD(lParam)) );
		return 0;

	case WM_ACTIVATE:
		/* Window is being activated by a mouse click */
		if (GET_WM_ACTIVATE_STATE(wParam, lParam) == 2)
			fIgnoreClick = fTrue;
		break;

	case WM_TIMER:
#ifdef CHEAT
		if (!fLocalPause)
#endif
			DoTimer();
		return 0;

	case WM_ENTERMENULOOP:
		fLocalPause = fTrue;
		break;

	case WM_EXITMENULOOP:
		fLocalPause = fFalse;
		break;

	case WM_PAINT:
		{
		PAINTSTRUCT ps;
		HDC hDC = BeginPaint(hWnd,&ps);
		DrawScreen(hDC);
		EndPaint(hWnd, &ps);
		}
		return 0;

	default:
		break;

    }

	return (DefWindowProc(hWnd, message, wParam, lParam));
}




/****** DIALOG PROCEDURES ******/

/*** P R E F  D L G  P R O C ***/

INT_PTR  APIENTRY PrefDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    // for context sensitive help
    static DWORD aIds[] = {     
        ID_EDIT_HEIGHT,        IDH_PREF_EDIT_HEIGHT,
        ID_EDIT_WIDTH,         IDH_PREF_EDIT_WIDTH,
        ID_EDIT_MINES,         IDH_PREF_EDIT_MINES,
        ID_TXT_HEIGHT,         IDH_PREF_EDIT_HEIGHT,
        ID_TXT_WIDTH,          IDH_PREF_EDIT_WIDTH,
        ID_TXT_MINES,          IDH_PREF_EDIT_MINES,
        0,0 }; 

	switch (message)
		{
	case WM_INITDIALOG:
		SetDlgItemInt(hDlg, ID_EDIT_HEIGHT, Preferences.Height ,fFalse);
		SetDlgItemInt(hDlg, ID_EDIT_WIDTH,  Preferences.Width  ,fFalse);
		SetDlgItemInt(hDlg, ID_EDIT_MINES,  Preferences.Mines  ,fFalse);
		return (fTrue);

	case WM_COMMAND:
		switch(GET_WM_COMMAND_ID(wParam, lParam)) {
		case ID_BTN_OK:
		case IDOK:
			{

			Preferences.Height = GetDlgInt(hDlg, ID_EDIT_HEIGHT, MINHEIGHT, 24);
			Preferences.Width  = GetDlgInt(hDlg, ID_EDIT_WIDTH,  MINWIDTH,  30);
			Preferences.Mines  = GetDlgInt(hDlg, ID_EDIT_MINES,  10,
				min(999, (Preferences.Height-1) * (Preferences.Width-1) ) );

			}

			/* Fall Through & Exit */
		case ID_BTN_CANCEL:
		case IDCANCEL:
			EndDialog(hDlg, fTrue);	      /* Exits the dialog box	     */
			return fTrue;

		default:
			break;
			}
        break;

    // context sensitive help.
    case WM_HELP: 
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("winmine.hlp"), 
                HELP_WM_HELP, (ULONG_PTR) aIds);         
        break;  

    case WM_CONTEXTMENU: 
        WinHelp((HWND) wParam, TEXT("winmine.hlp"), HELP_CONTEXTMENU, 
                (ULONG_PTR) aIds);         
        break;   
		}

    return (fFalse);			/* Didn't process a message    */
}


/*** S E T  D T E X T ***/

VOID SetDText(HWND hDlg, INT id, INT time, TCHAR FAR * szName)
{
	TCHAR sz[cchNameMax];

	wsprintf(sz, szTime, time);
	SetDlgItemText(hDlg, id, sz);
	SetDlgItemText(hDlg, id+1, szName);
}


/****** B E S T  D L G  P R O C ******/

INT_PTR  APIENTRY BestDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    // for context sensitive help
    static DWORD aIds[] = {     
        ID_BTN_RESET,        IDH_BEST_BTN_RESET,
        ID_STEXT1,           IDH_STEXT,
        ID_STEXT2,           IDH_STEXT,
        ID_STEXT3,           IDH_STEXT,
        ID_TIME_BEGIN,       IDH_STEXT,
        ID_TIME_INTER,       IDH_STEXT,
        ID_TIME_EXPERT,      IDH_STEXT,
        ID_NAME_BEGIN,       IDH_STEXT,
        ID_NAME_INTER,       IDH_STEXT,
        ID_NAME_EXPERT,      IDH_STEXT,

        0,0 }; 

	switch (message)
		{
	case WM_INITDIALOG:
LReset:	
		SetDText(hDlg, ID_TIME_BEGIN, Preferences.rgTime[wGameBegin], Preferences.szBegin);
		SetDText(hDlg, ID_TIME_INTER, Preferences.rgTime[wGameInter],  Preferences.szInter);
		SetDText(hDlg, ID_TIME_EXPERT, Preferences.rgTime[wGameExpert], Preferences.szExpert);
		return (fTrue);

	case WM_COMMAND:
		switch(GET_WM_COMMAND_ID(wParam, lParam)) {
		case ID_BTN_RESET:
			Preferences.rgTime[wGameBegin] = Preferences.rgTime[wGameInter]
				= Preferences.rgTime[wGameExpert] = 999;
			lstrcpy(Preferences.szBegin,  szDefaultName);
			lstrcpy(Preferences.szInter,  szDefaultName);
			lstrcpy(Preferences.szExpert, szDefaultName);
			fUpdateIni = fTrue;
			goto LReset;
			
		case ID_BTN_OK:
		case IDOK:
		case ID_BTN_CANCEL:
		case IDCANCEL:
			EndDialog(hDlg, fTrue);	      /* Exits the dialog box	     */
			return fTrue;

		default:
			break;
			}
        break;

    // context sensitive help.
    case WM_HELP: 
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("winmine.hlp"), 
                HELP_WM_HELP, (ULONG_PTR) aIds);         
        break;  

    case WM_CONTEXTMENU: 
        WinHelp((HWND) wParam, TEXT("winmine.hlp"), HELP_CONTEXTMENU, 
                (ULONG_PTR) aIds);         
        break;   
		}

	return (fFalse);			/* Didn't process a message    */
}



/****** E N T E R  D L G  P R O C ******/

INT_PTR  APIENTRY EnterDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

	switch (message)
		{
	case WM_INITDIALOG:
		{
		TCHAR sz[cchMsgMax];

		LoadSz((WORD)(Preferences.wGameType+ID_MSG_BEGIN), sz, ARRAYSIZE(sz));

		SetDlgItemText(hDlg, ID_TEXT_BEST, sz);

		SendMessage(GetDlgItem(hDlg, ID_EDIT_NAME), EM_SETLIMITTEXT, cchNameMax, 0L);

		SetDlgItemText(hDlg, ID_EDIT_NAME,
			(Preferences.wGameType == wGameBegin) ? Preferences.szBegin :
			(Preferences.wGameType == wGameInter) ? Preferences.szInter :
			 Preferences.szExpert);
		}
		return (fTrue);

	case WM_COMMAND:
		switch(GET_WM_COMMAND_ID(wParam, lParam)) {
		case ID_BTN_OK:
		case IDOK:
		case ID_BTN_CANCEL:
		case IDCANCEL:

			GetDlgItemText(hDlg, ID_EDIT_NAME,
				(Preferences.wGameType == wGameBegin) ? Preferences.szBegin :
				(Preferences.wGameType == wGameInter) ? Preferences.szInter :
				 Preferences.szExpert, cchNameMax);

			EndDialog(hDlg, fTrue);	      /* Exits the dialog box	     */
			return fTrue;

		default:
			break;
			}
		}

	return (fFalse);			/* Didn't process a message    */
        (lParam);
}





/****** A D J U S T  W I N D O W ******/

// Our verion of GetSystemMetrics
// 
// Tries to return whole screen (include other monitor) info
//

INT OurGetSystemMetrics( INT nIndex )
{
    INT Result=0;

    switch( nIndex )
    {
    case SM_CXSCREEN:
        Result= GetSystemMetrics( SM_CXVIRTUALSCREEN );
        if( !Result )
            Result= GetSystemMetrics( SM_CXSCREEN );
        break;

    case SM_CYSCREEN:
        Result= GetSystemMetrics( SM_CYVIRTUALSCREEN );
        if( !Result )
            Result= GetSystemMetrics( SM_CYSCREEN );
        break;

    default:
        Result= GetSystemMetrics( nIndex );
        break;
    }

    return( Result );
}

VOID AdjustWindow(INT fAdjust)
{
	REGISTER t;
	RECT rect;
    BOOL bDiffLevel = FALSE;
    RECT rectGame, rectHelp;

	// an extra check
	if (!hwndMain)
		return;

	dypAdjust = dypCaption;

	if (FMenuOn())
        {
        // dypMenu is initialized to GetSystemMetrics(SM_CYMENU) + 1,
        // which is the height of one menu line
        dypAdjust += dypMenu;

        // If the menu extends on two lines (because of the large-size
        // font the user has chosen for the menu), increase the size
        // of the window.

        // The two menus : "Game" and "Help" are on the same line, if
        // their enclosing rectangles top match. In that case, we don't
        // need to extend the window size.
        // If the tops do not match, that means they are on two lines.
        // In that case, extend the size of the window by size of
        // one menu line.
       
        if (hMenu && GetMenuItemRect(hwndMain, hMenu, 0, &rectGame) &&
                GetMenuItemRect(hwndMain, hMenu, 1, &rectHelp))
            {
            if (rectGame.top != rectHelp.top)
                {
                dypAdjust += dypMenu;
                bDiffLevel = TRUE;
                }
            }
        }

	dxWindow = dxBlk * xBoxMac + dxGridOff + dxRightSpace;
	dyWindow = dyBlk * yBoxMac + dyGridOff + dyBottomSpace;

	if ((t = Preferences.xWindow+dxWindow - OurGetSystemMetrics(SM_CXSCREEN)) > 0)
		{
		fAdjust |= fResize;
		Preferences.xWindow -= t;
		}

	if ((t = Preferences.yWindow+dyWindow - OurGetSystemMetrics(SM_CYSCREEN)) > 0)
		{
		fAdjust |= fResize;
		Preferences.yWindow -= t;
		}

    if (!bInitMinimized)
        {
    	if (fAdjust & fResize)
    		{
    		MoveWindow(hwndMain, Preferences.xWindow, Preferences.yWindow,
    			dxWindow+dxpBorder, dyWindow + dypAdjust, fTrue);
    		}

        // after the window is adjusted, the "Game" and "Help" may move to the
        // same line creating extra space at the bottom. so check again!

        if (bDiffLevel && hMenu && GetMenuItemRect(hwndMain, hMenu, 0, &rectGame) &&
                GetMenuItemRect(hwndMain, hMenu, 1, &rectHelp))
            {
            if (rectGame.top == rectHelp.top)
                {
                dypAdjust -= dypMenu;
    		    MoveWindow(hwndMain, Preferences.xWindow, Preferences.yWindow,
    			    dxWindow+dxpBorder, dyWindow + dypAdjust, fTrue);
                }
            }
       
    	if (fAdjust & fDisplay)
    		{
    		SetRect(&rect, 0, 0, dxWindow, dyWindow);
    		InvalidateRect(hwndMain, &rect, fTrue);
    		}


        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\ep\winmine\util.c ===
/**********/
/* util.c */
/**********/

#define  _WINDOWS
#include <windows.h>
#include <htmlhelp.h>   // for HtmlHelp()
#include "shellapi.h"   // for ShellAbout
#include <port1632.h>

#include "main.h"
#include "res.h"
#include "pref.h"
#include "util.h"
#include "sound.h"
#include "rtns.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "dos.h"

extern INT dypBorder;
extern INT dxpBorder;
extern INT dypCaption;
extern INT dypMenu;

extern TCHAR szClass[cchNameMax];
extern TCHAR szTime[cchNameMax];
extern TCHAR szDefaultName[cchNameMax];

extern HANDLE hInst;
extern HWND   hwndMain;
extern HMENU  hMenu;

extern PREF Preferences;

extern  HKEY g_hReg;
extern  TCHAR * rgszPref[iszPrefMax];
TCHAR   szIniFile[] = TEXT("entpack.ini");


/****** R N D ******/

/* Return a random number between 0 and rndMax */

INT Rnd(INT rndMax)
{
        return (rand() % rndMax);
}



/****** R E P O R T  E R R ******/

/* Report and error and exit */

VOID ReportErr(WORD idErr)
{
        TCHAR szMsg[cchMsgMax];
        TCHAR szMsgTitle[cchMsgMax];

        if (idErr < ID_ERR_MAX)
                LoadString(hInst, idErr, szMsg, cchMsgMax);
        else
                {
                LoadString(hInst, ID_ERR_UNKNOWN, szMsgTitle, cchMsgMax);
                wsprintf(szMsg, szMsgTitle, idErr);
                }

        LoadString(hInst, ID_ERR_TITLE, szMsgTitle, cchMsgMax);

        MessageBox(NULL, szMsg, szMsgTitle, MB_OK | MB_ICONHAND);
}


/****** L O A D  S Z ******/

VOID LoadSz(WORD id, TCHAR * sz, DWORD cch)
{
        if (LoadString(hInst, id, sz, cch) == 0)
                ReportErr(1001);
}


// Routines to read the ini file.

INT ReadIniInt(INT iszPref, INT valDefault, INT valMin, INT valMax)
{
	return max(valMin, min(valMax,
		(INT) GetPrivateProfileInt(szClass, rgszPref[iszPref], valDefault, szIniFile) ) );
}

#define ReadIniBool(iszPref, valDefault) ReadIniInt(iszPref, valDefault, 0, 1)


VOID ReadIniSz(INT iszPref, TCHAR FAR * szRet)
{
	GetPrivateProfileString(szClass, rgszPref[iszPref], szDefaultName, szRet, cchNameMax, szIniFile);
}




/****** I N I T  C O N S T ******/

VOID InitConst(VOID)
{
INT     iAlreadyPlayed = 0;     // have we already updated the registry ?
DWORD   dwDisposition;
       

        srand(LOWORD(GetCurrentTime()));

        LoadSz(ID_GAMENAME, szClass, ARRAYSIZE(szClass));
        LoadSz(ID_MSG_SEC,  szTime, ARRAYSIZE(szTime));
        LoadSz(ID_NAME_DEFAULT, szDefaultName, ARRAYSIZE(szDefaultName));

        dypCaption = GetSystemMetrics(SM_CYCAPTION) + 1;
        dypMenu    = GetSystemMetrics(SM_CYMENU)    + 1;
        dypBorder  = GetSystemMetrics(SM_CYBORDER)  + 1;
        dxpBorder  = GetSystemMetrics(SM_CXBORDER)  + 1;

        // Open the registry key;
        if (RegCreateKeyEx(HKEY_CURRENT_USER, SZWINMINEREG, 0, NULL, 0, KEY_READ, NULL, 
                   &g_hReg, &dwDisposition) == ERROR_SUCCESS)
        {
            iAlreadyPlayed = ReadInt(iszPrefAlreadyPlayed, 0, 0, 1);
            RegCloseKey(g_hReg);
        }


        // Read it from the .ini file and write it to registry.
        if (!iAlreadyPlayed)
        {
            Preferences.Height= ReadIniInt(iszPrefHeight,MINHEIGHT,DEFHEIGHT,25);
            Preferences.Width= ReadIniInt(iszPrefWidth,MINWIDTH,DEFWIDTH,30);

            Preferences.wGameType = (WORD)ReadIniInt(iszPrefGame,wGameBegin, wGameBegin, wGameExpert+1);
            Preferences.Mines    = ReadIniInt(iszPrefMines, 10, 10, 999);
            Preferences.xWindow  = ReadIniInt(iszPrefxWindow, 80, 0, 1024);
            Preferences.yWindow  = ReadIniInt(iszPrefyWindow, 80, 0, 1024);

            Preferences.fSound = ReadIniInt(iszPrefSound, 0, 0, fsoundOn);
            Preferences.fMark  = ReadIniBool(iszPrefMark,  fTrue);
            Preferences.fTick  = ReadIniBool(iszPrefTick,  fFalse);
            Preferences.fMenu  = ReadIniInt(iszPrefMenu,  fmenuAlwaysOn, fmenuAlwaysOn, fmenuOn);
	
            Preferences.rgTime[wGameBegin]  = ReadIniInt(iszPrefBeginTime, 999, 0, 999);
            Preferences.rgTime[wGameInter]  = ReadIniInt(iszPrefInterTime, 999, 0, 999);
            Preferences.rgTime[wGameExpert] = ReadIniInt(iszPrefExpertTime, 999, 0, 999);

            ReadIniSz(iszPrefBeginName, Preferences.szBegin);
            ReadIniSz(iszPrefInterName, Preferences.szInter);
            ReadIniSz(iszPrefExpertName, Preferences.szExpert);

            // set the color preference so we will use the right bitmaps
            // numcolors may return -1 on true color devices
            {
            HDC hDC = GetDC(GetDesktopWindow());
            Preferences.fColor  = ReadIniBool(iszPrefColor, (GetDeviceCaps(hDC, NUMCOLORS) != 2));
            ReleaseDC(GetDesktopWindow(),hDC);
            }

            if (FSoundOn())
                Preferences.fSound = FInitTunes();
            
            // Write it to registry.
            WritePreferences();
        }

}



/* * * * * *  M E N U S  * * * * * */

/****** C H E C K  E M ******/

VOID CheckEm(WORD idm, BOOL fCheck)
{
        CheckMenuItem(hMenu, idm, fCheck ? MF_CHECKED : MF_UNCHECKED);
}

/****** S E T  M E N U  B A R ******/

VOID SetMenuBar(INT fActive)
{
        Preferences.fMenu = fActive;
        FixMenus();
        SetMenu(hwndMain, FMenuOn() ? hMenu : NULL);
        AdjustWindow(fResize);
}


/****** D O  A B O U T ******/

VOID DoAbout(VOID)
{
        TCHAR szVersion[cchMsgMax];
        TCHAR szCredit[cchMsgMax];

        LoadSz(ID_MSG_VERSION, szVersion, ARRAYSIZE(szVersion));
        LoadSz(ID_MSG_CREDIT,  szCredit, ARRAYSIZE(szCredit));

        ShellAbout(hwndMain,
          szVersion, szCredit, LoadIcon(hInst, MAKEINTRESOURCE(ID_ICON_MAIN)));
}


/****** D O  H E L P ******/

VOID DoHelp(WORD wCommand, UINT lParam)
{
        CHAR szHelpFile[cchMaxPathname];
        CHAR * pch;

        // If we are showing help_onhelp, use the 
        // nthelp.chm file else use winmine.chm
        if (wCommand != HELP_HELPONHELP)
        {
            /*
            * Replace the .exe extension on the complete path with
            * the .hlp extension instead.
            */
            pch = szHelpFile +
                  GetModuleFileNameA(hInst, szHelpFile, cchMaxPathname) - 1;

            if ( (pch-szHelpFile > 4) &&
                 (*(pch-3) == '.') ) {
                    pch -= 3;
            }
            strcpy(pch, ".chm");
        }
        else strcpy(szHelpFile, "NTHelp.chm");

        HtmlHelpA(GetDesktopWindow(), szHelpFile, lParam, 0);
}



/****** G E T  D L G  I N T ******/

INT GetDlgInt(HWND hDlg, INT dlgID, INT numLo, INT numHi)
{
        INT num;
        BOOL fFlag;

        num = GetDlgItemInt(hDlg, dlgID, &fFlag, fFalse);

        if (num < numLo)
                num = numLo;
        else if (num > numHi)
                num = numHi;

        return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\dbutl.h ===
/***************************************************************************
 * dbutl.h -- Debugging utilities. 
 *
 *
 ***************************************************************************/

#if !defined(__DBUTL_H__)
#define __DBUTL_H__

// ********************************************************************
// Write a debug message to the debugger or a file
//
#define DM_ERROR          0x0001
#define DM_TRACE1         0x0002  // interface call tracing (except for messages)
#define DM_TRACE2         0x0004  // status type stuff.  These messages only
                                  // make sense with DM_TRACE1 enabled
#define DM_MESSAGE_TRACE1  0x0008  // message tracing
#define DM_MESSAGE_TRACE2 0x0010  // trace all messages (processed or not)
#define DM_NOW            0x0020  // Used for temp debugging during dev.
#define DM_NOEOL          0x1000 // don't follow the message with a \r\n

#ifdef _DEBUG
#include <assert.h>

#define DEBUGBREAK      DebugBreak()
#define DEBUGMSG(a)     DebugMessage a
#define DEBUGHRESULT(a) DebugHRESULT a
#define DEBUGREFIID(a)  DebugREFIID a

void DebugMessage(UINT mask, LPCTSTR pszMsg, ... );
void DebugHRESULT(int flags, HRESULT hResult);
void DebugREFIID(int flags, REFIID riid);

#define ASSERT(a)    assert((a))

#else
#define DEBUGBREAK
#define DEBUGMSG(a)
#define DEBUGHRESULT(a)
#define DEBUGREFIID(a)
#define ASSERT(a)
#endif


#endif // __DBUTL_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\dblnul.h ===
#ifndef _INC_DBLNUL_H
#define _INC_DBLNUL_H

#include <windows.h>
#include <strsafe.h>

#ifndef ASSERT
#   include <assert.h>
#   define ASSERT assert
#endif


#ifdef __cplusplus
//
//-----------------------------------------------------------------------------
// CDblNulTermListStrLib
//-----------------------------------------------------------------------------
//
// Type-specific string functions so the compiler can select the correct version
// to match the list type.
//
class CDblNulTermListStrLib
{
    public:
        static int StringLength(LPCSTR pszA)
            { return lstrlenA(pszA); }

        static int StringLength(LPCWSTR pszW)
            { return lstrlenW(pszW); }

        static HRESULT StringCopy(LPSTR pszDestA, size_t cchDestA, LPCSTR pszSrcA)
            { return StringCchCopyA(pszDestA, cchDestA, pszSrcA); }

        static HRESULT StringCopy(LPWSTR pszDestW, size_t cchDestW, LPCWSTR pszSrcW)
            { return StringCchCopyW(pszDestW, cchDestW, pszSrcW); }
};



//
//-----------------------------------------------------------------------------
// CDblNulTermListEnumImpl<T>
//-----------------------------------------------------------------------------
//
// For iterating over items in a double-nul terminated list of
// text strings.  An enumerator may be generated from an existing 
// dblnul list object or may be created for a raw double nul terminated string.
//
template <typename T>
class CDblNulTermListEnumImpl
{
    public:
        explicit CDblNulTermListEnumImpl(const T *pszList)
            : m_pszList(pszList),
              m_pszCurrent(pszList) { }

        ~CDblNulTermListEnumImpl(void) { }

        //
        // Retrieve address of next string in list.
        //
        HRESULT Next(const T **ppszItem);
        //
        // Reset enumerator to the start of the list.
        //
        void Reset(void)
            { m_pszCurrent = m_pszList; }

    private:
        const T *m_pszList;
        const T *m_pszCurrent;
};


// ----------------------------------------------------------------------------
// CEmptyList
// ----------------------------------------------------------------------------
//
// Provides type-sensitive empty dbl-nul-term lists.
// This is so that an empty dbl-nul-term list object will still provide a valid
// dbl-nul-term list if no items are added.
//
class CEmptyList
{
    public:
        CEmptyList(void)
            { 
                m_pszEmptyA = "\0";
                m_pszEmptyW = L"\0";
            }

        operator LPCSTR() const
            { return m_pszEmptyA; }

        operator LPCWSTR() const
            { return m_pszEmptyW; }

        bool operator == (LPCSTR pszA) const
            { return m_pszEmptyA == pszA; }

        bool operator == (LPCWSTR pszW) const
            { return m_pszEmptyW == pszW; }

        bool operator != (LPCSTR pszA) const
            { return !operator == (pszA); }

        bool operator != (LPCWSTR pszW) const
            { return !operator == (pszW); }

    private:
        LPCSTR  m_pszEmptyA;
        LPCWSTR m_pszEmptyW;
};



//
//-----------------------------------------------------------------------------
// CDblNulTermListImpl<T>
//-----------------------------------------------------------------------------
//
template <typename T>
class CDblNulTermListImpl
{
    public:
        explicit CDblNulTermListImpl(int cchGrowMin = MAX_PATH)
            : m_psz((T *) ((const T *)s_Empty)),
              m_cchAlloc(0),
              m_cchUsed(0),
              m_cElements(0),
              m_cchGrowMin(cchGrowMin) { }

        ~CDblNulTermListImpl(void)
            { if (s_Empty != m_psz) LocalFree(m_psz); }

        //
        // Add a string to the list.
        //
        HRESULT Add(const T *psz);
        //
        // Clear the list of all content.
        //
        void Clear(void);
        //
        // Return the count of strings in the list.
        //
        int Count(void) const
            { return m_cElements; }
        //
        // Return the number of bytes used by the list.
        // +1 for the list's terminating nul.
        //
        int SizeBytes(void) const
            { return (m_cchUsed + 1) * sizeof(T); }
        //
        // Retrieve the address of the start of the list buffer.
        // Use this and SizeBytes() to copy the list buffer.
        // 
        // CopyMemory(pbDest, (LPCTSTR)list, list.SizeBytes());
        //
        operator const T * () const
            { return m_psz; }
        //
        // Create an enumerator for enumerating strings in the list.
        //
        CDblNulTermListEnumImpl<T> CreateEnumerator(void) const
            { return CDblNulTermListEnumImpl<T>(m_psz); }

    private:
        T *       m_psz;        // The text buffer.
        int       m_cchAlloc;   // Total allocation in chars.
        int       m_cchUsed;    // Total used excluding FINAL nul term.
        int       m_cElements;  // Count of strings in list.
        const int m_cchGrowMin; // Minimum chars to grow each expansion.
        static CEmptyList s_Empty;

 
        HRESULT _Grow(int cchGrowMin);

        //
        // Prevent copy.
        //
        CDblNulTermListImpl(const CDblNulTermListImpl& rhs);
        CDblNulTermListImpl& operator = (const CDblNulTermListImpl& rhs);
};


//
// The list impl initially points to this so that an uninitialized
// list instance will simply provide an empty list.
//
template <typename T>
CEmptyList CDblNulTermListImpl<T>::s_Empty;


//
// Add a string to a dbl-nul-term list.
//
template <typename T>
HRESULT
CDblNulTermListImpl<T>::Add(
    const T *psz
    )
{
    HRESULT hr = E_FAIL;

    //
    // +2 for this string's nul and for list nul terminator.
    //
    const int cchString   = CDblNulTermListStrLib::StringLength(psz);
    const int cchRequired = cchString + 2;
    
    if ((m_cchAlloc - m_cchUsed) < cchRequired)
    {
        //
        // Grow by the amount required PLUS the "min growth" amount.
        // This way a client can choose between one of the two
        // following strategies:
        //
        //   1. low-waste/frequent allocation
        //   2. high-waste/infrequent allocation.
        //
        // The "waste" comes from the unused memory at the end
        // of the list after all strings have been added.
        //
        hr = _Grow(cchRequired + m_cchGrowMin);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    ASSERT(NULL != m_psz);
    CDblNulTermListStrLib::StringCopy(m_psz + m_cchUsed, m_cchAlloc - m_cchUsed, psz);
    m_cchUsed += cchString + 1;
    m_cElements++;
    return S_OK;
}


//
// Internal function used for allocating the list buffer as needed.
//
template <typename T>
HRESULT
CDblNulTermListImpl<T>::_Grow(int cchGrow)
{
    ASSERT(m_cchGrowMin > 0);

    HRESULT hr = E_OUTOFMEMORY;
    
    int cb = (m_cchAlloc + cchGrow) * sizeof(T);
    T *p = (T *)LocalAlloc(LPTR, cb);
    if (NULL != p)
    {
        if (s_Empty != m_psz)
        {
            CopyMemory(p, m_psz, m_cchUsed * sizeof(T));
            LocalFree(m_psz);
        }
        m_psz = p;
        m_cchAlloc += cchGrow;
        hr = S_OK;
    }
    return hr;
}


//
// Clears all items from the list.
//
template <typename T>
void 
CDblNulTermListImpl<T>::Clear(void)
{
    if (s_Empty != m_psz)
    {
        LocalFree(m_psz);
    }
    m_psz       = (T *) ((const T *)s_Empty);
    m_cchAlloc  = 0;
    m_cchUsed   = 0;
    m_cElements = 0;
}


//
// Retrieve the address of the next string in the enumeration.
// Returns S_FALSE if enumerator is exhausted.
//
template <typename T>
HRESULT
CDblNulTermListEnumImpl<T>::Next(
    const T **ppszItem
    )
{
    if (*m_pszCurrent)
    {
        *ppszItem = m_pszCurrent;
        m_pszCurrent += CDblNulTermListStrLib::StringLength(m_pszCurrent) + 1;
        return S_OK;
    }
    return S_FALSE;
}


//
// Create some types so clients don't need to deal with templates.
// Clients work with these types:
//
//      CDblNulTermList, CDblNulTermListA, CDblNulTermListW
//
//      CDblNulTermListEnum, CDblNulTermListEnumA, CDblNulTermListEnumW
//
//
typedef CDblNulTermListImpl<WCHAR> CDblNulTermListW;
typedef CDblNulTermListImpl<char> CDblNulTermListA;
typedef CDblNulTermListEnumImpl<WCHAR> CDblNulTermListEnumW;
typedef CDblNulTermListEnumImpl<char> CDblNulTermListEnumA;

#ifdef UNICODE
#   define CDblNulTermList CDblNulTermListW
#   define CDblNulTermListEnum CDblNulTermListEnumW
#else
#   define CDblNulTermList CDblNulTermListA
#   define CDblNulTermListEnum CDblNulTermListEnumA
#endif



#endif // __cplusplus


#ifdef __cplusplus
extern "C" {
#endif

//
// These types and functions support 'C' code or 'C++' code
// that prefers to work with handles rather than classes.
//

typedef void * HDBLNULTERMLISTW;
typedef void * HDBLNULTERMLISTENUMW;
typedef void * HDBLNULTERMLISTA;
typedef void * HDBLNULTERMLISTENUMA;

//
// Create a new dbl-nul-term list.
//
HRESULT DblNulTermListW_Create(int cchGrowMin, HDBLNULTERMLISTW *phList);
HRESULT DblNulTermListA_Create(int cchGrowMin, HDBLNULTERMLISTA *phList);
//
// Destroy a dbl-nul-term list.
//
void DblNulTermListW_Destroy(HDBLNULTERMLISTW hList);
void DblNulTermListA_Destroy(HDBLNULTERMLISTA hList);
//
// Add a string to a dbl-nul-term list.
//
HRESULT DblNulTermListW_Add(HDBLNULTERMLISTW hList, LPCWSTR pszW);
HRESULT DblNulTermListA_Add(HDBLNULTERMLISTA hList, LPCSTR pszA);
//
// Clear all entries in a dbl-nul-term list.
//
void DblNulTermListW_Clear(HDBLNULTERMLISTW hList);
void DblNulTermListA_Clear(HDBLNULTERMLISTA hList);
//
// Return count of entries in a dbl-nul-term list.
//
int DblNulTermListW_Count(HDBLNULTERMLISTW hList);
int DblNulTermListA_Count(HDBLNULTERMLISTA hList);
//
// Retrieve the address of the buffer in a dbl-nul-term list.
//
HRESULT DblNulTermListW_Buffer(HDBLNULTERMLISTW hList, LPCWSTR *ppszW);
HRESULT DblNulTermListA_Buffer(HDBLNULTERMLISTA hList, LPCSTR *ppszA);
//
// Create an enumerator for enumerating the strings in a dbl-nul-term list.
// Enumerator is created from an existing dbl-nul-term list object.
//
HRESULT DblNulTermListW_CreateEnum(HDBLNULTERMLISTA hList, HDBLNULTERMLISTENUMW *phEnum);
HRESULT DblNulTermListA_CreateEnum(HDBLNULTERMLISTW hList, HDBLNULTERMLISTENUMA *phEnum);
//
// Create an enumerator given the address of a raw double nul terminated string.
// The resulting enumerator can be used to enumerate the individual strings.
//
HRESULT DblNulTermListEnumW_Create(LPCWSTR pszW, HDBLNULTERMLISTENUMW *phEnum);
HRESULT DblNulTermListEnumA_Create(LPCSTR pszA, HDBLNULTERMLISTENUMA *phEnum);
//
// Destroy a dbl-nul-term list enumerator.
//
void DblNulTermListEnumW_Destroy(HDBLNULTERMLISTW hList);
void DblNulTermListEnumA_Destroy(HDBLNULTERMLISTA hList);
//
// Retrieve the address of the "next" string in a dbl-nul-term list enumerator.
// Returns S_FALSE when enumerator is exhausted.
//
HRESULT DblNulTermListEnumW_Next(HDBLNULTERMLISTW hList, LPCWSTR *ppszW);
HRESULT DblNulTermListEnumA_Next(HDBLNULTERMLISTA hList, LPCSTR *ppszA);


#ifdef UNICODE
#   define HDBLNULTERMLIST            HDBLNULTERMLISTW
#   define HDBLNULTERMLISTENUM        HDBLNULTERMLISTENUMW
#   define DblNulTermList_Create      DblNulTermListW_Create
#   define DblNulTermList_Destroy     DblNulTermListW_Destroy
#   define DblNulTermList_Add         DblNulTermListW_Add
#   define DblNulTermList_Clear       DblNulTermListW_Clear
#   define DblNulTermList_Count       DblNulTermListW_Count
#   define DblNulTermList_Buffer      DblNulTermListW_Buffer
#   define DblNulTermList_CreateEnum  DblNulTermListW_CreateEnum
#   define DblNulTermListEnum_Create  DblNulTermListEnumW_Create
#   define DblNulTermListEnum_Destroy DblNulTermListEnumW_Destroy
#   define DblNulTermListEnum_Next    DblNulTermListEnumW_Next
#else
#   define HDBLNULTERMLIST            HDBLNULTERMLISTA
#   define HDBLNULTERMLISTENUM        HDBLNULTERMLISTENUMA
#   define DblNulTermList_Create      DblNulTermListA_Create
#   define DblNulTermList_Destroy     DblNulTermListA_Destroy
#   define DblNulTermList_Add         DblNulTermListA_Add
#   define DblNulTermList_Clear       DblNulTermListA_Clear
#   define DblNulTermList_Count       DblNulTermListA_Count
#   define DblNulTermList_Buffer      DblNulTermListA_Buffer
#   define DblNulTermList_CreateEnum  DblNulTermListA_CreateEnum
#   define DblNulTermListEnum_Create  DblNulTermListEnumA_Create
#   define DblNulTermListEnum_Destroy DblNulTermListEnumA_Destroy
#   define DblNulTermListEnum_Next    DblNulTermListEnumA_Next
#endif


#ifdef __cplusplus
}  // extern "C"
#endif

#endif // INC_DBLNUL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\cpanel.h ===
#ifndef __PCONTROL_H__
#define __PCONTROL_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "fvscodes.h"    // FVS_xxxxxx (font validation status) codes & macros.
                         // \nt\private\windows\shell\control\t1instal\fvscodes.h

//
//  Global definitions
//
//
// Note for file macros below.
// The LZxxx functions are no longer used in the macro substitutions.
// The need to use LZxxx implementations is a function of the file type, not
// the target platform.  Wherever LZxxx functions are required, they
// are now used explicitely.
//

#define FOPEN( sz, lpsz, cch )   MyOpenFile( sz, lpsz, cch, OF_READ )
#define FREAD( fh, buf, len )    MyAnsiReadFile( fh, CP_ACP, buf, len )
#define FWRITE( fh, buf, len )   MyAnsiWriteFile( fh, CP_ACP, buf, len )
#define FREADBYTES(fh,buf,len)   MyByteReadFile( fh, buf, len )
#define FWRITEBYTES(fh,buf,len)  MyByteWriteFile( fh, buf, len )

#define FSEEK( fh, off, i )      MyFileSeek( fh, (DWORD) off, i )
#define FCLOSE( fh )             MyCloseFile( fh )
#define FCREATE( sz )            MyOpenFile( sz, NULL, 0, OF_READWRITE | OF_CREATE )

//
//  Global variables
//

extern  FullPathName_t e_szDirOfSrc;
extern  UINT s_wBrowseDoneMsg;


//
//  Flags for ReadLine
//

#define  RL_MORE_MEM       -1
#define  RL_SECTION_END    -2

#define  SEEK_BEG           0
#define  SEEK_CUR           1
#define  SEEK_END           2

#define  PRN               148
#define  MON_OF_YR         276
#define  MOUSE           MON_OF_YR+48
#define  INSTALL         MOUSE+16


//
//  Font file types used in Fonts applet - installation
//

#define NOT_TT_OR_T1        0       //  Neither TrueType or Type 1 font (FALSE)
#define TRUETYPE_FONT       1       //  This is a TrueType font (TRUE)
#define TYPE1_FONT          2       //  This is an Adobe Type1 font
#define TYPE1_FONT_NC       3       //  Type1 font that cannot be converted to TT
#define OPENTYPE_FONT       4       //  Font is OpenType.

//
//  Font file types used in Fonts applet - Main dlg "Installed Fonts" lbox
//

#define IF_OTHER            0       //  TrueType or Bitmap 1 font (FALSE)
#define IF_TYPE1            1       //  Adobe Type1 font
#define IF_TYPE1_TT         2       //  Matching TT font for Adobe Type1 font

#define T1_MAX_DATA     (2 * PATHMAX + 6)

//
//  Return codes from InstallT1Font routine
//

#define TYPE1_INSTALL_IDOK       IDOK        //  User pressed OK from MessageBox error
#define TYPE1_INSTALL_IDYES      IDYES       //  Same as IDOK
#define TYPE1_INSTALL_IDNO       IDNO        //  Font not installed - user pressed NO
#define TYPE1_INSTALL_IDCANCEL   IDCANCEL    //  Entire installation cancelled
#define TYPE1_INSTALL_PS_ONLY     10         //  Only the PS Font installed.
#define TYPE1_INSTALL_PS_AND_MTT  11         //  PostScript Font installed and matching
                                             //   TT font already installed.
#define TYPE1_INSTALL_TT_AND_PS   12         //  PS Font installed and converted to TT.
#define TYPE1_INSTALL_TT_ONLY     13         //  PS Font converted to TT only.
#define TYPE1_INSTALL_TT_AND_MPS  14         //  PS Font converted to TT and matching
                                             //   PS font already installed.
//
//  Global functions
//

//
//  append.cpp
//

BOOL FAR PASCAL fnAppendSplitFiles( LPTSTR FAR *, LPTSTR, int );

//
//  instfls.c
//

typedef int (FAR PASCAL *INSTALL_PROC)(HWND hDlg, WORD wMsg, int i,
             LPTSTR FAR *pszFiles, LPTSTR lpszDir );

#define IFF_CHECKINI  0x0001
#define IFF_SRCANDDST 0x0002

#define IF_ALREADY_INSTALLED    1
#define IF_ALREADY_RUNNING      2
#define IF_JUST_INSTALLED       3

PTSTR  FAR PASCAL CopyString( LPTSTR szStr );
PTSTR  FAR PASCAL MyLoadString( WORD wId );
LPTSTR FAR PASCAL CpyToChr( LPTSTR pDest, LPTSTR pSrc, TCHAR cChr, int iMax );

VOID FAR PASCAL GetDiskAndFile( LPTSTR pszInf,
                                short /* int */ FAR *nDsk,
                                LPTSTR pszDriver,
                                WORD wSize );

DWORD FAR PASCAL InstallFiles( HWND hwnd, LPTSTR FAR *pszFiles, int nCount,
                               INSTALL_PROC lpfnNewFile, WORD wFlags );

//
//  PFONT.CPP
//

class CFontManager;
extern BOOL FAR PASCAL bCPAddFonts( HWND ma );

#define CPDI_CANCEL  -1
#define CPDI_FAIL     0
#define CPDI_SUCCESS  1

extern int FAR PASCAL CPDropInstall( HWND hwndParent,
                                     LPTSTR szFile,
                                     size_t cchFile,
                                     DWORD  dwEffect,
                                     LPTSTR lpszDestName = NULL,
                                     int    iCount = 0 );

extern VOID FAR  PASCAL vCPDeleteFromSharedDir( LPTSTR pszFileOnly );
extern VOID FAR  PASCAL vCPFilesToDescs( );
extern BOOL NEAR PASCAL bUniqueOnSharedDir( LPTSTR lpszDst,  size_t cchDst, LPTSTR lpszSrc );
extern VOID NEAR PASCAL vHashToNulls( LPTSTR lpStr );
extern BOOL FAR  PASCAL bUniqueFilename (LPTSTR lpszDst, size_t cchDst, LPTSTR lpszSrc, LPTSTR lpszDir);

//
//  cpsetup.c
//

typedef WORD (*LPSETUPINFPROC)( LPTSTR, LPVOID );
extern DWORD ReadSetupInfSection( LPTSTR pszInfPath,
                                  LPTSTR pszSection,
                                  LPTSTR *ppszSectionItems );


extern WORD ReadSetupInfCB( LPTSTR pszInfPath,
                            LPTSTR pszSection,
                            LPSETUPINFPROC,
                            LPVOID pData);

extern int    FAR PASCAL ReadSetupInfIntoLBs( HWND hLBName,
                                              HWND hLBDBase,
                                              WORD wAddMsg,
                                              LPTSTR pszSection,
                                              WORD (FAR PASCAL *lpfnGetName)(LPTSTR, LPTSTR) );

//
//  PINSTALL.CPP
//

extern BOOL FAR PASCAL bCPInstallFile( HWND hwndParent,
                                       LPTSTR lpDir,
                                       LPTSTR lpFrom,
                                       LPTSTR lpTo );

//
//  PFILES.CPP
//

extern BOOL FAR PASCAL bCPValidFontFile( LPTSTR lpszFile,
                                         LPTSTR lpszDesc,
                                         size_t cchDesc,
                                         WORD FAR *lpwType = NULL,
                                         BOOL bFOTOK = FALSE,
                                         LPDWORD lpdwStatus = NULL);
//
//  PUTIL.CPP
//

extern BOOL FAR PASCAL bCPSetupFromSource( );
extern BOOL FAR PASCAL bCPIsHelp( WORD message );
extern BOOL FAR PASCAL bCPIsBrowseDone( WORD message );
extern RC   FAR PASCAL rcCPLoadFontList( );
extern VOID FAR PASCAL vCPHelp( HWND );
extern VOID FAR PASCAL vCPStripBlanks( LPTSTR lpszString, size_t cchString );
extern VOID FAR PASCAL vCPUpdateSourceDir( );
extern VOID FAR PASCAL vCPWinIniFontChange( );
extern VOID FAR PASCAL vCPPanelInit( );
extern LPTSTR FAR PASCAL lpCPBackSlashTerm( LPTSTR lpszPath, size_t cchPath );
extern BOOL bFileIsInFontsDirectory(LPCTSTR lpszPath);
extern int FAR PASCAL DoDialogBoxParam( int nDlg,
                                        HWND hParent,
                                        DLGPROC lpProc,
                                        DWORD dwHelpContext,
                                        LPARAM dwParam);

extern HANDLE PASCAL wCPOpenFileWithShare( LPTSTR, LPTSTR, size_t, WORD );

extern UINT MyAnsiReadFile( HANDLE  hFile,
                            UINT uCodePage,
                            LPVOID  lpUnicode,
                            DWORD  cchUnicode );

extern UINT MyAnsiWriteFile( HANDLE  hFile,
                             UINT uCodePage,
                             LPVOID lpUnicode,
                             DWORD cchUnicode );

extern UINT   MyByteReadFile( HANDLE  hFile, LPVOID lpBuffer, DWORD nBytes );
extern UINT   MyByteWriteFile( HANDLE hFile, LPVOID lpBuffer, DWORD nBytes );
extern BOOL   MyCloseFile( HANDLE  hFile );
extern LONG   MyFileSeek( HANDLE hFile, LONG lDistanceToMove, DWORD dwMoveMethod );
extern HANDLE MyOpenFile( LPTSTR lpszFile, TCHAR * lpszPath, size_t cchPath, DWORD fuMode );

VOID  CentreWindow( HWND hwnd );


LPVOID AllocMem( DWORD cb );
BOOL   FreeMem( LPVOID pMem, DWORD  cb );
LPTSTR AllocStr( LPTSTR lpStr );
BOOL   FreeStr( LPTSTR lpStr );
BOOL   ReallocStr( LPTSTR *plpStr, LPTSTR lpStr );


/* t1.cpp */

BOOL CheckT1Install( LPTSTR pszDesc, LPTSTR pszData, size_t cchData);
BOOL DeleteT1Install( HWND hwndParent, LPTSTR pszDesc, BOOL bDeleteFiles );
BOOL EnumType1Fonts( HWND hLBox );
BOOL GetT1Install( LPTSTR pszDesc, LPTSTR pszPfmFile, size_t cchPfmFile, LPTSTR pszPfbFile, size_t cchPfbFile );
int  InstallT1Font( HWND hwndParent, BOOL bCopyTTFile, BOOL bCopyType1Files,
                    BOOL bInSharedDir, LPTSTR szPfmName, size_t cchPfmName, LPTSTR szDesc, size_t cchDesc );

HWND InitProgress( HWND hwnd );
BOOL InstallCancelled(void);
void InitPSInstall( );
BOOL IsPSFont( LPTSTR lpszKey, LPTSTR lpszDesc, size_t cchDesc, LPTSTR lpszPfm, size_t cchPfm, LPTSTR lpszPfb, size_t cchPfb,
               BOOL *pbCreatedPFM, LPDWORD lpdwStatus = NULL );

BOOL OkToConvertType1ToTrueType(LPCTSTR pszFontDesc, LPCTSTR pszPFB, HWND hwndParent);

BOOL ExtractT1Files( LPTSTR pszMulti, LPTSTR pszPfmFile, size_t cchPfmFile, LPTSTR pszPfbFile, size_t cchPfbFile );
void Progress2( int PercentDone, LPTSTR szDesc );
void RemoveDecoration( LPTSTR pszDesc, BOOL bDeleteTrailingSpace );
void ResetProgress( );
void TermProgress( );
void TermPSInstall( );
void UpdateProgress( int iTotalCount, int iFontInstalling, int iProgress );

BOOL WriteType1RegistryEntry( HWND hwndParent, LPTSTR szDesc, LPTSTR szPfmName,
                              LPTSTR szPfbName, BOOL bInFontsDir );

BOOL BuildType1FontResourceName(LPCTSTR pszPfm, LPCTSTR pszPfb,
                                  LPTSTR pszDest, DWORD cchDest);

#define MAX_TYPE1_FONT_RESOURCE  (MAX_PATH * 2)  // 2 paths + separator.

#ifdef __cplusplus
}
#endif

#endif

/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * $lge$
 *
 ****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fdir.h ===
/***************************************************************************
 * fdir.h -- Interface for the class: CFontDir
 *
 *
 * Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
 ***************************************************************************/

#if !defined(__FDIR_H__)
#define __FDIR_H__

#include "vecttmpl.h"

class CFontDir {
public:
   CFontDir();
   virtual ~CFontDir();

   BOOL     bInit( LPCTSTR lpPath, int iLen);
   BOOL     bSameDir( LPTSTR lpStr, int iLen );
   BOOL     bOnSysDir() { return m_bSysDir; };
   VOID     vOnSysDir( BOOL b ) { m_bSysDir = b; };
   LPTSTR   lpString();

private: 
   int      m_iLen;
   BOOL     m_bSysDir;
   TCHAR    m_szPath[MAX_PATH];
};

//
// Class representing a dynamic array of CFontDir object ptrs.
// Implemented as a singleton object through the static member
// function GetSingleton.
//
// History:  
//     In the original font folder code (as written for Win95), 
//     this directory list was implemented as a simple derivation 
//     from CIVector<CFontDir> with a single instance allocated 
//     on the heap and attached to the static member variable 
//     CFontClass::s_poDirList.  There was no code to delete
//     this instance so we had a memory leak.  To fix this I've
//     replaced this instance with a true Singleton object.  
//     Class CFontDirList is that singleton.  Memory management 
//     is now correct.
//     [brianau - 2/27/01]
//
class CFontDirList
{
    public:
        ~CFontDirList(void);

        void Clear(void);
        BOOL Add(CFontDir *poDir);
        CFontDir *Find(LPTSTR pszPath, int iLen, BOOL bAdd = FALSE);
        BOOL IsEmpty(void) const;
        int Count(void) const;
        CFontDir *GetAt(int index) const;
        //
        // Singleton access function.
        //
        static BOOL GetSingleton(CFontDirList **ppDirList);

    private:
        //
        // Dynamic vector holding CFontDir ptrs.
        //
        CIVector<CFontDir> *m_pVector;
        //
        // Ctor is private to enforce singleton usage.
        //
        CFontDirList(void);
};        



#endif   // __FDIR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\extinit.h ===
/**********************************************************************
 * ExtInit.h - Definition for the CShellExtInit, our implementation for
 *             IShellExtInit.
 *
 **********************************************************************/

#if !defined(__EXTINIT_H__)
#define __EXTINIT_H__

class CShellExtInit : public IShellExtInit, public IContextMenu,
   public IShellPropSheetExt
{
public:
   CShellExtInit();
   ~CShellExtInit();
   BOOL bInit();

   // *** IUnknown methods ***

   STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   // *** IShellExtInit methods ***

   STDMETHODIMP Initialize( LPCITEMIDLIST pidlFolder,
                            LPDATAOBJECT lpdobj,
                            HKEY hkeyProgID);

   // ** IContextMenu methods ***

   STDMETHODIMP QueryContextMenu( HMENU hmenu,
                                  UINT indexMenu,
                                  UINT idCmdFirst,
                                  UINT idCmdLast,
                                  UINT uFlags);

   STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

   STDMETHODIMP GetCommandString( UINT_PTR idCmd,
                                  UINT   uFlags,
                                  UINT  *pwReserved,
                                  LPSTR  pszName,
                                  UINT   cchMax);

   // ***IShellPropSheet Ext ***
   //
   STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
   STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);


private:
   // Data for IUnknown
   //
   ULONG          m_cRef;

   // Data for IShellExtInit
   //
   LPDATAOBJECT   m_poData;
};


#endif // __EXTINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\extricon.h ===
#ifndef __EXTRICON_H__
#define __EXTRICON_H__
///////////////////////////////////////////////////////////////////////////////
/*  File: extricon.h

    Description: Contains implementation of IExtractIcon for the font folder.
        This code provides icon identification for both TrueType and OpenType
        font files.  The logic used is as follows:
        
            TrueType(1)  DSIG?   CFF?    Icon
            ------------ ------- ------- -----------
            yes          no      no      TT
            yes          no      yes     OTp
            yes          yes     no      OTt
            yes          yes     yes     OTp

        (1) Files must contain required TrueType tables to be considered
            a TrueType font file.

        This icon handler is used by both the shell and the font folder
        to display TrueType and OpenType font icons.  It is designed to be
        easily extensible if support for dynamic icon identification is
        required in other fonts.

        Classes (indentation denotes inheritance):

            CFontIconHandler
            IconHandler
                TrueTypeIconHandler
               

        NOTE:  The design is sort of in a state of limbo right now.  Originally
               the idea was to support two types of OpenType icons along with
               the conventional TrueType and raster font icons.  The OpenType
               icons were OTt and OTp with the 't' and 'p' meaning "TrueType"
               and "PostScript".  Later we decided to only show the icons as
               "OT" without the subscript 't' or 'p'.  The code still distinguishes
               the difference but we just use the same "OT" icon for both the
               OTt and OTp conditions.  Make sense?  Anyway, This OTt and OTp
               stuff may come back at a later date (GDI guys haven't decided)
               so I'm leaving that code in place. [brianau - 4/7/98]

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/13/97    Initial creation.                                    BrianAu
    04/08/98    Removed OpenTypeIconHandler and folded it into       BrianAu
                TrueTypeIconHandler.  There's no need for the 
                separation.  Also added detection of "required"
                TrueType tables.
*/
///////////////////////////////////////////////////////////////////////////////

//
// Pure virtual base class for all types of icon handlers.
//
class IconHandler
{
    public:
        //
        // Simple encapsulation of a mapped file for opening font files.
        //
        class MappedFile
        {
            public:
                MappedFile(VOID)
                    : m_hFile(INVALID_HANDLE_VALUE),
                      m_hFileMapping(INVALID_HANDLE_VALUE),
                      m_pbBase(NULL) { }

                ~MappedFile(VOID);
                HRESULT Open(LPCTSTR pszFile);
                VOID Close(VOID);

                LPBYTE Base(VOID)
                    { return m_pbBase; }

            private:
                HANDLE m_hFile;
                HANDLE m_hFileMapping;
                LPBYTE m_pbBase;

                //
                // Prevent copy.
                //
                MappedFile(const MappedFile& rhs);
                MappedFile& operator = (const MappedFile& rhs);
        };

        virtual ~IconHandler(VOID) { };
        //
        // Derived classes implement this to retrieve the index (ID) of the 
        // desired icon in fontext.dll.
        //
        virtual INT GetIconIndex(LPCTSTR pszFileName) = 0;
        //
        // Derived classes implement this to retrieve the large and small
        // icons corresponding to an index.  The index should be one returned
        // from GetIconIndex().
        //
        virtual HRESULT GetIcons(UINT iIconIndex, HICON *phiconLarge, HICON *phiconSmall) = 0;
        //
        // This static function creates an icon handler object of the proper
        // derived type for the font file extension specified in pszFileExt.
        //
        static HRESULT Create(LPCTSTR pszFile, IconHandler **ppHandler);
};

/*
//
// This is a template for creating a new type of icon handler for 
// other types of font files. 
//
// To create a new handler:
// 1. Create new handler class from template below.
// 2. Provide implementations for GetIconIndex and GetIcons.
// 3. Load icons in constructor.  See OpenTypeIconHandler as an example.
// 4. Modify IconHandler::Create() to instantiate the new handler type.
//
class XXXXIconHandler : public IconHandler
{
    public:
        XXXXIconHandler(VOID);
        virtual INT GetIconIndex(LPCTSTR pszFileName);
        virtual HRESULT GetIcons(UINT iIconIndex, HICON *phiconLarge, HICON *phiconSmall);

    private:
        static HICON m_hiconLarge;
        static HICON m_hiconSmall;
};
*/    


//
// Icon handler for TrueType font files.
//
class TrueTypeIconHandler : public IconHandler
{
    public:
        TrueTypeIconHandler(DWORD dwTables);
        ~TrueTypeIconHandler(void);

        virtual INT GetIconIndex(LPCTSTR pszFileName);
        virtual HRESULT GetIcons(UINT iIconIndex, HICON *phiconLarge, HICON *phiconSmall);
        //
        // Scans TTF or OTF file identifying tables.
        // Used by TrueTypeIconHandler and any subclasses.
        //
        static BOOL GetFileTables(LPCTSTR pszFile, LPDWORD pfTables);

        enum TABLES { 
                         //
                         // These are the only tables we're interested in.
                         //
                         TABLE_CFF  = 0x00000001,
                         TABLE_DSIG = 0x00000002,
                         TABLE_HEAD = 0x00000004,
                         TABLE_NAME = 0x00000008,
                         TABLE_CMAP = 0x00000010,
                         TABLE_HHEA = 0x00000020,
                         TABLE_HMTX = 0x00000040,
                         TABLE_OS2  = 0x00000080,
                         TABLE_POST = 0x00000100,
                         TABLE_GLYF = 0x00000200,
                         TABLE_MAXP = 0x00000400,
                         TABLE_LOCA = 0x00000800,
                         TABLE_TTCF = 0x00001000  // this is a pseudo table.
                    };

        static DWORD RequiredOpenTypeTables(void)
            { return (TABLE_CMAP |
                      TABLE_HEAD |
                      TABLE_HHEA |
                      TABLE_HMTX |
                      TABLE_MAXP |
                      TABLE_NAME |
                      TABLE_POST |
                      TABLE_OS2); }

        static DWORD RequiredTrueTypeTables(void)
            { return (RequiredOpenTypeTables() |
                      TABLE_GLYF |
                      TABLE_LOCA); }

    protected:
        enum eIcons {iICON_LARGE_TT,
                     iICON_SMALL_TT,
                     iICON_LARGE_OTt,
                     iICON_SMALL_OTt,
                     iICON_LARGE_OTp,
                     iICON_SMALL_OTp,
                     iICON_LARGE_TTC,
                     iICON_SMALL_TTC,
                     MAX_ICONS };

        DWORD m_dwTables;
        HICON m_rghIcons[MAX_ICONS]; // Array of icon handles.

    private:
        static BOOL ReadFileTables(IconHandler::MappedFile& file, LPDWORD pfTables);
        static INT FilterReadFileTablesException(INT nException);
        HICON GetIcon(int iIcon);
};


//
// Declaration for the DLL's icon handler.
// This is the object that is instantiated whenever a client asks CLSID_FontExt 
// for IID_IExtractIcon or IID_IPersistFile.
//
class CFontIconHandler : public IExtractIconW, 
                         public IExtractIconA, 
                         public IPersistFile
{
    public:
        CFontIconHandler(VOID);
        ~CFontIconHandler(VOID);

        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID riid,
            LPVOID *ppvOut);

        STDMETHODIMP_(ULONG)
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG)
        Release(
            VOID);

        //
        // IExtractIconW methods.
        //
        STDMETHODIMP Extract(
            LPCWSTR pszFileW,
            UINT nIconIndex,
            HICON *phiconLarge,
            HICON *phiconSmall,
            UINT nIconSize);

        STDMETHODIMP GetIconLocation(
            UINT uFlags,
            LPWSTR szIconFileW,
            UINT cchMax,
            int *piIndex,
            UINT *pwFlags);

        //
        // IExtractIconA methods.
        //
        STDMETHODIMP Extract(
            LPCSTR pszFileA,
            UINT nIconIndex,
            HICON *phiconLarge,
            HICON *phiconSmall,
            UINT nIconSize);

        STDMETHODIMP GetIconLocation(
            UINT uFlags,
            LPSTR szIconFileA,
            UINT cchMax,
            int *piIndex,
            UINT *pwFlags);

        //
        // IPersist methods.
        //
        STDMETHODIMP GetClassID(
            CLSID *pClassID);

        //
        // IPersistFile methods.
        //
        STDMETHODIMP IsDirty(
            VOID);

        STDMETHODIMP Load(
            LPCOLESTR pszFileName,
            DWORD dwMode);

        STDMETHODIMP Save(
            LPCOLESTR pszFileName,
            BOOL fRemember);

        STDMETHODIMP SaveCompleted(
            LPCOLESTR pszFileName);

        STDMETHODIMP GetCurFile(
            LPOLESTR *ppszFileName);

    private:
        LONG         m_cRef;
        TCHAR        m_szFileName[MAX_PATH];    // Name of icon file.
        IconHandler *m_pHandler;                // Ptr to type-specific handler.
        static TCHAR m_szFontExtDll[MAX_PATH];  // Path to FONTEXT.DLL

        INT GetIconIndex(VOID);
        HRESULT GetIcons(UINT iIconIndex, HICON *phiconLarge, HICON *phiconSmall);
};

#endif // __EXTRICON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fontext.h ===
//
// Class ID for the registry browser extension
// {BD84B380-8CA2-1069-AB1D-08000948F534}
//

DEFINE_GUID(CLSID_FontExt, 0xBD84B380L, 0x8CA2, 0x1069, 0xAB, 0x1D, 0x08,
        0x00, 0x09, 0x48, 0xF5, 0x34);

extern HINSTANCE g_hmodThisDll;   // Module handle for this dll
extern HANDLE    g_crefThisDll;   // Reference count for the dll


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fontfile.h ===
#ifndef _INC_FONTEXT_FONTFILE
#define _INC_FONTEXT_FONTFILE

class CFontFileIo;

//
// This class provides an abstraction that hides the differences required to read
// compressed and non-compressed font files.  The font folder was originally written
// to use the LZ APIs provided in LZ32.DLL for all reading of font files.  These
// APIs work with compressed and non-compressed files.  The problems is that the
// APIs are very old and are based on the OpenFile API and DOS file handles.  This
// means they're not UNICODE aware and have a maximum path length of 128 characters.
// So, even though compressed font files are rare today, all font files are 
// subject to these limitations in the font folder.  The LZ APIs are considered 
// legacy code and are not going to be being modified.  
//
// Since we can't modify the LZ APIs I decided to create this CFontFile class
// which defers the IO functionality to a properly-typed subclass.  Non-compressed
// files are handled with Win32 functions (i.e. CreateFile, ReadFile etc).  
// Compressed files are handled with LZ functions (i.e. LZOpenFile, LZRead etc).
// This means that the UNICODE and path length restrictions only affect compressed
// files and that non-compressed files (the vast majority today) are unaffected. 
//
// brianau [3/1/99]
//
class CFontFile
{
    public:
        CFontFile(void)
            : m_pImpl(NULL) { }

        ~CFontFile(void);

        DWORD Open(LPCTSTR pszPath, DWORD dwAccess, DWORD dwShareMode, bool bCreate = false);

        void Close(void);

        DWORD Read(LPVOID pbDest, DWORD cbDest, LPDWORD pcbRead = NULL);

        DWORD Seek(UINT uDistance, DWORD dwMethod);

        DWORD Reset(void)
            { return Seek(0, FILE_BEGIN); }

        DWORD GetExpandedName(LPCTSTR pszFile, LPTSTR pszDest, UINT cchDest);

        DWORD CopyTo(LPCTSTR pszTo);

    private:
        CFontFileIo *m_pImpl;  // Properly-typed implementation.

        bool IsCompressed(void);

        //
        // Prevent copy.
        //
        CFontFile(const CFontFile& rhs);
        CFontFile& operator = (const CFontFile& rhs);
};


#endif // _INC_FONTEXT_FONTFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fontcl.h ===
/***************************************************************************
 * fontcl.h - declarations for the font class and it related buddies:
 *
 *       PANOSEBytesClass  - The list of decoded PANOSE bytes
 *       PANOSENumClass    - The PANOSE number
 *       DirFilenameClass   - Directory slot and filename
 *       CFontClass         - Font class itself
 *
 * Copyright (C) 1992-93 ElseWare Corporation.   All rights reserved.
 ***************************************************************************/

#ifndef __FONTCL_H__
#define __FONTCL_H__

#include <stdio.h>
#include <string.h>

#if !defined(__FDIR_H__)
#include "fdir.h"
#endif


/*************************************************************************
 * PANOSE definitions.
 *************************************************************************/

#define NUM_PAN_DIGITS        10
#define PANOSE_LEN            10
#define PANOSE_ANY            0
#define PANOSE_NOFIT          1

#define FAMILY_LATTEXT        2

/***************************************************************************
 * LATIN TEXT PANOSE INDICES
 *
 * Indices into an array containing the standard 10-digit PANOSE number.
 ***************************************************************************/

#define PAN_IND_FAMILY         0
#define PAN_IND_SERIF          1
#define PAN_IND_WEIGHT         2
#define PAN_IND_PROPORTION     3
#define PAN_IND_CONTRAST       4
#define PAN_IND_STROKE         5
#define PAN_IND_ARMSTYLE       6
#define PAN_IND_LTRFORM        7
#define PAN_IND_MIDLINE        8
#define PAN_IND_XHEIGHT        9
#define PAN_IND__LAST          9

/***************************************************************************
 * PURPOSE:  Check a 10-digit PANOSE for validity.  We just look for any
 *           PANOSE_ANY's and disqualify it if we find one.  We probably should]
 *           also check for digits greater than DIGIT__LAST.
 ***************************************************************************/

class far PANOSEBytesClass {
public :
    PANOSEBytesClass ()        {   vClear (); };
    VOID  vClear  ()           { for( int i = 0; i < PANOSE_LEN; i++ )
                                     m_ajBytes[i] = PANOSE_NOFIT; };
    BOOL  bVerify ()           {  for( int i = 0; i < PANOSE_LEN; i++ )
                                    if( m_ajBytes[i] == PANOSE_ANY )
                                       return FALSE;
                                return TRUE; };
    BYTE  jFamily ()            { return jGet(PAN_IND_FAMILY); };
    BYTE  jGet( int i )         { return m_ajBytes[i]; };

public   : // fields

    BYTE   m_ajBytes[ PANOSE_LEN ];

};  // end PANOSEBytesClass

/* required wrapper */

class far PANOSENumClass {
public :   
   BYTE    m_ajNumMem[ NUM_PAN_DIGITS ];    // m_xNumMem. Old extended pan.
};


/*
 * Path and filename
 */

class far DirFilenameClass
{
public :
    void  vGetFullName( LPTSTR pszPath, size_t cchPath );

    void  vGetFileName( LPTSTR pszName, size_t cchName )      
        { StringCchCopy( pszName, cchName, m_szFOnly ); };

    BOOL  bSameFileName( LPTSTR pszName )
        {  return( lstrcmpi( pszName, m_szFOnly ) == 0 ); } ;

    void  vSet (CFontDir * poDir, LPTSTR pszPath) 
        {  
           m_poDir = poDir;
           StringCchCopy( m_szFOnly, ARRAYSIZE(m_szFOnly), pszPath ); 
        };

    BOOL  bSameName( LPTSTR pszName )
        { return lstrcmpi( pszName, m_szFOnly ) == 0; };
        
    BOOL  bOnSysDir(void)
        { return m_poDir->bOnSysDir(); };

private:
    CFontDir *  m_poDir;
    FILENAME    m_szFOnly;      // File name portion only
};

/************************************************************************* 
 * Font record
 */
class far CFontClass {
public   :
         CFontClass   ()
            : m_cRef(0),
              m_bAttributesValid(FALSE) { m_eFileKind = eFKNone; vClear( ); };
         ~CFontClass  () { vFreeFOT( ); }

    ULONG AddRef(void);
    ULONG Release(void);

    static int s_cFonts;
    //
    // WARNING:  This function zeros out the ENTIRE object using memset.
    //          This is so bogus I can't believe the original author did it.
    //          I'm not changing it because I don't want to break anything but
    //          be aware that it's here.  If you introduce a virtual function,
    //          into this class, this call will overwrite your vtable ptr 
    //          with NULL (ugh!).  If you add a non-trivial class as a member,
    //          this function will wipe out any initialization and any vtable
    //          ptr it might contain (double ugh!).  [brianau - 3/24/98]
    //
    void  vClear      ()         { memset( this, 0, sizeof( *this ) );
                                   m_lpszFamName = m_szFamName;
                                   m_cchFamNameMax = ARRAYSIZE(m_szFamName); };

   /* PANOSE stuff */

    BYTE *lpBasePANOSE( )     { bFillIn(); return (BYTE *)&m_xPANOSE.m_ajBytes;};

    BOOL  bLTDFamily( )       { bFillIn(); return m_jFamily == FAMILY_LATTEXT; };
    BOOL  bLTDAndPANOSE( )    { bFillIn(); return /* m_fHavePANOSE && */
                                         bLTDFamily();};

    /**********************************************************************    
     * Name (also Family and filename) stuff 
     */
    BOOL  bSameFileName( PTSTR pStr )  { return m_dirfn.bSameFileName(pStr); };

    BOOL  bGetFQName( LPTSTR lpszName, size_t cchName );

    BOOL  GetFileTime( FILETIME* pft );

    void  GetFileInfo( );

    void  vGetFileName( PTSTR pStr, size_t cchStr )   { m_dirfn.vGetFileName( pStr, cchStr );     };

    DWORD dwGetFileAttributes(void);
        
    void InvalidateFileAttributes(void) { m_bAttributesValid = FALSE; }

    void  vGetDirFN( PTSTR pStr, size_t cchStr )      { m_dirfn.vGetFullName( pStr, cchStr );     };

    BOOL  bSameDirName( PTSTR pStr )   { return m_dirfn.bSameName( pStr ); };

    RC    rcStoreDirFN ( LPTSTR pStr ) { return rcStoreDirFN (pStr, m_dirfn); };
    
    void  vGetDesc( PTSTR pstr, size_t cchDesc )  { StringCchCopy( pstr, cchDesc, m_szFontLHS );   };

    const LPTSTR szGetDesc( )          { return m_szFontLHS; }

    void  vGetName( PTSTR pstr, size_t cchName )    { StringCchCopy( pstr, cchName, m_szFontLHS ); }
                      
    BOOL  bNameOverlap( PTSTR pstr )
                   {  int iLen = lstrlen( pstr );
                      if( iLen > m_wNameLen ) iLen = m_wNameLen;
                      int iCmp = _tcsnicmp( m_szFontLHS, pstr, iLen );
                      return( iCmp == 0 ); } ;
    
    BOOL  bSameName( PTSTR pstr )
                   {  int iCmp = ( lstrlen( pstr ) - m_wNameLen ); 
                      if( iCmp == 0 )
                         iCmp = _tcsnicmp( m_szFontLHS, pstr, m_wNameLen );
                      return iCmp == 0; };
    
    BOOL  bSameDesc( PTSTR pstr ) { return( lstrcmpi( pstr, m_szFontLHS ) == 0 ); };
    
    int   iCompareName( CFontClass* pComp )
             { return _tcsnccmp( m_szFontLHS, pComp->m_szFontLHS, m_wNameLen ); };
    
    void  vGetFamName( PTSTR pstr, size_t cchName )  { bFillIn(); StringCchCopy (pstr, cchName, m_lpszFamName); };

    void  vSetFamName( PTSTR pstr )  { StringCchCopy (m_lpszFamName, m_cchFamNameMax, pstr); };
    
    BOOL  bSameFamily( CFontClass* pComp )
                {  if( pComp == NULL ) return FALSE;
                   bFillIn();
                   pComp->bFillIn();
                   return lstrcmp( m_lpszFamName, pComp->m_lpszFamName ) == 0;};
    
    /**********************************************************************    
     * font data stuff 
     */
    
    int   iFontType( )      { return m_eFileKind; }
    BOOL  bDeviceType( )    { return m_eFileKind == eFKDevice;    }
    BOOL  bTrueType( )      { return ((m_eFileKind == eFKTrueType) || 
                                   (m_eFileKind == eFKTTC)); }
    BOOL  bOpenType( )      { return m_eFileKind == eFKOpenType; }
    BOOL  bTTC( )           { return m_eFileKind == eFKTTC; }
    BOOL  bType1( )         { return m_eFileKind == eFKType1; }
    
    /**********************************************************************    
     * AddFontResource and RemoveFontResource
     */
    BOOL  bAFR();
    BOOL  bRFR();
    
    /********************************************************************** 
     * For dealing with the font family list 
     */
    VOID  vSetFamilyFont( )          {  m_bFamily = TRUE;    };

    VOID  vSetNoFamilyFont( )        {  m_bFamily = FALSE;
                                        /* m_wFamIdx = IDX_NULL; */ };

    VOID  vSetFamIndex( WORD wVal )  {  m_wFamIdx = wVal; };

    WORD  wGetFamIndex( )            {  return m_wFamIdx; };

    BOOL  bSameFamIndex( CFontClass* pComp )
                               { return pComp->m_wFamIdx == m_wFamIdx; };
    
    /**********************************************************************
     * For dealing with the flags 
     */
    DWORD dwStyle( )        { return m_dwStyle; }

    BOOL  bHavePANOSE( )    { bFillIn(); return (m_jFamily != PANOSE_ANY); }

    BOOL  bFamilyFont( )    { return m_bFamily;         };
    
    BOOL  bOnSysDir( )      { return m_dirfn.bOnSysDir(); };

    WORD  wFontSize( )      { return m_wFileK;    };
    
    BOOL  bFilledIn( )      { return m_bFilledIn; };
    
    
    DWORD dCalcFileSize( );

    RC    rcStoreDirFN( LPTSTR pStr, DirFilenameClass& dirfn );
    
    BOOL  bInit( LPTSTR lpszDesc, LPTSTR lpPath, LPTSTR lpAltPath = NULL );

    BOOL  bFillIn( );
    
    BOOL  bFOT()        { return( m_lpszFOT != NULL ); };

    BOOL  bGetFOT( LPTSTR pszFOT, size_t cchFOT )
    {
        if( !bFOT( ) )
            return( FALSE );

        if (FAILED(StringCchCopy( pszFOT, cchFOT, m_lpszFOT )))
            return( FALSE );

        return( TRUE );
    }
    
    BOOL  bPFB()        { return( m_lpszPFB != NULL ); };

    BOOL  bGetPFB( LPTSTR pszPFB, size_t cchPFB )
    {
        if( !bType1( ) )
            return( FALSE );

        if (FAILED(StringCchCopy( pszPFB, cchPFB, m_lpszPFB )))
            return( FALSE );

        return( TRUE );
    }
    
    BOOL  bGetFileToDel( LPTSTR pszFileName, size_t cchFileName );
    
private :
    CFontDir * poAddDir( LPTSTR lpPath, LPTSTR * lpName );
    BOOL bAddDirToDirList(CFontDirList *pDirList, LPCTSTR pszDir, BOOL bSystemDir);
    VOID  vSetDeviceType( )        { m_eFileKind = eFKDevice;   };
    VOID  vSetTrueType( BOOL bFOT) { m_eFileKind = eFKTrueType; }
    VOID  vSetOpenType( )          { m_eFileKind = eFKOpenType; }
    VOID  vSetTTCType( )           { m_eFileKind = eFKTTC; }
    VOID  vSetType1( )             { m_eFileKind = eFKType1; }
    
    BOOL  bSetFOT( LPCTSTR pszFOT )
    {
        m_lpszFOT = StrDup(pszFOT);
        return NULL != m_lpszFOT;
    }

    void  vFreeFOT() { if( bFOT( ) ) LocalFree( m_lpszFOT ); m_lpszFOT = NULL; }

    BOOL  bSetPFB( LPCTSTR pszPFB )
    {
        m_lpszPFB = StrDup(pszPFB);
        return NULL != m_lpszPFB;
    }

    void  vFreePFB() { if( bType1( ) ) LocalFree( m_lpszPFB ); m_lpszPFB = NULL; }

    //
    // Functions for getting information from Type1 fonts and 
    // 32-bit font resources.
    //
    DWORD GetType1Info(LPCTSTR pszPath, 
                       LPTSTR pszFamilyBuf, 
                       UINT nBufChars, 
                       LPDWORD pdwStyle, 
                       LPWORD pwWeight);

    DWORD GetLogFontInfo(LPTSTR pszPath, LOGFONT **ppLogFontInfo);
    
private :
    LONG              m_cRef;        // Reference count.

    // Some things are filled in on the first pass, others are
    // filled in on the second pass during background processing,
    // idle time, or on demand.
    //
    BOOL              m_bAFR;        // True if the font is in GDI
    FontDesc_t        m_szFontLHS;   // 1
    FAMNAME           m_szFamName;   // 2
    LPTSTR            m_lpszFamName; // 2
    size_t            m_cchFamNameMax;
    
    BOOL              m_bFilledIn;   // True after 2nd pass
    BYTE              m_wNameLen;    // 1
    BYTE              m_jFamily;     // 2
    PANOSEBytesClass  m_xPANOSE;     // 2
    
    DirFilenameClass  m_dirfn;       // 1. Path in WIN.INI, not real TTF path
    WORD              m_wFileK;      // 2.
    WORD              m_wFamIdx;     // Set externally.
    eFileKind         m_eFileKind;   // Always an int
    
    BOOL              m_bFileInfoFetched;
    FILETIME          m_ft;
    
    LPTSTR            m_lpszFOT;
    LPTSTR            m_lpszPFB;
    DWORD             m_dwFileAttributes; // Cached file attributes.
    BOOL              m_bAttributesValid; 

public:   // TODO: Add access functions for this.
    WORD              m_wWeight;      // 2. From OS/2 table
    BOOL              m_bFamily;      // 2. Set if main family font
    DWORD             m_dwStyle;      // 2. Same values as 
};


BOOL PASCAL bMakeFQName( LPTSTR, LPTSTR, size_t, BOOL bSearchPath=FALSE );

BOOL bTTFFromFOT( LPTSTR pszFOTPath, LPTSTR pszTTF, size_t cchTTF );

BOOL FFGetFileResource( LPCTSTR szFile, LPCTSTR szType, LPCTSTR szRes,
                        DWORD dwReserved, DWORD *pdwLen, LPVOID lpvData );


#endif   // __FONTCL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fontdir.h ===
#ifndef __FONTDIR_H__
#define __FONTDIR_H__

/* font file header (Adaptation Guide section 6.4) */

typedef struct {
    WORD     dfVersion;         /* not in FONTINFO */
    DWORD    dfSize;            /* not in FONTINFO */
    BYTE     dfCopyright[60];   /* not in FONTINFO */
    WORD     dfType;
    WORD     dfPoints;
    WORD     dfVertRes;
    WORD     dfHorizRes;
    WORD     dfAscent;
    WORD     dfInternalLeading;
    WORD     dfExternalLeading;
    BYTE     dfItalic;
    BYTE     dfUnderline;
    BYTE     dfStrikeOut;
    WORD     dfWeight;
    BYTE     dfnCharSet;
    WORD     dfPixWidth;
    WORD     dfPixHeight;
    BYTE     dfPitchAndFamily;
    WORD     dfAvgWidth;
    WORD     dfMaxWidth;
    BYTE     dfFirstChar;
    BYTE     dfLastChar;
    BYTE     dfDefaultCHar;
    BYTE     dfBreakChar;
    WORD     dfWidthBytes;
    DWORD    dfDevice;          /* See Adaptation Guide 6.3.10 and 6.4 */
    DWORD    dfFace;            /* See Adaptation Guide 6.3.10 and 6.4 */
    DWORD    dfBitsPointer;     /* See Adaptation Guide 6.3.10 and 6.4 */
} FFH;

/*
    The lpFDirEntry is a string corresponding to the resource
    index (two bytes) prepended to an Fontdefs.h FFH structure, with device
    and face name strings appended
    First word is number of fonts, skip to first font resource name
*/

typedef struct {
    WORD    dfFontCount;        /* Overall info */
    WORD    dfSkipper;          /* ?? */
    FFH     xFFH;
    char    cfFace;
} FFHWRAP, FAR* LPFHHWRAP;

#endif



/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * $lge$
 *
 ****************************************************************************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fonthelp.h ===
//------------------------------------------------------------------------
// FONTHELP.H
//
// ID's for help topics. The Fonts Folder has the range from 8100-8199
// for help topics.
//------------------------------------------------------------------------

#ifndef __FONTHELP_H__
#define __FONTHELP_H__

// This needs to be defined by the Documentation folks.
//
#define IDH_WINDOWS_FONTS_ADDNEW_31HELP   8100
#define IDH_FONTS_ADD_SELECTALL           8101
#define IDH_FONTS_TRUETYPE_ON_COMPUTER    8105
#define IDH_FONTS_ADD_COPY_TO_FONT_DIR    8106
#define IDH_FONTS_ADD_FONTLIST            8107


#endif   // __FONTHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fontlist.h ===
/**********************************************************************
 * FontList.h  -- Manages a list of FontID objects via an array of
 *             FontVector objects.
 *
 **********************************************************************/

#if !defined(__FONTLIST_H__)
#define __FONTLIST_H__


#include "fontvect.h"

class CFontClass;

const int kDefaultVectSize = 50;   // Number of fonts in each CFontArray

class CFontList {
public:
    CFontList( int iSize, int iVectorSize = kDefaultVectSize );
    ~CFontList();
    
    int bInit();
    CFontList *Clone(void);
        
    //
    //  The real array functions.
    //

    int   iCount( void );
    int   bAdd( CFontClass * t );
    CFontClass *  poObjectAt( int idx );
    CFontClass *  poDetach( int idx );
    CFontClass *  poDetach( CFontClass * t );
    void  vDetachAll( );
    int   bDelete( int idx );
    int   bDelete( CFontClass * t );
    void  vDeleteAll( );
    int   iFind( CFontClass * t );
    void  ReleaseAll(void);
    void  AddRefAll(void);
    
private:
    CFontVector **  m_pData;
    int   m_iCount;         // Number of Fonts
    int   m_iVectorCount;   // Number of vectors allocated
    int   m_iVectorBounds;  // Total number of vector points
    int   m_iVectorSize;    // Number of fonts in each vector
};



/**********************************************************************
 * Some things you can do with a font list.
 */
HDROP hDropFromList( CFontList * poList );

#endif   // __FONTLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fontman.h ===
/***************************************************************************
 * FontMan.h   -- Definintion for the class: CFontManager
 *
 *
 * Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
 ***************************************************************************/

#if !defined(__FONTMAN_H__)
#define __FONTMAN_H__

#if !defined(__FSNOTIFY_H__)
#include "fsnotify.h"
#endif

#include "strtab.h"

// The database search capabilities have been extended.
enum {
    kSearchAny = 1,
    kSearchTT,
    kSearchNotTT
};


//*********************************************************************
// Forward declarations
//
class CFontClass;
class CFontList;
class CFontManager;
struct IPANOSEMapper;

DWORD dwResetFamilyFlags(void);

//*********************************************************************
// Class CFontManager
//
class CFontManager
{
public:
    virtual ~CFontManager( );
    
    BOOL  bInit( );          // Any initialization
    BOOL  bLoadFontList( );  // Build the font list
    
    VOID  vReconcileFolder( int iPriority );
    VOID  vDoReconcileFolder();

    CFontClass *   poAddToList( LPTSTR lpName, LPTSTR lpPath, LPTSTR lpCompFile = NULL );
    CFontList  *   poLockFontList( );
    void           vReleaseFontList( );
    
    void           vGetFamily( CFontClass * poFont, CFontList * poList );
    
    int            iSearchFontList( PTSTR pszTarget, BOOL bExact = TRUE, int iType = kSearchAny );
    int            iSearchFontListLHS( PTSTR pszLHS );
    int            iSearchFontListFile( PTSTR pszFile );
    CFontClass *   poSearchFontList( PTSTR pszTarget, BOOL bExact = TRUE, int iType = kSearchAny );
    CFontClass *   poSearchFontListLHS( PTSTR pszLHS );
    CFontClass *   poSearchFontListFile( PTSTR pszFile );
    
    VOID           vResetFamilyFlags( );
    VOID           vDoResetFamilyFlags( );
    BOOL           bWaitOnFamilyReset( );
    BOOL           bLoadFamList( );
    BOOL           bRefresh( BOOL bCheckDup = TRUE );
    
    void           vToBeRemoved( CFontList * poList );
    BOOL           bCheckTBR( );
    void           vUndoTBR( );
 
    void           vVerifyList( );
    
    void           vDeleteFontList( CFontList * poList, BOOL bDelete = TRUE );
    void           vDeleteFont( CFontClass * pFont,  BOOL bRemoveFile );
    void           vDeleteFontFamily( CFontClass * pFont,  BOOL bRemoveFile );
    
    int            iCompare( CFontClass * pFont1, CFontClass * pFont2, CFontClass * pOrigin );
    USHORT         nDiff( CFontClass * pFont1, CFontClass * pFont2 );
    
    int            GetFontsDirectory( LPTSTR lpDir, int iLen );
    BOOL           ShouldAutoInstallFile( PTSTR pstr, DWORD dwAttrib );
    BOOL           bFamiliesNeverReset(void) { return m_bFamiliesNeverReset; }
    
    //
    // Enumerated return values for dwWaitForInstallationMutex().
    //
    enum           { MUTEXWAIT_SUCCESS,  // Got the mutex.
                     MUTEXWAIT_TIMEOUT,  // Wait timed out.
                     MUTEXWAIT_FAILED,   // Wait failed.
                     MUTEXWAIT_WMQUIT    // Rcvd WM_QUIT while waiting.
                   };

    DWORD          dwWaitForInstallationMutex(DWORD dwTimeout = 2000);
    BOOL           bReleaseInstallationMutex(void);

    BOOL           CheckForType1FontDriver(void);
    BOOL           Type1FontDriverInstalled(void)
                        { return m_bType1FontDriverInstalled; }

private: // Methods
    CFontManager();
    VOID           ProcessRegKey( HKEY hk, BOOL bCheckDup );
    VOID           ProcessT1RegKey( HKEY hk, BOOL bCheckDup );
    int            GetSection( LPTSTR lpFile,
                               LPTSTR lpSection,
                               LPHANDLE hSection);
    
    HRESULT        GetPanMapper( IPANOSEMapper ** ppMapper );

    CFontList     *  m_poFontList;
    CFontList     *  m_poTempList;
    IPANOSEMapper *  m_poPanMap;
    BOOL             m_bTriedOnce;   // Set to true if an attempt has been made
                                     // to get at the pan mapper.
    
    BOOL             m_bFamiliesNeverReset; // T = family reset never done yet.
    BOOL             m_bType1FontDriverInstalled;
    CFontList     *  m_poRemoveList; // List of fonts being dragged out.
    
    NOTIFYWATCH m_Notify;
    HANDLE      m_hNotifyThread;
    HANDLE      m_hReconcileThread;
    HANDLE      m_hResetFamThread;
    
    HANDLE      m_hEventTerminateThreads;
    HANDLE      m_hEventResetFamily;
    HANDLE      m_hMutexResetFamily;
    HANDLE      m_hMutexInstallation;  // Prevent concurrent installation
                                       // by reconciliation and main threads.
    CRITICAL_SECTION  m_cs;
   
    class HiddenFilesList : public StringTable
    {
        public:
            HiddenFilesList(void) { }
            ~HiddenFilesList(void) { }

            DWORD Initialize(void);

    } m_HiddenFontFilesList;


friend DWORD dwResetFamilyFlags(LPVOID);
friend DWORD dwNotifyWatchProc(LPVOID);
friend DWORD dwReconcileThread(LPVOID);
friend HRESULT GetOrReleaseFontManager(CFontManager **ppoFontManager, bool bGet);

};

//
// Singleton instance management.
//
HRESULT GetFontManager(CFontManager **ppoFontManager);
void ReleaseFontManager(CFontManager **poFontManager);


#endif // __FONTMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fontvect.h ===
/**********************************************************************
 * FontVect.h  -- Font vector. An indirect array of FontID objects.
 *
 **********************************************************************/

#if !defined(__FONTVECT_H__)
#define __FONTVECT_H__

#include "vecttmpl.h"


// ********************************************************************
// Forward Declarations
//
class CFontClass;

typedef CIVector<CFontClass> CFontVector;



#endif   // __FONTVECT_H__ 

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\oeminf.h ===
/*
** oeminf.h - Public interface for oeminf.c.
*/

// Constants
/////////////

#define MAX_INF_COMP_LEN      0xffff   // Must not overrun a segment.
#define MAX_INF_READ_SIZE     0xffff   // INT_MAX  // Must not overrun an int.

#define INF_PREFIX            TEXT( "oem" )
#define INF_EXTENSION         TEXT( "inf" )

#define MAX_5_DEC_DIGITS      99999

// Buffer size for Get...Directory() calls.
#define MAX_NET_PATH          MAX_PATH

// .inf file specification and length.
#define OEM_STAR_DOT_INF      TEXT( "\\oem*.inf" )
#define OEM_STAR_DOT_INF_LEN  9


// Macros
//////////

#define IS_PATH_SEPARATOR(c)  ((c) == TEXT( '\\' ) || (c) == TEXT( '/' ) || (c) == TEXT( ':' ))
#define IS_SLASH(c)           ((c) == TEXT( '\\' ) || (c) == TEXT( '/' ))

BOOL   FAR PASCAL RunningFromNet( void );
HANDLE FAR PASCAL ReadFileIntoBuffer( int doshSource );
int    FAR PASCAL FilesMatch( HANDLE h1, HANDLE h2, unsigned uLength );
int    FAR PASCAL OpenFileAndGetLength( LPTSTR pszSourceFile, LPLONG plFileLength );
int    FAR PASCAL IsNewFile( LPTSTR lpszSourceFile, LPTSTR lpszSearchSpec );
LPTSTR FAR PASCAL MakeUniqueFilename( LPTSTR pszDirName, LPTSTR pszPrefix, LPTSTR pszExtension );
BOOL   FAR PASCAL CopyNewOEMInfFile( LPTSTR pszOEMInfPath, size_t cchOEMInfPath );

// Macros
//////////

#define FILEMAX            14          // 8.3 + null terminator

// #define FOPEN(sz)          _lopen(sz, OF_READ)
// #define FCLOSE(fh)         _lclose(fh)
// #define FCREATE(sz)        _lcreat(sz, 0)



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fontview.h ===
/**********************************************************************
 * FontView.h - Definition for the CFontView, our implementation for
 *       the IShellView in our browser.
 *
 **********************************************************************/

#if !defined(__FONTVIEW_H__)
#define __FONTVIEW_H__

#ifndef __EXTRICON_H__
#include "extricon.h"
#endif


// Forward declarations.
class CFontClass;
class CFontList;
class CFontView;
class CFontManager;

VOID InstallDataObject( LPDATAOBJECT pdobj, DWORD dwEffect, HWND hWnd, CFontView * poView = NULL);

// ********************************************************************


class CFontData : public IDataObject
{
public:
    // ctor, dtor, and init.
    //
    CFontData();
    ~CFontData();
    BOOL bInit( CFontList * poList );
    CFontList *poDetachList(void);
    CFontList *poCloneList(void);

    // *** IUnknown methods ***

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj );
    STDMETHODIMP_(ULONG) AddRef( void );
    STDMETHODIMP_(ULONG) Release( void );

    // **** IDataObject ****
    //
    STDMETHODIMP GetData( FORMATETC *pformatetcIn, STGMEDIUM *pmedium );
    STDMETHODIMP GetDataHere( FORMATETC *pformatetc, STGMEDIUM *pmedium );
    STDMETHODIMP QueryGetData( FORMATETC *pformatetc );

    STDMETHODIMP GetCanonicalFormatEtc( FORMATETC *pformatectIn,
                                        FORMATETC *pformatetcOut );

    STDMETHODIMP SetData( FORMATETC *pformatetc,
                          STGMEDIUM *pmedium,
                          BOOL fRelease );

    STDMETHODIMP EnumFormatEtc( DWORD dwDirection,
                                IEnumFORMATETC **ppenumFormatEtc );

    STDMETHODIMP DAdvise( FORMATETC  *pformatetc,
                          DWORD advf,
                          IAdviseSink *pAdvSink,
                          DWORD *pdwConnection);

    STDMETHODIMP DUnadvise( DWORD dwConnection);

    STDMETHODIMP EnumDAdvise( IEnumSTATDATA **ppenumAdvise );

    // Additional public interfaces.
    //
    BOOL bAFR();      // AddFontResource() for each of these
    BOOL bRFR();      // RemoveFontResource for each object.

    static CLIPFORMAT s_CFPerformedDropEffect; // Performed Drop Effect CF atom.
    static CLIPFORMAT s_CFPreferredDropEffect;
    static CLIPFORMAT s_CFLogicalPerformedDropEffect;

    //
    // Get the performed data transfer effect from the Data Object.
    //
    DWORD GetPerformedDropEffect(void)
        { return m_dwPerformedDropEffect; }
    void SetPerformedDropEffect(DWORD dwEffect)
        { m_dwPerformedDropEffect = dwEffect; }
        
    DWORD GetLogicalPerformedDropEffect(void)
        { return m_dwLogicalPerformedDropEffect; }
    void SetLogicalPerformedDropEffect(DWORD dwEffect)
        { m_dwLogicalPerformedDropEffect = dwEffect; }
        
    DWORD GetPreferredDropEffect(void)
        { return m_dwPreferredDropEffect; }
    void SetPreferredDropEffect(DWORD dwEffect)
        { m_dwPreferredDropEffect = dwEffect; }

private:
    int   m_cRef;
    CFontList * m_poList;

    DWORD m_dwPerformedDropEffect;        // DROPEFFECT_XXXX.
    DWORD m_dwPreferredDropEffect;        // DROPEFFECT_XXXX.
    DWORD m_dwLogicalPerformedDropEffect;

    HRESULT ReleaseStgMedium(LPSTGMEDIUM pmedium);
};


// ********************************************************************
class CFontView : public IShellView, public IDropTarget, public IPersistFolder
{
public:
    CFontView(void);
    ~CFontView( );

    int Compare( CFontClass * pFont1, CFontClass * pFont2 );
    void vShapeView( );

    // *** IUnknown methods ***

    STDMETHODIMP QueryInterface( REFIID riid, void **ppv );
    STDMETHODIMP_(ULONG) AddRef( void );
    STDMETHODIMP_(ULONG) Release( void );

    // *** IOleWindow methods ***

    STDMETHODIMP GetWindow( HWND * lphwnd );
    STDMETHODIMP ContextSensitiveHelp( BOOL fEnterMode );

    // *** IShellView methods ***

    STDMETHODIMP TranslateAccelerator( LPMSG msg );
    STDMETHODIMP EnableModeless( BOOL fEnable );
    STDMETHODIMP UIActivate( UINT uState );
    STDMETHODIMP Refresh( void );

    STDMETHODIMP CreateViewWindow( IShellView * lpPrevView,
                                   LPCFOLDERSETTINGS lpfs,
                                   IShellBrowser * psb,
                                   RECT * prcView,
                                   HWND * phwnd);

    STDMETHODIMP DestroyViewWindow( void );
    STDMETHODIMP GetCurrentInfo( LPFOLDERSETTINGS lpfs );
    STDMETHODIMP AddPropertySheetPages( DWORD dwReserved,
                                        LPFNADDPROPSHEETPAGE lpfn,
                                        LPARAM lparam);

    STDMETHODIMP SaveViewState( void );
    STDMETHODIMP SelectItem( LPCITEMIDLIST lpvID, UINT uFlags );
    STDMETHODIMP GetItemObject( UINT uItem, REFIID riid, LPVOID *ppv );


    // **** IDropTarget ****
    //
    STDMETHODIMP DragEnter( IDataObject __RPC_FAR *pDataObj,
                            DWORD grfKeyState, POINTL pt,
                            DWORD __RPC_FAR *pdwEffect );

    STDMETHODIMP DragOver( DWORD grfKeyState,
                           POINTL pt,
                           DWORD __RPC_FAR *pdwEffect );

    STDMETHODIMP DragLeave( void );

    STDMETHODIMP Drop( IDataObject __RPC_FAR *pDataObj,
                       DWORD grfKeyState,
                       POINTL pt,
                       DWORD __RPC_FAR *pdwEffect );

    // *** IPersist methods ***

    STDMETHODIMP GetClassID( LPCLSID lpClassID );

    // *** IPersistFolder methods ***

    STDMETHODIMP Initialize( LPCITEMIDLIST pidl );

public:
    void StatusPush( UINT nStatus );
    void StatusPush( LPTSTR lpsz );
    void StatusPop( );
    void StatusClear( );
    //
    // Exposing this is a violation of the design of this object.
    // However, it is needed so that we can provide a parent to the installation
    // progress dialog.
    //
    HWND GetViewWindow(void)
        { return m_hwndView; }
    DWORD GetDateReading(void)
        { return m_dwDateFormat; }

    IDataObject *m_pdtobjHdrop; // Used to support drag-drop from Win3.1 app.

private:
    enum CLICKMODE
    {
        CLICKMODE_SINGLE = 1,
        CLICKMODE_DOUBLE = 2,
    };

    int RegisterWindowClass( );
    STDMETHODIMP GetSavedViewState( );
    void SortObjects( );
    void FillObjects( );
    int AddObject( CFontClass * poFont );
    LRESULT BeginDragDrop( NM_LISTVIEW FAR *lpn );
    int OnActivate( UINT state );
    int OnDeactivate( );
    int MergeToolbar( );
    static INT_PTR CALLBACK FontViewDlgProc( HWND, UINT, WPARAM, LPARAM );
    static LRESULT CALLBACK FontViewWndProc( HWND, UINT, WPARAM, LPARAM );
    static INT_PTR CALLBACK OptionsDlgProc( HWND, UINT, WPARAM, LPARAM) ;
    int OnMenuSelect( HWND hWnd, UINT nID, UINT nFlags, HMENU hMenu );
    int OnCommand( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
    int OnNotify( LPNMHDR lpn );
    VOID OnLVN_ItemActivate(LPNMITEMACTIVATE pnma);
    void OnDropFiles( HDROP hDrop, DWORD dwEffect = DROPEFFECT_MOVE );
    void OnCmdCutCopy( UINT nID );
    void OnCmdDelete( );
    void OnCmdPaste( );
    void OnCmdProperties( );
    void OnPointSize( int nPlus );
    void OnHelpTopics( HWND hWnd );
    INT ItemImageIndex(CFontClass *poFont);
    CLICKMODE SetListviewClickMode(VOID);
    void UpdateUnderlines(void);
    void LV_OnGetInfoTip(LPNMLVGETINFOTIP lpnm);
    VOID LV_OnHoverNotify(LPNMLISTVIEW pnmlv);
    BOOL CreateToolTipWindow(VOID);
    VOID UpdateFontSample(INT iItem);

    //
    // Functions to support Attributes column in details view and
    // alternate coloring of compressed files.
    //
    int OnShellChangeNotify(WPARAM wParam, LPARAM lParam);
    int OnCustomDrawNotify(LPNMHDR lpn);
    void UpdateFontViewObject(CFontClass *poFont);
    int CompareByFileAttributes(CFontClass *poFont1, CFontClass *poFont2);
    LPTSTR BuildAttributeString(DWORD dwAttributes, LPTSTR pszString, UINT nChars);

    //
    // Functions to support drag-drop from Win3.1 app.
    //
    void OldDAD_DropTargetLeaveAndReleaseData(void);
    LRESULT OldDAD_HandleMessages(UINT message, WPARAM wParam, const DROPSTRUCT *lpds);

    void UpdateMenuItems( HMENU hMenu );
    void UpdateToolbar( );
    LRESULT ProcessMessage( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
    BOOL OpenCurrent( );
    BOOL PrintCurrent( );
    BOOL ViewValue( CFontClass * poFont );
    BOOL PrintValue( CFontClass *poFont );

    void vLoadCombo( );
    void SetViewMode( UINT uMode );
    void UpdatePanColumn( );
    void vToggleSelection( BOOL bSelectAll );
    int  iCurrentSelection( );

    HRESULT  GetUIObjectFromItem( REFIID riid, LPVOID FAR *ppobj, UINT nItem );
    HRESULT  GetFontList( CFontList **ppoList, UINT nItem );
    void ReleaseFontObjects(void);
    void UpdateSelectedCount();


private:
    int   m_cRef;
    BOOL  m_bFamilyOnly;
    CFontClass * m_poPanose;
    HWND  m_hwndView;
    HWND  m_hwndList;
    HWND  m_hwndText;
    HWND  m_hwndCombo;
    HWND  m_hwndParent;
    HWND  m_hwndNextClip;       // Next window in the viewer chain
    HMODULE m_hmodHHCtrlOcx;    // Html Help OCX.

    DWORD m_dwDateFormat;

    HWND    m_hwndToolTip;        // Tooltip window handle.
    BOOL    m_bShowPreviewToolTip;// User preference setting.
    LPTSTR  m_pszSampleText;      // Sample string used for character fonts.
    LPTSTR  m_pszSampleSymbols;   // Sample string used for symbol fonts.
    INT     m_iTTLastHit;         // Last item with active tooltip.
    HFONT   m_hfontSample;        // Font for displaying sample in tooltip window.

    HIMAGELIST m_hImageList;
    HIMAGELIST m_hImageListSmall;
    int   m_iFirstBitmap;
    HMENU m_hmenuCur;
    IShellBrowser* m_psb;

    UINT  m_uState;             // Deactivated, active-focus, active-nofocus
    UINT  m_idViewMode;
    UINT  m_ViewModeReturn;
    UINT  m_fFolderFlags;
    UINT  m_nComboWid;
    int   m_iSortColumn;
    int   m_iSortLast;
    BOOL  m_bSortAscending;     // TRUE = ascending, FALSE = descending.
    CLICKMODE m_iViewClickMode; // CLICKMODE_SINGLE or CLICKMODE_DOUBLE.

    DWORD m_dwEffect;           // Drag/drop effect.
    DWORD m_dwOldDADEffect;     // Drag/drop effect for Win3.1-style drops.
    DWORD m_grfKeyState;
    BOOL  m_bDragSource;
    int m_iHidden;
    HANDLE m_hAccel;
    BOOL  m_bResizing;          // Resizing the view window ?
    BOOL  m_bUIActivated;       // UI Activated through UIActivate( )
                                // This flag is used to prevent processing
                                // NM_SETFOCUS before UIActivate( ) has
                                // been called.
    ULONG m_uSHChangeNotifyID;  // Registered shell change notification ID.
    CFontIconHandler m_IconHandler;
    CFontManager *m_poFontManager;

    BOOL  m_bShowCompColor;     // T = user want's alternate color for compressed items.
    BOOL  m_bShowHiddenFonts;
};


#endif   // __FONTVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\fsnotify.h ===
//------------------------------------------------------------------------
// FSNotify.h
//
// Include file for FSNotify.cpp
//------------------------------------------------------------------------

#if !defined(__FSNOTIFY_H__)
#define __FSNOTIFY_H__

#if defined(__FCN__)

// Forward Declarations --------------------------------------------------
//
class CFontManager;

//------------------------------------------------------------------------

typedef struct {
   HANDLE          m_hWatch;  // Returned from FindFirstChangeNotify.
} NOTIFYWATCH, FAR * LPNOTIFYWATCH;

DWORD dwNotifyWatchProc( LPVOID pvParams );

#endif // __FCN__ 

#endif   // __FSNOTIFY_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\globals.h ===
/***************************************************************************
 * globals.h - TrueType Font Manager global data declaration.
 *
 * $keywords: globals.h 1.3 17-Mar-94 2:38:47 PM$
 *
 * Copyright (C) 1992-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __GLOBALS_H__
#define __GLOBALS_H__

#define ERR_FAIL 0
#define NOERR 1

#include <fstream.h>

//
//  Constants
//

#define MAX_NAME_LEN            64
#define MAX_LOG_NAME_LEN        32
#define MAX_PATH_LEN            MAX_PATH
#define MAX_FILE_LEN            MAX_PATH_LEN
// #define MAX_DIRS                32
#define IDX_NULL                0xFFFF      // index out of range
#define IDX_ZERO                0x0000
#define PANOSE_LEN              10
#define COPYRIGHT_LEN           60

//
//  Defines
//

#define PATHMAX MAX_PATH   // path length max - used for Get...Directory() calls
#define DESCMAX 129        // max description in newexe header
#define MODNAMEMAX 20      // max module name in newexe header

//
//  Name/string types
//

typedef TCHAR   FullPathName_t[ PATHMAX ];
typedef TCHAR   FontDesc_t[ DESCMAX ];
typedef TCHAR   ModName_t[ MODNAMEMAX ];

typedef TCHAR   LOGNAME[ MAX_LOG_NAME_LEN + 1 ]; // log font name
typedef TCHAR   FAMNAME[ MAX_LOG_NAME_LEN + 1 ]; // font Family name
typedef TCHAR   FONTNAME[ MAX_NAME_LEN + 1 ];
typedef TCHAR   PATHNAME[ MAX_PATH_LEN + 1 ];
typedef TCHAR   FILENAME[ MAX_FILE_LEN + 1 ];


//
//  Globals
//

extern BOOL      g_bTrace;
extern BOOL      g_bDiag;
extern BOOL      g_bTimer;

extern HINSTANCE g_hInst;

extern TCHAR     g_szType1Key[];

extern TCHAR     c_szTrueType[];
extern TCHAR     c_szOpenType[];
extern TCHAR     c_szPostScript[];
extern TCHAR     c_szDescFormat[];
extern TCHAR     szNull[];

extern FullPathName_t   s_szSharedDir;


//
// Far East character handling.
//
extern BOOL g_bDBCS;

//
//  Number of references to objects in this dll
//

extern LONG      g_cRefThisDll;

//
//  Types
//

typedef short  RC;
typedef WORD   SFIDX;      /* display sorted index into font list */
typedef WORD   FTIDX;
typedef WORD   POINTSIZE;     /* Size of point measurement */

// EMR: This needs to be a WORD so it fits in the ListITEMDATA struct.
//typedef int         FONTNUM;    /* Font number */
typedef WORD         FONTNUM;    /* Font number */
typedef FONTNUM*     PFONTNUM;   /* Font number */
typedef FONTNUM FAR* LPFONTNUM;  /* Font number */

//
//  typedefs.
//

//
//  Font description info. Used during installation and to retrieve info
//  about a font.
//
//  szFile must is filled in by calling proc. The rest is filled in depending
//       on the flags.
//

#define  FDI_DESC    1
#define  FDI_FAMILY  2
#define  FDI_PANOSE  4
#define  FDI_STYLE   8
#define  FDI_ALL     (DWORD)(15)
#define  FDI_NONE    0

#define  FDI_VTC     16    // Version Trademark and copyright.

//
// Style bits. These can be OR'd together
//

#define  FDI_S_REGULAR  0
#define  FDI_S_BOLD     1
#define  FDI_S_ITALIC   2


typedef struct {
   DWORD          dwFlags;
   FullPathName_t szFile;
   FontDesc_t     szDesc;
   FAMNAME        szFamily;
   DWORD          dwStyle;
   WORD           wWeight;
   TCHAR          jPanose[ PANOSE_LEN ];

   //
   // These strings are allocated by the routine that actually retrieves
   // the strings. They should be deleted using the C++ delete[] operator.
   //

   TCHAR *  lpszVersion;
   TCHAR *  lpszTrademark;
   TCHAR *  lpszCopyright;
   
} FONTDESCINFO, FAR * LPFONTDESCINFO;

void FONTDESCINFO_Init(FONTDESCINFO *pfdi);
void FONTDESCINFO_Destroy(FONTDESCINFO *pfdi);

inline void FONTDESCINFO_Init(FONTDESCINFO *pfdi)
{
    ZeroMemory(pfdi, sizeof(*pfdi));
}

inline void FONTDESCINFO_Destroy(FONTDESCINFO *pfdi)
{
    delete[] pfdi->lpszVersion;
    delete[] pfdi->lpszTrademark;
    delete[] pfdi->lpszCopyright;
    FONTDESCINFO_Init(pfdi);
}


//
//  Enums
//

typedef enum {
   eFKNone     = 0,
   eFKDevice,
   eFKTrueType,
   eFKOpenType,
   eFKTTC,
   eFKType1
} eFileKind;

typedef enum _tagMPVIEW {
   eVFont    = 0,
   eVFamily,
   eVFile,
   eVPanose
} MPVIEW;


extern BOOL  NEAR PASCAL bIsTrueType( LPFONTDESCINFO lpFile, LPDWORD pdwTableTags = NULL, LPDWORD lpdwStatus = NULL );
extern BOOL  NEAR PASCAL bIsNewExe( LPFONTDESCINFO lpFile );

extern int GetFontsDirectory( LPTSTR pszPath, size_t cchPath);
extern BOOL WriteToRegistry( LPTSTR lpDesc, LPTSTR lpFile );

extern int  FAR PASCAL iUIErrMemDlg(HWND hwndParent);   // Everyone needs this
extern int  FAR PASCAL iUIMsgBox( HWND hwndParent, 
                                  WORD wIDStr,
                                  WORD wCAPStr,
                                  UINT uiMBFlags,
                                  LPCTSTR wArg1 = 0,
                                  LPCTSTR wArg2 = 0,
                                  LPCTSTR wArg3 = 0,
                                  LPCTSTR wArg4 = 0);
//
//  These are 3 simple covers which make calling the message routine
//  much simpler.
//

int FAR PASCAL iUIMsgBoxWithCaption(HWND hwndParent, WORD wIDStr, WORD wCaption);
int FAR PASCAL iUIMsgYesNoExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg = 0);
int FAR PASCAL iUIMsgYesNoExclaim(HWND hwndParent, WORD wIDStr, WORD wCap, LPCTSTR wArg=0);
int FAR PASCAL iUIMsgOkCancelExclaim(HWND hwndParent, WORD wIDStr, WORD wCap, LPCTSTR wArg=0);
int FAR PASCAL iUIMsgRetryCancelExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg=0 );
int FAR PASCAL iUIMsgExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg = 0);
int FAR PASCAL iUIMsgBox(HWND hwndParent, WORD wIDStr, LPCTSTR wArg = 0);
int FAR PASCAL iUIMsgInfo(HWND hwndParent, WORD wIDStr, LPCTSTR wArg = 0);

//
// Special-purpose message box for reporting font validation failures.
// dwStatusCode must be one of FVS_XXXXXXXX values as defined in fvscodes.h
// 
int iUIMsgBoxInvalidFont(HWND hwndParent, LPCTSTR pszFontFile, LPCTSTR pszFontDesc,
                         DWORD dwStatusCode,
                         UINT uStyle = (MB_OKCANCEL | MB_ICONEXCLAMATION));

#include "fvscodes.h"  // \nt\private\windows\shell\control\t1instal\fvscodes.h
                       // Contains FVS_xxxxx codes and related macros.


#endif /* __GLOBALS_H_ */

/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * 1.1     9-Mar-94   eric Background thread and g_hDBMutex
 * 1.2     9-Mar-94   eric Added Gdi mutex.
 * 1.3    17-Mar-94   eric Removed mutex handles.
 * $lge$
 *
 ****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\priv.h ===
#define _INC_OLE
#define CONST_VTABLE
#define DONT_WANT_SHELLDEBUG   1

#include <windows.h>
#include <windowsx.h>
#include <winuserp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlobjp.h>
#include <shfusion.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <ole2.h>
#include <tchar.h>
#include <strsafe.h>

// define __FCN__ to enable the FileChangeNotify procession.
//
#define __FCN__

#ifdef _fstrcpy
#undef _fstrcpy
#endif
#ifdef _fstrcat
#undef _fstrcat
#endif
#ifdef _fstrlen
#undef _fstrlen
#endif

#define _fstrcpy lstrcpy
#define _fstrcat lstrcat
#define _fstrlen lstrlen

#ifndef ARRAYSIZE
#   define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#endif

inline HRESULT ResultFromLastError(void)
{
    const DWORD dwErr = GetLastError();
    return HRESULT_FROM_WIN32(dwErr);
}

HRESULT ComboGetText(HWND hwndCombo, int iItem, LPTSTR pszText, size_t cchText);

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\pnewexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */

#ifdef NEVER
    unsigned short int  ne_psegcsum;    /* offset to segment chksums */
#else
    unsigned char    ne_exetyp;    /* Target Operating system */
    unsigned char    ne_flagsothers;    /* Other .EXE flags */
#endif
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res
#define NE_EXETYPE(x)    (x).ne_exetyp

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP     0x03        /* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004      /* True if handler proc return handle */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

/* Target operating systems:  Possible values of ne_exetyp field */

#define NE_UNKNOWN    0    /* Unknown (any "new-format" OS) */
#define NE_OS2        1    /* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS    2    /* Microsoft Windows         */
#define NE_DOS4       3    /* Microsoft MS-DOS 4.x         */
#define NE_DEV386     4    /* Microsoft Windows 386     */



/****************************************************************************
 * $lgb$
 * 1.0     7-Mar-94   eric Initial revision.
 * $lge$
 *
 ****************************************************************************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\panmap.h ===
/***************************************************************************
 * PANMAP.H - Base definitions for ElseWare PANOSE(tm) 1.0 Font Mapper.
 *            OLE 2.0 Implementation
 *
 *
 * Copyright (C) 1991-94 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __PANOLE2_H__
#define __PANOLE2_H__

#ifdef INITGUID

/* A Global Unique Identifier and an Interface ID for the PANOSE mapper.
 */

DEFINE_GUID(CLSID_PANOSEMapper, 0xBD84B381L, 0x8CA2, 0x1069, 0xAB, 0x1D, 0x08,
        0x00, 0x09, 0x48, 0xF5, 0x34);
DEFINE_GUID(IID_IPANOSEMapper, 0xBD84B382L, 0x8CA2, 0x1069, 0xAB, 0x1D, 0x08,
        0x00, 0x09, 0x48, 0xF5, 0x34);
#else

#if defined(__cplusplus)
extern "C" {
#endif

extern const CLSID CLSID_PANOSEMapper;
extern const IID IID_IPANOSEMapper;

#if defined(__cplusplus)
}
#endif

#endif



DECLARE_INTERFACE_( IPANOSEMapper, IUnknown)
{
    /* IUnknown 
     */
    STDMETHOD(QueryInterface) (THIS_
                               REFIID riid,
                               LPVOID FAR* ppvObj) PURE;

    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    /* The PANOSE Mapper interface.
     */

    STDMETHOD_(USHORT, unPANMatchFonts) ( THIS_
                                          LPBYTE lpPanWant,
                                          ULONG ulSizeWant,
                                          LPBYTE lpPanThis,
                                          ULONG ulSizeThis,
                                          BYTE jMapToFamily) PURE;
    
    
    STDMETHOD_(VOID, vPANMakeDummy)( THIS_
                                     LPBYTE lpPanThis,
                                     USHORT unSize ) PURE;
    
    STDMETHOD_(SHORT, nPANGetMapDefault)( THIS_
                                          LPBYTE lpPanDef,
                                          USHORT unSizePanDef ) PURE;
    
    STDMETHOD_(SHORT, nPANSetMapDefault) (THIS_
                                          LPBYTE lpPanDef,
                                          USHORT unSizePanDef ) PURE;
    
    STDMETHOD_(BOOL, bPANEnableMapDefault) (THIS_
                                            BOOL bEnable )  PURE;
    
    STDMETHOD_(BOOL, bPANIsDefaultEnabled) (THIS)  PURE;
    
    STDMETHOD_(USHORT, unPANPickFonts) (THIS_
                                        USHORT FAR *lpIndsBest,
                                        USHORT FAR *lpMatchValues,
                                        LPBYTE lpPanWant,
                                        USHORT unNumInds,
                                        LPBYTE lpPanFirst,
                                        USHORT unNumAvail,
                                        SHORT nRecSize,
                                        BYTE jMapToFamily ) PURE ;
    
    STDMETHOD_(USHORT, unPANGetMapThreshold) (THIS) PURE;
    
    STDMETHOD_(BOOL, bPANSetMapThreshold) (THIS_
                                           USHORT unThreshold ) PURE;
    
    STDMETHOD_(BOOL, bPANIsThresholdRelaxed) (THIS) PURE;
    
    STDMETHOD_(VOID, vPANRelaxThreshold) (THIS) PURE;
    
    STDMETHOD_(BOOL, bPANRestoreThreshold) (THIS) PURE;
    
    STDMETHOD_(BOOL, bPANGetMapWeights) (THIS_
                                         BYTE jFamilyA,
                                         BYTE jFamilyB,
                                         LPBYTE lpjWts,
                                         LPBOOL lpbIsCustom ) PURE;
    
    STDMETHOD_(BOOL, bPANSetMapWeights) (THIS_
                                         BYTE jFamilyA,
                                         BYTE jFamilyB, LPBYTE lpjWts ) PURE;
    
    STDMETHOD_(BOOL, bPANClearMapWeights) (THIS_
                                           BYTE jFamilyA,
                                           BYTE jFamilyB ) PURE;
};
typedef IPANOSEMapper FAR * LPPANOSEMAPPER;


//------------------------------------------------------------------------
// Mapper definitions.
//

#endif   // __PANOLE2_H__


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\resource.h ===
/**************************************************************************
 * resource.h - Font assistant resource constants.
 *
 * Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
 ***************************************************************************/

#ifndef __RESOURCE_H__
#define __RESOURCE_H__

#include <dlgs.h>

//*********************************************************************
// Icons
//
#define IDI_ICON                        1

#define IDI_FIRSTFONTICON               2  // First in image list.

#define IDI_TTF                         2
#define IDI_FON                         3
#define IDI_TTC                         4
#define IDI_T1                          5
#define IDI_OTFp                        6  // "OTp" icon
#define IDI_OTFt                        7  // "OTt" icon

#define IDI_LASTFONTICON                7  // Update this if you add another.

#define TYPE1ICON                     IDI_T1

   // Extracted from SHELL32.DLL
   //
#define IDI_X_LINK                      30
#define IDI_X_NUKE_FILE                 161
#define IDI_X_DELETE                    142


//*********************************************************************
// Bitmaps
//
#define IDB_TOOLICONS                   15

//*********************************************************************
// Accelerator table
//
#define ACCEL_DEF                       20

//*********************************************************************
// Menus and Menu Items
//
#define MENU_DEFSHELLVIEW               29

#define IDM_FILE_SAMPLE                 30
#define IDM_FILE_PRINT                  31
#define IDM_FILE_INSTALL                32
#define IDM_FILE_LINK                   33
#define IDM_FILE_DEL                    34
#define IDM_FILE_RENAME                 35
#define IDM_FILE_PROPERTIES             36

#define IDM_EDIT_SELECTALL              37
#define IDM_EDIT_SELECTINVERT           38
#define IDM_EDIT_CUT                    39
#define IDM_EDIT_COPY                   40
#define IDM_EDIT_PASTE                  41

// --------------------------------------------------------
// The following IDs need to be kept in sequetial order: 
//    IDM_VIEW_ICON to IDM_POINT_DOWN
//
#define IDM_VIEW_ICON                   42
#define IDM_VIEW_LIST                   43
#define IDM_VIEW_PANOSE                 44
#define IDM_VIEW_DETAILS                45

#define IDM_VIEW_ACTUAL                 46
#define IDM_EDIT_UNDO                   47  
#define IDM_VIEW_PREVIEW                48
// --------------------------------------------------------

#define IDM_VIEW_VARIATIONS             49

// Popups for context menus.
#define IDM_POPUPS                      58
#define IDM_POPUP_NOITEM                59
#define IDM_POPUP_DRAGDROP              60


// Other messages delivered through WM_COMMAND
//
#define IDM_IDLE                        61
#define IDM_POPUP_MOVE                  62
#define IDM_POPUP_COPY                  63
#define IDM_POPUP_LINK                  64
#define IDM_POPUP_CANCEL                65

#define IDM_HELP_TOPIC                  66
#define IDM_HELP_ABOUT                  67

//*********************************************************************
// Dialogs
//
#define ID_DLG_FONT2                   70  // Install dialog
#define ID_LB_ADD      ctlLast+1
#define ID_SS_PCT      ctlLast+2

#define ID_DLG_MAIN                    76
#define ID_TXT_SIM                     77
#define ID_CB_PANOSE                   78

#define ID_DLG_PROPPAGE                80

#define ID_DLG_OPTIONS                 85
#define IDC_TTONLY                     86

#define DLG_INSTALL                    90
#define IDD_INSTALL                    91
#define COLOR_SAVE                     92
#define IDD_HELP                       93

#define DLG_BROWSE                     100
#define IDD_BROWSE                     101

#define DLG_PROGRESS                   110
#define DLG_INSTALL_PS                 120

#define DLG_COPYRIGHT_NOTIFY           130
#define IDC_COPYRIGHT_FONTNAME         131
#define IDC_COPYRIGHT_VENDORNAME       132
//
// Help ids
//

#define IDH_HELPFIRST        5000
#define IDH_SYSMENU     (IDH_HELPFIRST + 2000)
#define IDH_MBFIRST     (IDH_HELPFIRST + 2001)
#define IDH_DLG_FONT2   (IDH_HELPFIRST + 2002)
#define IDH_MBLAST      (IDH_HELPFIRST + 2099)
#define IDH_DLGFIRST    (IDH_HELPFIRST + 3000)

//#define IDH_DLG_REMOVEFONT  (IDH_DLGFIRST + DLG_REMOVEFONT)
#define IDH_DLG_BROWSE      (IDH_DLGFIRST + DLG_BROWSE)

#define IDH_DLG_INSTALL_PS     (IDH_DLGFIRST + DLG_INSTALL_PS)
//#define IDH_DLG_REMOVEFONT_PS  (IDH_DLGFIRST + DLG_REMOVEFONT_PS)

//
//  Progress dialog control ids
//

#define ID_INSTALLMSG           42
#define ID_PROGRESSMSG          43
#define ID_BAR                  44
#define ID_OVERALL              45


//
//  Font dialogs control ids
//

#define IDD_YESALL        122

#define FONT_REMOVEMSG    418
#define FONT_REMOVECHECK  419
#define FONT_TRUETYPEONLY 420
#define FONT_CONVERT_PS   431
#define FONT_INSTALL_PS   432
#define FONT_COPY_PS      433
#define FONT_REMOVE_PS    434
#define FONT_INSTALLMSG   435




//*********************************************************************
// Strings
//

/* General messsages.  If the message is a constant string, we call
 * it IDS_MSG_xxx or IDX_TXT_xxx.
 * If we substitute something (via sprintf or similar), its IDS_FMT_xxx
 */

#define IDS_FONTS_FOLDER        140    // The name of the fonts folder in the windows dir.

#define IDS_MSG_CAPTION         151
#define IDS_MSG_NOVERSION       153
#define IDS_MSG_NSFMEM          154

#define IDS_MSG_PANOSE          163

#define IDS_MSG_ALLFILTER       165
#define IDS_MSG_NORMALFILTER    166


#define IDS_FMT_VERSION         177

/* Font installer messages */

#define IDSI_CAP_NOINSTALL      210
#define IDSI_CAP_NOCREATE       211
#define IDSE_CAP_CREATERR       212

#define IDSI_MSG_TTDISABLED     215
#define IDSI_MSG_NOFONTS        216
#define IDSI_MSG_COPYCONFIRM    217
#define IDSI_MSG_DEFDIR         218

#define IDSI_FMT_BADINSTALL     222
#define IDSI_FMT_ISINSTALLED    223
#define IDSI_FMT_RETRIEVE       224
#define IDSI_FMT_COMPRFILE      225
#define IDSI_FMT_FILEFNF        229
#define IDSI_UNKNOWN_VENDOR     232



#define INSTALL0        250
#define INSTALL1        251
#define INSTALL2        252
#define INSTALL3        253
#define INSTALL4        254
#define INSTALL5        255
#define INSTALL6        256
#define INSTALL7        257
#define INSTALL8        258
#define INSTALL9        259

// COLUMN String info for the List Views
#define IDS_PAN_COL1          301
#define IDS_PAN_COL2          302

#define IDS_FILE_COL1         303
#define IDS_FILE_COL2         304
#define IDS_FILE_COL3         305
#define IDS_FILE_COL4         306
#define IDS_FILE_COL5         307
#define IDS_ATTRIB_CHARS      308
#define IDS_FONTSAMPLE_TEXT   309
#define IDS_FONTSAMPLE_SYMBOLS 310

#define IDS_VIEW_ICON         311
#define IDS_VIEW_LIST         312
#define IDS_VIEW_PANOSE       313
#define IDS_VIEW_DETAILS      314


// File types
#define IDS_FONT_FILE         407
#define IDS_TT_FILE           408

#define IDS_NO_PAN_INFO       409
#define IDS_PAN_VERY_SIMILAR  410
#define IDS_PAN_SIMILAR       411
#define IDS_PAN_NOT_SIMILAR   412
#define IDS_FMT_FILEK         413
#define IDS_TTC_CONCAT        414


// Strings for Shell Extension
//
#define IDS_EXT_INSTALL       420
#define IDS_EXT_INSTALL_HELP  421

//
// Strings for font file validation errors.
// FVS = Font Validation Status.
//
#define IDS_FMT_FVS_PREFIX      450
#define IDS_FMT_FVS_FILEOPEN    451
#define IDS_FMT_FVS_FILECREATE  452
#define IDS_FMT_FVS_FILEEXISTS  453
#define IDS_FMT_FVS_BADVERSION  454
#define IDS_FMT_FVS_INVFONTFILE 455
#define IDS_FMT_FVS_FILEIO      466
#define IDS_FMT_FVS_INTERNAL    467


// Status messages.
//

#define IDST_FILE_SAMPLE       490
#define IDST_FILE_PRINT        491
#define IDST_FILE_INSTALL      492
#define IDST_FILE_LINK         493

#define IDST_FILE_DEL          494
#define IDST_FILE_RENAME       495
#define IDST_FILE_PROPERTIES   496
                                
#define IDST_EDIT_SELECTALL    497
#define IDST_EDIT_SELECTINVERT 498
#define IDST_EDIT_CUT          499
#define IDST_EDIT_COPY         500
#define IDST_EDIT_PASTE        501

#define IDST_VIEW_ICON         502
#define IDST_VIEW_LIST         503
#define IDST_VIEW_PANOSE       504
#define IDST_VIEW_DETAILS      505

#define IDST_EDIT_UNDO         506
                                
#define IDST_VIEW_VARIATIONS   509
#define IDST_VIEW_PREVIEW      510
#define IDST_HELP_TOPICS       511

#define IDS_SELECTED_FONT_COUNT         520
#define IDS_TOTAL_FONT_COUNT            521
#define IDS_TOTAL_AND_HIDDEN_FONT_COUNT 522
#define IDSI_FMT_DELETECONFIRM          523

#define IDS_NEXTREBOOT          524
#define IDS_INSTALL_MUTEX_WAIT_FAILED 525

#define INSTALLIT               530     /* Two messages for installing */

#define MYFONT                  600

#define IDC_LIST_OF_FONTS		601
#endif   //  __RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\strtab.h ===
#ifndef __STRING_TABLE_H
#define __STRING_TABLE_H
///////////////////////////////////////////////////////////////////////////////
// Class: StringTable
//
// This class implements a simple hash table for storing text strings.
// The purpose of the table is to store strings and then verify later
// if the table contains a given string.  Since there is no data associated
// with the string, the stored strings act as both key and data.  Therefore,
// there is no requirement for string retrieval.  Only existence checks
// are required.
// The structure maintains a fixed-length array of pointers, each pointing
// to a linked list structure (List).  These lists are used to handle the
// problem of hash collisions (sometimes known as "separate chaining").
//
// Note that these classes do not contain all the stuff that is usually
// considered necessary in C++ classes.  Things like copy constructors,
// assignment operator, type conversion etc are excluded.  The classes
// are very specialized for the Font Folder application and these things
// would be considered "fat".  Should this hash table class be later used 
// in a situation where these things are needed, they can be added then.
//
// The public interfaces to the table are:
//
//      Initialize  - Initialize a new string table.
//      Add         - Add a new string to a table.
//      Exists      - Determine if a string exists in a table.
//      Count       - Return the number of strings in a table.
//
// Destruction of the object automatically releases all memory associated
// with the table.
//
// BrianAu - 4/11/96
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <tchar.h>

//
// Hash table containing text strings.
// 
class StringTable {
    private:
        //
        // Linked list for hash collisions.
        //
        class List {
            private:
                //
                // Element in hash collision list.
                //
                class Element {
                    public:
                        LPTSTR m_pszText;   // Pointer to string text.
                        Element *m_pNext;   // Pointer to next in list.

                        Element(void);
                        ~Element(void);
                        BOOL Initialize(LPCTSTR pszItem);
                        BOOL operator == (const Element& ele) const;
                        BOOL operator != (const Element& ele) const;
#ifdef DEBUG
                        void DebugOut(void) const;
#endif
                };

                Element *m_pHead;  // Ptr to head of list;
                DWORD   m_dwCount; // Count of elements in list.

            public:
                List(void);
                ~List(void);
                BOOL Add(LPCTSTR pszText, BOOL bAllowDuplicates = TRUE);
                BOOL Exists(LPCTSTR pszText) const;
                DWORD Count(void) const { return m_dwCount; }
#ifdef DEBUG
                void DebugOut(void) const;
#endif
        };

        List **m_apLists;         // Array of ptrs to collision lists.
        DWORD m_dwItemCount;      // Number of items in table.
        DWORD m_dwHashBuckets;    // Number of pointers in hash array.
        BOOL  m_bCaseSensitive;   // Key strings treated case-sensitive?
        BOOL  m_bAllowDuplicates; // Allow duplicate strings?

        DWORD Hash(LPCTSTR pszText) const;
        LPTSTR StringTable::CreateUpperCaseString(LPCTSTR pszText) const;
        BOOL Exists(DWORD dwHashCode, LPCTSTR pszText);

    public:
        StringTable(void);
        ~StringTable(void);
        HRESULT Initialize(DWORD dwHashBuckets, 
                           BOOL bCaseSensitive   = TRUE,
                           BOOL bAllowDuplicates = FALSE);

        void Destroy(void);
        BOOL Add(LPCTSTR pszText);
        BOOL Exists(LPCTSTR pszText);
        DWORD Count(void) const { return m_dwItemCount; }
#ifdef DEBUG
        void DebugOut(void) const;
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\vecttmpl.h ===
/**********************************************************************
 * VectTmpl.h
 *
 * Template for a vector class.
 *
 **********************************************************************/


#if !defined(__VECTTMPL_H__)
#define __VECTTMPL_H__

#ifndef __DBUTL_H__
#include "dbutl.h"
#endif


const int kNotFound = -1;

//
//  The CIVector class is a vector of pointers to objects (The I is for
//  Indirect).
//

template <class T>
class CIVector {
public:
    CIVector( int iSize );
    ~CIVector( );
    
    int bInit( );
    
    //
    //  The real array functions.
    //

    int   iCount( void );
    int   bAdd( T * t );
    T *   poObjectAt( int idx );
    T *   poDetach( int idx );
    int   bDelete( int idx );
    int   bDelete( T * t );
    void  vDeleteAll( );
    int   iFind( T * t );
    
private:
    T **  m_pData;
    int   m_iSize;
    int   m_iCount;

};

////////////////////////////////////////////////////////////////////////////
template <class T> 
CIVector<T>::CIVector(int iSize)
   :  m_pData(0),
      m_iSize(iSize),
      m_iCount(0)
{}

template <class T> CIVector<T>::~CIVector()
{
    ASSERT( this );
    vDeleteAll( );
    delete [] m_pData;
}

template <class T> int CIVector<T>::bInit()
{
    ASSERT( this );
    int   iRet = 0;
    
    if( !m_pData && (m_iSize > 0) )
    {
        m_pData = new T * [ m_iSize ];

        if( m_pData )
            return 1;
    }
    return 0;
}


template <class T> int CIVector<T>::iCount(void)
{
    ASSERT( this );
    return m_iCount;
}


template <class T> int CIVector<T>::bAdd(T * t)
{
    ASSERT( this );

#ifdef _DEBUG
    if( !m_pData )
    {
        OutputDebugString( TEXT( "CIVector::bAdd()  m_pData not allocated" ) );
        DebugBreak();
    }

    if( ! t )
        DebugBreak();
#endif

    if ( m_iCount < m_iSize )
    {
        m_pData[ m_iCount++ ] = t;
        return 1;
    }

    return 0;
}

template <class T> T * CIVector<T>::poObjectAt(int idx)
{
    ASSERT( this );

    if( idx >= 0 && idx < m_iCount )
    {
        ASSERT( m_pData[ idx ] );

        return m_pData[ idx ];
    }
    return 0;
}

template <class T> T * CIVector<T>::poDetach(int idx)
{
    ASSERT( this );

    if( idx >= 0 && idx < m_iCount )
    {
        ASSERT( m_pData );

        T * pID = m_pData[ idx ];

        //
        //  Move the last one down
        //

        m_pData[ idx ] = m_pData[ --m_iCount ];

#ifdef _DEBUG
        //
        //  When debugging, put a 0 in the slot.
        //

        m_pData[ m_iCount ] = (T *) 0;
#endif

        ASSERT ( pID );

        return pID;
    }

    return (T *)0;
}

template <class T> int CIVector<T>::bDelete( int idx )
{
    ASSERT( this );
    
    T * pID = poDetach( idx );
    
    if ( pID )
    {
        delete pID;
        return 1;
    }
    
    return 0;
}

template <class T> int CIVector<T>::bDelete( T * t )
{
    ASSERT( this );

    return bDelete( iFind( t ) );
}

template <class T> void CIVector<T>::vDeleteAll()
{
    ASSERT( this );

    while( m_iCount )
        bDelete( 0 );
}

template <class T> int CIVector<T>::iFind( T * t )
{
    ASSERT( this );

    for( int i = 0; i < m_iCount; i++ )
    {
        if( m_pData[ i ] == t )
            return i;
    }

    return kNotFound;
}

#endif   // __VECTTMPL_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\inc\ui.h ===
//------------------------------------------------------------------------
// UI.H
//
// Commonly used UI routines, classes, etc.
//------------------------------------------------------------------------

#if !defined(__UI_H__)
#define __UI_H__


#define vUIPStatusShow(a,b)

VOID FAR PASCAL vUIMsgInit( );
int FAR PASCAL iUIErrMemDlg( );

/*  The wait cursor is used to cause an hourglass for the duration of a
 *  routine.  The constructor sets the cursor to the hourglass, holding
 *  the previous. The destructor recovers the original cursor (or arrow if
 *  none).
 */

class WaitCursor
{
    public :
        WaitCursor () { m_Cursor = SetCursor(LoadCursor(NULL, IDC_WAIT));};
        ~WaitCursor () { if (m_Cursor != NULL)
                            SetCursor (m_Cursor);
                         else
                            SetCursor(LoadCursor(NULL, IDC_ARROW)); };
    private :
        HCURSOR    m_Cursor;
};

#endif // __UI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\append.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// append.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
// These logic are originally in sdkinstall.
// I rewrote these as used in CP font installation for JAPAN spec. -yutakan
//
// Modifies: now fnAppendSplitFiles takes pszFiles param that contains
//           list of split files, and szDest which should have destination path.
//           - 06/10/1992 yutakan
//
//  Create: 06/09/1992 Yutaka Nakajima [mskk]
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"
#include "cpanel.h"

#include "ui.h"

#define MAX_BUF         5120


//
// Import from dos.asm
// extern int FAR PASCAL OEMInfDosChDir( LPTSTR szDir );
//

BOOL AttachComponentFile( HANDLE fhDst, int fhSrc );

///////////////////////////////////////////////////////////////////////////////
//
// BOOL fnAppendSplitFiles( LPTSTR FAR *pszFiles, LPTSTR szDest );
//
// ASSUMES: The component files have already been LZ-copied to their
//          respective destination directories.
//          Explicitly uses LZxxxx functions for reading the component files.
//          Component files are compressed.
//
// ENTRY: LPTSTR FAR * pszFiles  .. has list of source files
//                                 files should be ordered in the order
//                                 in which they should be attached.
//        LPTSTR szDest          .. file name for destination.
//        int   nComp           .. number of component files we're attaching . 
//
// EXIT:  BOOL                  .. TRUE if succeed.
//
///////////////////////////////////////////////////////////////////////////////

BOOL far pascal fnAppendSplitFiles( LPTSTR FAR *pszFiles, LPTSTR szDest, int nComp )
{
    TCHAR    szCompFile[ 80 ];
    int      i;
    LPTSTR   lpDestFileName;
    LPTSTR   lpTemp;
    HANDLE   fhDst;
    TCHAR    lppath[ MAX_PATH ];

    int      fhComp;
    OFSTRUCT ofstruct;

    if( lpDestFileName = StrRChr( szDest, NULL, TEXT( '\\' ) ) )
    {
        *lpDestFileName = TEXT( '\0' );
        lpDestFileName++;
    }
    else
        return FALSE;

    //
    // Change to destination directory.
    //

    // if (OEMInfDosChDir(szDest) != 0)

    if( !SetCurrentDirectory( szDest ) )
        return FALSE;

    //
    //  Create destination file for writing. If it already exists,
    //  it is truncated to zero length.
    //

    fhDst = FCREATE ( lpDestFileName );

    if ( !fhDst )
        return FALSE;

    //
    //  When appending files, Cursor should be in HourGlass.
    //   1992.12.22 by yutakas
    //

    {

        WaitCursor wait;

        //
        //  Append all the component files one-by one to the destination
        //  file
        //

        for( i = 0; i < nComp; i++)
        {
            if( lstrlen( pszFiles[ i ] ) < 2 ) 
                goto BadParam;

            //
            // Assume pszFiles has list of string already formated as x:name,y:name...
            //

            if( lpTemp = StrChr( pszFiles[ i ], TEXT( ':' ) ) )
                StringCchCopy( szCompFile, ARRAYSIZE(szCompFile), lpTemp+1 );
            else
                StringCchCopy( szCompFile, ARRAYSIZE(szCompFile), pszFiles[ i ] );

            fhComp = LZOpenFile(szCompFile, &ofstruct, OF_READ | OF_SHARE_DENY_WRITE);

            if ( fhComp < 0 )
            {
BadParam:
                FCLOSE ( fhDst );
                return FALSE;
            }

            if( !AttachComponentFile( fhDst, fhComp ) )
            {
                FCLOSE ( fhDst );
                LZClose(fhComp);
                return FALSE;
            }

            //
            //  delete component file
            //
            LZClose(fhComp);
            DeleteFile(szCompFile);
        }   

        //
        //  close destination file
        //

        FCLOSE ( fhDst );
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// AttachComponentFile( fhDst, fhSrc )
//
// Appends a single file to another file using an intermediate buffer.
// Explicitly uses LZxxxx functions for reading the component file.
// Component files are compressed.
//
// ENTRY: int fhDst - handle of open destination file.
//        int fhSrc - handle of open component file.
//
// EXIT: BOOL
//     - TRUE on success, FALSE on failure  [ yutakan ] - 06/10/1992
//     - [ lalithar ] - 05/21/91
//
// NOTE: current buffer size set to 5K. The limit may be increased to a
//       larger value if needed.
//
///////////////////////////////////////////////////////////////////////////////
BOOL AttachComponentFile( HANDLE fhDst, int fhSrc )
{

#define BUF_STEP         1024

    char *pBuf, *pTmp;
    long   dwLen;
    int    wBufSize = MAX_BUF;

    //
    // determine the length of the component file
    //

    dwLen = LZSeek( fhSrc, 0L, SEEK_END );

    LZSeek(fhSrc, 0L, SEEK_SET);

    //
    // allocate a buffer of a reasonable size
    //

    pBuf = (LPSTR) LocalAlloc(LPTR, wBufSize );

    for ( ; ( pBuf == NULL ) && wBufSize; wBufSize -= BUF_STEP )
    {
        pBuf = (LPSTR) LocalAlloc(LPTR, wBufSize );
    }

    if( !pBuf )
        return FALSE;

    //
    //  Read MAX_BUF bytes of the component file into the buffer
    //  and write out the buffer to the destination file. Repeat this
    //  until the entire source file has been copied to the dest. file.
    //

    for( pTmp = pBuf; dwLen > wBufSize ; dwLen -= wBufSize )
    {
        LZRead( fhSrc, pTmp, wBufSize );
        FWRITEBYTES( fhDst, pTmp, wBufSize );
    }

    LZRead( fhSrc, pTmp, dwLen );
    FWRITEBYTES( fhDst, pTmp, dwLen );

    LocalFree( pBuf );

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\dblnul.cpp ===
#include "dblnul.h"

extern "C" {

HRESULT 
DblNulTermListW_Create(
    int cchGrowMin, 
    HDBLNULTERMLISTW *phList
    )
{
    CDblNulTermListW *pList = new CDblNulTermListW(cchGrowMin);
    if (NULL != pList)
    {
        *phList = static_cast<HDBLNULTERMLISTW>(pList);
        return S_OK;
    }
    *phList = NULL;
    return E_OUTOFMEMORY;
}


HRESULT 
DblNulTermListA_Create(
    int cchGrowMin,
    HDBLNULTERMLISTA *phList
    )
{
    CDblNulTermListA *pList = new CDblNulTermListA(cchGrowMin);
    if (NULL != pList)
    {
        *phList = static_cast<HDBLNULTERMLISTA>(pList);
        return S_OK;
    }
    *phList = NULL;
    return E_OUTOFMEMORY;
}

void 
DblNulTermListW_Destroy(
    HDBLNULTERMLISTW hList
    )
{
    delete static_cast<CDblNulTermListW *>(hList);
}

void 
DblNulTermListA_Destroy(
    HDBLNULTERMLISTA hList
    )
{
    delete static_cast<CDblNulTermListA *>(hList);
}


HRESULT 
DblNulTermListW_Add(
    HDBLNULTERMLISTW hList, 
    LPCWSTR pszW
    )
{
    CDblNulTermListW *pList = static_cast<CDblNulTermListW *>(hList);
    return pList->Add(pszW);
}

HRESULT 
DblNulTermListA_Add(
    HDBLNULTERMLISTA hList, 
    LPCSTR pszA
    )
{
    CDblNulTermListA *pList = static_cast<CDblNulTermListA *>(hList);
    return pList->Add(pszA);
}


void 
DblNulTermListW_Clear(
    HDBLNULTERMLISTW hList
    )
{
    CDblNulTermListW *pList = static_cast<CDblNulTermListW *>(hList);
    pList->Clear();
}

void 
DblNulTermListA_Clear(
    HDBLNULTERMLISTA hList
    )
{
    CDblNulTermListA *pList = static_cast<CDblNulTermListA *>(hList);
    pList->Clear();
}


int 
DblNulTermListW_Count(
    HDBLNULTERMLISTW hList
    )
{
    CDblNulTermListW *pList = static_cast<CDblNulTermListW *>(hList);
    return pList->Count();
}


int 
DblNulTermListA_Count(
    HDBLNULTERMLISTA hList
    )
{
    CDblNulTermListA *pList = static_cast<CDblNulTermListA *>(hList);
    return pList->Count();
}


HRESULT
DblNulTermListW_Buffer(
    HDBLNULTERMLISTW hList,
    LPCWSTR *ppszW
    )
{
    CDblNulTermListW *pList = static_cast<CDblNulTermListW *>(hList);
    *ppszW = (LPCWSTR)*pList;
    if (NULL != *ppszW)
    {
        return S_OK;
    }
    return E_FAIL;
}


HRESULT
DblNulTermListA_Buffer(
    HDBLNULTERMLISTA hList,
    LPCSTR *ppszA
    )
{
    CDblNulTermListA *pList = static_cast<CDblNulTermListA *>(hList);
    *ppszA = (LPCSTR)*pList;
    if (NULL != *ppszA)
    {
        return S_OK;
    }
    return E_FAIL;
}


HRESULT 
DblNulTermListW_CreateEnum(
    HDBLNULTERMLISTW hList,
    HDBLNULTERMLISTENUMW *phEnum
    )
{
    CDblNulTermListW *pList = static_cast<CDblNulTermListW *>(hList);
    CDblNulTermListEnumW *pEnum = new CDblNulTermListEnumW(pList->CreateEnumerator());
    if (NULL != pEnum)
    {
        *phEnum = static_cast<HDBLNULTERMLISTENUMW>(pEnum);
        return S_OK;
    }
    *phEnum = NULL;
    return E_OUTOFMEMORY;
}


HRESULT 
DblNulTermListA_CreateEnum(
    HDBLNULTERMLISTA hList,
    HDBLNULTERMLISTENUMA *phEnum
    )
{
    CDblNulTermListA *pList = static_cast<CDblNulTermListA *>(hList);
    CDblNulTermListEnumA *pEnum = new CDblNulTermListEnumA(pList->CreateEnumerator());
    if (NULL != pEnum)
    {
        *phEnum = static_cast<HDBLNULTERMLISTENUMA>(pEnum);
        return S_OK;
    }
    *phEnum = NULL;
    return E_OUTOFMEMORY;
}


HRESULT
DblNulTermListEnumW_Create(
    LPCWSTR pszW, 
    HDBLNULTERMLISTENUMW *phEnum
    )
{
    CDblNulTermListEnumW *pEnum = new CDblNulTermListEnumW(pszW);
    if (NULL != pEnum)
    {
        *phEnum = static_cast<HDBLNULTERMLISTENUMW>(pEnum);
        return S_OK;
    }
    *phEnum = NULL;
    return E_OUTOFMEMORY;
}


HRESULT
DblNulTermListEnumA_Create(
    LPCSTR pszA, 
    HDBLNULTERMLISTENUMA *phEnum
    )
{
    CDblNulTermListEnumA *pEnum = new CDblNulTermListEnumA(pszA);
    if (NULL != pEnum)
    {
        *phEnum = static_cast<HDBLNULTERMLISTENUMA>(pEnum);
        return S_OK;
    }
    *phEnum = NULL;
    return E_OUTOFMEMORY;
}


void
DblNulTermListEnumW_Destroy(
    HDBLNULTERMLISTENUMW hList
    )
{
    delete static_cast<CDblNulTermListEnumW *>(hList);
}

void
DblNulTermListEnumA_Destroy(
    HDBLNULTERMLISTENUMA hList
    )
{
    delete static_cast<CDblNulTermListEnumA *>(hList);
}


HRESULT 
DblNulTermListEnumW_Next(
    HDBLNULTERMLISTENUMW hEnum, 
    LPCWSTR *ppszW
    )
{
    CDblNulTermListEnumW *pEnum = static_cast<CDblNulTermListEnumW *>(hEnum);
    return pEnum->Next(ppszW);
}


HRESULT 
DblNulTermListEnumA_Next(
    HDBLNULTERMLISTENUMA hEnum, 
    LPCSTR *ppszA
    )
{
    CDblNulTermListEnumA *pEnum = static_cast<CDblNulTermListEnumA *>(hEnum);
    return pEnum->Next(ppszA);
}


} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\cpsetup.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// cpsetup.cpp
//      Explorer Font Folder extension routines
//      This file holds all the code for reading setup.inf
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//      2/24/96 [BrianAu]
//          Replaced INF parsing code with Win32 Setup API.
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================
#include "priv.h"
#include "globals.h"
#include "cpanel.h"   // Needs "extern" declaration for exports.

#include "setupapi.h"

//
// I have re-worked this code so that the original INF parsing code
// has been replaced with calls to the Win32 Setup API.  This not
// only greatly simplifies the code but also shields the font folder
// from any ANSI/DBCS/UNICODE parsing issues as well as compressed file
// issues.
//
// You'll notice that the Setup API extracts fields from the INF section
// and we paste them back together to form a key=value string.  This is
// because the calling code previously used GetPrivateProfileSection() which
// returned information as key=value<nul>key=value<nul>key=value<nul><nul>.
// The function ReadSetupInfSection assembles the required information into
// the same format so that the calling code remains unchanged.
//
// [BrianAu 2/24/96]

//
// ReadSetupInfFieldKey
//
// Reads the key name from an Inf key=value pair.
//
// pContext - Pointer to Setup Inf Line context.
// pszBuf   - Pointer to destination buffer.
// cchBuf   - Size of destination buffer in characters.
//
// If destination buffer is not large enough for the name, function returns
// the number of characters required.  Otherwise, the number of characters
// read is returned.
//
DWORD ReadSetupInfFieldKey(INFCONTEXT *pContext, LPTSTR pszBuf, DWORD cchBuf)
{
    DWORD cchRequired = 0;

    if (!SetupGetStringField(pContext,
                             0,                  // Get key name
                             pszBuf,
                             cchBuf,
                             &cchRequired))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            cchRequired = 0;
    }
    return cchRequired;
}


//
// ReadSetupInfFieldText
//
// Reads the value text from an Inf key=value pair.
//
// pContext - Pointer to Setup Inf Line context.
// pszBuf   - Pointer to destination buffer.
// cchBuf   - Size of destination buffer in characters.
//
// If destination buffer is not large enough for text, function returns
// the number of characters required.  Otherwise, the number of characters
// read is returned.
//
DWORD ReadSetupInfFieldText(INFCONTEXT *pContext, LPTSTR pszBuf, DWORD cchBuf)
{
    DWORD cchRequired = 0;


    if (!SetupGetLineText(pContext,
                          NULL,
                          NULL,
                          NULL,
                          pszBuf,
                          cchBuf,
                          &cchRequired))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            cchRequired = 0;
    }

    return cchRequired;
}



//
// ReadSetupInfSection
//
// pszInfPath - Name of INF file to read.
// pszSection - Name of INF file section to read.
// ppszItems  - Address of pointer to receive address of
//              buffer containing INF items.  If *ppszItems
//              is non-null, the addressed buffer contains items read from
//              section in INF.  Each item is nul-terminated with a double
//              nul terminating the entire list.  The caller is responsible for
//              freeing this buffer with LocalFree( ).
//
// Returns: Number of characters read from INF section.  Count includes nul
//          separators and double-nul terminator.
//          0 = Section not found or section empty or couldn't allocate buffer.
//              *ppszItems will be NULL.
//
// The information returned through *ppszItems is in the format:
//
//      key=value<nul>key=value<nul>key=value<nul><nul>
//
DWORD ReadSetupInfSection( LPTSTR pszInfPath, LPTSTR pszSection, LPTSTR *ppszItems )
{
    DWORD cchTotalRead = 0;

    //
    // Input pointers must be non-NULL.
    //
    if (NULL != pszInfPath && NULL != pszSection && NULL != ppszItems)
    {
        HANDLE hInf = INVALID_HANDLE_VALUE;

        //
        // Initialize caller's buffer pointer.
        //
        *ppszItems = NULL;

        hInf = SetupOpenInfFile(pszInfPath,         // Path to inf file.
                                NULL,               // Allow any inf type.
                                INF_STYLE_OLDNT,    // Old-style text format.
                                NULL);              // Don't care where error happens.

        if (INVALID_HANDLE_VALUE != hInf)
        {
            INFCONTEXT FirstLineContext;            // Context for first line in sect.
            INFCONTEXT ScanningContext;             // Used while scanning.
            INFCONTEXT *pContext        = NULL;     // The one we're using.
            LPTSTR     pszLines         = NULL;     // Buffer for sections.
            DWORD      cchTotalRequired = 0;        // Bytes reqd for section.

            if (SetupFindFirstLine(hInf,         
                                   pszSection,      // Section name.
                                   NULL,            // No key.  Find first line.
                                   &FirstLineContext))
            {
                //
                // Make a copy of context so we can re-use the original later.
                // Start using the copy.
                //
                CopyMemory(&ScanningContext, &FirstLineContext, sizeof(ScanningContext));
                pContext = &ScanningContext;

                //
                // Find how large buffer needs to be to hold section text.
                // The value returned by each of these ReadSetupXXXXX calls 
                // includes a terminating nul character.
                //
                do
                {
                    cchTotalRequired += ReadSetupInfFieldKey(pContext,
                                                             NULL,
                                                             0);
                    cchTotalRequired += ReadSetupInfFieldText(pContext,
                                                              NULL,
                                                              0);
                }
                while(SetupFindNextLine(pContext, pContext));

                cchTotalRequired++;  // For terminating double nul.

                //
                // Allocate the buffer.
                //
                pszLines = (LPTSTR)LocalAlloc(LPTR, cchTotalRequired * sizeof(TCHAR));
                if (NULL != pszLines)
                {
                    LPTSTR pszWrite     = pszLines;
                    DWORD  cchAvailable = cchTotalRequired;
                    DWORD  cchThisPart  = 0;        

                    //
                    // We can use the first line context now.
                    // Doesn't matter if we alter it.
                    //
                    pContext = &FirstLineContext;

                    do
                    {
                        cchThisPart = ReadSetupInfFieldKey(pContext,
                                                           pszWrite,
                                                           cchAvailable);

                        if (cchThisPart <= cchAvailable)
                        {
                            cchAvailable -= cchThisPart;  // Decr avail counter.
                            pszWrite     += cchThisPart;  // Adv write pointer.
                            *(pszWrite - 1) = TEXT('=');  // Replace nul with '='
                            cchTotalRead += cchThisPart;  // Adv total counter.
                        }
                        else
                        {
                            //
                            // Something went wrong and we tried to overflow
                            // buffer.  This shouldn't happen.
                            //
                            cchTotalRead = 0;
                            goto InfReadError;
                        }

                        cchThisPart = ReadSetupInfFieldText(pContext,
                                                            pszWrite,
                                                            cchAvailable);

                        if (cchThisPart <= cchAvailable)
                        {
                            cchAvailable -= cchThisPart;  // Decr avail counter.
                            pszWrite     += cchThisPart;  // Adv write pointer.
                            cchTotalRead += cchThisPart;  // Adv total counter.
                        }
                        else
                        {
                            //
                            // Something went wrong and we tried to overflow
                            // buffer.  This shouldn't happen.
                            //
                            cchTotalRead = 0;
                            goto InfReadError;
                        }
                    }
                    while(SetupFindNextLine(pContext, pContext));

                    if (cchAvailable > 0)
                    {
                        //
                        // SUCCESS! Section read without errors.
                        // Return address of buffer to caller.
                        // By allocating buffer with LPTR, text is already 
                        // double-nul terminated.
                        //
                        *ppszItems = pszLines;   
                    }
                    else
                    {
                        //
                        // Something went wrong and we tried to overflow
                        // buffer.  This shouldn't happen.
                        //
                        cchTotalRead = 0;
                    }
                }
            }

InfReadError:

            SetupCloseInfFile(hInf);
        }
    }
    return cchTotalRead;
}




//
// ReadSetupInfCB
//
// pszSection   - Name of INF section without surrounding [].
// lpfnNextLine - Address of callback function called for each item in the section.
// pData        - Data item contains info stored in dialog listbox.
//
// Returns:  0 = Success.
//          -1 = Item callback failed.
//          INSTALL+14 = No INF section found.
//
WORD ReadSetupInfCB(LPTSTR pszInfPath,
                    LPTSTR pszSection,
                    WORD (*lpfnNextLine)(LPTSTR, LPVOID),
                    LPVOID pData)
{
    LPTSTR lpBuffer  = NULL;
    WORD   wResult   = INSTALL+14;       // This is the "no file" message

    //
    // Read in the section from the INF file.
    //
    ReadSetupInfSection(pszInfPath, pszSection, &lpBuffer);

    if (NULL != lpBuffer)
    {
        //
        // Got a buffer full of section text.
        // Each item is nul-terminated with a double nul
        // terminating the entire set of items.
        // Now iterate over the set, calling the callback function
        // for each item.
        //
        LPTSTR pInfEntry = lpBuffer;
        wResult = 0;

        while(TEXT('\0') != *pInfEntry)
        {
            wResult = (*lpfnNextLine)(pInfEntry, pData);
            if ((-1) == wResult)
                break;

            pInfEntry += lstrlen(pInfEntry) + 1;
        }
        LocalFree(lpBuffer);
    }
    return wResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\extinit.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// extinit.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include "extinit.h"
#include "resource.h"
#include "ui.h"
#include "cpanel.h"
#include "fontcl.h"
#include "fontview.h"

#include "dbutl.h"


//------------------------------------------------------------------------


//------------------------------------------------------------------------
CShellExtInit::CShellExtInit( )
   :  m_cRef( 0 ),
      m_poData( NULL )
{
    g_cRefThisDll++;
}

CShellExtInit::~CShellExtInit( )
{
    if( m_poData )
    {
        m_poData->Release( );
        m_poData = NULL;
    }

    g_cRefThisDll--;
}

BOOL CShellExtInit::bInit( )
{
    return TRUE;
}

STDMETHODIMP CShellExtInit::QueryInterface(REFIID riid, void  **ppv)
{
    DEBUGMSG( ( DM_NOEOL | DM_TRACE1,
              TEXT( "FONTEXT: CShellExtInit::QueryInterface called for: " ) ) );

    static const QITAB qit[] = {
        QITABENT(CShellExtInit, IShellExtInit),
        QITABENT(CShellExtInit, IContextMenu),
        QITABENT(CShellExtInit, IShellPropSheetExt),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG ) CShellExtInit::AddRef( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CShellExtInit::AddRef called: %d->%d references" ),
              m_cRef, m_cRef + 1 ) );

    return( ++m_cRef );
}


STDMETHODIMP_(ULONG) CShellExtInit::Release( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CShellExtInit::Release called: %d->%d references" ),
              m_cRef, m_cRef - 1 ) );

    ULONG retval;

    retval = --m_cRef;

    if( !retval ) delete this;

    return( retval );
}


STDMETHODIMP CShellExtInit::Initialize( LPCITEMIDLIST pidlFolder,
                                        LPDATAOBJECT lpdobj,
                                        HKEY hkeyProgID )
{
    if( m_poData )
        m_poData->Release( );

    m_poData = lpdobj;
    m_poData->AddRef( );

    return NOERROR;
}


STDMETHODIMP CShellExtInit::QueryContextMenu( HMENU hmenu,
                                              UINT indexMenu,
                                              UINT idCmdFirst,
                                              UINT idCmdLast,
                                              UINT uFlags )
{
    UINT  nCmd = idCmdFirst;
    TCHAR  szCmd[ 64 ];


    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: QueryContextMenu called with following:" ) ) );
    DEBUGMSG( (DM_TRACE2, TEXT( "         indexMenu:  %d" ), indexMenu ) );
    DEBUGMSG( (DM_TRACE2, TEXT( "         idCmdFirst: %d" ), idCmdFirst ) );
    DEBUGMSG( (DM_TRACE2, TEXT( "         uFlags:     %d" ), uFlags ) );

    LoadString( g_hInst, IDS_EXT_INSTALL, szCmd, ARRAYSIZE( szCmd ) );

    InsertMenu( hmenu, indexMenu++, MF_STRING|MF_BYPOSITION, nCmd++, szCmd );

    return (HRESULT)( 1 );
}

STDMETHODIMP CShellExtInit::InvokeCommand( LPCMINVOKECOMMANDINFO lpici )
{
   HRESULT hr   = E_INVALIDARG;
   UINT    nCmd = LOWORD( lpici->lpVerb );

   //
   // We only have one command: Install
   //

   if( !nCmd && m_poData )
   {
        //
        // The fact that we got here is success. The install may or may not work.
        //
        hr = NOERROR;

        InstallDataObject( m_poData, DROPEFFECT_COPY, lpici->hwnd );
   }

   return hr;
}

STDMETHODIMP CShellExtInit::GetCommandString( UINT_PTR idCmd,
                                              UINT    uFlags,
                                              UINT   *pwReserved,
                                              LPSTR   pszName,
                                              UINT    cchMax )
{
    HRESULT  hr = E_INVALIDARG;
    UINT  nID;

    if( !idCmd )
    {
        if( uFlags & GCS_HELPTEXT )
            nID = IDS_EXT_INSTALL_HELP;
        else
            nID = IDS_EXT_INSTALL;

        if( uFlags & GCS_UNICODE )
            if( LoadStringW( g_hInst, nID, (LPWSTR) pszName, cchMax ) )
                hr = S_OK;
            else
                hr = ResultFromLastError();
        else
            if( LoadStringA( g_hInst, nID, (LPSTR) pszName, cchMax ) )
                hr = S_OK;
            else
                hr = ResultFromLastError();
    }

    return hr;
}


//---------------------------------------------------------------------------
//
// FSPage_InitDialog
//
//  This function is called when the dialog procedure receives the
// WM_INITDIALOG message. In this sample code, we simply fill the
// listbox with the list of fully qualified paths to the file and
// directories.
//
//---------------------------------------------------------------------------

void FSPage_InitDialog( HWND hDlg, LPPROPSHEETPAGE psp )
{
    LPDATAOBJECT   poData = (LPDATAOBJECT)psp->lParam;

    FORMATETC fmte = {
                 CF_HDROP,
                 (DVTARGETDEVICE FAR *)NULL,
                 DVASPECT_CONTENT,
                 -1,
                 TYMED_HGLOBAL };

    STGMEDIUM medium;

    HRESULT hres = poData->GetData( &fmte, &medium );


    if( SUCCEEDED( hres ) )
    {
        HDROP        hDrop = (HDROP) medium.hGlobal;
        FONTDESCINFO fdi;
        TCHAR        szAll[ 512 ];

        FONTDESCINFO_Init(&fdi);
        fdi.dwFlags = FDI_ALL | FDI_VTC;

        ::DragQueryFile( hDrop, 0, fdi.szFile, ARRAYSIZE( fdi.szFile ) );

        if( bIsTrueType( &fdi ) || bIsNewExe( &fdi ) )
        {
            SetDlgItemText( hDlg, stc1, fdi.szDesc );

            //
            // Get the copyright info and put it in the edit control, edt1.
            //

            StringCchPrintf( szAll, ARRAYSIZE(szAll), TEXT( "%s\r\n\r\n%s\r\n\r\n%s" ), fdi.lpszVersion,
                      fdi.lpszTrademark, fdi.lpszCopyright );

            SetDlgItemText( hDlg, edt1, szAll );
        }
        FONTDESCINFO_Destroy(&fdi);

        ReleaseStgMedium( &medium );
    }
}


//---------------------------------------------------------------------------
//
// FSPage_DlgProc
//
//  The dialog procedure for the TEXT( "FSPage" ) property sheet page.
//
//---------------------------------------------------------------------------

INT_PTR CALLBACK FSPage_DlgProc( HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam )
{
    LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)GetWindowLongPtr( hDlg, DWLP_USER );

    switch( uMessage )
    {
    //
    //  When the shell creates a dialog box for a property sheet page,
    // it passes the pointer to the PROPSHEETPAGE data structure as
    // lParam. The dialog procedures of extensions typically store it
    // in the DWL_USER of the dialog box window.
    //
    case WM_INITDIALOG:
        SetWindowLongPtr( hDlg, DWLP_USER, lParam );

        psp = (LPPROPSHEETPAGE)lParam;

        FSPage_InitDialog( hDlg, psp );

        break;

    case WM_DESTROY:
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY:
        switch( ( (NMHDR FAR *)lParam)->code )
        {
        case PSN_SETACTIVE:
           break;

        case PSN_APPLY:
           break;

        default:
           break;
        }
        break;

    default:
        return( FALSE );
    }

    return( TRUE );
}


STDMETHODIMP CShellExtInit::AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage,
                                      LPARAM lParam )
{
    HRESULT  hr = NOERROR;      // ResultFromScode( E_INVALIDARG );

    if( m_poData )
    {
        //
        // Get an HDROP, if possible.
        //
        FORMATETC fmte = {
                       CF_HDROP,
                       (DVTARGETDEVICE FAR *)NULL,
                       DVASPECT_CONTENT,
                       -1,
                       TYMED_HGLOBAL };

        STGMEDIUM medium;

        hr = m_poData->GetData( &fmte, &medium );

        if( SUCCEEDED( hr ) )
        {
            //
            // Only add a page if there is exactly one font selected.
            //

            HDROP hDrop = (HDROP) medium.hGlobal;
            UINT cnt = ::DragQueryFile( hDrop, (UINT)-1, NULL, 0 );

            if( cnt == 1 )
            {
                PROPSHEETPAGE  psp;
                HPROPSHEETPAGE hpage;

                psp.dwSize      = sizeof( psp );        // no extra data.
                psp.dwFlags     = PSP_USEREFPARENT;
                psp.hInstance   = g_hInst;
                psp.pszTemplate = MAKEINTRESOURCE( ID_DLG_PROPPAGE );
                psp.pfnDlgProc  = FSPage_DlgProc;
                psp.pcRefParent = (UINT *)&g_cRefThisDll;
                psp.lParam      = (LPARAM)m_poData;

                hpage = CreatePropertySheetPage( &psp );

                if( hpage )
                {
                    if( !lpfnAddPage( hpage, lParam ) )
                        DestroyPropertySheetPage( hpage );
                }
            }

            ReleaseStgMedium( &medium );
        }
    }

    return hr;
}


STDMETHODIMP CShellExtInit::ReplacePage( UINT uPageID,
                                         LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                         LPARAM lParam )
{
    return NOERROR;
}

const TCHAR c_szFileNameMap[] = CFSTR_FILENAMEMAP;       // "FileNameMap"

VOID InstallDataObject( LPDATAOBJECT pdobj,
                        DWORD dwEffect,
                        HWND hWnd,
                        CFontView * poView)
{
    //
    // Get an HDROP, if possible.
    //

    FORMATETC fmte = {
                    CF_HDROP,
                    (DVTARGETDEVICE FAR *)NULL,
                    DVASPECT_CONTENT,
                    -1,
                    TYMED_HGLOBAL };

    STGMEDIUM medium;

    HRESULT hres = pdobj->GetData( &fmte, &medium );

    if( SUCCEEDED( hres ) )
    {
        WaitCursor     cWaiter;           // Starts and stops busy cursor
        STGMEDIUM      mediumNameMap;
        HDROP          hDrop = (HDROP) medium.hGlobal;
        BOOL           bAdded = FALSE;
        FullPathName_t szFile;

        UINT   cfFileNameMap = RegisterClipboardFormat( c_szFileNameMap );
        LPTSTR lpszNameMap   = NULL;

        fmte.cfFormat = (CLIPFORMAT) cfFileNameMap;

        if( pdobj->GetData( &fmte, &mediumNameMap ) == S_OK )
        {
            lpszNameMap = (LPTSTR) GlobalLock( mediumNameMap.hGlobal );
        }

        UINT cnt = ::DragQueryFile( hDrop, (UINT) -1, NULL, 0 );

        for( UINT i = 0; i < cnt; )
        {
            ::DragQueryFile( hDrop, i, szFile, ARRAYSIZE( szFile ) );

            if( poView )
                poView->StatusPush( szFile );

            switch( CPDropInstall( poView->GetViewWindow(),
                                   szFile,
                                   ARRAYSIZE(szFile),
                                   dwEffect,
                                   lpszNameMap,
                                   (int) (cnt - ++i) ) )
            {
            case CPDI_SUCCESS:
                bAdded = TRUE;
                break;

            case CPDI_FAIL:
                break;

            case CPDI_CANCEL:
                i = cnt;
                break;
            }

            if( lpszNameMap && *lpszNameMap )
            {
                lpszNameMap += lstrlen( lpszNameMap ) + 1;
            }
        }

        poView->StatusClear( );

        if( lpszNameMap )
        {
            GlobalUnlock( mediumNameMap.hGlobal );
            ReleaseStgMedium( &mediumNameMap );
        }


        if( bAdded )
        {
          vCPWinIniFontChange( );

        }

        ReleaseStgMedium( &medium );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\extricon.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: extricon.cpp

    Description: Contains implementation of IExtractIcon for the font folder.
        This code provides icon identification for both TrueType and OpenType
        font files.  The logic used is as follows:
        
            TrueType(1)  DSIG?   CFF?    Icon
            ------------ ------- ------- -----------
            yes          no      no      TT
            yes          no      yes     OTp
            yes          yes     no      OTt
            yes          yes     yes     OTp

        (1) Files must contain required TrueType tables to be considered
            a TrueType font file.

        This icon handler is used by both the shell and the font folder
        to display TrueType and OpenType font icons.  It is designed to be
        easily extensible if support for dynamic icon identification is
        required in other fonts.

        Classes (indentation denotes inheritance):

            CFontIconHandler
            IconHandler
                TrueTypeIconHandler
               

        NOTE:  The design is sort of in a state of limbo right now.  Originally
               the idea was to support two types of OpenType icons along with
               the conventional TrueType and raster font icons.  The OpenType
               icons were OTt and OTp with the 't' and 'p' meaning "TrueType"
               and "PostScript".  Later we decided to only show the icons as
               "OT" without the subscript 't' or 'p'.  The code still distinguishes
               the difference but we just use the same "OT" icon for both the
               OTt and OTp conditions.  Make sense?  Anyway, This OTt and OTp
               stuff may come back at a later date (GDI guys haven't decided)
               so I'm leaving that code in place. [brianau - 4/7/98]

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/13/97    Initial creation.                                    BrianAu
    04/08/98    Removed OpenTypeIconHandler and folded it into       BrianAu
                TrueTypeIconHandler.  There's no need for the 
                separation.  Also added detection of "required"
                TrueType tables.
    03/04/99    Added explicit support for IExtractIconW and         BrianAu
                IExtractIconA.  Was previously only supporting
                IExtractIconW implicitely through UNICODE build.
*/
///////////////////////////////////////////////////////////////////////////////
#include "priv.h"

#include "dbutl.h"
#include "globals.h"
#include "fontext.h"
#include "resource.h"
#include "extricon.h"


//
// TrueType/OpenType table tag values.
// Note that MAKETAG macro is defined in winuserp.h
//
static const DWORD TAG_DSIGTABLE = MAKETAG('D','S','I','G');
static const DWORD TAG_CFFTABLE  = MAKETAG('C','F','F',' ');
//
// Required TrueType tables.  This is per the TrueType
// specification at http://www.microsoft.com/typography/tt/ttf_spec
//
static const DWORD TAG_NAMETABLE = MAKETAG('n','a','m','e');
static const DWORD TAG_CMAPTABLE = MAKETAG('c','m','a','p');
static const DWORD TAG_HEADTABLE = MAKETAG('h','e','a','d');
static const DWORD TAG_HHEATABLE = MAKETAG('h','h','e','a');
static const DWORD TAG_HMTXTABLE = MAKETAG('h','m','t','x');
static const DWORD TAG_OS2TABLE  = MAKETAG('O','S','/','2');
static const DWORD TAG_POSTTABLE = MAKETAG('p','o','s','t');
static const DWORD TAG_GLYFTABLE = MAKETAG('g','l','y','f');
static const DWORD TAG_LOCATABLE = MAKETAG('l','o','c','a');
static const DWORD TAG_MAXPTABLE = MAKETAG('m','a','x','p');
//
// "ttcf" isn't really a table.  It's a tag found at the front of 
// a TTC (TrueType Collection) font file.  Treating it like a table
// tag fits well with this scheme.
//
static const DWORD TAG_TTCFILE   = MAKETAG('t','t','c','f');

//
// Helper to swap bytes in a word.
//
inline WORD
SWAP2B(WORD x) 
{
    return ((x << 8) | HIBYTE(x));
}

//
// Template of a TrueType file header.
//
struct TrueTypeFileHdr {
  DWORD dwVersion;
  WORD  uNumTables;
  WORD  uSearchRange;
  WORD  uEntrySelector;
  WORD  uRangeShift;
};

//
// Template of a TrueType table header.
//
struct TrueTypeTableHdr {
  DWORD dwTag;
  DWORD dwCheckSum;
  DWORD dwOffset;
  DWORD dwLength;
};


//-----------------------------------------------------------------------------
// CFontIconHandler
//-----------------------------------------------------------------------------
//
// Path to FONTEXT.DLL.  Only one instance required.
//
TCHAR CFontIconHandler::m_szFontExtDll[];

//
// Initialize the font icon handler object.  This is the object created
// to implement IExtractIcon.  Internally, it creates a type-specific
// handler to handle font file type-specific issues.
//
CFontIconHandler::CFontIconHandler(
    VOID
    ) : m_cRef(0),
        m_pHandler(NULL)
{
    m_szFileName[0] = TEXT('\0');
    //
    // Save the path to FONTEXT.DLL to return in GetIconLocation.
    // This is a static string that should only be initialized once.
    //
    if (TEXT('\0') == m_szFontExtDll[0])
    {
        HINSTANCE hModule = GetModuleHandle(TEXT("FONTEXT.DLL"));
        if (NULL != hModule)
        {
            GetModuleFileName(hModule, m_szFontExtDll, ARRAYSIZE(m_szFontExtDll));
        }
    }

    //
    // Keep DLL in memory as long as this object needs it.
    // Must be done at the end of the ctor in case something in the ctor throws
    // an exception.  The dtor is not called on a partially constructed
    // object.
    //
    InterlockedIncrement(&g_cRefThisDll);
}

CFontIconHandler::~CFontIconHandler(
    VOID
    )
{
    delete m_pHandler;
    //
    // DLL no longer required for this object.
    //
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}


STDMETHODIMP 
CFontIconHandler::QueryInterface(
    REFIID riid, 
    void **ppv
    )
{
    static const QITAB qit[] = {
        QITABENT(CFontIconHandler, IExtractIconW),
        QITABENT(CFontIconHandler, IExtractIconA),
        QITABENT(CFontIconHandler, IPersistFile),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDMETHODIMP_(ULONG) 
CFontIconHandler::AddRef(
    VOID
    )
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) 
CFontIconHandler::Release(
    VOID
    )
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {   
        delete this;
    }
    return cRef;
}


//
// Implementation of IPersist::GetClassID
//
STDMETHODIMP 
CFontIconHandler::GetClassID(
    CLSID *pClassID
    )
{
    *pClassID = CLSID_FontExt;
    return S_OK;
}


//
// Implementation of IPersistFile::IsDirty
//
STDMETHODIMP 
CFontIconHandler::IsDirty(
    VOID
    )
{
    return E_NOTIMPL;
}

//
//
// Implementation of IPersistFile::Load
//
// This is called by the shell before IExtractIcon::GetIconLocation.
// It gives the extension a chance to save the file name.
//
STDMETHODIMP 
CFontIconHandler::Load(
    LPCOLESTR pszFileName,
    DWORD dwMode            // unused.
    )
{
    //
    // Save the name of the font file so that the IExtractIcon
    // functions know what file to work with.
    //
    HRESULT hr = StringCchCopy(m_szFileName, ARRAYSIZE(m_szFileName), pszFileName);
    if (SUCCEEDED(hr))
    {
        //
        // Delete any existing type-specific handler.
        //
        delete m_pHandler;
        m_pHandler = NULL;
     
        //
        // Create a new type-specific handler.
        //
        hr = IconHandler::Create(m_szFileName, &m_pHandler);
    }

    return hr;
}


//
// Implementation of IPersistFile::Save
//
STDMETHODIMP 
CFontIconHandler::Save(
    LPCOLESTR pszFileName,
    BOOL fRemember
    )
{
    return E_NOTIMPL;
}


//
// Implementation of IPersistFile::SaveCompleted
//
STDMETHODIMP 
CFontIconHandler::SaveCompleted(
    LPCOLESTR pszFileName
    )
{
    return E_NOTIMPL;
}


//
// Implementation of IPersistFile::GetCurFile
//
STDMETHODIMP 
CFontIconHandler::GetCurFile(
    LPOLESTR *ppszFileName
    )
{
    return E_NOTIMPL;
}


//
// Implementation of IExtractIconW::Extract
//
STDMETHODIMP 
CFontIconHandler::Extract(
    LPCWSTR pszFileNameW,   // unused
    UINT niconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize          // unused
    )
{
    HICON hiconLarge;
    HICON hiconSmall;

    HRESULT hr = GetIcons(niconIndex, &hiconLarge, &hiconSmall);
    if (SUCCEEDED(hr))
    {
        if (NULL != phiconLarge)
            *phiconLarge = CopyIcon(hiconLarge);
        if (NULL != phiconSmall)
            *phiconSmall = CopyIcon(hiconSmall);
    }

    return SUCCEEDED(hr) ? NO_ERROR     // Use these icons.
                         : S_FALSE;     // Caller must load icons.
}



//
// Implementation of IExtractIconW::GetIconLocation
//
STDMETHODIMP 
CFontIconHandler::GetIconLocation(
    UINT uFlags,        // unused
    LPWSTR pszIconFileW,
    UINT cchMax,
    int *piIndex,
    UINT *pwFlags
    )
{
    HRESULT hr      = S_FALSE;
    INT iIconIndex  = GetIconIndex();

    if (-1 != iIconIndex)
    {
        //
        // This is a special case for internal font folder use.
        // Normally, the shell always gives us a pointer to a destination
        // for the path to FONTEXT.DLL.  Since we also use this icon
        // handler in the font folder itself, that code only needs to know
        // the icon index (it already knows the icon is in fontext.dll).
        // This test allows the font folder code to pass NULL and skip
        // the unnecessary string copy.
        // 
        if (NULL != pszIconFileW)
        {
            hr = StringCchCopyW(pszIconFileW, cchMax, m_szFontExtDll);
        }
        if (SUCCEEDED(hr))
        {
            *pwFlags = GIL_PERINSTANCE;
            *piIndex = iIconIndex;
            hr       = S_OK;
        }
    }

    return hr;
}


//
// Implementation of IExtractIconA::Extract
//
STDMETHODIMP 
CFontIconHandler::Extract(
    LPCSTR pszFileNameA,
    UINT niconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize          // unused
    )
{
    WCHAR szFileNameW[MAX_PATH * 2] = {0};
    MultiByteToWideChar(CP_ACP,
                        0,
                        pszFileNameA,
                        -1,
                        szFileNameW,
                        ARRAYSIZE(szFileNameW));
                            
    return Extract(szFileNameW, niconIndex, phiconLarge, phiconSmall, nIconSize);
}



//
// Implementation of IExtractIconA::GetIconLocation
//
STDMETHODIMP 
CFontIconHandler::GetIconLocation(
    UINT uFlags,        // unused
    LPSTR pszIconFileA,
    UINT cchMax,
    int *piIndex,
    UINT *pwFlags
    )
{
    //
    // Call the wide-char version then convert the result to ansi.
    //
    WCHAR szIconFileW[MAX_PATH * 2] = {0};
    HRESULT hr = GetIconLocation(uFlags, 
                                 szIconFileW, 
                                 ARRAYSIZE(szIconFileW), 
                                 piIndex, 
                                 pwFlags);
    if (SUCCEEDED(hr))
    {
        WideCharToMultiByte(CP_ACP, 
                            0,
                            szIconFileW,
                            -1,
                            pszIconFileA,
                            cchMax,
                            NULL,
                            NULL);
    }
    return hr;
}


//
// Retrieve the icon index for the font file loaded in Load().
//
INT
CFontIconHandler::GetIconIndex(
    VOID
    )
{
    INT iIconIndex = -1;
    if (NULL != m_pHandler)
    {
        //
        // Call the type-specific icon handler to get the index.
        //
        iIconIndex = m_pHandler->GetIconIndex(m_szFileName);
    }
    return iIconIndex;
}


//
// Retrieve the icon handles for a given icon index.
//
HRESULT
CFontIconHandler::GetIcons(
    UINT iIconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall
    )
{
    HRESULT hr = E_FAIL;
    if (NULL != m_pHandler)
    {
        //
        // Call the type-specific icon handler to get the icons.
        //
        hr = m_pHandler->GetIcons(iIconIndex, phiconLarge, phiconSmall);
    }
    return hr;
}


//
// Create a new type-specific icon handler based on the file name extension.
//
HRESULT
IconHandler::Create(
    LPCTSTR pszFile,
    IconHandler **ppHandler
    )
{
    HRESULT hr = E_FAIL;
    
    *ppHandler = NULL;
    
    LPCTSTR pszFileExt = PathFindExtension(pszFile);
    if (TEXT('.') == *pszFileExt)
    {
        //
        // Do some quick checks of the first character in the extension before
        // making a call out to lstrcmpi.  Should help perf just a bit.
        //
        bool bCreateHandler = false;
        pszFileExt++;
        switch(*pszFileExt)
        {
            case TEXT('t'):
            case TEXT('T'):
                bCreateHandler = (0 == lstrcmpi(pszFileExt, TEXT("TTF")) ||
                                  0 == lstrcmpi(pszFileExt, TEXT("TTC")));
                break;

            case TEXT('O'):
            case TEXT('o'):
                bCreateHandler = (0 == lstrcmpi(pszFileExt, TEXT("OTF")));
                break;

            default:
                break;
        }
        if (bCreateHandler)
        {
            //
            // Filename has either TTF, TTC or OTF extension.
            //
            DWORD dwTables = 0;
            if (TrueTypeIconHandler::GetFileTables(pszFile, &dwTables))
            {
                //
                // Only require the "open type" tables which are a proper subset
                // of the required "true type" tables.
                //
                DWORD dwReqdTables = TrueTypeIconHandler::RequiredOpenTypeTables();
                if (dwReqdTables == (dwTables & dwReqdTables))
                {
                    //
                    // File is a valid TrueType file.
                    //
                    *ppHandler = new TrueTypeIconHandler(dwTables);
                    if (NULL != *ppHandler)
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }
    //
    // If new font types are added later, here's where you'll create
    // the handler.
    //

    return hr;
}

//-----------------------------------------------------------------------------
// TrueTypeIconHandler
//-----------------------------------------------------------------------------
//
// Initialize the OpenType icon handler.
//
TrueTypeIconHandler::TrueTypeIconHandler(
    DWORD dwTables
    ) : m_dwTables(dwTables)
{
    ZeroMemory(m_rghIcons, sizeof(m_rghIcons));
}


TrueTypeIconHandler::~TrueTypeIconHandler(
    void
    )
{
    for (int i = 0; i < ARRAYSIZE(m_rghIcons); i++)
    {
        if (NULL != m_rghIcons[i])
            DestroyIcon(m_rghIcons[i]);
    }
}


//
// Get the icon index for icons to represent a particular TrueType font
// file.  This is where all of the icon identification logic is.
//
INT 
TrueTypeIconHandler::GetIconIndex(
    LPCTSTR pszFile
    )
{
    INT iIconIndex = IDI_TTF;
    if (TABLE_CFF & m_dwTables)
    {
        iIconIndex = IDI_OTFp;
    }
    else if (TABLE_DSIG & m_dwTables)
    {
        iIconIndex = IDI_OTFt;
    }
    else if (TABLE_TTCF & m_dwTables)
    {
        iIconIndex = IDI_TTC;
    }
    return iIconIndex;
}


//
// Retrieve the large and small icons based on the icon index (ID).
//
HRESULT
TrueTypeIconHandler::GetIcons(
    UINT iIconIndex, 
    HICON *phiconLarge, 
    HICON *phiconSmall
    )
{
    HRESULT hr = NO_ERROR;
    int iSmall = -1;
    int iLarge = -1;

    switch(iIconIndex)
    {
        case IDI_TTF:
            iLarge = iICON_LARGE_TT;
            iSmall = iICON_SMALL_TT;
            break;

        case IDI_OTFt:
            iLarge = iICON_LARGE_OTt;
            iSmall = iICON_SMALL_OTt;
            break;

        case IDI_OTFp:
            iLarge = iICON_LARGE_OTp;
            iSmall = iICON_SMALL_OTp;
            break;

        case IDI_TTC:
            iLarge = iICON_LARGE_TTC;
            iSmall = iICON_SMALL_TTC;
            break;

        default:
            hr = E_FAIL;
            break;
    }

    if (-1 != iLarge)
    {
        *phiconLarge = GetIcon(iLarge);
        *phiconSmall = GetIcon(iSmall);
    }

    return hr;
}


//
// Retrieve the icon's handle.  If the icon isn't yet loaded we 
// load it here.  Once it's loaded it stays loaded until the handler
// object is destroyed.  This way we only load icons on demand.
//
HICON
TrueTypeIconHandler::GetIcon(
    int iIcon
    )
{
    HICON hicon = NULL;

    if (0 <= iIcon && ARRAYSIZE(m_rghIcons) > iIcon)
    {
        if (NULL == m_rghIcons[iIcon])
        {
            //
            // Icon hasn't been loaded yet.  Load it.
            //
            // These must be kept in the same order as the iICON_XXXXX enumeration.
            //
            static const struct
            {
                UINT idIcon;
                int  cxcyIcon;

            } rgIconInfo[] = { { IDI_TTF,     32 }, // iICON_LARGE_TT
                               { IDI_TTF,     16 }, // iICON_SMALL_TT
                               { IDI_OTFt,    32 }, // iICON_LARGE_OTt
                               { IDI_OTFt,    16 }, // iICON_SMALL_OTt
                               { IDI_OTFp,    32 }, // iICON_LARGE_OTp
                               { IDI_OTFp,    16 }, // iICON_SMALL_OTp
                               { IDI_TTC,     32 }, // iICON_LARGE_TTC
                               { IDI_TTC,     16 }  // iICON_SMALL_TTC
                             };

            m_rghIcons[iIcon] = (HICON)LoadImage(g_hInst, 
                                     MAKEINTRESOURCE(rgIconInfo[iIcon].idIcon),
                                     IMAGE_ICON,
                                     rgIconInfo[iIcon].cxcyIcon,
                                     rgIconInfo[iIcon].cxcyIcon,
                                     0);
        }
        hicon = m_rghIcons[iIcon];
    }
    return hicon;
}



//
// Provide wrapper around ReadFileTables to handle any exceptions
// in the case of trying to read an invalid font file.
//
BOOL
TrueTypeIconHandler::GetFileTables(
    LPCTSTR pszFile,
    LPDWORD pfTables
    )
{
    BOOL bResult = FALSE;
    //
    // Assumes pszFile points to a TTF or OTF file name (fully qualified).
    //
    IconHandler::MappedFile file;
    if (SUCCEEDED(file.Open(pszFile)))
    {
        __try
        {
            bResult = ReadFileTables(file, pfTables);
        }
        __except(FilterReadFileTablesException(GetExceptionCode()))
        {
            //
            // Something in reading the font file caused an exception.
            // Probably opened a file that isn't really a font file and it
            // had a bogus table count number.  This can cause us to read 
            // beyond the file mapping.  If this happens, we just set the
            // flags value to 0 indicating that we didn't find any tables 
            // in the file.
            //
            *pfTables = 0;
            DEBUGMSG((DM_ERROR, 
                      TEXT("FONTEXT: Exception occurred reading file %s"), 
                      pszFile));
        }
    }
    return bResult;
}


//
// Determine the index (ID) of the icon for a given TrueType icon file.
// This can also be used by the OpenType handler since TrueType and OpenType
// font files have the same table format.
//
// NOTE: This code does not handle LZ-compressed files like other similar
//       code in the font folder.  The reason is that this code needs to 
//       interrogate only TTF and OTF files which are not compressed.  The
//       font folder must also deal with .TT_ (compressed) files that sometimes
//       come on distribution media.  This icon handler is not required to 
//       display special icons for .TT_ files.  The performance penalty 
//       incurred by using LZxxxxx functions instead of directly mapping
//       files into memory would be significant. [brianau - 6/13/97]
//
// ************************** IMPORTANT **************************
// This function can AV if it tries to read an invalid font file.
// Therefore it is necessary to enclose any call to this function
// in a __try/__except block.
//
BOOL
TrueTypeIconHandler::ReadFileTables(
    IconHandler::MappedFile& file,
    LPDWORD pfTables
    )
{
    *pfTables = 0;

    LPBYTE pbBase = file.Base();

    TrueTypeFileHdr  *pFileHdr  = (TrueTypeFileHdr *)pbBase;
    if (TAG_TTCFILE == pFileHdr->dwVersion)
    {
        //
        // This icon handler is only interested in what icon is required.
        // Since TTC files have only one icon we don't care about any of the
        // table information.  What we have is all we need.  So basically,
        // if the file has a TTC extension and 'ttcf' is the first 4 bytes
        // in the file, we'll display a TTC icon.
        //
        *pfTables |= (TABLE_TTCF | TrueTypeIconHandler::RequiredTrueTypeTables());
    }
    else
    {
        TrueTypeTableHdr *pTableHdr = (TrueTypeTableHdr *)(pbBase + sizeof(*pFileHdr));
        INT cTables                 = SWAP2B(pFileHdr->uNumTables);

        //
        // Do a sanity check on the table count.
        // This is the same check used in bValidateTrueType (pfiles.cpp).
        //
        if ((0x7FFFF / sizeof(TrueTypeTableHdr)) > cTables)
        {
            //
            // Scan the table headers looking for identifying table tags.
            //
            for (INT i = 0; i < cTables; i++, pTableHdr++)
            {
/*
                //
                // Uncomment this to see the tags for each table.
                //
                DEBUGMSG((DM_ERROR, TEXT("Table[%d] tag = 0x%08X \"%c%c%c%c\""), 
                       i, pTableHdr->dwTag,
                       pTableHdr->dwTag  & 0x000000FF,
                       (pTableHdr->dwTag & 0x0000FF00) >> 8,
                       (pTableHdr->dwTag & 0x00FF0000) >> 16,
                       (pTableHdr->dwTag & 0xFF000000) >> 24));
*/
                switch(pTableHdr->dwTag)
                {
                    case TAG_DSIGTABLE: *pfTables |= TABLE_DSIG; break;
                    case TAG_CFFTABLE:  *pfTables |= TABLE_CFF;  break;
                    case TAG_NAMETABLE: *pfTables |= TABLE_NAME; break;
                    case TAG_CMAPTABLE: *pfTables |= TABLE_CMAP; break;
                    case TAG_HEADTABLE: *pfTables |= TABLE_HEAD; break;
                    case TAG_HHEATABLE: *pfTables |= TABLE_HHEA; break;
                    case TAG_HMTXTABLE: *pfTables |= TABLE_HMTX; break;
                    case TAG_OS2TABLE:  *pfTables |= TABLE_OS2;  break;
                    case TAG_POSTTABLE: *pfTables |= TABLE_POST; break;
                    case TAG_GLYFTABLE: *pfTables |= TABLE_GLYF; break;
                    case TAG_LOCATABLE: *pfTables |= TABLE_LOCA; break;
                    case TAG_MAXPTABLE: *pfTables |= TABLE_MAXP; break;
                    default:
                        break;
                }
            }
        }
    }
    return (0 != *pfTables);
}


//
// ReadFileTable's response to an exception depends upon the exception
// For debugger-initiated exceptions, continue the search for a handler so
// that the debugger can handle the exception.
// For all others, execute the handler code.
//
INT
TrueTypeIconHandler::FilterReadFileTablesException(
    INT nException
    )
{
    DEBUGMSG((DM_ERROR, TEXT("FONTEXT: Exception Filter: nException = 0x%08X"), nException));
    if (STATUS_SINGLE_STEP == nException ||
        STATUS_BREAKPOINT == nException)
    {
        //
        // Exception generated by debugger.  
        //
        return EXCEPTION_CONTINUE_SEARCH;
    }
    else
    {
        //
        // Exception generated by processing the mapped file.
        //
        return EXCEPTION_EXECUTE_HANDLER;
    }
}


//-----------------------------------------------------------------------------
// IconHandler::MappedFile
//
// A simple encapsulation of opening a mapped file in memory.
// The file is opened with READ access only.
// Client calls Base() to retrieve the base pointer of the mapped file.
//-----------------------------------------------------------------------------
IconHandler::MappedFile::~MappedFile(
    VOID
    )
{
    Close();
}


//
// Close the file mapping and the file.
//
VOID
IconHandler::MappedFile::Close(
    VOID
    )
{
    if (NULL != m_pbBase)
    {
        UnmapViewOfFile(m_pbBase);
        m_pbBase = NULL;
    }
    if (INVALID_HANDLE_VALUE != m_hFileMapping)
    {
        CloseHandle(m_hFileMapping);
        m_hFileMapping = INVALID_HANDLE_VALUE;
    }
    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
}


//
// Open the file.  Caller retrieves the base pointer through the
// Base() member function.
//
HRESULT
IconHandler::MappedFile::Open(
    LPCTSTR pszFile
    )
{
    HRESULT hr = NO_ERROR;

    m_hFile = CreateFile(pszFile, 
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL);

    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        if ((m_hFileMapping = CreateFileMapping(m_hFile,
                                                NULL,
                                                PAGE_READONLY,
                                                0,
                                                0,
                                                NULL)) != NULL)
        {
            m_pbBase = (LPBYTE)MapViewOfFile(m_hFileMapping,
                                             FILE_MAP_READ,
                                             0,
                                             0,
                                             0);
            if (NULL == m_pbBase)
            {
                hr = ResultFromLastError();
                DEBUGMSG((DM_ERROR, 
                          TEXT("FONTEXT: Error 0x%08X mapping view of OTF file %s"), 
                          hr, pszFile));
            }
        }
        else
        {
            hr = ResultFromLastError();
            DEBUGMSG((DM_ERROR, 
                      TEXT("FONTEXT: Error 0x%08X creating mapping for OTF file %s"), 
                      hr, pszFile));
        }
    }
    else
    {
        hr = ResultFromLastError();
        DEBUGMSG((DM_ERROR, 
                  TEXT("FONTEXT: Error 0x%08X opening OTF file %s"), 
                  hr, pszFile));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\fontcl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fontcl.cpp
//      Explorer Font Folder extension routines.
//      module to handle classes defined in fontcl.h:
//      CFontClass and DirFilenameClass
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//   All routines for these classes are in this module, EXCEPT:
//   1) inline functions - in FONTCL.H of course
//
// $keywords: fontcl.cpp 1.7  4-May-94 5:24:41 PM$
//
//***************************************************************************
// $lgb$
// 1.0     7-Mar-94 eric Initial revision.
// 1.1     9-Mar-94 eric Background thread and g_hDBMutex
// 1.2     9-Mar-94 eric Added m_bFilledIn
// 1.3     7-Apr-94 eric Removed LoadLibrary on FOT files.
// 1.4     8-Apr-94 eric Added s_szFontsDir
// 1.5    13-Apr-94 eric Calling bFillIn appropriately
// 1.6    15-Apr-94 eric Rip control
// 1.7     4-May-94 build GetOTM changes
// $lge$
//***************************************************************************
//
//  Copyright (C) 1992-93 ElseWare Corporation. All rights reserved.
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include <sys/types.h>
#include <sys/stat.h>

#include "fontcl.h"
#include "fdir.h"
#include "fontdir.h"
#include "resource.h"

#include "dbutl.h"
#include "cpanel.h"
#include "fontman.h"

#include <shlobjp.h>


#ifdef __cplusplus
extern "C" {
#endif

//
// [stevecat]   This used to reside in "wingdip.h" (included with <winp.h>)
//  6/29/95     but I have taken it out because of C++ name-mangling problems
//              with that header file that are not going to be fixed because
//              this file is going to change significantly (according to
//              EricK) when we switch over to Kernel mode GDI/User.
//
//
//#include <stddef.h>     //  Needed for winp.h
//#include <winp.h>       //  For private GDI entry point:  GetFontResourceInfo
//

// Private Control Panel entry point to enumerate fonts by file.

#define GFRI_NUMFONTS       0L
#define GFRI_DESCRIPTION    1L
#define GFRI_LOGFONTS       2L
#define GFRI_ISTRUETYPE     3L
#define GFRI_TTFILENAME     4L
#define GFRI_ISREMOVED      5L
#define GFRI_FONTMETRICS    6L


#include <winfont.h> //Type1 PFM file offsets and reader macros.

extern BOOL WINAPI GetFontResourceInfoW( LPWSTR  lpPathname,
                                         LPDWORD lpBytes,
                                         LPVOID  lpBuffer,
                                         DWORD   iType );

#ifdef __cplusplus
}
#endif

#define  BYTESTOK(Len) ((Len + 1023) / 1024)   // Convert from bytes to K

BOOL bTTFFromFOT( LPTSTR pszFOTPath, LPTSTR pszTTF, size_t cchTTF )
{
    PATHNAME szTTFPath;
    DWORD cbTTFPath = sizeof(szTTFPath);

    BOOL bValid = GetFontResourceInfoW( pszFOTPath, &cbTTFPath, szTTFPath,
                                       GFRI_TTFILENAME );

    //
    //  We make sure there's a terminating null at the end of the path name.
    //  Then make up a full name.
    //
    if( bValid )
    {
        szTTFPath[ ARRAYSIZE(szTTFPath) - 1 ] = TEXT( '\0' );

        bValid = bMakeFQName( szTTFPath, pszTTF, cchTTF );
    }

    return bValid;

}


/***************************************************************************
 * FUNCTION:
 *
 * PURPOSE:  Load the full directory/path/filename into the given string.
 *              The full name includes the directory name from the database,
 *              with the file name appended to it.
 *
 * RETURNS:  void
 ***************************************************************************/

int GetFontsDirectory( LPTSTR pszPath, size_t cchPath )
{
    static   FullPathName_t s_szFontsDir;
    static   int            iRet = 0;

    //
    //  Get the system directory, which we'll store and pre-fix whenever
    //  a file needs it. Note that there isn't a backslash unless the name
    //  is the root directory.
    //

    if(0 == s_szFontsDir[0])
    {
        if (SHGetSpecialFolderPath(NULL, s_szFontsDir, CSIDL_FONTS, FALSE))
        {
            iRet = lstrlen(s_szFontsDir);
        }
    }
    if (FAILED(StringCchCopy(pszPath, cchPath, s_szFontsDir)))
        return 0;

    return iRet;
}


/***************************************************************************
 * DirFilenameClass routines:
 ***************************************************************************/

/***************************************************************************
 * FUNCTION: vGetFullName
 *
 * PURPOSE:  Load the full directory/path/filename into the given string.
 *              The full name includes the directory name from the database,
 *              with the file name appended to it.
 *
 * RETURNS:  void
 ***************************************************************************/

void DirFilenameClass :: vGetFullName( LPTSTR pszPath, size_t cchPath )
{
    ASSERT(NULL != m_poDir);
    TCHAR szTemp[MAX_PATH];

    if (!PathCombine(szTemp, m_poDir->lpString(), m_szFOnly))
    {
        szTemp[0] = 0;
    }
    StringCchCopy(pszPath, cchPath, szTemp);
}


//
// Add a single directory to a directory list.
//
BOOL CFontClass::bAddDirToDirList(
    CFontDirList *pDirList,
    LPCTSTR pszDir,
    BOOL bSystemDir
    )
{
    BOOL bResult = FALSE;

    CFontDir *poDir = new CFontDir;
    if (NULL != poDir)
    {
        if (poDir->bInit(pszDir, lstrlen(pszDir)))
        {
            poDir->vOnSysDir(bSystemDir);
            if (pDirList->Add(poDir))
            {
                poDir   = NULL;  // Now owned by list.
                bResult = TRUE;
            }
        }
        if (NULL != poDir)
        {
            //
            // CFontDir object not owned by list.
            //
            delete poDir;
        }
    }
    return bResult;
}
    
    


CFontDir * CFontClass::poAddDir( LPTSTR lpPath, LPTSTR * lpName )
{
    *lpName = NULL;

    LPTSTR lpLastSlash;
    LPTSTR lpFileOnly;
    CFontDir * poDir = 0;

    //
    //  The first time through, allocate the directory struct.
    //
    CFontDirList *pDirList;
    if (CFontDirList::GetSingleton(&pDirList))
    {
        if (pDirList->IsEmpty())
        {
            //
            //  Load the default directory into the font dir list. It is expected
            //  to be at location 0, so we add it first.
            //
            FullPathName_t szBaseDir;
            szBaseDir[0] = 0;
            
            GetFontsDirectory(szBaseDir, ARRAYSIZE(szBaseDir));
            if (!bAddDirToDirList(pDirList, szBaseDir, TRUE))
            {
                pDirList->Clear();
                return 0;
            }
            //
            //  Add the <win>\system directory. We use it for compatibility reasons.
            // It is located in slot 1.
            //
            szBaseDir[0] = 0;
            GetSystemDirectory(szBaseDir, ARRAYSIZE(szBaseDir));
            if (!bAddDirToDirList(pDirList, szBaseDir, TRUE))
            {
                pDirList->Clear();
                return 0;
            }
        }
 
        //
        //  If we find a backslash in the path name, the name includes a directory
        //  If so, we're going to store the directory name in a separate list.
        //  Otherwise, we reserve slot 0 for the default directory cases.
        //

        // Force same case file (?)
        // lstrcpy( lpPath, /* _strlwr */ (lpPath ) );

        lpLastSlash = StrRChr( lpPath, NULL, TEXT( '\\' ) );


        TCHAR szTempFile[ MAX_PATH_LEN ];


        if( !lpLastSlash )
        {
            if( !bMakeFQName(lpPath, szTempFile, ARRAYSIZE(szTempFile), TRUE ) )
            {
                return( NULL );
            }

            *lpName = lpPath;
            lpPath = szTempFile;

            lpLastSlash = StrRChr( lpPath, NULL, TEXT( '\\' ) );

            if( !lpLastSlash )
            {
                //
                // This should never happen
                //

                return( NULL );
            }
        }

        lpFileOnly = lpLastSlash+1;

        //
        // Try to find the directory in the list.
        //

        int iLen = (int)(lpFileOnly - lpPath - 1);

        poDir = pDirList->Find( lpPath, iLen, TRUE );

        if( !*lpName )
        {
            *lpName = lpFileOnly;
        }
    }
    return poDir;
}


/***************************************************************************
 * FUNCTION: rcStoreDirFN
 *
 * PURPOSE:  Store a directory path in our path list.
 *
 * RETURNS:  RC - NOERR unless directory list full or name too long
 ***************************************************************************/

RC CFontClass :: rcStoreDirFN( LPTSTR lpszPath, DirFilenameClass& dirfn )
{
    RC     rc = ERR_FAIL;
    LPTSTR lpName;
    CFontDir * poDir = poAddDir( lpszPath, &lpName );

    if( poDir && ( lstrlen( lpName ) <= MAX_FILE_LEN ) )
    {
        dirfn.vSet( poDir, lpName );

        rc = NOERR;
    }

    return rc;
}


DWORD CFontClass :: dCalcFileSize( )
{
    //
    //  First we get the size of the basis file
    //

    GetFileInfo( );

    return m_wFileK;
}


/***************************************************************************
 * Start of Public routines
 ***************************************************************************/

/***************************************************************************
 * FUNCTION: bAFR
 *
 * PURPOSE:  Add font resource
 *
 * RETURNS:  TRUE on success.
 ***************************************************************************/

BOOL CFontClass::bAFR( )
{
    if( !m_bAFR )
    {
        FullPathName_t szFile;
        LPTSTR pszResourceName = szFile;
        TCHAR szType1FontResourceName[MAX_TYPE1_FONT_RESOURCE];

        if( !bGetFOT( szFile, ARRAYSIZE( szFile ) ) )
        {
            bGetFQName( szFile, ARRAYSIZE( szFile ) );
        }
        if (bType1())
        {
            //
            // Font is a Type1.
            // Create a Type1 font resource name as:  "<pfm>|<pfb>"
            //
            TCHAR szPfbPath[MAX_PATH];

            if (bGetPFB(szPfbPath, ARRAYSIZE(szPfbPath)) &&
                BuildType1FontResourceName(szFile,
                                           szPfbPath,
                                           szType1FontResourceName,
                                           ARRAYSIZE(szType1FontResourceName)))
            {
                pszResourceName = szType1FontResourceName;
            }
        }
        if( AddFontResource(pszResourceName) )
            m_bAFR = TRUE;
   }

   return m_bAFR;
}


void CFontClass::GetFileInfo( )
{
    TCHAR szPath[ MAX_PATH ];
    WIN32_FIND_DATA fd;

    if( !m_bFileInfoFetched )
    {
        m_ft.dwLowDateTime  = 0;
        m_ft.dwHighDateTime = 0;

        if( bGetFQName( szPath, ARRAYSIZE( szPath ) ) )
        {
            HANDLE hfind = FindFirstFile( szPath, &fd );

            m_bFileInfoFetched  = TRUE;

            if( hfind != INVALID_HANDLE_VALUE )
            {
                m_wFileK = (UINT) BYTESTOK( fd.nFileSizeLow );
                m_ft     = fd.ftLastWriteTime;

                FindClose( hfind );
            }
        }

        if( bPFB( ) )
        {
            if( bMakeFQName( m_lpszPFB, szPath, ARRAYSIZE( szPath ) ) )
            {
                HANDLE hfind = FindFirstFile( szPath, &fd );

                m_bFileInfoFetched  = TRUE;

                if( hfind != INVALID_HANDLE_VALUE )
                {
                    m_wFileK += (UINT) BYTESTOK( fd.nFileSizeLow );

                    FindClose( hfind );
                }
            }
        }

    }
}


BOOL CFontClass::GetFileTime( FILETIME * pft )
{
    GetFileInfo( );

    *pft = m_ft;

    return( pft->dwLowDateTime || pft->dwHighDateTime );
}


/***************************************************************************
 * FUNCTION: bRFR
 *
 * PURPOSE:  Remove font resource
 *
 * RETURNS:  TRUE on success.
 ***************************************************************************/
BOOL CFontClass::bRFR( )
{
    if( m_bAFR )
    {
        FullPathName_t szFile;
        LPTSTR pszResourceName = szFile;
        TCHAR szType1FontResourceName[MAX_TYPE1_FONT_RESOURCE];

        //
        // GDI seems to be particular about full pathname and partial name.
        // Try both if necessary.
        //

        if( !bGetFOT( szFile, ARRAYSIZE( szFile ) ) )
        {
            bGetFQName( szFile, ARRAYSIZE( szFile ) );
        }

        m_bAFR = FALSE;

        if (bType1())
        {
            //
            // Font is a Type1.
            // Create a Type1 font resource name as:  "<pfm>|<pfb>"
            //
            TCHAR szPfbPath[MAX_PATH];

            if (bGetPFB(szPfbPath, ARRAYSIZE(szPfbPath)) &&
                BuildType1FontResourceName(szFile,
                                           szPfbPath,
                                           szType1FontResourceName,
                                           ARRAYSIZE(szType1FontResourceName)))
            {
                pszResourceName = szType1FontResourceName;
            }
        }
        if( !RemoveFontResource( pszResourceName ) )
        {
            TCHAR szFN[ MAX_PATH_LEN ];

            vGetFileName( szFN, ARRAYSIZE(szFN) );

            if( bFOT( ) || !RemoveFontResource( szFN ) )
            {
                //
                // If the file doesn't exist, then it couldn't be in GDI.
                //

                if( GetFileAttributes( szFile ) != 0xffffffff )
                    m_bAFR = TRUE;
            }
        }
    }

    return( !m_bAFR );
}


BOOL CFontClass :: bInit( LPTSTR lpszDesc, LPTSTR lpFileName, LPTSTR lpCompanionFile )
{
    static const TCHAR    c_szPLOTTER     [] = TEXT( " (PLOTTER)" );
    static const TCHAR    c_szTRUETYPE    [] = TEXT( " (TRUETYPE)" );
    static const TCHAR    c_szTRUETYPEALT [] = TEXT( " (TRUE TYPE)" );
    static const TCHAR    c_szTYPE1       [] = TEXT( " (TYPE 1)" );
    static const TCHAR    c_szTYPE1ALT    [] = TEXT( " (POSTSCRIPT)" );
    static const TCHAR    c_szFOT         [] = TEXT( ".FOT" );
    static const TCHAR    c_szTTF         [] = TEXT( ".TTF" );
    static const TCHAR    c_szTTC         [] = TEXT( ".TTC" );
    static const TCHAR    c_szOTF         [] = TEXT( ".OTF" );
    static const TCHAR    c_szPFM         [] = TEXT( ".PFM" );
    static const TCHAR    c_szINF         [] = TEXT( ".INF" );

    LPTSTR  pTT;
    LPTSTR  lpszEn;
    BOOL    bSuccess = TRUE;


    LPCTSTR lpName = PathFindFileName( lpFileName );


    if( !lpName )
    {
        lpName = lpFileName;
    }

    FullPathName_t szName;

    if (FAILED(StringCchCopy(szName, ARRAYSIZE( szName ), lpName )))
    {
        return FALSE;
    }

    CharUpper( szName );

    m_bFileInfoFetched = FALSE;

    //
    // Store the file name.
    //

    if( rcStoreDirFN( lpFileName ) != NOERR )
    {
        return FALSE;
    }

    //
    // Figure out what type of font this is.
    //

    lpszEn = _tcsstr( lpszDesc, TEXT( " (" ) );

    if( lpszEn == NULL )
    {
        //
        //  There's no additional description, so set filetype based on
        //  extension.
        //

        m_wNameLen = (BYTE)lstrlen( lpszDesc );

        if( _tcsstr( szName, c_szTTF ) )
            vSetTrueType( FALSE );
        else if( _tcsstr( szName, c_szOTF ) )
            vSetOpenType( );
        else if( _tcsstr( szName, c_szTTC ) )
            vSetTTCType( );
        else if( _tcsstr( szName, c_szPFM ) )
        {
            vSetType1( );

            if( lpCompanionFile != NULL )
                bSetPFB( lpCompanionFile );
        }
        else if( _tcsstr( szName, c_szINF ) )
        {
            vSetType1( );

            if( lpCompanionFile != NULL )
                bSetPFB( lpCompanionFile );
        }
    }
    else
    {
        m_wNameLen = (BYTE)(lpszEn-lpszDesc);

        FontDesc_t szEn;

        if (FAILED(StringCchCopy(szEn, ARRAYSIZE( szEn ), lpszEn )))
        {
            return FALSE;
        }

        CharUpper( szEn );

        pTT = _tcsstr( szEn, c_szTRUETYPE );

        if( !pTT )
            pTT = _tcsstr( szEn, c_szTRUETYPEALT );

        if( pTT )
        {
            //
            //  This is either a TTF or an FOT
            //

            BOOL bFOT = ( _tcsstr( szName, c_szFOT ) != (LPTSTR) NULL );

            if( bFOT )
            {
                FullPathName_t szTTF;
                FullPathName_t szFOT;

                if( bMakeFQName( lpFileName, szFOT, ARRAYSIZE( szFOT ) ) )
                {
                    bSuccess = bTTFFromFOT( szFOT, szTTF, ARRAYSIZE( szTTF ) );

                    if( bSuccess )
                    {
                        if( !bSetFOT( szFOT ) )
                        {
                            return( FALSE );
                        }

                        return bInit( lpszDesc, szTTF, NULL );
                    }
                }

                //
                //  error
                //

                return FALSE;
            }

            vSetTrueType( bFOT );

            if( _tcsstr( szName, c_szTTC ) )
                vSetTTCType( );
        }
        else if( _tcsstr( szName, c_szOTF ) )
        {
            vSetOpenType( );
        }
        else if( _tcsstr( szName, c_szTTC ) )
        {
            vSetTTCType( );
        }
        else if( _tcsstr( szName, c_szTYPE1 ) )
        {
            vSetType1( );

            if( lpCompanionFile != NULL )
                bSetPFB( lpCompanionFile );
        }
        else if( _tcsstr( szName, c_szTYPE1ALT ) )
        {
            vSetType1( );

            if( lpCompanionFile != NULL )
                bSetPFB( lpCompanionFile );
        }
        else    //   if( _tcsstr( szEn, c_szPLOTTER ) == NULL )
        {
            vSetDeviceType( );
        }
    }

    if (FAILED(StringCchCopy( m_szFontLHS, ARRAYSIZE( m_szFontLHS ), lpszDesc )))
    {
        return FALSE;
    }

    //
    //  It is assumed that this font is already installed.
    //  Set the flag to assume it.
    //

    m_bAFR = TRUE;

    //
    // Set this to be the main family font. This will be reset as necessary.
    //

    m_wFamIdx = IDX_NULL;

    vSetFamilyFont( );

    //
    // Invalidate the font object's cached file attributes.
    // They will be refreshed next time dwGetFileAttributes() is called for
    // this object.
    //
    InvalidateFileAttributes();

    return bSuccess;
}


//
// Retrieve the font object's cached file attributes.
// If invalid, refresh attribute value from the file system.
//
DWORD CFontClass::dwGetFileAttributes(void)
{
    if (!m_bAttributesValid)
    {
        //
        // Cached value is invalid.
        // Refresh from file system.
        //
        TCHAR szPath[MAX_PATH] = { TEXT('\0') };

        //
        // Get full path to file.
        //
        if (!bGetFileToDel(szPath, ARRAYSIZE(szPath)))   // Gets path if local font file.
            vGetDirFN(szPath, ARRAYSIZE(szPath));        // Gets path if remote font file.

        if (TEXT('\0') != szPath[0])
        {
            DWORD dwAttr = GetFileAttributes(szPath);
            if ((DWORD)~0 != dwAttr)
            {
                m_dwFileAttributes = dwAttr;
                m_bAttributesValid = TRUE;
            }
        }
    }
    return m_dwFileAttributes;
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION: CFontClass::GetLogFontInfo
//
//  DESCRIP: Retrieves a list of LOGFONT structures for a font resource.
//
//     ARGS: pszPath
//              Pointer to the font file path string.
//
//           ppLogFontInfo
//              Address of a pointer to an array of LOGFONT structures.
//              The function writes the address of the LOGFONT array
//              to this location.
//
//  RETURNS: Number of LOGFONT structures in returned array.
//
//    NOTES: If *ppLogFontInfo is non-NULL on return,
//           caller must delete array of LOGFONT structures using
//           LocalFree() when finished with it.
//
///////////////////////////////////////////////////////////////////////////////
DWORD CFontClass::GetLogFontInfo(LPTSTR pszPath, LOGFONT **ppLogFontInfo)
{
    DWORD dwNumFonts = 0;
    DWORD dwBufSize = 0;

    ASSERT(NULL != pszPath);
    ASSERT(NULL != ppLogFontInfo);

    dwBufSize = sizeof(dwNumFonts);
    //
    // Get the number of fonts in the font resource.
    //
    if ( NULL != pszPath &&
         NULL != ppLogFontInfo &&
         GetFontResourceInfoW(pszPath,
                              &dwBufSize,
                              &dwNumFonts,
                              GFRI_NUMFONTS) )
    {
        *ppLogFontInfo = (LPLOGFONT)LocalAlloc(LPTR, sizeof(LOGFONT) * dwNumFonts);

        if ( NULL != *ppLogFontInfo )
        {
            dwBufSize = sizeof(LOGFONT) * dwNumFonts;
            //
            // Now get the array of LOGFONT structures.
            //
            if (!GetFontResourceInfoW(pszPath,
                                      &dwBufSize,
                                      *ppLogFontInfo,
                                      GFRI_LOGFONTS))
            {
                //
                // GetFontResourceInfo failed.
                // Clean up and adjust return value to indicate failure.
                //
                LocalFree(*ppLogFontInfo);
                *ppLogFontInfo = NULL;
                dwNumFonts     = 0;
            }
        }
    }
    return dwNumFonts;
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION: CFontClass::GetType1Info
//
//  DESCRIP: Retrieves the family name, style and weight metrics from a Type 1
//           PFM (printer font metrics) file.  Maps a view of the file and
//           reads the required information.
//           Offsets into the PFM file are obtained from the gdi file winfont.h.
//
//           The macros READ_WORD( ) and READ_DWORD( ) handle byte-ordering
//           differences between the Type1 file and memory.
//
//     ARGS: pszPath
//              Pointer to the font file path string.
//
//           pszFamilyBuf
//              Address of destination buffer for family name string.
//              Can be NULL.
//
//           nBufChars
//              Number of characters in family name buffer.
//              Ignored if pszFamilyBuf is NULL.
//
//           pdwStyle
//              Address of DWORD where style value is written.
//              Style will be FDI_S_ITALIC or FDI_S_REGULAR.
//              Can be NULL.
//
//           pwWeight
//              Address of WORD where weight value is written.
//              Can be NULL.
//
//  RETURNS: SUCCESS
//           or Win32 Error code.
//
///////////////////////////////////////////////////////////////////////////////
DWORD CFontClass::GetType1Info(LPCTSTR pszPath,
                               LPTSTR pszFamilyBuf,
                               UINT nBufChars,
                               LPDWORD pdwStyle,
                               LPWORD pwWeight)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwResult = ERROR_SUCCESS;

    ASSERT(NULL != pszPath);

    if (NULL != pszPath &&
       (hFile = CreateFile(pszPath,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) != INVALID_HANDLE_VALUE )
    {
        HANDLE hFileMapping = INVALID_HANDLE_VALUE;

        if ((hFileMapping = CreateFileMapping(hFile,
                                              NULL,
                                              PAGE_READONLY,
                                              0,
                                              0,
                                              NULL)) != NULL)
        {
            LPCSTR pbFile = NULL;

            if ((pbFile = (LPCSTR)MapViewOfFile(hFileMapping,
                                                FILE_MAP_READ,
                                                0,
                                                0,
                                                0)) != NULL)
            {
                //
                // Get font style.
                //
                if ( NULL != pdwStyle )
                    *pdwStyle = READ_DWORD(&pbFile[OFF_Italic]) ? FDI_S_ITALIC : FDI_S_REGULAR;

                //
                // Get font weight.
                //
                if ( NULL != pwWeight )
                    *pwWeight = READ_WORD(&pbFile[OFF_Weight]);

                //
                // Get family (face) name string.
                //
                if ( NULL != pszFamilyBuf )
                {
                    LPCSTR pszFaceName = (LPCSTR)(pbFile + READ_DWORD(&pbFile[OFF_Face]));

                    MultiByteToWideChar(CP_ACP,
                                        0,
                                        pszFaceName,
                                        -1,
                                        pszFamilyBuf,
                                        nBufChars);
                }
                UnmapViewOfFile(pbFile);
            }
            else
                dwResult = GetLastError();

            CloseHandle(hFileMapping);
        }
        else
            dwResult = GetLastError();

        CloseHandle(hFile);
    }
    else
        dwResult = GetLastError();

    return dwResult;
}


/***************************************************************************
 * FUNCTION: bFillIn
 *
 * PURPOSE:  This functions is used to fill in values that may not be
 *           necessary right away. This includes: Panose number and
 *           family name.
 *
 *
 * RETURNS:  TRUE if value is successfully filled in.
 ***************************************************************************/
BOOL CFontClass :: bFillIn( )
{
    FONTDESCINFO   fdi;

    FONTDESCINFO_Init(&fdi);

    if( !m_bFilledIn )
    {
        //
        //  If this is a TTC file, we don't care about PANOSE numbers and
        //  family names.
        //

        if( bTTC( ) )
        {
            // vSetFamName( szGetDesc( ) );

            m_lpszFamName = m_szFontLHS;
            m_cchFamNameMax = ARRAYSIZE(m_szFontLHS);

            vSetFamilyFont( );
        }
        else if( bTrueType( ) || bOpenType( ) )
        {
            if( !bGetFQName( fdi.szFile, ARRAYSIZE( fdi.szFile ) ) )
                goto errout1;

            fdi.dwFlags = FDI_ALL;

            //
            //  Set this as a family font. (We set it so it
            //  doesn't disappear on "hide variations". It will get reset as
            //  soon as possible.)
            //

            vSetFamilyFont( );

            if( !bIsTrueType( &fdi ) )
            {
                //
                // Couldn't open font file for Type1 info.
                // One reason is a font shortcut who's link has been broken.
                // All we have for a name is the LHS string from the registry.
                // Remove the decoration and use it.
                //
                StringCchCopy(m_szFamName, ARRAYSIZE(m_szFamName), m_szFontLHS);
                RemoveDecoration(m_szFamName, TRUE);
                goto errout1;
            }

            //
            //  Copy over font info.
            //

            memcpy( m_xPANOSE.m_ajBytes, &fdi.jPanose, sizeof(m_xPANOSE.m_ajBytes));

            if (FAILED(StringCchCopy( m_szFamName, ARRAYSIZE(m_szFamName), fdi.szFamily )))
            {
                goto errout1;
            }

            m_wWeight = fdi.wWeight;

            // m_fItalic = fdi.dwStyle & FDI_S_ITALIC;

            m_dwStyle = fdi.dwStyle;

            //
            //  Verify the PANOSE number.
            //

            if( !m_xPANOSE.bVerify( ) )
            {
                m_xPANOSE.vClear( );

                // m_fHavePANOSE = FALSE;
            }
            else
                // m_fHavePANOSE = TRUE;
                m_jFamily = m_xPANOSE.jFamily( );
        }
        else if ( bType1() )
        {
            if( ! bGetFQName( fdi.szFile, ARRAYSIZE( fdi.szFile ) ) )
                goto errout1;

            //
            // Make sure we're dealing with a PFM file.
            // GetType1Info only knows how to read a PFM.
            //
            if (0 == lstrcmpi(TEXT(".PFM"), PathFindExtension(fdi.szFile)))
            {
                if (ERROR_SUCCESS != GetType1Info(fdi.szFile,
                                                  m_szFamName,
                                                  ARRAYSIZE(m_szFamName),
                                                  &m_dwStyle,
                                                  &m_wWeight))
                {
                    //
                    // Couldn't open font file for Type1 info.
                    // One reason is a font shortcut who's link has been broken.
                    // All we have for a name is the LHS string from the registry.
                    // Remove the decoration and use it.
                    //
                    StringCchCopy(m_szFamName, ARRAYSIZE(m_szFamName), m_szFontLHS);
                    RemoveDecoration(m_szFamName, TRUE);
                }
            }
            else
            {
                //
                // If this code is hit, it means that we have installed
                // something other than a PFM file as a Type1 font.  This is
                // an error that must be corrected.
                // Fill in with some safe values so we don't have just garbage.
                // During development, complain about it.
                //
                DEBUGMSG((DM_TRACE1, TEXT("Non-PFM file (%s) installed for Type1 font."),
                                     fdi.szFile));
                ASSERT(0);

                m_szFamName[0] = TEXT('\0');
                m_dwStyle      = 0;
                m_wWeight      = 0;
            }
        }
        //
        //  FNT files.
        //
        else
        {
            if( ! bGetFQName( fdi.szFile, ARRAYSIZE( fdi.szFile ) ) )
                goto errout1;

            fdi.dwFlags = FDI_ALL;

            vSetFamilyFont( );

            if( bIsNewExe( &fdi ) )
            {
                //
                // Copy over font info.
                //

                if (FAILED(StringCchCopy( m_szFamName, ARRAYSIZE(m_szFamName), fdi.szFamily )))
                {
                    goto errout1;
                }

                m_wWeight = fdi.wWeight;

                m_dwStyle = fdi.dwStyle;
            }
            else
            {
                //
                // Probably a 32-bit font resource.
                // Even if there are multiple fonts in resource,
                // just use info from first font.
                //
                LOGFONT *paLogFontInfo = NULL;
                DWORD dwNumLogFonts    = 0;

                dwNumLogFonts = GetLogFontInfo(fdi.szFile, &paLogFontInfo);
                if ( 0 != dwNumLogFonts && NULL != paLogFontInfo)
                {
                    if (FAILED(StringCchCopy(m_szFamName, ARRAYSIZE(m_szFamName), (paLogFontInfo + 0)->lfFaceName)))
                    {
                        LocalFree(paLogFontInfo);
                        goto errout1;
                    }
                    m_wWeight = (WORD)((paLogFontInfo + 0)->lfWeight);
                    m_dwStyle = ((paLogFontInfo + 0)->lfItalic ? FDI_S_ITALIC : FDI_S_REGULAR);
                    LocalFree(paLogFontInfo);
                }
                else
                    goto errout1;
            }
        }

        m_bFilledIn = TRUE;
    }

errout1:
    FONTDESCINFO_Destroy(&fdi);
    return m_bFilledIn;
}


/***************************************************************************
 * FUNCTION: bGetFQName
 *
 * PURPOSE:  Get the fully qualified FOT filename of the file associated with
 *              the input font record.  This is the FQ version of the filename
 *              found in WIN.INI.
 *
 *           Assumes: lpsz is of size wLen + 1
 *
 * RETURNS:  TRUE if successful
 ***************************************************************************/
BOOL CFontClass :: bGetFQName( LPTSTR pszName, size_t cchName )
{
    //
    //  Get the font's directory path, and make the fully qualified name from
    //  that.
    //

    PATHNAME  szPath;

    vGetDirFN( szPath, ARRAYSIZE(szPath) );

    return bMakeFQName( szPath, pszName, cchName );
}


BOOL CFontClass::bGetFileToDel( LPTSTR pszFileName, size_t cchFileName )
{
    if( bFOT( ) )
    {
        LPTSTR lpPath = m_lpszFOT;
        LPTSTR lpLastSlash = StrRChr( lpPath, NULL, TEXT( '\\' ) );

        TCHAR szTempFile[ MAX_PATH_LEN ];

        if( !lpLastSlash )
        {
            if( !bMakeFQName( lpPath, szTempFile, ARRAYSIZE(szTempFile), TRUE ) )
            {
                return( FALSE );
            }

            lpPath = szTempFile;

            lpLastSlash = StrRChr( lpPath, NULL, TEXT( '\\' ) );

            if( !lpLastSlash )
            {
                //
                //  This should never happen
                //
                return( FALSE );
            }
        }

        LPTSTR lpFileOnly = lpLastSlash + 1;

        //
        //  Try to find the directory in the list, but do not add it
        //

        int iLen = (int)(lpFileOnly - lpPath - 1);

        CFontDirList *pDirList;
        if (CFontDirList::GetSingleton(&pDirList))
        {
            CFontDir *poDir = pDirList->Find( lpPath, iLen, FALSE );

            if( poDir && poDir->bOnSysDir( ) )
            {
                bGetFOT( pszFileName, cchFileName );
                return( TRUE );
            }
        }
    }
    else if( bOnSysDir( ) )
    {
        vGetDirFN( pszFileName, cchFileName );
        return( TRUE );
    }

    return( FALSE );
}

int CFontClass::s_cFonts = 0;
ULONG CFontClass::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CFontClass::Release(void)
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {   
        delete this;
    }
    return cRef;
}



/*****************************************************************************
    Local functions:
*****************************************************************************/

typedef enum
{
    DC_ERROR,
    DC_YES,
    DC_NO,
} DC_RETURN;

DC_RETURN bDirContains( LPCTSTR szInName,
                        LPCTSTR szDir,
                        BOOL bCheckExist,
                        LPTSTR lpszName,
                        DWORD dwNameLen )
{
    //
    //  If the path doesn't have a disk or directory specifier in it, start
    //  the resulting name with the system directory (this is ready for
    //  appending).  Otherwise, start with nothing - we'll append the entire
    //  input path.
    //

    if (FAILED(StringCchPrintf( lpszName, dwNameLen, TEXT("%s%s"), szDir, szInName )))
    {
        return( DC_ERROR );
    }

    if( !bCheckExist )
    {
        return( DC_YES );
    }
    return( MyOpenFile( lpszName, NULL, 0, OF_EXIST )
                        != (HANDLE) INVALID_HANDLE_VALUE ? DC_YES : DC_NO );
}


/***************************************************************************
 * FUNCTION: bMakeFQName
 *
 * PURPOSE:  Build a fully qualified filename based on the input name
 *              and the system directory (obtained from win.ini).  If there's
 *              already a device and/or directory, don't append the sys dir.
 *
 * RETURNS:  TRUE if FQ name will fit in return, error FALSE
 ***************************************************************************/
BOOL PASCAL bMakeFQName( LPTSTR pszNameIn,
                         LPTSTR pszNameOut,
                         size_t cchNameOut,
                         BOOL   bSearchPath )
{
    size_t cchNameIn = lstrlen( pszNameIn );

    if( _tcscspn( pszNameIn, TEXT( ":\\" ) ) != cchNameIn )
    {
        //
        //  (Presumably) fully qualified; no need to check anything
        //

        if (FAILED(StringCchCopy(pszNameOut, cchNameOut, pszNameIn)))
        {
            return( FALSE );
        }
        return( TRUE );
    }

    FullPathName_t szDir;

    if( bSearchPath )
    {
        //
        //  Set the current dir to the Fonts folder so it will get searched
        //  first
        //

        if( !GetFontsDirectory( szDir, ARRAYSIZE( szDir ) ) )
        {
            return( FALSE );
        }

        SetCurrentDirectory( szDir );

        //
        //  Check to see if the file exists on the path.
        //
        TCHAR szPathName[ PATHMAX ];

        if( MyOpenFile( pszNameIn, szPathName, ARRAYSIZE(szPathName), OF_EXIST )
                    != (HANDLE) INVALID_HANDLE_VALUE )
        {
            if (FAILED(StringCchCopy(pszNameOut, cchNameOut, szPathName)))
            {
                return( FALSE );
            }
            return( TRUE );
        }
        //
        //  If not on the path, we will fall through and just fill in the
        //  Fonts dir
    }
    else
    {
        //
        //  First check in the system directory; always check for existence
        //

        if( !GetSystemDirectory( szDir, ARRAYSIZE( szDir ) ) )
        {
            return( FALSE );
        }

        if (!lpCPBackSlashTerm( szDir, ARRAYSIZE(szDir)))
        {
            return( FALSE );
        }

        switch( bDirContains( pszNameIn, szDir, TRUE, pszNameOut, cchNameOut ) )
        {
        case DC_YES:
            return( TRUE );
            break;
        }

        //
        //  Next check in the fonts directory; only check for existence if we
        //  are really looking for the file to exist
        //

        if( !GetFontsDirectory( szDir, ARRAYSIZE( szDir ) ) )
        {
            return( FALSE );
        }
    }

    if (!lpCPBackSlashTerm( szDir, ARRAYSIZE(szDir)))
    {
        return( FALSE );
    }

    switch( bDirContains( pszNameIn, szDir, FALSE, pszNameOut, cchNameOut ) )
    {
    case DC_ERROR:
        return( FALSE );
        break;
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\fontext.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fontext.cpp
//      Explorer Font Folder extension routines
//     Fonts Folder Shell Extension
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"

// ********************************************************
// Initialize GUIDs
//

#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <cguid.h>
#include <shlguid.h>
#include "fontext.h"
#include "panmap.h"     // the IID for the Panose Mapper.

//#undef INITGUID
#pragma data_seg()

#include "globals.h"
#include "extinit.h"
#include "fontman.h"
#include "fontview.h"
#include "cpanel.h"
#include "ui.h"
#include "dbutl.h"
#include "extricon.h"

#define GUIDSIZE  (GUIDSTR_MAX + 1)

HINSTANCE g_hInst = NULL;
LONG      g_cRefThisDll = 0; // Number of references to objects in this dll
LONG      g_cLock = 0;
BOOL      g_bDBCS;           // Running in a DBCS locale ?
CRITICAL_SECTION g_csFontManager; // For acquiring font manager ptr.

class CImpIClassFactory;

// UINT g_DebugMask; //  = DM_ERROR | DM_TRACE1 | DM_MESSAGE_TRACE1 | DM_TRACE2;
UINT g_DebugMask = DM_ERROR | DM_TRACE1 | DM_MESSAGE_TRACE1 | DM_TRACE2;


#ifdef _DEBUG

//
// The Alpha compiler doesn't like the typecast used in the call to wvsprintf().
// Using standard variable argument mechanism.
//
#include <stdarg.h>

void DebugMessage( UINT mask, LPCTSTR pszMsg, ... )
{

    TCHAR ach[ 256 ];

    va_list args;
    va_start(args, pszMsg);
    if( !( mask & g_DebugMask ) ) return;

    StringCchVPrintf( ach, ARRAYSIZE(ach), pszMsg, ( (char *)(TCHAR *) &pszMsg + sizeof( TCHAR * ) ) );
    StringCchVPrintf( ach, ARRAYSIZE(ach), pszMsg, args);
    va_end(args);

    if( !( mask & DM_NOEOL ) ) StringCchCat( ach, ARRAYSIZE(ach), TEXT( "\r\n" ) );


#ifndef USE_FILE
    OutputDebugString( ach );
#else
    HANDLE hFile;
    long x;
    
    hFile = CreateFile( g_szLogFile, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

    if( INVALID_HANDLE_VALUE == hFile )
    {
       OutputDebugString( TEXT( "FontExt: Unable to open log file\r\n" ) );
       return;
    }
    
    if( 0xFFFFFFFF == SetFilePointer( hFile, 0, NULL, FILE_END ) )
    {
       OutputDebugString( TEXT( "FontExt: Unable to seek to end of log file\r\n" ) );
       return;
    }
    
    if( !WriteFile( hFile, ach, strlen( ach ), &x, NULL ) )
    {
       OutputDebugString( TEXT( "FontExt: Unable to write to log file\r\n" ) );
       return;
    }
    
    if( !CloseHandle( hFile ) )
    {
       OutputDebugString( TEXT( "FontExt: Unable to close log file\r\n" ) );
       return;
    }
#endif
}


// ******************************************************************
// Send an HRESULT to the debug output
//

void DebugHRESULT( int flags, HRESULT hResult )
{
    switch( GetScode( hResult ) )
    {
        case S_OK:          DEBUGMSG( (flags, TEXT( "S_OK" ) ) );          return;
        case S_FALSE:       DEBUGMSG( (flags, TEXT( "S_FALSE" ) ) );       return;
        case E_NOINTERFACE: DEBUGMSG( (flags, TEXT( "E_NOINTERFACE" ) ) ); return;
        case E_NOTIMPL:     DEBUGMSG( (flags, TEXT( "E_NOTIMPL" ) ) );     return;
        case E_FAIL:        DEBUGMSG( (flags, TEXT( "E_FAIL" ) ) );        return;
        case E_OUTOFMEMORY: DEBUGMSG( (flags, TEXT( "E_OUTOFMEMORY" ) ) ); return;
    } // switch

    if( SUCCEEDED( hResult ) ) 
        DEBUGMSG( (flags, TEXT( "S_unknown" ) ) );
    else if( FAILED( hResult ) ) 
        DEBUGMSG( (flags, TEXT( "E_unknown" ) ) );
    else 
        DEBUGMSG( (flags, TEXT( "No Clue" ) ) );
}


// ******************************************************************
// Print a REFIID to the debugger

void DebugREFIID( int flags, REFIID riid )
{
   if( riid == IID_IUnknown ) DEBUGMSG( (flags, TEXT( "IID_IUnknown" ) ) );
   else if( riid == IID_IShellFolder )  DEBUGMSG( (flags, TEXT( "IID_IShellFolder" ) ) );
   else if( riid == IID_IClassFactory ) DEBUGMSG( (flags, TEXT( "IID_IClassFactory" ) ) );
   else if( riid == IID_IShellView )    DEBUGMSG( (flags, TEXT( "IID_IShellView" ) ) );
   else if( riid == IID_IShellBrowser ) DEBUGMSG( (flags, TEXT( "IID_IShellBrowser" ) ) );
   else if( riid == IID_IContextMenu )  DEBUGMSG( (flags, TEXT( "IID_IContextMenu" ) ) );
   else if( riid == IID_IShellExtInit ) DEBUGMSG( (flags, TEXT( "IID_IShellExtInit" ) ) );
   else if( riid == IID_IShellPropSheetExt ) DEBUGMSG( (flags, TEXT( "IID_IShellPropSheetExt" ) ) );
   else if( riid == IID_IPersistFolder ) DEBUGMSG( (flags, TEXT( "IID_IPersistFolder" ) ) );
   else if( riid == IID_IExtractIconW )  DEBUGMSG( (flags, TEXT( "IID_IExtractIconW" ) ) );
   else if( riid == IID_IExtractIconA )  DEBUGMSG( (flags, TEXT( "IID_IExtractIconA" ) ) );
   else if( riid == IID_IDropTarget )   DEBUGMSG( (flags, TEXT( "IID_IDropTarget" ) ) );
   else if( riid == IID_IPersistFile )   DEBUGMSG( (flags, TEXT( "IID_IPersistFile" ) ) );
   //else if( riid == IID_I ) DEBUGMSG( (flags, TEXT( "IID_I" ) ) );
   else DEBUGMSG( (flags, TEXT( "No clue what interface this is" ) ) );
}
#endif   // _DEBUG


// ******************************************************************
// ******************************************************************
// DllMain

STDAPI_(BOOL) APIENTRY DllMain( HINSTANCE hDll, 
                                DWORD dwReason, 
                                LPVOID lpReserved )
{
    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
        {
            g_DebugMask = DM_ERROR | DM_TRACE1 | DM_TRACE2
                          | DM_MESSAGE_TRACE1; //  | DM_MESSAGE_TRACE2;
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_PROCESS_ATTACH" ) ) );
            g_hInst = hDll;

            if (!InitializeCriticalSectionAndSpinCount(&g_csFontManager, 0))
            {
                return FALSE;
            }

            DisableThreadLibraryCalls(hDll);
            if (!SHFusionInitializeFromModuleID(hDll, 124))
            {
                DeleteCriticalSection(&g_csFontManager);
                return FALSE;
            }

            
            //
            // Initialize the global g_bDBCS flag.
            //
            USHORT wLanguageId = LANGIDFROMLCID(GetThreadLocale());

            g_bDBCS = (LANG_JAPANESE == PRIMARYLANGID(wLanguageId)) ||
                      (LANG_KOREAN   == PRIMARYLANGID(wLanguageId)) ||
                      (LANG_CHINESE  == PRIMARYLANGID(wLanguageId));

            //
            // Initialize the various modules.
            //
            
            vCPPanelInit( );
            vUIMsgInit( );
            
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_PROCESS_ATTACH" ) ) );
            break;
        }
        
        case DLL_PROCESS_DETACH:
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_PROCESS_DETACH" ) ) );

            SHFusionUninitialize();
            DeleteCriticalSection(&g_csFontManager);
            break;
        
        case DLL_THREAD_ATTACH:
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_THREAD_ATTACH" ) ) );
            break;
        
        case DLL_THREAD_DETACH:
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_THREAD_DETACH" ) ) );
            break;
        
        default:
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: LibMain - DLL_something else" ) ) );
            break;
      
    } // switch
    
    return( TRUE );
}

 
// ******************************************************************
// DllCanUnloadNow

STDAPI DllCanUnloadNow( )
{
    HRESULT retval;
    
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: DllCanUnloadNow called - %d references" ),
               g_cRefThisDll ) );

    retval = (g_cRefThisDll == 0 ) && (g_cLock == 0 ) ? S_OK : S_FALSE;

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: DllCanUnloadNow returning: %s" ),
               g_cRefThisDll ? TEXT( "S_FALSE" ) : TEXT( "S_OK" ) ) );

    return( retval );
}


// ********************************************************************

class CImpIClassFactory : public IClassFactory
{

public:
   CImpIClassFactory( ) : m_cRef( 0 )

      { g_cRefThisDll++;}
   ~CImpIClassFactory( ) { 
      DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: ~CImpIClassFactory" ) ) );
      g_cRefThisDll--; }

   //
   // *** IUnknown methods ***
   //

   STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj );
   STDMETHODIMP_(ULONG) AddRef( void );
   STDMETHODIMP_(ULONG) Release( void );
 
   //
   // *** IClassFactory methods ***
   //

   STDMETHODIMP CreateInstance( LPUNKNOWN pUnkOuter,
                                REFIID riid,
                                LPVOID FAR* ppvObject );

   STDMETHODIMP LockServer( BOOL fLock );

private:
  int m_cRef;

};

// ******************************************************************
// ******************************************************************
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, 
                          REFIID riid, 
                          LPVOID FAR* ppvObj )
{

    // DEBUGBREAK;
    
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: DllGetClassObject called" ) ) );
    
    if( !(rclsid == CLSID_FontExt ) )
    {
       DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Dll-GCO: Tried to create a ClassFactory for an unknown class" ) ) );
    
       return E_FAIL;
    }
    
    if( !(riid == IID_IUnknown ) && !(riid == IID_IClassFactory ) )
    {
       DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Dll-GCO: Unknown Interface requested" ) ) );
       return E_NOINTERFACE;
    }
    
    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: Dll-GCO Creating a class factory for CLSID_FontExt" ) ) );
    
    *ppvObj = (LPVOID) new CImpIClassFactory;
    
    if( !*ppvObj )
    {
        DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Dll-GCO: Out of memory" ) ) );

        return E_OUTOFMEMORY;
    }
    
    ((LPUNKNOWN)*ppvObj)->AddRef( );
    
    return S_OK;
}


HRESULT CreateViewObject( LPVOID FAR * ppvObj )
{
    CFontView* prv;
    
    HRESULT hr = E_OUTOFMEMORY;
    
    prv = new CFontView();

    if(prv)
    {
        //
        //  AddRef the view and then Release after the QI. If QI fails,
        //  then prv with delete itself gracefully.
        //

        prv->AddRef( );

        hr = prv->QueryInterface( IID_IShellView, ppvObj );

        prv->Release( );
    }
    
    return hr;

}

// ***********************************************************************
// ***********************************************************************
//  CImpIClassFactory member functions
//
//  *** IUnknown methods ***
//

STDMETHODIMP CImpIClassFactory::QueryInterface( REFIID riid, 
                                                LPVOID FAR* ppvObj )
{
    *ppvObj = NULL;
    
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory::QueryInterface called" ) ) );
    
    //
    //  Any interface on this object is the object pointer
    //

    if( (riid == IID_IUnknown) || (riid == IID_IClassFactory) )
       *ppvObj = (LPVOID) this;
    
    if( *ppvObj )
    {
       ((LPUNKNOWN)*ppvObj)->AddRef( );
       return NOERROR;
    }
    
    return( ResultFromScode( E_NOINTERFACE ) );
}


STDMETHODIMP_(ULONG) CImpIClassFactory::AddRef( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory::AddRef called: %d->%d references" ),
              m_cRef, m_cRef + 1) );

    return( ++m_cRef );
}


STDMETHODIMP_(ULONG) CImpIClassFactory::Release( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory::Release called: %d->%d references" ),
              m_cRef, m_cRef - 1) );
    
    ULONG retval;
    
    retval = --m_cRef;
    
    if( !retval ) 
       delete this;

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory Leaving. " ) ) );

    return( retval );
}
 

//
//  *** IClassFactory methods ***
//

STDMETHODIMP CImpIClassFactory::CreateInstance( LPUNKNOWN pUnkOuter,
                                                REFIID riid,
                                                LPVOID FAR* ppvObj )
{
    LPUNKNOWN poUnk = NULL;
    
    HRESULT hr = E_NOINTERFACE;
    
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory::CreateInstance called" ) ) );
    DEBUGREFIID( (DM_TRACE1, riid) );
    
    //
    //  we do not support aggregation
    //
    
    if( pUnkOuter )
       return CLASS_E_NOAGGREGATION;
    

    if( riid == IID_IShellView || riid == IID_IPersistFolder )
    {
        hr = CreateViewObject( (void **)&poUnk );
    }
    else if( riid == IID_IShellExtInit )
    {
        CShellExtInit * poExt = new CShellExtInit;

        if(!poExt)
        {
            DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: factory - no memory") ) );
            return E_OUTOFMEMORY;
        }
        else if (!poExt->bInit())
        {
            delete poExt;
            return E_OUTOFMEMORY;
        }

        hr = poExt->QueryInterface( IID_IUnknown, (void **)&poUnk );
    }
    else if (riid == IID_IExtractIconW || 
             riid == IID_IExtractIconA ||
             riid == IID_IPersistFile)
    {
        CFontIconHandler *pfih = new CFontIconHandler;

        if (NULL == pfih)
        {
            DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: factory - no memory") ) );
            return E_OUTOFMEMORY;
        }

        hr = pfih->QueryInterface(IID_IUnknown, (LPVOID *)&poUnk);
    }
   
    //
    //  If we got an IUnknown, then AddRef (above) before QI and then Release. 
    //  This will force the object to be deleted if QI fails.
    //
    //  This method of first querying for IUnknown then again for the
    //  actual interface of interest is unnecessary.
    //  I've left it this way just because it works and I don't want to 
    //  risk breaking something that has been coded around this weirdness.
    //  [brianau - 07/23/97]
    //

    if( poUnk )
    {
        hr = poUnk->QueryInterface( riid, ppvObj );
        poUnk->Release( );
    }

    return hr;
}


STDMETHODIMP CImpIClassFactory::LockServer( BOOL fLock )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CImpIClassFactory::LockServer called" ) ) );

    if( fLock ) 
        g_cLock++;
    else 
        g_cLock--;

    return( NOERROR );
}


//
// We need a CLSID->string converter but I don't want to link to 
// ole32 to get it.  This isn't a terribly efficient implementation but
// we only call it once during DllRegServer so it doesn't need to be.
// [brianau - 2/23/99]
//
HRESULT
GetClsidStringA(
    REFGUID clsid,
    LPSTR pszDest,
    UINT cchDest
    )
{
    return StringCchPrintfA(pszDest, 
                            cchDest,
                            "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                            clsid.Data1,
                            clsid.Data2,
                            clsid.Data3,
                            clsid.Data4[0],
                            clsid.Data4[1],
                            clsid.Data4[2],
                            clsid.Data4[3],
                            clsid.Data4[4],
                            clsid.Data4[5],
                            clsid.Data4[6],
                            clsid.Data4[7]);
}



HRESULT
CreateDesktopIniFile(
    void
    )
{
    //
    // Get the path for the file (%windir%\fonts\desktop.ini)
    //
    TCHAR szPath[MAX_PATH * 2];
    HRESULT hr = SHGetSpecialFolderPath(NULL, szPath, CSIDL_FONTS, FALSE) ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        if (!PathAppend(szPath, TEXT("desktop.ini")))
        {
            hr = E_FAIL;
        }
        else
        {
            //
            // Build the file's content.  Note that it's ANSI text.
            //
            char szClsid[GUIDSIZE];

            hr = GetClsidStringA(CLSID_FontExt, szClsid, ARRAYSIZE(szClsid));
            if (SUCCEEDED(hr))
            {
                const char szFmt[] = "[.ShellClassInfo]\r\nUICLSID=%s\r\n";
                char szText[ARRAYSIZE(szClsid) + ARRAYSIZE(szFmt)];
                DWORD dwBytesWritten;

                hr = StringCchPrintfA(szText, ARRAYSIZE(szText), szFmt, szClsid);
                if (SUCCEEDED(hr))
                {
                    //
                    // Always create the file.  Attr are SYSTEM+HIDDEN.
                    //
                    HANDLE hFile = CreateFile(szPath,
                                              GENERIC_WRITE,
                                              FILE_SHARE_READ,
                                              NULL,
                                              CREATE_ALWAYS,
                                              FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN,
                                              NULL);

                    if (INVALID_HANDLE_VALUE != hFile)
                    {
                        //
                        // Write out the contents.
                        //
                        if (!WriteFile(hFile, szText, lstrlenA(szText), &dwBytesWritten, NULL))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CloseHandle(hFile);
                    }
                    else
                        hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }
    return hr;
}


STDAPI DllRegisterServer(void)
{
    //
    // Currently, all we do is create the desktop.ini file.
    //
    return CreateDesktopIniFile();
}

STDAPI DllUnregisterServer(void)
{
    //
    // Do nothing.
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\fontfile.cpp ===
#include <windows.h>
#include <lzexpand.h>
#include "priv.h"
#include "fontfile.h"

//
// Pure virtual base class for all font file I/O implementations.
//
class CFontFileIo
{
    public:
        CFontFileIo(LPCTSTR pszPath)
            : m_pszPath(StrDup(pszPath)) { }

        virtual ~CFontFileIo(void) { delete[] m_pszPath; }

        virtual DWORD Open(DWORD dwAccess, DWORD dwShareMode, bool bCreate) = 0;

        virtual void Close(void) = 0;

        virtual DWORD Read(LPVOID pbDest, DWORD cbDest, LPDWORD pcbRead) = 0;

        virtual DWORD Seek(LONG lDistance, DWORD dwMethod) = 0;

        virtual bool IsOpen(void) const = 0;

        virtual DWORD GetExpandedName(LPTSTR pszDest, UINT cchDest) = 0;

        virtual DWORD CopyTo(LPCTSTR pszFileTo) = 0;

    protected:
        LPTSTR m_pszPath;

    private:
        LPTSTR StrDup(LPCTSTR psz);
        //
        // Prevent copy.
        //
        CFontFileIo(const CFontFileIo& rhs);
        CFontFileIo& operator = (const CFontFileIo& rhs);
};


//
// Opens and reads font files using Win32 functions.
//
class CFontFileIoWin32 : public CFontFileIo
{
    public:
        CFontFileIoWin32(LPCTSTR pszPath)
            : CFontFileIo(pszPath),
              m_hFile(INVALID_HANDLE_VALUE) { }

        virtual ~CFontFileIoWin32(void);

        virtual DWORD Open(DWORD dwAccess, DWORD dwShareMode, bool bCreate = false);

        virtual void Close(void);

        virtual DWORD Read(LPVOID pbDest, DWORD cbDest, LPDWORD pcbRead);

        virtual DWORD Seek(LONG lDistance, DWORD dwMethod);

        virtual bool IsOpen(void) const
            { return INVALID_HANDLE_VALUE != m_hFile; }

        virtual DWORD GetExpandedName(LPTSTR pszDest, UINT cchDest);

        virtual DWORD CopyTo(LPCTSTR pszFileTo);

    private:
        HANDLE m_hFile;

        //
        // Prevent copy.
        //
        CFontFileIoWin32(const CFontFileIoWin32& rhs);
        CFontFileIoWin32& operator = (const CFontFileIoWin32& rhs);
};


//
// Opens and reads font files using LZ (compression) library functions.
//
class CFontFileIoLz : public CFontFileIo
{
    public:
        CFontFileIoLz(LPCTSTR pszPath)
            : CFontFileIo(pszPath),
              m_hFile(-1) { }

        virtual ~CFontFileIoLz(void);

        virtual DWORD Open(DWORD dwAccess, DWORD dwShareMode, bool bCreate = false);

        virtual void Close(void);

        virtual DWORD Read(LPVOID pbDest, DWORD cbDest, LPDWORD pcbRead);

        virtual DWORD Seek(LONG lDistance, DWORD dwMethod);

        virtual bool IsOpen(void) const
            { return -1 != m_hFile; }

        virtual DWORD GetExpandedName(LPTSTR pszDest, UINT cchDest);

        virtual DWORD CopyTo(LPCTSTR pszFileTo);

    private:
        int m_hFile;

        DWORD LZERR_TO_WIN32(INT err);

        //
        // Prevent copy.
        //
        CFontFileIoLz(const CFontFileIoLz& rhs);
        CFontFileIoLz& operator = (const CFontFileIoLz& rhs);
};


//-----------------------------------------------------------------------------
// CFontFileIo
//-----------------------------------------------------------------------------
//
// Helper to duplicate strings.
//
LPTSTR 
CFontFileIo::StrDup(
    LPCTSTR psz
    )
{
    const size_t cch = lstrlen(psz) + 1;
    LPTSTR pszNew = new TCHAR[cch];
    if (NULL != pszNew)
        StringCchCopy(pszNew, cch, psz);

    return pszNew;
}


//-----------------------------------------------------------------------------
// CFontFileIoWin32
//-----------------------------------------------------------------------------
//
// Ensure the file is closed on object destruction.
//
CFontFileIoWin32::~CFontFileIoWin32(
    void
    )
{ 
    Close();
}


//
// Open the file using Win32 operations.
//
DWORD
CFontFileIoWin32::Open(
    DWORD dwAccess,
    DWORD dwShareMode,
    bool bCreate
    )
{
    DWORD dwResult = ERROR_SUCCESS;

    if (NULL == m_pszPath)
    {
        //
        // Path string creation failed in ctor.
        //
        return ERROR_NOT_ENOUGH_MEMORY; 
    }
    //
    // Close existing file if open.
    //
    Close();

    m_hFile = ::CreateFile(m_pszPath,
                           dwAccess,
                           dwShareMode,
                            0,
                           bCreate ? CREATE_ALWAYS : OPEN_EXISTING,
                           0,
                           NULL);

    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        dwResult = ::GetLastError();
    }
    return dwResult;
}



void
CFontFileIoWin32::Close(
    void
    )
{
    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        ::CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
}


DWORD
CFontFileIoWin32::Read(
    LPVOID pbDest, 
    DWORD cbDest, 
    LPDWORD pcbRead
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    DWORD cbRead;

    if (NULL == pcbRead)
    {
        //
        // Not performing overlapped I/O so pcbRead can't be NULL.
        // User doesn't want the byte count so use a local dummy variable.
        // 
        pcbRead = &cbRead;
    }
    if (!::ReadFile(m_hFile, pbDest, cbDest, pcbRead, NULL))
    {
        dwResult = ::GetLastError();
    }
    return dwResult;
}



DWORD
CFontFileIoWin32::Seek(
    LONG lDistance, 
    DWORD dwMethod
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    if (INVALID_SET_FILE_POINTER == ::SetFilePointer(m_hFile, lDistance, NULL, dwMethod))
    {
        dwResult = ::GetLastError();
    }
    return dwResult;
}


//
// Expanding the name of a non-LZ file is just a string copy
// of the full path.
//
DWORD 
CFontFileIoWin32::GetExpandedName(
    LPTSTR pszDest, 
    UINT cchDest
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    if (NULL != m_pszPath)
    {
        dwResult = HRESULT_CODE(StringCchCopy(pszDest, cchDest, m_pszPath));
    }
    else
    {
        //
        // Failed to create path string in ctor.
        //
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
    }
    return dwResult;
}


//
// Copy the file to a new file using Win32 operations.
// Fail if the destination file already exists.
//
DWORD 
CFontFileIoWin32::CopyTo(
    LPCTSTR pszFileTo
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    if (NULL != m_pszPath)
    {
        if (!::CopyFile(m_pszPath, pszFileTo, TRUE))
            dwResult = ::GetLastError();
    }
    else
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
    }
    return dwResult;
}


//-----------------------------------------------------------------------------
// CFontFileIoLz
//-----------------------------------------------------------------------------
//
// Ensure file is closed on object destruction.
//
CFontFileIoLz::~CFontFileIoLz(
    void
    )
{ 
    Close();
}


//
// Open the file using LZOpen.
//
DWORD
CFontFileIoLz::Open(
    DWORD dwAccess,
    DWORD dwShareMode,
    bool bCreate
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    DWORD dwMode;
    OFSTRUCT ofs   = { 0 };

    if (NULL == m_pszPath)
        return ERROR_NOT_ENOUGH_MEMORY; 

    ofs.cBytes = sizeof(ofs);
    //
    // Close file if it's open.
    //
    Close();
    //
    // Map the Win32 access flags to the associated OFSTRUCT flags.
    //
    dwMode = OF_SHARE_EXCLUSIVE; // Assume we want exclusive access.

    if (GENERIC_READ & dwAccess)
        dwMode |= OF_READ;
    if (GENERIC_WRITE & dwAccess)
        dwMode |= OF_WRITE;
    if (0 == (FILE_SHARE_READ & dwShareMode))
        dwMode &= ~OF_SHARE_DENY_READ;
    if (0 == (FILE_SHARE_WRITE & dwShareMode))
        dwMode &= ~OF_SHARE_DENY_WRITE;

    if (bCreate)
        dwMode |= OF_CREATE;

    m_hFile = ::LZOpenFile((LPTSTR)m_pszPath, &ofs, LOWORD(dwMode));
    if (0 > m_hFile)
    {
        dwResult = LZERR_TO_WIN32(m_hFile);
    }
    return dwResult;
}


void
CFontFileIoLz::Close(
    void
    )
{
    if (-1 != m_hFile)
    {
        ::LZClose(m_hFile);
        m_hFile = -1;
    }
}



DWORD
CFontFileIoLz::Read(
    LPVOID pbDest, 
    DWORD cbDest, 
    LPDWORD pcbRead
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    INT cbRead = ::LZRead(m_hFile, (LPSTR)pbDest, (INT)cbDest);
    if (0 > cbRead)
    {
        dwResult = LZERR_TO_WIN32(cbRead);
    }
    else
    {
        if (NULL != pcbRead)
            *pcbRead = cbRead;
    }
    return dwResult;
}



DWORD
CFontFileIoLz::Seek(
    LONG lDistance, 
    DWORD dwMethod
    )
{
    //
    // LZSeek iOrigin codes match exactly with Win32
    // dwMethod codes (i.e. FILE_BEGIN == 0)
    //
    DWORD dwResult = ERROR_SUCCESS;
    LONG cbPos = ::LZSeek(m_hFile, lDistance, (INT)dwMethod);
    if (0 > cbPos)
    {
        dwResult = LZERR_TO_WIN32(cbPos);
    }
    return dwResult;
}



DWORD 
CFontFileIoLz::GetExpandedName(
    LPTSTR pszDest, 
    UINT cchDest
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    if (NULL != m_pszPath)
    {
        INT iResult = ::GetExpandedName(const_cast<TCHAR *>(m_pszPath), pszDest);
        if (0 > iResult)
            dwResult = LZERR_TO_WIN32(iResult);
    }
    else
    {
        //
        // Failed to create path string in ctor.
        //
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwResult;
}



DWORD 
CFontFileIoLz::CopyTo(
    LPCTSTR pszFileTo
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    bool bOpened   = false;          // Did we open the file?

    if (!IsOpen())
    {
        //
        // If file isn't already open, open it with READ access.
        //
        dwResult = Open(GENERIC_READ, FILE_SHARE_READ, false);
        bOpened = (ERROR_SUCCESS == dwResult);
    }

    if (ERROR_SUCCESS == dwResult)
    {
        CFontFileIoLz fileTo(pszFileTo);
        dwResult = fileTo.Open(GENERIC_WRITE, FILE_SHARE_READ, true);
        if (ERROR_SUCCESS == dwResult)
        {
            INT iResult = ::LZCopy(m_hFile, fileTo.m_hFile);
            if (0 > iResult)
                dwResult = LZERR_TO_WIN32(iResult);
        }
    }

    if (bOpened)
    {
        //
        // We opened it here.  Close it.
        //
        Close();
    }
    return dwResult;
}


//
// Convert an LZ API error code to a Win32 error code.
//
DWORD
CFontFileIoLz::LZERR_TO_WIN32(
    INT err
    )
{
    static const struct
    {
        int   lzError;
        DWORD dwError;
    } rgLzErrMap[] = {
    
         { LZERROR_BADINHANDLE,  ERROR_INVALID_HANDLE      },
         { LZERROR_BADOUTHANDLE, ERROR_INVALID_HANDLE      },              
         { LZERROR_BADVALUE,     ERROR_INVALID_PARAMETER   },
         { LZERROR_GLOBALLOC,    ERROR_NOT_ENOUGH_MEMORY   }, 
         { LZERROR_GLOBLOCK,     ERROR_LOCK_FAILED         },
         { LZERROR_READ,         ERROR_READ_FAULT          },
         { LZERROR_WRITE,        ERROR_WRITE_FAULT         } };

    for (int i = 0; i < ARRAYSIZE(rgLzErrMap); i++)
    {
        if (err == rgLzErrMap[i].lzError)
            return rgLzErrMap[i].dwError;
    }
    return DWORD(err); // FEATURE:  We should probably assert here.
}


//-----------------------------------------------------------------------------
// CFontFileIoLz
//-----------------------------------------------------------------------------
CFontFile::~CFontFile(
    void
    )
{
    delete m_pImpl; 
}


//
// This function provides the "virtual construction" for CFontFile objects.
// If the file is compressed, it creates a CFontFileIoLz object to handle
// the file I/O operations using the LZ32 library.  Otherwise it creates a 
// CFontFileIoWin32 object to handle the operations using Win32 functions.
//
DWORD
CFontFile::Open(
    LPCTSTR pszPath,
    DWORD dwAccess, 
    DWORD dwShareMode,
    bool bCreate
    )
{
    DWORD dwResult = ERROR_NOT_ENOUGH_MEMORY;

    delete m_pImpl; // Delete any existing implementation.

    m_pImpl = new CFontFileIoWin32(pszPath);
    if (NULL != m_pImpl)
    {
        bool bOpen = true;  // Do we need to call Open()?
 
        if (!bCreate)
        {
            //
            // Opening existing file.  Need to know if it's compressed or not.
            //
            dwResult = m_pImpl->Open(GENERIC_READ, FILE_SHARE_READ, false);
            if (ERROR_SUCCESS == dwResult)
            {
                if (IsCompressed())
                {
                    //
                    // File is compressed.  Destroy this io object and
                    // create one that understands LZ compression.
                    //
                    delete m_pImpl;
                    m_pImpl = new CFontFileIoLz(pszPath);
                    if (NULL == m_pImpl)
                    {
                        bOpen    = false;
                        dwResult = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else
                {
                    //
                    // It's not compressed.
                    //
                    if (GENERIC_READ == dwAccess && FILE_SHARE_READ == dwShareMode)
                    {
                        //
                        // The access attributes are the same as for the file we 
                        // already have open.  Just use the existing object.
                        //
                        Reset();
                        bOpen = false;
                    }
                    else
                    {
                        //
                        // Access attributes aren't right.  Close the current
                        // Win32 io object and re-open it with the requested access
                        // attributes.
                        //
                        m_pImpl->Close();
                    }
                }
            }
        }
        if (bOpen)
        {
            //
            // Assumes m_pImpl is not NULL.
            //
            dwResult = m_pImpl->Open(dwAccess, dwShareMode, bCreate);
        }
    }
    return dwResult;
}


void 
CFontFile::Close(
    void
    )
{
    if (NULL != m_pImpl) 
        m_pImpl->Close(); 
}


DWORD
CFontFile::Read(
    LPVOID pbDest, 
    DWORD cbDest, 
    LPDWORD pcbRead
    )
{
    if (NULL != m_pImpl)
        return m_pImpl->Read(pbDest, cbDest, pcbRead); 

    return ERROR_INVALID_ADDRESS;
}


DWORD
CFontFile::Seek(
    UINT uDistance, 
    DWORD dwMethod
    )
{ 
    if (NULL != m_pImpl)
        return m_pImpl->Seek(uDistance, dwMethod); 

    return ERROR_INVALID_ADDRESS;
}


DWORD 
CFontFile::CopyTo(
    LPCTSTR pszFileTo
    )
{
    if (NULL != m_pImpl)
        return m_pImpl->CopyTo(pszFileTo);

    return ERROR_INVALID_ADDRESS;
}


//
// Determine if the file is compressed by reading the first 8 bytes
// of the file.  Compressed files have this fixed signature.
//
bool
CFontFile::IsCompressed(
    void
    )
{
    const BYTE rgLzSig[] = "SZDD\x88\xf0\x27\x33";
    BYTE rgSig[sizeof(rgLzSig)];
    bool bCompressed = false; // Assume it's not compressed.

    if (ERROR_SUCCESS == Read(rgSig, sizeof(rgSig)))
    {
        bCompressed = true;  // Now assume it's compressed and prove otherwise.

        for (int i = 0; i < ARRAYSIZE(rgLzSig) - 1; i++)
        {
            if (rgSig[i] != rgLzSig[i])
            {
                bCompressed = false; // Not an LZ header.  Not compressed.
                break;
            }
        }
    }
    return bCompressed;
}


//
// Retrieve the "expanded" filename for a font file.  If the font file is
// compressed, this code eventually calls into the LZ32 library's 
// GetExpandedName API.  If the file is not compressed, the full path
// (as provided) is returned.  
//
DWORD 
CFontFile::GetExpandedName(
    LPCTSTR pszFile, 
    LPTSTR pszDest, 
    UINT cchDest
    )
{
    CFontFile file;
    DWORD dwResult = file.Open(pszFile, GENERIC_READ, FILE_SHARE_READ, false);
    if (ERROR_SUCCESS == dwResult)
    {
        file.Close();
        dwResult = file.m_pImpl->GetExpandedName(pszDest, cchDest);
    }

    if (ERROR_SUCCESS != dwResult)
    {
        //
        // Failed to get expanded name.
        // Ensure output buffer is nul-terminated.
        //
        if (0 < cchDest)
            *pszDest = TEXT('\0');
    }
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\fdir.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fdir.cpp
//      Explorer Font Folder extension routines
//      Implementation for the class: CFontDir
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"
#include "fdir.h"



CFontDir::CFontDir( )
   :  m_iLen( 0 ),
      m_bSysDir( FALSE )
{}


CFontDir::~CFontDir( )
{}


BOOL CFontDir::bInit( LPCTSTR lpPath, int iLen )
{

    if( iLen >= 0 && iLen <= ARRAYSIZE( m_szPath ) )
    {
        m_iLen = iLen;

        if (SUCCEEDED(StringCchCopy(m_szPath, ARRAYSIZE(m_szPath), lpPath)))
        {
            m_szPath[iLen] = 0;
            return TRUE;
        }
    }

    //
    // Error. Clean up and return.
    //
    return FALSE;
}


BOOL CFontDir::bSameDir( LPTSTR lpStr, int iLen )
{
    return( ( iLen == m_iLen ) && ( _tcsnicmp( m_szPath, lpStr, iLen ) == 0 ) );
}


LPTSTR CFontDir::lpString( )
{
    return m_szPath;
}


//-----------------------------------------------------------------------------
// CFontDirList
//-----------------------------------------------------------------------------
//
// Class representing a dynamic array of CFontDir object ptrs.
// Implemented as a singleton object through the static member
// function GetSingleton.
//
CFontDirList::CFontDirList(
    void
    ) : m_pVector(NULL)
{

}

CFontDirList::~CFontDirList(
    void
    )
{
    delete m_pVector;
}


//
// Retrieve the address of the singleton object.
//
BOOL 
CFontDirList::GetSingleton(  // [static]
    CFontDirList **ppDirList
    )
{
    static CFontDirList TheList;

    *ppDirList = NULL;
    if (NULL == TheList.m_pVector)
    {
        //
        // Singleton not yet initialized.  Initialize it.
        //
        TheList.m_pVector = new CIVector<CFontDir>(64);
        if (NULL != TheList.m_pVector)
        {
            if (!TheList.m_pVector->bInit())
            {
                delete TheList.m_pVector;
                TheList.m_pVector = NULL;
            }
        }
    }
    if (NULL != TheList.m_pVector)
    {
        //
        // Singleton is initialized.  Return it's address.
        //
        *ppDirList = &TheList;
    }
    return (NULL != *ppDirList);
}        


//
// Clear all entries from the directory list.
//
void
CFontDirList::Clear(
    void
    )
{
    m_pVector->vDeleteAll();
}


//
// Add an entry to the directory list.
//
BOOL
CFontDirList::Add(
    CFontDir *poDir
    )
{
    BOOL bAdded = FALSE;
    if (m_pVector->bAdd(poDir))
    {
        bAdded = TRUE;
    }
    else
    {
        //
        // The original font folder code cleared the list if
        // any one addition failed.
        //
        Clear();
    }
    return bAdded;
}


BOOL
CFontDirList::IsEmpty(
    void
    ) const
{
    return 0 == Count();
}


int
CFontDirList::Count(
    void
    ) const
{
    return m_pVector->iCount();
}


//
// Returns the address of the CFontDir object at 
// a given index.
//
CFontDir*
 CFontDirList::GetAt(
    int index
    ) const
{
    return m_pVector->poObjectAt(index);
}


//
// Locates and returns a given CFontDir object in the list.
//
CFontDir *
CFontDirList::Find(
    LPTSTR lpPath, 
    int iLen, 
    BOOL bAddToList  // optional.  Default == FALSE
    )
{
    //
    // Try to find the directory in the list.
    //
    CFontDir *poDir = NULL;
    const int iCnt  = Count();

    for (int i = 0; i < iCnt; i++, poDir = 0)
    {
        poDir = GetAt( i );

        if (poDir->bSameDir(lpPath, iLen))
            break;
    }

    //
    // If we didn't find one, create one and add it.
    //
    if (!poDir && bAddToList)
    {
        poDir = new CFontDir;
        if (poDir)
        {
            if (!poDir->bInit(lpPath, iLen) || !Add(poDir))
            {
                delete poDir;
                poDir = NULL;
            }
        }
    }
    return( poDir );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\instfls.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// instfls.cpp
//      Explorer Font Folder extension routines
//    This file holds all the code for installing any kind of file.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include "ui.h"
#include "cpanel.h"
#include "resource.h"

#include "dbutl.h"
#include "dblnul.h"


/*****************************************************/
/******************** Globals ************************/
/*****************************************************/

extern FullPathName_t  s_szSharedDir;
extern TCHAR           szDirOfSrc[ PATHMAX ];  // For installing

LPTSTR    pszWinDir = s_szSharedDir;
LPTSTR    pszSysDir = s_szSharedDir;

UINT  s_wBrowseDoneMsg;

TCHAR szTestOpen[] = TEXT( "a:a" );
TCHAR szDisks[]    = TEXT( "Disks" );
TCHAR szOEMDisks[] = TEXT( "OEMDisks" );
TCHAR szNull[]     = TEXT( "" );

HWND  ghwndFontDlg;

/* extern */

TCHAR szDrv[ PATHMAX ];

extern TCHAR szSetupInfPath[];
extern TCHAR szSetupDir[];

#ifdef JAPAN
extern HWND ghWndPro;
#endif


/*****************************************************/
/******************** Defines ************************/
/*****************************************************/


#define RECOVERABLEERROR (VIF_SRCOLD | VIF_DIFFLANG | VIF_DIFFCODEPG | VIF_DIFFTYPE)
#define UNRECOVERABLEERROR (VIF_FILEINUSE | VIF_OUTOFSPACE | VIF_CANNOTCREATE | VIF_CANNOTDELETE | VIF_CANNOTRENAME | VIF_OUTOFMEMORY | VIF_CANNOTREADDST)
#define READONLY (1)


/*****************************************************/
/******************** Functions **********************/
/*****************************************************/


/* Fill in the lpName string with the name of the disk specified
 * in the lpDisk string.  This name is retrieved from the [disks]
 * or [oemdisks] section of setup.inf.
 * Returns: TRUE if name was found, FALSE otherwise
 * Assumes: lpName buffer is at least PATHMAX bytes
 */

BOOL NEAR PASCAL GetInstDiskName( LPTSTR lpDisk, LPTSTR lpName, UINT cchName )
{
    if( GetPrivateProfileString( szDisks, lpDisk, szNull, lpName,
                                 cchName, szSetupInfPath ) )
      return( TRUE );

    return( GetPrivateProfileString( szOEMDisks, lpDisk, szNull, lpName,
                                     cchName, szSetupInfPath ) != 0 );
}


BOOL FAR PASCAL IsDriveReady( LPTSTR lpszPath )
{
    OFSTRUCT ofstruct;
    BOOL bReady;
//  MSG msg;


    szTestOpen[ 0 ] = lpszPath[ 0 ];
    szTestOpen[ 1 ] = lpszPath[ 1 ];

    bReady = MyOpenFile( szTestOpen[ 1 ] == TEXT( ':' )
                            ? szTestOpen
                            : szTestOpen + 2,
                            NULL,
                            0,
                            OF_PARSE ) != (HANDLE) INVALID_HANDLE_VALUE;

    if( bReady )
        bReady = MyOpenFile( lpszPath, NULL, 0, OF_EXIST )
                        != (HANDLE) INVALID_HANDLE_VALUE;

    return( bReady );
}


//
//  Hooks into common dialog to show only directories
//

UINT_PTR CALLBACK AddFileHookProc( HWND hDlg, UINT iMessage,
                               WPARAM wParam, LPARAM lParam )
{
    HWND hTemp;

    switch( iMessage )
    {
        case WM_INITDIALOG:
        {
            TCHAR szTemp[ 200 ];

            GetDlgItemText( ((LPOPENFILENAME)lParam)->hwndOwner, IDRETRY,
                            szTemp, ARRAYSIZE( szTemp ) );
            SetDlgItemText( hDlg, ctlLast+1, szTemp );

            goto PostMyMessage;
        }

        case WM_COMMAND:
            switch( wParam )
            {
                case lst2:
                case cmb2:
                case IDOK:
PostMyMessage:
                  PostMessage( hDlg, WM_COMMAND, ctlLast+2, 0L );
                  break;

                case pshHelp:
                    //
                    //  Enable this if a decision is made to add the help
                    //  information.
                    //
                    // WinHelp( hWnd, TEXT( "WINDOWS.HLP" ), HELP_CONTEXT,
                    //          IDH_WINDOWS_FONTS_BROWSE_31HELP );
                    //

                    return TRUE;
                    break;

                case ctlLast+2:
                    if( SendMessage( hTemp = GetDlgItem( hDlg, lst1 ),
                                     LB_GETCOUNT, 0, 0L ) )
                    {
                        SendMessage( hTemp, LB_SETCURSEL, 0, 0L );

                        SendMessage( hDlg, WM_COMMAND, lst1,
                                     MAKELONG( hTemp, LBN_SELCHANGE ) );
                        break;
                    }

                    SetDlgItemText( hDlg, edt1, szDrv );
                    break;
            }

            break;

        default:
            if( iMessage == s_wBrowseDoneMsg )
            {
                OFSTRUCT of;
                int fh;

                if( ( fh = LZOpenFile( szDrv, &of, OF_READ ) ) == -1 )
                {
                    iUIMsgExclaim(hDlg, IDSI_FMT_FILEFNF, (LPTSTR)szDrv );

                    //
                    //  return TRUE so commdlg does not exit
                    //
                    return( TRUE );
                }

                LZClose( fh );
            }
            break;
    }

    return FALSE;  // commdlg, do your thing
}


short nDisk=TEXT( 'A' );


VOID NEAR PASCAL FormatAddFilePrompt( LPTSTR szStr2, size_t cchStr2 )
{
    TCHAR  szString[ 256 ], szStr3[ 200 ];
    LPTSTR pszStart, pszEnd;

    //
    //  Set the prompt to specify the disk
    //

    if( nDisk && GetInstDiskName( (LPTSTR)&nDisk, szStr3, ARRAYSIZE(szStr3) )
          && (pszStart = StrChr( szStr3, TEXT( '"' ) ) )
          && (pszEnd = StrChr( ++pszStart, TEXT( '"' ) ) ) )
    {
        *pszEnd = TEXT( '\0' );

        LoadString( g_hInst, INSTALLIT, szString, ARRAYSIZE( szString ) );

        // wsprintf( szStr2, szString, (LPTSTR)pszStart, (LPTSTR)szDrv );

        LPTSTR args [ 2 ] = { pszStart, szDrv };

        FormatMessage( FORMAT_MESSAGE_FROM_STRING
                       | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       szString,
                       0,
                       0,
                       szStr2,
                       cchStr2,
                       (va_list *) args
                       );
    }
    else
    {
        LoadString( g_hInst, INSTALLIT + 1, szString, ARRAYSIZE( szString ) );
        StringCchPrintf( szStr2, cchStr2, szString, (LPTSTR)szDrv );
    }
}


INT_PTR CALLBACK AddFileDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    RECT rc;

    switch( message )
    {
    case WM_INITDIALOG:
        GetWindowRect( hDlg,&rc );

        SetWindowPos( hDlg,NULL,
                (GetSystemMetrics( SM_CXSCREEN ) - (rc.right - rc.left) ) / 2,
                (GetSystemMetrics( SM_CYSCREEN ) - (rc.bottom - rc.top) ) / 3,
                0, 0, SWP_NOSIZE | SWP_NOACTIVATE );

        SetDlgItemText( hDlg, IDRETRY,  (LPTSTR)lParam );

        SendDlgItemMessage( hDlg, COLOR_SAVE, EM_LIMITTEXT, PATHMAX - 20, 0L );

        SetDlgItemText( hDlg, COLOR_SAVE, szDirOfSrc );

        SendDlgItemMessage( hDlg, COLOR_SAVE, EM_SETSEL, 0, 0x7FFF0000 );

        if (g_bDBCS)
        {
            if( ghwndFontDlg )
            {
                TCHAR szString[ 64 ];

                LoadString( g_hInst, INSTALLIT + 2, szString, ARRAYSIZE( szString ) );

                SetWindowText( hDlg, szString );
            }
        }
        return( TRUE );

    case WM_COMMAND:
        switch( wParam )
        {
        case IDOK:
            GetDlgItemText( hDlg, COLOR_SAVE,  szDirOfSrc, ARRAYSIZE(szDirOfSrc) );

            vCPStripBlanks( szDirOfSrc, ARRAYSIZE(szDirOfSrc) );

            lpCPBackSlashTerm( szDirOfSrc, ARRAYSIZE(szDirOfSrc) );

        case IDCANCEL:
            EndDialog( hDlg, wParam == IDOK );

            return( TRUE );

        case IDD_BROWSE:
            {
                OPENFILENAME OpenFileName;
                TCHAR szPath[ PATHMAX ];
                TCHAR szFilter[ 20 ];

                // DWORD dwSave;

                int temp;
                LPTSTR lpTemp;

                szFilter[ 0 ] = TEXT( 'a' );
                szFilter[ 1 ] = TEXT( '\0' );

                StringCchCopy( szFilter+2, ARRAYSIZE(szFilter)-2, szDrv );

                if( !(lpTemp = StrChr( szFilter+2, TEXT( '.' ) ) ) )
                   lpTemp = szFilter+2+lstrlen( szFilter+2 );

                StringCchCopy( lpTemp, ARRAYSIZE(szFilter) - (lpTemp - szFilter), TEXT( ".*" ) );

                *szPath = TEXT( '\0' );

                GetDlgItemText( hDlg, COLOR_SAVE, szDirOfSrc, ARRAYSIZE(szDirOfSrc) );

                //
                //  Save context. TODO: fix. EMR
                //  dwSave = dwContext;
                //  dwContext = IDH_DLG_BROWSE;
                //

                OpenFileName.lStructSize = sizeof( OPENFILENAME );
                OpenFileName.hwndOwner = hDlg;
                OpenFileName.hInstance = g_hInst;
                OpenFileName.lpstrFilter = szFilter;
                OpenFileName.lpstrCustomFilter = NULL;
                OpenFileName.nMaxCustFilter = 0;
                OpenFileName.nFilterIndex = 1;
                OpenFileName.lpstrFile = (LPTSTR) szPath;
                OpenFileName.nMaxFile = ARRAYSIZE( szPath );
                OpenFileName.lpstrInitialDir = (LPTSTR) szDirOfSrc;
                OpenFileName.lpstrTitle = NULL;
                OpenFileName.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK |
                                     OFN_ENABLETEMPLATE |
                                     /* OFN_SHOWHELP | */ OFN_NOCHANGEDIR;
                OpenFileName.lCustData = MAKELONG( hDlg, 0 );
                OpenFileName.lpfnHook = AddFileHookProc;
                OpenFileName.lpTemplateName =(LPTSTR)MAKEINTRESOURCE( DLG_BROWSE );
                OpenFileName.nFileOffset = 0;
                OpenFileName.nFileExtension = 0;
                OpenFileName.lpstrDefExt = NULL;
                OpenFileName.lpstrFileTitle = NULL;

                temp = GetOpenFileName( &OpenFileName );

                //
                //  Restore context.
                //  TODO: FIX  -EMR
                //  dwContext = dwSave;
                //

                //
                //  force buttons to repaint
                //

                UpdateWindow( hDlg );

                if( temp )
                {
                    szPath[ OpenFileName.nFileOffset ] = TEXT( '\0' );

                    SetDlgItemText( hDlg, COLOR_SAVE, szPath );
                }
#ifdef DEBUG
                else
                {
                    StringCchPrintf( szPath, ARRAYSIZE(szPath), TEXT( "Commdlg error = 0x%04x" ),
                              temp = LOWORD( CommDlgExtendedError( ) ) );

                    if( temp )
                        MessageBox( hDlg, szPath, TEXT( "Control" ),
                                   MB_SETFOREGROUND|MB_OK|MB_ICONINFORMATION );
                }
#endif

                break;
            }
        }
        break;

        default:
            return FALSE;

    }

    //
    //  Didn't process a message
    //

    return( FALSE );
}


/* This copies a string up to a given char (not including the char)
 * into another string, up to a maximum number of chars
 * Notice that wMax includes the terminating NULL, while StrCpyN
 * does not
 */

LPTSTR FAR PASCAL CpyToChr( LPTSTR lpDest, LPTSTR lpSrc, TCHAR cChr, int iMax )
{
    LPTSTR lpch;
    int    len;

    lpch = StrChr( lpSrc, cChr );

    if( lpch )
        len = (int)(lpch - lpSrc);
    else
        len = lstrlen( lpSrc );

    iMax--;

    if( len > iMax )
        len = iMax;

    StringCchCopy( lpDest, len + 1, lpSrc );

    return lpSrc + lstrlen( lpDest );
}


/* Parse a string like '5:hppcl.drv,' into the disk and the driver
 * *nDsk gets the 5, and pszDriver gets "hppcl.drv"
 * It is assumed that the ONE byte before the ':' identifies
 * the disk, and is in '0'-'9' or 'A'-'Z'
 */

VOID FAR PASCAL GetDiskAndFile( LPTSTR pszInf,
                                short /* int */ FAR *nDsk,
                                LPTSTR pszDriver,
                                WORD wSize )
{
    LPTSTR pszTmp;

    //
    //  Determine the disk on which to find the file; note if a comma comes
    //  before a colon, there is no disk specified
    //

    if( !(pszTmp = StrChr( pszInf+1, TEXT( ':' ) ) )
        || StrRChr( pszInf+1, pszTmp, TEXT( ',' ) ) )
    {
        *nDsk = 0;
    }
    else
    {
        pszInf = pszTmp + 1;
        *nDsk  = *(pszTmp - 1 );
    }

    //
    //  Get the driver name and terminate at the TEXT( ',' )
    //

    CpyToChr( pszDriver, pszInf, TEXT( ',' ), wSize );
}


/* This attempts to set the attributes of a file; dx is set to 0
 * if the call was successful, -1 otherwise.  ax gets the attributes,
 * or the DOS error.
 */

DWORD NEAR PASCAL GetSetFileAttr( LPTSTR lpFileName, DWORD dwAttr )
{
    if( dwAttr != 0xffffffff )
        SetFileAttributes( lpFileName, dwAttr );

    return GetFileAttributes( lpFileName );
}


//
// Returns: Number of files installed.
//          0xFFFFFFFF = Operation aborted by user.
//

DWORD FAR PASCAL InstallFiles( HWND hwnd,
                               LPTSTR FAR *pszFiles,
                               int nCount,
                               INSTALL_PROC lpfnNewFile,
                               WORD wIFFlags )
{
    SHFILEOPSTRUCT fop;
    FullPathName_t szWinDir;
    TCHAR          szTmpFile[MAX_PATH];
    DWORD          dwInstalledCount = 0;
    TCHAR          szFile[MAX_PATH];
    int            i;
    int            nPass;
    BOOL           bFileExists = FALSE;
    int            iSHFileOpResult = 0;
    UINT OldErrorMode;
    CDblNulTermList listTo;
    CDblNulTermList listFiles;

    //
    //  Initialize. Set the fop struct to copy the files into
    //  the fonts directory.
    //

    if( !GetFontsDirectory( szWinDir, ARRAYSIZE( szWinDir ) ) )
        goto backout;

    //
    // SHFileOperation requires that the source and destination file
    // lists be double-nul terminated.
    //
    if (FAILED(listTo.Add(szWinDir)))
        goto backout;

    memset( &fop, 0, sizeof( fop ) );

    fop.hwnd   = hwnd;
    fop.wFunc  = FO_COPY;
    fop.pTo    = listTo;
    fop.fFlags = FOF_NOCONFIRMATION;

    for( i = 0; i < nCount; i++)
    {
        //
        // Which disk and file are we on?
        //

        GetDiskAndFile( pszFiles[ i ], &nDisk, szFile, ARRAYSIZE( szFile ) );

        vCPStripBlanks( szFile, ARRAYSIZE(szFile) );

        if( !nDisk )
        {
            LPTSTR pszEnd;

            if( !GetInstDiskName( (LPTSTR) &nDisk, szDirOfSrc, ARRAYSIZE(szDirOfSrc) )
                 || !(pszEnd = StrChr( szDirOfSrc, TEXT( ',' ) ) ) )
                goto backout;

            *pszEnd = 0;
            vCPStripBlanks( szDirOfSrc, ARRAYSIZE(szDirOfSrc) );
        }

        CharUpper( szFile );

        *szTmpFile = 0;

        //
        //  Need to check DriveReady before attempting to install the file.
        //

        nPass = 0;

        do
        {
            OldErrorMode = SetErrorMode( 1 );

            if (!PathCombine( szTmpFile, szDirOfSrc, szFile ))
                goto backout;

            bFileExists = IsDriveReady( szTmpFile );

            SetErrorMode( OldErrorMode );

            if( !bFileExists )
            {
                BOOL bUserPressedOk = FALSE;

                GetDiskAndFile( pszFiles[ i ], &nDisk,szDrv, ARRAYSIZE(szDrv));

                CharUpper( szDrv );

                //
                //  Query the user for the disk. This has to succeed or
                //  we bail.
                //

                FormatAddFilePrompt( szTmpFile, ARRAYSIZE(szTmpFile) );

                //
                //  EMR TODO fix help id.
                //

                bUserPressedOk = DoDialogBoxParam( DLG_INSTALL,
                                        hwnd,
                                        AddFileDlg,
                                        0              /* IDH_DLG_INSERT_DISK */,
                                        (LPARAM) (LPTSTR) szTmpFile );
                if( !bUserPressedOk )
                {
                    //
                    // User pressed "Cancel"
                    //
                    dwInstalledCount = (DWORD)-1;
                    goto backout;
                }
            }
        } while( !bFileExists  );

        //
        // Build the full path as a double-nul-terminated list
        // (required by SHFileOperation).
        //
        if (!PathCombine(szTmpFile, szDirOfSrc, szFile))
            goto backout;

        if (FAILED(listFiles.Add(szTmpFile)))
            goto backout;

        fop.pFrom = listFiles;

        //
        //  Copy the file
        //
        if( ( iSHFileOpResult = SHFileOperation( &fop ) ) || fop.fAnyOperationsAborted )
        {
            //
            // If operation was aborted or cancelled.
            //
            if( fop.fAnyOperationsAborted ||
              ( iSHFileOpResult == 0x75 /* DE_OPCANCELLED */) )
            {
                dwInstalledCount = (DWORD)-1;
            }
            goto backout;
        }
        else
        {
            dwInstalledCount++;  // Success!
        }
    }

backout:

    //
    //  If we cancelled, remove any of the files that we may have installed.
    //

    if( (DWORD)(-1) == dwInstalledCount)
    {
        for( int j = 0; j <= i; j++)
        {
            //
            // Which disk and file are we on?
            //

            GetDiskAndFile( pszFiles[ j ], &nDisk, szFile, ARRAYSIZE( szFile ) );
            vCPStripBlanks( szFile, ARRAYSIZE(szFile) );

            vCPDeleteFromSharedDir( szFile );
       }
    }

    return dwInstalledCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\fontlist.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fontlist.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================
#include "priv.h"
#include "globals.h"

#include "fontvect.h"
#include "fontlist.h"

#include <memory.h>     // For memcpy
#include "fontcl.h"
#include "dbutl.h"


////////////////////////////////////////////////////////////////////////////

CFontList::CFontList(
   int iSize,  // Initial number of fonts
   int iVectorSize )
   :  m_pData( 0 ),
      m_iCount( 0 ),
      m_iVectorCount( 0 ),
      m_iVectorSize( iVectorSize ),
      m_iVectorBounds( 0 )
{
    if( m_iVectorSize <= 0 )
        m_iVectorSize = kDefaultVectSize;

    m_iVectorBounds = iSize / m_iVectorSize + 1;
      
}


CFontList::~CFontList( )
{
    vDeleteAll( );

    if( m_pData )
        delete [] m_pData;
}


int CFontList::bInit( )
{
    if( m_iVectorSize && !m_iCount && m_iVectorBounds )
    {
        m_pData = new CFontVector * [ m_iVectorBounds ];

        if( m_pData )
        {
            // 
            //  Allocate one CFontVector
            //

            m_pData[ 0 ] = new CFontVector( m_iVectorSize );

            if(m_pData[0])
            {
                if (m_pData[0]->bInit())
                {
                    m_iVectorCount++;
                    return 1;
                }
                else
                {
                    delete m_pData[0];
                    m_pData[0] = NULL;
                }
            }
        }
    }
    return 0;
}


int CFontList::iCount( void )
{
    return m_iCount;
}


int CFontList::bAdd( CFontClass * t )
{
    if( t == ( CFontClass *) 0 )
        return 0;

    //
    //  Determine which vector to put it in.
    //

    int iVector = m_iCount / m_iVectorSize;

    //
    //  If the vector isn't valid, then make one.
    //

    if( iVector >= m_iVectorCount )
    {
        //
        //  Allocate more vector pointers if we're out.
        //

        if( m_iVectorCount >= m_iVectorBounds )
        {
            int iNewBounds = m_iVectorBounds + 5;

            CFontVector ** pNew = new CFontVector * [ iNewBounds ];

            if( !pNew )
                return 0;

            memcpy( pNew, m_pData, sizeof( CFontVector * ) * m_iVectorBounds );

            delete [] m_pData;
            m_pData = pNew;

            m_iVectorBounds = iNewBounds;
        }

        m_pData[ iVector ] = new CFontVector( m_iVectorSize );
        if(m_pData[iVector])
        {
            if (!m_pData[ iVector ]->bInit())
            {
                delete m_pData[iVector];
                m_pData[iVector] = NULL;
            }
        }
        if (!m_pData[iVector])
        {
            return 0;
        }

        m_iVectorCount++;

    }

    if(  m_pData[ iVector ]->bAdd( t ) )
    {
        t->AddRef();
        m_iCount++;
        return 1;
    }

    return 0;
}


CFontClass * CFontList::poObjectAt( int idx )
{
    ASSERT( this );

    if( idx >=0 && idx < m_iCount )
    {
        int iVector = idx / m_iVectorSize;

        int subIdx = idx % m_iVectorSize;

        return m_pData[ iVector ]->poObjectAt( subIdx );
    }

    return 0;
}


CFontClass * CFontList::poDetach( int idx )
{
    ASSERT( this );

    if( idx >=0 && idx < m_iCount )
    {
        int iVector = idx / m_iVectorSize;

        int subIdx = idx % m_iVectorSize;

        CFontClass * pID = m_pData[ iVector ]->poDetach( subIdx );

        //
        //  If this isn't the last vector, then move one out of the last
        //  and into this one.
        //

        if( iVector != ( m_iVectorCount - 1 ) )
        {
            m_pData[ iVector ]->bAdd( m_pData[ m_iVectorCount - 1 ]->poDetach( 0 ) );
        }

        //
        //  If the last vector is now empty, remove it.
        //

        if( ! m_pData[ m_iVectorCount - 1 ]->iCount( ) )
        {
            m_iVectorCount--;

            delete m_pData[ m_iVectorCount ];
            m_pData[ m_iVectorCount ] = 0;
        }

        ASSERT( pID );

        if( pID )
            m_iCount--;

        return pID;
    }

    return (CFontClass *) 0;
}


void CFontList::vDetachAll( )
{
    ASSERT( this );
    
    while( m_iCount )
    {
        CFontClass *poFont = poDetach( m_iCount - 1 );
        if (NULL != poFont)
            poFont->Release();
    }
}


CFontClass * CFontList::poDetach( CFontClass * t )
{
    ASSERT( this );

    return poDetach( iFind( t ) );
}


int CFontList::bDelete( int idx )
{
    ASSERT( this );

    CFontClass * pID = poDetach( idx );

    if( pID )
    {
        pID->Release();
        return 1;
    }

    return 0;
}


int CFontList::bDelete( CFontClass * t )
{
    ASSERT( this );

    return bDelete( iFind( t ) );
}


void CFontList::vDeleteAll( )
{
    ASSERT( this );

    while( m_iCount )
        bDelete( m_iCount - 1 );
}


int CFontList::iFind( CFontClass * t )
{
    int iRet;
    
    ASSERT( this );
    
    for( int i = 0; i < m_iVectorCount; i++ )
    {
       if( ( iRet = m_pData[ i ]->iFind( t ) ) != kNotFound )
          return( i * m_iVectorSize + iRet );
    }
    
    return kNotFound;
}


//
// Call CFontClass::Release for each font contained in the list.
//
void CFontList::ReleaseAll(void)
{
    CFontClass *poFont = NULL;
    for (INT i = 0; i < m_iCount; i++)
    {
        poFont = poObjectAt(i);
        if (NULL != poFont)
            poFont->Release();
    }
}

//
// Call CFontClass::AddRef for each font contained in the list.
//
void CFontList::AddRefAll(void)
{
    CFontClass *poFont = NULL;
    for (INT i = 0; i < m_iCount; i++)
    {
        poFont = poObjectAt(i);
        if (NULL != poFont)
            poFont->AddRef();
    }
}

//
// Create a clone of the list.
// Why Clone and not a copy ctor and assignment operator?
// The font folder code in general isn't very proper C++.
// Clone() is a better match to the existing code.
//
CFontList*
CFontList::Clone(
    void
    )
{
    CFontList *pNewList = new CFontList(m_iCount, m_iVectorSize);
    if (NULL != pNewList)
    {
        if (pNewList->bInit())
        {
            for (int i = 0; i < m_iCount; i++)
            {
                if (!pNewList->bAdd(poObjectAt(i)))
                {
                    delete pNewList;
                    pNewList = NULL;
                    break;
                }
            }
        }
        else
        {
            delete pNewList;
            pNewList = NULL;
        }
    }
    return pNewList;
}



/**********************************************************************
 * Some things you can do with a font list.
 */

HDROP hDropFromList( CFontList * poList )
{
    HANDLE           hMem = 0;
    LPDROPFILESTRUCT lpDrop;
    DWORD            dwSize;
    int              iCount,
                     i;
    CFontClass *     poFont;
    FullPathName_t   szPath;
    LPTSTR           lpPath;
    
    //
    //  Sanity.
    //
    if( !poList )
       goto backout0;
    
    //
    //  Walk the list and find out how much space we need.
    //

    iCount = poList->iCount( );

    if( !iCount )
        goto backout0;
    
    dwSize = sizeof( DROPFILESTRUCT ) + sizeof(TCHAR);  // size + terminating extra nul

    for( i = 0; i < iCount; i++ )
    {
        poFont = poList->poObjectAt( i );

        poFont->bGetFQName( szPath, ARRAYSIZE( szPath ) );
        dwSize += ( lstrlen( szPath ) + 1 ) * sizeof( TCHAR );

        //
        // Add length of PFB file path if this font has an associated PFB.
        // Note that bGetPFB() returns FALSE if the font isn't Type1.
        //
        if (poFont->bGetPFB(szPath, ARRAYSIZE(szPath)))
            dwSize += (lstrlen(szPath) + 1) * sizeof( TCHAR );
    }
    
    //
    //  Allocate the buffer and fill it in.
    //

    hMem = GlobalAlloc( GMEM_SHARE | GHND, dwSize );

    if( !hMem )
        goto backout0;
    
    lpDrop = (LPDROPFILESTRUCT) GlobalLock( hMem );

    lpDrop->pFiles = (DWORD)(sizeof(DROPFILESTRUCT));
    lpDrop->pt.x   = 0;
    lpDrop->pt.y   = 0;
    lpDrop->fNC    = FALSE;
    lpDrop->fWide  = TRUE;

    //
    //  Fill in the path names.
    //

    const int cchNamesMax = (dwSize - (sizeof( DROPFILESTRUCT ) + sizeof(TCHAR)))/sizeof(TCHAR);
    LPTSTR pszNamesStart = (LPTSTR)((LPBYTE)lpDrop + lpDrop->pFiles);
    lpPath = pszNamesStart;

    for( i = 0; i < iCount; i++ )
    {
        poFont = poList->poObjectAt( i );

        poFont->bGetFQName( lpPath, cchNamesMax - (lpPath - pszNamesStart));
        lpPath += lstrlen( lpPath ) + 1;

        //
        // Add PFB file path if font is a type 1.
        //
        if( poFont->bGetPFB(lpPath, cchNamesMax - (lpPath - pszNamesStart)))
            lpPath += ( lstrlen( lpPath ) + 1 );
    }

    *lpPath = TEXT('\0');       // Extra Nul terminate
    
    //
    //  Unlock the buffer and return it.
    //

    GlobalUnlock( hMem );
    
backout0:
    return (HDROP) hMem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\fsnotify.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fsnotify.cpp
//      Explorer Font Folder extension routines
//     Routines to watch the Fonts directory and handle change notifications.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#if defined(__FCN__)

#include "fsnotify.h"
#include "fontman.h"

#include "dbutl.h"

#ifdef DEBUG
int iCount = 0;
#endif  // DEBUG


//------------------------------------------------------------------------
// FUNCTION:   dwNotifyWatchProc
//
// PURPOSE:    Watch a directory and notify the CFontManager when something
//             has changed.
//------------------------------------------------------------------------
DWORD dwNotifyWatchProc( LPVOID pvParams )
{
    DWORD dwRet;
    BOOL  bFileChange = FALSE;
    BOOL bDone = FALSE;
    CFontManager *pFontManager = (CFontManager *)pvParams;

    DEBUGMSG( (DM_TRACE2, TEXT( "dwNotifyWatchProc called" ) ) );
    
    if (NULL == pFontManager)
        return (DWORD)-1;

    HANDLE rgHandles[] = { pFontManager->m_hEventTerminateThreads,
                           pFontManager->m_Notify.m_hWatch };
    while(!bDone)
    {
        //
        //  Wait for the FONTS folder to change. If we time out, then attempt
        //  to undo any deletions that might be occuring.
        //                      
        dwRet = WaitForMultipleObjects(ARRAYSIZE(rgHandles), 
                                       rgHandles, 
                                       FALSE, 
                                       1500);

        if (WAIT_TIMEOUT == dwRet)
        {
            // DEBUGMSG( (DM_TRACE2, TEXT( "dwNotifyWatchProc: main loop - Timeout from WaitForSingleObject - iteration %d" ), ++iCount ) );

            if( !pFontManager->bCheckTBR( ) )
                pFontManager->vUndoTBR( );
        
            //
            //  Go through the fonts directory and make sure it's in a
            //  stable condition.
            //

            if( bFileChange )
            {
                bFileChange = FALSE;
                pFontManager->vReconcileFolder( THREAD_PRIORITY_NORMAL );
            }
        }
        else switch(dwRet - WAIT_OBJECT_0)
        {
            case 0:
                //
                // "Terminate-threads" event was set.  Time to go home.
                //
                bDone = true;
                break;
                
            case 1:
                //
                //  Things be happenin'. We could call bCheckTBR() at this
                //  point, but we might as well wait for a time out and do
                //  it all at once. Doing nothing just causes us to wait 
                //  another 1.5 secs; i.e. reset the timeout.
                //
                bFileChange = TRUE;

                //
                //  Since an event came in, reset the Change Notification to
                //  watch it some more.  This call should NOT be done during
                //  the TIMEOUT because it causes another change packet under
                //  WinNT and an undesireable race condition under Win 95.
                //  (Note:  The extra change packets under WinNT are allocated
                //   out of Non-paged pool memory and excessive requests can
                //   use up the processes non-paged pool memory quota, and
                //   then the fun really begins with the app.)  [stevecat]
                //
        
                if( !FindNextChangeNotification(pFontManager->m_Notify.m_hWatch))
                {
                    DEBUGMSG( (DM_ERROR, TEXT( "dwNotifyWatchProc: FindNextChangeNotification FAILED - error = %d" ), GetLastError( ) ) );
                }
        
                DEBUGMSG( (DM_TRACE2, TEXT( "dwNotifyWatchProc: FindNextChangeNotification called - handle = 0x%x" ), pFontManager->m_Notify.m_hWatch));
        
                //
                // Wait 'til next 1.5 second timeout to do anything.
                //
                break;
                
            default:
                    break;
        }
    }

    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);    
    return 0;
}

#endif   // __FCN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\fontman.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fontman.cpp
//      Explorer Font Folder extension routines.
//      Implementation for the class: CFontManager
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-93 ElseWare Corporation.    All rights reserved.
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include <shlobjp.h>
#include <setupapi.h>
#include "fontman.h"
#include "fontlist.h"
#include "fontcl.h"
#include "panmap.h"
#include "cpanel.h"
#include "strtab.h"

#include "dbutl.h"
#include "resource.h"


#define ECS    EnterCriticalSection( &m_cs )
#define LCS    LeaveCriticalSection( &m_cs )

static TCHAR s_szKey1[] = TEXT( "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts" );
static TCHAR s_szKeyFontDrivers[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Font Drivers");
static TCHAR s_szKey2[] = TEXT( "Display\\Fonts" );
static TCHAR s_szINISFonts[] = TEXT( "fonts" );

/***************************************************************************
 * METHOD:  bKeyHasKey
 *
 * PURPOSE: Determine if the key exists in the registry.
 *
 * RETURNS: the number of bytes written into the buffer.
 *
 ***************************************************************************/

BOOL bKeyHasKey( HKEY          hk,
                 const TCHAR * pszKey,
                 TCHAR       * pszValue,
                 int           iValLen )
{
    DWORD  i;
    TCHAR  szKey[ 80 ];
    DWORD  dwKey,
           dwValue,
           dwKeyLen;
    DWORD  dwErr;
    int    iFound = 0;

    dwKeyLen = lstrlen( pszKey );

    i = 0;

    while( TRUE )
    {
        dwKey   = ARRAYSIZE( szKey );

        dwValue = iValLen * sizeof( TCHAR );

        dwErr = RegEnumValue( hk, i, szKey, &dwKey, NULL,
                              NULL, (LPBYTE)pszValue, &dwValue );

        if( dwErr == ERROR_NO_MORE_ITEMS )
            break;
        else if( dwErr == ERROR_SUCCESS )
        {
            //
            //  Null terminate it.
            //

            szKey[ dwKey ] = 0;

            //
            //  Check to see if this is the one we want.
            //

            if( dwKey == dwKeyLen )
            {
                if( ( iFound = !lstrcmpi( szKey, pszKey ) ) )
                    break;
            }
        }

        //
        //  Move on to the next one.
        //

        i++;
    }

    return (int)iFound;
}


BOOL bRegHasKey( const TCHAR * pszKey, TCHAR * pszValue = NULL, int iValLen = 0 );


BOOL bRegHasKey( const TCHAR * pszKey, TCHAR * pszValue, int iValLen )
{
    HKEY  hk;
    BOOL  bHasKey = FALSE;
    FullPathName_t szPath;

    if( !pszValue )
    {
        pszValue = szPath;
        iValLen  = ARRAYSIZE( szPath );
    }

    //
    //  Check standard 'fonts' registry list to see if font is
    //  already installed.
    //

    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_szKey1, 0,
                                       KEY_READ, &hk ) )
    {
        bHasKey = bKeyHasKey( hk, pszKey, pszValue, iValLen );
        RegCloseKey( hk );
    }
    //
    //  If we still don't have it, try from the WIN.INI file.
    //

    if( !bHasKey )
    {
        bHasKey = (BOOL) GetProfileString( s_szINISFonts, pszKey, TEXT( "" ),
                                           pszValue,
                                           iValLen );
    }
    return bHasKey;
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

BOOL  WriteToRegistry( LPTSTR lpValue, LPTSTR lpData )
{
    HKEY  hk;
    LONG  lRet;


    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_szKey1, 0,
                                       KEY_SET_VALUE, &hk ) )
    {
        if( lpData )
            lRet = RegSetValueEx( hk, lpValue, 0, REG_SZ,
                                  (const LPBYTE)lpData,
                                  (lstrlen( lpData ) + 1) * sizeof( TCHAR ) );
        else
        {
            lRet = RegDeleteValue( hk, lpValue );
        }

        RegCloseKey( hk );
        return( lRet == ERROR_SUCCESS );
    }

    return FALSE;
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

CFontManager::CFontManager( )
   :  m_poFontList( 0 ),
      m_poTempList( 0 ),
      m_poPanMap( 0 ),
      m_bTriedOnce( FALSE ),
      m_bFamiliesNeverReset( TRUE ),
      m_poRemoveList( 0 ),
      m_hNotifyThread( 0 ),
      m_hReconcileThread( 0 ),
      m_hResetFamThread( 0 ),
      m_hMutexResetFamily( 0 ),
      m_hMutexInstallation( 0 ),
      m_hEventTerminateThreads(NULL)
{
    m_Notify.m_hWatch    = INVALID_HANDLE_VALUE;

    m_hMutexResetFamily = CreateMutex( NULL, FALSE, NULL );
    m_hEventResetFamily = CreateEvent( NULL, TRUE, FALSE, NULL );
    m_hMutexInstallation = CreateMutex( NULL, FALSE, NULL );
    m_hEventTerminateThreads  = CreateEvent(NULL, TRUE, FALSE, NULL);

    InitializeCriticalSection( &m_cs );
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

CFontManager::~CFontManager( )
{
    //
    // Set the "terminate-all-threads" event.
    // Any threads in this module will recognize this event and 
    // immediately terminate their processing in a normal fashion.
    //
    // The order of these "SetEvent" calls is CRITICAL.  Must 
    // set the "terminate threads" event first.
    //
    if (NULL != m_hEventTerminateThreads)
    {
        SetEvent(m_hEventTerminateThreads);
    }
    if (NULL != m_hEventResetFamily)
    {
        SetEvent(m_hEventResetFamily);
    }        
    //
    // Wait for all active threads to terminate.
    //
    HANDLE rghThreads[3];
    int cThreads = 0;
    if (NULL != m_hNotifyThread)
        rghThreads[cThreads++] = m_hNotifyThread;
    if (NULL != m_hResetFamThread)
        rghThreads[cThreads++] = m_hResetFamThread;
    if (NULL != m_hReconcileThread)
        rghThreads[cThreads++] = m_hReconcileThread;

    DWORD dwWait = WaitForMultipleObjects(cThreads, rghThreads, TRUE, INFINITE);
        
    if( m_hNotifyThread )
    {
        CloseHandle( m_hNotifyThread );
    }
    if( m_hReconcileThread )
    {
        CloseHandle( m_hReconcileThread );
    }
    if( m_hResetFamThread )
    {
        CloseHandle( m_hResetFamThread );
    }

    ECS;
    if( m_Notify.m_hWatch != INVALID_HANDLE_VALUE )
    {
        if( !FindCloseChangeNotification( m_Notify.m_hWatch ) )
        {
            DEBUGMSG( (DM_ERROR, TEXT( "CFontManager:~CFontManager FindCloseChangeNotification FAILED - error = %d Handle = 0x%x" ), GetLastError( ), m_Notify.m_hWatch ) );
        }

        DEBUGMSG( (DM_TRACE2, TEXT( "CFontManager:~CFontManager FindCloseChangeNotification called" ) ) );
    }

    if( m_poFontList )
    {
        delete m_poFontList;
        m_poFontList = 0;
    }

    if( m_poPanMap )
    {
        m_poPanMap->Release( );
    }

    if( m_poTempList )
        delete m_poTempList;

    if( m_poRemoveList )
        delete m_poRemoveList;

    LCS;

    if (NULL != m_hMutexResetFamily)
        CloseHandle( m_hMutexResetFamily );

    if (NULL != m_hEventResetFamily)
        CloseHandle( m_hEventResetFamily );

    if (NULL != m_hMutexInstallation)
        CloseHandle( m_hMutexInstallation );

    if (NULL != m_hEventTerminateThreads)
        CloseHandle(m_hEventTerminateThreads);

    DeleteCriticalSection( &m_cs );
}



//
// GetOrReleaseFontManager
//
// Used by both GetFontManager and ReleaseFontManager.  I have both functions
// calling into this single function so we can control the scope of the 
// single CFontManager ptr and reference counter to a single function.
//
// Here's the scoop:
// The font folder uses a single CFontManager object.  The original code
// created it in the extinit code, destroyed it on process detach 
// and accessed it through a global pointer.  While not the best way
// to manage a singleton, this worked for Win9x and NT4.  In NT5 fontext.dll
// now implements an icon handler.  Therefore, fontext.dll is ALWAYS
// loaded in explorer.exe and the global font manager wasn't being destroyed
// until logoff because process-detach code in explorer.exe is only invoked 
// at logoff.
// 
// I added reference counting and centralized the access to the singleton
// font manager so that it's created on demand and destroyed when the last
// client is finished with it.  I made the CFontManager ctor private to
// enforce the use of the GetFontManager API.
// I also added code so that the manager's threads are now shut down in 
// an orderly fashion.  The original implementation merely called 
// TerminateThread() in the font manager's dtor (bad).  
// 
// [brianau - 6/5/99]
//
extern CRITICAL_SECTION g_csFontManager; // defined in fontext.cpp

HRESULT GetOrReleaseFontManager(CFontManager **ppoFontManager, bool bGet)
{
    static CFontManager *pSingleton;
    static LONG cRef = 0;
    
    HRESULT hr = NOERROR;
    EnterCriticalSection(&g_csFontManager);
    if (bGet)
    {
        if (NULL == pSingleton)
        {
            //
            // No manager exists.  Create it.
            //
            pSingleton = new CFontManager();
            if (NULL != pSingleton)
            {
                if (!pSingleton->bInit())
                {
                    delete pSingleton;
                    pSingleton = NULL;
                }
            }
        }
        if (NULL != pSingleton)
        {
            *ppoFontManager = pSingleton;
            cRef++;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppoFontManager = NULL;
        if (0 == (--cRef))
        {
            //
            // Last reference to manager.
            // Delete it.
            //
            delete pSingleton;
            pSingleton = NULL;
        }
    }
    LeaveCriticalSection(&g_csFontManager);
    return hr;
}

HRESULT GetFontManager(CFontManager **ppoFontManager)
{
    return GetOrReleaseFontManager(ppoFontManager, true);
}

void ReleaseFontManager(CFontManager **ppoFontManager)
{
    GetOrReleaseFontManager(ppoFontManager, false);
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/
BOOL CFontManager::bInit( )
{
    //
    // Load up the font list and request to receive file system change
    // notifications so we can react to new files added to the fonts directory.
    //
    DWORD idThread;
    if ( bLoadFontList() )
    {
         FullPathName_t szPath;

         GetFontsDirectory( szPath, ARRAYSIZE( szPath ) );
         //
         // Is a loadable Type1 font driver installed?
         // Result can be retrieved through CFontManager::Type1FontDriverInstalled().
         //
         CheckForType1FontDriver();

         m_Notify.m_hWatch    = FindFirstChangeNotification( szPath, 0, FILE_NOTIFY_CHANGE_FILE_NAME );

         DEBUGMSG( (DM_TRACE2, TEXT( "CFontManager:bInit FindFirstChangeNotification called" ) ) );

         if( m_Notify.m_hWatch != INVALID_HANDLE_VALUE )
         {
              //
              //  Launch a Background thread to keep an eye on it.
              //

              FindNextChangeNotification( m_Notify.m_hWatch );

              DEBUGMSG( (DM_TRACE2, TEXT( "CFontManager:bInit FindNextChangeNotification called - creating Notify thread" ) ) );
              DEBUGMSG( (DM_TRACE2, TEXT( "CFontManager:bInit ChangeNotification Handle = 0x%x" ), m_Notify.m_hWatch ) );
              
              InterlockedIncrement(&g_cRefThisDll);
              m_hNotifyThread = CreateThread( NULL,
                                       0,
                                      (LPTHREAD_START_ROUTINE)dwNotifyWatchProc,
                                      (LPVOID)this,
                                       0,                  // CREATE_NO_WINDOW,
                                       &idThread);
              if (NULL == m_hNotifyThread)
              {
                  ASSERT( 0 != g_cRefThisDll );
                  InterlockedDecrement(&g_cRefThisDll);
              }
         }
         //
         //  Launch a background process to reconcile any new font files
         //  that have been dropped in the FONTS folder.
         //  Only do this if font list is valid.  Reconciliation requires
         //  that the font list exists.
         //
         vReconcileFolder( THREAD_PRIORITY_LOWEST );
    }

    //
    //  Start a thread that resets the font family information. This thread
    //  is activated by pulsing the m_hEventResetFamily handle. It runs at
    //  the lowest priority unless the main (UI) thread is waiting on it.
    //
    InterlockedIncrement(&g_cRefThisDll);
    m_hResetFamThread = CreateThread(
                                  NULL,
                                  0,
                                  (LPTHREAD_START_ROUTINE)dwResetFamilyFlags,
                                  (LPVOID)this,
                                  0, // CREATE_NO_WINDOW,
                                  &idThread);

    if( m_hResetFamThread )
    {
        SetThreadPriority( m_hResetFamThread, THREAD_PRIORITY_LOWEST );
    }
    else
    {
        ASSERT( 0 != g_cRefThisDll );
        InterlockedDecrement(&g_cRefThisDll);
    }

    //
    //  Even if the notify doesn't work, return OK.
    //

    return TRUE;
}


static DWORD dwReconcileThread(LPVOID pvParams)
{
    CFontManager* pFontManager = (CFontManager *)pvParams;
    if (NULL != pFontManager)
    {
        pFontManager->vDoReconcileFolder();
    }
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
    return 0;
}


VOID CFontManager::vReconcileFolder( int iPriority )
{
    DWORD idThread;
    
    ECS;

    //
    //  If one is running reset its priority and return.
    //

    if( m_hReconcileThread )
    {
        SetThreadPriority( m_hReconcileThread, iPriority );
        LCS;
        return;
    }

    //
    //  Always do this in the background, if possible.
    //
    InterlockedIncrement(&g_cRefThisDll);
    m_hReconcileThread = CreateThread(
                                    NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE) dwReconcileThread,
                                    (LPVOID) this,
                                    0,              // CREATE_NO_WINDOW,
                                    &idThread);
    LCS;

    //
    //  At statup we want this to idle in the backgound. Most other times it
    //  runs at normal priority.
    //

    if( m_hReconcileThread )
    {
        SetThreadPriority( m_hReconcileThread, iPriority );
    }
    else
    {
        ASSERT( 0 != g_cRefThisDll );
        InterlockedDecrement(&g_cRefThisDll);
        vDoReconcileFolder( );
    }
}


BOOL bValidFOTFile( LPTSTR szFull, LPTSTR szLHS, size_t cchLHS, BOOL *pbTrueType, LPDWORD lpdwStatus = NULL)
{
    LPCTSTR pszExt = PathFindExtension( szFull );

    //
    // Initialize status return.
    //
    if (NULL != lpdwStatus)
       *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_STATUS, FVS_FILE_UNK);


    if( !pszExt || lstrcmpi( pszExt, TEXT( ".fot" ) ) != 0 )
    {
        if (NULL != lpdwStatus)
            *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);

        return( FALSE );
    }

    FontDesc_t szDesc;

    WORD wType;


    if( !::bCPValidFontFile( szFull, szDesc, ARRAYSIZE(szDesc), &wType, TRUE, lpdwStatus ) )
    {
        return( FALSE );
    }

    *pbTrueType = TRUE;

    if (FAILED(StringCchPrintf( szLHS, cchLHS, c_szDescFormat, (LPTSTR) szDesc, c_szTrueType )))
    {
        return( FALSE );
    }

    return( TRUE );
}


VOID CFontManager::vDoReconcileFolder( )
{
    HANDLE            hSearch;
    WIN32_FIND_DATA   fData;
    FullPathName_t    szPath;
    FullPathName_t    szWD;
    BOOL              bAdded = FALSE;
    BOOL              bChangeNotifyRequired = FALSE;

    //
    // Load the list of hidden font file names from FONT.INF.
    // This initialization is done here on the background thread
    // so we don't steal cycles from the UI.
    //
    HRESULT hr;
    ECS;
    hr = m_HiddenFontFilesList.Initialize();
    LCS;
    if (FAILED(hr))
    {
        return;
    }

    GetFontsDirectory( szPath, ARRAYSIZE( szPath ) );

    if (FAILED(StringCchCat( szPath, ARRAYSIZE(szPath), TEXT( "\\*.*" ) )))
    {
        return;
    }

    //
    //  Process each file in the directory.
    //
    //  Reasons for getting here:
    //   - File was copied into Fonts folder, but not installed.
    //

    ///////////////////////////////////////////////////////////////////
    //
    // NOTE: [brianau]
    //
    // There was a condition in the original font folder where not all
    // fonts in a set of manually-added fonts would be installed by the
    // reconciliation process.  Given the following scenario and invariants:
    //
    // Scenario:
    //    Installing a large set of fonts manually with COPY command while
    //    installing a set of fonts through the font folder interface.
    //
    // Invariants:
    //    In response to a file sys change notification, the watch thread
    //    either starts the reconcile thread (if not active) or sets its
    //    priority if already active.
    //    The reconcile loop uses the FindFirstFile/FindNextFile functions
    //    to obtain names of files in the fonts directory.  FindNextFile
    //    returns information on the next file it encounters in the
    //    directory in alphabetical name order.
    //
    // The Problem:
    //    If a font file is being added to the fonts directory while the
    //    FindFirst/FindNext loop is active and it's name is lexically
    //    "less than" the file currently being returned by FindNextFile,
    //    it will be skipped by the FindFirst/FindNext processing and
    //    will not be installed.  Since the file sys notifications arrive
    //    in rapid succession while the reconcile loop is active,  the
    //    loop is never re-started (only thread priority is set).  Therefore,
    //    these missed fonts are never added.  However, they will be
    //    installed the next time the reconcile thread is started.
    //
    // Possible solutions:
    //    Replace the reconcile loop with a single installation function
    //    that is called each time a notification is received via
    //    ReadDirectoryChanges().  ReadDirectoryChangesW() is a new NT
    //    API similar to FindFirstChangeNotification/FindNextChangeNotification
    //    except it returns detailed information about the file that
    //    triggered the change notification.  This would eliminate the
    //    need for scanning the entire directory.
    //
    //    I added the existing "hack" of repeating the loop until no more
    //    fonts can be added.  It's not as clean as the ReadDirectoryChanges()
    //    fix but it works with the existing code.  Since we're on a
    //    background thread, the user won't notice the extra iterations.
    //
    //    I think we should replace this hack with the ReadDirectoryChanges
    //    solution when possible.
    ///////////////////////////////////////////////////////////////////
    do {
        bAdded = FALSE;

        hSearch = FindFirstFile( szPath, &fData );

        if( hSearch != INVALID_HANDLE_VALUE )
        {
            GetFontsDirectory( szWD, ARRAYSIZE( szWD ) );

            //
            //  We can't use Get/SetCurrent directory because we might
            //  hose the main UI thread. Most notably the Common File
            //  Dialog.
            //
            //  GetCurrentDirectory( ARRAYSIZE( szCD ), szCD );
            //  SetCurrentDirectory( szWD );
            //
            do
            {
                //
                // poSearchFontListFile needs a valid m_poFontList.
                //
                ASSERT(NULL != m_poFontList);

                //
                // Wait for mutex so we don't have multiple threads installing
                // fonts concurrently.  Aquire and release mutex for each font.
                // This will minimize blocking time for other waiting threads.
                // Since we're on a background thread, we don't mind waiting
                // a while for the mutex (5 seconds).
                //
                if ( MUTEXWAIT_SUCCESS == dwWaitForInstallationMutex(5000) )
                {
                    //
                    // See if the Font Manager knows about this font. If not,
                    // then install it.
                    //
                    if( fData.cFileName[ 0 ] != TEXT( '.' ) &&
                         !poSearchFontListFile( fData.cFileName ) &&
                         ShouldAutoInstallFile( fData.cFileName, fData.dwFileAttributes ) )
                    {

                        FullPathName_t szFull;
                        FontDesc_t     szLHS;
                        BOOL           bTrueType;
                        WORD           wType;

                        if (!PathCombine(szFull, szWD, fData.cFileName))
                        {
                            //
                            // Couldn't successfully build the path name.  
                            // Truncate to empty string so that we don't try to
                            // process an incomplete path.
                            //
                            szFull[0] = 0;
                        }

                        //
                        //  Check to see if this is a valid font file.
                        //  Don't call CPDropInstall() 'cause we don't want any UI
                        //  coming up.
                        //
                        //  bCPDropInstall( m_poFontMan, szFull );
                        //

                        if( ::bCPValidFontFile( szFull, szLHS, ARRAYSIZE(szLHS), &wType )
                               || bValidFOTFile( szFull, szLHS, ARRAYSIZE(szLHS), &bTrueType ) )
                        {
                            //
                            //  Make sure it's not already in the registry, possibly
                            //  from another file
                            //

                            if(wType == TYPE1_FONT)
                            {
                                //
                                //  Check registry font entries under the
                                //  Type 1 Installer
                                //

                                if( !CheckT1Install( szLHS, NULL, 0 ) )
                                {
                                    FullPathName_t szPfbFile;

                                    if( IsPSFont( szFull, (LPTSTR) NULL, 0, (LPTSTR) NULL, 0,
                                                  szPfbFile, ARRAYSIZE(szPfbFile), (BOOL *) NULL) )
                                    {
                                        if (Type1FontDriverInstalled())
                                        {
                                            TCHAR szType1FontResourceName[MAX_TYPE1_FONT_RESOURCE];

                                            if (BuildType1FontResourceName(
                                                    szFull,
                                                    szPfbFile,
                                                    szType1FontResourceName,
                                                    ARRAYSIZE(szType1FontResourceName)))
                                            {
                                                AddFontResource(szType1FontResourceName);
                                            }
                                        }
                                        if( WriteType1RegistryEntry( NULL, szLHS, szFull,
                                                                     szPfbFile, TRUE ) )
                                        {
                                            bAdded = TRUE;
                                        }
                                    }
                                }
                            }
                            else if( !bRegHasKey( szLHS ) )
                            {
                                if( AddFontResource( fData.cFileName ) )
                                {
                                    if (WriteToRegistry( szLHS, fData.cFileName ))
                                        bAdded = TRUE;
                                    else
                                        RemoveFontResource(fData.cFileName);
                                }
                            }
                        }

                        //
                        //  TODO. Should we remove the file if it isn't a font file or
                        //  shouldn't be in this directory?
                        //
                        //  [stevecat] DO NOT delete extraneous files from this dir
                        //   on WINNT because we recognize .PFM files as the main
                        //   Type 1 file but the matching .PFB file may also be present
                        //   for use by the Postscript printer driver.
                        //
                    }
                    //
                    // Let some other thread install a font.
                    // WARNING:  Don't miss this call with an early return.
                    //           (break, goto, return)
                    //
                    bReleaseInstallationMutex();
               }
               else
               {
                    //
                    // I have yet to see this thread not get the mutex.
                    // But, just in case it doesn't, give up on installing
                    // this font.
                    // Note that we don't inform the user since this is a background
                    // thread that the user isn't aware of.
                    //
               }

           } while( FindNextFile( hSearch, &fData ) );

           // SetCurrentDirectory( szCD );

           FindClose( hSearch );
        }
        //
        // We need to post a font change notification if any fonts
        // have been added.
        //
        bChangeNotifyRequired = bChangeNotifyRequired || bAdded;
    } while (TRUE == bAdded);

    //
    //  For all practical purposes, we're done.
    //

    ECS;

    if( m_hReconcileThread )
    {
        CloseHandle( m_hReconcileThread );
        m_hReconcileThread = 0;
    }
  
    //
    // Destroy contents of hidden files list.
    // Folder reconciliation is the only time this table is used so
    // we don't need to keep the strings in memory when they're not
    // needed.
    // It will be re-created next time vDoReconcileFolder is called.
    //
    m_HiddenFontFilesList.Destroy();
    LCS;

    if( bChangeNotifyRequired )
        vCPWinIniFontChange( );
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/
VOID CFontManager::ProcessRegKey( HKEY hk, BOOL bCheckDup )
{

    DWORD          i;
    int            idx;
    FontDesc_t     szValue = {0};
    DWORD          dwValue;
    FullPathName_t szData = {0};
    DWORD          dwData;


    for( i = 0; ; ++i )
    {
        dwValue = ARRAYSIZE( szValue );
        dwData  = sizeof( szData );

        LONG lRet = RegEnumValue( hk, i, szValue, &dwValue,
                                  NULL, NULL, (LPBYTE) szData, &dwData );

        if( lRet == ERROR_MORE_DATA )
        {
            //
            //  I guess I'm just going to skip this guy.
            //  It's mostly invalid anyway
            //

            continue;
        }
        else if (lRet != ERROR_SUCCESS)
        {
            //
            //  I assume this is ERROR_NO_MORE_ITEMS
            //

            break;
        }

        if( szValue[ 0 ] )
        {

            if( bCheckDup )
            {
                if( ( idx = iSearchFontListLHS( szValue ) ) >= 0 )
                {
                    if( m_poTempList )
                    {
                        CFontClass *poFont = m_poFontList->poDetach(idx);
                        if (poFont)
                        {
                            m_poTempList->bAdd(poFont);
                            poFont->Release();  // Release from m_poFontList.
                        }
                    }


                    continue;
                }
            }

            poAddToList( szValue, szData );
        }
    }
}


/***************************************************************************
 * METHOD:  ProcessT1RegKey
 *
 * PURPOSE: Crack REG_MULTISZ Type registry value entry and look for dups
 *
 * RETURNS:
 *
 ***************************************************************************/

VOID CFontManager::ProcessT1RegKey( HKEY hk, BOOL bCheckDup )
{
    DWORD          i = 0;
    int            idx;
    TCHAR          szValue[ PATHMAX ] = {0};
    DWORD          dwValue = ARRAYSIZE( szValue );
    TCHAR          szData[ 2 * PATHMAX + 10 ] = {0};
    DWORD          dwData = sizeof( szData );
    FullPathName_t szPfmFile;
    FullPathName_t szPfbFile;


    while( ERROR_SUCCESS == RegEnumValue( hk, i, szValue, &dwValue, NULL,
                                          NULL, (LPBYTE)szData, &dwData ) )
    {
        if( szValue[ 0 ] )
        {
            if( bCheckDup )
            {
                if( ( idx = iSearchFontListLHS( szValue ) ) >= 0 )
                {
                    if( m_poTempList )
                    {
                        CFontClass *poFont = m_poFontList->poDetach(idx);
                        m_poTempList->bAdd(poFont);
                        poFont->Release();  // Release from m_poFontList.
                    }

                    goto MoveOn;
                }
            }

            //
            //  For Type 1 font entries, extract PFM and PFB font file
            //  names for storage in the class object.
            //

            if( ::ExtractT1Files( szData, szPfmFile, ARRAYSIZE(szPfmFile), szPfbFile, ARRAYSIZE(szPfbFile) ) )
                poAddToList( szValue, szPfmFile, szPfbFile );
        }
MoveOn:
        //
        //  Move on to the next one.
        //

        ZeroMemory(szData, sizeof(szData));
        ZeroMemory(szValue, sizeof(szValue));
        dwValue = ARRAYSIZE( szValue );
        dwData  = sizeof( szData );
        i++;
    }
}


/***************************************************************************
 * METHOD:  bRefresh
 *
 * PURPOSE: Re-read the win.ini and registry to determine if fonts have
 *          been added.
 *
 *          If we're checking for dups, move them to m_poTempList as we
 *          find them. Then move them back when we're all done.
 *
 * RETURNS:
 *
 ***************************************************************************/
BOOL CFontManager::bRefresh( BOOL bCheckDup )
{
    //
    //  Load the Font List.
    //

    static BOOL  s_bInRefresh = FALSE;
    TCHAR        szFonts[] = TEXT( "FONTS" );
    PTSTR        pszItem;                          // pointer into buffer
    PATHNAME     szPath;
    HANDLE       hLocalBuf;
    PTSTR        pLocalBuf, pEnd;
    DWORD        nCount;
    int          idx;

    //
    //  Don't reenter this puppy. If we're already in here (either this thread
    //  or another) the caller won't be able to get the list until it's
    //  available in a consistent state.
    //

    if( s_bInRefresh )
        return TRUE;

    s_bInRefresh = TRUE;

    //
    //  If we're checking for dups, then allocate the temp list to put them
    //  in. If we can't allocate one, just don't use it.
    //

    if( bCheckDup && !m_poTempList )
    {
        m_poTempList = new CFontList( m_poFontList->iCount( ) );

        if(m_poTempList)
        {
            if (!m_poTempList->bInit())
            {
                delete m_poTempList;
                m_poTempList = NULL;
            }
        }
    }

    //
    //  Process the WIN.INI file first.
    //

    nCount = GetSection( NULL, szFonts, &hLocalBuf );

    if( !hLocalBuf )
    {
        iUIErrMemDlg(NULL);
        s_bInRefresh = FALSE;

        return FALSE;
    }

    ECS;

    pLocalBuf = (PTSTR) LocalLock( hLocalBuf );

    pEnd = pLocalBuf + nCount;

    //
    //  Add all the fonts in the list, if they haven't been added already
    //

    for( pszItem = pLocalBuf; pszItem < pEnd; pszItem += lstrlen( pszItem )+1 )
    {
        if( !*pszItem )
            continue;

        if( bCheckDup )
        {
            if( ( idx = iSearchFontListLHS( pszItem ) ) >= 0 )
            {
                if( m_poTempList )
                {
                    CFontClass *poFont = m_poFontList->poDetach(idx);
                    m_poTempList->bAdd(poFont);
                    poFont->Release(); // Release from m_poFontList.
                }
                continue;
            }
        }

        GetProfileString( szFonts, pszItem, TEXT( "" ), szPath,
                          ARRAYSIZE( szPath ) );

        //
        //  there's a RHS here
        //

        if( *szPath )
        {
            poAddToList( pszItem, szPath, NULL );
        }
    }

    LocalUnlock( hLocalBuf );

    LocalFree  (hLocalBuf );

    //
    //  Now, process the entries in the Registry. There are two locations:
    //  one that holds the display fonts and one that holds the TT fonts.
    //

    HKEY     hk;

    //
    //  Process Type 1 fonts registry location
    //

    if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, g_szType1Key, 0,
                                       KEY_READ, &hk ) )
    {
        ProcessT1RegKey( hk, bCheckDup );
        RegCloseKey( hk );
    }
    //
    //  If we put some things in m_poTempList, put them back in the main list.
    //

    if( m_poTempList )
    {
        int iCount = m_poTempList->iCount( );
        int i;

        for( i = iCount - 1; i >= 0; i-- )
        {
            CFontClass *poFont = m_poTempList->poDetach(i);
            m_poFontList->bAdd(poFont);
            poFont->Release(); // Release from m_poTempList.
        }
    }

    LCS;

    //
    //  Reset the family connections.
    //

    vResetFamilyFlags( );

    s_bInRefresh = FALSE;

    return TRUE;
}


/*************************************************************************
 * METHOD:  vToBeRemoved
 *
 * PURPOSE: Set the TBR list to poList. The font manager owns the list at
 *          this point. If there is already a TBR list, then this one is
 *          merged with the current one and deleted.
 *
 * RETURNS: Nothing.
 *************************************************************************/

void CFontManager::vToBeRemoved( CFontList * poList )
{
    int   iCount;
    int   i;

    CFontClass * poFont;

    //
    //  Quick check for valid pointer.
    //
    if( !poList )
       return;

    ECS;

    //
    //  Make sure the objects aren't in the main list. Merge into the current
    //  list, if there is one, simultaneously.
    //

    iCount = poList->iCount( );

    if( !iCount )
       goto done;

    for( i = 0; i < iCount; i++ )
    {
        poFont = poList->poObjectAt( i );
        if (poFont)
        {
            if (NULL != m_poFontList->poDetach( poFont ))
                poFont->Release();

            if( m_poRemoveList )
                m_poRemoveList->bAdd( poFont );
        }
    }

    if( !m_poRemoveList )
        m_poRemoveList = poList;
    else
        delete poList;

done:
    LCS;
}


/*************************************************************************
 * METHOD:  bCheckTBR( )
 *
 * PURPOSE: Check the To Be Removed list. Any files that no longer exist
 *          will be uninstalled.
 *
 * RETURNS: TRUE if something was removed.
 *************************************************************************/
BOOL  CFontManager::bCheckTBR( )
{
    int            iCount,
                   i;
    FullPathName_t szPath;
    BOOL           bRet = FALSE;
    CFontClass * poFont;

    //
    //  Quick return.
    //

    if( !m_poRemoveList )
        return bRet;

    ECS;

    //
    //  Walk the list and check for files that no longer exist and remove them.
    //

    iCount = m_poRemoveList->iCount( );
 
    for( i = iCount - 1; i >= 0; i-- )
    {
        poFont = m_poRemoveList->poObjectAt( i );

        poFont->bGetFQName( szPath, ARRAYSIZE( szPath ) );

        if( GetFileAttributes( szPath ) == 0xffffffff )
        {
            m_poRemoveList->poDetach( i );

            //
            //  Make sure it is no longer in the registry.
            //

            poFont->bRFR( );

            vDeleteFont( poFont, FALSE );

            bRet = TRUE;
       }
    }

    //
    //  If there's nothing left in here, delete the list.
    //

    if(  !m_poRemoveList->iCount( ) )
    {
        delete m_poRemoveList;
        m_poRemoveList = 0;
    }

    LCS;

    //
    //  Notify everyone that the font world has changed.
    //

    if( !m_poRemoveList )
        vCPWinIniFontChange( );

    return bRet;
}


/*************************************************************************
 * METHOD:  vUndoTBR( )
 *
 * PURPOSE: Undo the To Be Removed list. This usually happens when something
 *          has gone wrong with a delete operation.
 *
 * RETURNS: Nothing.
 *************************************************************************/

void CFontManager::vUndoTBR( )
{
    int   iCount;
    int   i;
    CFontClass *   poFont;

    //
    //  Try once more and quick return.
    //

    bCheckTBR( );

    if( !m_poRemoveList )
       return;

    ECS;

    //
    //  Put anything in the list back into the main list.
    //

    if( m_poRemoveList )
    {
        iCount = m_poRemoveList->iCount( );

        for( i = (iCount-1); i >= 0; i-- )
        {
            poFont = m_poRemoveList->poObjectAt( i );

            //
            //  If we can add the item back into GDI, do so
            //

            if( poFont && poFont->bAFR( ) )
            {
                m_poRemoveList->poDetach( i );
                m_poFontList->bAdd( poFont );
            }
        }

        //
        //  Delete the list.
        //

        if( !m_poRemoveList->iCount( ) )
        {
            delete m_poRemoveList;
            m_poRemoveList = 0;
        }
    }

    LCS;

    //
    //  Notify everyone that the font world has changed.
    //

    if( !m_poRemoveList )
        vCPWinIniFontChange( );

}


/*************************************************************************
 * METHOD:  vVerifyList( )
 *
 * PURPOSE: Validate the entries in the list.
 *
 * RETURNS: Nothing.
 *************************************************************************/

void CFontManager::vVerifyList( )
{
    int            iCount,
                   i;
    CFontList    * poList = 0;
    FullPathName_t szPath;
    CFontClass   * poFont;

    //
    //  Quick return;
    //

    if( !m_poFontList )
        return;

    ECS;

    //
    //  Walk the list and any files that don't reference valid files.
    //

    iCount = m_poFontList->iCount( );

    for( i = iCount - 1; i >= 0; i--)
    {
        poFont = m_poFontList->poObjectAt( i );

        //
        //  Only look at something that is in the FONTS folder or on the
        //  same drive( TODO ) as the Windows directory.
        //

        if( poFont->bOnSysDir( ) )
        {
            poFont->bGetFQName( szPath, ARRAYSIZE( szPath ) );

            if( GetFileAttributes( szPath ) == 0xffffffff )
            {
                //
                //  Allocate the list if necessary.
                //

                if( !poList )
                {
                    poList = new CFontList( 50 );
                    if (poList)
                    {
                        if (!poList->bInit())
                        {
                            delete poList;
                            poList = NULL;
                        }
                    }
                }
                if (!poList)
                    break;

                poList->bAdd( poFont );
                poFont = m_poFontList->poDetach( i );
                if (NULL != poFont)
                    poFont->Release();
            }
        }
    }

    //
    //  Set the list up to be removed. This will happen in a background
    //  thread.
    //

    if( poList )
       vToBeRemoved( poList );

    LCS;
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vGetFamily( CFontClass * lpFontRec, CFontList * poList )
{
    int   iCount = m_poFontList->iCount( );
    WORD  wFam   = lpFontRec->wGetFamIndex( );

    while( iCount--)
    {
       lpFontRec = m_poFontList->poObjectAt( iCount );

       if( lpFontRec && ( wFam == lpFontRec->wGetFamIndex( ) ) )
          poList->bAdd( lpFontRec );
    }
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

BOOL CFontManager::bLoadFontList( )
{
    BOOL  bRet = FALSE;

    ECS;

    if( m_poFontList )
    {
        bRet = TRUE;
        goto done;
    }

    //
    //  Allocate a list for 220 fonts (with the default bucket size) and
    //  64 directory entries.
    //

    m_poFontList = new CFontList( 220 );

    if( !m_poFontList )
    {
        goto done;
    }

    //
    //  Initialize them.
    //

    if( !m_poFontList->bInit( ) )
    {
        delete m_poFontList;
        m_poFontList = NULL;
        goto done;
    }

    bRet = bRefresh( FALSE );

    //
    //  Verify the list.
    //

    vVerifyList( );

done:
    LCS;

    return bRet;
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

CFontClass * CFontManager::poAddToList( LPTSTR lpDesc,      //  Font desc
                                        LPTSTR lpPath,      //  Primary font file
                                        LPTSTR lpCompFile ) //  Companion font file
{
    BOOL         bSuccess = FALSE;
    CFontClass * poFont   = new CFontClass;


    if( !poFont )
       return 0;

    if( bSuccess = poFont->bInit( lpDesc, lpPath, lpCompFile ) )
    {
        ECS;

        bSuccess = m_poFontList->bAdd( poFont );

        LCS;
    }

    if(  !bSuccess )
    {
        delete poFont;
        poFont = NULL;
    }

    return poFont;
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

CFontList * CFontManager::poLockFontList( )
{
    if( bLoadFontList( ) )
    {
       DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "CFontManager: EnterCriticalSection in poLockFontList()  " ) ) );

       ECS;

       return m_poFontList;
    }

    return 0;
}


void CFontManager::vReleaseFontList( )
{
    LCS;
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "CFontManager: LeaveCriticalSection in vReleaseFontList()  " ) ) );
}


/***************************************************************************
 * METHOD:
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

int CFontManager::GetSection( LPTSTR lpFile, LPTSTR lpSection, LPHANDLE hSection )
{
    ULONG  nCount;
    ULONG  nSize;
    HANDLE hLocal, hTemp;
    TCHAR *pszSect;


    if( !(hLocal = LocalAlloc( LMEM_MOVEABLE, nSize = 8192 ) ) )
        return( 0 );

    //
    //  Now that a buffer exists, Enumerate all LHS of the section.  If the
    //  buffer overflows, reallocate it and try again.
    //

    do
    {
        pszSect = (PTSTR) LocalLock( hLocal );

        if( lpFile )
            nCount = GetPrivateProfileString( lpSection, NULL, TEXT( "" ),
                                              pszSect, nSize / sizeof( TCHAR ),
                                              lpFile );
        else
            nCount = GetProfileString( lpSection, NULL, TEXT( "" ), pszSect,
                                       nSize / sizeof( TCHAR ) );

        LocalUnlock( hLocal );

        if( nCount != ( nSize / sizeof( TCHAR ) ) - 2 )
            break;

        nSize += 4096;

        if( !(hLocal = LocalReAlloc( hTemp = hLocal, nSize, LMEM_MOVEABLE ) ) )
        {
            LocalFree( hTemp );
            return( 0 );
        }
    } while( 1 ) ;

    *hSection = hLocal;

    return( nCount );
}


/***************************************************************************
 * METHOD:  GetFontsDirectory
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

int CFontManager::GetFontsDirectory( LPTSTR lpDir, int iLen )
{
    return ::GetFontsDirectory( lpDir, iLen );
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION: CFontManager::dwWaitForInstallationMutex
//
//  DESCRIP: Block until installation mutex is available.
//           Thread input messages are handled during wait.
//
//ARGUMENTS: dwTimeout
//              Number of milliseconds to wait for mutex.
//              The default is 2,000 ( 2 seconds ).
//
//  RETURNS: MUTEXWAIT_SUCCESS  = Obtained mutex either via release or abandonment.
//           MUTEXWAIT_WMQUIT   = Received a WM_QUIT message while waiting.
//                                  Caller should automatically cancel operation.
//           MUTEXWAIT_TIMEOUT  = Wait timed out.
//                                  Caller can retry or cancel operation.
//           MUTEXWAIT_FAILED   = Wait failure.
//                                  Shouldn't happen.  Caller should retry/cancel.
//////////////////////////////////////////////////////////////////////////////
DWORD CFontManager::dwWaitForInstallationMutex(DWORD dwTimeout)
{
    DWORD dwWaitResult = 0;                 // Wait result.
    DWORD dwResult     = MUTEXWAIT_SUCCESS; // Return code.

    if (NULL != m_hMutexInstallation)
    {
        //
        // Repeat this loop until one of the following occurs:
        //    1. We aquire the installation mutex.
        //    2. Mutex is abandoned by owner thread.
        //    3. Mutex wait times out.
        //    4. Mutex wait results in error.
        //    5. Receive a WM_QUIT message while waiting.
        //
        do
        {
            //
            // Note:  Don't handle posted messages.  The folder posts an IDM_IDLE message
            //        to the font install dialog every 2 seconds for filling in the font
            //        name list.  This message will satisfy the wait and mess up the
            //        timeout processing.  The (~QS_POSTMESSAGE) prevents this.
            //
            dwWaitResult = MsgWaitForMultipleObjects(1,
                                                     &m_hMutexInstallation,
                                                     FALSE,
                                                     dwTimeout,
                                                     QS_ALLINPUT & (~QS_POSTMESSAGE));
            switch(dwWaitResult)
            {
                case WAIT_OBJECT_0 + 1:
                {
                    MSG msg ;
                    //
                    // Allow blocked thread to respond to sent messages.
                    //
                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    {
                        if ( WM_QUIT != msg.message )
                        {
                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }
                        else
                        {
                            dwResult     = MUTEXWAIT_WMQUIT;
                            dwWaitResult = WAIT_FAILED;
                        }
                    }
                    break;
                }

                case WAIT_OBJECT_0:
                case WAIT_ABANDONED_0:
                    DEBUGMSG((DM_TRACE1, TEXT("Thread 0x%08x: HAS install mutex."), GetCurrentThread()));
                    dwResult = MUTEXWAIT_SUCCESS;
                    break;

                case WAIT_TIMEOUT:
                    DEBUGMSG((DM_TRACE1, TEXT("Thread 0x%08X: TIMEOUT waiting for install mutex."), GetCurrentThread()));
                    dwResult = MUTEXWAIT_TIMEOUT;
                    break;

                case WAIT_FAILED:
                default:
                    dwResult = MUTEXWAIT_FAILED;
                    break;
            }
        } while( (WAIT_OBJECT_0 + 1) == dwWaitResult );
    }
    return dwResult;
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION: CFontManager::bReleaseInstallationMutex
//
//  DESCRIP: Release ownership of the installation mutex.
//
//  RETURNS: TRUE  = Thread owned the mutex and it was released.
//           FALSE = Thread did not own the mutex or it couldn't be released.
//////////////////////////////////////////////////////////////////////////////
BOOL CFontManager::bReleaseInstallationMutex(void)
{
    BOOL bStatus = FALSE;

    if (NULL != m_hMutexInstallation)
    {
        DEBUGMSG((DM_TRACE1, TEXT("Thread 0x%08x: RELEASED install mutex."), GetCurrentThread()));
        bStatus = ReleaseMutex(m_hMutexInstallation);
    }

    return bStatus;
}


//
// Wait until the family-reset mutex is available.  Also returns
// if the "terminate-threads" event is set, meaning that it's time
// to shut down the folder.
// Returns:
//    TRUE  = Obtained the mutex.  OK to proceed.
//    FALSE = Terminate-threads was signaled.  We don't necessarily
//            own the mutex.  Don't proceed.  Return asap.
//
BOOL CFontManager::bWaitOnFamilyReset( )
{
    //
    //  Set the thread to Highest priority until we get the mutex,
    //  which means the thread is done.
    //
    DWORD dwWait;
    BOOL bResult = FALSE;
    BOOL bDone = FALSE;
    HANDLE rgHandles[] = { m_hEventTerminateThreads,
                           m_hMutexResetFamily };
                           
    if( m_hResetFamThread )
        SetThreadPriority( m_hResetFamThread, THREAD_PRIORITY_HIGHEST );

    //
    // This is called on the UI thread.  Must be able to handle
    // sent thread messages.
    //
    do
    {
        dwWait = MsgWaitForMultipleObjects(ARRAYSIZE(rgHandles),
                                           rgHandles,
                                           FALSE,
                                           INFINITE,
                                           QS_ALLINPUT & (~QS_POSTMESSAGE));
                                           
        if (WAIT_OBJECT_0 + ARRAYSIZE(rgHandles) == dwWait)
        {
            MSG msg ;
            //
            // Allow blocked thread to respond to sent messages.
            //
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if ( WM_QUIT != msg.message )
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
                else
                {
                    dwWait = 0; // Rcvd WM_QUIT. Exit loop.
                }
            }
        }
        else if (0 == (dwWait - WAIT_OBJECT_0))
        {
            //
            // Terminate-threads event was set.
            //
            bDone = TRUE;
        }
        else if (1 == (dwWait - WAIT_OBJECT_0))
        {
            //
            // Got the mutex.
            //
            if( m_hResetFamThread )
                SetThreadPriority( m_hResetFamThread, THREAD_PRIORITY_LOWEST );
            
            bResult = TRUE;
            bDone   = TRUE;
        }            
    }
    while(!bDone);
    //
    // Always release the mutex before returning.
    // Even if the wait was satisfied by the "terminate" event this
    // will ensure we don't hold the mutex.  If we don't own it this call
    // will harmlessly fail.
    //
    ReleaseMutex( m_hMutexResetFamily );
    
    return bResult;
}


/***************************************************************************
 * METHOD:  dwResetFamilyFlags
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

DWORD dwResetFamilyFlags(LPVOID pvParams)
{
    CFontManager *pFontManager = (CFontManager *)pvParams;

    if (NULL != pFontManager)
    {
        BOOL bDone = FALSE;
        HANDLE rghObj[] = { pFontManager->m_hMutexResetFamily,
                            pFontManager->m_hEventResetFamily };

        while(!bDone)
        {
            //
            //  Wait for the FONTS folder to change. If we time out, then attempt
            //  to undo any deletions that might be occuring.
            //  Note that the CFontManager dtor will set both the reset-family
            //  event and the terminate-threads event.  This way we'll be sure
            //  to terminate this thread when it's time to shut down.
            //                      
            WaitForMultipleObjects(ARRAYSIZE(rghObj), 
                                   rghObj, 
                                   TRUE, 
                                   INFINITE);

            ResetEvent(pFontManager->m_hEventResetFamily);
            //
            // We got the OK to reset the family flags.  Now let's check
            // the "terminate-threads" event.  If it's set then it's time to
            // go home.
            //
            if (WAIT_OBJECT_0 == WaitForSingleObject(pFontManager->m_hEventTerminateThreads, 0))
            {
                bDone = true;
            }
            else
            {
                pFontManager->vDoResetFamilyFlags( );
            }
            //
            //  Release the mutex. The event was already reset by the
            //  PulseEvent
            //
            ReleaseMutex(pFontManager->m_hMutexResetFamily );
        }
    }

    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
    return 0;
}


/***************************************************************************
 * METHOD:  vResetFamilyFlags
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vResetFamilyFlags( )
{
    SetEvent( m_hEventResetFamily );
}


/***************************************************************************
 * METHOD:  vDoResetFamilyFlags
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vDoResetFamilyFlags( )
{
    /* static */ WORD   s_wIdx = 0;

    CFontClass * poFont;
    CFontClass * poFont2;

    if( !m_poFontList )
        return;


    ECS;

restart:
    int iCount = m_poFontList->iCount( );

    //
    //  It would be nice to walk the list and only set the values that aren't
    //  set to IDX_NULL. However, this doesn't work if the main font for
    //  a family is deleted.
    //

    for( int i = 0; i < iCount; i++ )
    {
        m_poFontList->poObjectAt( i )->vSetFamIndex( IDX_NULL );
    }

    //
    //  Release for a sec.
    //

    LCS;

    Sleep( 0 );

    ECS;

    iCount = m_poFontList->iCount( );

    for( i = 0; i < iCount; i++)
    {
        poFont = m_poFontList->poObjectAt( i );

        if( poFont && poFont->wGetFamIndex( ) == IDX_NULL )
        {
            //
            //  Set the index and get the name.
            //

            poFont->vSetFamIndex( s_wIdx );
            poFont->vSetFamilyFont( );

            //
            //  Everything up to here already has an index.
            //

            for( int j = i + 1; j < iCount; j++ )
            {
                poFont2 = m_poFontList->poObjectAt( j );

                if( poFont2 && poFont2->bSameFamily( poFont ) )
                {
                    poFont2->vSetFamIndex( s_wIdx );
                    poFont2->vSetNoFamilyFont( );

                    //
                    //  A Type1 cannot supercede as "head of the family".
                    //  If two non-Type1 fonts are competing for
                    //  "head of the family", the one with the "more regular"
                    //  style wins.  Lesser style values are "more regular".
                    //  This could be one boolean expression but I think the
                    //  nested "ifs" are more readable.
                    //
                    if ( !poFont2->bType1() )
                    {
                        if ( poFont->bType1() ||
                            (poFont2->dwStyle() < poFont->dwStyle()) )
                        {
                            poFont2->vSetFamilyFont( );
                            poFont->vSetNoFamilyFont( );

                            //
                            //  Use the new one as the main family font.
                            //
                            poFont = poFont2;
                        }
                    }
                }
            }

            s_wIdx++;

        }

        //
        //  If the main thread isn't waiting for us. Let go of the
        //  Critical_Section for a moment.
        //

        LCS;

        Sleep( 0 );

        ECS;

        //
        //  If the list has changed while we were gone, start over. We could
        //  just recurse and exit, but the combination of ECS/LCS and stack
        //  could mess us up.
        //

        if( iCount != m_poFontList->iCount( ) )
        {
            goto restart;
        }
    }

    m_bFamiliesNeverReset = FALSE;

    LCS;
}


/***************************************************************************
 * METHOD:  iSearchFontListFile
 *
 * PURPOSE: Search the list of fonts to see if the file is represented.
 *
 * RETURNS: the index or (-1)
 *
 ***************************************************************************/

int   CFontManager::iSearchFontListFile( PTSTR pszFile )
{
    //
    //  This function assumes the file is in the Fonts directory.
    //  This shortcoming will be rectified if necessary.
    //

    CFontClass* poFont = 0;
    int iCount = poLockFontList()->iCount();
    int i;
    int iRet = (-1);

    if( pszFile == NULL ) return NULL;

    for( i = 0; i < iCount; i++ )
    {
        poFont = m_poFontList->poObjectAt( i );

        if( poFont->bSameFileName( pszFile ) )
        {
            iRet = i;
            break;
        }
    }

    vReleaseFontList( );

    return iRet;
}


/***************************************************************************
 * METHOD:  poSearchFontListFile
 *
 * PURPOSE: Search the list of fonts to see if the file is represented.
 *
 * RETURNS: The object or NULL
 *
 ***************************************************************************/

CFontClass * CFontManager::poSearchFontListFile( PTSTR pszFile )
{
    return m_poFontList->poObjectAt( iSearchFontListFile( pszFile ) );
}


/***************************************************************************
 * METHOD:  ShouldAutoInstallFile
 *
 * PURPOSE: TRUE  = Install this file from reconciliation thread.
 *          FALSE = Don't install this file on reconciliation thread.
 *
 ***************************************************************************/

//
// Extensions of font files that should be excluded from auto-installation.
// This list includes AFM and INF because the reconciliation thread doesn't
// know how to build a PFM from an AFM/INF pair.  That function also displays
// a UI which we also don't want on the reconciliation thread.  To install
// a Type1 font on the reconciliation thread, the PFM and PFB files have to
// be copied to the fonts folder.
//
LPCTSTR c_pszExcludeThese[] = {TEXT("TTE"),
                               TEXT("AFM"),
                               TEXT("INF"),
                               NULL};


BOOL CFontManager::ShouldAutoInstallFile( PTSTR pszFile, DWORD dwAttribs )
{
    //
    // If the file is hidden, don't auto install it.
    //
    ECS;
    const bool bFileIsHidden = (dwAttribs & FILE_ATTRIBUTE_HIDDEN) || m_HiddenFontFilesList.Exists(pszFile);
    LCS;
    if (bFileIsHidden)
    {
        return FALSE;
    }

    LPTSTR pszExt = PathFindExtension( pszFile );

    if( pszExt && *pszExt )
    {
        pszExt++;

        for (UINT i = 0; NULL != c_pszExcludeThese[i]; i++)
        {
            if (0 == lstrcmpi(c_pszExcludeThese[i], pszExt))
            {
                //
                // If the file's extension is in the list of excluded
                // extensions, don't install it.
                //
                return FALSE;
            }
        }
    }

    return TRUE;
}


/***************************************************************************
 * METHOD:  iSearchFontListLHS
 *
 * PURPOSE: Search the list of fonts for the description.
 *
 * RETURNS: the font object or NULL.
 *
 ***************************************************************************/

int  CFontManager::iSearchFontListLHS( PTSTR pszLHS )
{
    CFontClass* poFont = 0;
    int iCount = poLockFontList()->iCount();
    int i;
    int iRet = (-1);


    if( pszLHS == NULL ) return NULL;

    for( i = 0; i < iCount; i++ )
    {
        poFont = m_poFontList->poObjectAt( i );

        if( poFont->bSameDesc( pszLHS ) )
        {
            iRet = i;
            break;
        }
    }

    vReleaseFontList( );

    return iRet;
}


/***************************************************************************
 * METHOD:  poSearchFontListLHS
 *
 * PURPOSE: Search the list of fonts for the description.
 *
 * RETURNS: the font object or NULL.
 *
 ***************************************************************************/

CFontClass * CFontManager::poSearchFontListLHS( PTSTR pszLHS )
{
    return m_poFontList->poObjectAt( iSearchFontListLHS( pszLHS ) );
}


/***************************************************************************
 * FUNCTION: iSearchFontList
 *
 * PURPOSE:  Search the FONTLIST for a face name.
 *
 * RETURNS:  index of item, or (-1)
 ***************************************************************************/

int CFontManager::iSearchFontList( PTSTR pszTarget, BOOL bExact, int iType )
{
    CFontClass* poFont = 0;
    int iCount;
    int i;

    if( pszTarget == NULL ) return( -1 );

    ECS;

    iCount = m_poFontList->iCount();

    for( i = 0; i < iCount; i++ ) {
       poFont = m_poFontList->poObjectAt( i );
       if( poFont && poFont->bSameName( pszTarget ) ) {
          LCS;
          return i;
       }
    }

    //
    //  If we didn't find a name, and bExact == FALSE, then look for anything
    //  with an overlap.
    //

    if( !bExact )
    {
        for( i = 0; i < iCount; i++ )
        {
            poFont = m_poFontList->poObjectAt( i );

            if( poFont && poFont->bNameOverlap( pszTarget ) )
            {
                if( ( iType == kSearchTT ) && !(poFont->bTrueType( ) || poFont->bOpenType( )))
                    continue;

                if( ( iType == kSearchNotTT ) && (poFont->bTrueType( ) || poFont->bOpenType( )))
                    continue;

                LCS;

                return i;
            }
        }
    }

    LCS;

    //
    //  No Match.
    //

    return( -1 );
}


/***************************************************************************
 * FUNCTION: lpDBSearchFontList
 *
 * PURPOSE:  Search the FONTLIST for a face name.
 *
 * RETURNS:  FontClass* if found, NULL if not.
 ***************************************************************************/

CFontClass* CFontManager::poSearchFontList( PTSTR pszTarget, BOOL bExact, int iType )
{
    return m_poFontList->poObjectAt( iSearchFontList( pszTarget, bExact, iType ) );
}


/***************************************************************************
 * METHOD:  vDeleteFontList
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vDeleteFontList( CFontList * poList, BOOL bDelete )
{
    //
    //  Build up NULL delimited, NULL-terminated buffer to hand to
    //  SHFileOperations(). Any files that are links (not in the fonts
    //  directory) are not part of this -- we just remove their reference
    //  in WIN.INI
    //

    int            iCount = poList->iCount();
    FullPathName_t szPath;
    int            iBufSize = 1; // 1 for double-nul terminator.
    CFontClass *   poFont;
    int            i;


    if( !bDelete )
        goto uninstall;

    //
    //  Count the amount of memory we need. While we're at it, remove
    //  the font from GDI
    //

    for( i = 0; i < iCount; i++ )
    {
        poFont = poList->poObjectAt( i );

        if( poFont && poFont->bGetFileToDel( szPath, ARRAYSIZE(szPath) ) )
        {
            iBufSize += lstrlen( szPath ) + 1;

            //
            // Add length of PFB file path if this font has an associated PFB
            // and that PFB is located in the fonts directory.  We don't
            // want to delete a PFB that isn't under our control.
            // Note that bGetPFB() returns FALSE if the font isn't Type1.
            //
            if (poFont->bGetPFB(szPath, ARRAYSIZE(szPath)) &&
                bFileIsInFontsDirectory(szPath))
            {
                iBufSize += lstrlen(szPath) + 1;
            }

            //
            //  If this doesn't work, we'll pick it up below because the
            //  delete failed.
            //

            poFont->bRFR( );
        }
    }

    //
    //  If all the entries were links, then there is no buffer.
    //

    if( 1 < iBufSize )
    {
        LPTSTR  lpBuf = new TCHAR[ iBufSize ];

        if( !lpBuf )
            return;

        //
        //  Fill it in.
        //

        LPTSTR lpCur = lpBuf;

        for( i = 0; i < iCount; i++ )
        {
            poFont = poList->poObjectAt( i );

            if( poFont->bGetFileToDel( lpCur, iBufSize - (lpCur - lpBuf) ) )
            {
                lpCur += ( lstrlen( lpCur ) + 1 );

                //
                // Add path to the PFB file if there is one and if
                // that PFB is located in the fonts directory.  We don't
                // want to delete a PFB that isn't under our control.
                // Note that bGetPFB() returns FALSE if the font isn't Type1.
                //
                if (poFont->bGetPFB(szPath, ARRAYSIZE(szPath)) &&
                    bFileIsInFontsDirectory(szPath))
                {
                    // The buffer was properly allocated to hold all file names.
                    // This copy operation will not truncate the output.
                    StringCchCopy(lpCur, iBufSize - (size_t)(lpCur - lpBuf), szPath);
                    lpCur += (lstrlen(lpCur) + 1);
                }
            }
        }

        *lpCur = 0;

        //
        //  Do the delete.
        //

        SHFILEOPSTRUCT sFileOp =
        {
            NULL,
            FO_DELETE,
            lpBuf,
            NULL,
            FOF_ALLOWUNDO | FOF_NOCONFIRMATION,
            0,
            0
        } ;

        int iRet = SHFileOperation( &sFileOp );

        //
        //  If the operation was cancelled, determined what was done and what
        //  wasn't.
        //

        if( iRet || sFileOp.fAnyOperationsAborted )
        {
            //
            // Walk the list and determine if the file is there or not.
            //

            for( i = iCount - 1; i >= 0; i-- )
            {
               poFont = poList->poObjectAt( i );

               if( poFont->bOnSysDir( ) )
               {
                    poFont->vGetDirFN( szPath, ARRAYSIZE(szPath) );

                    //
                    //  If the file exists then the operation didn't succeed.
                    //  Remove it from the list and AddFontResource.
                    //

                    if( GetFileAttributes( szPath ) != 0xffffffff )
                    {
                        poList->poDetach( i );
                        poFont->bAFR( );
                        poFont->Release();
                    }
                }
            }
        }
    }  // End of if( iBufSize )

uninstall:

    //
    //  Remove the fonts from the main list.
    //

    iCount = poList->iCount( );

    for( i = 0; i < iCount; i++)
    {
        poFont = poList->poObjectAt( i );
        if (poFont)
        {
            vDeleteFont( poFont, FALSE );
        }
    }

    //
    //  If there was something deleted, then notify apps.
    //

    if( iCount )
        vCPWinIniFontChange( );
}


/***************************************************************************
 * METHOD:  vDeleteFont
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vDeleteFont( CFontClass * lpFontRec, BOOL bRemoveFile )
{
    FontDesc_t     szLHS;

    if( lpFontRec->bType1( ) )
    {
        //
        //  Remove registry entries (files should have been deleted
        //  before reaching this point - in vDeleteFontList above).
        //
        //

        lpFontRec->vGetDesc( szLHS, ARRAYSIZE(szLHS) );

        DeleteT1Install( NULL, szLHS, bRemoveFile );

        goto RemoveRecord;
    }

    if( !lpFontRec->bRFR( ) )
        return;

    //  Remove the entry from WIN.INI or the registry -- whereever it
    //  resides.

    lpFontRec->vGetDesc( szLHS, ARRAYSIZE(szLHS) );

    WriteProfileString( s_szINISFonts, szLHS, 0L );

    WriteToRegistry( szLHS, NULL );
    
RemoveRecord:

    ECS;

    //
    //  Remove the record from the list.
    //

    if( !m_poFontList->bDelete( lpFontRec ) )
        lpFontRec->Release();

    LCS;
}


/***************************************************************************
 * METHOD:  vDeleteFontFamily
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

void CFontManager::vDeleteFontFamily( CFontClass * lpFontRec, BOOL bRemoveFile )
{
    int   iCount = m_poFontList->iCount( );
    WORD  wFam = lpFontRec->wGetFamIndex( );

    while( iCount--)
    {
       lpFontRec = m_poFontList->poObjectAt( iCount );

       if( lpFontRec && ( wFam == lpFontRec->wGetFamIndex( ) ) )
          vDeleteFont( lpFontRec, bRemoveFile );
    }
}


/***************************************************************************
 * METHOD:  iCompare
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

int CFontManager::iCompare( CFontClass * pFont1,
                            CFontClass * pFont2,
                            CFontClass * pOrigin )
{
   USHORT   nDiff1,
            nDiff2;

   // DEBUGMSG( (DM_TRACE1,TEXT( "FontMan: iCompare" ) ) );

   nDiff1 = nDiff( pOrigin, pFont1 );
   nDiff2 = nDiff( pOrigin, pFont2 );

   return(  ( (int)(ULONG) nDiff1 ) - ((int)(ULONG) nDiff2 ) );
}


/***************************************************************************
 * METHOD:  nDiff
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/

USHORT CFontManager::nDiff( CFontClass * pFont1, CFontClass * pFont2 )
{
   IPANOSEMapper * m_poMap;
   USHORT   nRet = (USHORT)(-1);

   // DEBUGMSG( (DM_TRACE1,TEXT( "nDiff        " ) ) );

   if( SUCCEEDED( GetPanMapper( &m_poMap ) ) ) {
      BYTE * lpPan1 = pFont1->lpBasePANOSE( );
      BYTE * lpPan2 = pFont2->lpBasePANOSE( );

      nRet = m_poMap->unPANMatchFonts( lpPan1,
                        PANOSE_LEN,
                        lpPan2,
                        PANOSE_LEN,
                        *lpPan1 );

      m_poMap->Release( );
   }

   return nRet;
}

// -----------------------------------------------------------------------
// GetPanoseClass
//
// Return the class of the Panose Mapper. If we expose this in the
// registery, we can just alter this function and everything still
// works correctly.
//
//------------------------------------------------------------------------

CLSID GetPanoseClass( )
{
   return CLSID_PANOSEMapper;
}

/***************************************************************************
 * METHOD:  GetPanMapper
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 ***************************************************************************/
HRESULT CFontManager::GetPanMapper( IPANOSEMapper ** ppMapper )
{
    HRESULT   hr = ResultFromScode( E_NOINTERFACE );


    *ppMapper = NULL;

    ECS;

    if( !m_poPanMap && !m_bTriedOnce )
    {
        m_bTriedOnce = TRUE;

        DEBUGMSG( (DM_TRACE1,TEXT( "GetPanMapper calling GetPanoseClass()" ) ) );

        CLSID clsid = GetPanoseClass( );

        DEBUGMSG( (DM_TRACE1,TEXT( "GetPanMapper calling CoCreateInstance" ) ) );

        DEBUGMSG( (DM_TRACE1, TEXT( "Initializing OLE" ) ) );

        DEBUGMSG( (DM_TRACE1, TEXT( "Calling CoCreateInstance" ) ) );

        hr = SHCoCreateInstance( NULL,
                                 &clsid,
                                 NULL,
                                 IID_IPANOSEMapper,
                                 (LPVOID *) &m_poPanMap );

        if( FAILED( hr ) )
        {
            DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: CFontMan::GetPan() Failed  %d" ),
                        hr) );

            // DEBUGBREAK;
        }

        //
        //  We have the mapper. Relax the threshold so we
        //  can get values for sorting.
        //

        else
            m_poPanMap->vPANRelaxThreshold( );
    }

    //
    //  AddRef for the caller. (This will make the count > 1 )
    //  We Release( ) on delete.
    //

    if( m_poPanMap )
    {
        // DEBUGMSG( (DM_TRACE1, TEXT( "GetPanMapper calling m_poPanMap->AddRef()" ) ) );

        m_poPanMap->AddRef( );

        *ppMapper = m_poPanMap;
        hr = NOERROR;
    }

    LCS;

    return hr;
}


//
// Build a hash table of font file names contained in the
// "HiddenFontFiles" section of %windir%\FONT.INF.  This identifies
// those font files that are to be always hidden, and therefore
// excluded from installation via the folder reconciliation thread.
//
DWORD CFontManager::HiddenFilesList::Initialize(void)
{
    DWORD dwNamesLoaded = 0;

    //
    // Initialize hash table with 101 buckets and
    // make it case insensitive.
    // There are currently 140 entries in the HiddenFontFiles
    // section of FONT.INF.
    // Note that initialization of the string table will
    // destroy any current content.
    //
    if (SUCCEEDED(StringTable::Initialize(101,       // Hash bucket count.
                                          FALSE,     // Case insensitive.
                                          FALSE)))    // No duplicates.
    {
        HANDLE hInf = INVALID_HANDLE_VALUE;

        hInf = SetupOpenInfFile(TEXT("FONT.INF"), NULL, INF_STYLE_WIN4, NULL);

        if (INVALID_HANDLE_VALUE != hInf)
        {
            INFCONTEXT Context;

            if(SetupFindFirstLine(hInf, TEXT("HiddenFontFiles"), NULL, &Context))
            {
                TCHAR szFileName[MAX_PATH];
                DWORD dwReqdSize = 0;

                do
                {
                    if(SetupGetStringField(&Context,
                                           0,
                                           szFileName,
                                           ARRAYSIZE(szFileName),
                                           &dwReqdSize))
                    {
                        if (Add(szFileName))
                            dwNamesLoaded++;
                    }
                } while(SetupFindNextLine(&Context, &Context));
            }
            SetupCloseInfFile(hInf);
        }
    }
    return dwNamesLoaded;
}


//
// Determine if a Type1 font driver is loaded.
// This code was taken from \ntuser\client\fntsweep.c
// Originally written by BodinD.
//
BOOL CFontManager::CheckForType1FontDriver(void)
{
    LONG       lRet;
    WCHAR      awcClass[MAX_PATH] = L"";
    DWORD      cwcClassName = MAX_PATH;
    DWORD      cSubKeys;
    DWORD      cjMaxSubKey;
    DWORD      cwcMaxClass;
    DWORD      cValues = 0;
    DWORD      cwcMaxValueName;
    DWORD      cjMaxValueData;
    DWORD      cjSecurityDescriptor;

    HKEY       hkey = NULL;
    FILETIME   ftLastWriteTime;

    BOOL bRet = FALSE;

    // open the font drivers key and check if there are any entries, if so
    // return true. If that is the case we will call AddFontResourceW on
    // Type 1 fonts at boot time, right after user had logged on
    // PostScript printer drivers are not initialized at this time yet,
    // it is safe to do it at this time.

    lRet = RegOpenKeyExW(HKEY_LOCAL_MACHINE,        // Root key
                         s_szKeyFontDrivers,        // Subkey to open
                         0L,                        // Reserved
                         KEY_READ,                  // SAM
                         &hkey);                    // return handle

    if (lRet == ERROR_SUCCESS)
    {
        // get the number of entries in the [Fonts] section

        lRet = RegQueryInfoKeyW(
                   hkey,
                   awcClass,              // "" on return
                   &cwcClassName,         // 0 on return
                   NULL,
                   &cSubKeys,             // 0 on return
                   &cjMaxSubKey,          // 0 on return
                   &cwcMaxClass,          // 0 on return
                   &cValues,              // == cExternalDrivers
                   &cwcMaxValueName,      // longest value name
                   &cjMaxValueData,       // longest value data
                   &cjSecurityDescriptor, // security descriptor,
                   &ftLastWriteTime
                   );

        if ((lRet == ERROR_SUCCESS) && cValues)
        {
            bRet = TRUE;
        }

        RegCloseKey(hkey);
    }
    return (m_bType1FontDriverInstalled = bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\oeminf.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// oeminf.cpp
//      Explorer Font Folder extension routines.
//    Functions for manipulating OEMxxxxx.INF files.  This module is
//    shared by Windows Setup and Control Panel.  The constant
//    WINSETUP is defined when compiling for Windows Setup.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include "dbutl.h"
#include "dblnul.h"

#define USE_OEMINF_DEFS
#include "oeminf.h"



/* BOOL RunningFromNet( void );
 *
 * Checks to see if the user is running on a network Windows installation.
 *
 * ENTRY: void
 *
 * EXIT: BOOL - TRUE if the user is running on a network Windows
 *              installation.  FALSE if not or if one of the
 *              Get...Directory() calls fails.
 *
 */
BOOL FAR PASCAL RunningFromNet( void )
{
    TCHAR  pszWindowsDir[ MAX_NET_PATH ], pszSystemDir[ MAX_NET_PATH ];
    LPTSTR pszWindowsTemp, pszSystemTemp;


    //
    //  Check the results from GetSystemWindowsDirectory() and GetSystemDirectory().
    //  If the System directory is a direct subdirectory of the Windows
    //  directory, this is not a network installation.  Otherwise it is a
    //  network installation.
    //

    if( GetSystemWindowsDirectory( pszWindowsDir, ARRAYSIZE( pszWindowsDir ) ) == 0 )
        return( FALSE );

    if( GetSystemDirectory( pszSystemDir, ARRAYSIZE( pszSystemDir ) ) == 0 )
        return( FALSE );

    pszWindowsTemp = pszWindowsDir;
    pszSystemTemp  = pszSystemDir;

    CharUpper( pszWindowsTemp );
    CharUpper( pszSystemTemp );

    while( ( *pszWindowsTemp != TEXT( '\0' ) )
           && ( *pszWindowsTemp++ == *pszSystemTemp++ ) )
       ;

    //
    //  Did the path specifications match?
    //

    if( *pszWindowsTemp == TEXT( '\0' ) )
        return( FALSE );
    else
        return( TRUE );
}


/* HANDLE ReadFileIntoBuffer( int doshSource );
 *
 * Reads up to first (64K - 1) bytes of an input file into a buffer.
 *
 * ENTRY: doshSource - DOS file handle of file open for reading
 *
 * EXIT: HANDLE - Global handle to the file buffer filled from the input
 *                file.  NULL if an error occurs.
 *
 */

HANDLE FAR PASCAL ReadFileIntoBuffer( int doshSource )
{
    LONG lLength;
    HANDLE hBuffer;
    LPTSTR lpszBuffer, lpszTemp;
    int nBytesToRead;


    //
    //  How long is the file?
    //

    if( ( lLength = _llseek( doshSource, 0L, 2 ) ) < 0L )
    {

       //
       //  Return NULL on error.
       //

       return( NULL );
    }


    //
    //  Return to the beginning of the file.
    //

    if( _llseek( doshSource, 0L, 0 ) != 0L )
        return( NULL );

    //
    //  Don't overrun the .inf buffer bound.
    //

    if( lLength > MAX_INF_COMP_LEN )
        lLength = MAX_INF_COMP_LEN;

    //
    //  Allocate storage for the file.
    //

    if( ( hBuffer = GlobalAlloc( GHND, (DWORD) lLength ) ) == NULL )
        return( NULL );

    //
    //  Lock the buffer in place.
    //

    if( ( lpszTemp = lpszBuffer = (LPTSTR) GlobalLock( hBuffer ) ) == NULL )
        return( NULL );

    //
    //  Fill the buffer from the file.
    //

    while( lLength > 0 )
    {
        nBytesToRead = (int)min( lLength, MAX_INF_READ_SIZE );

        if( _lread( doshSource, lpszTemp, nBytesToRead ) != (WORD)nBytesToRead )
        {
            GlobalUnlock( hBuffer );
            GlobalFree( hBuffer );
            return( NULL );
        }

        lLength -= (LONG)nBytesToRead;
        lpszTemp += (LONG)nBytesToRead;
    }

    //
    //  Unlock the buffer.
    //

    GlobalUnlock( hBuffer );

    //
    //  File read in successfully.
    //

    return( hBuffer );
}


/* int FilesMatch( int dosh1, int dosh2, unsigned int uLength );
 *
 * Compares two files.
 *
 * ENTRY: dosh1   - DOS file handle of first file open for reading
 *        dosh2   - DOS file handle of second file open for reading
 *        uLength - number of bytes to compare
 *
 * EXIT: int - TRUE if first (64K - 1) bytes of the files match exactly.
 *             FALSE if not.  (-1) if an error occurs.
 *
 * The buffers need not be null-terminated.  TEXT( '\0' )s are treated as just
 * another byte to compare.
 *
 */

int FAR PASCAL FilesMatch( HANDLE h1, HANDLE h2, unsigned uLength )
{
    int    nReturnCode = -1;
    LPTSTR lpsz1, lpsz2;

    if( ( lpsz1 = (LPTSTR) GlobalLock( h1 ) ) == NULL )
    {
        GlobalUnlock( h1 );
        return( nReturnCode );
    }

    if( ( lpsz2 = (LPTSTR) GlobalLock( h2 ) ) != NULL )
    {
        //
        //  See if the files match.
        //

        nReturnCode = !memcmp( lpsz1, lpsz2, uLength );
    }

    GlobalUnlock( h1 );
    GlobalUnlock( h2 );

    return( nReturnCode );
}


/* int OpenFileAndGetLength( LPTSTR lpszSourceFile, PLONG plFileLength );
 *
 * Opens a file into a global buffer.  Returns a handle to the buffer and the
 * actual length of the file.
 *
 * ENTRY: lpszSourceFile - source file name
 *        plFileLength   - pointer to LONG to be filled with length of source
 *                         file
 *
 * EXIT: int           - Open DOS file handle if successful.  (-1) if
 *                       unsuccessful.
 *       *plFileLength - Filled in with length of source file if successful.
 *                       Undefined if unsuccessful.
 */

int FAR PASCAL OpenFileAndGetLength( LPTSTR lpszSourceFile,
                                     LPLONG plFileLength )
{
    int      doshSource;
    OFSTRUCT of;


////////////////////////////////////////////////////////////////////
//
// NOTE [stevecat]  - Why are we munging INF files?  For now
//          just convert the filename to ASCII and use the current
//          fileio apis to munge thru the INF files.
//
////////////////////////////////////////////////////////////////////

    char    szFile[ PATHMAX ];

    WideCharToMultiByte( CP_ACP, 0, lpszSourceFile, -1, szFile,
                         ARRAYSIZE(szFile), NULL, NULL );

    doshSource = OpenFile( szFile, &of, OF_READ );

    if( doshSource == -1 )
        return doshSource;

    //
    //  Keep track of the length of the new file.
    //

    if( ( *plFileLength = _llseek( doshSource, 0L, 2 ) ) < 0L )
    {
        _lclose( doshSource );
        return(-1);
    }

    return( doshSource );
}


#define INF_YES (1)
#define INF_NO  (0)
#define INF_ERR (-1)


/* int IsNewFile( LPTSTR lpszSourceFile, LPTSTR lpszDestDir );
 *
 * Checks to see if a given file already exists as a file matching a given
 * file specification.
 *
 * ENTRY: pszSourceFile - path name of the new file
 *        pszSearchSpec - target directory and file specification (may
 *                        include wildcards) to use to search for duplicates
 *                        (e.g., "c:\win\system\*.inf")
 *
 * EXIT: int - TRUE if the new file doesn't already exist as a file matching
 *             the given file specification.  FALSE if it does.  (-1) if an
 *             error occurs.
 *
 */

int FAR PASCAL IsNewFile( LPTSTR lpszSourceFile, size_t cchSourceFile, LPTSTR lpszSearchSpec )
{
    int    nReturnCode = INF_ERR;
    int    nTargetLen, nMatchRet;
    HANDLE hFind;
    WIN32_FIND_DATA   sFind;
    LPTSTR lpszReplace;
    TCHAR  szTargetFileName[ MAX_NET_PATH + FILEMAX ];
    int    doshSource, doshTarget;
    HANDLE hSourceBuf, hTargetBuf;
    LONG   lSourceLength, lTargetLength;


    //
    //  How much storage do we need for the destination file name?
    //

    lpszReplace = PathFindFileName(lpszSearchSpec);

    //
    // [stevecat] The following statement is evil and parochial. It
    //            will not work correctly in a UNICODE environment.
    //
    //       nTargetLen = lpszReplace - lpszSearchSpec + FILEMAX;
    //
    //  Replace with a better way to calculate string length.
    //

    nTargetLen = (LONG)(lpszReplace - lpszSearchSpec) / sizeof( TCHAR ) + FILEMAX;

    //
    //  Don't overflow the buffer.
    //

    if( nTargetLen > ARRAYSIZE( szTargetFileName ) )
        return( INF_ERR );

    //
    //  Keep track of the start of the file name in the destination path
    //  specification.
    //
    if (FAILED(StringCchCopy( szTargetFileName, ARRAYSIZE(szTargetFileName), lpszSearchSpec )))
        return( INF_ERR );

    lpszReplace = (LPTSTR)szTargetFileName + ( lpszReplace - lpszSearchSpec );

    //
    //  Are there any files to process?
    //

    hFind = FindFirstFile( lpszSearchSpec, &sFind );


    //
    //  Only open the source file if there are any existing files to compare
    //  against.
    //

    if( hFind == INVALID_HANDLE_VALUE )
        return( INF_YES );

    if( ( doshSource = OpenFileAndGetLength( lpszSourceFile, &lSourceLength ) ) == NULL )
    {
        FindClose( hFind );
        return( INF_ERR );
    }

    hSourceBuf = ReadFileIntoBuffer( doshSource );

    _lclose( doshSource );

    if( hSourceBuf == NULL )
    {
        FindClose( hFind );
        return( INF_ERR );
    }

    //
    //  Check all the matching files.
    //

    while( hFind != INVALID_HANDLE_VALUE )
    {
        //
        //  Replace the wildcard file specification with the file name of the
        //  target file.
        //  lstrcpy( lpszReplace, fcbSearch.szName );
        //

        if (FAILED(StringCchCopy(lpszReplace, 
                                 ARRAYSIZE(szTargetFileName) - (lpszReplace - szTargetFileName), 
                                 sFind.cAlternateFileName )))
        {
            goto IsNewFileExit;
        }

        //
        //  Open the target file.
        //

        if( ( doshTarget = OpenFileAndGetLength( szTargetFileName,
                                                 &lTargetLength ) ) == NULL )
           goto IsNewFileExit;

        //
        //  Is the target file the same size as the new file?
        //

        if( lTargetLength == lSourceLength )
        {
           //
           //  Yes.  Read in the target file.
           //

           hTargetBuf = ReadFileIntoBuffer( doshTarget );

           _lclose( doshTarget );

           if( hTargetBuf == NULL )
                goto IsNewFileExit;

           //
           //  ReadFileIntoBuffer( ) has already checked to make sure the files
           //  aren't longer than (64K - 1) bytes long.
           //  Assert: lSourceLength fits in an unsigned int.
           //

           nMatchRet = FilesMatch( hSourceBuf, hTargetBuf,
                                  (unsigned int)lSourceLength );

           GlobalFree( hTargetBuf );

           if( nMatchRet == -1 )
                goto IsNewFileExit;
           else if( nMatchRet == TRUE )
           {
                if (SUCCEEDED(StringCchCopy( lpszSourceFile, cchSourceFile, szTargetFileName )))
                {
                    nReturnCode = INF_NO;
                }
                goto IsNewFileExit;
           }
        }

        //
        //  Look for the next matching file.
        //  bFound = OEMInfDosFindNext( &fcbSearch );
        //

        if( !FindNextFile( hFind, &sFind ) )
        {
            FindClose( hFind );
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    nReturnCode = INF_YES;

IsNewFileExit:

    if( hFind != INVALID_HANDLE_VALUE )
        FindClose( hFind );


    GlobalFree( hSourceBuf );

    return( nReturnCode );
}


/* PTSTR MakeUniqueFilename( PTSTR pszDirName, PTSTR pszPrefix,
 *                                 PTSTR pszExtension );
 *
 * Creates a unique filename in a directory given a prefix for the base of
 * the filename and an extension.  The prefix must be three characters long.
 * The extension may be zero to three characters long.  The extension should
 * not include a period.  E.g., prefix "oem" and extension "inf".
 *
 * pszDirName's buffer must have space for up to 13 extra characters to be
 * appended (a slash plus 8.3).
 *
 *
 * ENTRY: pszDirName   - buffer holding target directory, unique filename
 *                       will be appended
 *        cchDirName   - Size of buffer (in chars) referenced by pszDirName.
 *        pszPrefix    - three-character base filename prefix to use
 *        pszExtension - filename extension to use
 *
 * EXIT: PTSTR - Pointer to modified path specification if successful.  NULL
 *              if unsuccessful.
 *
 */

LPTSTR FAR PASCAL MakeUniqueFilename( LPTSTR lpszDirName,
                                      size_t cchDirName,
                                      LPTSTR lpszPrefix,
                                      LPTSTR lpszExtension )
{
    TCHAR   szOriginalDir[ MAX_NET_PATH ];
    TCHAR   szUniqueName[ FILEMAX ];
    ULONG   ulUnique = 0UL;
    LPTSTR  lpszTemp;
    BOOL    bFoundUniqueName = FALSE;


    DEBUGMSG( (DM_TRACE1, TEXT( "MakeUniqueFilename() " ) ) );

    //
    //  Check form of arguments.
    //

    if( lstrlen( lpszPrefix ) != 3 || lstrlen( lpszExtension ) > 3 )
        return( NULL );

    //
    //  Save current directory.
    //  if( OEMInfDosCwd( szOriginalDir ) != 0 )
    //

    if( !GetCurrentDirectory( ARRAYSIZE( szOriginalDir ), szOriginalDir ) )
        return( NULL );

    //
    //  Move to target directory.
    //  if( OEMInfDosChDir( lpszDirName ) != 0 )
    //

    if( !SetCurrentDirectory( lpszDirName ) )
        return( NULL );

    //
    //  Make file specification.
    //

    if (FAILED(StringCchCopy( szUniqueName, ARRAYSIZE(szUniqueName), lpszPrefix )))
        return( NULL );

    lpszTemp = szUniqueName + 3;
    const size_t cchTemp = ARRAYSIZE(szUniqueName) - (lpszTemp - szUniqueName);

    //
    //  Try to create a unique filename.
    //

    while( !bFoundUniqueName && ulUnique <= MAX_5_DEC_DIGITS )
    {
        //
        //  Hack together next filename to try.
        //

        if (FAILED(StringCchPrintf( lpszTemp, cchTemp, TEXT( "%lu.%s" ), ulUnique, lpszExtension )))
            return( NULL );

        //
        //  Is this name being used?
        //  if( OEMInfDosFindFirst( & fcbSearch, szUniqueName, ATTR_ALL_FD ) == 0 )
        //

        if( GetFileAttributes( szUniqueName ) == 0xffffffff )
        {
            //
            //  Nope.
            //

            bFoundUniqueName = TRUE;
            break;
        }
        else
            //
            // Yes.  Keep trying.
            //

            ulUnique++;
    }

    //
    //  Have all 100,000 possibilties been exhausted?
    //

    if( !bFoundUniqueName )
        return( NULL );

    //
    //  Add new unique filename on to end of path specification buffer.
    //

    //
    //  Check for ending slash.
    //

    lpszTemp = lpszDirName + lstrlen( lpszDirName );

    if( !IS_SLASH( *(lpszTemp - 1 ) ) && *(lpszTemp - 1 ) != TEXT( ':' ) )
       *lpszTemp++ = TEXT( '\\' );

    //
    //  Append unique filename.
    //

    if (FAILED(StringCchCopy(lpszTemp, 
                             cchDirName - (lpszTemp - lpszDirName),
                             szUniqueName )))
    {
        return( NULL );
    }

    //
    //  Return pointer to modified buffer.
    //

    DEBUGMSG( (DM_TRACE1,TEXT( "MakeUniqueFilename returning: %s %s" ),
              lpszDirName, lpszTemp) );

    return( lpszDirName );
}


/* BOOL CopyNewOEMInfFile( PTSTR pszOEMInfPath );
 *
 * Copies a new OEMSetup.inf file into the user's Windows (network) or System
 * (non-network) directory.  Gives the new .inf file a unique name of the
 * form 'OEMxxxxx.INF'.  Only copies it in if it is really a new .inf file.
 *
 * ENTRY: pszOEMInfPath - path name of the new .inf file to be copied
 *
 * EXIT: BOOL - TRUE if the new .inf file was copied successfully or had
 *              already been added.  0 if the copy failed.
 *
 */

BOOL FAR PASCAL CopyNewOEMInfFile( LPTSTR lpszOEMInfPath, size_t cchOEMInfPath )
{
    BOOL   bRunningFromNet;
    TCHAR  szDest[ MAX_NET_PATH + FILEMAX ];
    LPTSTR pszTemp;

    if (cchOEMInfPath < ARRAYSIZE(szDest))
    {
        //
        // Make sure out buffer is big enough.
        //
        return( FALSE );
    }

    //
    //  Where should we put the new .inf file?
    //

    if( bRunningFromNet = RunningFromNet( ) )
    {
        //
        //  Put new .inf file in Windows directory.
        //

        if( GetWindowsDirectory( szDest, ARRAYSIZE(szDest)) == 0 )
            return( FALSE );
    }
    else
    {
        //
        //  Put new .inf file in System directory.
        //

        if( GetSystemDirectory( szDest, ARRAYSIZE(szDest)) == 0 )
            return( FALSE );
    }

    //
    //  Make file specification for IsNewFile( ).
    //

    pszTemp = szDest + lstrlen( szDest );

    //
    //  N.b., we depend on pszDest not ending in a slash here.
    //

    if (FAILED(StringCchCopy(pszTemp,
                             ARRAYSIZE(szDest) - (pszTemp - szDest),
                             OEM_STAR_DOT_INF )))
    {
        return( FALSE );
    }

    //
    //  Has this .inf file already been copied to the user's Windows or System
    //  directory?
    //

    switch( IsNewFile( lpszOEMInfPath, cchOEMInfPath, szDest ) )
    {
    case INF_ERR:
        return( FALSE );

    case INF_YES:
    {
        //
        //  Trim TEXT( "\*.inf" ) off end of pszDest.
        //

        *pszTemp = TEXT( '\0' );

        // Create a unique name for the new .inf file. We could use
        // SHFileOperation() to create a unique file, but we don't want to
        // copy the file more than once -- we want IsNewFile() to only check
        // for OEMxxxx.INF files.
        //

        if( MakeUniqueFilename( szDest, ARRAYSIZE(szDest), INF_PREFIX, INF_EXTENSION ) == NULL )
            return( FALSE );

        //
        //  Copy .inf file.
        //
        //
        // SHFileOperation requires double-nul terminated strings.
        //
        CDblNulTermList listFrom;
        CDblNulTermList listTo;

        if (FAILED(listFrom.Add(lpszOEMInfPath)) ||
            FAILED(listTo.Add(szDest)))
        {
            return( FALSE );
        }

        SHFILEOPSTRUCT fop;
        memset( &fop, 0, sizeof( fop ) );

        fop.wFunc  = FO_COPY;
        fop.pFrom  = listFrom;
        fop.pTo    = listTo;
        fop.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

        SHFileOperation( &fop );

        //
        //  Copy the new file name back, so the calling function can use it
        //

        StringCchCopy( lpszOEMInfPath, cchOEMInfPath, szDest );
        break;
    }        

    default:
        break;
    }

    //
    //  New .inf file already existed or copied successfully.
    //

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\pfiles.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// pfiles.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include "resource.h"
#include "cpanel.h"
#include "fontcl.h"        // Just for PANOSEBytesClass
#include "pnewexe.h"

#include "dbutl.h"
#include "fontfile.h"



#ifdef __cplusplus
extern "C" {
#endif

//
// [stevecat]   This used to reside in "wingdip.h" (included with <winp.h>)
//  6/29/95     but I have taken it out because of C++ name-mangling problems
//              with that header file that are not going to be fixed because
//              this file is going to change significantly (according to
//              EricK) when we switch over to Kernel mode GDI/User.
//
//
//#include <stddef.h>     //  Needed for winp.h
//#include <winp.h>       //  For private GDI entry point:  GetFontResourceInfo
//
//#undef SWAPL            //  The SWAPL macro in wingdip.h clashes with mine
//

// Private Control Panel entry point to enumerate fonts by file.

#define GFRI_NUMFONTS       0L
#define GFRI_DESCRIPTION    1L
#define GFRI_LOGFONTS       2L
#define GFRI_ISTRUETYPE     3L
#define GFRI_TTFILENAME     4L
#define GFRI_ISREMOVED      5L
#define GFRI_FONTMETRICS    6L

extern BOOL WINAPI GetFontResourceInfoW( LPWSTR  lpPathname,
                                         LPDWORD lpBytes,
                                         LPVOID  lpBuffer,
                                         DWORD   iType );

#ifdef __cplusplus
}
#endif


//-------------------------------------------------------------------
// this needs to go in a header. Probably pnewexe.h
//

#pragma pack(1)
typedef struct
{
    WORD    fontOrdinal;
    WORD    dfVersion;
    DWORD   dfSize;
    char    dfCopyright[ COPYRIGHT_LEN ];
    WORD    dfType;
    WORD    dfPoints;
    WORD    dfVertRes;
    WORD    dfHorzRes;
    WORD    dfAscent;
    WORD    dfIntLeading;
    WORD    dfExtLeading;
    BYTE    dfItalic;
    BYTE    dfUnderline;
    BYTE    dfStrikeOut;
    WORD    dfWeight;
    BYTE    dfCharSet;
    WORD    dfPixWidth;
    WORD    dfPixHeight;
    BYTE    dfPitchAndFamily;
    WORD    dfAvgWidth;
    WORD    dfMaxWidth;
    BYTE    dfFirstChar;
    BYTE    dfLastChar;
    BYTE    dfDefaultChar;
    BYTE    dfBreakChar;
    WORD    dfWidthBytes;
    DWORD   dfDevice;
    DWORD   dfFace;
    DWORD   dfReserved;
    char    szDeviceName[ 1 ];

} FONTENTRY, FAR *LPFONTENTRY;
#pragma pack()

//-------------------------------------------------------------------

TCHAR c_szTrueType[] = TEXT( "TrueType" );
TCHAR c_szOpenType[] = TEXT( "OpenType" );
TCHAR c_szDotOTF[]   = TEXT( ".OTF" );

#define M_INTEGERTYPE( wType )   (wType & 0x8000)
#define M_FONTDIRTYPE( wType )   ((wType & 0x7fff) == 7)

#define SWAP2B(p) (((unsigned short) ((p)[ 0 ]) << 8) | (p)[ 1 ])
#define SWAP4B(p) (SWAP2B((p)+2) | ((SWAP2B(p) + 0L) << 16))
#define SWAPW(x)  ((WORD)SWAP2B((unsigned char FAR *)(&x)))
#define SWAPL(x)  ((unsigned long)SWAP4B((unsigned char FAR *)(&x)))

#define Mac2Ansi(a)    a    // do this right later!

//
//  Platform and language we'll be looking for in the OS2 tables
//  The NAMEID_xxx are the ids of the name records we'll be hunting for.
//

#define LANG_US_ENG        0x0904        // US (1033) (in mac order)
// #define LANG_SHIFTJIS      0x1104        // SHIFTJIS

//
//  name ids.
//

#define COPYRIGHT_ID    0x0000
#define FAMILY_ID       0x0100
#define SUBFAMILY_ID    0x0200
#define PLATFORM_MS     0x0300        // in mac order
#define FACENAME_ID     0x0400        // in mac order
#define VERSION_ID      0x0500
#define POSTSCRIPT_ID   0x0600
#define TRADEMARK_ID    0x0700

#define ENCODEID_UNICODE   0x0100
#define ENCODEID_SHIFTJIS  0x0200
#define ENCODEID_PRC       0x0300
#define ENCODEID_BIG5      0x0400
#define ENCODEID_WANGSUNG  0x0500
#define ENCODEID_JOHAB     0x0600


#define NAMEID_COPYRIGHT    0
#define NAMEID_VERSION      5
#define NAMEID_TRADEMARK    7

#define TAG_CHARTOINDEXMAP   0x70616d63      //  'cmap'
#define TAG_FONTHEADER       0x64616568      //  'head'
#define TAG_NAMINGTABLE      0x656d616e      //  'name'
#define TAG_OS2TABLE         0x322f534f      //  'os_2'
#define TAG_DSIG             0x47495344      //  'DSIG'
#define TAG_CFF              0x20464643      //  'CFF'
#define SFNT_MAGIC           0xf53C0F5f


//
// Enumeration of bit mask values enables us to identify a set of TrueType
// tables in a single DWORD.  The total set of possible tables is open-ended
// as the TrueType specification is extensible.  This enumeration is merely
// a subset that is useful in the font folder.
//
enum TrueTypeTables {
    TT_TABLE_CMAP  = 0x00000001,
    TT_TABLE_HEAD  = 0x00000002,
    TT_TABLE_NAME  = 0x00000004,
    TT_TABLE_OS2   = 0x00000008,
    TT_TABLE_DSIG  = 0x00000010,
    TT_TABLE_CFF   = 0x00000020
                    };

//
//  The TTF structure as used here:
//  The TABLERECORD's the highest level.  It contains
//     sfnt_NameTable entries which in turn consist of
//     sfnt_NameRecord entries
//

typedef struct {
        WORD    id_Specific;
        WORD    id_Platform;
        WORD    id_Language;
} IDBlock_t;

//
//  A little macro for turning an array of 4 chars into dwords.
//

#define M_MAKETAG(a,b,c,d)   ((((((((DWORD) (a) ) << 8)  \
                             | (DWORD) (b) ) << 8)  \
                             | (DWORD) (c) ) << 8)  \
                             | (DWORD) (d) )

#define TAG_TTCF     M_MAKETAG('f', 'c', 't', 't' )

//
//  True type file structures
//

typedef struct ttc_hdr_tag {
   DWORD dwTag;
   DWORD dwVersion;
   DWORD dwDirCount;
} ttc_hdr;

typedef struct tt_hdr_tag {
  DWORD dwVersion;
  WORD  uNumTables;
  WORD  uSearchRange;
  WORD  uEntrySelector;
  WORD  uRangeShift;
} tt_hdr;

typedef struct tttag_tag {
  DWORD dwTag;
  DWORD dwCheckSum;
  DWORD dwOffset;
  DWORD dwLength;
} tttag;

typedef struct tt_head_tag {
  DWORD dwVersion;
  DWORD dwRevision;
  DWORD dwChecksum;
  DWORD dwMagic;
  WORD  wFlags;
  WORD  wUnitsPerEm;
  DWORD dwCreated1;
  DWORD dwCreated2;
  DWORD dwModified1;
  DWORD dwModified2;
  WORD  wXMin;
  WORD  wYMin;
  WORD  wXMax;
  WORD  wYMax;
  WORD  wStyle;
  WORD  wMinReadableSize;
  short iDirectionHint;
  short iIndexToLocFormat;
  short iGlyphDataFormat;
} tt_head;

typedef struct {
     WORD     wPlatformID;
     WORD     wSpecificID;
     DWORD    wOffset;
} sfnt_platformEntry;

typedef struct {
    WORD    wVersion;
    WORD    wNumTables;
    // sfnt_platformEntry platform[ 1 ];   // platform[ numTables ]
} sfnt_char2IndexDir;

typedef struct {
    WORD    wPlatformID;
    WORD    wSpecificID;
    WORD    wLanguageID;
    WORD    wNameID;
    WORD    wLength;
    WORD    wOffset;
} sfnt_NameRecord, *sfnt_pNameRecord, FAR* sfnt_lpNameRecord;

typedef struct {
    WORD    wFormat;
    WORD    wCntRecords;
    WORD    wOffsetString;
/*  sfnt_NameRecord[ count ]  */
} sfnt_NameTable, *sfnt_pNameTable, FAR* sfnt_lpNameTable;


extern "C" {
    void FAR PASCAL UnicodeToAnsi( LPWORD lpwName, LPSTR szName );
}

static void NEAR PASCAL FillName( LPTSTR            szName,
                                  size_t            cchName,
                                  sfnt_lpNameRecord pNameRecord,
                                  WORD              igi,
                                  LPBYTE            pStringByte );

static BOOL  NEAR PASCAL bGetName( CFontFile&    file,
                                   tttag         *pTTTag,
                                   IDBlock_t     &ID_Block,
                                   LPTSTR         szName,
                                   size_t         cchName,
                                   LPFONTDESCINFO lpFDI = NULL,
                                   LPDWORD       *pdwStatus = NULL);

static BOOL  NEAR PASCAL bFindNameThing( sfnt_pNameTable pNames,
                                         IDBlock_t      &ID_Block,
                                         WORD            NameID,
                                         LPTSTR          szName,
                                         size_t          cchName);

static VOID  NEAR PASCAL vReadCountedString( CFontFile& file, LPSTR lpStr, int iLen );



/***************************************************************************
 * Start of Public functions
 ***************************************************************************/

//
// Wrapper around GetFontResourceInfo(GFRI_DESCRIPTION) to handle
// the dynamic buffer sizing required.  With some TTC fonts, the
// description can get very long.
//
BOOL
GetFontResourceDescription(
    LPTSTR pszFile,
    LPTSTR *ppszDesc
    )
{
    *ppszDesc = NULL;

    //
    // First call the GDI API once to get the required buffer size.
    //
    BYTE bDummy;
    DWORD dwBufSize = 0;
    if (GetFontResourceInfoW(pszFile, &dwBufSize, &bDummy, GFRI_DESCRIPTION))
    {
        if (0 < dwBufSize)
        {
            *ppszDesc = (LPTSTR)LocalAlloc(LPTR, dwBufSize);
            if (NULL != *ppszDesc)
            {
                if (GetFontResourceInfoW(pszFile, &dwBufSize, *ppszDesc, GFRI_DESCRIPTION))
                {
                    return TRUE;
                }
                LocalFree(*ppszDesc);
                *ppszDesc = NULL;
            }
        }
    }
    return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
//
// ValidFontFile
//
// in:
//    lpszFile       file name to validate
// out:
//    lpszDesc       on succes name of TT file or description from exehdr
//    lpiFontType    set to a value based on Font type 1 == TT, 2 == Type1
//    lpdwStatus     Set to status of validation functions.
//                   Query to determine why font is invalid.
//                   The following list contains the possible status
//                   values.  See fvscodes.h for details.
//
//                   FVS_SUCCESS
//                   FVS_INVALID_FONTFILE
//                   FVS_INVALID_ARG
//                   FVS_INSUFFICIENT_BUF
//                   FVS_FILE_IO_ERR
//                   FVS_EXCEPTION
//
// NOTE: Assumes that lpszDesc is of size DESCMAX
//
// returns:
//    TRUE success, FALSE failure
//
/////////////////////////////////////////////////////////////////////////////

BOOL bCPValidFontFile( LPTSTR    lpszFile,
                       LPTSTR    lpszDesc,
                       size_t    cchDesc,
                       WORD FAR *lpwFontType,
                       BOOL      bFOTOK,
                       LPDWORD   lpdwStatus )
{
    BOOL          result;
    DWORD         dwBufSize;
    FONTDESCINFO  File;
    BOOL          bTrueType = FALSE;
    TCHAR         szDesc[ DESCMAX ];
    WORD          wType = NOT_TT_OR_T1;
    LPTSTR        lpTemp;
    DWORD         dwStatus = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
    DWORD         dwTrueTypeTables = 0;

    FONTDESCINFO_Init(&File);

    //
    // Initialize status return.
    //
    if (NULL != lpdwStatus)
       *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_STATUS, FVS_FILE_UNK);

    //
    //  Set up the FDI depending on what the caller wanted.
    //

    File.dwFlags = FDI_NONE;

    if( lpszDesc )
    {
        *lpszDesc = (TCHAR) 0;
        File.dwFlags = FDI_DESC;
    }

    if( lpwFontType )
        *lpwFontType = NOT_TT_OR_T1;

    GetFullPathName( lpszFile,
                     ARRAYSIZE(File.szFile),
                     File.szFile,
                     &lpTemp );

    if( bIsTrueType( &File, &dwTrueTypeTables, &dwStatus ) )
    {
        LPCTSTR pszDecoration = c_szTrueType;
        WORD    wFontType     = TRUETYPE_FONT;
        //
        // If the font has a CFF table, we append (OpenType) name decoration.
        //
        if (TT_TABLE_CFF & dwTrueTypeTables)
        {
            pszDecoration = c_szOpenType;
            wFontType     = OPENTYPE_FONT;
        }
        if( lpwFontType )
            *lpwFontType = wFontType;

        if( lpszDesc )
            StringCchPrintf( lpszDesc, cchDesc, c_szDescFormat, File.szDesc, pszDecoration );

        if (NULL != lpdwStatus)
            *lpdwStatus = dwStatus;

        FONTDESCINFO_Destroy(&File);
        return TRUE;
    }
    else
    {
        //
        // Return FALSE if bIsTrueType failed for any reason other than
        // FVS_INVALID_FONTFILE.
        //
        if (FVS_STATUS(dwStatus) != FVS_INVALID_FONTFILE)
        {
            if (NULL != lpdwStatus)
                *lpdwStatus = dwStatus;

            FONTDESCINFO_Destroy(&File);
            return FALSE;
        }
    }


    if( ::IsPSFont( File.szFile, szDesc, ARRAYSIZE(szDesc), (LPTSTR) NULL, 0, (LPTSTR) NULL, 0,
                    (BOOL *) NULL, &dwStatus ))
    {
        if( lpwFontType )
            *lpwFontType = TYPE1_FONT;

        if( lpszDesc )
            StringCchCopy( lpszDesc, cchDesc, szDesc );

        if (NULL != lpdwStatus)
            *lpdwStatus = dwStatus;

        FONTDESCINFO_Destroy(&File);
        return TRUE;
    }
    else
    {
        //
        // Return FALSE if IsPSFont failed for any reason other than
        // FVS_INVALID_FONTFILE.
        //
        if (FVS_STATUS(dwStatus) != FVS_INVALID_FONTFILE)
        {
            if (NULL != lpdwStatus)
                *lpdwStatus = dwStatus;

            FONTDESCINFO_Destroy(&File);
            return FALSE;
        }
    }

    result = FALSE;

    if( AddFontResource( File.szFile ) )
    {
        //
        //  At this point it is a valid font file of some sort
        //  (like a .FON file); however, we are still looking for
        //  more validation using GetFontResourceInfoW call.
        //
        //  See if this is a TrueType font file
        //

        dwBufSize = sizeof( BOOL );

        result = GetFontResourceInfoW( File.szFile,
                                       &dwBufSize,
                                       &bTrueType,
                                       GFRI_ISTRUETYPE );

        if( bTrueType && lpwFontType )
            *lpwFontType = TRUETYPE_FONT;

        if( result )
        {
            if (NULL != lpszDesc)
            {
                LPWSTR pszResDesc;
                result = GetFontResourceDescription(File.szFile, &pszResDesc);
                if (result)
                {
                    vCPStripBlanks(pszResDesc, lstrlen(pszResDesc) + 1);
                    if (bTrueType)
                    {
                        StringCchPrintf(lpszDesc, cchDesc, c_szDescFormat, pszResDesc, c_szTrueType);
                    }
                    else
                    {
                        StringCchCopy(lpszDesc, cchDesc, pszResDesc);
                    }
                    LocalFree(pszResDesc);
                    pszResDesc = NULL;
                }
            }
        }
        RemoveFontResource( File.szFile );
    }

    //
    // At this point, "result" indicates status of the FontResource tests.
    // If we've made it this far, this function just reports SUCCESS or INVALID_FONTFILE.
    //
    if (NULL != lpdwStatus)
        *lpdwStatus = (result ? FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK) :
                                FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK));

    FONTDESCINFO_Destroy(&File);
    return( result );
}


         

/***************************************************************************
 * End of public interfaces
 ***************************************************************************/

///////////////////////////////////////////////////////////////////////////////
// Determine if a True Type font file (.TTF) was converted from a Type1 font.
//
// The string "Converter: Windows Type 1 Installer" is stored in a TrueType file
// in the the version info section of the "name" block to indicate that
// the font was converted from a Type1 font.  This function reads this version
// info string from the caller-provided name block and determines if it matches
// the Type1 converter signature.
//
// Note that in the UNICODE section of the file, the converter signature
// string is stored in Big Endian byte order.  However, since bFindNameThing
// handles byte ordering and returns a TEXT string, we can just compare strings.
//
// WARNING:  Refererence \ntgdi\fondrv\tt\ttfd\fdfon.c for the actual
//           byte string that is written by GDI to the file upon conversion.
//
///////////////////////////////////////////////////////////////////////////////
BOOL NEAR PASCAL bIsConvertedTrueType(sfnt_pNameTable pNames, IDBlock_t& ID_Block)
{
    BOOL bStatus = FALSE;
    static TCHAR szTTFConverterSignature[] = TEXT("Converter: Windows Type 1 Installer");
    static UINT cchTTFConverterSignature   = ARRAYSIZE(szTTFConverterSignature);

    if (NULL != pNames)
    {
        FontDesc_t szVersionInfo;
        if( bFindNameThing( pNames, ID_Block, VERSION_ID, szVersionInfo, ARRAYSIZE(szVersionInfo) ) )
        {
            //
            // Got version info string from "name" block.
            // Truncate to proper length for comparison with signature and compare.
            //
            szVersionInfo[cchTTFConverterSignature - 1] = TEXT('\0');
            bStatus = lstrcmp(szVersionInfo, szTTFConverterSignature) == 0;
        }
    }
    return bStatus;
}



BOOL NEAR PASCAL bGetName( CFontFile& file,
                           tttag *pTTTag,
                           IDBlock_t& ID_Block,
                           LPTSTR lpszName,
                           size_t cchName,
                           LPFONTDESCINFO lpFDI,
                           DWORD *lpdwStatus)
{
    DWORD dwStatus;
    sfnt_pNameTable pNames;
    WORD            size;
    TCHAR           szSubFamily[ 64 ];

    IDBlock_t       ID_DefBlock = ID_Block;

    if (lpdwStatus)
    {
        dwStatus = *lpdwStatus;
    }
    else
    {
        dwStatus = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
    }

    ID_DefBlock.id_Language = (ID_DefBlock.id_Platform == PLATFORM_MS)
                                                         ? LANG_US_ENG : 0;

    size = (WORD) SWAPL( pTTTag->dwLength );

    *lpszName = 0;

    pNames = (sfnt_pNameTable) LocalAlloc( LPTR, size );

    if( pNames )
    {
        if (ERROR_SUCCESS == file.Read(pNames, size))
        {
            //
            //  The logic for what name to find:
            //  If font file was converted from a Type1 font
            //     1) POSTCRIPT_ID in current language
            //  else
            //     1) FACENAME_ID in current language.
            //  2) FAMILY and SUBFAMILY in current language.
            //  3) FACENAME_ID in default language.
            //
            // If the TrueType font was converted from a Type1 font, we want
            // to use the "postscript" form of the font description so that
            // it matches the description returned by IsPSFont() when invoked
            // on the "parent" Type1 file.  These descriptions are used as registry
            // keys in the "Fonts" and "Type1Fonts" sections and must match.
            //
            if (bIsConvertedTrueType(pNames, ID_Block) &&
                bFindNameThing(pNames, ID_Block, POSTSCRIPT_ID, lpszName, cchName))
            {
               //
               // Replace all dashes with spaces (same as .PFM/.INF file reader code)
               //
               for (LPTSTR pc = lpszName; *pc; pc++)
                 if (*pc == TEXT('-'))
                    *pc = TEXT(' ');
            }
            else if( bFindNameThing( pNames, ID_Block, FACENAME_ID, lpszName, cchName ) )
               ;
            else if( bFindNameThing( pNames, ID_Block, SUBFAMILY_ID, szSubFamily, ARRAYSIZE(szSubFamily) )
                 && (bFindNameThing( pNames, ID_Block,    FAMILY_ID, lpszName, cchName )
                 ||  bFindNameThing( pNames, ID_DefBlock, FAMILY_ID, lpszName, cchName ) ) )
            {
                StringCchCat( lpszName, cchName, TEXT( " " ) );
                StringCchCat( lpszName, cchName, szSubFamily );
            }
            else( bFindNameThing( pNames, ID_DefBlock, FACENAME_ID, lpszName, cchName ) )
                ;

            //
            //  Get the names for the font description if requested.
            //

            if( lpFDI )
            {
                if( lpFDI->dwFlags & FDI_FAMILY )
                {
                    lpFDI->szFamily[ 0 ] = 0;

                    if( !bFindNameThing( pNames, ID_Block, FAMILY_ID,
                                         lpFDI->szFamily, ARRAYSIZE(lpFDI->szFamily) ) )
                        bFindNameThing( pNames, ID_DefBlock, FAMILY_ID,
                                        lpFDI->szFamily, ARRAYSIZE(lpFDI->szFamily) );
                }

                if( lpFDI->dwFlags & FDI_VTC )
                {
                    TCHAR  szTemp[ 256 ];

                    lpFDI->lpszVersion   = 0;
                    lpFDI->lpszTrademark = 0;
                    lpFDI->lpszCopyright = 0;


                    if( bFindNameThing( pNames, ID_Block, VERSION_ID, szTemp, ARRAYSIZE(szTemp) ) ||
                       bFindNameThing( pNames, ID_DefBlock, VERSION_ID, szTemp, ARRAYSIZE(szTemp) ) )
                    {
                        const size_t cchVersion = lstrlen(szTemp) + 1;
                        lpFDI->lpszVersion = new TCHAR[ cchVersion ];

                        if( lpFDI->lpszVersion )
                            StringCchCopy( lpFDI->lpszVersion, cchVersion, szTemp );
                        else
                            dwStatus = FVS_MAKE_CODE(FVS_MEM_ALLOC_ERR, FVS_FILE_UNK);
                    }

                    if( bFindNameThing( pNames, ID_Block, COPYRIGHT_ID, szTemp, ARRAYSIZE(szTemp) ) ||
                       bFindNameThing( pNames, ID_DefBlock, COPYRIGHT_ID, szTemp, ARRAYSIZE(szTemp) ) )
                    {
                        const size_t cchCopyright = lstrlen(szTemp) + 1;
                        lpFDI->lpszCopyright = new TCHAR[ cchCopyright ];

                        if( lpFDI->lpszCopyright )
                            StringCchCopy( lpFDI->lpszCopyright, cchCopyright, szTemp );
                        else
                            dwStatus = FVS_MAKE_CODE(FVS_MEM_ALLOC_ERR, FVS_FILE_UNK);
                    }

                    if( bFindNameThing( pNames, ID_Block, TRADEMARK_ID, szTemp, ARRAYSIZE(szTemp) ) ||
                       bFindNameThing( pNames, ID_DefBlock, TRADEMARK_ID, szTemp, ARRAYSIZE(szTemp) ) )
                    {
                        const size_t cchTrademark = lstrlen(szTemp) + 1;
                        lpFDI->lpszTrademark = new TCHAR[ cchTrademark ];

                        if( lpFDI->lpszTrademark )
                            StringCchCopy( lpFDI->lpszTrademark, cchTrademark, szTemp );
                        else
                            dwStatus = FVS_MAKE_CODE(FVS_MEM_ALLOC_ERR, FVS_FILE_UNK);
                    }
                }

            }
        }
        LocalFree( (HANDLE)pNames );
   }

   if (lpdwStatus)
   {
       *lpdwStatus = dwStatus;
   }

   return *lpszName != 0;
}


void NEAR PASCAL FillName( LPTSTR            szName,
                           size_t            cchName,
                           sfnt_lpNameRecord pNameRecord, // unsigned PlatformID,
                           WORD              igi,         // string length (bytes)
                           LPBYTE            pStringByte )
{
    if( pNameRecord->wPlatformID == PLATFORM_MS )
    {
        //
        //  wName now contains the flipped bytes.
        //  Decode depending on the way the string was encoded.
        //
        //  Rules:
        //     Encodind ID=1 (Unicode)
        //        Unicode
        //
        //     Encoding ID=2 (ShiftJIS)
        //        Unicode
        //
        //     Encoding ID=3 (PRC GB2312)
        //        Uses two bytes per character and GB2312 encoding. Single byte
        //        characters need null padding for leading byte.
        //
        //     Encoding ID=4 (Big 5)
        //        Uses two bytes per character and Big 5 encoding. Single byte
        //        characters need null padding for leading byte.
        //
        //     Encoding ID=5 (Wangsung)
        //        Uses two bytes per character and Wangsung encoding. Single byte
        //        characters need null padding for leading byte.
        //
        //     Encoding ID=6 (Johab)
        //        Uses two bytes per character and Johab encoding. Single byte
        //        characters need null padding for leading byte.
        //

        switch( pNameRecord->wSpecificID )
        {
        case ENCODEID_PRC:
        case ENCODEID_BIG5:
        case ENCODEID_WANGSUNG:
        case ENCODEID_JOHAB:
            if (g_bDBCS)
            {
                //
                // Running on a DBCS system.  Copy to wName[] buffer
                // and nul-terminate then convert to UNICODE for output.
                //
                WORD wName[ 64 ];
                LPSTR pszRead  = (LPSTR)pStringByte;
                LPSTR pszWrite = (LPSTR)wName;
                LPSTR pszEnd   = (LPSTR)wName + sizeof(wName) - 1;

                for(int i = 0; i < igi && pszWrite < pszEnd; i++)
                {
                    if(IsDBCSLeadByte(*pszRead))
                    {
                        *pszWrite++ = *pszRead++;
                        i++;
                    }
                    else if(!*pszRead)
                    {
                        pszRead++;
                        i++;
                    }
                    if (pszWrite < pszEnd)
                    {
                        *pszWrite++ = *pszRead++;
                    }
                }

                *pszWrite = (BYTE) 0;

                MultiByteToWideChar(CP_ACP,0,(LPSTR)wName,-1,szName,cchName);
            }
            else // !g_bDBCS
            {
                //
                // Running on a non-DBCS system.  Copy directly to
                // output and nul-terminate.
                //
                LPSTR  pszRead  = (LPSTR)pStringByte;
                LPTSTR pszWrite = szName;
                LPTSTR pszEnd   = szName + cchName - 1;
                for(int i = 0; i < igi && pszWrite < pszEnd; i++)
                {
                    if( IsDBCSLeadByte( *pszRead ) )
                    {
                        *pszWrite++ = (TCHAR)*pszRead++;
                        i++;
                    }
                    else if(!*pszRead)
                    {
                        pszRead++;
                        i++;
                    }
                    if (pszWrite < pszEnd)
                    {
                        *pszWrite++ = (TCHAR)*pszRead++;
                    }
                }

                *pszWrite = (TCHAR) 0;
            }

            break;


         default:
            //
            // This name string is really a string of UNICODE characters.
            // Use pStringWord to walk the string.
            // Even though the characters are UNICODE, we still need
            // to swap bytes from Mac format before copying to the output. 
            //
            ZeroMemory(szName, cchName * sizeof(szName[0]));

            WORD UNALIGNED *pStringWord = (PWORD)pStringByte;
            const int cchMax = min(igi / sizeof(WCHAR), cchName);
            for (int i = 0; i < cchMax; i++)
            {
                szName[i] = SWAPW(pStringWord[i]);
            }
            szName[cchName-1] = 0;
        }  // End of switch( )

    }
    else
    {
        //
        //  Mac font
        //

        szName[ igi ] = (TCHAR) 0;

        while( igi--)
            szName[ igi ] = Mac2Ansi( pStringByte[ igi ] );
    }
}



DWORD GetFontDefaultLangID( )
{
    //
    //  set it initally to illegal value
    //

    static DWORD dwLangID = 0xffffffff;


    //
    //  Only do this once
    //

    if( dwLangID == 0xffffffff )
    {
        //
        //  Default to English
        //

        DWORD dwTemp = 0x00000409;
        TCHAR   szModName[ PATHMAX ];
        DWORD   dwSize, dwHandle;
        LPVOID  lpvBuf;


        if( GetModuleFileName( g_hInst, szModName, ARRAYSIZE(szModName) ) )
        {
            if( dwSize = GetFileVersionInfoSize( szModName, &dwHandle ) )
            {
                if( lpvBuf = (LPVOID) LocalAlloc( LPTR, dwSize ) )
                {
                    if( GetFileVersionInfo( szModName, dwHandle, dwSize, lpvBuf ) )
                    {
                        struct
                        {
                            WORD wLang;
                            WORD wCodePage;
                        } *lpTrans;

                        UINT uSize;

                        if( VerQueryValue( lpvBuf,
                                           TEXT( "\\VarFileInfo\\Translation" ),
                                           (LPVOID *) &lpTrans,
                                           &uSize )
                            && uSize >= sizeof( *lpTrans ) )
                        {
                            dwTemp = lpTrans->wLang;
                        }
                    }
                    LocalFree( (HLOCAL) lpvBuf );
                }
            }
        }

        //
        //  Use dwTemp so this is re-entrant (if not efficient)
        //

        dwLangID = dwTemp;
    }

    return( dwLangID );
}

///////////////////////////////////////////////////////////////////////////////
//
//  bValidateTrueType
//
//  The following list contains the possible status values
//  written to lpdwStatus. See fvscodes.h for details.
//
//  FVS_SUCCESS
//  FVS_INVALID_FONTFILE
//  FVS_MEM_ALLOC_ERR
//
///////////////////////////////////////////////////////////////////////////////
BOOL bValidateTrueType( CFontFile& file,
                        DWORD dwOffset,
                        LPFONTDESCINFO lpFile,
                        DWORD *pdwTableTags,
                        LPDWORD lpdwStatus )
{
    struct cmap_thing {
        sfnt_char2IndexDir    DirCmap;
        sfnt_platformEntry    Plat[ 2 ];
    } Cmap;

    tt_hdr     TTHeader;
    tt_head    TTFontHeader;

    IDBlock_t  ID_Block;
    tttag*     pTags;

    sfnt_platformEntry FAR* lpPlat;

    short      i, nTables;
    DWORD      dwSize;
    unsigned   cTables, ncTables;
    BOOL       result = FALSE;
    //
    // Most errors from this function are "header" errors.
    // Therefore, we default to this type of error code.
    //
    DWORD dwStatus = FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);

    //
    // Initialize return status value.
    //
    if (NULL != lpdwStatus)
        *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_STATUS, FVS_FILE_UNK);

    //
    //  Init the ID block.
    //

    ID_Block.id_Platform = (WORD) -1;

    WORD wLangID = (WORD) GetFontDefaultLangID( );

    ID_Block.id_Language = SWAPW( wLangID );   // SWAPW( info.nLanguageID );

    //
    //  Load the TTF directory header.
    //
    file.Seek(dwOffset, FILE_BEGIN);

    if (ERROR_SUCCESS != file.Read(&TTHeader, sizeof(TTHeader)))
        goto IsTrueType_closefile;

    //
    //  If number of tables is so large that LocalAlloc fails, then the font
    //  will be blown off.
    //

    if( ( nTables = SWAPW( TTHeader.uNumTables ) ) > 0x7fff / sizeof( tttag ) )
    {
        DEBUGMSG( ( DM_ERROR, TEXT( "bIsTrueType: header too large." ) ) );
        goto IsTrueType_closefile;
    }

    i = nTables * sizeof( tttag );

    if( !(pTags = (tttag *) LocalAlloc( LPTR, i ) ) )
    {
        DEBUGMSG( ( DM_ERROR, TEXT( "bIsTrueType( ): LocalAlloc failed." ) ) );
        dwStatus = FVS_MAKE_CODE(FVS_MEM_ALLOC_ERR, FVS_FILE_UNK);
        goto IsTrueType_closefile;
    }

    if (ERROR_SUCCESS != file.Read(pTags, i))
    {
        DEBUGMSG( ( DM_ERROR, TEXT( "bIsTrueType(): File READ failure" ) ) );
        goto FailAndFree;
    }

    //
    //  the tables are in sorted order, so we should find 'cmap'
    //  before 'head', then 'name'
    //

    //  first we find the cmap table so we can find out what PlatformID
    //  this font uses
    //

    for( i = 0; i < nTables; i++ )
    {
        if( pTags[ i ].dwTag == TAG_CHARTOINDEXMAP )
        {
            //
            //  get platform stuff
            //
            file.Seek(SWAPL(pTags[ i ].dwOffset), FILE_BEGIN);

            if (ERROR_SUCCESS != file.Read(&Cmap, sizeof(Cmap), &dwSize))
                break;
            else if( ( ncTables = SWAPW( Cmap.DirCmap.wNumTables ) ) == 1 )
            {
                if( dwSize < sizeof( Cmap )-sizeof( Cmap.Plat[ 1 ] ) )
                    break;
            }

            for( cTables = 0; cTables < ncTables; cTables++ )
            {
                //
                //  we read 2 platform entries at a time
                //

                if( cTables >= 2 && !(cTables & 1 ) )
                {
                    dwSize = ncTables-cTables>1 ? sizeof( Cmap.Plat )
                                                : sizeof( Cmap.Plat[ 0 ]);

                    if (ERROR_SUCCESS != file.Read(Cmap.Plat, dwSize))
                        break;
                }

                lpPlat = &Cmap.Plat[ cTables & 01 ];

                //
                //  Unicode: get this and exit
                //

                if( lpPlat->wPlatformID == PLATFORM_MS )
                {
                    DEBUGMSG( (DM_TRACE1, TEXT( "--- PlatformID is PLATFORM_MS" ) ) );

                    ID_Block.id_Platform = lpPlat->wPlatformID;
                    ID_Block.id_Specific = lpPlat->wSpecificID;
                    break;
                }

                //
                //  Mac: get it, hope the Unicode platform will come
                //

                if( lpPlat->wPlatformID == 0x100 && lpPlat->wSpecificID == 0 )
                {
                    ID_Block.id_Platform = lpPlat->wPlatformID;
                    ID_Block.id_Specific = lpPlat->wSpecificID;
                }
            }
            break; // found continue below
        }
    }

    if( ID_Block.id_Platform == (WORD)-1 )
    {
        DEBUGMSG( ( DM_ERROR, TEXT( "bIsTrueType( ): No platform id" ) ) );
        goto FailAndFree;
    }

    //
    //  we found 'cmap' with the PlatformID now look for 'head'
    //  then 'name'

    while( ++i < nTables )
    {
        if( pTags[ i ].dwTag == TAG_FONTHEADER )
        {
            file.Seek(SWAPL( pTags[ i ].dwOffset ), FILE_BEGIN);

            if (ERROR_SUCCESS != file.Read(&TTFontHeader, sizeof(TTFontHeader))
                || TTFontHeader.dwMagic != SFNT_MAGIC )
            {
                DEBUGMSG( (DM_ERROR, TEXT( "WRONG MAGIC! : %x" ), TTFontHeader.dwMagic ) );
                goto FailAndFree;
            }
            break;
        }
    }

    //
    //  At this point, the function is successful. If the caller wants a
    //  description and can't get it, return false (see next block).
    //

    result = TRUE;

    //
    //  Retrieve the font name (description) and family name if they were
    //  requested.
    //

    if( lpFile->dwFlags & (FDI_DESC | FDI_FAMILY ) )
    {
        while( ++i < nTables )
        {
            if( pTags[ i ].dwTag == TAG_NAMINGTABLE )
            {
                file.Seek(SWAPL( pTags[ i ].dwOffset ), FILE_BEGIN);
                result = bGetName( file, &pTags[ i ], ID_Block, lpFile->szDesc,
                                   ARRAYSIZE(lpFile->szDesc), lpFile, &dwStatus );
                break;
            }
       }
    }

    //
    //  if requested, get the style and PANOSE information.
    //

    if( lpFile->dwFlags & (FDI_STYLE | FDI_PANOSE ) )
    {
        for( i = 0; i < nTables; i++ )
        {
            if( pTags[ i ].dwTag == TAG_OS2TABLE )
            {

#define WEIGHT_OFFSET   4
#define PAN_OFFSET      32
#define SEL_OFFSET      62

                DWORD dwStart = SWAPL( pTags[ i ].dwOffset );

                if( lpFile->dwFlags & FDI_PANOSE )
                {
                    file.Seek(dwStart + PAN_OFFSET, FILE_BEGIN);
                    file.Read(lpFile->jPanose, sizeof(lpFile->jPanose));
                }

                if( lpFile->dwFlags & FDI_STYLE )
                {
                    WORD  wTemp;

                    file.Seek(dwStart + WEIGHT_OFFSET, FILE_BEGIN);
                    file.Read(&wTemp, sizeof(wTemp));

                    lpFile->wWeight = SWAPW( wTemp );

                    file.Seek(dwStart + SEL_OFFSET, FILE_BEGIN);
                    file.Read(&wTemp, sizeof(wTemp));

                    wTemp = SWAPW( wTemp );

                    lpFile->dwStyle  = (wTemp & 0x0001) ? FDI_S_ITALIC
                                                        : FDI_S_REGULAR;

                    lpFile->dwStyle |= (wTemp & 0x0020) ? FDI_S_BOLD : 0;
                }
                break;
            }
        }
    }

    if (NULL != pdwTableTags)
    {
        //
        // Caller want's to know exactly what tables the font contains.
        // Would prefer to do this in one of the earlier loops but they
        // all have early exits.  This is the only reliable way to get the
        // table info.  It's merely comparing DWORDs so it's very fast.
        //
        *pdwTableTags = 0;
        for (i = 0; i < nTables; i++)
        {
            switch(pTags[i].dwTag)
            {
                case TAG_CHARTOINDEXMAP:  *pdwTableTags |= TT_TABLE_CMAP; break;
                case TAG_FONTHEADER:      *pdwTableTags |= TT_TABLE_HEAD; break;
                case TAG_NAMINGTABLE:     *pdwTableTags |= TT_TABLE_NAME; break;
                case TAG_OS2TABLE:        *pdwTableTags |= TT_TABLE_OS2;  break;
                case TAG_DSIG:            *pdwTableTags |= TT_TABLE_DSIG; break;
                case TAG_CFF:             *pdwTableTags |= TT_TABLE_CFF;  break;
                default:
                    break;
            }
        }
    }

FailAndFree:

    LocalFree( (HANDLE) pTags );

IsTrueType_closefile:

    //
    // If successful, update verification status for success.
    // Otherwise, leave at assigned error code.
    //
    if (NULL != lpdwStatus)
        *lpdwStatus = (result ? FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK) : dwStatus);

    return result;
}


///////////////////////////////////////////////////////////////////////////////
//
//  bIsTrueType
//
//  The following list contains the possible status values
//  written to lpdwStatus. See fvscodes.h for details.
//
//  FVS_SUCCESS
//  FVS_INVALID_FONTFILE
//  FVS_MEM_ALLOC_ERR
//  FVS_FILE_OPEN_ERR
//  FVS_INSUFFICIENT_BUF
//
///////////////////////////////////////////////////////////////////////////////
BOOL NEAR PASCAL bIsTrueType( LPFONTDESCINFO lpFile, DWORD *pdwTableTags, LPDWORD lpdwStatus )
{
    ttc_hdr     TTCHeader;
    CFontFile   file;
    DWORD       i;
    BOOL        result = FALSE;
    DWORD       *pdwDirectory = 0;
    FontDesc_t  szFontDesc;
    TCHAR       szConcat[ 32 ];


    DEBUGMSG( (DM_TRACE1, TEXT( "bIsTrueType() checking file %s" ), lpFile->szFile ) );

    if (ERROR_SUCCESS != file.Open(lpFile->szFile, GENERIC_READ, FILE_SHARE_READ))
    {
        if (NULL != lpdwStatus)
            *lpdwStatus = FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_UNK);

        return( FALSE );
    }

    //
    // If any of this code causes return of FALSE,
    // we return INVALID_FONTFILE unless indicated otherwise by
    // explicitely setting the return code.
    //
    if (NULL != lpdwStatus)
        *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);

    if(ERROR_SUCCESS != file.Read(&TTCHeader, sizeof(TTCHeader)))
        goto IsTrueType_closefile;

    //
    //  Check for a TTC file.
    //

    if( TTCHeader.dwTag == TAG_TTCF )
    {
       if( !LoadString( g_hInst, IDS_TTC_CONCAT, szConcat, ARRAYSIZE( szConcat ) ) )
            StringCchCopy( szConcat, ARRAYSIZE(szConcat), TEXT( " & " ) );

       TTCHeader.dwDirCount  = SWAPL( TTCHeader.dwDirCount );

       //
       //  Load in the first directory, for now.
       //

       if( !TTCHeader.dwDirCount )
            goto IsTrueType_closefile;

       pdwDirectory = new DWORD [ TTCHeader.dwDirCount ];

       if( !pdwDirectory )
            goto IsTrueType_closefile;

       file.Seek(sizeof(TTCHeader), FILE_BEGIN);

       DWORD dwBytesToRead = sizeof( DWORD ) * TTCHeader.dwDirCount;

       if(ERROR_SUCCESS != file.Read(pdwDirectory, dwBytesToRead))
            goto IsTrueType_closefile;
    }
    else
    {
        TTCHeader.dwDirCount = 1;

        pdwDirectory = new DWORD [ 1 ];

        if( !pdwDirectory )
            goto IsTrueType_closefile;

        *pdwDirectory = 0;
    }

    //
    //  For each TrueType directory, process it.
    //

    szFontDesc[ 0 ] = 0;

    for( i = 0; i < TTCHeader.dwDirCount; i++ )
    {
        //
        //  Save of the description of the previous font.
        //

        if( i && ( lpFile->dwFlags & FDI_DESC ) )
        {
           vCPStripBlanks(lpFile->szDesc, ARRAYSIZE(lpFile->szDesc));
           if( ( lstrlen( szFontDesc ) + lstrlen( lpFile->szDesc )
                 + lstrlen( szConcat ) + 1 ) > ARRAYSIZE( szFontDesc ) )
           {
                if (NULL != lpdwStatus)
                    *lpdwStatus = FVS_MAKE_CODE(FVS_INSUFFICIENT_BUF, FVS_FILE_UNK);

                goto IsTrueType_closefile;
           }

           StringCchCat( szFontDesc, ARRAYSIZE(szFontDesc), lpFile->szDesc );

           StringCchCat( szFontDesc, ARRAYSIZE(szFontDesc), szConcat );
        }

        if( !bValidateTrueType( file, SWAPL( *(pdwDirectory + i ) ), lpFile, pdwTableTags, lpdwStatus ) )
            goto IsTrueType_closefile;
    }

    //
    //  If we did more than one font, then we have to add the name of the
    //  last one to the list.
    //

    if( TTCHeader.dwDirCount > 1 )
    {
        if( lpFile->dwFlags & FDI_DESC )
        {
            vCPStripBlanks(lpFile->szDesc, ARRAYSIZE(lpFile->szDesc));
            if( ( lstrlen( szFontDesc ) + lstrlen( lpFile->szDesc )
                  + lstrlen( szConcat ) + 1 ) > ARRAYSIZE( szFontDesc ) )
                goto IsTrueType_closefile;

          StringCchCat( szFontDesc, ARRAYSIZE(szFontDesc), lpFile->szDesc );

          StringCchCopy( lpFile->szDesc, ARRAYSIZE(lpFile->szDesc), szFontDesc );
        }
    }

    result = TRUE;

IsTrueType_closefile:

    if( pdwDirectory )
        delete [] pdwDirectory;

    DEBUGMSG( (DM_TRACE1, TEXT( "bIsTrueType() returning %d" ), result ) );

    //
    // If successful, update verification status.
    // Otherwise, leave at assigned error code.
    //
    if ((NULL != lpdwStatus) && result)
        *lpdwStatus = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);

    return result;
}



void NEAR PASCAL vReadCountedString( CFontFile& file, LPSTR lpString, int iLen )
{
    char cBytes;

    file.Read(&cBytes, 1);

    //
    //  Limit check 6 August 1990    clarkc
    //

    cBytes = __min( cBytes, iLen-1 );

    file.Read(lpString, cBytes);

    *(lpString + cBytes) = 0;
}


BOOL bReadNewExeInfo( CFontFile& file,
                      struct new_exe * pne,
                      long             lHeaderOffset,
                      LPFONTDESCINFO   lpFile )
{
    LONG  lResTable = pne->ne_rsrctab + lHeaderOffset;
    BOOL  bRet = FALSE;
    WORD  wShiftCount;

    struct rsrc_typeinfo rt;
    struct rsrc_nameinfo ri;

    LPFONTENTRY pfe;


    //
    //  Fix up the lpFile in case we bail early.
    //

    lpFile->lpszVersion = lpFile->lpszCopyright = lpFile->lpszTrademark = 0;

    //
    //  Move to the beginning of the resource table.
    //

    file.Seek(lResTable, FILE_BEGIN);

    //
    //  Read the shift count.
    //
    if(ERROR_SUCCESS != file.Read(&wShiftCount, 2))
        goto backout;

    //
    //  Quick validity check.
    //

    if( wShiftCount > 12 )
        goto backout;

    //
    //  Read the resources until we hit the FONTDIR
    //

    while( TRUE )
    {
        memset( &rt, 0, sizeof( rt ) );

        if(ERROR_SUCCESS != file.Read(&rt, sizeof(rt)))
            goto backout;

        if( rt.rt_id == 0 )
            break;

        if( M_INTEGERTYPE( rt.rt_id ) && M_FONTDIRTYPE( rt.rt_id ) )
        {
            //
            //  Read one resinfo record. We don't need all of them. The
            //  style and name of all should be the same.
            //

            if (ERROR_SUCCESS != file.Read(&ri, sizeof(ri)))
                goto backout;


            LONG lOffset = ( (LONG) ri.rn_offset ) << wShiftCount;
            LONG lSize   = ( (LONG) ri.rn_length ) << wShiftCount;

            //
            //  Allocate memory for the resource.
            //

            LPSTR lpMem = new char [ lSize ];


            if( !lpMem )
                goto backout;

            file.Seek(lOffset, FILE_BEGIN);

            LPSTR lpTMem = lpMem;

            while( lSize )
            {
                WORD wSize;

                if( lSize >= 32767 )
                   wSize = 32767;
                else
                   wSize = (WORD) lSize;

                if (ERROR_SUCCESS != file.Read(lpTMem, wSize))
                {
                   delete [] lpMem;
                   goto backout;
                }

                lSize -= wSize;
                lpTMem += wSize;
            }

            //
            //  The first word is the font count and the rest is a chunk of
            //  font entries.
            //

            int nFonts = (int)*( (unsigned short *) lpMem );

            pfe = (LPFONTENTRY) (lpMem + sizeof( WORD ) );

            if( lpFile->dwFlags & FDI_STYLE )
            {
               lpFile->dwStyle = (pfe->dfItalic ) ? FDI_S_ITALIC : FDI_S_REGULAR;

               lpFile->wWeight = pfe->dfWeight;
            }

            if( lpFile->dwFlags & FDI_FAMILY )
            {
                LPSTR lpFace;
                LPSTR lpDev = pfe->szDeviceName;

                lpFace = lpDev + lstrlenA( lpDev ) + 1;

                MultiByteToWideChar( CP_ACP, 0, lpFace, -1,
                                     lpFile->szFamily, ARRAYSIZE(lpFile->szFamily) );
            }

            if( lpFile->dwFlags & FDI_VTC )
            {
                //
                //  No version or trademark. Get the copyright.
                //

                lpFile->lpszCopyright = new TCHAR[ COPYRIGHT_LEN ];
                if( lpFile->lpszCopyright )
                {
                    MultiByteToWideChar( CP_ACP, 0, pfe->dfCopyright, -1,
                                         lpFile->lpszCopyright, COPYRIGHT_LEN );
                }
                else
                {
                    delete[] lpMem;
                    goto backout;
                }
            }

            bRet = TRUE;
            delete [] lpMem;

            //
            //  We got one, get out of here.
            //

            break;
        }
    }

backout:
    return bRet;
}

BOOL NEAR PASCAL bIsNewExe( LPFONTDESCINFO lpFile )
{
    BOOL     bValid = FALSE;
    long     lNewHeader;
    CFontFile file;

    struct exe_hdr oeHeader;
    struct new_exe neHeader;


    if (ERROR_SUCCESS == file.Open(lpFile->szFile, GENERIC_READ, FILE_SHARE_READ))
    {
        file.Read(&oeHeader, sizeof(oeHeader));

        if( oeHeader.e_magic == EMAGIC && oeHeader.e_lfanew )
            lNewHeader = oeHeader.e_lfanew;
        else
            lNewHeader = 0L;

        file.Seek(lNewHeader, FILE_BEGIN);

        file.Read(&neHeader, sizeof(neHeader));

        if( neHeader.ne_magic == NEMAGIC )
        {
            //
            // seek to the description, and read it
            //
            file.Seek(neHeader.ne_nrestab, FILE_BEGIN);

            char szTemp[ DESCMAX ];

            vReadCountedString( file, szTemp, ARRAYSIZE(szTemp));

            MultiByteToWideChar( CP_ACP, 0, szTemp, -1,
                                     lpFile->szDesc, ARRAYSIZE(lpFile->szDesc));

            bValid = TRUE;

            //
            //  If requested, get family and style information.
            //

            if( lpFile->dwFlags & (FDI_FAMILY | FDI_STYLE | FDI_VTC ) )
            {
                bValid = bReadNewExeInfo( file, &neHeader, lNewHeader, lpFile );
            }
        }
    }

    return bValid;
}


//
//  find a TT name matching the platform specific and language from
//  the name table
//
//  in:
//     pNames        name table to search
//     PlatformID    search for this
//     SpecificID    and this
//     uLanguageID    and this
//     NameID        this is the name type
//
//  out:
//     szName        name if found
//
//  returns:
//     TRUE    name found, szName contains the name
//     FALSE    name not found, szName is NULL
//

BOOL NEAR PASCAL bFindNameThing( sfnt_pNameTable pNames, IDBlock_t &ID_Block,
                                 WORD NameID, LPTSTR szName, size_t cchName )
{
    sfnt_lpNameRecord pNameRecord;

    sfnt_lpNameRecord pFoundRecord = NULL;

    int     cNames;
    LPBYTE  pStringArea;
    WORD    wWantLang = SWAPW( ID_Block.id_Language );


    szName[ 0 ] = 0;

    //
    //  Verify that this, indeed, is a name thing. The format should be zero.
    //

    if( pNames->wFormat )
        return FALSE;

    cNames = SWAPW( pNames->wCntRecords );

    pNameRecord = (sfnt_pNameRecord)( (LPBYTE) pNames + sizeof( sfnt_NameTable ) );

    for( ; cNames--; pNameRecord++ )
    {
        if( pNameRecord->wPlatformID == ID_Block.id_Platform &&
            pNameRecord->wSpecificID == ID_Block.id_Specific &&
            pNameRecord->wNameID     == NameID )
        {
            //
            //  Check the language matches
            //

            WORD wFoundLang = SWAPW( pNameRecord->wLanguageID );

            if( PRIMARYLANGID( wFoundLang ) != PRIMARYLANGID( wWantLang ) )
            {
                continue;
            }

            pFoundRecord = pNameRecord;

            //
            //  Check the locale matches too
            //

            if( pNameRecord->wLanguageID == ID_Block.id_Language )
            {
                break;
            }
        }
    }

    if( pFoundRecord )
    {
        pNameRecord = pFoundRecord;

        pStringArea  = (LPBYTE) pNames;
        pStringArea += SWAPW( pNames->wOffsetString );
        pStringArea += SWAPW( pNameRecord->wOffset );

        FillName( szName, cchName, pNameRecord, //->wPlatformID,
                  SWAPW( pNameRecord->wLength ), pStringArea );

        return TRUE;
    }

    DEBUGMSG( (DM_ERROR, TEXT( "bFindNameThing(): ERROR!" ) ) );
    DEBUGMSG( (DM_ERROR, TEXT( "--- Platform: %x  Specific: %x   Language: %x" ),
            ID_Block.id_Platform, ID_Block.id_Specific, ID_Block.id_Language) );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\fontview.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// fontview.cpp
//      Explorer Font Folder extension routines.
//      Implementation for the CFontView class.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================


#include "priv.h"
#include "globals.h"
#include "fonthelp.h"
#include "fontview.h"
#include "fontman.h"
#include "fontcl.h"
#include "fontlist.h"
#include "cpanel.h"
#include "resource.h"
#include "ui.h"
#include "dbutl.h"
#include "extricon.h"


#include <sys\stat.h>
#include <time.h>
#include <htmlhelp.h>
#include <regstr.h>


#ifdef __cplusplus
extern "C" {
#endif

//
// APPCOMPAT:  Hack to avoid duplicate-macro error.  platform.h (included by shlobjp.h)
//          also defines a PATH_SEPARATOR macro (as does wingdip.h).  None of the
//          code in fontview.cpp uses this macro.  Once the name conflict is
//          removed from the headers, we can remove this undefinition hack.
//          [brianau - 3/6/98]
//
#ifdef PATH_SEPARATOR
#   undef PATH_SEPARATOR
#endif
#include <wingdip.h>

#ifdef __cplusplus
}
#endif

#define BOOLIFY(expr)   (!!(expr))

#define FFCOL_DEFAULT -1
#define FFCOL_NAME 0
#define FFCOL_PANOSE 1
#define FFCOL_FILENAME 1
#define FFCOL_SIZE 2
#define FFCOL_MODIFIED 3
#define FFCOL_ATTRIBUTES 4

#define WID_LISTVIEW 2

const INT FONT_SAMPLE_PT_SIZE = 16;

//
// Message for shell change notifications.
// Same value as WM_DSV_FSNOTIFY.
//
#define WM_SHELL_CHANGE_NOTIFY (WM_USER + 0xA0)

UINT const cDeadMenu = MF_BYCOMMAND | MF_DISABLED | MF_GRAYED;
UINT const cLiveMenu = MF_BYCOMMAND | MF_ENABLED;

UINT const kMinPointSize = 8;

const int kBaseViewStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP | LVS_AUTOARRANGE;

TCHAR* g_szViewClass = TEXT( "FONTEXT_View" );

//
// List of file attribute bit values.  The order (with respect
// to meaning) must match that of the characters in g_szAttributeChars[].
//
const DWORD g_adwAttributeBits[] = {
                                    FILE_ATTRIBUTE_READONLY,
                                    FILE_ATTRIBUTE_HIDDEN,
                                    FILE_ATTRIBUTE_SYSTEM,
                                    FILE_ATTRIBUTE_ARCHIVE,
                                    FILE_ATTRIBUTE_COMPRESSED
                                   };

#define NUM_ATTRIB_CHARS  ARRAYSIZE(g_adwAttributeBits)

//
// Buffer for characters that represent attributes in Details View attributes
// column.  Must provide room for 1 character for each bit and a NUL.  The current 5
// represent Read-only, Hidden, System, Archive, and Compressed in that order.
// This can't be const because we overwrite it using LoadString.
//
TCHAR g_szAttributeChars[NUM_ATTRIB_CHARS + 1] = { 0 } ;

//
// Things associated with "alternate" color for compressed files in folder.
//

COLORREF g_crAltColor      = RGB(0,0,255);     // Color defaults to blue.
HKEY g_hkcuExplorer        = NULL;
TCHAR const c_szAltColor[] = TEXT("AltColor"); // Reg loc for setting.


#pragma data_seg(".text", "CODE")
const static DWORD rgOptionPropPageHelpIDs[] =
{
    IDC_TTONLY, IDH_FONTS_TRUETYPE_ON_COMPUTER,
    0,0
};

#pragma data_seg()


//***   IsBackSpace -- is key a Backspace
BOOL IsBackSpace(LPMSG pMsg)
{
    return pMsg && (pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_BACK);
}

//***   IsVK_TABCycler -- is key a TAB-equivalent
// ENTRY/EXIT
//  dir     0 if not a TAB, non-0 if a TAB
// NOTES
//  NYI: -1 for shift+tab, 1 for tab
//
int IsVK_TABCycler(MSG *pMsg)
{
    if (!pMsg)
        return 0;

    if (pMsg->message != WM_KEYDOWN)
        return 0;
    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        return 0;

    return (GetKeyState(VK_SHIFT) < 0) ? -1 : 1;
}


// ***********************************************************************
// ***********************************************************************
// ***********************************************************************

//
// Call CFontClass::Release() for each font object contained in the ListView.
//
void CFontView::ReleaseFontObjects(void)
{
    int iCount = ListView_GetItemCount(m_hwndList);
    LV_ITEM lvi;
    CFontClass *pFont = NULL;

    lvi.mask       = LVIF_PARAM;
    lvi.iSubItem   = 0;
    lvi.state      = 0;
    lvi.stateMask  = 0;
    lvi.pszText    = NULL;
    lvi.cchTextMax = 0;
    lvi.iImage     = 0;

    for (int i = 0; i < iCount; i++)
    {
        lvi.iItem = i;

        if (ListView_GetItem(m_hwndList, &lvi))
        {
            pFont = (CFontClass *)lvi.lParam;
            if (NULL != pFont)
                pFont->Release();
        }
    }
}


//
//  This function emulates OleSetClipboard().
//

STDAPI FFSetClipboard( LPDATAOBJECT pdtobj )
{
    HRESULT hres = NOERROR;

    if( OpenClipboard( NULL ) )    // associate it with current task.
    {
        EmptyClipboard( );

        if( pdtobj )
        {
            //
            //  Support WIN3.1 style clipboard : Just put the file name of
            //  the first item as "FileName".
            //

            FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            STGMEDIUM medium;

            hres = pdtobj->GetData( &fmte, &medium );

            if( SUCCEEDED( hres ) )
            {
                if( !SetClipboardData( CF_HDROP, medium.hGlobal ) )
                    ReleaseStgMedium( &medium );

                fmte.cfFormat = CFontData::s_CFPreferredDropEffect;
                hres = pdtobj->GetData(&fmte, &medium);
                if (SUCCEEDED(hres))
                {
                    if (!SetClipboardData(CFontData::s_CFPreferredDropEffect, medium.hGlobal))
                        ReleaseStgMedium(&medium);
                }
            }
        }
        CloseClipboard( );
    }
    else
    {
        hres = ResultFromScode( CLIPBRD_E_CANT_OPEN );
    }

    return hres;
}


// ***********************************************************************
//  Structures used to manipulate the view of the list.
//

typedef struct _COLUMN_ENTRY {
                UINT     m_iID;         //  String
                UINT     m_iWidth;      //  width of column
                UINT     m_iFormat;
} COLUMN_ENTRY;


COLUMN_ENTRY PanoseColumns[] = { { IDS_PAN_COL1, 20, LVCFMT_LEFT},
                                 { IDS_PAN_COL2, 30, LVCFMT_LEFT} };

#define PAN_COL_COUNT  (sizeof( PanoseColumns ) / sizeof( COLUMN_ENTRY ) )

COLUMN_ENTRY FileColumns[] = { { IDS_FILE_COL1, 20, LVCFMT_LEFT},
                               { IDS_FILE_COL2, 14, LVCFMT_LEFT},
                               { IDS_FILE_COL3,  6, LVCFMT_RIGHT},
                               { IDS_FILE_COL4, 15, LVCFMT_LEFT},
                               { IDS_FILE_COL5, 10, LVCFMT_RIGHT}};


const TCHAR c_szM[] = TEXT( "M" );

//
//  the width of an M
//

int g_cxM = 0;


#define FILE_COL_COUNT  (sizeof( FileColumns ) / sizeof( COLUMN_ENTRY ) )



// ***********************************************************************
//  Forward Declarations.
//

void  MergeFileMenu( HMENU hmenu, HMENU hmenuMerge );
void  MergeEditMenu( HMENU hmenu, HMENU hmenuMerge );
void  MergeViewMenu( HMENU hmenu, HMENU hmenuMerge );
void  MergeHelpMenu( HMENU hmenu, HMENU hmenuMerge );
HMENU GetMenuFromID( HMENU hmMain, UINT uID );
void  SetListColumns( HWND hWnd, UINT iCount, COLUMN_ENTRY * lpCol );


// ***********************************************************************
//  Local Functions
//

static ::HFONT hCreateFont( HDC hDC, int iPoints, const TCHAR FAR* lpFace )
{
    int FPoints = -MulDiv( iPoints, GetDeviceCaps( hDC, LOGPIXELSY ), 72 );

    return ::CreateFont( FPoints, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, lpFace );
}


UINT WSFromViewMode( UINT uMode, HWND hWnd = 0 );

UINT WSFromViewMode( UINT uMode, HWND hWnd )
{
    UINT  ws;

    if( hWnd )
        ws = GetWindowLong( hWnd, GWL_STYLE ) & ~LVS_TYPEMASK;
    else
        ws = kBaseViewStyle;

    switch( uMode )
    {
        default: // case IDM_VIEW_ICON:
            ws |= LVS_ICON;
            break;

        case IDM_VIEW_LIST:
            ws |= LVS_LIST;
            break;

        case IDM_VIEW_PANOSE:
            ws |= LVS_REPORT;
            break;
        case IDM_VIEW_DETAILS:
            ws |= LVS_REPORT;
            break;
    }

    return ws;
}


// ***********************************************************************
// ***********************************************************************
// ***********************************************************************


class CEnumFormatEtc : public IEnumFORMATETC
    {
    private:
        ULONG           m_cRef;         //Object reference count
        LPUNKNOWN       m_pUnkRef;      //For reference counting
        ULONG           m_iCur;         //Current element.
        ULONG           m_cfe;          //Number of FORMATETCs in us
        LPFORMATETC     m_prgfe;        //Source of FORMATETCs

    public:
        CEnumFormatEtc( LPUNKNOWN, ULONG, LPFORMATETC );
        ~CEnumFormatEtc( void );

        //IUnknown members that delegate to m_pUnkRef.
        STDMETHODIMP         QueryInterface( REFIID, VOID ** );
        STDMETHODIMP_(ULONG) AddRef( void );
        STDMETHODIMP_(ULONG) Release( void );

        //IEnumFORMATETC members
        STDMETHODIMP Next( ULONG, LPFORMATETC, ULONG FAR * );
        STDMETHODIMP Skip( ULONG );
        STDMETHODIMP Reset( void );
        STDMETHODIMP Clone( IEnumFORMATETC FAR * FAR * );
    };



typedef CEnumFormatEtc FAR *LPCEnumFormatEtc;


/*
 * CEnumFormatEtc::CEnumFormatEtc
 * CEnumFormatEtc::~CEnumFormatEtc
 *
 * Parameters (Constructor):
 *  pUnkRef         LPUNKNOWN to use for reference counting.
 *  cFE             ULONG number of FORMATETCs in pFE
 *  prgFE           LPFORMATETC to the array to enumerate.
 */

CEnumFormatEtc::CEnumFormatEtc( LPUNKNOWN pUnkRef, ULONG cFE, LPFORMATETC prgFE )
{
    UINT        i;

    m_cRef    = 0;
    m_pUnkRef = pUnkRef;

    m_iCur  = 0;
    m_cfe   = cFE;
    m_prgfe = new FORMATETC[ (UINT)cFE ];

    if( NULL != m_prgfe )
    {
        for( i = 0; i < cFE; i++ )
            m_prgfe[ i ] = prgFE[ i ];
    }

    return;
}


CEnumFormatEtc::~CEnumFormatEtc( void )
{
    if( NULL != m_prgfe )
        delete [] m_prgfe;

    return;
}


/*
 * CEnumFormatEtc::QueryInterface
 * CEnumFormatEtc::AddRef
 * CEnumFormatEtc::Release
 *
 * Purpose:
 *  IUnknown members for CEnumFormatEtc object.  For QueryInterface
 *  we only return out own interfaces and not those of the data
 *  object.  However, since enumerating formats only makes sense
 *  when the data object is around, we insure that it stays as
 *  long as we stay by calling an outer IUnknown for AddRef
 *  and Release.  But since we are not controlled by the lifetime
 *  of the outer object, we still keep our own reference count in
 *  order to free ourselves.
 */

STDMETHODIMP CEnumFormatEtc::QueryInterface( REFIID riid, VOID ** ppv )
{
    *ppv = NULL;

    //
    //  Enumerators are separate objects, not the data object, so
    //  we only need to support out IUnknown and IEnumFORMATETC
    //  interfaces here with no concern for aggregation.
    //

    if( IsEqualIID( riid, IID_IUnknown )
        || IsEqualIID( riid, IID_IEnumFORMATETC ) )
        *ppv = (LPVOID)this;

    //
    //  AddRef any interface we'll return.
    //

    if( NULL!=*ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef( );

        return NOERROR;
    }

    return ResultFromScode( E_NOINTERFACE );
}


STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef( void )
{
    ++m_cRef;

    m_pUnkRef->AddRef( );

    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release( void )
{
    ULONG       cRefT;

    cRefT=--m_cRef;

    m_pUnkRef->Release( );

    if( 0L == m_cRef )
        delete this;

    return cRefT;
}


/*
 * CEnumFormatEtc::Next
 *
 * Purpose:
 *  Returns the next element in the enumeration.
 *
 * Parameters:
 *  cFE             ULONG number of FORMATETCs to return.
 *  pFE             LPFORMATETC in which to store the returned
 *                  structures.
 *  pulFE           ULONG FAR * in which to return how many we
 *                  enumerated.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, S_FALSE otherwise,
 */

STDMETHODIMP CEnumFormatEtc::Next( ULONG cFE, LPFORMATETC pFE, ULONG FAR *pulFE )
{
    ULONG   cReturn = 0L;

    if( NULL == m_prgfe )
        return ResultFromScode( S_FALSE );

    if( NULL != pulFE )
        *pulFE = 0L;

    if( NULL == pFE || m_iCur >= m_cfe )
        return ResultFromScode( S_FALSE );

    while( m_iCur < m_cfe && cFE > 0 )
    {
        *pFE++ = m_prgfe[ m_iCur++ ];

        cReturn++;

        cFE--;
    }

    if( NULL!=pulFE )
        *pulFE = cReturn;

    return NOERROR;
}


/*
 * CEnumFormatEtc::Skip
 *
 * Purpose:
 *  Skips the next n elements in the enumeration.
 *
 * Parameters:
 *  cSkip           ULONG number of elements to skip.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, S_FALSE if we could not
 *                  skip the requested number.
 */

STDMETHODIMP CEnumFormatEtc::Skip( ULONG cSkip )
{
    if( ( (m_iCur + cSkip) >= m_cfe ) || NULL == m_prgfe )
        return ResultFromScode( S_FALSE );

    m_iCur += cSkip;
    return NOERROR;
}


/*
 * CEnumFormatEtc::Reset
 *
 * Purpose:
 *  Resets the current element index in the enumeration to zero.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR
 */

STDMETHODIMP CEnumFormatEtc::Reset( void )
{
    m_iCur = 0;
    return NOERROR;
}


/*
 * CEnumFormatEtc::Clone
 *
 * Purpose:
 *  Returns another IEnumFORMATETC with the same state as ourselves.
 *
 * Parameters:
 *  ppEnum          LPENUMFORMATETC FAR * in which to return the
 *                  new object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CEnumFormatEtc::Clone( LPENUMFORMATETC FAR *ppEnum )
{
    LPCEnumFormatEtc    pNew;

    *ppEnum = NULL;

    //
    //  Create the clone
    //

    pNew = new CEnumFormatEtc( m_pUnkRef, m_cfe, m_prgfe );

    if( NULL == pNew )
        return ResultFromScode( E_OUTOFMEMORY );

    pNew->AddRef( );
    pNew->m_iCur = m_iCur;

    *ppEnum = pNew;
    return NOERROR;
}

// ***********************************************************************
// ***********************************************************************
// CFontData members
//

//
// NOTE:  Our preferred drop effect is ALWAYS DROPEFFECT_COPY.
//        The font folder doesn't support the "cut" operation; never has.
//        [brianau - 10/28/98]
//
CLIPFORMAT CFontData::s_CFPerformedDropEffect = 0; // Performed Drop Effect CF atom.
CLIPFORMAT CFontData::s_CFPreferredDropEffect = 0;
CLIPFORMAT CFontData::s_CFLogicalPerformedDropEffect = 0;


CFontData::CFontData( )
   :  m_cRef( 0 ),
      m_poList( 0 ),
      m_dwPerformedDropEffect(DROPEFFECT_NONE),
      m_dwPreferredDropEffect(DROPEFFECT_COPY),
      m_dwLogicalPerformedDropEffect(DROPEFFECT_NONE)
{
    //
    // Get the atom for the "performed effect" clipboard format.
    // This CF has already been added by the shell.  We're just getting the atom.
    //
    if (0 == s_CFPerformedDropEffect)
    {
        s_CFPerformedDropEffect = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PERFORMEDDROPEFFECT);
        s_CFPreferredDropEffect = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        s_CFLogicalPerformedDropEffect = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_LOGICALPERFORMEDDROPEFFECT);
    }
}


CFontData::~CFontData( )
{
    if( m_poList )
    {
        m_poList->vDetachAll( );
        delete m_poList;
    }
}


CFontList * CFontData::poDetachList( )
{
    CFontList * poList = m_poList;

    m_poList = 0;
    return poList;
}


CFontList *CFontData::poCloneList(void)
{
    return m_poList ? m_poList->Clone() : NULL;
}
    


BOOL CFontData::bInit( CFontList * poList )
{
    m_poList = poList;

    return TRUE;
}


//
// *** IUnknown methods ***
//

HRESULT CFontData::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    *ppvObj = NULL;

    if( riid == IID_IUnknown )
        *ppvObj = (IUnknown*)( IDataObject* ) this;

    if( riid == IID_IDataObject )
        *ppvObj = (IDataObject* ) this;


    if( *ppvObj )
    {
        ((LPUNKNOWN)*ppvObj)->AddRef( );
        return NOERROR;
    }

    return( ResultFromScode( E_NOINTERFACE ) );
}


ULONG  CFontData::AddRef( void )
{
    return( ++m_cRef );
}

ULONG CFontData::Release( void )
{
    ULONG retval;

    retval = --m_cRef;

    if( !retval )
    {
        delete this;
    }

    return( retval );
}


//
// **** IDataObject ****
//

HRESULT CFontData::GetData( FORMATETC *pfe, STGMEDIUM *ps )
{
    if( !( DVASPECT_CONTENT & pfe->dwAspect ) )
        return ResultFromScode( DATA_E_FORMATETC );

    if( ( pfe->cfFormat == CF_HDROP ) && ( pfe->tymed & TYMED_HGLOBAL ) )
    {
        ps->hGlobal = hDropFromList( m_poList );

        if( ps->hGlobal )
        {
            ps->tymed          = TYMED_HGLOBAL;
            ps->pUnkForRelease = NULL;

            return NOERROR;
        }
    }
    else if ((pfe->cfFormat == s_CFPerformedDropEffect) && (pfe->tymed & TYMED_HGLOBAL))
    {
        //
        // The shell called SetData during a previous drag/drop and we stored
        // the performed drop effect in m_dwPerformedDropEffect.  Now, someone
        // is asking for that effect value.
        // Internally, the font folder just calls GetPerformedDropEffect().
        // This GetData code was added so that we complement SetData.
        //
        ps->hGlobal = (HGLOBAL)LocalAlloc(LPTR, sizeof(DWORD));

        if (NULL != ps->hGlobal)
        {
            *((LPDWORD)ps->hGlobal) = m_dwPerformedDropEffect;
            ps->tymed               = TYMED_HGLOBAL;
            ps->pUnkForRelease      = NULL;
            return NOERROR;
        }
        else
            return ResultFromScode(E_UNEXPECTED);
    }
    else if ((pfe->cfFormat == s_CFLogicalPerformedDropEffect) && (pfe->tymed & TYMED_HGLOBAL))
    {
        ps->hGlobal = (HGLOBAL)LocalAlloc(LPTR, sizeof(DWORD));

        if (NULL != ps->hGlobal)
        {
            *((LPDWORD)ps->hGlobal) = m_dwLogicalPerformedDropEffect;
            ps->tymed               = TYMED_HGLOBAL;
            ps->pUnkForRelease      = NULL;
            return NOERROR;
        }
        else
            return ResultFromScode(E_UNEXPECTED);
    }
    else if ((pfe->cfFormat == s_CFPreferredDropEffect) && (pfe->tymed & TYMED_HGLOBAL))
    {
        ps->hGlobal = (HGLOBAL)LocalAlloc(LPTR, sizeof(DWORD));

        if (NULL != ps->hGlobal)
        {
            *((LPDWORD)ps->hGlobal) = m_dwPreferredDropEffect;
            ps->tymed               = TYMED_HGLOBAL;
            ps->pUnkForRelease      = NULL;

            return NOERROR;
        }
        else
            return ResultFromScode(E_UNEXPECTED);
    }
    return ResultFromScode( DATA_E_FORMATETC );
}



HRESULT CFontData::GetDataHere( FORMATETC *pformatetc, STGMEDIUM *pmedium )
{
    return ResultFromScode( E_NOTIMPL );
}


HRESULT CFontData::QueryGetData( FORMATETC *pfe )
{
    HRESULT  hRet = ResultFromScode( S_FALSE );

    //
    //  Check the aspects we support.
    //

    if( !( DVASPECT_CONTENT & pfe->dwAspect ) )
        return ResultFromScode( DATA_E_FORMATETC );

    if (TYMED_HGLOBAL != pfe->tymed)
        return ResultFromScode( DV_E_TYMED );

    if( pfe->cfFormat == CF_HDROP ||
        pfe->cfFormat == s_CFPreferredDropEffect ||
        pfe->cfFormat == s_CFPerformedDropEffect ||
        pfe->cfFormat == s_CFLogicalPerformedDropEffect)
    {
        hRet = NOERROR ;
    }

    return hRet;
}


HRESULT CFontData::GetCanonicalFormatEtc( FORMATETC *pfeIn, FORMATETC *pfeOut )
{
    *pfeOut = *pfeIn;

    pfeOut->ptd = NULL;

    return ResultFromScode( DATA_S_SAMEFORMATETC );
}


HRESULT CFontData::SetData( FORMATETC *pformatetc,
                            STGMEDIUM *pmedium,
                            BOOL fRelease )
{
    HRESULT hr = DATA_E_FORMATETC;

    if ((pformatetc->cfFormat == s_CFPerformedDropEffect) &&
        (pformatetc->tymed & TYMED_HGLOBAL))
    {
        //
        // The shell has called to tell us what the performed
        // drop effect was from the drag/drop operation.  We save
        // the drop effect so we can provide it when someone asks
        // for it through GetData or GetPerformedDropEffect.
        //
        LPDWORD pdw = (LPDWORD)GlobalLock(pmedium->hGlobal);

        if (NULL != pdw)
        {
            m_dwPerformedDropEffect = *pdw;
            GlobalUnlock(pmedium->hGlobal);
            hr = NOERROR;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        if (fRelease)
            ReleaseStgMedium(pmedium);
    }
    else if ((pformatetc->cfFormat == s_CFLogicalPerformedDropEffect) &&
             (pformatetc->tymed & TYMED_HGLOBAL))
    {
        //
        // The shell has called to tell us what the logical performed
        // drop effect was from the drag/drop operation.  We save
        // the drop effect so we can provide it when someone asks
        // for it through GetData or GetPerformedDropEffect.
        //
        LPDWORD pdw = (LPDWORD)GlobalLock(pmedium->hGlobal);

        if (NULL != pdw)
        {
            m_dwLogicalPerformedDropEffect = *pdw;
            GlobalUnlock(pmedium->hGlobal);
            hr = NOERROR;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        if (fRelease)
            ReleaseStgMedium(pmedium);
    }
    return hr;
}


HRESULT CFontData::ReleaseStgMedium(LPSTGMEDIUM pmedium)
{
    if (pmedium->pUnkForRelease)
    {
        pmedium->pUnkForRelease->Release();
    }
    else
    {
        switch(pmedium->tymed)
        {
        case TYMED_HGLOBAL:
            GlobalFree(pmedium->hGlobal);
            break;

        case TYMED_ISTORAGE: // depends on pstm/pstg overlap in union
        case TYMED_ISTREAM:
            pmedium->pstm->Release();
            break;

        default:
            ASSERT(0);  // unknown type
        }
    }

    return S_OK;
}


HRESULT CFontData::EnumFormatEtc( DWORD dwDirection, IEnumFORMATETC **ppEnum )
{
    FORMATETC feGet[] = {{ CF_HDROP,                NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
                         { s_CFPreferredDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
                         { s_CFPerformedDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
                         { s_CFLogicalPerformedDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
                        };

    FORMATETC feSet[] = {{ s_CFPerformedDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
                         { s_CFLogicalPerformedDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
                        };

    FORMATETC *pfe = NULL;
    INT cfe = 0;

    *ppEnum = NULL;

    switch(dwDirection)
    {
        case DATADIR_GET:
            pfe = feGet;
            cfe = ARRAYSIZE(feGet);
            break;

        case DATADIR_SET:
            pfe = feSet;
            cfe = ARRAYSIZE(feSet);
            break;

        default:
            break;
    }

    if (0 < cfe)
    {
        *ppEnum = new CEnumFormatEtc(this, cfe, pfe);
    }

    if( *ppEnum )
    {
        (*ppEnum)->AddRef( );

        return NOERROR;
    }
    else
        return ResultFromScode( E_FAIL );
}


HRESULT CFontData::DAdvise( FORMATETC  *pformatetc,
                            DWORD advf,
                            IAdviseSink *pAdvSink,
                            DWORD *pdwConnection )
{
    return ResultFromScode( E_NOTIMPL );
}


HRESULT CFontData::DUnadvise( DWORD dwConnection )
{
    return ResultFromScode( E_NOTIMPL );
}


HRESULT CFontData::EnumDAdvise( IEnumSTATDATA **ppenumAdvise )
{
    return ResultFromScode( E_NOTIMPL );
}


BOOL CFontData::bRFR( )
{
    if( m_poList )
    {
        int iCount = m_poList->iCount( );

        for( int i = 0; i < iCount; i++ )
            m_poList->poObjectAt( i )->bRFR( );

        return TRUE;
    }

    return FALSE;
}


BOOL CFontData::bAFR( )
{
    if( m_poList )
    {
        int iCount = m_poList->iCount( );

        for( int i = 0; i < iCount; i++ )
            m_poList->poObjectAt( i )->bAFR( );

        return TRUE;
    }

    return FALSE;
}


// ***********************************************************************
// ***********************************************************************
// CFontView members
//


CFontView::CFontView(void)
{
    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView object constructed" ) ) );

    m_cRef          = 0;
    m_poFontManager = NULL;
    m_bFamilyOnly   = FALSE;
    m_poPanose      = NULL;

    m_hwndView   = NULL;
    m_hwndList   = NULL;
    m_hwndText   = NULL;
    m_hwndCombo  = NULL;
    m_hwndParent = NULL;

    m_hwndNextClip = NULL;

    m_hImageList      = NULL;
    m_hImageListSmall = NULL;

    m_hmenuCur       = NULL;
    m_psb            = NULL;
    m_uState         = SVUIA_DEACTIVATE;
    m_idViewMode     = IDM_VIEW_ICON;
    m_iViewClickMode = CLICKMODE_DOUBLE;
    m_ViewModeReturn = FVM_ICON;
    m_fFolderFlags   = FWF_AUTOARRANGE;
    m_bDragSource    = FALSE;
    m_iSortColumn    = FFCOL_DEFAULT;
    m_iSortLast      = FFCOL_DEFAULT;
    m_bSortAscending = TRUE;
    m_bUIActivated   = FALSE;
    m_pdtobjHdrop    = NULL;
    m_bResizing      = FALSE;

    m_dwDateFormat   = 0;

    m_uSHChangeNotifyID = 0;

    m_hwndToolTip          = NULL;
    m_bShowPreviewToolTip  = FALSE;
    m_iTTLastHit           = -1;
    m_hfontSample          = NULL;

    //
    // Load up the sample text for non-symbol fonts.
    //
    TCHAR szSample[MAX_PATH];
    LoadString(g_hInst, IDS_FONTSAMPLE_TEXT, szSample, ARRAYSIZE(szSample));

    size_t cchSample = lstrlen(szSample) + 1;
    m_pszSampleText = new TCHAR[cchSample];
    if (NULL != m_pszSampleText)
        StringCchCopy(m_pszSampleText, cchSample, szSample);

    //
    // Load up the sample text for symbol fonts.
    //
    LoadString(g_hInst, IDS_FONTSAMPLE_SYMBOLS, szSample, ARRAYSIZE(szSample));
    cchSample = lstrlen(szSample) + 1;
    m_pszSampleSymbols = new TCHAR[cchSample];
    if (NULL != m_pszSampleSymbols)
        StringCchCopy(m_pszSampleSymbols, cchSample, szSample);

    m_bShowCompColor = FALSE;
    m_bShowHiddenFonts = FALSE;
    m_hmodHHCtrlOcx = NULL;
    g_cRefThisDll++;
}


CFontView::~CFontView( )
{
   //
   //  These are destroyed by the ListView
   //  if( m_hImageList) ImageList_Destroy( m_hImageList );
   //  if( m_hImageListSmall ) ImageList_Destroy( m_hImageListSmall );
   //

    if (NULL != m_hfontSample)
    {
        DeleteObject(m_hfontSample);
        m_hfontSample = NULL;
    }
    delete[] m_pszSampleText;
    delete[] m_pszSampleSymbols;

    if (NULL != m_hmodHHCtrlOcx)
        FreeLibrary(m_hmodHHCtrlOcx);
        
    if (NULL != m_poFontManager)
        ReleaseFontManager(&m_poFontManager);

    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView object blasted out of creation" ) ) );
    g_cRefThisDll--;
}


//
// Build a text string containing characters that represent attributes of a file.
// The attribute characters are assigned as follows:
// (R)eadonly, (H)idden, (S)ystem, (A)rchive, (C)ompressed.
//
LPTSTR CFontView::BuildAttributeString(DWORD dwAttributes, LPTSTR pszString, UINT nChars)
{
    if (NULL != pszString)
    {
        int j = 0;

        if (nChars > NUM_ATTRIB_CHARS)
        {
            int i = 0;

            for (i = 0, j = 0; i < NUM_ATTRIB_CHARS; i++)
                if (dwAttributes & g_adwAttributeBits[i])
                    *(pszString + (j++)) = g_szAttributeChars[i];

        }
        *(pszString + j) = TEXT('\0');
    }

    return pszString;
}


//
// Compare two font objects based upon the character-string representation of their
// file's attributes.
// Returns: -1 = *pFontA is "less than" *pFontB.
//           0 = *pFontA is "equal to" *pFontB.
//           1 = *pFontA is "greater than" *pFontB.
//
int CFontView::CompareByFileAttributes(CFontClass *pFontA, CFontClass *pFontB)
{
    int iResult = 0; // Assume equal

    DWORD mask = FILE_ATTRIBUTE_READONLY  |
                 FILE_ATTRIBUTE_HIDDEN    |
                 FILE_ATTRIBUTE_SYSTEM    |
                 FILE_ATTRIBUTE_ARCHIVE   |
                 FILE_ATTRIBUTE_COMPRESSED;

    if (NULL != pFontA && NULL != pFontB)
    {
        //
        // Calculate value of desired bits in attribute DWORD.
        //
        DWORD dwAttribA = pFontA->dwGetFileAttributes() & mask;
        DWORD dwAttribB = pFontB->dwGetFileAttributes() & mask;

        if (dwAttribA != dwAttribB)
        {
            //
            // If the values are not equal,
            // sort alphabetically based on string representation.
            //
            int diff = 0;
            TCHAR szAttribA[NUM_ATTRIB_CHARS + 1];
            TCHAR szAttribB[NUM_ATTRIB_CHARS + 1];

            //
            // Create attribute string for objects A and B.
            //
            BuildAttributeString(dwAttribA, szAttribA, ARRAYSIZE(szAttribA));
            BuildAttributeString(dwAttribB, szAttribB, ARRAYSIZE(szAttribB));

            //
            // Compare attribute strings and determine difference.
            //
            diff = lstrcmp(szAttribA, szAttribB);

            if (diff > 0)
               iResult = 1;
            if (diff < 0)
               iResult = -1;
        }
    }
    return iResult;
}


int CALLBACK iCompare( LPARAM p1, LPARAM p2, LPARAM p3 )
{
    return( ( (CFontView *)p3)->Compare( (CFontClass *)p1, (CFontClass *)p2) );
}

int CFontView::Compare( CFontClass * pFont1, CFontClass * pFont2 )
{
    //
    //  Sorting by name:
    //     If variations are hidden, then sort by family name.
    //     If not, sort by name. The view doesn't matter.
    //
    //  Sorting by Panose:
    //     If the current selected font doesn't have Panose information,
    //     just sort by name. If neither the compare items has PANOSE
    //     info, just sort by name. If only one has PANOSE, return it.
    //     If both have PANOSE, invoke the mapper to get a comparison.
    //

    int iRet = 0;
    bool bNoNegateResult = false;
    UINT viewMode = m_idViewMode;
    TCHAR szFont1[ MAX_NAME_LEN ];
    TCHAR szFont2[ MAX_NAME_LEN ];

    if( viewMode == IDM_VIEW_PANOSE )
    {
        if( (m_iSortColumn == FFCOL_DEFAULT ||
             m_iSortColumn == FFCOL_PANOSE ) )
        {
            BOOL bPan1 = pFont1->bHavePANOSE( );
            BOOL bPan2 = pFont2->bHavePANOSE( );

            //
            //  If neither has a PAN number, just sort by name.
            //

            if( !( bPan1 || bPan2 ) )
            {
                goto CompareNames;
            }
            else
            {
                if( !m_poPanose )
                {
                    if( bPan1 )
                        iRet = -1;
                    else
                        iRet = 1;

                    goto ReturnCompareResult;
                }

                else if(  !(bPan1 && bPan2 ) )
                {
                    //
                    //  We have m_poPanose, but do we have the others?
                    //
                    if( bPan1 )
                        iRet = -1;
                    if( bPan2 )
                        iRet = 1;
                    //
                    // This flag keeps the "No Panose Information" items
                    // always at the bottom of the view.
                    //
                    bNoNegateResult = true;
                    goto ReturnCompareResult;
                }
            }
        }
        else
        {
            goto CompareNames;
        }
    }

    switch( viewMode )
    {
    default:
        switch( m_iSortColumn )
        {
        case FFCOL_DEFAULT:
        case FFCOL_NAME:
CompareNames:
            if( m_bFamilyOnly )
            {
                pFont1->vGetFamName( szFont1, ARRAYSIZE(szFont1) );
                pFont2->vGetFamName( szFont2, ARRAYSIZE(szFont2) );
            }
            else
            {
                pFont1->vGetName( szFont1, ARRAYSIZE(szFont1) );
                pFont2->vGetName( szFont2, ARRAYSIZE(szFont2) );
            }
            iRet = lstrcmpi( szFont1, szFont2 );
            //
            // Use font type for secondary ordering.
            //
            if (0 == iRet)
            {
                iRet = pFont1->iFontType() - pFont2->iFontType();
                //
                // Force non-zero results to -1 or 1.
                //
                if (0 != iRet)
                    iRet = ((iRet < 0) ? -1 : 1);
            }
            break;

        case FFCOL_FILENAME:
            pFont1->vGetFileName( szFont1, ARRAYSIZE(szFont1) );
            pFont2->vGetFileName( szFont2, ARRAYSIZE(szFont2) );
            iRet = lstrcmpi( szFont1, szFont2 );
            break;

        case FFCOL_SIZE:
            iRet = pFont1->dCalcFileSize( ) - pFont2->dCalcFileSize( );
            if( iRet == 0 )
                goto CompareNames;
            break;

        case FFCOL_MODIFIED:
        {
            FILETIME ft1;
            FILETIME ft2;
            BOOL b1, b2;

            b1 = pFont1->GetFileTime( &ft1 );
            b2 = pFont2->GetFileTime( &ft2 );

            if( b1 && b2 )
            {
                if( ft1.dwHighDateTime == ft2.dwHighDateTime )
                {
                    if( ft1.dwLowDateTime > ft2.dwLowDateTime )
                        iRet = -1;
                    else if( ft1.dwLowDateTime < ft2.dwLowDateTime )
                        iRet = 1;
                    else
                        goto CompareNames;
                }
                else if( ft1.dwHighDateTime > ft2.dwHighDateTime )
                {
                    iRet = -1;
                }
                else
                    iRet = 1;
            }
            else if( !b1 && !b2 )
            {
                goto CompareNames;
            }
            else if( b1 )
            {
                iRet = -1;
            }
            else
                iRet = 1;

            break;
        }

        case FFCOL_ATTRIBUTES:
            iRet = CompareByFileAttributes(pFont1, pFont2);
            if (0 == iRet)
                goto CompareNames;
            break;

        }
        break;

    case IDM_VIEW_PANOSE:
        //
        // At this point, we are guaranteed that all three fonts
        // have PANOSE information.
        // The primary key for sorting is the "range" that the
        // difference between each font's panose number and the
        // panose number of the font currently selected in the dropdown
        // combo box falls within.  It's this range that determines the
        // text displayed next to the font in the listview
        // entry (see CFontView::OnNotify).  If two fonts fall into
        // the same range, we use the font face name as the secondary
        // sort key.  This was not done in Win9x or NT4 but I think
        // it's a helpful feature.  Otherwise, the items within a given
        // range are not sorted. [brianau - 3/24/98]
        //
        {
            //
            // Get the difference in panose number between each of the
            // comparison fonts and the font selected in the dropdown combo
            // (m_poPanose).
            //
            int nDiff1 = m_poFontManager->nDiff(m_poPanose, pFont1);
            int nDiff2 = m_poFontManager->nDiff(m_poPanose, pFont2);
            bool bCompareByName = false;

            //
            // Use a filter approach to determine if the two fonts are in
            // the same range (i.e. "similar to", "very similar to" etc.)
            // If they are, we'll sort on font face name to ensure ordering
            // within the ranges.
            //
            if (nDiff1 < 100)
            {
                if (nDiff2 < 100)
                {
                    //
                    // Both diffs < 100.
                    //
                    if (nDiff1 < 30)
                    {
                        if (nDiff2 < 30)
                        {
                            //
                            // Both diffs < 30.
                            //
                            bCompareByName = true;
                        }
                    }
                    else if (nDiff2 >= 30)
                    {
                        //
                        // Both diffs are between 30 and 99 inclusive.
                        //
                        bCompareByName = true;
                    }
                }
            }
            else if (nDiff2 >= 100)
