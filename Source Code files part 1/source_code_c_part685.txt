workbyteorder = htons(localtime.wYear);

    //
    // Format "dateandtime" according to RFC1514
    //
    octet_time[0] = (year_networkbyteorder & 0xFF);
    octet_time[1] = (year_networkbyteorder >> 8);
    octet_time[2] = (char) localtime.wMonth;
    octet_time[3] = (char) localtime.wDay;
    octet_time[4] = (char) localtime.wHour;
    octet_time[5] = (char) localtime.wMinute;
    octet_time[6] = (char) localtime.wSecond;
    octet_time[7] = localtime.wMilliseconds / 100;

    outvalue->length = 8;
    outvalue->string = octet_time;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemDate() */


/*
 *  GetHrSystemInitialLoadDevice
 *    The index of the hrDeviceEntry for the device from which this host is 
 *    configured to load its initial operating system configurat
 *    
 *    Gets the value for HrSystemInitialLoadDevice.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemInitialLoadDevice
 | 
 |  ACCESS         SYNTAX
 |  read-write     INTEGER (1..2147483647)
 | 
 | "The index of the hrDeviceEntry for the device from which this host is
 | configured to load its initial operating system configuration."
 | 
 | DISCUSSION:
 | 
 | <POA-2> It seems that RFC1514 is attempting to allow the setting and resetting
 | of the default operating system to be booted thru the combination of this
 | attribute and "hrSystemInitialLoadParameters" (below).
 | 
 | While generic PC hardware typically boots from a hard disk partition that is
 | going to wind up being labelled as drive "C:", these two variables speak to a
 | more general situation in which a hardware bootstrap loader can be set to
 | point to almost any system image on a "permanent file system" (to use the unix
 | phrase).  It is apparent that we must attempt to approximate this in some way.
 | 
 | I note that a system file named "Boot.ini" resides on the bootable partition
 | of an Intel NT system.  The one on my system looks like:
 | 
 | >>>>>>>>
 | [boot loader]
 | timeout=30
 | default=multi(0)disk(0)rdisk(0)partition(1)\WINNT35
 | [operating systems]
 | multi(0)disk(0)rdisk(0)partition(1)\WINNT35="Windows NT Server Version 3.51"
 | multi(0)disk(0)rdisk(0)partition(1)\WINNT35="Windows NT Server Version 3.51 [VGA mode]" /basevideo /sos
 | <<<<<<<<
 | 
 | The contents of this file seems to be the source of the menu that appears
 | during the NT boot process.  Programming a selection from this menu is a close
 | approximation to the flexibility hinted at thru the combination of these
 | two SNMP attributes, "hrSystemInitialLoadDevice" and
 | "hrSystemInitialLoadParameters".
 | 
 | For the purposes of "GET", given the "default" shown in the "Boot.ini" file
 | above, it would seem that the string "multi(0)disk(0)rdisk(0)partition(1)"
 | constitutes a passing resemblance to "hrSystemInitialLoadDevice" while the
 | string "\WINNT35" seems to be a good candidate for the value of
 | "hrSystemInitialLoadParameters" (where both of these are drawn from the value
 | specified for "default" under "[boot loader]").
 | 
 | For the purposes of "SET", we would be required to modify this file according
 | to the values received.  I note that the file on my system is write-protected
 | and clearly this poses a problem if we allow the SNMP agent to attempt to
 | modify it.  Additionally, there is the problem of error-checking any value
 | provided from an SNMP SET request (I do not know the exact semantic
 | significance of "multi(0)disk(0)rdisk(0)partition(1)" and I do not know how
 | to error-check a received value).
 | 
 | RESOLVED >>>>>>>
 | <POA-2> Call GetWindowsDirectory and work backwards from that (get the 
 | device name, e.g. D, then do a QueryDosDevice to get the underlying 
 | partition information).  Much more accurate than trying to parse boot.ini, 
 | and portable to Alpha.  Leave read-only.
 | RESOLVED >>>>>>>
 |============================================================================
 | 1.3.6.1.2.1.25.1.3.0
 |                | |
 |                | *-hrSystemInitialLoadDevice
 |                *---hrSystem
 */

UINT
GetHrSystemInitialLoadDevice( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    /*
    | Fetch this magic index from static storage in "HRDEVENT.C".
    */
    *outvalue = InitLoadDev_index;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemInitialLoadDevice() */



/*
 *  SetHrSystemInitialLoadDevice
 *    The index of the hrDeviceEntry for the device from which this host is 
 *    configured to load its initial operating system configurat
 *    
 *    Sets the HrSystemInitialLoadDevice value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 */

UINT
SetHrSystemInitialLoadDevice( 
        IN Integer *invalue ,
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{

    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrSystemInitialLoadDevice() */


/*
 *  GetHrSystemInitialLoadParameters
 *    This object contains the paramets (e.g. a pathname and parameter) 
 *    supplied to the load device when requesting the initial operat
 *    
 *    Gets the value for HrSystemInitialLoadParameters.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemInitialLoadParameters
 | 
 |   ACCESS        SYNTAX
 |   read-write    InternationalDisplayString (SIZE (0..128))
 | 
 | "This object contains the parameters (e.g. a pathname and parameter) supplied
 | to the load device when requesting the initial operating system configuration
 | from that device."
 | 
 | DISCUSSION:
 | 
 | (See discussion for "hrSystemInitialLoadDevice" above).
 | 
 | For initial version, we return a zero length string, and it is not SETable.
 |
 |============================================================================
 | 1.3.6.1.2.1.25.1.4.0
 |                | |
 |                | *-hrSystemInitialLoadParameters
 |                *---hrSystem
 */

UINT
GetHrSystemInitialLoadParameters( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    // (No parameter-string returned  for initial release)
    outvalue->length = 0;
    outvalue->string = NULL;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemInitialLoadParameters() */


/*
 *  SetHrSystemInitialLoadParameters
 *    This object contains the paramets (e.g. a pathname and parameter) 
 *    supplied to the load device when requesting the initial operat
 *    
 *    Sets the HrSystemInitialLoadParameters value.
 *
 *  Arguments:
 *
 *    invalue                    address of value to set the variable
 *    outvalue                   address to return the set variable value
 *    access                     Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_BADVALUE   Set value not in range
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtset.ntc v0.10
 */

UINT
SetHrSystemInitialLoadParameters( 
        IN InternationalDisplayString *invalue ,
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    return SNMP_ERRORSTATUS_NOSUCHNAME ;

} /* end of SetHrSystemInitialLoadParameters() */

/*
 *  GetHrSystemNumUsers
 *    The number of user sessions for which this host is storing state 
 *    information.
 *    
 *    Gets the value for HrSystemNumUsers.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 | =============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemNumUsers
 | 
 |  ACCESS         SYNTAX
 |  read-only      Gauge
 | 
 | "The number of user sessions for which this host is storing state information.
 | A session is a collection of processes requiring a single act of user
 | authentication and possibly subject to collective job control."
 | 
 | DISCUSSION:
 | 
 | <POA-3> This metric does not seem to be directly available thru a standard
 | Win32 API function.  I note that what appears to be logon information seems to
 | be stored in the registry under:
 | 
 |           "HKEY_LOCAL_MACHINE\microsoft\windows nt\winlogon".
 | 
 | + Should I use this as a source for this SNMP attribute?
 | + If this registry entry is the proper place to acquire this information, what
 |   is the full and proper way to parse this entry?  (By this I mean if more
 |   than one user is logged on, how does this single registry entry reflect
 |   multiple users?)
 | + Does it reflect other users logged in via a network connection?
 | 
 | RESOLVED >>>>>>>
 | <POA-3> There is going to be either one interactive user or none.  Use 
 | NetWkstaGetInfo to try to determine the name of the currently logged on 
 | interactive user and if this succeeds then it is the former.
 | RESOLVED >>>>>>>
 |
 |=============================================================================
 | 1.3.6.1.2.1.25.1.5.0
 |                | |
 |                | *-hrSystemNumUsers
 |                *---hrSystem
 */

UINT
GetHrSystemNumUsers( 
        OUT Gauge *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    LPBYTE  info;     /* Where we get logged-on information */


    // Attempt to get the number of logged-on users . . . 
    if (NetWkstaGetInfo(NULL,           /* "Local" computer     */
                        102,            /* Info Level 102       */
                        &info) != NERR_Success) {

        return SNMP_ERRORSTATUS_GENERR ;
        }


    /* Just return it */
    *outvalue = ((LPWKSTA_INFO_102) info)->wki102_logged_on_users;

    /* Free the Net API Buffer */
    NetApiBufferFree(info);

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemNumUsers() */


/*
 *  GetHrSystemProcesses
 *    The number of process contexts currently loaded or running on this system.
 *    
 *    Gets the value for HrSystemProcesses.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 |=============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemProcesses
 | 
 |  ACCESS         SYNTAX
 |  read-only      Gauge
 | 
 | "The number of process contexts currently loaded or running on this system."
 | 
 | DISCUSSION:
 | 
 | The sample-code "Process Viewer" (PVIEWER.EXE) that is part of the Win32 SDK
 | infers a list of active processes from performance information that is stored
 | in the registry.  We use this approach (and borrowed code) to obtaining a
 | count of active processes.
 |
 |-- (The foregoing approach is abandoned for a direct "beyond-the-veil" call
 |--  to NtQuerySystemInfo()).
 |=============================================================================
 | 1.3.6.1.2.1.25.1.6.0
 |                | |
 |                | *-hrSystemNumUsers
 |                *---hrSystem
 */

UINT
GetHrSystemProcesses( 
        OUT Gauge *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    ULONG       process_count;

    // If we failed to get the Process Count successfully . . . 
    if ((process_count = Spt_GetProcessCount()) == 0) {
        return SNMP_ERRORSTATUS_GENERR ;
        }

    // Return the value
    *outvalue = process_count;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemProcesses() */


/*
 *  GetHrSystemMaxProcesses
 *    The maximum number of process contexts this system can support.  If there 
 *    is no fixed maximum, the value should be zero.
 *    
 *    Gets the value for HrSystemMaxProcesses.
 *
 *  Arguments:
 *
 *    outvalue                   address to return variable value
 *    accesss                    Reserved for future security use
 *    instance                   address of instance name as ordered native
 *                               data type(s)
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 *    SNMP_ERRORSTATUS_NOERROR    Successful get
 *    SNMP_ERRORSTATUS_GENERR     Catch-all failure code
 * mibtget.c v0.10
 *
 |=============== From WebEnable Design Spec Rev 3 04/11/97==================
 | hrSystemMaxProcesses
 | 
 |  ACCESS         SYNTAX
 |  read-only      INTEGER (0..2147483647)
 | 
 | "The maximum number of process contexts this system can support.  If there is
 | no fixed maximum, the value should be zero.  On systems that have a fixed
 | maximum, this object can help diagnose failures that occur when this maximum
 | is reached."
 | 
 | DISCUSSION:
 | 
 | My understanding is there is no fixed maximum, as the effective maximum is
 | main-memory dependent.  We return 0 for the value of this attribute.
 | 
 |=============================================================================
 | 1.3.6.1.2.1.25.1.7.0
 |                | |
 |                | *-hrSystemNumUsers
 |                *---hrSystem
 */

UINT
GetHrSystemMaxProcesses( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance )

{
    *outvalue = 0;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of GetHrSystemMaxProcesses() */


/*
 *  HrSystemFindInstance
 *
 *     This routine is used to verify that the specified instance is
 *     valid.
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSystemFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance )
{
    UINT tmp_instance ;

    //
    //  Developer instrumentation code to find appropriate instance goes here.
    //  For non-tables, it is not necessary to modify this routine.  However, 
    //  if there is any context that needs to be set, it can be done here.
    //

    if ( FullOid->idLength <= HRSYSTEM_VAR_INDEX )
	// No instance was specified
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else  if ( FullOid->idLength != HRSYSTEM_VAR_INDEX + 1 )
	// Instance length is more than 1
	return SNMP_ERRORSTATUS_NOSUCHNAME ;
    else
	// The only valid instance for a non-table are instance 0.  If this
	// is a non-table, the following code validates the instances.  If this
	// is a table, developer modification is necessary below.

	tmp_instance = FullOid->ids[ HRSYSTEM_VAR_INDEX ] ;
	if ( tmp_instance )
	    return SNMP_ERRORSTATUS_NOSUCHNAME ;
	else
	{
	    // the instance is valid.  Create the instance portion of the OID
	    // to be returned from this call.
	    instance->ids[ 0 ] = tmp_instance ;
	    instance->idLength = 1 ;
	}

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSystemFindInstance() */



/*
 *  HrSystemFindNextInstance
 *
 *     This routine is called to get the next instance.  If no instance
 *     was passed than return the first instance (1).
 *
 *  Arguments:
 *
 *     FullOid                 Address for the full oid - group, variable,
 *                             and instance information
 *     instance                Address for instance specification as an oid
 *
 *  Return Codes:
 *
 *     SNMP_ERRORSTATUS_NOERROR     Instance found and valid
 *     SNMP_ERRORSTATUS_NOSUCHNAME  Invalid instance
 *
 */

UINT
HrSystemFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance )
{
    //
    //  Developer supplied code to find the next instance of class goes here.
    //  If this is a class with cardinality 1, no modification of this routine
    //  is necessary unless additional context needs to be set.
    //  If the FullOid does not specify an instance, then the only instance
    //  of the class is returned.  If this is a table, the first row of the
    //  table is returned.
    //
    //  If an instance is specified and this is a non-table class, then NOSUCHNAME
    //  is returned so that correct MIB rollover processing occurs.  If this is
    //  a table, then the next instance is the one following the current instance.
    //  If there are no more instances in the table, return NOSUCHNAME.
    //

    if ( FullOid->idLength <= HRSYSTEM_VAR_INDEX )
    {
	instance->ids[ 0 ] = 0 ;
	instance->idLength = 1 ;
    }
    else
	return SNMP_ERRORSTATUS_NOSUCHNAME ;

    return SNMP_ERRORSTATUS_NOERROR ;

} /* end of HrSystemFindNextInstance() */



/*
 *  HrSystemConvertInstance
 *
 *     This routine is used to convert the object id specification of an
 *     instance into an ordered native representation.  The object id format
 *     is that object identifier that is returned from the Find Instance
 *     or Find Next Instance routines.  It is NOT the full object identifier
 *     that contains the group and variable object ids as well.  The native
 *     representation is an argc/argv-like structure that contains the
 *     ordered variables that define the instance.  This is specified by
 *     the MIB's INDEX clause.  See RFC 1212 for information about the INDEX
 *     clause.
 *
 *
 *  Arguments:
 *
 *     oid_spec                Address of the object id instance specification
 *     native_spec             Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *     SUCCESS                 Conversion complete successfully
 *     FAILURE                 Unable to convert object id into native format
 *
 */

UINT
HrSystemConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec )
{
    //
    //  Developer supplied code to convert instance identifer to native
    //  specification of instance names goes here.
    //

    return SUCCESS ;

} /* end of HrSystemConvertInstance() */




/*
 *  HrSystemFreeInstance
 *
 *     This routine is used to free an ordered native representation of an
 *     instance name.
 *
 *  Arguments:
 *
 *     instance                Address to return the ordered native instance
 *                             specification
 *
 *  Return Codes:
 *
 *
 */

void
HrSystemFreeInstance( IN OUT InstanceName *instance )
{

    //
    //  Developer supplied code to free native representation of instance name goes here.
    //

} /* end of HrSystemFreeInstance() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\mib_xtrn.h ===
/*
 *  mib_xtrn.h v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1994 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the external declarations for the MIB.
 *
 *  Author:
 *
 *	David Burns @ Webenable Inc
 *
 *  Date:
 *
 *	Thu Nov 07 16:38:28 1996
 *
 *  Revision History:
 *
 */

#ifndef mib_xtrn_h
#define mib_xtrn_h

// Necessary includes.

#include <snmp.h>
#include "gennt.h"
#include "hostmsmi.h"

//
// External declarations for the table
//
//extern table declarations

extern class_t class_info[] ;
extern trap_t trap_info[] ;
extern UINT number_of_traps ;
extern char *EventLogString ;

#endif /* mib_xtrn_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\mib.h ===
/*
 *  mib.h v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the definitions for the MIB generated by Agent
 *    Factory.  This module includes the definitions for attribute and class
 *    codes, object identifiers, and the tables for each group or table in the
 *    MIB.
 *
 *  Author:
 *
 *	David Burns @ Webenable Inc
 *
 *  Date:
 *
 *	Thu Nov 07 16:38:26 1996
 *
 *  Revision History:
 *
 */

#ifndef mib_h
#define mib_h

// Necessary includes.

#include <snmp.h>
#include "gennt.h"
#include "smint.h"
#include "hostmsmi.h"

#define SUBROOT_LENGTH 7
extern AsnObjectIdentifier Subroot_oid ;
#define HOST_CODE 25
#define HOST_SEQ MIB_2_SEQ, 25
#define HOST_LENGTH ( MIB_2_LENGTH + 1  )
#define HRSYSTEM_CODE 1
#define HRSYSTEM_SEQ HOST_SEQ, 1
#define HRSYSTEM_LENGTH ( HOST_LENGTH + 1  )
#define HRSTORAGE_CODE 2
#define HRSTORAGE_SEQ HOST_SEQ, 2
#define HRSTORAGE_LENGTH ( HOST_LENGTH + 1  )
#define HRDEVICE_CODE 3
#define HRDEVICE_SEQ HOST_SEQ, 3
#define HRDEVICE_LENGTH ( HOST_LENGTH + 1  )
#define HRSWRUN_CODE 4
#define HRSWRUN_SEQ HOST_SEQ, 4
#define HRSWRUN_LENGTH ( HOST_LENGTH + 1  )
#define HRSWRUNPERF_CODE 5
#define HRSWRUNPERF_SEQ HOST_SEQ, 5
#define HRSWRUNPERF_LENGTH ( HOST_LENGTH + 1  )
#define HRSWINSTALLED_CODE 6
#define HRSWINSTALLED_SEQ HOST_SEQ, 6
#define HRSWINSTALLED_LENGTH ( HOST_LENGTH + 1  )
#define HRSTORAGETABLE_CODE 3
#define HRSTORAGETABLE_SEQ HRSTORAGE_SEQ, 3
#define HRSTORAGETABLE_LENGTH ( HRSTORAGE_LENGTH + 1  )
#define HRSTORAGEENTRY_CODE 1
#define HRSTORAGEENTRY_SEQ HRSTORAGETABLE_SEQ, 1
#define HRSTORAGEENTRY_LENGTH ( HRSTORAGETABLE_LENGTH + 1  )
#define HRDEVICETABLE_CODE 2
#define HRDEVICETABLE_SEQ HRDEVICE_SEQ, 2
#define HRDEVICETABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRDEVICEENTRY_CODE 1
#define HRDEVICEENTRY_SEQ HRDEVICETABLE_SEQ, 1
#define HRDEVICEENTRY_LENGTH ( HRDEVICETABLE_LENGTH + 1  )
#define HRNETWORKTABLE_CODE 4
#define HRNETWORKTABLE_SEQ HRDEVICE_SEQ, 4
#define HRNETWORKTABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRNETWORKENTRY_CODE 1
#define HRNETWORKENTRY_SEQ HRNETWORKTABLE_SEQ, 1
#define HRNETWORKENTRY_LENGTH ( HRNETWORKTABLE_LENGTH + 1  )
#define HRPROCESSORTABLE_CODE 3
#define HRPROCESSORTABLE_SEQ HRDEVICE_SEQ, 3
#define HRPROCESSORTABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRPROCESSORENTRY_CODE 1
#define HRPROCESSORENTRY_SEQ HRPROCESSORTABLE_SEQ, 1
#define HRPROCESSORENTRY_LENGTH ( HRPROCESSORTABLE_LENGTH + 1  )
#define HRPRINTERTABLE_CODE 5
#define HRPRINTERTABLE_SEQ HRDEVICE_SEQ, 5
#define HRPRINTERTABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRPRINTERENTRY_CODE 1
#define HRPRINTERENTRY_SEQ HRPRINTERTABLE_SEQ, 1
#define HRPRINTERENTRY_LENGTH ( HRPRINTERTABLE_LENGTH + 1  )
#define HRDISKSTORAGETABLE_CODE 6
#define HRDISKSTORAGETABLE_SEQ HRDEVICE_SEQ, 6
#define HRDISKSTORAGETABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRDISKSTORAGEENTRY_CODE 1
#define HRDISKSTORAGEENTRY_SEQ HRDISKSTORAGETABLE_SEQ, 1
#define HRDISKSTORAGEENTRY_LENGTH ( HRDISKSTORAGETABLE_LENGTH + 1  )
#define HRPARTITIONTABLE_CODE 7
#define HRPARTITIONTABLE_SEQ HRDEVICE_SEQ, 7
#define HRPARTITIONTABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRPARTITIONENTRY_CODE 1
#define HRPARTITIONENTRY_SEQ HRPARTITIONTABLE_SEQ, 1
#define HRPARTITIONENTRY_LENGTH ( HRPARTITIONTABLE_LENGTH + 1  )
#define HRFSTABLE_CODE 8
#define HRFSTABLE_SEQ HRDEVICE_SEQ, 8
#define HRFSTABLE_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRFSENTRY_CODE 1
#define HRFSENTRY_SEQ HRFSTABLE_SEQ, 1
#define HRFSENTRY_LENGTH ( HRFSTABLE_LENGTH + 1  )
#define HRSWRUNTABLE_CODE 2
#define HRSWRUNTABLE_SEQ HRSWRUN_SEQ, 2
#define HRSWRUNTABLE_LENGTH ( HRSWRUN_LENGTH + 1  )
#define HRSWRUNENTRY_CODE 1
#define HRSWRUNENTRY_SEQ HRSWRUNTABLE_SEQ, 1
#define HRSWRUNENTRY_LENGTH ( HRSWRUNTABLE_LENGTH + 1  )
#define HRSWRUNPERFTABLE_CODE 1
#define HRSWRUNPERFTABLE_SEQ HRSWRUNPERF_SEQ, 1
#define HRSWRUNPERFTABLE_LENGTH ( HRSWRUNPERF_LENGTH + 1  )
#define HRSWRUNPERFENTRY_CODE 1
#define HRSWRUNPERFENTRY_SEQ HRSWRUNPERFTABLE_SEQ, 1
#define HRSWRUNPERFENTRY_LENGTH ( HRSWRUNPERFTABLE_LENGTH + 1  )
#define HRSWINSTALLEDTABLE_CODE 3
#define HRSWINSTALLEDTABLE_SEQ HRSWINSTALLED_SEQ, 3
#define HRSWINSTALLEDTABLE_LENGTH ( HRSWINSTALLED_LENGTH + 1  )
#define HRSWINSTALLEDENTRY_CODE 1
#define HRSWINSTALLEDENTRY_SEQ HRSWINSTALLEDTABLE_SEQ, 1
#define HRSWINSTALLEDENTRY_LENGTH ( HRSWINSTALLEDTABLE_LENGTH + 1  )
#define HRDEVICETYPES_CODE 1
#define HRDEVICETYPES_SEQ HRDEVICE_SEQ, 1
#define HRDEVICETYPES_LENGTH ( HRDEVICE_LENGTH + 1  )
#define HRSTORAGETYPES_CODE 1
#define HRSTORAGETYPES_SEQ HRSTORAGE_SEQ, 1
#define HRSTORAGETYPES_LENGTH ( HRSTORAGE_LENGTH + 1  )
#define HRFSTYPES_CODE 9
#define HRFSTYPES_SEQ HRDEVICE_SEQ, 9
#define HRFSTYPES_LENGTH ( HRDEVICE_LENGTH + 1  )
extern AsnObjectIdentifier host_oid;
extern AsnObjectIdentifier hrSystemUptime_oid;
extern AsnObjectIdentifier hrSystemDate_oid;
extern AsnObjectIdentifier hrSystemInitialLoadDevice_oid;
extern AsnObjectIdentifier hrSystemInitialLoadParameters_oid;
extern AsnObjectIdentifier hrSystemNumUsers_oid;
extern AsnObjectIdentifier hrSystemProcesses_oid;
extern AsnObjectIdentifier hrSystemMaxProcesses_oid;
#define HRSYSTEMUPTIME_CODE 1
#define HRSYSTEMUPTIME_SEQ HRSYSTEM_SEQ, 1
#define HRSYSTEMUPTIME_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMDATE_CODE 2
#define HRSYSTEMDATE_SEQ HRSYSTEM_SEQ, 2
#define HRSYSTEMDATE_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMINITIALLOADDEVICE_CODE 3
#define HRSYSTEMINITIALLOADDEVICE_SEQ HRSYSTEM_SEQ, 3
#define HRSYSTEMINITIALLOADDEVICE_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMINITIALLOADPARAMETERS_CODE 4
#define HRSYSTEMINITIALLOADPARAMETERS_SEQ HRSYSTEM_SEQ, 4
#define HRSYSTEMINITIALLOADPARAMETERS_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMNUMUSERS_CODE 5
#define HRSYSTEMNUMUSERS_SEQ HRSYSTEM_SEQ, 5
#define HRSYSTEMNUMUSERS_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMPROCESSES_CODE 6
#define HRSYSTEMPROCESSES_SEQ HRSYSTEM_SEQ, 6
#define HRSYSTEMPROCESSES_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEMMAXPROCESSES_CODE 7
#define HRSYSTEMMAXPROCESSES_SEQ HRSYSTEM_SEQ, 7
#define HRSYSTEMMAXPROCESSES_LENGTH ( HRSYSTEM_LENGTH + 1  )
#define HRSYSTEM_VAR_INDEX  ( HRSYSTEM_LENGTH + 1 )
#define MIN_HRSYSTEM_CODE 1
#define MAX_HRSYSTEM_CODE 7
extern AsnObjectIdentifier hrSystem_oid;
extern AsnObjectIdentifier hrMemorySize_oid;
#define HRMEMORYSIZE_CODE 2
#define HRMEMORYSIZE_SEQ HRSTORAGE_SEQ, 2
#define HRMEMORYSIZE_LENGTH ( HRSTORAGE_LENGTH + 1  )
#define HRSTORAGE_VAR_INDEX  ( HRSTORAGE_LENGTH + 1 )
#define MIN_HRSTORAGE_CODE 2
#define MAX_HRSTORAGE_CODE 2
extern AsnObjectIdentifier hrStorage_oid;
extern AsnObjectIdentifier hrStorageOther_oid;
extern AsnObjectIdentifier hrStorageRAM_oid;
extern AsnObjectIdentifier hrStorageVirtualMemory_oid;
extern AsnObjectIdentifier hrStorageFixedDisk_oid;
extern AsnObjectIdentifier hrStorageRemovableDisk_oid;
extern AsnObjectIdentifier hrStorageFloppyDisk_oid;
extern AsnObjectIdentifier hrStorageCompactDisk_oid;
extern AsnObjectIdentifier hrStorageRamDisk_oid;
#define HRSTORAGEOTHER_CODE 1
#define HRSTORAGEOTHER_SEQ HRSTORAGETYPES_SEQ, 1
#define HRSTORAGEOTHER_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGERAM_CODE 2
#define HRSTORAGERAM_SEQ HRSTORAGETYPES_SEQ, 2
#define HRSTORAGERAM_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGEVIRTUALMEMORY_CODE 3
#define HRSTORAGEVIRTUALMEMORY_SEQ HRSTORAGETYPES_SEQ, 3
#define HRSTORAGEVIRTUALMEMORY_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGEFIXEDDISK_CODE 4
#define HRSTORAGEFIXEDDISK_SEQ HRSTORAGETYPES_SEQ, 4
#define HRSTORAGEFIXEDDISK_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGEREMOVABLEDISK_CODE 5
#define HRSTORAGEREMOVABLEDISK_SEQ HRSTORAGETYPES_SEQ, 5
#define HRSTORAGEREMOVABLEDISK_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGEFLOPPYDISK_CODE 6
#define HRSTORAGEFLOPPYDISK_SEQ HRSTORAGETYPES_SEQ, 6
#define HRSTORAGEFLOPPYDISK_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGECOMPACTDISK_CODE 7
#define HRSTORAGECOMPACTDISK_SEQ HRSTORAGETYPES_SEQ, 7
#define HRSTORAGECOMPACTDISK_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
#define HRSTORAGERAMDISK_CODE 8
#define HRSTORAGERAMDISK_SEQ HRSTORAGETYPES_SEQ, 8
#define HRSTORAGERAMDISK_LENGTH ( HRSTORAGETYPES_LENGTH + 1  )
extern AsnObjectIdentifier hrStorageTypes_oid;
extern AsnObjectIdentifier hrStorageIndex_oid;
extern AsnObjectIdentifier hrStorageType_oid;
extern AsnObjectIdentifier hrStorageDesc_oid;
extern AsnObjectIdentifier hrStorageAllocationUnits_oid;
extern AsnObjectIdentifier hrStorageSize_oid;
extern AsnObjectIdentifier hrStorageUsed_oid;
extern AsnObjectIdentifier hrStorageAllocationFailures_oid;
#define HRSTORAGEINDEX_CODE 1
#define HRSTORAGEINDEX_SEQ HRSTORAGEENTRY_SEQ, 1
#define HRSTORAGEINDEX_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGETYPE_CODE 2
#define HRSTORAGETYPE_SEQ HRSTORAGEENTRY_SEQ, 2
#define HRSTORAGETYPE_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGEDESC_CODE 3
#define HRSTORAGEDESC_SEQ HRSTORAGEENTRY_SEQ, 3
#define HRSTORAGEDESC_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGEALLOCATIONUNITS_CODE 4
#define HRSTORAGEALLOCATIONUNITS_SEQ HRSTORAGEENTRY_SEQ, 4
#define HRSTORAGEALLOCATIONUNITS_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGESIZE_CODE 5
#define HRSTORAGESIZE_SEQ HRSTORAGEENTRY_SEQ, 5
#define HRSTORAGESIZE_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGEUSED_CODE 6
#define HRSTORAGEUSED_SEQ HRSTORAGEENTRY_SEQ, 6
#define HRSTORAGEUSED_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGEALLOCATIONFAILURES_CODE 7
#define HRSTORAGEALLOCATIONFAILURES_SEQ HRSTORAGEENTRY_SEQ, 7
#define HRSTORAGEALLOCATIONFAILURES_LENGTH ( HRSTORAGEENTRY_LENGTH + 1  )
#define HRSTORAGEENTRY_VAR_INDEX  ( HRSTORAGEENTRY_LENGTH + 1 )
#define MIN_HRSTORAGEENTRY_CODE 1
#define MAX_HRSTORAGEENTRY_CODE 7
extern AsnObjectIdentifier hrStorageEntry_oid;
#define HRDEVICE_VAR_INDEX  ( HRDEVICE_LENGTH + 1 )
extern AsnObjectIdentifier hrDeviceOther_oid;
extern AsnObjectIdentifier hrDeviceUnknown_oid;
extern AsnObjectIdentifier hrDeviceProcessor_oid;
extern AsnObjectIdentifier hrDeviceNetwork_oid;
extern AsnObjectIdentifier hrDevicePrinter_oid;
extern AsnObjectIdentifier hrDeviceDiskStorage_oid;
extern AsnObjectIdentifier hrDeviceVideo_oid;
extern AsnObjectIdentifier hrDeviceAudio_oid;
extern AsnObjectIdentifier hrDeviceCoprocessor_oid;
extern AsnObjectIdentifier hrDeviceKeyboard_oid;
extern AsnObjectIdentifier hrDeviceModem_oid;
extern AsnObjectIdentifier hrDeviceParallelPort_oid;
extern AsnObjectIdentifier hrDevicePointing_oid;
extern AsnObjectIdentifier hrDeviceSerialPort_oid;
extern AsnObjectIdentifier hrDeviceTape_oid;
extern AsnObjectIdentifier hrDeviceClock_oid;
extern AsnObjectIdentifier hrDeviceVolatileMemory_oid;
extern AsnObjectIdentifier hrDeviceNonVolatileMemory_oid;
#define HRDEVICEOTHER_CODE 1
#define HRDEVICEOTHER_SEQ HRDEVICETYPES_SEQ, 1
#define HRDEVICEOTHER_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEUNKNOWN_CODE 2
#define HRDEVICEUNKNOWN_SEQ HRDEVICETYPES_SEQ, 2
#define HRDEVICEUNKNOWN_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEPROCESSOR_CODE 3
#define HRDEVICEPROCESSOR_SEQ HRDEVICETYPES_SEQ, 3
#define HRDEVICEPROCESSOR_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICENETWORK_CODE 4
#define HRDEVICENETWORK_SEQ HRDEVICETYPES_SEQ, 4
#define HRDEVICENETWORK_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEPRINTER_CODE 5
#define HRDEVICEPRINTER_SEQ HRDEVICETYPES_SEQ, 5
#define HRDEVICEPRINTER_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEDISKSTORAGE_CODE 6
#define HRDEVICEDISKSTORAGE_SEQ HRDEVICETYPES_SEQ, 6
#define HRDEVICEDISKSTORAGE_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEVIDEO_CODE 10
#define HRDEVICEVIDEO_SEQ HRDEVICETYPES_SEQ, 10
#define HRDEVICEVIDEO_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEAUDIO_CODE 11
#define HRDEVICEAUDIO_SEQ HRDEVICETYPES_SEQ, 11
#define HRDEVICEAUDIO_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICECOPROCESSOR_CODE 12
#define HRDEVICECOPROCESSOR_SEQ HRDEVICETYPES_SEQ, 12
#define HRDEVICECOPROCESSOR_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEKEYBOARD_CODE 13
#define HRDEVICEKEYBOARD_SEQ HRDEVICETYPES_SEQ, 13
#define HRDEVICEKEYBOARD_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEMODEM_CODE 14
#define HRDEVICEMODEM_SEQ HRDEVICETYPES_SEQ, 14
#define HRDEVICEMODEM_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEPARALLELPORT_CODE 15
#define HRDEVICEPARALLELPORT_SEQ HRDEVICETYPES_SEQ, 15
#define HRDEVICEPARALLELPORT_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEPOINTING_CODE 16
#define HRDEVICEPOINTING_SEQ HRDEVICETYPES_SEQ, 16
#define HRDEVICEPOINTING_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICESERIALPORT_CODE 17
#define HRDEVICESERIALPORT_SEQ HRDEVICETYPES_SEQ, 17
#define HRDEVICESERIALPORT_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICETAPE_CODE 18
#define HRDEVICETAPE_SEQ HRDEVICETYPES_SEQ, 18
#define HRDEVICETAPE_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICECLOCK_CODE 19
#define HRDEVICECLOCK_SEQ HRDEVICETYPES_SEQ, 19
#define HRDEVICECLOCK_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICEVOLATILEMEMORY_CODE 20
#define HRDEVICEVOLATILEMEMORY_SEQ HRDEVICETYPES_SEQ, 20
#define HRDEVICEVOLATILEMEMORY_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
#define HRDEVICENONVOLATILEMEMORY_CODE 21
#define HRDEVICENONVOLATILEMEMORY_SEQ HRDEVICETYPES_SEQ, 21
#define HRDEVICENONVOLATILEMEMORY_LENGTH ( HRDEVICETYPES_LENGTH + 1  )
extern AsnObjectIdentifier hrDeviceTypes_oid;
extern AsnObjectIdentifier hrDeviceIndex_oid;
extern AsnObjectIdentifier hrDeviceType_oid;
extern AsnObjectIdentifier hrDeviceDesc_oid;
extern AsnObjectIdentifier hrDeviceID_oid;
extern AsnObjectIdentifier hrDeviceStatus_oid;
extern AsnObjectIdentifier hrDeviceErrors_oid;
#define HRDEVICETYPE_CODE 2
#define HRDEVICETYPE_SEQ HRDEVICEENTRY_SEQ, 2
#define HRDEVICETYPE_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICEDESC_CODE 3
#define HRDEVICEDESC_SEQ HRDEVICEENTRY_SEQ, 3
#define HRDEVICEDESC_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICEID_CODE 4
#define HRDEVICEID_SEQ HRDEVICEENTRY_SEQ, 4
#define HRDEVICEID_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICESTATUS_CODE 5
#define HRDEVICESTATUS_SEQ HRDEVICEENTRY_SEQ, 5
#define HRDEVICESTATUS_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICEERRORS_CODE 6
#define HRDEVICEERRORS_SEQ HRDEVICEENTRY_SEQ, 6
#define HRDEVICEERRORS_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICEINDEX_CODE 1
#define HRDEVICEINDEX_SEQ HRDEVICEENTRY_SEQ, 1
#define HRDEVICEINDEX_LENGTH ( HRDEVICEENTRY_LENGTH + 1  )
#define HRDEVICEENTRY_VAR_INDEX  ( HRDEVICEENTRY_LENGTH + 1 )
#define MIN_HRDEVICEENTRY_CODE 1
#define MAX_HRDEVICEENTRY_CODE 6
extern AsnObjectIdentifier hrDeviceEntry_oid;
extern AsnObjectIdentifier hrProcessorFrwID_oid;
extern AsnObjectIdentifier hrProcessorLoad_oid;
#define HRPROCESSORFRWID_CODE 1
#define HRPROCESSORFRWID_SEQ HRPROCESSORENTRY_SEQ, 1
#define HRPROCESSORFRWID_LENGTH ( HRPROCESSORENTRY_LENGTH + 1  )
#define HRPROCESSORLOAD_CODE 2
#define HRPROCESSORLOAD_SEQ HRPROCESSORENTRY_SEQ, 2
#define HRPROCESSORLOAD_LENGTH ( HRPROCESSORENTRY_LENGTH + 1  )
#define HRPROCESSORENTRY_VAR_INDEX  ( HRPROCESSORENTRY_LENGTH + 1 )
#define MIN_HRPROCESSORENTRY_CODE 1
#define MAX_HRPROCESSORENTRY_CODE 2
extern AsnObjectIdentifier hrProcessorEntry_oid;
extern AsnObjectIdentifier hrNetworkIfIndex_oid;
#define HRNETWORKIFINDEX_CODE 1
#define HRNETWORKIFINDEX_SEQ HRNETWORKENTRY_SEQ, 1
#define HRNETWORKIFINDEX_LENGTH ( HRNETWORKENTRY_LENGTH + 1  )
#define HRNETWORKENTRY_VAR_INDEX  ( HRNETWORKENTRY_LENGTH + 1 )
#define MIN_HRNETWORKENTRY_CODE 1
#define MAX_HRNETWORKENTRY_CODE 1
extern AsnObjectIdentifier hrNetworkEntry_oid;
extern AsnObjectIdentifier hrPrinterStatus_oid;
extern AsnObjectIdentifier hrPrinterDetectedErrorState_oid;
#define HRPRINTERSTATUS_CODE 1
#define HRPRINTERSTATUS_SEQ HRPRINTERENTRY_SEQ, 1
#define HRPRINTERSTATUS_LENGTH ( HRPRINTERENTRY_LENGTH + 1  )
#define HRPRINTERDETECTEDERRORSTATE_CODE 2
#define HRPRINTERDETECTEDERRORSTATE_SEQ HRPRINTERENTRY_SEQ, 2
#define HRPRINTERDETECTEDERRORSTATE_LENGTH ( HRPRINTERENTRY_LENGTH + 1  )
#define HRPRINTERENTRY_VAR_INDEX  ( HRPRINTERENTRY_LENGTH + 1 )
#define MIN_HRPRINTERENTRY_CODE 1
#define MAX_HRPRINTERENTRY_CODE 2
extern AsnObjectIdentifier hrPrinterEntry_oid;
extern AsnObjectIdentifier hrDiskStorageAccess_oid;
extern AsnObjectIdentifier hrDiskStorageMedia_oid;
extern AsnObjectIdentifier hrDiskStorageRemoveble_oid;
extern AsnObjectIdentifier hrDiskStorageCapacity_oid;
#define HRDISKSTORAGEACCESS_CODE 1
#define HRDISKSTORAGEACCESS_SEQ HRDISKSTORAGEENTRY_SEQ, 1
#define HRDISKSTORAGEACCESS_LENGTH ( HRDISKSTORAGEENTRY_LENGTH + 1  )
#define HRDISKSTORAGEMEDIA_CODE 2
#define HRDISKSTORAGEMEDIA_SEQ HRDISKSTORAGEENTRY_SEQ, 2
#define HRDISKSTORAGEMEDIA_LENGTH ( HRDISKSTORAGEENTRY_LENGTH + 1  )
#define HRDISKSTORAGEREMOVEBLE_CODE 3
#define HRDISKSTORAGEREMOVEBLE_SEQ HRDISKSTORAGEENTRY_SEQ, 3
#define HRDISKSTORAGEREMOVEBLE_LENGTH ( HRDISKSTORAGEENTRY_LENGTH + 1  )
#define HRDISKSTORAGECAPACITY_CODE 4
#define HRDISKSTORAGECAPACITY_SEQ HRDISKSTORAGEENTRY_SEQ, 4
#define HRDISKSTORAGECAPACITY_LENGTH ( HRDISKSTORAGEENTRY_LENGTH + 1  )
#define HRDISKSTORAGEENTRY_VAR_INDEX  ( HRDISKSTORAGEENTRY_LENGTH + 1 )
#define MIN_HRDISKSTORAGEENTRY_CODE 1
#define MAX_HRDISKSTORAGEENTRY_CODE 4
extern AsnObjectIdentifier hrDiskStorageEntry_oid;
extern AsnObjectIdentifier hrPartitionIndex_oid;
extern AsnObjectIdentifier hrPartitionLabel_oid;
extern AsnObjectIdentifier hrPartitionID_oid;
extern AsnObjectIdentifier hrPartitionSize_oid;
extern AsnObjectIdentifier hrPartitionFSIndex_oid;
#define HRPARTITIONINDEX_CODE 1
#define HRPARTITIONINDEX_SEQ HRPARTITIONENTRY_SEQ, 1
#define HRPARTITIONINDEX_LENGTH ( HRPARTITIONENTRY_LENGTH + 1  )
#define HRPARTITIONLABEL_CODE 2
#define HRPARTITIONLABEL_SEQ HRPARTITIONENTRY_SEQ, 2
#define HRPARTITIONLABEL_LENGTH ( HRPARTITIONENTRY_LENGTH + 1  )
#define HRPARTITIONID_CODE 3
#define HRPARTITIONID_SEQ HRPARTITIONENTRY_SEQ, 3
#define HRPARTITIONID_LENGTH ( HRPARTITIONENTRY_LENGTH + 1  )
#define HRPARTITIONSIZE_CODE 4
#define HRPARTITIONSIZE_SEQ HRPARTITIONENTRY_SEQ, 4
#define HRPARTITIONSIZE_LENGTH ( HRPARTITIONENTRY_LENGTH + 1  )
#define HRPARTITIONFSINDEX_CODE 5
#define HRPARTITIONFSINDEX_SEQ HRPARTITIONENTRY_SEQ, 5
#define HRPARTITIONFSINDEX_LENGTH ( HRPARTITIONENTRY_LENGTH + 1  )
#define HRPARTITIONENTRY_VAR_INDEX  ( HRPARTITIONENTRY_LENGTH + 1 )
#define MIN_HRPARTITIONENTRY_CODE 1
#define MAX_HRPARTITIONENTRY_CODE 5
extern AsnObjectIdentifier hrPartitionEntry_oid;
extern AsnObjectIdentifier hrFSIndex_oid;
extern AsnObjectIdentifier hrFSMountPoint_oid;
extern AsnObjectIdentifier hrFSRemoteMountPoint_oid;
extern AsnObjectIdentifier hrFSType_oid;
extern AsnObjectIdentifier hrFSAccess_oid;
extern AsnObjectIdentifier hrFSBootable_oid;
extern AsnObjectIdentifier hrFSStorageIndex_oid;
extern AsnObjectIdentifier hrFSLastFullBackupDate_oid;
extern AsnObjectIdentifier hrFSLastPartialBackupDate_oid;
#define HRFSINDEX_CODE 1
#define HRFSINDEX_SEQ HRFSENTRY_SEQ, 1
#define HRFSINDEX_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSMOUNTPOINT_CODE 2
#define HRFSMOUNTPOINT_SEQ HRFSENTRY_SEQ, 2
#define HRFSMOUNTPOINT_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSREMOTEMOUNTPOINT_CODE 3
#define HRFSREMOTEMOUNTPOINT_SEQ HRFSENTRY_SEQ, 3
#define HRFSREMOTEMOUNTPOINT_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSTYPE_CODE 4
#define HRFSTYPE_SEQ HRFSENTRY_SEQ, 4
#define HRFSTYPE_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSACCESS_CODE 5
#define HRFSACCESS_SEQ HRFSENTRY_SEQ, 5
#define HRFSACCESS_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSBOOTABLE_CODE 6
#define HRFSBOOTABLE_SEQ HRFSENTRY_SEQ, 6
#define HRFSBOOTABLE_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSSTORAGEINDEX_CODE 7
#define HRFSSTORAGEINDEX_SEQ HRFSENTRY_SEQ, 7
#define HRFSSTORAGEINDEX_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSLASTFULLBACKUPDATE_CODE 8
#define HRFSLASTFULLBACKUPDATE_SEQ HRFSENTRY_SEQ, 8
#define HRFSLASTFULLBACKUPDATE_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSLASTPARTIALBACKUPDATE_CODE 9
#define HRFSLASTPARTIALBACKUPDATE_SEQ HRFSENTRY_SEQ, 9
#define HRFSLASTPARTIALBACKUPDATE_LENGTH ( HRFSENTRY_LENGTH + 1  )
#define HRFSENTRY_VAR_INDEX  ( HRFSENTRY_LENGTH + 1 )
#define MIN_HRFSENTRY_CODE 1
#define MAX_HRFSENTRY_CODE 9
extern AsnObjectIdentifier hrFSEntry_oid;
extern AsnObjectIdentifier hrFSOther_oid;
extern AsnObjectIdentifier hrFSUnknown_oid;
extern AsnObjectIdentifier hrFSBerkeleyFFS_oid;
extern AsnObjectIdentifier hrFSSys5FS_oid;
extern AsnObjectIdentifier hrFSFat_oid;
extern AsnObjectIdentifier hrFSHPFS_oid;
extern AsnObjectIdentifier hrFSHFS_oid;
extern AsnObjectIdentifier hrFSMFS_oid;
extern AsnObjectIdentifier hrFSNTFS_oid;
extern AsnObjectIdentifier hrFSVNode_oid;
extern AsnObjectIdentifier hrFSJournaled_oid;
extern AsnObjectIdentifier hrFSiso9660_oid;
extern AsnObjectIdentifier hrFSRockRidge_oid;
extern AsnObjectIdentifier hrFSNFS_oid;
extern AsnObjectIdentifier hrFSNetware_oid;
extern AsnObjectIdentifier hrFSAFS_oid;
extern AsnObjectIdentifier hrFSDFS_oid;
extern AsnObjectIdentifier hrFSApplshare_oid;
extern AsnObjectIdentifier hrFSRFS_oid;
extern AsnObjectIdentifier hrFSDGFS_oid;
extern AsnObjectIdentifier hrFSBFS_oid;
#define HRFSOTHER_CODE 1
#define HRFSOTHER_SEQ HRFSTYPES_SEQ, 1
#define HRFSOTHER_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSUNKNOWN_CODE 2
#define HRFSUNKNOWN_SEQ HRFSTYPES_SEQ, 2
#define HRFSUNKNOWN_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSBERKELEYFFS_CODE 3
#define HRFSBERKELEYFFS_SEQ HRFSTYPES_SEQ, 3
#define HRFSBERKELEYFFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSSYS5FS_CODE 4
#define HRFSSYS5FS_SEQ HRFSTYPES_SEQ, 4
#define HRFSSYS5FS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSFAT_CODE 5
#define HRFSFAT_SEQ HRFSTYPES_SEQ, 5
#define HRFSFAT_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSHPFS_CODE 6
#define HRFSHPFS_SEQ HRFSTYPES_SEQ, 6
#define HRFSHPFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSHFS_CODE 7
#define HRFSHFS_SEQ HRFSTYPES_SEQ, 7
#define HRFSHFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSMFS_CODE 8
#define HRFSMFS_SEQ HRFSTYPES_SEQ, 8
#define HRFSMFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSNTFS_CODE 9
#define HRFSNTFS_SEQ HRFSTYPES_SEQ, 9
#define HRFSNTFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSVNODE_CODE 10
#define HRFSVNODE_SEQ HRFSTYPES_SEQ, 10
#define HRFSVNODE_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSJOURNALED_CODE 11
#define HRFSJOURNALED_SEQ HRFSTYPES_SEQ, 11
#define HRFSJOURNALED_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSISO9660_CODE 12
#define HRFSISO9660_SEQ HRFSTYPES_SEQ, 12
#define HRFSISO9660_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSROCKRIDGE_CODE 13
#define HRFSROCKRIDGE_SEQ HRFSTYPES_SEQ, 13
#define HRFSROCKRIDGE_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSNFS_CODE 14
#define HRFSNFS_SEQ HRFSTYPES_SEQ, 14
#define HRFSNFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSNETWARE_CODE 15
#define HRFSNETWARE_SEQ HRFSTYPES_SEQ, 15
#define HRFSNETWARE_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSAFS_CODE 16
#define HRFSAFS_SEQ HRFSTYPES_SEQ, 16
#define HRFSAFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSDFS_CODE 17
#define HRFSDFS_SEQ HRFSTYPES_SEQ, 17
#define HRFSDFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSAPPLSHARE_CODE 18
#define HRFSAPPLSHARE_SEQ HRFSTYPES_SEQ, 18
#define HRFSAPPLSHARE_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSRFS_CODE 19
#define HRFSRFS_SEQ HRFSTYPES_SEQ, 19
#define HRFSRFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSDGFS_CODE 20
#define HRFSDGFS_SEQ HRFSTYPES_SEQ, 20
#define HRFSDGFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
#define HRFSBFS_CODE 21
#define HRFSBFS_SEQ HRFSTYPES_SEQ, 21
#define HRFSBFS_LENGTH ( HRFSTYPES_LENGTH + 1  )
extern AsnObjectIdentifier hrFSTypes_oid;
extern AsnObjectIdentifier hrSWOSIndex_oid;
#define HRSWOSINDEX_CODE 1
#define HRSWOSINDEX_SEQ HRSWRUN_SEQ, 1
#define HRSWOSINDEX_LENGTH ( HRSWRUN_LENGTH + 1  )
#define HRSWRUN_VAR_INDEX  ( HRSWRUN_LENGTH + 1 )
#define MIN_HRSWRUN_CODE 1
#define MAX_HRSWRUN_CODE 1
extern AsnObjectIdentifier hrSWRun_oid;
extern AsnObjectIdentifier hrSWRunIndex_oid;
extern AsnObjectIdentifier hrSWRunName_oid;
extern AsnObjectIdentifier hrSWRunID_oid;
extern AsnObjectIdentifier hrSWRunPath_oid;
extern AsnObjectIdentifier hrSWRunParameters_oid;
extern AsnObjectIdentifier hrSWRunType_oid;
extern AsnObjectIdentifier hrSWRunStatus_oid;
#define HRSWRUNINDEX_CODE 1
#define HRSWRUNINDEX_SEQ HRSWRUNENTRY_SEQ, 1
#define HRSWRUNINDEX_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNNAME_CODE 2
#define HRSWRUNNAME_SEQ HRSWRUNENTRY_SEQ, 2
#define HRSWRUNNAME_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNID_CODE 3
#define HRSWRUNID_SEQ HRSWRUNENTRY_SEQ, 3
#define HRSWRUNID_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNPATH_CODE 4
#define HRSWRUNPATH_SEQ HRSWRUNENTRY_SEQ, 4
#define HRSWRUNPATH_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNPARAMETERS_CODE 5
#define HRSWRUNPARAMETERS_SEQ HRSWRUNENTRY_SEQ, 5
#define HRSWRUNPARAMETERS_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNENTRY_VAR_INDEX  ( HRSWRUNENTRY_LENGTH + 1 )
#define HRSWRUNTYPE_CODE 6
#define HRSWRUNTYPE_SEQ HRSWRUNENTRY_SEQ, 6
#define HRSWRUNTYPE_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNSTATUS_CODE 7
#define HRSWRUNSTATUS_SEQ HRSWRUNENTRY_SEQ, 7
#define HRSWRUNSTATUS_LENGTH ( HRSWRUNENTRY_LENGTH + 1  )
#define HRSWRUNENTRY_VAR_INDEX  ( HRSWRUNENTRY_LENGTH + 1 )
#define MIN_HRSWRUNENTRY_CODE 1
#define MAX_HRSWRUNENTRY_CODE 7
extern AsnObjectIdentifier hrSWRunEntry_oid;
#define HRSWRUNPERF_VAR_INDEX  ( HRSWRUNPERF_LENGTH + 1 )
extern AsnObjectIdentifier hrSWRunPerfCPU_oid;
extern AsnObjectIdentifier hrSWRunPerfMem_oid;
#define HRSWRUNPERFCPU_CODE 1
#define HRSWRUNPERFCPU_SEQ HRSWRUNPERFENTRY_SEQ, 1
#define HRSWRUNPERFCPU_LENGTH ( HRSWRUNPERFENTRY_LENGTH + 1  )
#define HRSWRUNPERFMEM_CODE 2
#define HRSWRUNPERFMEM_SEQ HRSWRUNPERFENTRY_SEQ, 2
#define HRSWRUNPERFMEM_LENGTH ( HRSWRUNPERFENTRY_LENGTH + 1  )
#define HRSWRUNPERFENTRY_VAR_INDEX  ( HRSWRUNPERFENTRY_LENGTH + 1 )
#define MIN_HRSWRUNPERFENTRY_CODE 1
#define MAX_HRSWRUNPERFENTRY_CODE 2
extern AsnObjectIdentifier hrSWRunPerfEntry_oid;
extern AsnObjectIdentifier hrSWInstalledLastChange_oid;
extern AsnObjectIdentifier hrSWInstalledLastUpdateTime_oid;
#define HRSWINSTALLEDLASTCHANGE_CODE 1
#define HRSWINSTALLEDLASTCHANGE_SEQ HRSWINSTALLED_SEQ, 1
#define HRSWINSTALLEDLASTCHANGE_LENGTH ( HRSWINSTALLED_LENGTH + 1  )
#define HRSWINSTALLEDLASTUPDATETIME_CODE 2
#define HRSWINSTALLEDLASTUPDATETIME_SEQ HRSWINSTALLED_SEQ, 2
#define HRSWINSTALLEDLASTUPDATETIME_LENGTH ( HRSWINSTALLED_LENGTH + 1  )
#define HRSWINSTALLED_VAR_INDEX  ( HRSWINSTALLED_LENGTH + 1 )
#define MIN_HRSWINSTALLED_CODE 1
#define MAX_HRSWINSTALLED_CODE 2
extern AsnObjectIdentifier hrSWInstalled_oid;
extern AsnObjectIdentifier hrSWInstalledIndex_oid;
extern AsnObjectIdentifier hrSWInstalledName_oid;
extern AsnObjectIdentifier hrSWInstalledID_oid;
extern AsnObjectIdentifier hrSWInstalledType_oid;
extern AsnObjectIdentifier hrSWInstalledDate_oid;
#define HRSWINSTALLEDINDEX_CODE 1
#define HRSWINSTALLEDINDEX_SEQ HRSWINSTALLEDENTRY_SEQ, 1
#define HRSWINSTALLEDINDEX_LENGTH ( HRSWINSTALLEDENTRY_LENGTH + 1  )
#define HRSWINSTALLEDNAME_CODE 2
#define HRSWINSTALLEDNAME_SEQ HRSWINSTALLEDENTRY_SEQ, 2
#define HRSWINSTALLEDNAME_LENGTH ( HRSWINSTALLEDENTRY_LENGTH + 1  )
#define HRSWINSTALLEDID_CODE 3
#define HRSWINSTALLEDID_SEQ HRSWINSTALLEDENTRY_SEQ, 3
#define HRSWINSTALLEDID_LENGTH ( HRSWINSTALLEDENTRY_LENGTH + 1  )
#define HRSWINSTALLEDTYPE_CODE 4
#define HRSWINSTALLEDTYPE_SEQ HRSWINSTALLEDENTRY_SEQ, 4
#define HRSWINSTALLEDTYPE_LENGTH ( HRSWINSTALLEDENTRY_LENGTH + 1  )
#define HRSWINSTALLEDDATE_CODE 5
#define HRSWINSTALLEDDATE_SEQ HRSWINSTALLEDENTRY_SEQ, 5
#define HRSWINSTALLEDDATE_LENGTH ( HRSWINSTALLEDENTRY_LENGTH + 1  )
#define HRSWINSTALLEDENTRY_VAR_INDEX  ( HRSWINSTALLEDENTRY_LENGTH + 1 )
#define MIN_HRSWINSTALLEDENTRY_CODE 1
#define MAX_HRSWINSTALLEDENTRY_CODE 5
extern AsnObjectIdentifier hrSWInstalledEntry_oid;
#define CLASS_TABLE_MAX 15

UINT
GetHrSystemUptime( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemInitialLoadDevice( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrSystemInitialLoadDevice( 
        IN Integer *invalue ,
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemInitialLoadParameters( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrSystemInitialLoadParameters( 
        IN InternationalDisplayString *invalue ,
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemNumUsers( 
        OUT Gauge *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemProcesses( 
        OUT Gauge *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSystemMaxProcesses( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSystemFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSystemFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSystemConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSystemFreeInstance( IN OUT InstanceName *instance );

//  HrSWRunEntry.c 

UINT
GetHrSWRunIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunName( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunPath( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunParameters( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunType( 
        OUT INTSWType *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunStatus( 
        OUT INThrSWRunStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrSWRunStatus( 
        IN INThrSWRunStatus *invalue ,
        OUT INThrSWRunStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSWRunEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSWRunEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSWRunEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSWRunEntryFreeInstance( IN OUT InstanceName *instance );

//  HrSWRun.c 

UINT
GetHrSWOSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSWRunFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSWRunFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSWRunConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSWRunFreeInstance( IN OUT InstanceName *instance );

// HrSWRunPerfEntry.c 

UINT
GetHrSWRunPerfCPU( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWRunPerfMem( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSWRunPerfEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSWRunPerfEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSWRunPerfEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSWRunPerfEntryFreeInstance( IN OUT InstanceName *instance );

//  HrSWInstalled.c 

UINT
GetHrSWInstalledLastChange( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWInstalledLastUpdateTime( 
        OUT TimeTicks *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSWInstalledFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSWInstalledFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSWInstalledConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSWInstalledFreeInstance( IN OUT InstanceName *instance );

// HrStorage.c 

UINT
GetHrMemorySize( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrStorageFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrStorageFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrStorageConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrStorageFreeInstance( IN OUT InstanceName *instance );

// HrStorageEntry.c 

UINT
GetHrStorageIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageType( 
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageDesc( 
        OUT Simple_DisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageAllocationUnits( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageSize( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrStorageSize( 
        IN Integer *invalue ,
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageUsed( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrStorageAllocationFailures( 
        OUT Counter *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrStorageEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrStorageEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrStorageEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrStorageEntryFreeInstance( IN OUT InstanceName *instance );

// HrProcessorEntry.c 

UINT
GetHrProcessorFrwID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrProcessorLoad( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrProcessorEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrProcessorEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrProcessorEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrProcessorEntryFreeInstance( IN OUT InstanceName *instance );

// HrPrinterEntry.c 

UINT
GetHrPrinterStatus( 
        OUT INThrPrinterStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPrinterDetectedErrorState( 
        OUT OctetString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrPrinterEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrPrinterEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrPrinterEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrPrinterEntryFreeInstance( IN OUT InstanceName *instance );

// HrPrinterEntry.c 

UINT
GetHrPrinterStatus( 
        OUT INThrPrinterStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPrinterDetectedErrorState( 
        OUT OctetString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrPrinterEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrPrinterEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrPrinterEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrPrinterEntryFreeInstance( IN OUT InstanceName *instance );

//  HrPartitionEntry.c 

UINT
GetHrPartitionIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPartitionLabel( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPartitionID( 
        OUT OctetString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPartitionSize( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrPartitionFSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrPartitionEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrPartitionEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrPartitionEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrPartitionEntryFreeInstance( IN OUT InstanceName *instance );

//  HrNetworkEntry.c 

UINT
GetHrNetworkIfIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrNetworkEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrNetworkEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrNetworkEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrNetworkEntryFreeInstance( IN OUT InstanceName *instance );

//  HrFSEntry.c 

UINT
GetHrFSIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSMountPoint( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSRemoteMountPoint( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSType( 
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSAccess( 
        OUT INTAccess *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSBootable( 
        OUT Boolean *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSStorageIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSLastFullBackupDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrFSLastFullBackupDate( 
        IN DateAndTime *invalue ,
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrFSLastPartialBackupDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
SetHrFSLastPartialBackupDate( 
        IN DateAndTime *invalue ,
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrFSEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrFSEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrFSEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrFSEntryFreeInstance( IN OUT InstanceName *instance );

// HrDiskStorageEntry.c 

UINT
GetHrDiskStorageAccess( 
        OUT INTAccess *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDiskStorageMedia( 
        OUT INThrDiskStorageMedia *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDiskStorageRemoveble( 
        OUT Boolean *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDiskStorageCapacity( 
        OUT KBytes *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrDiskStorageEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrDiskStorageEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrDiskStorageEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrDiskStorageEntryFreeInstance( IN OUT InstanceName *instance );

// HrDeviceEntry.c 

UINT
GetHrDeviceIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDeviceType( 
        OUT ObjectIdentifier *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDeviceDesc( 
        OUT Simple_DisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDeviceID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDeviceStatus( 
        OUT INThrDeviceStatus *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrDeviceErrors( 
        OUT Counter *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrDeviceEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrDeviceEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrDeviceEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrDeviceEntryFreeInstance( IN OUT InstanceName *instance );

//  hostmsmi.c

UINT
SMIGetBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildBoolean(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildKBytes(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINThrDeviceStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINThrPrinterStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINTAccess(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINThrDiskStorageMedia(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINTSWType(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildINThrSWRunStatus(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for building
      IN char *invalue );
UINT
SMIGetDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildDateAndTime(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue );
UINT
SMIGetInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildInternationalDisplayString(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue );
UINT
SMIGetProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for get
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMISetProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN unsigned long int cindex ,
      IN unsigned long int vindex ,
      IN InstanceName *instance );
UINT
SMIBuildProductID(
      IN OUT RFC1157VarBind *VarBind , // Variable binding for set
      IN char *invalue );

// HrSWInstalledEntry.c 

UINT
GetHrSWInstalledIndex( 
        OUT Integer *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWInstalledName( 
        OUT InternationalDisplayString *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWInstalledID( 
        OUT ProductID *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWInstalledType( 
        OUT INTSWType *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
GetHrSWInstalledDate( 
        OUT DateAndTime *outvalue ,
        IN Access_Credential *access ,
        IN InstanceName *instance );
UINT
HrSWInstalledEntryFindInstance( IN ObjectIdentifier *FullOid ,
                       IN OUT ObjectIdentifier *instance );
UINT
HrSWInstalledEntryFindNextInstance( IN ObjectIdentifier *FullOid ,
                           IN OUT ObjectIdentifier *instance );
UINT
HrSWInstalledEntryConvertInstance( IN ObjectIdentifier *oid_spec ,
                          IN OUT InstanceName *native_spec );
void
HrSWInstalledEntryFreeInstance( IN OUT InstanceName *instance );



/*
|==============================================================================
| hrProcessLoad_Refresh - Processor Load Time-Information Refresh Routine
*/
void
hrProcessLoad_Refresh(
                      void
                      );

/*
|==============================================================================
| Magic "Fetch Instance" Macro
|
| This macro decodes an "InstanceName" structure given the HostMIB's indices
| which are always simple numbers.
*/
#define GET_INSTANCE(n) (*((ULONG *)(instance->array[n])))

#endif // mib_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\mib.c ===
/*
 *  mib.c v0.10
 *  Generated in conjunction with Management Factory scripts:
 *      script version: SNMPv1, 0.16, Apr 25, 1996
 *      project:        D:\TEMP\EXAMPLE\HOSTMIB
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains oids and tables used for the table driven design.
 *
 *  Functions:
 *
 *    UserMibInit()
 *
 *  Author:
 *
 *	D. D. Burns @ Webenable Inc.  Genned: Thu Nov 07 16:38:27 1996
 *
 *
 *  Revision History:
 *
 *      04/15/97        Changed "mibEventValue" to "hostmib.dll" from
 *                              "gendll.dll", and
 *                              "eventLogString" to "HostMIBAgent"
 *                              from "GenAgent".
 */


#include <windows.h>
#include <malloc.h>
#include <stdio.h>

#include <snmp.h>

#include "mib.h"
#include "smint.h"
#include "hostmsmi.h"

#include "HMCACHE.H"    // For Cache-build function prototypes

//
// Text String used in logging to the Application Event log
//

    //
    //  THE EVENT AND DLL STRINGS ARE DECLARED HERE - FILLED IN BY CASE TOOL.
    //  note- nyi, null strings supplied temporarily
    //

char eventLogString[13] = "HostMIBAgent\0" ;
char *EventLogString = eventLogString ;

char mibEventValue[12] = "hostmib.dll\0" ;

//
//  BEGIN generated code:
//	OIDs
//	variable_t table for the attributes of each class
//	class_info containing information about each class
//
//  NOTE:  This stub code will not work if a table exists in the middle of a
//	group. It will work if all tables are at the end of the group.
//
//	Variable tables
//		A NULL entry exists for each "hole" in the sequence of
//		attributes. For example, if attributes 1, 3, 4, and 7 are
//		defined, there will be a NULL entry in the variable table
//		corresponding to attribute 2, 5, and 6.  There is always
//		a NULL entry for 0 in the variable tables, since 0 is an
//		invalid OID arc value for an attribute.
//
//	Class table
//		The class table entries are ordered lexicographically to
//		facilitate SNMP GetNext processing.
//
static
UINT
subroot_array [ SUBROOT_LENGTH ] = {1, 3, 6, 1, 2, 1, 25 } ;
AsnObjectIdentifier
Subroot_oid = { SUBROOT_LENGTH, subroot_array } ;
static
UINT
host_array[ HOST_LENGTH ] = { HOST_SEQ } ;
AsnObjectIdentifier
host_oid = { HOST_LENGTH, host_array } ;
static
UINT
hrSystemUptime_array[ HRSYSTEMUPTIME_LENGTH ] = { HRSYSTEMUPTIME_SEQ } ;
AsnObjectIdentifier
hrSystemUptime_oid = { HRSYSTEMUPTIME_LENGTH, hrSystemUptime_array } ;
static
UINT
hrSystemDate_array[ HRSYSTEMDATE_LENGTH ] = { HRSYSTEMDATE_SEQ } ;
AsnObjectIdentifier
hrSystemDate_oid = { HRSYSTEMDATE_LENGTH, hrSystemDate_array } ;
static
UINT
hrSystemInitialLoadDevice_array[ HRSYSTEMINITIALLOADDEVICE_LENGTH ] = { HRSYSTEMINITIALLOADDEVICE_SEQ } ;
AsnObjectIdentifier
hrSystemInitialLoadDevice_oid = { HRSYSTEMINITIALLOADDEVICE_LENGTH, hrSystemInitialLoadDevice_array } ;
static
UINT
hrSystemInitialLoadParameters_array[ HRSYSTEMINITIALLOADPARAMETERS_LENGTH ] = { HRSYSTEMINITIALLOADPARAMETERS_SEQ } ;
AsnObjectIdentifier
hrSystemInitialLoadParameters_oid = { HRSYSTEMINITIALLOADPARAMETERS_LENGTH, hrSystemInitialLoadParameters_array } ;
static
UINT
hrSystemNumUsers_array[ HRSYSTEMNUMUSERS_LENGTH ] = { HRSYSTEMNUMUSERS_SEQ } ;
AsnObjectIdentifier
hrSystemNumUsers_oid = { HRSYSTEMNUMUSERS_LENGTH, hrSystemNumUsers_array } ;
static
UINT
hrSystemProcesses_array[ HRSYSTEMPROCESSES_LENGTH ] = { HRSYSTEMPROCESSES_SEQ } ;
AsnObjectIdentifier
hrSystemProcesses_oid = { HRSYSTEMPROCESSES_LENGTH, hrSystemProcesses_array } ;
static
UINT
hrSystemMaxProcesses_array[ HRSYSTEMMAXPROCESSES_LENGTH ] = { HRSYSTEMMAXPROCESSES_SEQ } ;
AsnObjectIdentifier
hrSystemMaxProcesses_oid = { HRSYSTEMMAXPROCESSES_LENGTH, hrSystemMaxProcesses_array } ;
static
UINT
hrSystem_array[ HRSYSTEM_LENGTH ] = { HRSYSTEM_SEQ } ;
AsnObjectIdentifier
hrSystem_oid = { HRSYSTEM_LENGTH, hrSystem_array } ;
variable_t
    hrSystem_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSystemUptime_oid, ASN_RFC1155_TIMETICKS, NSM_READ_ONLY,
      GetHrSystemUptime, NULL,
      SMIGetTimeTicks, SMISetTimeTicks } , 
    { &hrSystemDate_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSystemDate, NULL,
      SMIGetDateAndTime, SMISetDateAndTime } , 
    { &hrSystemInitialLoadDevice_oid, ASN_INTEGER, NSM_READ_WRITE,
      GetHrSystemInitialLoadDevice, SetHrSystemInitialLoadDevice,
      SMIGetInteger, SMISetInteger } , 
    { &hrSystemInitialLoadParameters_oid, ASN_OCTETSTRING, NSM_READ_WRITE,
      GetHrSystemInitialLoadParameters, SetHrSystemInitialLoadParameters,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrSystemNumUsers_oid, ASN_RFC1155_GAUGE, NSM_READ_ONLY,
      GetHrSystemNumUsers, NULL,
      SMIGetGauge, SMISetGauge } , 
    { &hrSystemProcesses_oid, ASN_RFC1155_GAUGE, NSM_READ_ONLY,
      GetHrSystemProcesses, NULL,
      SMIGetGauge, SMISetGauge } , 
    { &hrSystemMaxProcesses_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSystemMaxProcesses, NULL,
      SMIGetInteger, SMISetInteger } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSystem_set_array[ MAX_HRSYSTEM_CODE + 1];
//  extern BYTE hrSystem_set_array[] ;
extern variable_t hrSystem_var_table[] ;
static
UINT
hrMemorySize_array[ HRMEMORYSIZE_LENGTH ] = { HRMEMORYSIZE_SEQ } ;
AsnObjectIdentifier
hrMemorySize_oid = { HRMEMORYSIZE_LENGTH, hrMemorySize_array } ;
static
UINT
hrStorage_array[ HRSTORAGE_LENGTH ] = { HRSTORAGE_SEQ } ;
AsnObjectIdentifier
hrStorage_oid = { HRSTORAGE_LENGTH, hrStorage_array } ;
variable_t
    hrStorage_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrMemorySize_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrMemorySize, NULL,
      SMIGetKBytes, SMISetKBytes } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrStorage_set_array[ MAX_HRSTORAGE_CODE + 1];
//  extern BYTE hrStorage_set_array[] ;
extern variable_t hrStorage_var_table[] ;
static
UINT
hrStorageOther_array[ HRSTORAGEOTHER_LENGTH ] = { HRSTORAGEOTHER_SEQ } ;
AsnObjectIdentifier
hrStorageOther_oid = { HRSTORAGEOTHER_LENGTH, hrStorageOther_array } ;
static
UINT
hrStorageRAM_array[ HRSTORAGERAM_LENGTH ] = { HRSTORAGERAM_SEQ } ;
AsnObjectIdentifier
hrStorageRAM_oid = { HRSTORAGERAM_LENGTH, hrStorageRAM_array } ;
static
UINT
hrStorageVirtualMemory_array[ HRSTORAGEVIRTUALMEMORY_LENGTH ] = { HRSTORAGEVIRTUALMEMORY_SEQ } ;
AsnObjectIdentifier
hrStorageVirtualMemory_oid = { HRSTORAGEVIRTUALMEMORY_LENGTH, hrStorageVirtualMemory_array } ;
static
UINT
hrStorageFixedDisk_array[ HRSTORAGEFIXEDDISK_LENGTH ] = { HRSTORAGEFIXEDDISK_SEQ } ;
AsnObjectIdentifier
hrStorageFixedDisk_oid = { HRSTORAGEFIXEDDISK_LENGTH, hrStorageFixedDisk_array } ;
static
UINT
hrStorageRemovableDisk_array[ HRSTORAGEREMOVABLEDISK_LENGTH ] = { HRSTORAGEREMOVABLEDISK_SEQ } ;
AsnObjectIdentifier
hrStorageRemovableDisk_oid = { HRSTORAGEREMOVABLEDISK_LENGTH, hrStorageRemovableDisk_array } ;
static
UINT
hrStorageFloppyDisk_array[ HRSTORAGEFLOPPYDISK_LENGTH ] = { HRSTORAGEFLOPPYDISK_SEQ } ;
AsnObjectIdentifier
hrStorageFloppyDisk_oid = { HRSTORAGEFLOPPYDISK_LENGTH, hrStorageFloppyDisk_array } ;
static
UINT
hrStorageCompactDisk_array[ HRSTORAGECOMPACTDISK_LENGTH ] = { HRSTORAGECOMPACTDISK_SEQ } ;
AsnObjectIdentifier
hrStorageCompactDisk_oid = { HRSTORAGECOMPACTDISK_LENGTH, hrStorageCompactDisk_array } ;
static
UINT
hrStorageRamDisk_array[ HRSTORAGERAMDISK_LENGTH ] = { HRSTORAGERAMDISK_SEQ } ;
AsnObjectIdentifier
hrStorageRamDisk_oid = { HRSTORAGERAMDISK_LENGTH, hrStorageRamDisk_array } ;
static
UINT
hrStorageTypes_array[ HRSTORAGETYPES_LENGTH ] = { HRSTORAGETYPES_SEQ } ;
AsnObjectIdentifier
hrStorageTypes_oid = { HRSTORAGETYPES_LENGTH, hrStorageTypes_array } ;
static
UINT
hrStorageIndex_array[ HRSTORAGEINDEX_LENGTH ] = { HRSTORAGEINDEX_SEQ } ;
AsnObjectIdentifier
hrStorageIndex_oid = { HRSTORAGEINDEX_LENGTH, hrStorageIndex_array } ;
static
UINT
hrStorageType_array[ HRSTORAGETYPE_LENGTH ] = { HRSTORAGETYPE_SEQ } ;
AsnObjectIdentifier
hrStorageType_oid = { HRSTORAGETYPE_LENGTH, hrStorageType_array } ;
static
UINT
hrStorageDesc_array[ HRSTORAGEDESC_LENGTH ] = { HRSTORAGEDESC_SEQ } ;
AsnObjectIdentifier
hrStorageDesc_oid = { HRSTORAGEDESC_LENGTH, hrStorageDesc_array } ;
static
UINT
hrStorageAllocationUnits_array[ HRSTORAGEALLOCATIONUNITS_LENGTH ] = { HRSTORAGEALLOCATIONUNITS_SEQ } ;
AsnObjectIdentifier
hrStorageAllocationUnits_oid = { HRSTORAGEALLOCATIONUNITS_LENGTH, hrStorageAllocationUnits_array } ;
static
UINT
hrStorageSize_array[ HRSTORAGESIZE_LENGTH ] = { HRSTORAGESIZE_SEQ } ;
AsnObjectIdentifier
hrStorageSize_oid = { HRSTORAGESIZE_LENGTH, hrStorageSize_array } ;
static
UINT
hrStorageUsed_array[ HRSTORAGEUSED_LENGTH ] = { HRSTORAGEUSED_SEQ } ;
AsnObjectIdentifier
hrStorageUsed_oid = { HRSTORAGEUSED_LENGTH, hrStorageUsed_array } ;
static
UINT
hrStorageAllocationFailures_array[ HRSTORAGEALLOCATIONFAILURES_LENGTH ] = { HRSTORAGEALLOCATIONFAILURES_SEQ } ;
AsnObjectIdentifier
hrStorageAllocationFailures_oid = { HRSTORAGEALLOCATIONFAILURES_LENGTH, hrStorageAllocationFailures_array } ;
static
UINT
hrStorageEntry_array[ HRSTORAGEENTRY_LENGTH ] = { HRSTORAGEENTRY_SEQ } ;
AsnObjectIdentifier
hrStorageEntry_oid = { HRSTORAGEENTRY_LENGTH, hrStorageEntry_array } ;
variable_t
    hrStorageEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrStorageIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrStorageIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrStorageType_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrStorageType, NULL,
      SMIGetObjectId, SMISetObjectId } , 
    { &hrStorageDesc_oid, ASN_RFC1213_DISPSTRING, NSM_READ_ONLY,
      GetHrStorageDesc, NULL,
      SMIGetDispString, SMISetDispString } , 
    { &hrStorageAllocationUnits_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrStorageAllocationUnits, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrStorageSize_oid, ASN_INTEGER, NSM_READ_WRITE,
      GetHrStorageSize, SetHrStorageSize,
      SMIGetInteger, SMISetInteger } , 
    { &hrStorageUsed_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrStorageUsed, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrStorageAllocationFailures_oid, ASN_RFC1155_COUNTER, NSM_READ_ONLY,
      GetHrStorageAllocationFailures, NULL,
      SMIGetCounter, SMISetCounter } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrStorageEntry_set_array[ MAX_HRSTORAGEENTRY_CODE + 1];
//  extern BYTE hrStorageEntry_set_array[] ;
extern variable_t hrStorageEntry_var_table[] ;
static
UINT
hrDeviceOther_array[ HRDEVICEOTHER_LENGTH ] = { HRDEVICEOTHER_SEQ } ;
AsnObjectIdentifier
hrDeviceOther_oid = { HRDEVICEOTHER_LENGTH, hrDeviceOther_array } ;
static
UINT
hrDeviceUnknown_array[ HRDEVICEUNKNOWN_LENGTH ] = { HRDEVICEUNKNOWN_SEQ } ;
AsnObjectIdentifier
hrDeviceUnknown_oid = { HRDEVICEUNKNOWN_LENGTH, hrDeviceUnknown_array } ;
static
UINT
hrDeviceProcessor_array[ HRDEVICEPROCESSOR_LENGTH ] = { HRDEVICEPROCESSOR_SEQ } ;
AsnObjectIdentifier
hrDeviceProcessor_oid = { HRDEVICEPROCESSOR_LENGTH, hrDeviceProcessor_array } ;
static
UINT
hrDeviceNetwork_array[ HRDEVICENETWORK_LENGTH ] = { HRDEVICENETWORK_SEQ } ;
AsnObjectIdentifier
hrDeviceNetwork_oid = { HRDEVICENETWORK_LENGTH, hrDeviceNetwork_array } ;
static
UINT
hrDevicePrinter_array[ HRDEVICEPRINTER_LENGTH ] = { HRDEVICEPRINTER_SEQ } ;
AsnObjectIdentifier
hrDevicePrinter_oid = { HRDEVICEPRINTER_LENGTH, hrDevicePrinter_array } ;
static
UINT
hrDeviceDiskStorage_array[ HRDEVICEDISKSTORAGE_LENGTH ] = { HRDEVICEDISKSTORAGE_SEQ } ;
AsnObjectIdentifier
hrDeviceDiskStorage_oid = { HRDEVICEDISKSTORAGE_LENGTH, hrDeviceDiskStorage_array } ;
static
UINT
hrDeviceVideo_array[ HRDEVICEVIDEO_LENGTH ] = { HRDEVICEVIDEO_SEQ } ;
AsnObjectIdentifier
hrDeviceVideo_oid = { HRDEVICEVIDEO_LENGTH, hrDeviceVideo_array } ;
static
UINT
hrDeviceAudio_array[ HRDEVICEAUDIO_LENGTH ] = { HRDEVICEAUDIO_SEQ } ;
AsnObjectIdentifier
hrDeviceAudio_oid = { HRDEVICEAUDIO_LENGTH, hrDeviceAudio_array } ;
static
UINT
hrDeviceCoprocessor_array[ HRDEVICECOPROCESSOR_LENGTH ] = { HRDEVICECOPROCESSOR_SEQ } ;
AsnObjectIdentifier
hrDeviceCoprocessor_oid = { HRDEVICECOPROCESSOR_LENGTH, hrDeviceCoprocessor_array } ;
static
UINT
hrDeviceKeyboard_array[ HRDEVICEKEYBOARD_LENGTH ] = { HRDEVICEKEYBOARD_SEQ } ;
AsnObjectIdentifier
hrDeviceKeyboard_oid = { HRDEVICEKEYBOARD_LENGTH, hrDeviceKeyboard_array } ;
static
UINT
hrDeviceModem_array[ HRDEVICEMODEM_LENGTH ] = { HRDEVICEMODEM_SEQ } ;
AsnObjectIdentifier
hrDeviceModem_oid = { HRDEVICEMODEM_LENGTH, hrDeviceModem_array } ;
static
UINT
hrDeviceParallelPort_array[ HRDEVICEPARALLELPORT_LENGTH ] = { HRDEVICEPARALLELPORT_SEQ } ;
AsnObjectIdentifier
hrDeviceParallelPort_oid = { HRDEVICEPARALLELPORT_LENGTH, hrDeviceParallelPort_array } ;
static
UINT
hrDevicePointing_array[ HRDEVICEPOINTING_LENGTH ] = { HRDEVICEPOINTING_SEQ } ;
AsnObjectIdentifier
hrDevicePointing_oid = { HRDEVICEPOINTING_LENGTH, hrDevicePointing_array } ;
static
UINT
hrDeviceSerialPort_array[ HRDEVICESERIALPORT_LENGTH ] = { HRDEVICESERIALPORT_SEQ } ;
AsnObjectIdentifier
hrDeviceSerialPort_oid = { HRDEVICESERIALPORT_LENGTH, hrDeviceSerialPort_array } ;
static
UINT
hrDeviceTape_array[ HRDEVICETAPE_LENGTH ] = { HRDEVICETAPE_SEQ } ;
AsnObjectIdentifier
hrDeviceTape_oid = { HRDEVICETAPE_LENGTH, hrDeviceTape_array } ;
static
UINT
hrDeviceClock_array[ HRDEVICECLOCK_LENGTH ] = { HRDEVICECLOCK_SEQ } ;
AsnObjectIdentifier
hrDeviceClock_oid = { HRDEVICECLOCK_LENGTH, hrDeviceClock_array } ;
static
UINT
hrDeviceVolatileMemory_array[ HRDEVICEVOLATILEMEMORY_LENGTH ] = { HRDEVICEVOLATILEMEMORY_SEQ } ;
AsnObjectIdentifier
hrDeviceVolatileMemory_oid = { HRDEVICEVOLATILEMEMORY_LENGTH, hrDeviceVolatileMemory_array } ;
static
UINT
hrDeviceNonVolatileMemory_array[ HRDEVICENONVOLATILEMEMORY_LENGTH ] = { HRDEVICENONVOLATILEMEMORY_SEQ } ;
AsnObjectIdentifier
hrDeviceNonVolatileMemory_oid = { HRDEVICENONVOLATILEMEMORY_LENGTH, hrDeviceNonVolatileMemory_array } ;
static
UINT
hrDeviceTypes_array[ HRDEVICETYPES_LENGTH ] = { HRDEVICETYPES_SEQ } ;
AsnObjectIdentifier
hrDeviceTypes_oid = { HRDEVICETYPES_LENGTH, hrDeviceTypes_array } ;
static
UINT
hrDeviceIndex_array[ HRDEVICEINDEX_LENGTH ] = { HRDEVICEINDEX_SEQ } ;
AsnObjectIdentifier
hrDeviceIndex_oid = { HRDEVICEINDEX_LENGTH, hrDeviceIndex_array } ;
static
UINT
hrDeviceType_array[ HRDEVICETYPE_LENGTH ] = { HRDEVICETYPE_SEQ } ;
AsnObjectIdentifier
hrDeviceType_oid = { HRDEVICETYPE_LENGTH, hrDeviceType_array } ;
static
UINT
hrDeviceDesc_array[ HRDEVICEDESC_LENGTH ] = { HRDEVICEDESC_SEQ } ;
AsnObjectIdentifier
hrDeviceDesc_oid = { HRDEVICEDESC_LENGTH, hrDeviceDesc_array } ;
static
UINT
hrDeviceID_array[ HRDEVICEID_LENGTH ] = { HRDEVICEID_SEQ } ;
AsnObjectIdentifier
hrDeviceID_oid = { HRDEVICEID_LENGTH, hrDeviceID_array } ;
static
UINT
hrDeviceStatus_array[ HRDEVICESTATUS_LENGTH ] = { HRDEVICESTATUS_SEQ } ;
AsnObjectIdentifier
hrDeviceStatus_oid = { HRDEVICESTATUS_LENGTH, hrDeviceStatus_array } ;
static
UINT
hrDeviceErrors_array[ HRDEVICEERRORS_LENGTH ] = { HRDEVICEERRORS_SEQ } ;
AsnObjectIdentifier
hrDeviceErrors_oid = { HRDEVICEERRORS_LENGTH, hrDeviceErrors_array } ;
static
UINT
hrDeviceEntry_array[ HRDEVICEENTRY_LENGTH ] = { HRDEVICEENTRY_SEQ } ;
AsnObjectIdentifier
hrDeviceEntry_oid = { HRDEVICEENTRY_LENGTH, hrDeviceEntry_array } ;
variable_t
    hrDeviceEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrDeviceIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDeviceIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrDeviceType_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrDeviceType, NULL,
      SMIGetObjectId, SMISetObjectId } , 
    { &hrDeviceDesc_oid, ASN_RFC1213_DISPSTRING, NSM_READ_ONLY,
      GetHrDeviceDesc, NULL,
      SMIGetDispString, SMISetDispString } , 
    { &hrDeviceID_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrDeviceID, NULL,
      SMIGetProductID, SMISetProductID } , 
    { &hrDeviceStatus_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDeviceStatus, NULL,
      SMIGetINThrDeviceStatus, SMISetINThrDeviceStatus } , 
    { &hrDeviceErrors_oid, ASN_RFC1155_COUNTER, NSM_READ_ONLY,
      GetHrDeviceErrors, NULL,
      SMIGetCounter, SMISetCounter } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrDeviceEntry_set_array[ MAX_HRDEVICEENTRY_CODE + 1];
//  extern BYTE hrDeviceEntry_set_array[] ;
extern variable_t hrDeviceEntry_var_table[] ;
static
UINT
hrProcessorFrwID_array[ HRPROCESSORFRWID_LENGTH ] = { HRPROCESSORFRWID_SEQ } ;
AsnObjectIdentifier
hrProcessorFrwID_oid = { HRPROCESSORFRWID_LENGTH, hrProcessorFrwID_array } ;
static
UINT
hrProcessorLoad_array[ HRPROCESSORLOAD_LENGTH ] = { HRPROCESSORLOAD_SEQ } ;
AsnObjectIdentifier
hrProcessorLoad_oid = { HRPROCESSORLOAD_LENGTH, hrProcessorLoad_array } ;
static
UINT
hrProcessorEntry_array[ HRPROCESSORENTRY_LENGTH ] = { HRPROCESSORENTRY_SEQ } ;
AsnObjectIdentifier
hrProcessorEntry_oid = { HRPROCESSORENTRY_LENGTH, hrProcessorEntry_array } ;
variable_t
    hrProcessorEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrProcessorFrwID_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrProcessorFrwID, NULL,
      SMIGetProductID, SMISetProductID } , 
    { &hrProcessorLoad_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrProcessorLoad, NULL,
      SMIGetInteger, SMISetInteger } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrProcessorEntry_set_array[ MAX_HRPROCESSORENTRY_CODE + 1];
//  extern BYTE hrProcessorEntry_set_array[] ;
extern variable_t hrProcessorEntry_var_table[] ;
static
UINT
hrNetworkIfIndex_array[ HRNETWORKIFINDEX_LENGTH ] = { HRNETWORKIFINDEX_SEQ } ;
AsnObjectIdentifier
hrNetworkIfIndex_oid = { HRNETWORKIFINDEX_LENGTH, hrNetworkIfIndex_array } ;
static
UINT
hrNetworkEntry_array[ HRNETWORKENTRY_LENGTH ] = { HRNETWORKENTRY_SEQ } ;
AsnObjectIdentifier
hrNetworkEntry_oid = { HRNETWORKENTRY_LENGTH, hrNetworkEntry_array } ;
variable_t
    hrNetworkEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrNetworkIfIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrNetworkIfIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrNetworkEntry_set_array[ MAX_HRNETWORKENTRY_CODE + 1];
//  extern BYTE hrNetworkEntry_set_array[] ;
extern variable_t hrNetworkEntry_var_table[] ;
static
UINT
hrPrinterStatus_array[ HRPRINTERSTATUS_LENGTH ] = { HRPRINTERSTATUS_SEQ } ;
AsnObjectIdentifier
hrPrinterStatus_oid = { HRPRINTERSTATUS_LENGTH, hrPrinterStatus_array } ;
static
UINT
hrPrinterDetectedErrorState_array[ HRPRINTERDETECTEDERRORSTATE_LENGTH ] = { HRPRINTERDETECTEDERRORSTATE_SEQ } ;
AsnObjectIdentifier
hrPrinterDetectedErrorState_oid = { HRPRINTERDETECTEDERRORSTATE_LENGTH, hrPrinterDetectedErrorState_array } ;
static
UINT
hrPrinterEntry_array[ HRPRINTERENTRY_LENGTH ] = { HRPRINTERENTRY_SEQ } ;
AsnObjectIdentifier
hrPrinterEntry_oid = { HRPRINTERENTRY_LENGTH, hrPrinterEntry_array } ;
variable_t
    hrPrinterEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrPrinterStatus_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrPrinterStatus, NULL,
      SMIGetINThrPrinterStatus, SMISetINThrPrinterStatus } , 
    { &hrPrinterDetectedErrorState_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrPrinterDetectedErrorState, NULL,
      SMIGetOctetString, SMISetOctetString } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrPrinterEntry_set_array[ MAX_HRPRINTERENTRY_CODE + 1];
//  extern BYTE hrPrinterEntry_set_array[] ;
extern variable_t hrPrinterEntry_var_table[] ;
static
UINT
hrDiskStorageAccess_array[ HRDISKSTORAGEACCESS_LENGTH ] = { HRDISKSTORAGEACCESS_SEQ } ;
AsnObjectIdentifier
hrDiskStorageAccess_oid = { HRDISKSTORAGEACCESS_LENGTH, hrDiskStorageAccess_array } ;
static
UINT
hrDiskStorageMedia_array[ HRDISKSTORAGEMEDIA_LENGTH ] = { HRDISKSTORAGEMEDIA_SEQ } ;
AsnObjectIdentifier
hrDiskStorageMedia_oid = { HRDISKSTORAGEMEDIA_LENGTH, hrDiskStorageMedia_array } ;
static
UINT
hrDiskStorageRemoveble_array[ HRDISKSTORAGEREMOVEBLE_LENGTH ] = { HRDISKSTORAGEREMOVEBLE_SEQ } ;
AsnObjectIdentifier
hrDiskStorageRemoveble_oid = { HRDISKSTORAGEREMOVEBLE_LENGTH, hrDiskStorageRemoveble_array } ;
static
UINT
hrDiskStorageCapacity_array[ HRDISKSTORAGECAPACITY_LENGTH ] = { HRDISKSTORAGECAPACITY_SEQ } ;
AsnObjectIdentifier
hrDiskStorageCapacity_oid = { HRDISKSTORAGECAPACITY_LENGTH, hrDiskStorageCapacity_array } ;
static
UINT
hrDiskStorageEntry_array[ HRDISKSTORAGEENTRY_LENGTH ] = { HRDISKSTORAGEENTRY_SEQ } ;
AsnObjectIdentifier
hrDiskStorageEntry_oid = { HRDISKSTORAGEENTRY_LENGTH, hrDiskStorageEntry_array } ;
variable_t
    hrDiskStorageEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrDiskStorageAccess_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDiskStorageAccess, NULL,
      SMIGetINTAccess, SMISetINTAccess } , 
    { &hrDiskStorageMedia_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDiskStorageMedia, NULL,
      SMIGetINThrDiskStorageMedia, SMISetINThrDiskStorageMedia } , 
    { &hrDiskStorageRemoveble_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDiskStorageRemoveble, NULL,
      SMIGetBoolean, SMISetBoolean } , 
    { &hrDiskStorageCapacity_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrDiskStorageCapacity, NULL,
      SMIGetKBytes, SMISetKBytes } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrDiskStorageEntry_set_array[ MAX_HRDISKSTORAGEENTRY_CODE + 1];
//  extern BYTE hrDiskStorageEntry_set_array[] ;
extern variable_t hrDiskStorageEntry_var_table[] ;
static
UINT
hrPartitionIndex_array[ HRPARTITIONINDEX_LENGTH ] = { HRPARTITIONINDEX_SEQ } ;
AsnObjectIdentifier
hrPartitionIndex_oid = { HRPARTITIONINDEX_LENGTH, hrPartitionIndex_array } ;
static
UINT
hrPartitionLabel_array[ HRPARTITIONLABEL_LENGTH ] = { HRPARTITIONLABEL_SEQ } ;
AsnObjectIdentifier
hrPartitionLabel_oid = { HRPARTITIONLABEL_LENGTH, hrPartitionLabel_array } ;
static
UINT
hrPartitionID_array[ HRPARTITIONID_LENGTH ] = { HRPARTITIONID_SEQ } ;
AsnObjectIdentifier
hrPartitionID_oid = { HRPARTITIONID_LENGTH, hrPartitionID_array } ;
static
UINT
hrPartitionSize_array[ HRPARTITIONSIZE_LENGTH ] = { HRPARTITIONSIZE_SEQ } ;
AsnObjectIdentifier
hrPartitionSize_oid = { HRPARTITIONSIZE_LENGTH, hrPartitionSize_array } ;
static
UINT
hrPartitionFSIndex_array[ HRPARTITIONFSINDEX_LENGTH ] = { HRPARTITIONFSINDEX_SEQ } ;
AsnObjectIdentifier
hrPartitionFSIndex_oid = { HRPARTITIONFSINDEX_LENGTH, hrPartitionFSIndex_array } ;
static
UINT
hrPartitionEntry_array[ HRPARTITIONENTRY_LENGTH ] = { HRPARTITIONENTRY_SEQ } ;
AsnObjectIdentifier
hrPartitionEntry_oid = { HRPARTITIONENTRY_LENGTH, hrPartitionEntry_array } ;
variable_t
    hrPartitionEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrPartitionIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrPartitionIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrPartitionLabel_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrPartitionLabel, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrPartitionID_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrPartitionID, NULL,
      SMIGetOctetString, SMISetOctetString } , 
    { &hrPartitionSize_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrPartitionSize, NULL,
      SMIGetKBytes, SMISetKBytes } , 
    { &hrPartitionFSIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrPartitionFSIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrPartitionEntry_set_array[ MAX_HRPARTITIONENTRY_CODE + 1];
//  extern BYTE hrPartitionEntry_set_array[] ;
extern variable_t hrPartitionEntry_var_table[] ;
static
UINT
hrFSIndex_array[ HRFSINDEX_LENGTH ] = { HRFSINDEX_SEQ } ;
AsnObjectIdentifier
hrFSIndex_oid = { HRFSINDEX_LENGTH, hrFSIndex_array } ;
static
UINT
hrFSMountPoint_array[ HRFSMOUNTPOINT_LENGTH ] = { HRFSMOUNTPOINT_SEQ } ;
AsnObjectIdentifier
hrFSMountPoint_oid = { HRFSMOUNTPOINT_LENGTH, hrFSMountPoint_array } ;
static
UINT
hrFSRemoteMountPoint_array[ HRFSREMOTEMOUNTPOINT_LENGTH ] = { HRFSREMOTEMOUNTPOINT_SEQ } ;
AsnObjectIdentifier
hrFSRemoteMountPoint_oid = { HRFSREMOTEMOUNTPOINT_LENGTH, hrFSRemoteMountPoint_array } ;
static
UINT
hrFSType_array[ HRFSTYPE_LENGTH ] = { HRFSTYPE_SEQ } ;
AsnObjectIdentifier
hrFSType_oid = { HRFSTYPE_LENGTH, hrFSType_array } ;
static
UINT
hrFSAccess_array[ HRFSACCESS_LENGTH ] = { HRFSACCESS_SEQ } ;
AsnObjectIdentifier
hrFSAccess_oid = { HRFSACCESS_LENGTH, hrFSAccess_array } ;
static
UINT
hrFSBootable_array[ HRFSBOOTABLE_LENGTH ] = { HRFSBOOTABLE_SEQ } ;
AsnObjectIdentifier
hrFSBootable_oid = { HRFSBOOTABLE_LENGTH, hrFSBootable_array } ;
static
UINT
hrFSStorageIndex_array[ HRFSSTORAGEINDEX_LENGTH ] = { HRFSSTORAGEINDEX_SEQ } ;
AsnObjectIdentifier
hrFSStorageIndex_oid = { HRFSSTORAGEINDEX_LENGTH, hrFSStorageIndex_array } ;
static
UINT
hrFSLastFullBackupDate_array[ HRFSLASTFULLBACKUPDATE_LENGTH ] = { HRFSLASTFULLBACKUPDATE_SEQ } ;
AsnObjectIdentifier
hrFSLastFullBackupDate_oid = { HRFSLASTFULLBACKUPDATE_LENGTH, hrFSLastFullBackupDate_array } ;
static
UINT
hrFSLastPartialBackupDate_array[ HRFSLASTPARTIALBACKUPDATE_LENGTH ] = { HRFSLASTPARTIALBACKUPDATE_SEQ } ;
AsnObjectIdentifier
hrFSLastPartialBackupDate_oid = { HRFSLASTPARTIALBACKUPDATE_LENGTH, hrFSLastPartialBackupDate_array } ;
static
UINT
hrFSEntry_array[ HRFSENTRY_LENGTH ] = { HRFSENTRY_SEQ } ;
AsnObjectIdentifier
hrFSEntry_oid = { HRFSENTRY_LENGTH, hrFSEntry_array } ;
variable_t
    hrFSEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrFSIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrFSIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrFSMountPoint_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrFSMountPoint, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrFSRemoteMountPoint_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrFSRemoteMountPoint, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrFSType_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrFSType, NULL,
      SMIGetObjectId, SMISetObjectId } , 
    { &hrFSAccess_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrFSAccess, NULL,
      SMIGetINTAccess, SMISetINTAccess } , 
    { &hrFSBootable_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrFSBootable, NULL,
      SMIGetBoolean, SMISetBoolean } , 
    { &hrFSStorageIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrFSStorageIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrFSLastFullBackupDate_oid, ASN_OCTETSTRING, NSM_READ_WRITE,
      GetHrFSLastFullBackupDate, SetHrFSLastFullBackupDate,
      SMIGetDateAndTime, SMISetDateAndTime } , 
    { &hrFSLastPartialBackupDate_oid, ASN_OCTETSTRING, NSM_READ_WRITE,
      GetHrFSLastPartialBackupDate, SetHrFSLastPartialBackupDate,
      SMIGetDateAndTime, SMISetDateAndTime } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrFSEntry_set_array[ MAX_HRFSENTRY_CODE + 1];
//  extern BYTE hrFSEntry_set_array[] ;
extern variable_t hrFSEntry_var_table[] ;
static
UINT
hrFSOther_array[ HRFSOTHER_LENGTH ] = { HRFSOTHER_SEQ } ;
AsnObjectIdentifier
hrFSOther_oid = { HRFSOTHER_LENGTH, hrFSOther_array } ;
static
UINT
hrFSUnknown_array[ HRFSUNKNOWN_LENGTH ] = { HRFSUNKNOWN_SEQ } ;
AsnObjectIdentifier
hrFSUnknown_oid = { HRFSUNKNOWN_LENGTH, hrFSUnknown_array } ;
static
UINT
hrFSBerkeleyFFS_array[ HRFSBERKELEYFFS_LENGTH ] = { HRFSBERKELEYFFS_SEQ } ;
AsnObjectIdentifier
hrFSBerkeleyFFS_oid = { HRFSBERKELEYFFS_LENGTH, hrFSBerkeleyFFS_array } ;
static
UINT
hrFSSys5FS_array[ HRFSSYS5FS_LENGTH ] = { HRFSSYS5FS_SEQ } ;
AsnObjectIdentifier
hrFSSys5FS_oid = { HRFSSYS5FS_LENGTH, hrFSSys5FS_array } ;
/*
 *    DOS
 */
static
UINT
hrFSFat_array[ HRFSFAT_LENGTH ] = { HRFSFAT_SEQ } ;
AsnObjectIdentifier
hrFSFat_oid = { HRFSFAT_LENGTH, hrFSFat_array } ;
/*
 *    OS/2 High Performance File System
 */
static
UINT
hrFSHPFS_array[ HRFSHPFS_LENGTH ] = { HRFSHPFS_SEQ } ;
AsnObjectIdentifier
hrFSHPFS_oid = { HRFSHPFS_LENGTH, hrFSHPFS_array } ;
/*
 *    Macintosh Hierarchical File System
 */
static
UINT
hrFSHFS_array[ HRFSHFS_LENGTH ] = { HRFSHFS_SEQ } ;
AsnObjectIdentifier
hrFSHFS_oid = { HRFSHFS_LENGTH, hrFSHFS_array } ;
/*
 *    Macintosh File System
 */
static
UINT
hrFSMFS_array[ HRFSMFS_LENGTH ] = { HRFSMFS_SEQ } ;
AsnObjectIdentifier
hrFSMFS_oid = { HRFSMFS_LENGTH, hrFSMFS_array } ;
/*
 *    Windows NT
 */
static
UINT
hrFSNTFS_array[ HRFSNTFS_LENGTH ] = { HRFSNTFS_SEQ } ;
AsnObjectIdentifier
hrFSNTFS_oid = { HRFSNTFS_LENGTH, hrFSNTFS_array } ;
static
UINT
hrFSVNode_array[ HRFSVNODE_LENGTH ] = { HRFSVNODE_SEQ } ;
AsnObjectIdentifier
hrFSVNode_oid = { HRFSVNODE_LENGTH, hrFSVNode_array } ;
static
UINT
hrFSJournaled_array[ HRFSJOURNALED_LENGTH ] = { HRFSJOURNALED_SEQ } ;
AsnObjectIdentifier
hrFSJournaled_oid = { HRFSJOURNALED_LENGTH, hrFSJournaled_array } ;
/*
 *    CD File System
 */
static
UINT
hrFSiso9660_array[ HRFSISO9660_LENGTH ] = { HRFSISO9660_SEQ } ;
AsnObjectIdentifier
hrFSiso9660_oid = { HRFSISO9660_LENGTH, hrFSiso9660_array } ;
static
UINT
hrFSRockRidge_array[ HRFSROCKRIDGE_LENGTH ] = { HRFSROCKRIDGE_SEQ } ;
AsnObjectIdentifier
hrFSRockRidge_oid = { HRFSROCKRIDGE_LENGTH, hrFSRockRidge_array } ;
static
UINT
hrFSNFS_array[ HRFSNFS_LENGTH ] = { HRFSNFS_SEQ } ;
AsnObjectIdentifier
hrFSNFS_oid = { HRFSNFS_LENGTH, hrFSNFS_array } ;
static
UINT
hrFSNetware_array[ HRFSNETWARE_LENGTH ] = { HRFSNETWARE_SEQ } ;
AsnObjectIdentifier
hrFSNetware_oid = { HRFSNETWARE_LENGTH, hrFSNetware_array } ;
/*
 *    Andrew File System
 */
static
UINT
hrFSAFS_array[ HRFSAFS_LENGTH ] = { HRFSAFS_SEQ } ;
AsnObjectIdentifier
hrFSAFS_oid = { HRFSAFS_LENGTH, hrFSAFS_array } ;
/*
 *    OSF DCE Distributed File System
 */
static
UINT
hrFSDFS_array[ HRFSDFS_LENGTH ] = { HRFSDFS_SEQ } ;
AsnObjectIdentifier
hrFSDFS_oid = { HRFSDFS_LENGTH, hrFSDFS_array } ;
static
UINT
hrFSApplshare_array[ HRFSAPPLSHARE_LENGTH ] = { HRFSAPPLSHARE_SEQ } ;
AsnObjectIdentifier
hrFSApplshare_oid = { HRFSAPPLSHARE_LENGTH, hrFSApplshare_array } ;
static
UINT
hrFSRFS_array[ HRFSRFS_LENGTH ] = { HRFSRFS_SEQ } ;
AsnObjectIdentifier
hrFSRFS_oid = { HRFSRFS_LENGTH, hrFSRFS_array } ;
/*
 *    Data General
 */
static
UINT
hrFSDGFS_array[ HRFSDGFS_LENGTH ] = { HRFSDGFS_SEQ } ;
AsnObjectIdentifier
hrFSDGFS_oid = { HRFSDGFS_LENGTH, hrFSDGFS_array } ;
/*
 *    SVR4 Boot File System
 */
static
UINT
hrFSBFS_array[ HRFSBFS_LENGTH ] = { HRFSBFS_SEQ } ;
AsnObjectIdentifier
hrFSBFS_oid = { HRFSBFS_LENGTH, hrFSBFS_array } ;
static
UINT
hrFSTypes_array[ HRFSTYPES_LENGTH ] = { HRFSTYPES_SEQ } ;
AsnObjectIdentifier
hrFSTypes_oid = { HRFSTYPES_LENGTH, hrFSTypes_array } ;
static
UINT
hrSWOSIndex_array[ HRSWOSINDEX_LENGTH ] = { HRSWOSINDEX_SEQ } ;
AsnObjectIdentifier
hrSWOSIndex_oid = { HRSWOSINDEX_LENGTH, hrSWOSIndex_array } ;
static
UINT
hrSWRun_array[ HRSWRUN_LENGTH ] = { HRSWRUN_SEQ } ;
AsnObjectIdentifier
hrSWRun_oid = { HRSWRUN_LENGTH, hrSWRun_array } ;
variable_t
    hrSWRun_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSWOSIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWOSIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSWRun_set_array[ MAX_HRSWRUN_CODE + 1];
//  extern BYTE hrSWRun_set_array[] ;
extern variable_t hrSWRun_var_table[] ;
static
UINT
hrSWRunIndex_array[ HRSWRUNINDEX_LENGTH ] = { HRSWRUNINDEX_SEQ } ;
AsnObjectIdentifier
hrSWRunIndex_oid = { HRSWRUNINDEX_LENGTH, hrSWRunIndex_array } ;
static
UINT
hrSWRunName_array[ HRSWRUNNAME_LENGTH ] = { HRSWRUNNAME_SEQ } ;
AsnObjectIdentifier
hrSWRunName_oid = { HRSWRUNNAME_LENGTH, hrSWRunName_array } ;
static
UINT
hrSWRunID_array[ HRSWRUNID_LENGTH ] = { HRSWRUNID_SEQ } ;
AsnObjectIdentifier
hrSWRunID_oid = { HRSWRUNID_LENGTH, hrSWRunID_array } ;
static
UINT
hrSWRunPath_array[ HRSWRUNPATH_LENGTH ] = { HRSWRUNPATH_SEQ } ;
AsnObjectIdentifier
hrSWRunPath_oid = { HRSWRUNPATH_LENGTH, hrSWRunPath_array } ;
static
UINT
hrSWRunParameters_array[ HRSWRUNPARAMETERS_LENGTH ] = { HRSWRUNPARAMETERS_SEQ } ;
AsnObjectIdentifier
hrSWRunParameters_oid = { HRSWRUNPARAMETERS_LENGTH, hrSWRunParameters_array } ;
static
UINT
hrSWRunType_array[ HRSWRUNTYPE_LENGTH ] = { HRSWRUNTYPE_SEQ } ;
AsnObjectIdentifier
hrSWRunType_oid = { HRSWRUNTYPE_LENGTH, hrSWRunType_array } ;
static
UINT
hrSWRunStatus_array[ HRSWRUNSTATUS_LENGTH ] = { HRSWRUNSTATUS_SEQ } ;
AsnObjectIdentifier
hrSWRunStatus_oid = { HRSWRUNSTATUS_LENGTH, hrSWRunStatus_array } ;
static
UINT
hrSWRunEntry_array[ HRSWRUNENTRY_LENGTH ] = { HRSWRUNENTRY_SEQ } ;
AsnObjectIdentifier
hrSWRunEntry_oid = { HRSWRUNENTRY_LENGTH, hrSWRunEntry_array } ;
variable_t
    hrSWRunEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSWRunIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWRunIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrSWRunName_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSWRunName, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrSWRunID_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrSWRunID, NULL,
      SMIGetProductID, SMISetProductID } , 
    { &hrSWRunPath_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSWRunPath, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrSWRunParameters_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSWRunParameters, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrSWRunType_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWRunType, NULL,
      SMIGetINTSWType, SMISetINTSWType } , 
    { &hrSWRunStatus_oid, ASN_INTEGER, NSM_READ_WRITE,
      GetHrSWRunStatus, SetHrSWRunStatus,
      SMIGetINThrSWRunStatus, SMISetINThrSWRunStatus } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSWRunEntry_set_array[ MAX_HRSWRUNENTRY_CODE + 1];
//  extern BYTE hrSWRunEntry_set_array[] ;
extern variable_t hrSWRunEntry_var_table[] ;
static
UINT
hrSWRunPerfCPU_array[ HRSWRUNPERFCPU_LENGTH ] = { HRSWRUNPERFCPU_SEQ } ;
AsnObjectIdentifier
hrSWRunPerfCPU_oid = { HRSWRUNPERFCPU_LENGTH, hrSWRunPerfCPU_array } ;
static
UINT
hrSWRunPerfMem_array[ HRSWRUNPERFMEM_LENGTH ] = { HRSWRUNPERFMEM_SEQ } ;
AsnObjectIdentifier
hrSWRunPerfMem_oid = { HRSWRUNPERFMEM_LENGTH, hrSWRunPerfMem_array } ;
static
UINT
hrSWRunPerfEntry_array[ HRSWRUNPERFENTRY_LENGTH ] = { HRSWRUNPERFENTRY_SEQ } ;
AsnObjectIdentifier
hrSWRunPerfEntry_oid = { HRSWRUNPERFENTRY_LENGTH, hrSWRunPerfEntry_array } ;
variable_t
    hrSWRunPerfEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSWRunPerfCPU_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWRunPerfCPU, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrSWRunPerfMem_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWRunPerfMem, NULL,
      SMIGetKBytes, SMISetKBytes } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSWRunPerfEntry_set_array[ MAX_HRSWRUNPERFENTRY_CODE + 1];
//  extern BYTE hrSWRunPerfEntry_set_array[] ;
extern variable_t hrSWRunPerfEntry_var_table[] ;
static
UINT
hrSWInstalledLastChange_array[ HRSWINSTALLEDLASTCHANGE_LENGTH ] = { HRSWINSTALLEDLASTCHANGE_SEQ } ;
AsnObjectIdentifier
hrSWInstalledLastChange_oid = { HRSWINSTALLEDLASTCHANGE_LENGTH, hrSWInstalledLastChange_array } ;
static
UINT
hrSWInstalledLastUpdateTime_array[ HRSWINSTALLEDLASTUPDATETIME_LENGTH ] = { HRSWINSTALLEDLASTUPDATETIME_SEQ } ;
AsnObjectIdentifier
hrSWInstalledLastUpdateTime_oid = { HRSWINSTALLEDLASTUPDATETIME_LENGTH, hrSWInstalledLastUpdateTime_array } ;
static
UINT
hrSWInstalled_array[ HRSWINSTALLED_LENGTH ] = { HRSWINSTALLED_SEQ } ;
AsnObjectIdentifier
hrSWInstalled_oid = { HRSWINSTALLED_LENGTH, hrSWInstalled_array } ;
variable_t
    hrSWInstalled_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSWInstalledLastChange_oid, ASN_RFC1155_TIMETICKS, NSM_READ_ONLY,
      GetHrSWInstalledLastChange, NULL,
      SMIGetTimeTicks, SMISetTimeTicks } , 
    { &hrSWInstalledLastUpdateTime_oid, ASN_RFC1155_TIMETICKS, NSM_READ_ONLY,
      GetHrSWInstalledLastUpdateTime, NULL,
      SMIGetTimeTicks, SMISetTimeTicks } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSWInstalled_set_array[ MAX_HRSWINSTALLED_CODE + 1];
//  extern BYTE hrSWInstalled_set_array[] ;
extern variable_t hrSWInstalled_var_table[] ;
static
UINT
hrSWInstalledIndex_array[ HRSWINSTALLEDINDEX_LENGTH ] = { HRSWINSTALLEDINDEX_SEQ } ;
AsnObjectIdentifier
hrSWInstalledIndex_oid = { HRSWINSTALLEDINDEX_LENGTH, hrSWInstalledIndex_array } ;
static
UINT
hrSWInstalledName_array[ HRSWINSTALLEDNAME_LENGTH ] = { HRSWINSTALLEDNAME_SEQ } ;
AsnObjectIdentifier
hrSWInstalledName_oid = { HRSWINSTALLEDNAME_LENGTH, hrSWInstalledName_array } ;
static
UINT
hrSWInstalledID_array[ HRSWINSTALLEDID_LENGTH ] = { HRSWINSTALLEDID_SEQ } ;
AsnObjectIdentifier
hrSWInstalledID_oid = { HRSWINSTALLEDID_LENGTH, hrSWInstalledID_array } ;
static
UINT
hrSWInstalledType_array[ HRSWINSTALLEDTYPE_LENGTH ] = { HRSWINSTALLEDTYPE_SEQ } ;
AsnObjectIdentifier
hrSWInstalledType_oid = { HRSWINSTALLEDTYPE_LENGTH, hrSWInstalledType_array } ;
static
UINT
hrSWInstalledDate_array[ HRSWINSTALLEDDATE_LENGTH ] = { HRSWINSTALLEDDATE_SEQ } ;
AsnObjectIdentifier
hrSWInstalledDate_oid = { HRSWINSTALLEDDATE_LENGTH, hrSWInstalledDate_array } ;
static
UINT
hrSWInstalledEntry_array[ HRSWINSTALLEDENTRY_LENGTH ] = { HRSWINSTALLEDENTRY_SEQ } ;
AsnObjectIdentifier
hrSWInstalledEntry_oid = { HRSWINSTALLEDENTRY_LENGTH, hrSWInstalledEntry_array } ;
variable_t
    hrSWInstalledEntry_var_table[] = {
    { NULL, ASN_NULL, NSM_NO_ACCESS, NULL, NULL, NULL, NULL } ,
    { &hrSWInstalledIndex_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWInstalledIndex, NULL,
      SMIGetInteger, SMISetInteger } , 
    { &hrSWInstalledName_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSWInstalledName, NULL,
      SMIGetInternationalDisplayString, SMISetInternationalDisplayString } , 
    { &hrSWInstalledID_oid, ASN_OBJECTIDENTIFIER, NSM_READ_ONLY,
      GetHrSWInstalledID, NULL,
      SMIGetProductID, SMISetProductID } , 
    { &hrSWInstalledType_oid, ASN_INTEGER, NSM_READ_ONLY,
      GetHrSWInstalledType, NULL,
      SMIGetINTSWType, SMISetINTSWType } , 
    { &hrSWInstalledDate_oid, ASN_OCTETSTRING, NSM_READ_ONLY,
      GetHrSWInstalledDate, NULL,
      SMIGetDateAndTime, SMISetDateAndTime } , 
    } ;
// Next two lines are platform specific 
//  BYTE hrSWInstalledEntry_set_array[ MAX_HRSWINSTALLEDENTRY_CODE + 1];
//  extern BYTE hrSWInstalledEntry_set_array[] ;
extern variable_t hrSWInstalledEntry_var_table[] ;
class_t
    class_info[] = { 
    // hrSystem
    { NON_TABLE, &hrSystem_oid, HRSYSTEM_VAR_INDEX,
      MIN_HRSYSTEM_CODE, MAX_HRSYSTEM_CODE,
      HrSystemFindInstance, HrSystemFindNextInstance,
      HrSystemConvertInstance, HrSystemFreeInstance,
      hrSystem_var_table } , 

    // hrStorage
    { NON_TABLE, &hrStorage_oid, HRSTORAGE_VAR_INDEX,
      MIN_HRSTORAGE_CODE, MAX_HRSTORAGE_CODE,
      HrStorageFindInstance, HrStorageFindNextInstance,
      HrStorageConvertInstance, HrStorageFreeInstance,
      hrStorage_var_table } , 

    // hrStorageEntry
    { TABLE, &hrStorageEntry_oid, HRSTORAGEENTRY_VAR_INDEX,
      MIN_HRSTORAGEENTRY_CODE, MAX_HRSTORAGEENTRY_CODE,
      HrStorageEntryFindInstance, HrStorageEntryFindNextInstance,
      HrStorageEntryConvertInstance, HrStorageEntryFreeInstance,
      hrStorageEntry_var_table } , 

    // hrDeviceEntry
    { TABLE, &hrDeviceEntry_oid, HRDEVICEENTRY_VAR_INDEX,
      MIN_HRDEVICEENTRY_CODE, MAX_HRDEVICEENTRY_CODE,
      HrDeviceEntryFindInstance, HrDeviceEntryFindNextInstance,
      HrDeviceEntryConvertInstance, HrDeviceEntryFreeInstance,
      hrDeviceEntry_var_table } , 

    // hrProcessorEntry
    { TABLE, &hrProcessorEntry_oid, HRPROCESSORENTRY_VAR_INDEX,
      MIN_HRPROCESSORENTRY_CODE, MAX_HRPROCESSORENTRY_CODE,
      HrProcessorEntryFindInstance, HrProcessorEntryFindNextInstance,
      HrProcessorEntryConvertInstance, HrProcessorEntryFreeInstance,
      hrProcessorEntry_var_table } , 

    // hrNetworkEntry
    { TABLE, &hrNetworkEntry_oid, HRNETWORKENTRY_VAR_INDEX,
      MIN_HRNETWORKENTRY_CODE, MAX_HRNETWORKENTRY_CODE,
      HrNetworkEntryFindInstance, HrNetworkEntryFindNextInstance,
      HrNetworkEntryConvertInstance, HrNetworkEntryFreeInstance,
      hrNetworkEntry_var_table } , 

    // hrPrinterEntry
    { TABLE, &hrPrinterEntry_oid, HRPRINTERENTRY_VAR_INDEX,
      MIN_HRPRINTERENTRY_CODE, MAX_HRPRINTERENTRY_CODE,
      HrPrinterEntryFindInstance, HrPrinterEntryFindNextInstance,
      HrPrinterEntryConvertInstance, HrPrinterEntryFreeInstance,
      hrPrinterEntry_var_table } , 

    // hrDiskStorageEntry
    { TABLE, &hrDiskStorageEntry_oid, HRDISKSTORAGEENTRY_VAR_INDEX,
      MIN_HRDISKSTORAGEENTRY_CODE, MAX_HRDISKSTORAGEENTRY_CODE,
      HrDiskStorageEntryFindInstance, HrDiskStorageEntryFindNextInstance,
      HrDiskStorageEntryConvertInstance, HrDiskStorageEntryFreeInstance,
      hrDiskStorageEntry_var_table } , 

    // hrPartitionEntry
    { TABLE, &hrPartitionEntry_oid, HRPARTITIONENTRY_VAR_INDEX,
      MIN_HRPARTITIONENTRY_CODE, MAX_HRPARTITIONENTRY_CODE,
      HrPartitionEntryFindInstance, HrPartitionEntryFindNextInstance,
      HrPartitionEntryConvertInstance, HrPartitionEntryFreeInstance,
      hrPartitionEntry_var_table } , 

    // hrFSEntry
    { TABLE, &hrFSEntry_oid, HRFSENTRY_VAR_INDEX,
      MIN_HRFSENTRY_CODE, MAX_HRFSENTRY_CODE,
      HrFSEntryFindInstance, HrFSEntryFindNextInstance,
      HrFSEntryConvertInstance, HrFSEntryFreeInstance,
      hrFSEntry_var_table } , 

    // hrSWRun
    { NON_TABLE, &hrSWRun_oid, HRSWRUN_VAR_INDEX,
      MIN_HRSWRUN_CODE, MAX_HRSWRUN_CODE,
      HrSWRunFindInstance, HrSWRunFindNextInstance,
      HrSWRunConvertInstance, HrSWRunFreeInstance,
      hrSWRun_var_table } , 

    // hrSWRunEntry
    { TABLE, &hrSWRunEntry_oid, HRSWRUNENTRY_VAR_INDEX,
      MIN_HRSWRUNENTRY_CODE, MAX_HRSWRUNENTRY_CODE,
      HrSWRunEntryFindInstance, HrSWRunEntryFindNextInstance,
      HrSWRunEntryConvertInstance, HrSWRunEntryFreeInstance,
      hrSWRunEntry_var_table } , 

    // hrSWRunPerfEntry
    { TABLE, &hrSWRunPerfEntry_oid, HRSWRUNPERFENTRY_VAR_INDEX,
      MIN_HRSWRUNPERFENTRY_CODE, MAX_HRSWRUNPERFENTRY_CODE,
      HrSWRunPerfEntryFindInstance, HrSWRunPerfEntryFindNextInstance,
      HrSWRunPerfEntryConvertInstance, HrSWRunPerfEntryFreeInstance,
      hrSWRunPerfEntry_var_table } , 

    // hrSWInstalled
    { NON_TABLE, &hrSWInstalled_oid, HRSWINSTALLED_VAR_INDEX,
      MIN_HRSWINSTALLED_CODE, MAX_HRSWINSTALLED_CODE,
      HrSWInstalledFindInstance, HrSWInstalledFindNextInstance,
      HrSWInstalledConvertInstance, HrSWInstalledFreeInstance,
      hrSWInstalled_var_table } , 

    // hrSWInstalledEntry
    { TABLE, &hrSWInstalledEntry_oid, HRSWINSTALLEDENTRY_VAR_INDEX,
      MIN_HRSWINSTALLEDENTRY_CODE, MAX_HRSWINSTALLEDENTRY_CODE,
      HrSWInstalledEntryFindInstance, HrSWInstalledEntryFindNextInstance,
      HrSWInstalledEntryConvertInstance, HrSWInstalledEntryFreeInstance,
      hrSWInstalledEntry_var_table } , 
    } ; 

extern class_t class_info[] ;

extern char *EventLogString ;
extern char mibEventValue[] ;




/*
 *  UserMibInit
 *
 *    This routine is to allow user to initialize any variable at the time of
 *    dll's activation.  This routine setups up the registry for application
 *    event logging and calls out to the trap initialization code.  The user
 *    specific code follows.
 *
 *  Arguments:
 *
 *    hPollForTrapEvent    handle for traps - this is used to coordinate
 *                         between the Extendible Agent and this Extension
 *                         Agent.  It is passed to the TrapInit() routine.
 *                             - NULL indicates no traps
 *                             - value from CreateEvent() indicates traps
 *                               are implemented and the Extendible agent
 *                               must poll for them
 *
 *  Return Code:
 *
 *    SUCCESS     Successful initialization
 *    FAILURE     Unable to initialize
 *
 */

UINT
UserMibInit( IN OUT HANDLE *hPollForTrapEvent )
{
    HKEY hkey ;
    DWORD dwData ;
    UCHAR valuebuf[ 80 ] ;
    char mibEventKey[ 256 ] ;


    // The user must initialize the Event Log handle.  NULL in the first
    // argument indicates that the log is on the local machine.  The text
    // string for the second argument is the same as the subkey in the
    // registry under
    //       HKEY_LOCAL_MACHINE
    //         SYSTEM
    //           CurrentControlSet
    //             Services
    //               EventLog
    //                 Application
    //                   GenAgent    (for this example)
    //
    // But first create the subkey and set the values associated with it.
    // The subkey uses the eventLogString name.

    memset( mibEventKey, '\0', sizeof( UCHAR ) * 256 ) ;
    sprintf( mibEventKey ,
             "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\%s" ,
             eventLogString ) ;
    if ( RegCreateKey( HKEY_LOCAL_MACHINE, mibEventKey, &hkey ) )
        return FAILURE ;

    memset( valuebuf, '\0', sizeof( UCHAR ) * 80 ) ;
    sprintf( valuebuf, "%%SystemRoot%%\\System32\\%s", mibEventValue ) ;
    if ( RegSetValueEx( hkey ,
                        "EventMessageFile" ,  // Value name
                        0 ,                   // must be zero
                        REG_EXPAND_SZ ,       // value type
                        (LPBYTE) valuebuf ,   // address of value data
                        strlen( valuebuf ) + 1 ) )
        return FAILURE ;
    dwData = EVENTLOG_ERROR_TYPE |
             EVENTLOG_WARNING_TYPE |
             EVENTLOG_INFORMATION_TYPE ;
    if ( RegSetValueEx( hkey ,
                        "TypesSupported" ,    // Value name
                        0 ,                   // must be zero
                        REG_DWORD ,           // value type
                        (LPBYTE)&dwData ,     // address of value data
                        sizeof( DWORD ) ) )   // length of value data
        return FAILURE ;
    RegCloseKey( hkey ) ;

    //
    //  USER'S INITIALIZATION CODE HERE.
    //

    /* 
    ||=============================================================
    || NOTE: Order of these initialization is important!
    ||       Some later inits may depend on earlier inits
    ||       ..see below
    ||=============================================================
    */


    /* HRSYSTEM DEPENDS:
    |  =================
    |   hrSystem Table has no cache, but the value of 
    |   "HrSystemInitialLoadDevice" depends on the hrDevice table having been
    |   initialized.
    */


    /* HRSTORAGE DEPENDS:
    |  =================
    |   None.
    */
    if (Gen_Hrstorage_Cache() == FALSE)      { return FAILURE ; }


    /* HRFSTABLE DEPENDS:
    |  =================
    |   The HRSTORAGE cache is searched in order to set the value of
    |   all "hrFSStorageIndex" attributes.
    */
    if (Gen_HrFSTable_Cache() == FALSE)      { return FAILURE ; }


    /* HRDEVICE DEPENDS:
    |  =================
    |   The HRFSTABLE cache is searched in order to set the values for
    |   "hrPartitionFSIndex" attributes in the hrPartition sub-table of
    |   the hrdevice table.
    |
    | Debugging Note:
    |  If you temporarily "no-op" the next line (and trigger the
    |  actual invocation of this cache build function from, say,
    |  function "SetHrStorageSize()" by sending a "SET" of that variable),
    |  you also need to "no-op" the invocation of "TrapInit()" below,
    |  otherwise the subagent will trap when the hrProcessorLoad timer
    |  (set-up by "TrapInit()" below) goes off.
    */
    if (Gen_HrDevice_Cache() == FALSE)       { return FAILURE ; }


    /* HRSWINSTALLED DEPENDS:
    |  ======================
    |   None.
    */
    if (Gen_HrSWInstalled_Cache() == FALSE)  { return FAILURE ; }


    /* HRSWRUN/PERF DEPENDS:
    |  =====================
    |   None.  This function is called repeatedly to refresh the cache
    |   at intervals of CACHE_MAX_AGE (defined in "HRSWRUNE.C").
    */
    if (Gen_HrSWRun_Cache() == FALSE)        { return FAILURE ; }


    /*
    | This "TrapInit" processing is deferred until after Gen_HrDevice_Cache()
    | processing has been done.
    |
    | Because no traps are defined by HostMIB, we use the mechanism
    | (by which the main SNMP agent "polls" for Traps when an event goes off)
    | to actually cause the HostMIB subagent to be periodically entered so
    | that timer-counts needed to accurately report "hrProcessorLoad"
    | values for each CPU may be refreshed.
    |
    | The hrProcessor sub-table initialization is performed as part of
    | hrDevice table init.  Buffer initialization for hrProcessorLoad is done
    | as part of this initialization and must be complete before we do this
    | "TrapInit()" call.
    |
    | "TrapInit()" in reality sets up the timer handle returned as 
    | "hPollForTrapEvent".  The function that is entered when the timer 
    | goes off ("hrProcessLoad_Refresh()" in "HRPROCES.C") expects the 
    | buffer initialization to have already been performed... hence the 
    | call to "TrapInit()" must follow other cache initialization.
    */    
    TrapInit( hPollForTrapEvent ) ;

    return SUCCESS ;

} /* end of UserMibInit() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\smint.h ===
/* smint.h  v0.10
// Copyright (C) 1992-1995, All Rights Reserved, by
// Digital Equipment Corporation, Maynard, Mass.
//
// This software is furnished under a license and may be used and copied
// only  in  accordance  with  the  terms  of such  license and with the
// inclusion of the above copyright notice. This software or  any  other
// copies thereof may not be provided or otherwise made available to any
// other person. No title to and ownership of  the  software  is  hereby
// transferred.
//
// The information in this software is subject to change without  notice
// and  should  not be  construed  as  a commitment by Digital Equipment
// Corporation.
//
// Digital assumes no responsibility for the use or  reliability  of its
// software on equipment which is not supplied by Digital.
*/

/*
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains the native data type definitions.  This file
 *    is taken from the Calaveras Project's system management work done by
 *    Wayne Duso.  By using these native data types (Structure of Management
 *    Information (SMI)) it is intended to align the management APIs on
 *    the Windows NT and UNIX platforms as closely as possible.
 */


#if !defined(_SMINT_H_)
#define _SMINT_H_ 

#if !defined(lint) && defined(INCLUDE_ALL_RCSID)
static char smitydef_h_rcsid[] = "$Header: /calsrv/usr/cal10/duso/calaveras/RCS/smint.h,v 1.6 1993/08/13 15:29:49 duso Exp $";
#endif



/*
// FACILITY:
//
// Calaveras System Management
//
// ABSTRACT:
//
// Structure Of Management Information (SMI) support. Specifically, type 
// declarations targeted for Management Agent use.
//
// AUTHORS:
//
// Wayne W. Duso
//
// CREATION DATE:
// 
// 25-November-1992 
//
// MODIFICATION HISTORY:
//
// $Log: smitydef.h,v $
 * Revision 1.7  1994/03/23  14:02:00  miriam
 * Modifications for Windows NT platform
 *
 * Revision 1.6  1993/08/13  15:29:49  duso
 * Housekeeping.
 *
 * Revision 1.5  1993/03/11  21:26:51  duso
 * Modify interface types to reflect CA X1.1.1 changes.
 *
 * Revision 1.4  1993/03/10  17:36:26  duso
 * Fix free bug resulting from using MOSS to create opaque structures and not
 * using MOSS to free said structures. Manipulation of MOSS opaque structures
 * now done using MOSS supplied routines exclusively. In the spirit of
 * providing opaque types with a 'complete' API, a create() operations has been
 * added to each SMI supported type.
 *
 * Revision 1.3  1993/02/22  18:12:58  duso
 * Support for all SNMP SMI types now in place. Also exclusive copy passed from
 * avlToLocal; not reference copy. This 'inefficiency' was needed to support
 * structure types (length, value). Said types could not be mutated from an
 * avl octet to their true form using references.
 *
 * Revision 1.2  1993/01/28  21:45:24  duso
 * Major clean up and completion to support SNMP centered MOMStub and class
 * Simple test MOC.
*/



/*
// TABLE OF CONTENTS
//
//  Associated Documents
//
//  Usage/Design Notes
//
//  Include Files
//
//  SMI Supported Types (typedef(s))
//      BIDT_ENUMERATION
//      ConstructionStart
//      ConstructionEnd
//      Counter
//      Gauge
//      Integer
//      IpAddress
//      Null
//      ObjectIdentifier
//      OctetString
//      Opaque
//      TimeTicks
*/


/*
// Associated Documents
//
// [1]  Calaveras Managed Object Module Framework Design Specification
// [2]  smidbty.h: Declares the pseudo abstract base psuedo class DtEntry and 
//      its API.
// [3]  smitypes.h: Declares actual instances of DtEntry, one for each typed
//      delcared in this file.
*/          


/*
// Usage/Design Notes
//
//  1.  Each type declared in this file has an accompanying API. The APIs
//      are declared in [2,3]. It is strongly recommended that type instances
//      be accessed through their API, not through direct manipulation of 
//      their internal format [NB: Additional operations must be added to the
//      API set to make the type's concrete/indiginous-like. Specifically,
//      there currently is no 'compare' interface; this must/will be corrected].
//   
//  2.  For each SMI type supported - those being any type defined by either 
//      RFC 1155 or by additions to said RFC accepted by the IETF - there is a 
//      typedef defining its 'in-memory' or 'local' representation. This 
//      information is made available to the SMI type database, the managed 
//      object module stub, and managed object classes (management agents) 
//      through this module.
*/   


/*
// Include Files
*/

#include <snmp.h>


 

/*
// SMI Supported Types (typedef(s))
*/
typedef enum
{
    nsm_true = 1 ,
    nsm_false = 2
} NSM_Boolean ;


typedef int BIDT_ENUMERATION;
/*  Signed 32 bit integer is the base data construct used by the MIR to 
//  represent integer enumerations.
*/


typedef unsigned long int Counter;
/*  Unsigned 32 bit integer is the base data construct.
*/


typedef unsigned long int Gauge;
/*  Unsigned 32 bit integer is the base data construct.
*/


typedef int Integer;
/*  Signed 32 bit integer is the base data construct.
*/


typedef unsigned long int IpAddress;
/*  Unsigned 32 bit integer is the base data construct. Interpret as
//  a 4 octet hex value.
*/


typedef char Null;
/*  The semantics of Null are that it should always be a 0 constant.
*/


typedef AsnObjectIdentifier ObjectIdentifier;
/*  
//  Aggregate type: Note that this is typedef to the Windows NT's version
//  of an object identifier to enable use with the Windows NT SNMP routines.
//  The Common Agent's MOSS library is not available for use on Windows NT.
//
//  The fields for the object identifier are:
//	UINT idLength ;		// number of integers in the oid's int array
//	UINT *ids ;		// address of the oid's int array
*/


typedef struct
/*  
//  This one is used to minimize differences across platforms and because
//  Windows NT has no support routines for manipulating an octet string.
//  Should that change consideration should be given to using the native
//  for as the Common Agent is not available on Windows NT.
//  Aggregate type: Note that this is structured exactly as the CA MOSS 
//  definition octet_string found in moss.h. As such, it should either be
//  removed in favor of that definition or its synchronization must be 
//  ensured.
*/
{
    int length;                 /* length of string */
    unsigned long int dataType; /* ASN.1 data type tag (currently optional)*/
    char* string;               /* pointer to counted string */
} OctetString;


typedef struct
/*  
//  Aggregate type
*/
{
    int length;     /* length of string */
    char* string;   /* pointer to counted entity */
} Opaque;


typedef unsigned long int TimeTicks;
/*  Unsigned 32 bit integer is the base data construct.
*/

typedef OctetString Simple_DisplayString ;
/* Included here as oppose to in the simpleema.hxx file on Calaveras to
// reduce the number of header files.
*/

typedef int Access_Credential ;
/* This is a dummy place holder for use in the future
*/

typedef struct 
{
    unsigned int count ;  /* number of identifying variables for an instance */
    char **array ;        /* array of pointers to variables' data */
} InstanceName ;
/* This is a flexible structure for passing the ordered native datatypes
// that compose the instance name.  For example,
//    tcpConnEntry from RFC 1213 p. 49 (MIB-II) is identified by
//
//	INDEX {
//		tcpConnLocalAddress,
//		tcpConnLocalPort,
//		tcpConnRemAddress,
//		tcpConnRemPort
//	      }
//
// The instance name would be an ordered set :
//
//	count = 4
//	array[ 0 ] = address of an IP Address (the local ip address)
//	array[ 1 ] = address of an Integer (the local port)
//	array[ 2 ] = address of an IP Address (the remote ip address)
//	array[ 3 ] = address of an Integer (the remote port)
*/

#define MAX_OCTET_STRING 256

UINT
SMIGetInteger( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMIGetNSMBoolean( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMIGetBIDTEnum( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance );
UINT
SMIGetOctetString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                   IN unsigned long int cindex ,
                   IN unsigned long int vindex ,
                   IN InstanceName *instance );
UINT
SMIGetObjectId( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance );
UINT
SMIGetCounter( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMIGetGauge( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
             IN unsigned long int cindex ,
             IN unsigned long int vindex ,
             IN InstanceName *instance );
UINT
SMIGetTimeTicks( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance );
UINT
SMIGetIpAddress( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance );
UINT
SMIGetDispString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                  IN unsigned long int cindex ,
                  IN unsigned long int vindex ,
                  IN InstanceName *instance );
UINT
SMISetInteger( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMISetNSMBoolean( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMISetBIDTEnum( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMISetOctetString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                   IN unsigned long int cindex ,
                   IN unsigned long int vindex ,
                   IN InstanceName *instance );
UINT
SMISetObjectId( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance );
UINT
SMISetCounter( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance );
UINT
SMISetGauge( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
             IN unsigned long int cindex ,
             IN unsigned long int vindex ,
             IN InstanceName *instance );
UINT
SMISetTimeTicks( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance );
UINT
SMISetIpAddress( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance );
UINT
SMISetDispString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                  IN unsigned long int cindex ,
                  IN unsigned long int vindex ,
                  IN InstanceName *instance );
UINT
SMIBuildInteger( IN OUT RFC1157VarBind *VarBind ,
                 IN char *invalue );
UINT
SMIBuildOctetString( IN OUT RFC1157VarBind *VarBind ,
                     IN char *invalue );
UINT
SMIBuildObjectId( IN OUT RFC1157VarBind *VarBind ,
                  IN char *invalue );
UINT
SMIBuildCounter( IN OUT RFC1157VarBind *VarBind ,
                 IN char *invalue );
UINT
SMIBuildGauge( IN OUT RFC1157VarBind *VarBind ,
               IN char *invalue );
UINT
SMIBuildTimeTicks( IN OUT RFC1157VarBind *VarBind ,
                   IN char *invalue );
UINT
SMIBuildIpAddress( IN OUT RFC1157VarBind *VarBind ,
                   IN char *invalue );
UINT
SMIBuildDispString( IN OUT RFC1157VarBind *VarBind ,
                    IN char *invalue );
void
SMIFree( IN AsnAny *invalue );

#endif  /*_SMINT_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\smint.c ===
/*
 *  smint.c v0.12  Mar 12 1996
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995, 1996 DIGITAL EQUIPMENT CORPORATION              *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module contains the SMI envelopes around the callout to the user's
 *    get and set routines.
 *
 *        SMIGetInteger
 *        SMIGetNSMBoolean
 *        SMIGetBIDTEnum
 *        SMIGetOctetString
 *        SMIGetObjectId
 *        SMIGetCounter
 *        SMIGetGauge
 *        SMIGetTimeTicks
 *        SMIGetIpAddress
 *        SMIGetDispString
 *        SMISetInteger
 *        SMISetNSMBoolean
 *        SMISetBIDTEnum
 *        SMISetOctetString
 *        SMISetObjectId
 *        SMISetCounter
 *        SMISetGauge
 *        SMISetTimeTicks
 *        SMISetIpAddress
 *        SMISetDispString
 *        SMIBuildInteger
 *        SMIBuildDIDTEnum
 *        SMIBuildOctetString
 *        SMIBuildObjectId
 *        SMIBuildCounter
 *        SMIBuildGauge
 *        SMIBuildTimeTicks
 *        SMIBuildIpAddress
 *        SMIBuildDispString
 *        SMIFree
 *
 *  Author:
 *     Wayne Duso, Miriam Amos Nihart, Kathy Faust
 *
 *  Date:
 *     2/17/95
 *
 *  Revision History:
 *  v0.1   Jul 20 95     AGS  Added SMIGet/SetBoolean
 *  v0.11  Feb 14 1996   AGS  changed SMIGet/SetBoolean to SMIGet/SetNSMBoolean
 *  v0.12  Mar 12, 1996  KKF  set outvalue.length to 256 for SMISetOctetString,
 *                            SMISetDispString so that instrumentation code knows
 *                            max length of buffer.
 *  v0.13  May 15, 1997  DDB  To Microsoft: 6 changes of "malloc" to
 *                              "SNMP_malloc"
 */


// Necessary includes.

#include <snmp.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>

#include "mib.h"
#include "mib_xtrn.h"
#include "smint.h"        // Wayne's type def file



/*
 *  SMIGetInteger
 *
 *    Encompasses the callouts to variables of the data type INTEGER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetInteger( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Integer outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;

    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number = (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetInteger() */



/*
 *  SMIGetNSMBoolean
 *
 *    Encompasses the callouts to variables of the data type Boolean.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *    In SNMPv1  true = 1 AND false = 2
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetNSMBoolean( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    NSM_Boolean outvalue ;	  // nsm_true = 1, nsm_false = 2
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;

    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number = (AsnInteger)outvalue ;
    }
    return result ;

} /* end of SMIGetNSMBoolean() */




/*
 *  SMIGetBIDTEnum
 *
 *    Encompasses the callouts to variables of the data type INTEGER that
 *    are enumerated.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetBIDTEnum( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    BIDT_ENUMERATION outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;

    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_INTEGER ;
        VarBind->value.asnValue.number = (AsnInteger)outvalue ;
    }
    return result ;

}  /* end of SMIGetBIDTEnum() */





/*
 *  SMIGetOctetString
 *
 *    Encompasses the callouts to variables of the data type OCTET STRING.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetOctetString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                   IN unsigned long int cindex ,
                   IN unsigned long int vindex ,
                   IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    OctetString outvalue ;
    char stream[ MAX_OCTET_STRING ] ;
    Access_Credential access ;    // dummy holder for future use

    outvalue.string = stream ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;

    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnValue.string.length = outvalue.length ;
        VarBind->value.asnValue.string.stream =
//            malloc( outvalue.length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
            SNMP_malloc( outvalue.length * sizeof( char ) ) ;
        if ( VarBind->value.asnValue.string.stream == NULL )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            memcpy( VarBind->value.asnValue.string.stream ,
                    outvalue.string ,
                    outvalue.length ) ;
            VarBind->value.asnType =  ASN_OCTETSTRING ;
            VarBind->value.asnValue.string.dynamic = TRUE ;
        }
    }
    return result ;

}  /* end of SMIGetOctetString() */




/*
 *  SMIGetObjectId
 *
 *    Encompasses the callouts to variables of the data type OBJECT IDENTIFIER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetObjectId( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    UINT status ;
    ObjectIdentifier outvalue ;
    Access_Credential access ;    // dummy holder for future use

    memset( &outvalue, '\0', sizeof( ObjectIdentifier ) ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        status = SNMP_oidcpy( &VarBind->value.asnValue.object, &outvalue ) ;
        if ( outvalue.idLength != 0 )
            SNMP_free( outvalue.ids ) ;
        if ( !status )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            VarBind->value.asnType = ASN_OBJECTIDENTIFIER ;
        }
    }
    return result ;

}  /* end of SMIGetObjectId() */




/*
 *  SMIGetCounter
 *
 *    Encompasses the callouts to variables of the data type COUNTER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetCounter( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Counter outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_RFC1155_COUNTER ;
        VarBind->value.asnValue.counter = outvalue ;
    }
    return result ;

}  /* end of SMIGetCounter() */




/*
 *  SMIGetGauge
 *
 *    Encompasses the callouts to variables of the data type GAUGE.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetGauge( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
             IN unsigned long int cindex ,
             IN unsigned long int vindex ,
             IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Gauge outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_RFC1155_GAUGE ;
        VarBind->value.asnValue.gauge = outvalue ;
    }
    return result ;

}  /* end of SMIGetGauge() */




/*
 *  SMIGetTimeTicks
 *
 *    Encompasses the callouts to variables of the data type TIMETICKS.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetTimeTicks( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    TimeTicks outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnType = ASN_RFC1155_TIMETICKS ;
        VarBind->value.asnValue.ticks = outvalue ;
    }
    return result ;

}  /* end of SMIGetTimeTicks() */




/*
 *  SMIGetIpAddress
 *
 *    Encompasses the callouts to variables of the data type IP ADDRESS.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetIpAddress( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    IpAddress outvalue ;
    Access_Credential access ;    // dummy holder for future use

    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnValue.address.length = 4 ;
//        VarBind->value.asnValue.address.stream = malloc( 4 * sizeof( char ) ) ;
// Changed 5/15/97 DDB
        VarBind->value.asnValue.address.stream = SNMP_malloc( 4 * sizeof( char ) ) ;
        if ( VarBind->value.asnValue.address.stream == NULL )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            memcpy( VarBind->value.asnValue.address.stream ,
                    (BYTE *)(&outvalue),
                    4 ) ;
            VarBind->value.asnType = ASN_RFC1155_IPADDRESS ;
            VarBind->value.asnValue.address.dynamic = TRUE ;
        }
    }
    return result ;

}  /* end of SMIGetIpAddress() */



/*
 *  SMIGetDispString
 *
 *    Encompasses the callouts to variables of the data type DISPLAY STRING.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIGetDispString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for get
                  IN unsigned long int cindex ,
                  IN unsigned long int vindex ,
                  IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Simple_DisplayString outvalue ;
    char stream[ MAX_OCTET_STRING ] ;
    Access_Credential access ;    // dummy holder for future use

    outvalue.string = stream ;
    outvalue.length = 0 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarGet )( &outvalue ,
                                                                  &access ,
                                                                  instance ) ;
    if ( result == SNMP_ERRORSTATUS_NOERROR )
    {
        VarBind->value.asnValue.string.length = outvalue.length ;
        VarBind->value.asnValue.string.stream =
//            malloc( outvalue.length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
            SNMP_malloc( outvalue.length * sizeof( char ) ) ;
        if ( VarBind->value.asnValue.string.stream == NULL )
            result = SNMP_ERRORSTATUS_GENERR ;
        else
        {
            memcpy( VarBind->value.asnValue.string.stream ,
                    outvalue.string ,
                    VarBind->value.asnValue.string.length ) ;
            VarBind->value.asnType = ASN_RFC1213_DISPSTRING ;
            VarBind->value.asnValue.string.dynamic = TRUE ;
        }
    }
    return result ;

}  /* end of SMIGetDispString() */




/*
 *  SMISetInteger
 *
 *    Encompasses the callouts to variables of the data type INTEGER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetInteger( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Integer *invalue ;
    Integer outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (Integer *)( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetInteger() */




/*
 *  SMISetNSMBoolean
 *
 *    Encompasses the callouts to variables of the data type Boolean
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *    In SNMPv1  true = 1 AND false = 2
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetNSMBoolean( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    NSM_Boolean *invalue ;        // nsm_true = 1, nsm_false = 2
    NSM_Boolean outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (NSM_Boolean *)( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetNSMBoolean() */




/*
 *  SMISetBIDTEmun
 *
 *    Encompasses the callouts to variables of the data type INTEGER that
 *    is enumerated.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetBIDTEnum( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    BIDT_ENUMERATION *invalue ;
    BIDT_ENUMERATION outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (BIDT_ENUMERATION *)( &VarBind->value.asnValue.number ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetBIDTEnum() */





/*
 *  SMISetOctetString
 *
 *    Encompasses the callouts to variables of the data type OCTET STRING.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetOctetString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                   IN unsigned long int cindex ,
                   IN unsigned long int vindex ,
                   IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    OctetString invalue ;
    OctetString outvalue ;
    char out_stream[ MAX_OCTET_STRING ] ;
    AsnOctetString *tmp ;
    Access_Credential access ;    // dummy holder for future use

    tmp = &VarBind->value.asnValue.string ;
    invalue.length = tmp->length ;
    invalue.string = tmp->stream ;
    outvalue.string = out_stream ;
    outvalue.length = 256 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( &invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetOctetString() */




/*
 *  SMISetObjectId
 *
 *    Encompasses the callouts to variables of the data type OBJECT IDENTIFIER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetObjectId( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                IN unsigned long int cindex ,
                IN unsigned long int vindex ,
                IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    ObjectIdentifier *invalue ;
    ObjectIdentifier outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = &VarBind->value.asnValue.object ;
    memset( &outvalue, '\0', sizeof ( ObjectIdentifier ) ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    if ( outvalue.idLength != 0 )
		SNMP_free( outvalue.ids ) ;

    return result ;

}  /* end of SMISetObjectId() */




/*
 *  SMISetCounter
 *
 *    Encompasses the callouts to variables of the data type COUNTER.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetCounter( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
               IN unsigned long int cindex ,
               IN unsigned long int vindex ,
               IN InstanceName *instance )

{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Counter *invalue ;
    Counter outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (Counter *)( &VarBind->value.asnValue.counter ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetCounter() */



/*
 *  SMISetGauge
 *
 *    Encompasses the callouts to variables of the data type GAUGE.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetGauge( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
             IN unsigned long int cindex ,
             IN unsigned long int vindex ,
             IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Gauge *invalue ;
    Gauge outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (Gauge *)( &VarBind->value.asnValue.gauge ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetGauge() */



/*
 *  SMISetTimeTicks
 *
 *    Encompasses the callouts to variables of the data type TIMETICKS.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetTimeTicks( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    TimeTicks *invalue ;
    TimeTicks outvalue ;
    Access_Credential access ;    // dummy holder for future use

    invalue = (TimeTicks *)( &VarBind->value.asnValue.ticks ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( invalue , &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetTimeTicks() */




/*
 *  SMISetIpAddress
 *
 *    Encompasses the callouts to variables of the data type IP ADDRESS.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetIpAddress( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                 IN unsigned long int cindex ,
                 IN unsigned long int vindex ,
                 IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    IpAddress invalue ;
    IpAddress outvalue ;
    Access_Credential access ;    // dummy holder for future use

    memcpy( &invalue, VarBind->value.asnValue.address.stream , 4 ) ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( &invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetIpAddress() */



/*
 *  SMISetDispString
 *
 *    Encompasses the callouts to variables of the data type DISPLAY STRING.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    cindex                     index to the class of the request
 *    vindex                     index to the variable of the request
 *    instance                   address of the instance specification in the
 *                               form of ordered native datatypes
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMISetDispString( IN OUT RFC1157VarBind *VarBind ,  // Variable Binding for set
                  IN unsigned long int cindex ,
                  IN unsigned long int vindex ,
                  IN InstanceName *instance )
{
    UINT result = SNMP_ERRORSTATUS_NOERROR ;
    Simple_DisplayString invalue ;
    Simple_DisplayString outvalue ;
    char out_stream[ MAX_OCTET_STRING ] ;
    AsnOctetString *tmp ;
    Access_Credential access ;    // dummy holder for future use

    tmp = &VarBind->value.asnValue.string ;
    invalue.length = tmp->length ;
    invalue.string = tmp->stream ;
    outvalue.string = out_stream ;
    outvalue.length = 256 ;
    result = ( *class_info[ cindex ].variable[ vindex ].VarSet )
             ( &invalue, &outvalue, &access, instance ) ;
    return result ;

}  /* end of SMISetDispString() */




/*
 *  SMIBuildInteger
 *
 *    Places the variable of datatype INTEGER into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                     address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildInteger( IN OUT RFC1157VarBind *VarBind ,
                 IN char *invalue )

{
    Integer *svalue = (Integer *)invalue ;
    VarBind->value.asnType = ASN_INTEGER ;
    VarBind->value.asnValue.number = *svalue ;

    return SNMP_ERRORSTATUS_NOERROR ;

}  /* end of SMIBuildInteger() */




/*
 *  SMIBuildOctetString
 *
 *    Places the variable of datatype OCTET STRING into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                    address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildOctetString( IN OUT RFC1157VarBind *VarBind ,
                     IN char *invalue )

{
    OctetString *svalue = (OctetString *)invalue ;

    UINT status = SNMP_ERRORSTATUS_NOERROR ;

    VarBind->value.asnValue.string.length = svalue->length ;
    VarBind->value.asnValue.string.stream =
//        malloc( svalue->length * sizeof( char ) ) ;
// Changed 5/15/97 DDB
        SNMP_malloc( svalue->length * sizeof( char ) ) ;
    if ( VarBind->value.asnValue.string.stream == NULL )
        status = SNMP_ERRORSTATUS_GENERR ;
    else
    {
        memcpy( VarBind->value.asnValue.string.stream ,
                svalue->string ,
                svalue->length ) ;
        VarBind->value.asnType =  ASN_OCTETSTRING ;
        VarBind->value.asnValue.string.dynamic = TRUE ;
    }
    return status ;

}  /* end of SMIBuildOctetString() */




/*
 *  SMIBuildObjectId
 *
 *    Places the variable of datatype OBJECT IDENTIFIER into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                    address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildObjectId( IN OUT RFC1157VarBind *VarBind ,
                  IN char *invalue )


{
    ObjectIdentifier *svalue = (ObjectIdentifier *)invalue ;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;
    UINT sts = TRUE ;

    sts = SNMP_oidcpy( &VarBind->value.asnValue.object ,
                       (AsnObjectIdentifier *)svalue ) ;
    if ( !sts )
        status = SNMP_ERRORSTATUS_GENERR ;
    else
        VarBind->value.asnType = ASN_OBJECTIDENTIFIER ;

    return status ;

}  /* end of SMIBuildObjectId() */




/*
 *  SMIBuildCounter
 *
 *    Places the variable of datatype COUNTER into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                    address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildCounter( IN OUT RFC1157VarBind *VarBind ,
                 IN char *invalue )

{
    Counter *svalue = (Counter *)invalue ;
    VarBind->value.asnType = ASN_RFC1155_COUNTER ;
    VarBind->value.asnValue.counter = *svalue ;

    return SNMP_ERRORSTATUS_NOERROR ;

}  /* end of SMIBuildCounter() */




/*
 *  SMIBuildGauge
 *
 *    Places the variable of datatype GAUGE into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    svalue                     address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildGauge( IN OUT RFC1157VarBind *VarBind ,
               IN char *invalue )

{
    Gauge *svalue = (Gauge *)invalue ;
    VarBind->value.asnType = ASN_RFC1155_GAUGE ;
    VarBind->value.asnValue.gauge = *svalue ;

    return SNMP_ERRORSTATUS_NOERROR ;

}  /* end of SMIBuildGauge() */




/*
 *  SMIBuildTimeTicks
 *
 *    Places the variable of datatype TIME TICKS into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                    address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildTimeTicks( IN OUT RFC1157VarBind *VarBind ,
                   IN char *invalue )

{
    TimeTicks *svalue = (TimeTicks *)invalue ;
    VarBind->value.asnType = ASN_RFC1155_TIMETICKS ;
    VarBind->value.asnValue.ticks = *svalue ;

    return SNMP_ERRORSTATUS_NOERROR ;

}  /* end of SMIBuildTimeTicks() */




/*
 *  SMIBuildIpAddress
 *
 *    Places the variable of datatype IpAddress into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                    address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildIpAddress( IN OUT RFC1157VarBind *VarBind ,
                   IN char *invalue )

{
    IpAddress *svalue = (IpAddress *)invalue;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;

    VarBind->value.asnValue.address.stream = SNMP_malloc( 4 * sizeof( char ) ) ;
    if ( VarBind->value.asnValue.address.stream == NULL )
        status = SNMP_ERRORSTATUS_GENERR ;
    else
    {
        memcpy( VarBind->value.asnValue.address.stream, (BYTE *)svalue, 4 ) ;
        VarBind->value.asnValue.address.length = 4 ;
        VarBind->value.asnType = ASN_RFC1155_IPADDRESS ;
        VarBind->value.asnValue.address.dynamic = TRUE ;
    }
    return status ;

}  /* end of SMIBuildIpAddress() */



/*
 *  SMIBuildDispString
 *
 *    Places the variable of datatype DISPLAY STRING into a Variable Binding.
 *
 *  Arguments:
 *
 *    VarBind                    pointer to the variable value pair
 *    invalue                     address of the data
 *
 *  Return Codes:
 *
 *    Standard PDU error codes.
 *
 */

UINT
SMIBuildDispString( IN OUT RFC1157VarBind *VarBind ,
                    IN char *invalue )

{
    Simple_DisplayString *svalue = (Simple_DisplayString *)invalue;
    UINT status = SNMP_ERRORSTATUS_NOERROR ;

    
    VarBind->value.asnValue.string.stream =
        SNMP_malloc( svalue->length * sizeof( char ) ) ;
    if ( VarBind->value.asnValue.string.stream == NULL )
        status = SNMP_ERRORSTATUS_GENERR ;
    else
    {
        memcpy( VarBind->value.asnValue.string.stream ,
                svalue->string ,
                svalue->length ) ;
        VarBind->value.asnValue.string.length = svalue->length ;
        VarBind->value.asnType = ASN_RFC1213_DISPSTRING ;
        VarBind->value.asnValue.string.dynamic = TRUE ;
    }
    return status ;

}  /* end of SMIBuildDispString() */

/* end of smi.c */


/*  SMIFree
 *
 *    Free the variable
 *
 *  Arguments:
 *
 *    invalue                     address of data
 *
 *  Return Codes:
 *
 *
 */

void
SMIFree( IN AsnAny *invalue )

{
    switch (invalue->asnType) {

        case ASN_OCTETSTRING:
        case ASN_RFC1155_IPADDRESS:
            if (invalue->asnValue.string.length != 0) {
                invalue->asnValue.string.length = 0 ;
                SNMP_free(invalue->asnValue.string.stream) ;
            }
        break;

        case ASN_OBJECTIDENTIFIER:
            if (invalue->asnValue.object.idLength != 0) {
                invalue->asnValue.object.idLength = 0;
                SNMP_free(invalue->asnValue.object.ids) ;
            }
            break ;

        default:
            break ;
    }
}  /* end of SMIFree */

/* end of smi.c */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\user.h ===
/*
 *  user.h v0.10
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    Windows NT SNMP Extension Agent
 *
 *  Abstract:
 *
 *    This module is a spane holder for user definitions.
 *
 *  Author:
 *
 *    D. D. Burns @ WebEnable, Inc.
 *
 *
 *  Revision History:
 *
 *    V1.0 - 04/16/97  D. D. Burns     Original Creation
 */

#ifndef user_h
#define user_h

/*
| USER.C - Function Prototypes
*/

/* Spt_GetProcessCount - Retrieve count of number of active processes */
ULONG
Spt_GetProcessCount(
                    void
                    );

/* PartitionTypeToLastArc - Convert Partition Type to Last OID Arc value */
ULONG
PartitionTypeToLastArc (
                        BYTE p_type
                        );                      /* Located in "HRFSENTR.C" */

#endif /* user_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\dlog_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    dlog_tbl.h

Abstract:

    Define all of the structures and routines used in the domain logon list
    table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef dlog_tbl_h
#define dlog_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define DLOG_USER_FIELD        1
#define DLOG_MACHINE_FIELD     2

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the domain logon table
typedef struct dom_logon_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString domLogonUser;    // Index
	   AsnDisplayString domLogonMachine; // Index
	   } DOM_LOGON_ENTRY;

   // Domain logon table definition
typedef struct
           {
	   UINT            Len;
	   DOM_LOGON_ENTRY *Table;
           } DOM_LOGON_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern DOM_LOGON_TABLE  MIB_DomLogonTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_dlogons_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* dlog_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\dlog_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    dlog_lm.c

Abstract:

    This file contains MIB_dlog_lmget, which actually call lan manager
    for the dloge table, copies it into structures, and sorts it to
    return ready to use by the higher level functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <string.h>
#include <search.h>
#include <stdlib.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include "mib.h"
#include "mibfuncs.h"
#include "dlog_tbl.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

int dlog_entry_cmp(
       IN DOM_LOGON_ENTRY *A,
       IN DOM_LOGON_ENTRY *B
       ) ;

void build_dlog_entry_oids( );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_dlog_lmget
//    Retrieve dlogion table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_dlogons_lmget(
	   )

{
SNMPAPI nResult = SNMPAPI_NOERROR;
#if 0
DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
SHARE_INFO_2 *DataTable;
DOM_LOGON_ENTRY *MIB_DomLogonTableElement ;
int First_of_this_block;
DWORD resumehandle=0;

   //
   //
   // If cached, return piece of info.
   //
   //

   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //

   // free the old table  LOOK OUT!!
   	
   // init the length
   MIB_DomLogonTable.Len = 0;
   First_of_this_block = 0;
   	
   do {  //  as long as there is more data to process

	lmCode =
    	NetShareEnum(NULL,          // local server
                2,                  // level 2,
                &bufptr,            // data structure to return
                MAX_PREFERRED_LENGTH,
                &entriesread,
                &totalentries,
                &resumehandle       //  resume handle
                );

        //
        // Filter out all the Admin shares (name ending with $).
        //
        AdminFilter(2,&entriesread,bufptr);


    DataTable = (SHARE_INFO_2 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
    	{  // valid so process it, otherwise error
   	
   	if(0 == MIB_DomLogonTable.Len) {  // 1st time, alloc the whole table
   		// alloc the table space
                MIB_DomLogonTable.Table = SnmpUtilMemAlloc(totalentries *
   						sizeof(DOM_LOGON_ENTRY) );
   	}
	
	MIB_DomLogonTableElement = MIB_DomLogonTable.Table + First_of_this_block ;
	
   	for(i=0; i<entriesread; i++) {  // once for each entry in the buffer
   		// increment the entry number
   		
   		MIB_DomLogonTable.Len ++;
   		
   		// Stuff the data into each item in the table
   		
   		// dloge name
                MIB_DomLogonTableElement->svShareName.stream = SnmpUtilMemAlloc (
   				strlen( DataTable->shi2_netname ) ) ;
   		MIB_DomLogonTableElement->svShareName.length =
   				strlen( DataTable->shi2_netname ) ;
		MIB_DomLogonTableElement->svShareName.dynamic = TRUE;
   		memcpy(	MIB_DomLogonTableElement->svShareName.stream,
   			DataTable->shi2_netname,
   			strlen( DataTable->shi2_netname ) ) ;
   		
   		// Share Path
                MIB_DomLogonTableElement->svSharePath.stream = SnmpUtilMemAlloc (
   				strlen( DataTable->shi2_path ) ) ;
   		MIB_DomLogonTableElement->svSharePath.length =
   				strlen( DataTable->shi2_path ) ;
		MIB_DomLogonTableElement->svSharePath.dynamic = TRUE;
   		memcpy(	MIB_DomLogonTableElement->svSharePath.stream,
   			DataTable->shi2_path,
   			strlen( DataTable->shi2_path ) ) ;
   		
   		
   		// Share Comment/Remark
                MIB_DomLogonTableElement->svShareComment.stream = SnmpUtilMemAlloc (
   				strlen( DataTable->shi2_remark ) ) ;
   		MIB_DomLogonTableElement->svShareComment.length =
   				strlen( DataTable->shi2_remark ) ;
		MIB_DomLogonTableElement->svShareComment.dynamic = TRUE;
   		memcpy(	MIB_DomLogonTableElement->svShareComment.stream,
   			DataTable->shi2_remark,
   			strlen( DataTable->shi2_remark ) ) ;
   		
   		
   		DataTable ++ ;  // advance pointer to next dlog entry in buffer
		MIB_DomLogonTableElement ++ ;  // and table entry
		
   	} // for each entry in the data table
   	
   	// indicate where to start adding on next pass, if any
   	First_of_this_block = i ;
   	
       	} // if data is valid to process
    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    build_dlog_entry_oids();

   // Sort the table information using MSC QuickSort routine
   qsort( &MIB_DomLogonTable.Table[0], MIB_DomLogonTable.Len,
          sizeof(DOM_LOGON_ENTRY), dlog_entry_cmp );

   //
   //
   // Cache table
   //
   //

   //
   //
   // Return piece of information requested
   //
   //

Exit:
#endif
   return nResult;

} // MIB_dlog_get

//
// MIB_dlog_cmp
//    Routine for sorting the dlogion table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int dlog_entry_cmp(
       IN DOM_LOGON_ENTRY *A,
       IN DOM_LOGON_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( &A->Oid, &B->Oid );
} // MIB_dlog_cmp


//
//    None.
//
void build_dlog_entry_oids(
       )

{
#if 0
AsnOctetString OSA ;
char StrA[MIB_SHARE_NAME_LEN];
DOM_LOGON_ENTRY *ShareEntry ;
unsigned i;

// start pointer at 1st guy in the table
ShareEntry = MIB_DomLogonTable.Table ;

// now iterate over the table, creating an oid for each entry
for( i=0; i<MIB_DomLogonTable.Len ; i++)  {
   // for each entry in the dlogion table

   // Make string to use as index
   memcpy( StrA, ShareEntry->svShareName.stream,
                 ShareEntry->svShareName.length );

   OSA.stream = StrA ;
   OSA.length =  ShareEntry->svShareName.length ;
   OSA.dynamic = FALSE;

   // Make the entry's OID from string index
   MakeOidFromStr( &OSA, &ShareEntry->Oid );

   ShareEntry++; // point to the next guy in the table

   } // for
#endif
} // build_dlog_entry_oids
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\hostmib\user.c ===
/*
 *  user.c v0.10
 *
 ****************************************************************************
 *                                                                          *
 *      (C) Copyright 1995 DIGITAL EQUIPMENT CORPORATION                    *
 *                                                                          *
 *      This  software  is  an  unpublished work protected under the        *
 *      the copyright laws of the  United  States  of  America,  all        *
 *      rights reserved.                                                    *
 *                                                                          *
 *      In the event this software is licensed for use by the United        *
 *      States Government, all use, duplication or disclosure by the        *
 *      United States Government is subject to restrictions  as  set        *
 *      forth in either subparagraph  (c)(1)(ii)  of the  Rights  in        *
 *      Technical  Data  And  Computer  Software  Clause  at   DFARS        *
 *      252.227-7013, or the Commercial Computer Software Restricted        *
 *      Rights Clause at FAR 52.221-19, whichever is applicable.            *
 *                                                                          *
 ****************************************************************************
 *
 *  Facility:
 *
 *    SNMP Extension Agent
 *
 *  Abstract:
 *  
 *    This module contains support functions for the HostMIB Subagent.
 *
 *
 *  Author:
 *
 *    D. D. Burns @ WebEnable, Inc.
 *
 *
 *  Revision History:
 *
 *    V0.01 - 04/16/97  D. D. Burns     Original Creation
 *
 *
 */




/*

|
| Support Functions accessible from outside this module:
|

Spt_GetProcessCount
    This function supports hrSystem table attribute "hrSystemProcesses"
    by returning the number of active processes in the system.  This
    code is derived from PERFDLL code in files "PERFSPRC.C" and
    "PERFPROC.C".

|
| Support Functions accessible only from inside this module:
|

*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>


/*
|| LOCAL DEFINES
*/

/*
| Spt_GetProcessCount
*/
#define INCREMENT_BUFFER_SIZE ((DWORD)(4096*2))
#define LARGE_BUFFER_SIZE   ((DWORD)(4096*16))



/* Spt_GetProcessCount - Retrieve count of number of active processes */
/* Spt_GetProcessCount - Retrieve count of number of active processes */
/* Spt_GetProcessCount - Retrieve count of number of active processes */

ULONG
Spt_GetProcessCount(
                    void
                    )
/*
|  IN SUPPORT OF:
|
|       HRSYSTEM.C - "hrSystemProcesses"
|
|  EXPLICIT INPUTS:
|
|       None.
|
|  IMPLICIT INPUTS:
|
|       System performance information is fetched thru
|       "NtQuerySystemInformation()".
|
|  OUTPUTS:
|
|     On Success:
|       Function returns the count of active processes as determined by
|       the number of performance information blocks for processes that
|       have both a name and a non-zero thread count (in the style of code in
|       "PERFPROC.C").
|
|     On any Failure:
|       Function returns zero (not a legal number of processes).
|
|  THE BIG PICTURE:
|
|       The generated function "GetHrSystemProcesses()" in HRSYSTEM.C is
|       invoked by the generic subagent to retrieve the current value of 
|       the SNMP attribute "GetHrSystemProcesses".  All the work of 
|       retrieving that value is done by this support function.
|
|  OTHER THINGS TO KNOW:
|
|       This function incurs a rather substantial bit of overhead in that
|       to determine the number of processes active it actually fetches
|       a large slug of performance data (a "slug" per process) for all
|       processes and merely counts the number of slugs returned.
|       This seems to be the only available way to acquire this information.
|
*/
{
DWORD   dwReturnedBufferSize;
NTSTATUS Status;
DWORD   ProcessBufSize = LARGE_BUFFER_SIZE;     // Initial Process-Buf size
LPBYTE  pProcessBuffer = NULL;                  // Pointer to Process-Buf
PSYSTEM_PROCESS_INFORMATION ProcessInfo;        // Walking ptr thru Process-Buf
ULONG   ProcessBufferOffset = 0;                // 
ULONG   Process_count = 0;                      // Count of Live processes


//
//  Get process data from system.
//

// Grab an initially-sized buffer to receive data
pProcessBuffer = malloc(ProcessBufSize);
if (pProcessBuffer == NULL) {
    return (0);         // Out of memory
    }

/*
| Loop until we've allocated a buffer big enough to receive all the data
| NtQuery wants to give us.
|
| Exit with the buffer loaded with info or on some kind of non-mismatch error.
*/

while( (Status = NtQuerySystemInformation(
                        SystemProcessInformation,
                        pProcessBuffer,
                        ProcessBufSize,
                        &dwReturnedBufferSize))
      == STATUS_INFO_LENGTH_MISMATCH ) {

    LPBYTE  pNewProcessBuffer;               // For use on realloc

    // expand buffer & retry
    ProcessBufSize += INCREMENT_BUFFER_SIZE;

    if ( !(pNewProcessBuffer = realloc(pProcessBuffer,ProcessBufSize)) ) {

        /* If realloc failed and left us with the old buffer, free it */
        if (pProcessBuffer != NULL) {
            free(pProcessBuffer);
            }

        return (0);     // Out of memory
        }
    else {
        /* Successful Realloc */
        pProcessBuffer = pNewProcessBuffer;
        }

    /* Try another query */        
    }

/* If we didn't meet with full success. . . */
if ( !NT_SUCCESS(Status) ) {
    if (pProcessBuffer != NULL) {
        free(pProcessBuffer);
        }

    return (0);     // Unknown error that prevents us from continuing
    }

/*
| At this point, "pProcessBuffer" points to a buffer formatted as a
| "System Process Information" structure.
|
| Setup to go a-walking it.
*/
ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pProcessBuffer;

while ( TRUE ) {

    // check for Live processes
    //  (i.e. name or threads)

    if ((ProcessInfo->ImageName.Buffer != NULL) ||
        (ProcessInfo->NumberOfThreads > 0)) {

        /* thread is not Dead */
        Process_count += 1;
        }


    // exit if this was the last process in list
    if (ProcessInfo->NextEntryOffset == 0) {
        break;
        }

    // point to next buffer in list
    ProcessBufferOffset += ProcessInfo->NextEntryOffset;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                      &pProcessBuffer[ProcessBufferOffset];

    }


free(pProcessBuffer);

return (Process_count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\dlog_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    dlog_tbl.c

Abstract:

    All routines to perform operations on the Domain Logon Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "dlog_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Domain Logon table
static UINT                dlogSubids[] = { 4, 8, 1 };
static AsnObjectIdentifier MIB_DomLogonPrefix = { 3, dlogSubids };

DOM_LOGON_TABLE     MIB_DomLogonTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define DLOG_FIELD_SUBID    (MIB_DomLogonPrefix.idLength+MIB_OidPrefix.idLength)

#define DLOG_FIRST_FIELD       DLOG_USER_FIELD
#define DLOG_LAST_FIELD        DLOG_MACHINE_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_dlogons_get(
        IN OUT RFC1157VarBind *VarBind
    );

int MIB_dlogons_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_dlogons_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_dlogons_func
//    High level routine for handling operations on the Domain Logon table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_dlogons_func(
    IN UINT Action,
        IN MIB_ENTRY *MibPtr,
    IN OUT RFC1157VarBind *VarBind
    )

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Domain Logon table with the info from server
     if ( SNMPAPI_ERROR == MIB_dlogons_lmget() )
        {
        ErrStat = SNMP_ERRORSTATUS_GENERR;
        goto Exit;
        }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_DomLogonTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { DLOG_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };
         AsnObjectIdentifier tmpOid;

         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (!SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (!SnmpUtilOidAppend( &VarBind->name, &MIB_DomLogonPrefix ))
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (!SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (!SnmpUtilOidAppend( &VarBind->name, &MIB_DomLogonTable.Table[0].Oid ))
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_dlogons_get( VarBind );
     break;

      case MIB_ACTION_GETNEXT:
         // Fill the Domain Logon Table with the info from server
     if ( SNMPAPI_ERROR == MIB_dlogons_lmget() )
        {
        ErrStat = SNMP_ERRORSTATUS_GENERR;
        goto Exit;
        }

         // Determine which field
         Field = VarBind->name.ids[DLOG_FIELD_SUBID];

         // Lookup OID in table
         if (Field < DLOG_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = DLOG_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > DLOG_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_dlogons_match( &VarBind->name, &Entry );

    
         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_DomLogonTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > DLOG_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_DomLogonTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > DLOG_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;
         AsnObjectIdentifier tmpOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

                 
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (!SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (!SnmpUtilOidAppend( &VarBind->name, &MIB_DomLogonPrefix ))
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (!SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (!SnmpUtilOidAppend( &VarBind->name, &MIB_DomLogonTable.Table[Entry].Oid ))
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_dlogons_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
     break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_dlogons_func



//
// MIB_dlogons_get
//    Retrieve Domain Logon Table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_dlogons_get(
        IN OUT RFC1157VarBind *VarBind
    )

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[DLOG_FIELD_SUBID] < DLOG_FIRST_FIELD ||
       VarBind->name.ids[DLOG_FIELD_SUBID] > DLOG_LAST_FIELD)
   {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
   }

   // Fill the Domain Logon Table with the info from server
   if ( SNMPAPI_ERROR == MIB_dlogons_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_dlogons_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_dlogons_copyfromtable( Entry, VarBind->name.ids[DLOG_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_dlogons_get



//
// MIB_dlogons_match
//    Match the target OID with a location in the Domain Logon Table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_dlogons_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_DomLogonPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_DomLogonPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_DomLogonTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_DomLogonTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_dlogons_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_dlogons_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case DLOG_USER_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_DomLogonTable.Table[Entry].domLogonUser.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_DomLogonTable.Table[Entry].domLogonUser.stream,
                       MIB_DomLogonTable.Table[Entry].domLogonUser.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_DomLogonTable.Table[Entry].domLogonUser.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case DLOG_MACHINE_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                      * MIB_DomLogonTable.Table[Entry].domLogonMachine.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_DomLogonTable.Table[Entry].domLogonMachine.stream,
                       MIB_DomLogonTable.Table[Entry].domLogonMachine.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_DomLogonTable.Table[Entry].domLogonMachine.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Domain Logon Table.\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_dlogons_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\hash.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Hash Table and support functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>

#include "mib.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "hash.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define HT_SIZE    101
#define HT_RADIX   18

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

   // Structure of one node in the hash table
typedef struct hash_node
           {
	   MIB_ENTRY        *MibEntry;
	   struct hash_node *Next;
	   } HASH_NODE;

   // Hash table definition
HASH_NODE *MIB_HashTable[HT_SIZE];

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_HashInit
//    Initializes hash table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_HashInit()

{
UINT      I;
UINT      HashRes;
HASH_NODE *ht_ptr;
SNMPAPI   nResult;


   // Initialize hash table
   for ( I=0;I < HT_SIZE;I++ )
      {
      MIB_HashTable[I] = NULL;
      }

   // Loop MIB hashing the OID's to find position in Hash Table
   for ( I=0;I < MIB_num_variables;I++ )
      {
      HashRes = MIB_Hash( &Mib[I].Oid );

      // Check for empty bucket
      if ( MIB_HashTable[HashRes] == NULL )
         {
	 // Allocate first node in bucket
         MIB_HashTable[HashRes] = SnmpUtilMemAlloc( sizeof(HASH_NODE) );
	 if ( MIB_HashTable[HashRes] == NULL )
	    {
	    SetLastError( SNMP_MEM_ALLOC_ERROR );

	    nResult = SNMPAPI_ERROR;
	    goto Exit;
	    }

	 // Make copy of position in hash table to save MIB entry
	 ht_ptr = MIB_HashTable[HashRes];
	 }
      else
         {
	 // Find end of bucket
	 ht_ptr = MIB_HashTable[HashRes];
	 while ( ht_ptr->Next != NULL )
	    {
	    ht_ptr = ht_ptr->Next;
	    }

	 // Alloc space for next node
         ht_ptr->Next = SnmpUtilMemAlloc( sizeof(HASH_NODE) );
	 if ( ht_ptr->Next == NULL )
	    {
	    SetLastError( SNMP_MEM_ALLOC_ERROR );

	    nResult = SNMPAPI_ERROR;
	    goto Exit;
	    }

	 // Make copy of position in hash table to save MIB entry
	 ht_ptr = ht_ptr->Next;
	 }

      // Save MIB Entry pointer
      ht_ptr->MibEntry = &Mib[I];
      ht_ptr->Next     = NULL;
      }

Exit:
   return nResult;
} // MIB_HashInit



//
// MIB_Hash
//    Hash an Object Identifier to find its position in the Hash Table.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_Hash(
        IN AsnObjectIdentifier *Oid // OID to hash
	)

{
long I;
UINT Sum;


   Sum = 0;
   for ( I=0;I < (long)Oid->idLength-1;I++ )
      {
      Sum = Sum * HT_RADIX + Oid->ids[I+1];
      }

   return Sum % HT_SIZE;
} // MIB_Hash



//
// MIB_HashLookup
//    Lookup OID in Hash Table and return pointer to MIB Entry.
//
// Notes:
//
// Return Codes:
//    NULL - OID not present in Hash Table.
//
// Error Codes:
//    None.
//
MIB_ENTRY *MIB_HashLookup(
              IN AsnObjectIdentifier *Oid // OID to lookup
	      )

{
HASH_NODE *ht_ptr;
MIB_ENTRY *pResult;
UINT      HashPos;


   // Hash OID to find position in Hash Table
   HashPos = MIB_Hash( Oid );

   // Search hash bucket for match
   ht_ptr = MIB_HashTable[HashPos];
   while ( ht_ptr != NULL )
      {
      if ( !SnmpUtilOidCmp(Oid, &ht_ptr->MibEntry->Oid) )
         {
	 pResult = ht_ptr->MibEntry;
	 goto Exit;
	 }

      ht_ptr = ht_ptr->Next;
      }

   // Check for not found error
   if ( ht_ptr == NULL )
      {
      pResult = NULL;
      }

Exit:
   return pResult;
} // MIB_HashLookup



#if 0 // Left in in case of more testing on hash performance
//
//
// Debugging Code
//
//

void MIB_HashPerformance()

{
UINT I;
UINT LargestBucket;
UINT BucketSize;
HASH_NODE *ht_ptr;
ULONG Sum;
ULONG Count;


   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Hash Performance Report\n" );

   LargestBucket = 0;
   Count         = 0;
   Sum           = 0;
   for ( I=0;I < HT_SIZE;I++ )
      {
      BucketSize = 0;
      ht_ptr     = MIB_HashTable[I];

      // Count nodes in bucket
      while ( ht_ptr != NULL )
         {
	 BucketSize++;
	 ht_ptr = ht_ptr->Next;
	 }

      if ( BucketSize )
         {
	 SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   %d -- Bucket Size:  %d\n", I, BucketSize ));

         Sum += BucketSize;
	 Count ++;

         LargestBucket = max( LargestBucket, BucketSize );
	 }
      }

   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Number of Buckets:  %d\n", HT_SIZE ));
   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Number of MIB Var:  %d\n", MIB_num_variables ));
   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Hashing Radix    :  %d\n", HashRadix ));

   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Used bucket Count:  %d\n", Count ));
   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Avg. Bucket Size :  %d\n", Sum / Count ));
   SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2:   Larg. bucket Size:  %d\n", LargestBucket ));
} // MIB_HashPerformance
#endif
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\lmcache.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    lmcache.c

Abstract:

    This file actually creates the global cache_table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <time.h>

#ifdef WIN32
#include <windows.h>
#endif

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

CACHE_ENTRY cache_table[MAX_CACHE_ENTRIES] =
		{
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0},
		{0, NULL, 0, 0}
		};

time_t cache_expire[MAX_CACHE_ENTRIES] =
		{
		120,	// 2 min cache expiration for C_NETWKSTAGETINFO		   1
		120,	// 2 min cache expiration for C_NETSERVERGETINFO	   2
		120,	// 2 min cache expiration for C_NETSTATISTICSGET_SERVER	3
		120,	// 2 min cache expiration for C_NETSTATISTICSGET_WORKSTATION	4
		120,	// 2 min cache expiration for C_NETSERVICEENUM		   5
		120,	// 2 min cache expiration for C_NETSESSIONENUM		   6
		120,	// 2 min cache expiration for C_NETUSERENUM			   7
		120,	// 2 min cache expiration for C_NETSHAREENUM		   8
		120,	// 2 min cache expiration for C_NETUSEENUM			   9
		120,	// 2 min cache expiration for C_NETWKSTAUSERGETINFO	  10
		120,	// 2 min cache expiration for C_NETSERVERENUM         11
		120,	// 2 min cache expiration for C_NETWKSTAGETINFO_502   12
		120,	// 2 min cache expiration for C_NETSERVERGETINFO_402  13
		120,	// 2 min cache expiration for C_NETSERVERGETINFO_403  14
		120,	// 2 min cache expiration for C_NETWKSTAGETINFO_101   15
		120,	// 2 min cache expiration for C_PRNT_TABLE            16
		120,	// 2 min cache expiration for C_USES_TABLE            17
		120,	// 2 min cache expiration for C_DLOG_TABLE            18
		120,	// 2 min cache expiration for C_SESS_TABLE            19
		120,	// 2 min cache expiration for C_SRVR_TABLE            20
		120,	// 2 min cache expiration for C_SRVC_TABLE            21
		120,	// 2 min cache expiration for C_USER_TABLE            22
		120,	// 2 min cache expiration for C_ODOM_TABLE            23
		120,	// 2 min cache expiration for C_SHAR_TABLE            24
		120	// 2 min cache expiration for C_NETSERVERENUM			25
		};
//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\hash.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Constants, types, and prototypes for Hash Table and supporting functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef hash_h
#define hash_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#include "mib.h"

//--------------------------- PUBLIC STRUCTS --------------------------------

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_HashInit(
           void
           );

UINT MIB_Hash(
        IN AsnObjectIdentifier *Oid // OID to hash
	);

MIB_ENTRY *MIB_HashLookup(
              IN AsnObjectIdentifier *Oid // OID to lookup
	      );

#ifdef MIB_DEBUG
void MIB_HashPerformance( void );
#endif

//------------------------------- END ---------------------------------------

#endif /* hash_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\odom_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    odom_lm.c

Abstract:

    This file contains the routines which actually call Lan Manager and
    retrieve the contents of the other domains table, including cacheing.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>
//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "odom_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)       if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

int __cdecl odom_entry_cmp(
       IN const DOM_OTHER_ENTRY *A,
       IN const DOM_OTHER_ENTRY *B
       ) ;

BOOL build_odom_entry_oids( );

void FreeDomOtherDomainTable();

int chrcount(char *s)
{
char *temp;
int i;
temp = s;
i = 1;  // assume one since no terminating space, other code counts tokens
while( NULL != (temp = strchr(temp,' ')) ) {
        i++;
        }
return i;
}

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_odoms_lmset
//    Perform the necessary actions to set an entry in the Other Domain Table.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None.
//
UINT MIB_odoms_lmset(
        IN AsnObjectIdentifier *Index,
        IN UINT Field,
        IN AsnAny *Value
        )

{
LPBYTE bufptr = NULL;
WKSTA_USER_INFO_1101 ODom;
LPBYTE Temp;
UINT   Entry;
UINT   I;
UINT   ErrStat = SNMP_ERRORSTATUS_NOERROR;
#ifdef UNICODE
LPWSTR unitemp ;
#endif


   // Must make sure the table is in memory
   if ( SNMPAPI_ERROR == MIB_odoms_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   // See if match in table
   if ( MIB_TBL_POS_FOUND == MIB_odoms_match(Index, &Entry) )
      {
      // If empty string then delete entry
      if ( Value->asnValue.string.length == 0 )
         {
         // Alloc memory for buffer
         bufptr = SnmpUtilMemAlloc( DNLEN * sizeof(char) *
                          (MIB_DomOtherDomainTable.Len-1) +
                          MIB_DomOtherDomainTable.Len-1 );

         // prefix #57351
         if (bufptr == NULL)
            return SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            

         // Create the other domain string
         Temp = bufptr;
         for ( I=0;I < MIB_DomOtherDomainTable.Len;I++ )
            {
            if ( I+1 != Entry )
               {
               if (MIB_DomOtherDomainTable.Table[I].domOtherName.length <= DNLEN)
                {
                memcpy( Temp,
                       MIB_DomOtherDomainTable.Table[I].domOtherName.stream,
                       MIB_DomOtherDomainTable.Table[I].domOtherName.length );
                Temp[MIB_DomOtherDomainTable.Table[I].domOtherName.length] = ' ';
                Temp += MIB_DomOtherDomainTable.Table[I].domOtherName.length + 1;
                }
                else
                {
                memcpy( Temp,
                       MIB_DomOtherDomainTable.Table[I].domOtherName.stream,
                       DNLEN );
                Temp[DNLEN] = ' ';
                Temp += DNLEN + 1;  
                }

               }
            }
         *(Temp-1) = '\0';
         }
      else
         {
         // Cannot modify the domain entries, so bad value
         ErrStat = SNMP_ERRORSTATUS_BADVALUE;
         goto Exit;
         }
      }
   else
      {
      // Check for addition of NULL string, bad value
      if ( Value->asnValue.string.length == 0 )
         {
         ErrStat = SNMP_ERRORSTATUS_BADVALUE;
         goto Exit;
         }

      //
      // Entry doesn't exist so add it to the list
      //

      // Alloc memory for buffer
      bufptr = SnmpUtilMemAlloc( DNLEN * sizeof(char) *
                       (MIB_DomOtherDomainTable.Len+1) +
                       MIB_DomOtherDomainTable.Len+1 );

      // prefix #57352
      if (bufptr == NULL)
          return SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;

      // Create the other domain string
      Temp = bufptr;
      for ( I=0;I < MIB_DomOtherDomainTable.Len;I++ )
         {
         
         if (MIB_DomOtherDomainTable.Table[I].domOtherName.length <= DNLEN)
            {
            memcpy( Temp, MIB_DomOtherDomainTable.Table[I].domOtherName.stream,
                 MIB_DomOtherDomainTable.Table[I].domOtherName.length );
            Temp[MIB_DomOtherDomainTable.Table[I].domOtherName.length] = ' ';
            Temp += MIB_DomOtherDomainTable.Table[I].domOtherName.length + 1;
            }
            else
            {
            memcpy( Temp, MIB_DomOtherDomainTable.Table[I].domOtherName.stream,
                     DNLEN );
                Temp[DNLEN] = ' ';
                Temp += DNLEN + 1;  
            }
         }

      // Add new entry
      if (Value->asnValue.string.length <= DNLEN)
        {
        memcpy( Temp, Value->asnValue.string.stream,
                        Value->asnValue.string.length );
        // Add NULL terminator
        Temp[Value->asnValue.string.length] = '\0';
        }
        else
        {
        memcpy( Temp, Value->asnValue.string.stream, DNLEN );
        // Add NULL terminator
        Temp[DNLEN] = '\0';
        }


      }

   // Set table and check return codes
   #ifdef UNICODE
   if (SnmpUtilUTF8ToUnicode(   &unitemp,
                                bufptr,
                                TRUE ))
   {
       // failed
       ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
       goto Exit;
   }
   ODom.wkui1101_oth_domains = unitemp;
   #else
   ODom.wkui1101_oth_domains = bufptr;
   #endif
#if 0
   if ( NERR_Success == NetWkstaUserSetInfo(NULL, 1101, (LPBYTE)&ODom, NULL) )
      {
      // Make cache be reloaded next time
      cache_table[C_ODOM_TABLE].bufptr = NULL;
      }
   else
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      }
#else
   ErrStat = SNMP_ERRORSTATUS_GENERR;
#endif

Exit:
   SnmpUtilMemFree( bufptr );

   return ErrStat;
} // MIB_odoms_lmset



//
// MIB_odom_lmget
//    Retrieve print queue table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_odoms_lmget(
           )

{

DWORD totalentries;
LPBYTE bufptr = NULL;
unsigned lmCode;
WKSTA_USER_INFO_1101 *DataTable;
DOM_OTHER_ENTRY *MIB_DomOtherDomainTableElement ;
char *p;
char *next;
time_t curr_time ;
unsigned i;
SNMPAPI nResult = SNMPAPI_NOERROR;



   time(&curr_time);    // get the time


   //
   //
   // If cached, return piece of info.
   //
   //


   if((NULL != cache_table[C_ODOM_TABLE].bufptr) &&
      (curr_time <
        (cache_table[C_ODOM_TABLE].acquisition_time
                 + cache_expire[C_ODOM_TABLE]              ) ) )
        { // it has NOT expired!

        goto Exit; // the global table is valid

        }

   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //


     //
     // remember to free the existing data
     //

     FreeDomOtherDomainTable();

     lmCode =
        NetWkstaUserGetInfo(
                        0,                      // required
                        1101,                   // level 0,
                        &bufptr                 // data structure to return
                        );


    DataTable = (WKSTA_USER_INFO_1101 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {  // valid so process it, otherwise error
        if(NULL==DataTable->wkui1101_oth_domains) {
                // Prefix #57350
                // free all of the lanman data
                SafeBufferFree( bufptr ) ;
                // Signal error
                nResult = SNMPAPI_ERROR;
                goto Exit;

        } else {  // compute it
        totalentries = chrcount((char *)DataTable->wkui1101_oth_domains);
        if(0 == MIB_DomOtherDomainTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_DomOtherDomainTable.Table = SnmpUtilMemAlloc(totalentries *
                                                sizeof(DOM_OTHER_ENTRY) );

                // Prefix #57349
                if (MIB_DomOtherDomainTable.Table == NULL) 
                {
                    // free all of the lanman data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
                }
        }

        MIB_DomOtherDomainTableElement = MIB_DomOtherDomainTable.Table  ;

        // make a pointer to the beginning of the string field

        #ifdef UNICODE
        if (SnmpUtilUnicodeToUTF8(
                &p,
                DataTable->wkui1101_oth_domains,
                TRUE))
        {
            // free all of the lanman data
            SafeBufferFree( bufptr ) ;
            // Signal error
            nResult = SNMPAPI_ERROR;
            goto Exit;

        }
        #else
        p =  DataTable->wkui1101_oth_domains  ;
        #endif

        // scan through the field, making an entry for each space
        // separated domain
        while(  (NULL != p ) &&
                ('\0' != *p)  ) {  // once for each entry in the buffer



                // find the end of this one
                next = strchr(p,' ');

                // if more to come, ready next pointer and mark end of this one
                if(NULL != next) {
                        *next='\0' ;    // replace space with EOS
                        next++ ;        // point to beginning of next domain
                }


                MIB_DomOtherDomainTableElement->domOtherName.stream = SnmpUtilMemAlloc (
                                strlen( p ) ) ;
                if (NULL == MIB_DomOtherDomainTableElement->domOtherName.stream)
                {
                    p = next;
                    continue;
                }
                MIB_DomOtherDomainTableElement->domOtherName.length =
                                strlen( p ) ;
                MIB_DomOtherDomainTableElement->domOtherName.dynamic = TRUE;
                memcpy( MIB_DomOtherDomainTableElement->domOtherName.stream,
                        p,
                        strlen( p ) ) ;

                // increment the entry number

                MIB_DomOtherDomainTable.Len ++;

                MIB_DomOtherDomainTableElement ++ ;  // and table entry

                p = next;


            } // while still more to do

        } // if there really were entries
        } // if data is valid to process

    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }


   // free all of the lan man data
   SafeBufferFree( bufptr ) ;


    // iterate over the table populating the Oid field
    if (! build_odom_entry_oids())
    {
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: build_odom_entry_oids failed\n."));

        FreeDomOtherDomainTable();
        cache_table[C_ODOM_TABLE].bufptr = NULL;
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

   // Sort the table information using MSC QuickSort routine
   qsort( (void *)&MIB_DomOtherDomainTable.Table[0], (size_t)MIB_DomOtherDomainTable.Len,
          (size_t)sizeof(DOM_OTHER_ENTRY), odom_entry_cmp );

   //
   //
   // Cache table
   //
   //


   if(0 != MIB_DomOtherDomainTable.Len) {

        cache_table[C_ODOM_TABLE].acquisition_time = curr_time ;

        cache_table[C_ODOM_TABLE].bufptr = bufptr ;
   }

   //
   //
   // Return piece of information requested
   //
   //

Exit:
   return nResult;
} // MIB_odom_get

//
// MIB_odom_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl odom_entry_cmp(
       IN const DOM_OTHER_ENTRY *A,
       IN const DOM_OTHER_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_odom_cmp


//
//    None.
//
BOOL build_odom_entry_oids(
       )

{
    AsnOctetString OSA ;
    DOM_OTHER_ENTRY *DomOtherEntry ;
    unsigned i;

    // start pointer at 1st guy in the table
    DomOtherEntry = MIB_DomOtherDomainTable.Table ;

    // now iterate over the table, creating an oid for each entry
    for( i=0; i<MIB_DomOtherDomainTable.Len ; i++)  {
        // for each entry in the session table

        OSA.stream = DomOtherEntry->domOtherName.stream ;
        OSA.length =  DomOtherEntry->domOtherName.length ;
        OSA.dynamic = FALSE;

        // Make the entry's OID from string index
        if (! MakeOidFromStr( &OSA, &DomOtherEntry->Oid ))
        {
            return FALSE;
        }

        DomOtherEntry++; // point to the next guy in the table

    } // for
    return TRUE;
} // build_odom_entry_oids

void FreeDomOtherDomainTable()
{
    UINT i;
    DOM_OTHER_ENTRY *MIB_DomOtherDomainTableElement;

    MIB_DomOtherDomainTableElement = MIB_DomOtherDomainTable.Table ;
    if (MIB_DomOtherDomainTableElement)
    {
        // iterate over the whole table
        for(i=0; i<MIB_DomOtherDomainTable.Len ;i++)
        {
            // free any alloc'ed elements of the structure
            SnmpUtilOidFree(&(MIB_DomOtherDomainTableElement->Oid));
            SnmpUtilMemFree(MIB_DomOtherDomainTableElement->domOtherName.stream);

            MIB_DomOtherDomainTableElement ++ ;  // increment table entry
        }
        SnmpUtilMemFree(MIB_DomOtherDomainTable.Table) ;  // free the base Table
    }
    MIB_DomOtherDomainTable.Table = NULL ;     // just for safety
    MIB_DomOtherDomainTable.Len = 0 ;          // just for safety
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\lmcache.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    lmcache.h

Abstract:

    This routine declares all of the structures required to cache the Lan
    Manager function calls.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef lmcache_h
#define lmcache_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#define	C_NETWKSTAGETINFO		1
#define	C_NETSERVERGETINFO		2
#define	C_NETSTATISTICSGET_SERVER	3
#define	C_NETSTATISTICSGET_WORKST	4
#define	C_NETSERVICEENUM		5
#define	C_NETSESSIONENUM		6
#define	C_NETUSERENUM			7
#define	C_NETSHAREENUM			8
#define	C_NETUSEENUM			9
#define	C_NETWKSTAUSERGETINFO		10
#define	C_NETSERVERENUM			11
#define	C_NETWKSTAGETINFO_502		12
#define	C_NETSERVERGETINFO_402		13
#define	C_NETSERVERGETINFO_403		14
#define	C_NETWKSTAGETINFO_101		15
#define C_PRNT_TABLE			16
#define C_USES_TABLE			17
#define C_DLOG_TABLE			18
#define C_SESS_TABLE			19
#define C_SRVR_TABLE			20
#define C_SRVC_TABLE			21
#define C_USER_TABLE			22
#define C_ODOM_TABLE			23
#define C_SHAR_TABLE		  	24
#define	MAX_CACHE_ENTRIES		25

//--------------------------- PUBLIC STRUCTS --------------------------------

typedef struct cache_entry
	{
	time_t acquisition_time ;	// time that data acquired
	LPBYTE bufptr;			// pointer to buffer
	DWORD entriesread;		// stuffed if appropriate
	DWORD totalentries;		// stuffed if appropriate
	} CACHE_ENTRY ;
	
//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern CACHE_ENTRY cache_table[MAX_CACHE_ENTRIES] ;
extern time_t cache_expire[MAX_CACHE_ENTRIES];
//--------------------------- PUBLIC PROTOTYPES -----------------------------


//------------------------------- END ---------------------------------------

#endif /* lmcache_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\mibfuncs.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mibfuncs.c

Abstract:

    Contains MIB functions for GET's and SET's for LM MIB.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef DOS
#if 0
#define INCL_NETWKSTA
#define INCL_NETERRORS
#include <lan.h>
#endif
#endif

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif
#include <tchar.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>
//---ft:07/13---LsaGetUserName substitutes NetWkstaGetUserInfo
#include <subauth.h>    // needed for the definition of PUNICODE_STRING
#include <ntlsa.h>      // LSA APIs
//---tf---
#include "mib.h"
#include "lmcache.h"


//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "mibfuncs.h"
#include "odom_tbl.h"
#include "user_tbl.h"
#include "shar_tbl.h"
#include "srvr_tbl.h"
#include "prnt_tbl.h"
#include "uses_tbl.h"


//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)       if(NULL != x) NetApiBufferFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

void  * MIB_common_func(
           IN UINT Action,  // Action to perform on Data
           IN LDATA LMData, // LM Data to manipulate
           IN void *SetData
           )

{
SNMPAPI nResult;
unsigned lmCode;
WKSTA_INFO_101 *wksta_info_one;
SERVER_INFO_102 *server_info_two;
STAT_SERVER_0 *server_stats_zero;
STAT_WORKSTATION_0 *wrk_stats_zero;
LPBYTE bufptr = NULL;
lan_return_info_type *retval=NULL;
BYTE *stream;
char temp[80];
BOOL cache_it = FALSE ;
time_t curr_time ;

UNREFERENCED_PARAMETER(SetData);

   time(&curr_time);    // get the time

   switch ( Action )
      {
      case MIB_ACTION_GET:
         // Check to see if data is cached
         //if ( Cached )
            //{
            // Retrieve from cache
            //}
         //else
            //{
            // Call LM call to get data

            // Put data in cache
            //}

         // See if data is supported
         switch ( LMData )
            {
            case MIB_LM_COMVERSIONMAJ:

              if((NULL == cache_table[C_NETWKSTAGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETWKSTAGETINFO].acquisition_time
                         + cache_expire[C_NETWKSTAGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETWKSTAGETINFO].bufptr ) ;
                cache_table[C_NETWKSTAGETINFO].bufptr = NULL;
                //
                lmCode =
                NetWkstaGetInfo( NULL,                  // local server
                                101,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETWKSTAGETINFO].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )        
                            goto Exit ;
                       
                       retval->data_element_type = ASN_OCTETSTRING ;
                       wksta_info_one = (WKSTA_INFO_101 *) bufptr ;
                       _itoa(wksta_info_one->wki101_ver_major,temp,10) ;
                       if(NULL ==
                        (stream = SnmpUtilMemAlloc( strlen(temp) ))
                       )  {
                            SnmpUtilMemFree(retval);
                            retval=NULL;
                            goto Exit ;
                       }
                       memcpy(stream,&temp,strlen(temp));
                       retval->d.octstrval.stream = stream;
                       retval->d.octstrval.length = strlen(temp);
                       retval->d.octstrval.dynamic = TRUE;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETWKSTAGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETWKSTAGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
               }
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_COMVERSIONMAJ.\n" ));
               break;

            case MIB_LM_COMVERSIONMIN:

              if((NULL == cache_table[C_NETWKSTAGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETWKSTAGETINFO].acquisition_time
                         + cache_expire[C_NETWKSTAGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETWKSTAGETINFO].bufptr ) ;
                //
               lmCode =
               NetWkstaGetInfo( NULL,                   // local server
                                101,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETWKSTAGETINFO].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       
                       retval->data_element_type = ASN_OCTETSTRING ;
                       wksta_info_one = (WKSTA_INFO_101 *) bufptr ;
                       _itoa(wksta_info_one->wki101_ver_minor,temp,10) ;
                       if(NULL ==
                        (stream = SnmpUtilMemAlloc( strlen(temp) ))
                       ){
                          SnmpUtilMemFree(retval);
                          retval=NULL;
                          goto Exit ;
                       }
                       memcpy(stream,&temp,strlen(temp));
                       retval->d.octstrval.stream = stream;
                       retval->d.octstrval.length = strlen(temp);
                       retval->d.octstrval.dynamic = TRUE;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETWKSTAGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETWKSTAGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_COMVERSIONMIN.\n" ));
               break;

            case MIB_LM_COMTYPE:
              if((NULL == cache_table[C_NETSERVERGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO].bufptr ) ;
                cache_table[C_NETSERVERGETINFO].bufptr = NULL;
               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                102,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_OCTETSTRING ;
                       server_info_two = (SERVER_INFO_102 *) bufptr ;
                       if(NULL ==
                        (stream = SnmpUtilMemAlloc( 4 * sizeof(BYTE) ))
                       ){
                          SnmpUtilMemFree(retval);
                          retval=NULL;
                          goto Exit ;
                       }
                       *(DWORD*)stream=server_info_two->sv102_type & 0x000000FF;
                       retval->d.octstrval.stream = stream;
                       retval->d.octstrval.length = 4 * sizeof(BYTE);
                       retval->d.octstrval.dynamic = TRUE;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_COMTYPE.\n" ));
               break;

            case MIB_LM_COMSTATSTART:
              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr);
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_start;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_STATSTART.\n" ));
               break;

            case MIB_LM_COMSTATNUMNETIOS:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_WORKST].bufptr);
                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval =
                  (wrk_stats_zero->SmbsReceived).LowPart +
                          (wrk_stats_zero->SmbsTransmitted).LowPart;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_STATNUMNETIOS.\n" ));
               break;

            case MIB_LM_COMSTATFINETIOS:


              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_WORKST].bufptr);
                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->InitiallyFailedOperations;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_STATFINETIOS.\n" ));
               break;

            case MIB_LM_COMSTATFCNETIOS:


              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_WORKST].bufptr);
                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->FailedCompletionOperations;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)

               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_STATFCNETIOS.\n" ));
               break;

            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Data not supported by function.\n" ));

               nResult = SNMPAPI_ERROR;
               goto Exit;
            }

         break;

      case MIB_ACTION_SET:
         break;


      default:
         // Signal an error

         nResult = SNMPAPI_ERROR;
         goto Exit;
      }

    return retval /*nResult*/;
    
Exit:
    if (cache_it)
    {
        SafeBufferFree(bufptr);
    }
    return retval /*nResult*/;
} // MIB_common_func

void  * MIB_server_func(
           IN UINT Action,  // Action to perform on Data
           IN LDATA LMData, // LM Data to manipulate
           IN void *SetData
           )

{

lan_return_info_type *retval=NULL;
SERVER_INFO_102 *server_info_two;
SERVER_INFO_102 server_info_10two;
STAT_SERVER_0 *server_stats_zero;
SERVER_INFO_102 *server_info_102 ;
SERVER_INFO_403 *server_info_four ;
SESSION_INFO_2 * session_info_two;
SERVER_INFO_402 *server_info_402 ;
#if 1
USER_INFO_0 *user_info_zero ;
#endif
unsigned lmCode;
BYTE *stream;
AsnOctetString *strvalue;
AsnInteger intvalue;
DWORD entriesread;
DWORD totalentries;
SNMPAPI nResult;
LPBYTE bufptr = NULL;
BOOL cache_it = FALSE;
time_t curr_time ;
#ifdef UNICODE
LPWSTR unitemp ;
#endif

   time(&curr_time);    // get the time

   switch ( Action )
      {
      case MIB_ACTION_GET:
         // Check to see if data is cached
         //if ( Cached )
            //{
            // Retrieve from cache
            //}
         //else
            //{
            // Call LM call to get data

            // Put data in cache
            //}

         // See if data is supported
         switch ( LMData )
            {

        case MIB_LM_SVDESCRIPTION:
              if((NULL == cache_table[C_NETSERVERGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO].bufptr );
                cache_table[C_NETSERVERGETINFO].bufptr = NULL;

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                102,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_OCTETSTRING ;
                       server_info_two = (SERVER_INFO_102 *) bufptr ;

                       #ifdef UNICODE
                                if (SnmpUtilUnicodeToUTF8(
                                        &stream,
                                        server_info_two->sv102_comment,
                                        TRUE))
                                {
                                    SnmpUtilMemFree(retval);
                                    retval = NULL;
                                    goto Exit;
                                }
                       #else
                               if(NULL ==
                                (stream = SnmpUtilMemAlloc( strlen(server_info_two->sv102_comment) + 1 ))
                               ) {
                                  SnmpUtilMemFree(retval);
                                  retval=NULL;
                                  goto Exit ;
                               }

                                memcpy(stream,server_info_two->sv102_comment,
                                        strlen(server_info_two->sv102_comment));
                       #endif
                       retval->d.octstrval.stream = stream;
                       retval->d.octstrval.length =
                                strlen(stream);
                       retval->d.octstrval.dynamic = TRUE;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVDESCRIPTION.\n" ));
               break;


                case MIB_LM_SVSVCNUMBER:

              if((NULL == cache_table[C_NETSERVICEENUM].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVICEENUM].acquisition_time
                         + cache_expire[C_NETSERVICEENUM]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVICEENUM].bufptr) ;
                cache_table[C_NETSERVICEENUM].bufptr = NULL;

               lmCode =
               NetServiceEnum( NULL,                    // local server
                                0,                      // level 0
                                &bufptr,                        // data structure to return
                                MAX_PREFERRED_LENGTH,
                                &entriesread,
                                &totalentries,
                                NULL);
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVICEENUM].bufptr ;
                totalentries =  cache_table[C_NETSERVICEENUM].totalentries ;
                entriesread =  cache_table[C_NETSERVICEENUM].entriesread ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       retval->d.intval = totalentries; // LOOK OUT!!
                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVICEENUM].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVICEENUM].bufptr = bufptr ;
                                cache_table[C_NETSERVICEENUM].totalentries =
                                                totalentries ;
                                cache_table[C_NETSERVICEENUM].entriesread =
                                                entriesread ;
                        } // if (cache_it)
               }


               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSVCNUMBER.\n" ));
               break;


                case MIB_LM_SVSTATOPENS:


              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_fopens;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)

               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATOPENS.\n" ));
               break;


                case MIB_LM_SVSTATDEVOPENS:



              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_devopens;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATDEVOPENS.\n" ));
               break;

                case MIB_LM_SVSTATQUEUEDJOBS:



              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_jobsqueued;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATQUEUEDJOBS.\n" ));
               break;

                case MIB_LM_SVSTATSOPENS:


              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_sopens;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATSOPENS.\n" ));
               break;

                case MIB_LM_SVSTATERROROUTS:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_serrorout;
                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATSERROROUTS.\n" ));
               break;

                case MIB_LM_SVSTATPWERRORS:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_pwerrors;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATPWERRORS.\n" ));
               break;

                case MIB_LM_SVSTATPERMERRORS:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_permerrors;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATPERMERRORS.\n" ));
               break;

                case MIB_LM_SVSTATSYSERRORS:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_syserrors;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATSYSERRORS.\n" ));
               break;

                case MIB_LM_SVSTATSENTBYTES:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_bytessent_low;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATSENTBYTES.\n" ));
               break;

                case MIB_LM_SVSTATRCVDBYTES:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_bytesrcvd_low;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATRCVDBYTES.\n" ));
               break;

                case MIB_LM_SVSTATAVRESPONSE:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_avresponse;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATAVRESPONSE.\n" ));
               break;

         case MIB_LM_SVSECURITYMODE:

             // hard code USER security per dwaink
             //
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       retval->d.intval = 2 ;

#if 0
              if((NULL == cache_table[C_NETSERVERGETINFO_403].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO_403].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO_403]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO_403].bufptr) ;

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                403,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO_403].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_info_four = (SERVER_INFO_403 *) bufptr ;
                       retval->d.intval = server_info_four->sv403_security;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO_403].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO_403].bufptr = bufptr ;
                        } // if (cache_it)
               }
#endif
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSECURITYMODE.\n" ));
               break;



                case MIB_LM_SVUSERS:

              if((NULL == cache_table[C_NETSERVERGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO].bufptr) ;
                cache_table[C_NETSERVERGETINFO].bufptr = NULL;

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                102,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_info_102 = (SERVER_INFO_102 *) bufptr ;
                       retval->d.intval = server_info_102->sv102_users;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVUSERS.\n" ));
               break;

                case MIB_LM_SVSTATREQBUFSNEEDED:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_reqbufneed;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATREQBUFSNEEDED.\n" ));
               break;

                case MIB_LM_SVSTATBIGBUFSNEEDED:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ;
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_bigbufneed;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATBIGBUFNEEDED.\n" ));
               break;

                case MIB_LM_SVSESSIONNUMBER:

              if((NULL == cache_table[C_NETSESSIONENUM].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSESSIONENUM].acquisition_time
                         + cache_expire[C_NETSESSIONENUM]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSESSIONENUM].bufptr) ;
                cache_table[C_NETSESSIONENUM].bufptr = NULL;

               lmCode =
               NetSessionEnum(  NULL,                   // local server
                                NULL,           // get server stats
                                NULL,
                                2,                      // level
                                &bufptr,                // data structure to return
                                MAX_PREFERRED_LENGTH,
                                &entriesread,
                                &totalentries,
                                NULL                    // no resume handle
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSESSIONENUM].bufptr ;
                totalentries =  cache_table[C_NETSESSIONENUM].totalentries ;
                entriesread =  cache_table[C_NETSESSIONENUM].entriesread ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       session_info_two = (SESSION_INFO_2 *) bufptr ;
                       retval->d.intval = totalentries;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSESSIONENUM].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSESSIONENUM].bufptr = bufptr ;
                                cache_table[C_NETSESSIONENUM].totalentries =
                                                totalentries ;
                                cache_table[C_NETSESSIONENUM].entriesread =
                                                entriesread ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSESSIONNUMBER.\n" ));
               break;

                case MIB_LM_SVAUTODISCONNECTS:

              if((NULL == cache_table[C_NETSTATISTICSGET_SERVER].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_SERVER]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSTATISTICSGET_SERVER].bufptr);
                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = NULL;

               lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_SERVER,         // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_SERVER].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_stats_zero = (STAT_SERVER_0 *) bufptr ;
                       retval->d.intval = server_stats_zero->sts0_stimedout;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_SERVER].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_SERVER].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSTATAUTODISCONNECT.\n" ));
               break;

                case MIB_LM_SVDISCONTIME:

              if((NULL == cache_table[C_NETSERVERGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO].bufptr) ;
                cache_table[C_NETSERVERGETINFO].bufptr = NULL;

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                102,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_info_102 = (SERVER_INFO_102 *) bufptr ;
                       retval->d.intval = server_info_102->sv102_disc ;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVDISCONTIME.\n" ));
               break;

                case MIB_LM_SVAUDITLOGSIZE:


            {
                HANDLE hEventLog;
                DWORD  cRecords;

                hEventLog = OpenEventLog( NULL,
                                          TEXT("APPLICATION"));
                if (NULL == hEventLog)
                {
                    goto Exit;
                }
                if(NULL ==
                       (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                {
                    CloseEventLog( hEventLog );
                    goto Exit ;
                }
                retval->data_element_type = ASN_INTEGER ;
                if(GetNumberOfEventLogRecords( hEventLog, &cRecords )){

                       retval->d.intval = cRecords ;
                } else {
                       retval->d.intval = 0 ;
                }
                CloseEventLog( hEventLog );
            }
#if 0
              if((NULL == cache_table[C_NETSERVERGETINFO_402].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSERVERGETINFO_402].acquisition_time
                         + cache_expire[C_NETSERVERGETINFO_402]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree( cache_table[C_NETSERVERGETINFO_402].bufptr) ;

               lmCode =
               NetServerGetInfo( NULL,                  // local server
                                402,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSERVERGETINFO_402].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       server_info_402 = (SERVER_INFO_402 *) bufptr ;
                       retval->d.intval = server_info_402->sv402_maxauditsz ;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSERVERGETINFO_402].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSERVERGETINFO_402].bufptr = bufptr ;
                        } // if (cache_it)
                }
#endif
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVAUDITLOGSIZE.\n" ));
               break;


                case MIB_LM_SVUSERNUMBER:



                MIB_users_lmget();   // fire off the table get
                if(NULL ==
                   (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                retval->data_element_type = ASN_INTEGER ;
                retval->d.intval = MIB_UserTable.Len;

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVUSERNUMBER.\n" ));
               break;


                case MIB_LM_SVSHARENUMBER:


                MIB_shares_lmget();   // fire off the table get
                if(NULL ==
                   (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ) )
                       )
                          goto Exit ;
                retval->data_element_type = ASN_INTEGER ;
                retval->d.intval = MIB_ShareTable.Len;


               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_SVSHARENUMBER.\n" ));
               break;


        case MIB_LM_SVPRINTQNUMBER:

                MIB_prntq_lmget();   // fire off the table get
                if(NULL ==
                    (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                retval->data_element_type = ASN_INTEGER ;
                retval->d.intval = MIB_PrintQTable.Len;


               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_PRINTQNUMBER.\n" ));
               break;



            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Data not supported by function.\n" ));

               nResult = SNMPAPI_ERROR;
               goto Exit;
            }

         break;

      case MIB_ACTION_SET:
         switch ( LMData )
            {

        case MIB_LM_SVDESCRIPTION:

                // retrieve string to be written
                strvalue = (AsnOctetString *) SetData ;

                // convert it to zero terminated string
                stream = SnmpUtilMemAlloc( strvalue->length+1 );
                if (stream == NULL) {
                    retval = (void *) FALSE;
                    break;
                }
                memcpy(stream,strvalue->stream,strvalue->length);
                stream[strvalue->length] = 0;

                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "LMMIB2: changing server description to %s.\n",
                    stream
                    ));

                #ifdef UNICODE
                if (SnmpUtilUTF8ToUnicode(&unitemp,
                                          stream,
                                          TRUE
                                          )) {
                    SnmpUtilMemFree(stream);
                    retval = (void *) FALSE;
                    break;
                }
                SnmpUtilMemFree(stream);
                stream = (LPBYTE)unitemp;
                #endif

                lmCode = NetServerSetInfo(
                                NULL,                   // this server
                                SV_COMMENT_INFOLEVEL,   // level
                                (LPBYTE)&stream,        // data
                                NULL );                 // option

                SnmpUtilMemFree(stream);

                if(NERR_Success == lmCode) {

                        retval = (void *) TRUE;
                        cache_table[C_NETSERVERGETINFO].acquisition_time = 0;

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "LMMIB2: server description changed, invalidating cache.\n"
                            ));

                } else {

                        retval = (void *) FALSE;

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "LMMIB2: server description not changed 0x%08lx.\n",
                            lmCode
                            ));
                }
                break ;

        case MIB_LM_SVDISCONTIME:

                intvalue = (AsnInteger)((ULONG_PTR) SetData) ;
                memset(&server_info_10two,0,sizeof(server_info_10two));
                server_info_10two.sv102_disc = intvalue ;
                lmCode = NetServerSetInfo(
                                NULL,                   // this server
                                SV_DISC_INFOLEVEL,                      // level
                                (LPBYTE)&server_info_10two,     // data
                                NULL );                 // option
                if(NERR_Success == lmCode) {
                        retval = (void *)TRUE;
                } else {
                        retval = (void *) FALSE;
                }
                break ;

        case MIB_LM_SVAUDITLOGSIZE:

                retval =  (void *) FALSE;
                break ;

            }  // switch(LMData)

         break;


      default:
         // Signal an error

         nResult = SNMPAPI_ERROR;
         goto Exit;
      }

   return retval /*nResult*/;
Exit:
    if (cache_it)
    {
        SafeBufferFree(bufptr);
    }
    return retval /*nResult*/;
} // MIB_server_func

void  * MIB_workstation_func(
           IN UINT Action,   // Action to perform on Data
           IN LDATA LMData,    // LM Data to manipulate
           IN void *SetData
           )

{

SNMPAPI nResult;
unsigned lmCode;
STAT_WORKSTATION_0 *wrk_stats_zero;
WKSTA_INFO_502 *wksta_info_five;
LPBYTE bufptr = NULL;
lan_return_info_type *retval=NULL;
DWORD entriesread;
DWORD totalentries;
BOOL cache_it = FALSE;
time_t curr_time ;


UNREFERENCED_PARAMETER(SetData);
   time(&curr_time);    // get the time

   switch ( Action )
      {
      case MIB_ACTION_GET:
         // Check to see if data is cached
         //if ( Cached )
            //{
            // Retrieve from cache
            //}
         //else
            //{
            // Call LM call to get data

            // Put data in cache
            //}

         // See if data is supported
         switch ( LMData )
            {

                case MIB_LM_WKSTASTATSESSSTARTS:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //

                SafeBufferFree(cache_table[C_NETSTATISTICSGET_WORKST].bufptr);
                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = NULL;

                lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->Sessions;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTASTATSESSSTARTS.\n" ));
               break;


                case MIB_LM_WKSTASTATSESSFAILS:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETSTATISTICSGET_WORKST].bufptr);
                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = NULL;

                lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->FailedSessions;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTASTATSESSFAILS.\n" ));
               break;

                case MIB_LM_WKSTASTATUSES:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETSTATISTICSGET_WORKST].bufptr);
                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = NULL;

                lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->UseCount;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTASTATUSES.\n" ));
               break;

                case MIB_LM_WKSTASTATUSEFAILS:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETSTATISTICSGET_WORKST].bufptr);
                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = NULL;

                lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->FailedUseCount;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTASTATUSEFAILS.\n" ));
               break;

                case MIB_LM_WKSTASTATAUTORECS:

              if((NULL == cache_table[C_NETSTATISTICSGET_WORKST].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time
                         + cache_expire[C_NETSTATISTICSGET_WORKST]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETSTATISTICSGET_WORKST].bufptr);
                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = NULL;

                lmCode =
               NetStatisticsGet( NULL,                  // local server
                                SERVICE_WORKSTATION,    // get server stats
                                0,                      // level 0
                                0,                      // don't clear stats
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETSTATISTICSGET_WORKST].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wrk_stats_zero = (STAT_WORKSTATION_0 *) bufptr ;
                       retval->d.intval = wrk_stats_zero->Reconnects;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETSTATISTICSGET_WORKST].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETSTATISTICSGET_WORKST].bufptr = bufptr ;
                        } // if (cache_it)
                }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTASTATAUTORECS.\n" ));
               break;

                case MIB_LM_WKSTAERRORLOGSIZE:

              if((NULL == cache_table[C_NETWKSTAGETINFO_502].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETWKSTAGETINFO_502].acquisition_time
                         + cache_expire[C_NETWKSTAGETINFO_502]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETWKSTAGETINFO_502].bufptr) ;
                cache_table[C_NETWKSTAGETINFO_502].bufptr = NULL;

               lmCode =
               NetWkstaGetInfo( NULL,                   // local server
                                502,                    // level 10, no admin priv.
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETWKSTAGETINFO_502].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_INTEGER ;
                       wksta_info_five = (WKSTA_INFO_502 *) bufptr ;
                       retval->d.intval =
                           wksta_info_five->wki502_maximum_collection_count ;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETWKSTAGETINFO_502].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETWKSTAGETINFO_502].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTAERRORLOGSIZE.\n" ));
               break;


                case MIB_LM_WKSTAUSENUMBER:

                MIB_wsuses_lmget();   // fire off the table get
                if(NULL ==
                   (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                retval->data_element_type = ASN_INTEGER ;
                retval->d.intval = MIB_WkstaUsesTable.Len;


               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_WKSTAUSENUMBER.\n" ));
               break;

            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Data not supported by function.\n" ));

               nResult = SNMPAPI_ERROR;
               goto Exit;
            }

         break;


      case MIB_ACTION_SET:
         switch ( LMData )
            {

                case MIB_LM_WKSTAERRORLOGSIZE:
                        ;
            }

         break;


      default:
         // Signal an error

         nResult = SNMPAPI_ERROR;
         goto Exit;
      }


   return retval /*nResult*/;
Exit:
    if (cache_it)
    {
        SafeBufferFree(bufptr);
    }
    return retval /*nResult*/;
}

void  * MIB_domain_func(
           IN UINT Action,   // Action to perform on Data
           IN LDATA LMData,  // LM Data to manipulate
           void *SetData
           )

{


SNMPAPI nResult;
unsigned lmCode;
WKSTA_INFO_101 *wksta_info_one;
LPBYTE bufptr = NULL;
lan_return_info_type *retval=NULL;
DWORD entriesread;
DWORD totalentries;
BYTE *stream;
BOOL cache_it = FALSE;
time_t curr_time ;

UNREFERENCED_PARAMETER(SetData);
   time(&curr_time);    // get the time


   switch ( Action )
      {
      case MIB_ACTION_GET:
         // Check to see if data is cached
         //if ( Cached )
            //{
            // Retrieve from cache
            //}
         //else
            //{
            // Call LM call to get data

            // Put data in cache
            //}

         // See if data is supported
         switch ( LMData )
            {

                case MIB_LM_DOMPRIMARYDOMAIN:

              if((NULL == cache_table[C_NETWKSTAGETINFO_101].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETWKSTAGETINFO_101].acquisition_time
                         + cache_expire[C_NETWKSTAGETINFO_101]              ) ) )
              {  // it has expired!
                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETWKSTAGETINFO_101].bufptr) ;
                cache_table[C_NETWKSTAGETINFO_101].bufptr = NULL;

               lmCode =
               NetWkstaGetInfo( NULL,                   // local server
                                101,                    // level 101,
                                &bufptr                 // data structure to return
                                );
                cache_it = TRUE ;
              } else {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETWKSTAGETINFO_101].bufptr ;
                cache_it = FALSE ;
              }


               if(lmCode == 0)  {  // valid so return it, otherwise error NULL
                       if(NULL ==
                        (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
                       retval->data_element_type = ASN_OCTETSTRING ;
                       wksta_info_one = (WKSTA_INFO_101 *) bufptr ;
#ifdef UNICODE
                       if (SnmpUtilUnicodeToUTF8(
                                        &stream,
                                        wksta_info_one->wki101_langroup,
                                        TRUE))
                       {
                          SnmpUtilMemFree(retval);
                          retval=NULL;
                          goto Exit ;
                       }
#else
                       if(NULL ==
                        (stream = SnmpUtilMemAlloc( strlen(wksta_info_one->wki101_langroup)+2 ))){
                          SnmpUtilMemFree(retval);
                          retval=NULL;
                          goto Exit ;
                       }

                       memcpy(stream,
                                        wksta_info_one->wki101_langroup,
                                        strlen(wksta_info_one->wki101_langroup));
#endif
                       retval->d.octstrval.stream = stream;
                       retval->d.octstrval.length = strlen(stream);
                       retval->d.octstrval.dynamic = TRUE;

                       if(cache_it) {
                       // now save it in the cache
                                cache_table[C_NETWKSTAGETINFO_101].acquisition_time =
                                        curr_time ;
                                cache_table[C_NETWKSTAGETINFO_101].bufptr = bufptr ;
                        } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_DOMPRIMARYDOMAIN.\n" ));
               break;

               case MIB_LM_DOMLOGONDOMAIN:
              if((NULL == cache_table[C_NETWKSTAUSERGETINFO].bufptr) ||
                 (curr_time >
                        (cache_table[C_NETWKSTAUSERGETINFO].acquisition_time
                         + cache_expire[C_NETWKSTAUSERGETINFO]              ) ) )
              {
                // it has expired!
                PLSA_UNICODE_STRING logonUserName, logonDomainName;

                //
                // remember to free the existing data
                //
                SafeBufferFree(cache_table[C_NETWKSTAUSERGETINFO].bufptr) ;
                cache_table[C_NETWKSTAUSERGETINFO].bufptr = NULL;
                logonUserName = logonDomainName = NULL;

                // sensible point. Hard to get a call that is returning the logonDomainName:
                // NetWkstaUserGetInfo() is returning NO_LOGON_SESSION (for level 1)
                // LsaGetUserName() is returning inaccurate info when running from service controller.
                lmCode = LsaGetUserName( &logonUserName, &logonDomainName);

                SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: got '%c'\n", (LPBYTE)(logonDomainName->Buffer)[0] ));
                if (lmCode == 0)
                {
                    DWORD cbLogonDomainName;

                    // save a copy of the logonDomainName
                    cbLogonDomainName = (wcslen(logonDomainName->Buffer) + 1) * sizeof(WCHAR);
                    if (NetApiBufferAllocate(cbLogonDomainName, &bufptr) == NERR_Success)
                    {
                        memcpy(bufptr, logonDomainName->Buffer, cbLogonDomainName);
                        // see BUG# 598384 and 587627 for detail on
                        // why we free the Buffer member
                        if (logonUserName)
                        {
                            LsaFreeMemory(logonUserName->Buffer);
                            LsaFreeMemory(logonUserName);
                        }
                        if (logonDomainName)
                        {
                            LsaFreeMemory(logonDomainName->Buffer);
                            LsaFreeMemory(logonDomainName);
                        }
                    }
                    else
                    {
                        // see BUG# 598384 and 587627 for detail on
                        // why we free the Buffer member
                        if (logonUserName)
                        {
                            LsaFreeMemory(logonUserName->Buffer);
                            LsaFreeMemory(logonUserName);
                        }
                        if (logonDomainName)
                        {
                            LsaFreeMemory(logonDomainName->Buffer);
                            LsaFreeMemory(logonDomainName);
                        }
                        goto Exit;
                    }
                }
                cache_it = TRUE ;
              }
              else
              {
                lmCode = 0 ;  // fake a sucessful lan man call
                bufptr =  cache_table[C_NETWKSTAUSERGETINFO].bufptr ;
                cache_it = FALSE ;
              }

               if(lmCode == 0)  
              {
                  // valid so return it, otherwise error NULL
                  if(NULL == (retval = SnmpUtilMemAlloc(sizeof(lan_return_info_type))) )
                          goto Exit ;
                  retval->data_element_type = ASN_OCTETSTRING ;
#ifdef UNICODE
                  if (SnmpUtilUnicodeToUTF8(
                    &stream,
                    (LPWSTR)bufptr,
                    TRUE))
                  {
                      SnmpUtilMemFree(retval);
                      retval=NULL;
                      goto Exit ;
                  }
#else
                  if(NULL == (stream = SnmpUtilMemAlloc(strlen((LPWSTR)bufptr)+2)) )
                  {
                      SnmpUtilMemFree(retval);
                      retval=NULL;
                      goto Exit ;
                  }

                  memcpy(stream,
                         bufptr,
                         strlen(bufptr));
#endif
                  retval->d.octstrval.stream = stream;
                  retval->d.octstrval.length = strlen(stream);
                  retval->d.octstrval.dynamic = TRUE;

                  if(cache_it)
                  {
                    // now save it in the cache
                    cache_table[C_NETWKSTAUSERGETINFO].acquisition_time = curr_time ;
                    cache_table[C_NETWKSTAUSERGETINFO].bufptr = bufptr ;
                  } // if (cache_it)
               }

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_DOMLOGONDOMAIN.\n" ));
               break;


               case MIB_LM_DOMOTHERDOMAINNUMBER:

               MIB_odoms_lmget();   // fire off the table get
               if(NULL ==
                   (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
               retval->data_element_type = ASN_INTEGER ;
               retval->d.intval = MIB_DomOtherDomainTable.Len;

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_DOMOTHERDOMAINNUMBER.\n" ));
               break;


               case MIB_LM_DOMSERVERNUMBER:

               MIB_svsond_lmget();   // fire off the table get
                
               if(NULL ==
                  (retval = SnmpUtilMemAlloc( sizeof(lan_return_info_type) ))
                       )
                          goto Exit ;
               retval->data_element_type = ASN_INTEGER ;
               retval->d.intval = MIB_DomServerTable.Len;

               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: processing MIB_LM_DOMSERVERNUMBER.\n" ));
               break;


//
// OPENISSUE --> NETLOGONENUM permanently eliminated
//
#if 0
// did some  of these guys get lost ???
// double check there is a mistake in the mib table
//
               case MIB_LM_DOMLOGONNUMBER:
               case MIB_LM_DOMLOGONTABLE:
               case MIB_LM_DOMLOGONENTRY:
               case MIB_LM_DOMLOGONUSER:
               case MIB_LM_DOMLOGONMACHINE:
#endif
            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Data not supported by function.\n" ));

               nResult = SNMPAPI_ERROR;
               goto Exit;
            }

         break;

      case MIB_ACTION_SET:
         switch ( LMData )
            {
                case MIB_LM_DOMOTHERNAME:
                        ;
            }
         break;


      default:
         // Signal an error

         nResult = SNMPAPI_ERROR;
         goto Exit;
      }


   return retval /*nResult*/;

Exit:
    if (cache_it)
    {
        SafeBufferFree(bufptr);
    }
    return retval /*nResult*/;
}



//
// MIB_leaf_func
//    Performs actions on LEAF variables in the MIB.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_leaf_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN RFC1157VarBind *VarBind
        )

{
lan_return_info_type *MibVal;
UINT                 nResult;

   switch ( Action )
      {
      case MIB_ACTION_GETNEXT:
         if ( MibPtr->MibNext == NULL )
            {
            nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
            }

         nResult = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                MibPtr->MibNext, VarBind );
         break;

      case MIB_ACTION_GETFIRST:

         // Check to see if this variable is accessible for GET
         if ( MibPtr->Access != MIB_ACCESS_READ &&
              MibPtr->Access != MIB_ACCESS_READWRITE )
         {
            if ( MibPtr->MibNext != NULL )
            {
               nResult = (*MibPtr->MibNext->MibFunc)( Action,
                                                      MibPtr->MibNext,
                                                      VarBind );
            }
            else
            {
               nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            }

            break;
         }
         else
         {
            // Place correct OID in VarBind
            AsnObjectIdentifier tmpOid;

            tmpOid = VarBind->name; // keep a copy (structure copy)
            if (!SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
                VarBind->name = tmpOid; // restore
                nResult = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                goto Exit;
            }
            if (!SnmpUtilOidAppend( &VarBind->name, &MibPtr->Oid ))
            {
                SnmpUtilOidFree(&VarBind->name);
                VarBind->name = tmpOid; // restore
                nResult = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                goto Exit;
            }
            // free the original VarBind->name
            SnmpUtilOidFree(&tmpOid);
         }

         // Purposefully let fall through to GET

      case MIB_ACTION_GET:
         // Make sure that this variable is GET'able
         if ( MibPtr->Access != MIB_ACCESS_READ &&
              MibPtr->Access != MIB_ACCESS_READWRITE )
            {
            nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
            }

         // Call the LM call to get data
         MibVal = (*MibPtr->LMFunc)( MIB_ACTION_GET, MibPtr->LMData, NULL );
         if ( MibVal == NULL )
            {
            nResult = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Setup varbind's return value
         VarBind->value.asnType = MibPtr->Type;
         switch ( MibPtr->Type )
            {
            case ASN_RFC1155_COUNTER:
            case ASN_RFC1155_GAUGE:
            case ASN_RFC1155_TIMETICKS:
            case ASN_INTEGER:
               VarBind->value.asnValue.number = MibVal->d.intval;
               break;

            case ASN_RFC1155_IPADDRESS:
            case ASN_RFC1155_OPAQUE:
            case ASN_OCTETSTRING:
               // This is non-standard copy of structure
               VarBind->value.asnValue.string = MibVal->d.octstrval;
               break;

            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Processing LAN Manager LEAF Variable\n" ));
               nResult = SNMP_ERRORSTATUS_GENERR;
               SnmpUtilMemFree( MibVal );
               goto Exit;
            } // type switch

         // Free memory alloc'ed by LM API call
         SnmpUtilMemFree( MibVal );
         nResult = SNMP_ERRORSTATUS_NOERROR;
         break;

      case MIB_ACTION_SET:
         // Check for writable attribute
         if ( MibPtr->Access != MIB_ACCESS_READWRITE &&
              MibPtr->Access != MIB_ACCESS_WRITE )
            {
            nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
            }

         // Check for proper type before setting
         if ( MibPtr->Type != VarBind->value.asnType )
            {
            nResult = SNMP_ERRORSTATUS_BADVALUE;
            goto Exit;
            }

         // Call LM routine to set variable
         switch ( VarBind->value.asnType )
            {
            case ASN_RFC1155_COUNTER:
            case ASN_INTEGER:
               if ( SNMPAPI_ERROR ==
                    (*MibPtr->LMFunc)(MIB_ACTION_SET, MibPtr->LMData,
                                      (void *)&VarBind->value.asnValue.number) )
                  {
                  nResult = SNMP_ERRORSTATUS_GENERR;
                  goto Exit;
                  }
               break;

            case ASN_OCTETSTRING: // This entails ASN_RFC1213_DISPSTRING also
               if ( SNMPAPI_ERROR ==
                    (*MibPtr->LMFunc)(MIB_ACTION_SET, MibPtr->LMData,
                                      (void *)&VarBind->value.asnValue.string) )
                  {
                  nResult = SNMP_ERRORSTATUS_GENERR;
                  goto Exit;
                  }
               break;
            default:
               SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Processing LAN Manager LEAF Variable\n" ));
               nResult = SNMP_ERRORSTATUS_GENERR;
               goto Exit;
            }

         nResult = SNMP_ERRORSTATUS_NOERROR;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Processing LAN Manager LEAF Variable\n" ));
         nResult = SNMP_ERRORSTATUS_GENERR;
      } // switch

Exit:
   return nResult;
} // MIB_leaf_func

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\mib.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mib.h

Abstract:

    LAN Manager MIB constants, types, and prototypes for implementing the LM
    MIB and its support functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef mib_h
#define mib_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>
#include <snmputil.h>

   // MIB Specifics
#define MIB_PREFIX_LEN            MIB_OidPrefix.idLength
#define MIB_TABLE                 0xe0   // High 3 bits not used by ASN
#define MIB_SRVC_NAME_LEN         15
#define MIB_SESS_CLIENT_NAME_LEN  15
#define MIB_SESS_USER_NAME_LEN    20
#define MIB_USER_NAME_LEN         20
#define MIB_SHARE_NAME_LEN        12
#define MIB_PRINTQ_NAME_LEN       12
#define MIB_USES_LOCAL_NAME_LEN   8
#define MIB_USES_REMOTE_LEN       255
#define MIB_DOM_OTHER_NAME_LEN    15
#define MIB_DOM_SERVER_NAME_LEN   15
#define MIB_DOM_LOGON_USER        20
#define MIB_DOM_LOGON_MACHINE     15


   // Start positions in MIB of first leaf of each group
#define MIB_COM_START          2
#define MIB_SV_START           10
#define MIB_WKSTA_START        45
#define MIB_DOM_START          55


   // MIB Node types
#define MIB_AGGREGATE          (MIB_TABLE | 0x0f)

   // MIB function actions
#define MIB_ACTION_GET         ASN_RFC1157_GETREQUEST
#define MIB_ACTION_SET         ASN_RFC1157_SETREQUEST
#define MIB_ACTION_GETNEXT     ASN_RFC1157_GETNEXTREQUEST
#define MIB_ACTION_GETFIRST    (MIB_TABLE | 0x00)
//#define MIB_ACTION_MATCH       (MIB_TABLE | 0x01)

   // MIB Variable access privileges
#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_ACCESS_NOT         3

   // MIB Variable status
#define MIB_STATUS_MANDATORY   0

   // LM operations -- COMMON group
#define MIB_LM_COMVERSIONMAJ          0
#define MIB_LM_COMVERSIONMIN          1
#define MIB_LM_COMTYPE                2
#define MIB_LM_COMSTATSTART           3
#define MIB_LM_COMSTATNUMNETIOS       4
#define MIB_LM_COMSTATFINETIOS        5
#define MIB_LM_COMSTATFCNETIOS        6

   // LM operations -- SERVER group
#define MIB_LM_SVDESCRIPTION          7
#define MIB_LM_SVSVCNUMBER            8
#define MIB_LM_SVSVCTABLE             9
#define MIB_LM_SVSVCENTRY             10
#define MIB_LM_SVSTATOPENS            16
#define MIB_LM_SVSTATDEVOPENS         17
#define MIB_LM_SVSTATQUEUEDJOBS       18
#define MIB_LM_SVSTATSOPENS           19
#define MIB_LM_SVSTATERROROUTS        20
#define MIB_LM_SVSTATPWERRORS         21
#define MIB_LM_SVSTATPERMERRORS       22
#define MIB_LM_SVSTATSYSERRORS        23
#define MIB_LM_SVSTATSENTBYTES        24
#define MIB_LM_SVSTATRCVDBYTES        25
#define MIB_LM_SVSTATAVRESPONSE       26
#define MIB_LM_SVSECURITYMODE         27
#define MIB_LM_SVUSERS                28
#define MIB_LM_SVSTATREQBUFSNEEDED    29
#define MIB_LM_SVSTATBIGBUFSNEEDED    30
#define MIB_LM_SVSESSIONNUMBER        31
#define MIB_LM_SVSESSIONTABLE         32
#define MIB_LM_SVSESSIONENTRY         33
#define MIB_LM_SVAUTODISCONNECTS      42
#define MIB_LM_SVDISCONTIME           43
#define MIB_LM_SVAUDITLOGSIZE         44
#define MIB_LM_SVUSERNUMBER           45
#define MIB_LM_SVUSERTABLE            46
#define MIB_LM_SVUSERENTRY            47
#define MIB_LM_SVSHARENUMBER          49
#define MIB_LM_SVSHARETABLE           50
#define MIB_LM_SVSHAREENTRY           51
#define MIB_LM_SVPRINTQNUMBER         55
#define MIB_LM_SVPRINTQTABLE          56
#define MIB_LM_SVPRINTQENTRY          57

   // LM operations -- WORKSTATION group
#define MIB_LM_WKSTASTATSESSSTARTS    60
#define MIB_LM_WKSTASTATSESSFAILS     61
#define MIB_LM_WKSTASTATUSES          62
#define MIB_LM_WKSTASTATUSEFAILS      63
#define MIB_LM_WKSTASTATAUTORECS      64
#define MIB_LM_WKSTAERRORLOGSIZE      65
#define MIB_LM_WKSTAUSENUMBER         66
#define MIB_LM_WKSTAUSETABLE          67
#define MIB_LM_WKSTAUSEENTRY          68

   // LM operations -- DOMAIN group
#define MIB_LM_DOMPRIMARYDOMAIN       72
#define MIB_LM_DOMLOGONDOMAIN         73
#define MIB_LM_DOMOTHERDOMAINNUMBER   74
#define MIB_LM_DOMOTHERDOMAINTABLE    75
#define MIB_LM_DOMOTHERDOMAINENTRY    76
#define MIB_LM_DOMOTHERNAME           77
#define MIB_LM_DOMSERVERNUMBER        78
#define MIB_LM_DOMSERVERTABLE         79
#define MIB_LM_DOMSERVERENTRY         80
#define MIB_LM_DOMLOGONNUMBER         82
#define MIB_LM_DOMLOGONTABLE          83
#define MIB_LM_DOMLOGONENTRY          84

   // Table matching constants
#define MIB_TBL_POS_FOUND    0
#define MIB_TBL_POS_BEFORE   -1
#define MIB_TBL_POS_END      -2

//--------------------------- PUBLIC STRUCTS --------------------------------

   // MIB generic data type
typedef ULONG LDATA;

   // MIB variable definition
typedef struct mib_entry
           {
	   AsnObjectIdentifier Oid;
	   BYTE                Type;
	   UINT                Access;
	   UINT                Status;
	   int                 Leaf;
           void *              (*LMFunc)( UINT, LDATA, void * );
	   UINT                (*MibFunc)( UINT, struct mib_entry *,
	                                   RFC1157VarBind * );
	   UINT                LMData;
	   struct mib_entry    *MibNext;
	   } MIB_ENTRY;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

   // Internal MIB structure
extern MIB_ENTRY Mib[];
extern UINT      MIB_num_variables;

   // Prefix to every variable in the LM MIB
extern AsnObjectIdentifier MIB_OidPrefix;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

MIB_ENTRY *MIB_get_entry(
              IN AsnObjectIdentifier *Oid
	      );

SNMPAPI MakeOidFromStr(
	   IN AsnDisplayString *Str,    // String to make OID
           OUT AsnObjectIdentifier *Oid // Resulting OID
	   );

//------------------------------- END ---------------------------------------

#endif /* mib_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\mib.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mib.c

Abstract:

    Contains definition of LAN Manager MIB.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>

#include "mibfuncs.h"
#include "hash.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "mib.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // If an addition or deletion to the MIB is necessary, there are several
   // places in the code that must be checked and possibly changed.
   //
   // 1.  There are 4 constants that are used as indexes to the start of each
   //     group in the MIB.  These are defined in MIB.H and must be adjusted
   //     to reflect any changes that affect them.
   //
   // 2.  The last field in each MIB entry is used to point to the NEXT
   //     leaf variable or table root.  If an AGGREGATE is next in the MIB,
   //     this pointer should skip it, because an AGGREGATE can never be
   //     accessed.  The last variable in the MIB is NULL.  Using the constants
   //     defined in step 1 above provides some flexibility.
   //
   // 3.  Following the MIB is a table of TABLE pointers into the MIB.  These
   //     pointers must be updated to reflect any changes made to the MIB.
   //     Each entry should point to the variable immediately below the table
   //     root.  (ie The entry in the table for "Session Table" should point
   //     to the MIB variable { svSessionTable 1 } in the server group.)

   // The prefix to all of the LM mib names is 1.3.6.1.4.1.77.1
UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 77, 1 };
AsnObjectIdentifier MIB_OidPrefix = { sizeof OID_Prefix / sizeof(UINT),
                                      OID_Prefix };

   // OID definitions for MIB -- group partitions
UINT MIB_common_group[] = { 1 };
UINT MIB_server_group[] = { 2 };
UINT MIB_wksta_group[]  = { 3 };
UINT MIB_domain_group[] = { 4 };

   // OID definitions for MIB -- COMMON group
UINT MIB_comVersionMaj[]    = { 1, 1, 0 };
UINT MIB_comVersionMin[]    = { 1, 2, 0 };
UINT MIB_comType[]          = { 1, 3, 0 };
UINT MIB_comStatStart[]     = { 1, 4, 0 };
UINT MIB_comStatNumNetIOs[] = { 1, 5, 0 };
UINT MIB_comStatFiNetIOs[]  = { 1, 6, 0 };
UINT MIB_comStatFcNetIOs[]  = { 1, 7, 0 };

   // OID definitions for MIB -- SERVER group
UINT MIB_svDescription[]         = { 2, 1, 0 };
UINT MIB_svSvcNumber[]           = { 2, 2, 0 };
UINT MIB_svSvcTable[]            = { 2, 3 };
UINT MIB_svSvcEntry[]            = { 2, 3, 1 };
UINT MIB_svStatOpens[]           = { 2, 4, 0 };
UINT MIB_svStatDevOpens[]        = { 2, 5, 0 };
UINT MIB_svStatQueuedJobs[]      = { 2, 6, 0 };
UINT MIB_svStatSOpens[]          = { 2, 7, 0 };
UINT MIB_svStatErrorOuts[]       = { 2, 8, 0 };
UINT MIB_svStatPwErrors[]        = { 2, 9, 0 };
UINT MIB_svStatPermErrors[]      = { 2, 10, 0 };
UINT MIB_svStatSysErrors[]       = { 2, 11, 0 };
UINT MIB_svStatSentBytes[]       = { 2, 12, 0 };
UINT MIB_svStatRcvdBytes[]       = { 2, 13, 0 };
UINT MIB_svStatAvResponse[]      = { 2, 14, 0 };
UINT MIB_svSecurityMode[]        = { 2, 15, 0 };
UINT MIB_svUsers[]               = { 2, 16, 0 };
UINT MIB_svStatReqBufsNeeded[]   = { 2, 17, 0 };
UINT MIB_svStatBigBufsNeeded[]   = { 2, 18, 0 };
UINT MIB_svSessionNumber[]       = { 2, 19, 0 };
UINT MIB_svSessionTable[]        = { 2, 20 };
UINT MIB_svSessionEntry[]        = { 2, 20, 1 };
UINT MIB_svAutoDisconnects[]     = { 2, 21, 0 };
UINT MIB_svDisConTime[]          = { 2, 22, 0 };
UINT MIB_svAuditLogSize[]        = { 2, 23, 0 };
UINT MIB_svUserNumber[]          = { 2, 24, 0 };
UINT MIB_svUserTable[]           = { 2, 25 };
UINT MIB_svUserEntry[]           = { 2, 25, 1 };
UINT MIB_svShareNumber[]         = { 2, 26, 0 };
UINT MIB_svShareTable[]          = { 2, 27 };
UINT MIB_svShareEntry[]          = { 2, 27, 1 };
UINT MIB_svPrintQNumber[]        = { 2, 28, 0 };
UINT MIB_svPrintQTable[]         = { 2, 29 };
UINT MIB_svPrintQEntry[]         = { 2, 29, 1 };

   // OID definitions for MIB - WORKSTATION group
UINT MIB_wkstaStatSessStarts[] = { 3, 1, 0 };
UINT MIB_wkstaStatSessFails[]  = { 3, 2, 0 };
UINT MIB_wkstaStatUses[]       = { 3, 3, 0 };
UINT MIB_wkstaStatUseFails[]   = { 3, 4, 0 };
UINT MIB_wkstaStatAutoRecs[]   = { 3, 5, 0 };
UINT MIB_wkstaErrorLogSize[]   = { 3, 6, 0 };
UINT MIB_wkstaUseNumber[]      = { 3, 7, 0 };
UINT MIB_wkstaUseTable[]       = { 3, 8 };
UINT MIB_wkstaUseEntry[]       = { 3, 8, 1 };

   // OID definitions for MIB - DOMAIN group
UINT MIB_domPrimaryDomain[]     = { 4, 1, 0 };
UINT MIB_domLogonDomain[]       = { 4, 2, 0 };
UINT MIB_domOtherDomainNumber[] = { 4, 3, 0 };
UINT MIB_domOtherDomainTable[]  = { 4, 4 };
UINT MIB_domOtherDomainEntry[]  = { 4, 4, 1 };
UINT MIB_domServerNumber[]      = { 4, 5, 0 };
UINT MIB_domServerTable[]       = { 4, 6 };
UINT MIB_domServerEntry[]       = { 4, 6, 1 };
UINT MIB_domLogonNumber[]       = { 4, 7, 0 };
UINT MIB_domLogonTable[]        = { 4, 8 };
UINT MIB_domLogonEntry[]        = { 4, 8, 1 };


   // LAN Manager MIB definiton
MIB_ENTRY Mib[] = {

             // LAN MGR 2 Root

          { { 0, NULL }, MIB_AGGREGATE, // { lanmanager 1 }
            0, 0, FALSE,
            NULL, NULL, 0,
            &Mib[MIB_COM_START] },

             // COMMON group

          { { 1, MIB_common_group }, MIB_AGGREGATE, // { lanmgr-2 1 }
            0, 0, FALSE,
            NULL, NULL, 0,
            &Mib[MIB_COM_START] },

          { { 3, MIB_comVersionMaj }, ASN_OCTETSTRING, // { common 1 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMVERSIONMAJ,
            &Mib[MIB_COM_START+1] },
          { { 3, MIB_comVersionMin }, ASN_OCTETSTRING, // { common 2 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMVERSIONMIN,
            &Mib[MIB_COM_START+2] },
          { { 3, MIB_comType }, ASN_OCTETSTRING, // { common 3 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMTYPE,
            &Mib[MIB_COM_START+3] },
          { { 3, MIB_comStatStart }, ASN_INTEGER, // { common 4 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMSTATSTART,
            &Mib[MIB_COM_START+4] },
          { { 3, MIB_comStatNumNetIOs }, ASN_RFC1155_COUNTER, // { common 5 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMSTATNUMNETIOS,
            &Mib[MIB_COM_START+5] },
          { { 3, MIB_comStatFiNetIOs }, ASN_RFC1155_COUNTER, // { common 6 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMSTATFINETIOS,
            &Mib[MIB_COM_START+6] },
          { { 3, MIB_comStatFcNetIOs }, ASN_RFC1155_COUNTER, // { common 7 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_common_func, MIB_leaf_func, MIB_LM_COMSTATFCNETIOS,
            &Mib[MIB_SV_START] },

             // SERVER group

          { { 1, MIB_server_group }, MIB_AGGREGATE, // { lanmgr-2 2 }
            0, 0, FALSE,
            NULL, NULL, 0,
            &Mib[MIB_SV_START] },

          { { 3, MIB_svDescription }, ASN_RFC1213_DISPSTRING, // { Server 1 }
            MIB_ACCESS_READWRITE, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVDESCRIPTION,
            &Mib[MIB_SV_START+1] },
          { { 3, MIB_svSvcNumber }, ASN_INTEGER, // { Server 2 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSVCNUMBER,
            &Mib[MIB_SV_START+3] },
          { { 2, MIB_svSvcTable }, MIB_AGGREGATE, // { Server 3 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_SVSVCTABLE,
            &Mib[MIB_SV_START+3] },
          { { 3, MIB_svSvcEntry }, MIB_TABLE, // { svSvcTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_srvcs_func, MIB_LM_SVSVCENTRY,
            &Mib[MIB_SV_START+4] },
          { { 3, MIB_svStatOpens }, ASN_RFC1155_COUNTER, // { server 4 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATOPENS,
            &Mib[MIB_SV_START+5] },
          { { 3, MIB_svStatDevOpens }, ASN_RFC1155_COUNTER, // { server 5 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATDEVOPENS,
            &Mib[MIB_SV_START+6] },
          { { 3, MIB_svStatQueuedJobs }, ASN_RFC1155_COUNTER, // { server 6 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATQUEUEDJOBS,
            &Mib[MIB_SV_START+7] },
          { { 3, MIB_svStatSOpens }, ASN_RFC1155_COUNTER, // { server 7 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATSOPENS,
            &Mib[MIB_SV_START+8] },
          { { 3, MIB_svStatErrorOuts }, ASN_RFC1155_COUNTER, // { server 8 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATERROROUTS,
            &Mib[MIB_SV_START+9] },
          { { 3, MIB_svStatPwErrors }, ASN_RFC1155_COUNTER, // { server 9 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATPWERRORS,
            &Mib[MIB_SV_START+10] },
          { { 3, MIB_svStatPermErrors }, ASN_RFC1155_COUNTER, // { server 10 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATPERMERRORS,
            &Mib[MIB_SV_START+11] },
          { { 3, MIB_svStatSysErrors }, ASN_RFC1155_COUNTER, // { server 11 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATSYSERRORS,
            &Mib[MIB_SV_START+12] },
          { { 3, MIB_svStatSentBytes }, ASN_RFC1155_COUNTER, // { server 12 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATSENTBYTES,
            &Mib[MIB_SV_START+13] },
          { { 3, MIB_svStatRcvdBytes }, ASN_RFC1155_COUNTER, // { server 13 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATRCVDBYTES,
            &Mib[MIB_SV_START+14] },
          { { 3, MIB_svStatAvResponse }, ASN_INTEGER, // { server 14 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATAVRESPONSE,
            &Mib[MIB_SV_START+15] },
          { { 3, MIB_svSecurityMode }, ASN_INTEGER, // { server 15 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSECURITYMODE,
            &Mib[MIB_SV_START+16] },
          { { 3, MIB_svUsers }, ASN_INTEGER, // { server 16 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVUSERS,
            &Mib[MIB_SV_START+17] },
          { { 3, MIB_svStatReqBufsNeeded }, ASN_RFC1155_COUNTER, // { server 17}
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATREQBUFSNEEDED,
            &Mib[MIB_SV_START+18] },
          { { 3, MIB_svStatBigBufsNeeded }, ASN_RFC1155_COUNTER, // { server 18}
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSTATBIGBUFSNEEDED,
            &Mib[MIB_SV_START+19] },
          { { 3, MIB_svSessionNumber }, ASN_INTEGER, // { server 19 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSESSIONNUMBER,
            &Mib[MIB_SV_START+21] },
          { { 2, MIB_svSessionTable }, MIB_AGGREGATE, // { server 20 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_SVSESSIONTABLE,
            &Mib[MIB_SV_START+21] },
          { { 3, MIB_svSessionEntry }, MIB_TABLE, // { svSessionTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_sess_func, MIB_LM_SVSESSIONENTRY,
            &Mib[MIB_SV_START+22] },
          { { 3, MIB_svAutoDisconnects }, ASN_INTEGER, // { server 21 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVAUTODISCONNECTS,
            &Mib[MIB_SV_START+23] },
          { { 3, MIB_svDisConTime }, ASN_INTEGER, // { server 22 }
            MIB_ACCESS_READWRITE, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVDISCONTIME,
#if 0
            &Mib[MIB_SV_START+24] },
#else
            &Mib[MIB_SV_START+25] },
#endif
          { { 3, MIB_svAuditLogSize }, ASN_INTEGER, // { server 23 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVAUDITLOGSIZE,
            &Mib[MIB_SV_START+25] },
          { { 3, MIB_svUserNumber }, ASN_INTEGER, // { server 24 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVUSERNUMBER,
            &Mib[MIB_SV_START+27] },
          { { 2, MIB_svUserTable }, MIB_AGGREGATE, // { server 25 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_SVUSERTABLE,
            &Mib[MIB_SV_START+27] },
          { { 3, MIB_svUserEntry }, MIB_TABLE, // { svUserTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_users_func, MIB_LM_SVUSERENTRY,
            &Mib[MIB_SV_START+28] },
          { { 3, MIB_svShareNumber }, ASN_INTEGER, // { server 26 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVSHARENUMBER,
            &Mib[MIB_SV_START+30] },
          { { 2, MIB_svShareTable }, MIB_AGGREGATE, // { server 27 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_SVSHARETABLE,
            &Mib[MIB_SV_START+30] },
          { { 3, MIB_svShareEntry }, MIB_TABLE, // { svShareTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_shares_func, MIB_LM_SVSHAREENTRY,
            &Mib[MIB_SV_START+31] },
          { { 3, MIB_svPrintQNumber }, ASN_INTEGER, // { server 28 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_server_func, MIB_leaf_func, MIB_LM_SVPRINTQNUMBER,
            &Mib[MIB_SV_START+33] },
          { { 2, MIB_svPrintQTable }, MIB_AGGREGATE, // { server 29 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_SVPRINTQTABLE,
            &Mib[MIB_SV_START+33] },
          { { 3, MIB_svPrintQEntry }, MIB_TABLE, // { svPrintQTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_prntq_func, MIB_LM_SVPRINTQENTRY,
            &Mib[MIB_WKSTA_START] },

          // WORKSTATION group

          { { 1, MIB_wksta_group }, MIB_AGGREGATE, // { lanmgr-2 3 }
            0, 0, FALSE,
            NULL, NULL, 0,
            &Mib[MIB_WKSTA_START] },

          { { 3, MIB_wkstaStatSessStarts }, ASN_RFC1155_COUNTER, // { wrksta 1 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTASTATSESSSTARTS,
            &Mib[MIB_WKSTA_START+1] },
          { { 3, MIB_wkstaStatSessFails }, ASN_RFC1155_COUNTER, // { wrksta 2 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTASTATSESSFAILS,
            &Mib[MIB_WKSTA_START+2] },
          { { 3, MIB_wkstaStatUses }, ASN_RFC1155_COUNTER, // { wrksta 3 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTASTATUSES,
            &Mib[MIB_WKSTA_START+3] },
          { { 3, MIB_wkstaStatUseFails }, ASN_RFC1155_COUNTER, // { wrksta 4 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTASTATUSEFAILS,
            &Mib[MIB_WKSTA_START+4] },
          { { 3, MIB_wkstaStatAutoRecs }, ASN_RFC1155_COUNTER, // { wrksta 5 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTASTATAUTORECS,
#if 0
            &Mib[MIB_WKSTA_START+5] },
#else
            &Mib[MIB_WKSTA_START+6] },
#endif
          { { 3, MIB_wkstaErrorLogSize }, ASN_INTEGER, // { wrksta 6 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTAERRORLOGSIZE,
            &Mib[MIB_WKSTA_START+6] },
          { { 3, MIB_wkstaUseNumber }, ASN_INTEGER, // { wrksta 7 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_workstation_func, MIB_leaf_func, MIB_LM_WKSTAUSENUMBER,
            &Mib[MIB_WKSTA_START+8] },
          { { 2, MIB_wkstaUseTable }, MIB_AGGREGATE, // { wrksta 8 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_WKSTAUSETABLE,
            &Mib[MIB_WKSTA_START+8] },
          { { 3, MIB_wkstaUseEntry }, MIB_TABLE, // { wrkstaUseTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_wsuses_func, MIB_LM_WKSTAUSEENTRY,
            &Mib[MIB_DOM_START] },

             // DOMAIN group

          { { 1, MIB_domain_group }, MIB_AGGREGATE, // { lanmgr-2 4 }
            0, 0, FALSE,
            NULL, NULL, 0,
            &Mib[MIB_DOM_START] },

          { { 3, MIB_domPrimaryDomain }, ASN_RFC1213_DISPSTRING, // { domain 1 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_domain_func, MIB_leaf_func, MIB_LM_DOMPRIMARYDOMAIN,
#if 0
            &Mib[MIB_DOM_START+1] },
#else
            NULL },
#endif
          { { 3, MIB_domLogonDomain }, ASN_RFC1213_DISPSTRING, // { domain 2 }
#if 0
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
#else
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, TRUE,
#endif
            MIB_domain_func, MIB_leaf_func, MIB_LM_DOMLOGONDOMAIN,
            &Mib[MIB_DOM_START+2] },
          { { 3, MIB_domOtherDomainNumber }, ASN_INTEGER, // { domain 3 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_domain_func, MIB_leaf_func, MIB_LM_DOMOTHERDOMAINNUMBER,
            &Mib[MIB_DOM_START+4] },
          { { 2, MIB_domOtherDomainTable }, MIB_AGGREGATE, // { domain 4 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_DOMOTHERDOMAINTABLE,
            &Mib[MIB_DOM_START+4] },
          { { 3, MIB_domOtherDomainEntry }, MIB_TABLE, // { domOtherDomTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_odoms_func, MIB_LM_DOMOTHERDOMAINENTRY,
            &Mib[MIB_DOM_START+5] },
          { { 3, MIB_domServerNumber }, ASN_INTEGER, // { domain 5 }
            MIB_ACCESS_READ, MIB_STATUS_MANDATORY, TRUE,
            MIB_domain_func, MIB_leaf_func, MIB_LM_DOMSERVERNUMBER,
            &Mib[MIB_DOM_START+7] },
          { { 2, MIB_domServerTable }, MIB_AGGREGATE, // { domain 6 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, NULL, MIB_LM_DOMSERVERTABLE,
            &Mib[MIB_DOM_START+7] },
          { { 3, MIB_domServerEntry }, MIB_TABLE, // { domServerTable 1 }
            MIB_ACCESS_NOT, MIB_STATUS_MANDATORY, FALSE,
            NULL, MIB_svsond_func, MIB_LM_DOMSERVERENTRY,
            NULL }
          };
UINT MIB_num_variables = sizeof Mib / sizeof( MIB_ENTRY );


//
// List of table pointers - References must agree with MIB
//
MIB_ENTRY *MIB_Tables[] = {
             &Mib[MIB_SV_START+3],     // Service
             &Mib[MIB_SV_START+21],    // Session
             &Mib[MIB_SV_START+27],    // User
             &Mib[MIB_SV_START+30],    // Share
             &Mib[MIB_SV_START+33],    // Print Queue
             &Mib[MIB_WKSTA_START+8],  // Uses
             &Mib[MIB_DOM_START+4],    // Other domain
             &Mib[MIB_DOM_START+7]     // Server
             };
UINT MIB_table_list_size = sizeof MIB_Tables / sizeof( MIB_ENTRY * );

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_get_entry
//    Lookup OID in MIB, and return pointer to its entry.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    SNMP_MIB_UNKNOWN_OID
//
MIB_ENTRY *MIB_get_entry(
              IN AsnObjectIdentifier *Oid
              )

{
AsnObjectIdentifier TempOid;
UINT                I;
MIB_ENTRY           *pResult;


   // Check prefix
   if ( SnmpUtilOidNCmp(&MIB_OidPrefix, Oid, MIB_PREFIX_LEN) )
      {
      pResult = NULL;
      goto Exit;
      }

   // Strip prefix by placing in temp
   TempOid.idLength = Oid->idLength - MIB_PREFIX_LEN;
   TempOid.ids      = &Oid->ids[MIB_PREFIX_LEN];

   // Get pointer into MIB
   pResult = MIB_HashLookup( &TempOid );

   // Check for possible table entry
   if ( pResult == NULL )
      {
      for ( I=0;I < MIB_table_list_size;I++ )
         {
         if ( !SnmpUtilOidNCmp(&TempOid, &MIB_Tables[I]->Oid,
                            MIB_Tables[I]->Oid.idLength) )
            {
            pResult = MIB_Tables[I];
            goto Exit;
            }
         }
      }

Exit:
   return pResult;
} // MIB_get_entry



//
// MakeOidFromStr
//    Makes an OID out of string so a table can be indexed.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None.
//
SNMPAPI MakeOidFromStr(
           IN AsnDisplayString *Str,    // String to make OID
           OUT AsnObjectIdentifier *Oid // Resulting OID
           )

{
    UINT    I;
    SNMPAPI nResult = SNMPAPI_NOERROR;


    if ( NULL == (Oid->ids = SnmpUtilMemAlloc((Str->length+1) * sizeof(UINT))) )
    {
        SetLastError(SNMP_MEM_ALLOC_ERROR);
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // Place length as first OID sub-id
    Oid->ids[0] = Str->length;

    // Place each character of string as sub-id
    for ( I=0;I < Str->length;I++ )
    {
        Oid->ids[I+1] = Str->stream[I];
    }

    Oid->idLength = Str->length + 1;


Exit:
    return nResult;
} // MakeOidFromStr

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\mibfuncs.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mibfuncs.h

Abstract:

    All constants, types, and prototypes to support the MIB manipulation
    functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef mibfuncs_h
#define mibfuncs_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#include "mib.h"

//--------------------------- PUBLIC STRUCTS --------------------------------

// Return type from LAN Manager conver functions
typedef struct lan_return_info_type {

	unsigned int size ;
	unsigned int data_element_type;
	union {
		AsnInteger intval;
		AsnOctetString octstrval;
	} d ;
} lan_return_info_type ;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

//--------------------------- PUBLIC PROTOTYPES -----------------------------

void * MIB_common_func(
           IN UINT Action,   // Action to perform on Data
	   IN LDATA LMData,  // LM Data to manipulate
	   IN void *SetData  // Data to use in a SET
	   );

void * MIB_server_func(
           IN UINT Action,   // Action to perform on Data
	   IN LDATA LMData,    // LM Data to manipulate
	   IN void *SetData  // Data to use in a SET
	   );

void * MIB_workstation_func(
           IN UINT Action,   // Action to perform on Data
	   IN LDATA LMData,    // LM Data to manipulate
	   IN void *SetData  // Data to use in a SET
	   );

void * MIB_domain_func(
           IN UINT Action,   // Action to perform on Data
	   IN LDATA LMData,    // LM Data to manipulate
	   IN void *SetData  // Data to use in a SET
	   );

UINT MIB_srvcs_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_sess_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_users_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_shares_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_prntq_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_wsuses_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_odoms_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_svsond_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_dlogons_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        );

UINT MIB_leaf_func(
        IN UINT Action,
	IN MIB_ENTRY *MibPtr,
	IN RFC1157VarBind *VarBind
	);

//
// Prototype for AdminFilter function
//

VOID
AdminFilter(
    DWORD           Level,
    LPDWORD         pEntriesRead,
    LPBYTE          ShareInfo
    );

//------------------------------- END ---------------------------------------

#endif /* mibfuncs_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\odom_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    odom_tbl.h

Abstract:

    Define the structures and routines used in the other domain table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef odom_tbl_h
#define odom_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define ODOM_NAME_FIELD        1

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the other domain table
typedef struct dom_other_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString domOtherName;
	   } DOM_OTHER_ENTRY;

   // Other domain table definition
typedef struct
           {
	   UINT            Len;
	   DOM_OTHER_ENTRY *Table;
           } DOM_OTHER_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern DOM_OTHER_TABLE  MIB_DomOtherDomainTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_odoms_lmget(
           void
	   );

int MIB_odoms_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_odoms_lmset(
        IN AsnObjectIdentifier *Index,
	IN UINT Field,
	IN AsnAny *Value
	);

//------------------------------- END ---------------------------------------

#endif /* odom_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\odom_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    odom_tbl.c

Abstract:

    Routines supporting operations on the Other Domain Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "odom_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Other Domain table
static UINT                odomSubids[] = { 4, 4, 1 };
static AsnObjectIdentifier MIB_DomOtherDomainPrefix = { 3, odomSubids };

DOM_OTHER_TABLE  MIB_DomOtherDomainTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define ODOM_FIELD_SUBID       (MIB_DomOtherDomainPrefix.idLength + \
                                MIB_OidPrefix.idLength)

#define ODOM_FIRST_FIELD       ODOM_NAME_FIELD
#define ODOM_LAST_FIELD        ODOM_NAME_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_odoms_get(
        IN OUT RFC1157VarBind *VarBind
    );

UINT MIB_odoms_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_odoms_func
//    High level routine for handling operations on the Other Domain table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_odoms_func(
    IN UINT Action,
        IN MIB_ENTRY *MibPtr,
    IN OUT RFC1157VarBind *VarBind
    )

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Other Domain table with the info from server
         if ( SNMPAPI_ERROR == MIB_odoms_lmget() )
        {
        ErrStat = SNMP_ERRORSTATUS_GENERR;
        goto Exit;
        }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_DomOtherDomainTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { ODOM_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };
         AsnObjectIdentifier tmpOid;

         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (! SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_DomOtherDomainPrefix ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_DomOtherDomainTable.Table[0].Oid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_odoms_get( VarBind );
     break;

      case MIB_ACTION_GETNEXT:
         // Fill the Other Domain Table with the info from server
         if ( SNMPAPI_ERROR == MIB_odoms_lmget() )
        {
        ErrStat = SNMP_ERRORSTATUS_GENERR;
        goto Exit;
        }

         // Determine which field
         Field = VarBind->name.ids[ODOM_FIELD_SUBID];

         // Lookup OID in table
         if (Field < ODOM_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = ODOM_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > ODOM_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_odoms_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_DomOtherDomainTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > ODOM_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_DomOtherDomainTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > ODOM_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;
         AsnObjectIdentifier tmpOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;               

         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (! SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_DomOtherDomainPrefix ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_DomOtherDomainTable.Table[Entry].Oid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_odoms_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         // Make sure OID is long enough
     if ( ODOM_FIELD_SUBID + 1 > VarBind->name.idLength )
            {
        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
        goto Exit;
        }

     // Get field number
     Field = VarBind->name.ids[ODOM_FIELD_SUBID];

     // If the field being set is not the NAME field, error
     if ( Field != ODOM_NAME_FIELD )
        {
        ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
        }

         // Check for proper type before setting
         if ( ASN_RFC1213_DISPSTRING != VarBind->value.asnType )
        {
        ErrStat = SNMP_ERRORSTATUS_BADVALUE;
        goto Exit;
        }

     // Call LM set routine
     ErrStat = MIB_odoms_lmset( &VarBind->name, Field, &VarBind->value );

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_odoms_func



//
// MIB_odoms_get
//    Retrieve Other Domain Table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_odoms_get(
        IN OUT RFC1157VarBind *VarBind
    )

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[ODOM_FIELD_SUBID] < ODOM_FIRST_FIELD ||
       VarBind->name.ids[ODOM_FIELD_SUBID] > ODOM_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }
   
   // Fill the Other Domain Table with the info from server
   if ( SNMPAPI_ERROR == MIB_odoms_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_odoms_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_odoms_copyfromtable( Entry,
                                      VarBind->name.ids[ODOM_FIELD_SUBID],
                                      VarBind );

Exit:
   return ErrStat;
} // MIB_odoms_get



//
// MIB_odoms_match
//    Match the target OID with a location in the Other Domain Table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_odoms_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_DomOtherDomainPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_DomOtherDomainPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_DomOtherDomainTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_DomOtherDomainTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_odoms_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_odoms_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case ODOM_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_DomOtherDomainTable.Table[Entry].domOtherName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_DomOtherDomainTable.Table[Entry].domOtherName.stream,
                       MIB_DomOtherDomainTable.Table[Entry].domOtherName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_DomOtherDomainTable.Table[Entry].domOtherName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Other Domain Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_odoms_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\resolve.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    resolve.h

Abstract:

    All constants, types, and prototypes to resolve Variable Bindings.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef resolve_h
#define resolve_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

//--------------------------- PUBLIC STRUCTS --------------------------------

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

//--------------------------- PUBLIC PROTOTYPES -----------------------------

//------------------------------- END ---------------------------------------

#endif /* resolve_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\prnt_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    prnt_tbl.c

Abstract:

    Routines supporting operations on the Print Queue table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "prnt_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Print Queue table
static UINT                printQSubids[] = { 2, 29, 1 };
static AsnObjectIdentifier MIB_PrintQPrefix = { 3, printQSubids };

PRINTQ_TABLE     MIB_PrintQTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define PRNTQ_FIELD_SUBID     (MIB_PrintQPrefix.idLength+MIB_OidPrefix.idLength)

#define PRNTQ_FIRST_FIELD      PRNTQ_NAME_FIELD
#define PRNTQ_LAST_FIELD       PRNTQ_JOBS_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_prntq_get(
        IN OUT RFC1157VarBind *VarBind
        );

int MIB_prntq_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_prntq_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_prntq_func
//    High level routine for handling operations on the print queue table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_prntq_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        )

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Print Queue table with the info from server
         if ( SNMPAPI_ERROR == MIB_prntq_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_PrintQTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { PRNTQ_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };

         // prefix bug 445188
         AsnObjectIdentifier tmpOid;
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_PrintQPrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_PrintQTable.Table[0].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_prntq_get( VarBind );
	 break;

      case MIB_ACTION_GETNEXT:
         // Fill the Print Queue table with the info from server
         if ( SNMPAPI_ERROR == MIB_prntq_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // Determine which field
         Field = VarBind->name.ids[PRNTQ_FIELD_SUBID];

        // Lookup OID in table
         if (Field < PRNTQ_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = PRNTQ_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > PRNTQ_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_prntq_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_PrintQTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > PRNTQ_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_PrintQTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > PRNTQ_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;

         AsnObjectIdentifier tmpOid; // prefix bug 445188
         
         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         // prefix bug 445188  
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_PrintQPrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_PrintQTable.Table[Entry].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_prntq_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
	 break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_prntq_func



//
// MIB_prntq_get
//    Retrieve print queue table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_prntq_get(
        IN OUT RFC1157VarBind *VarBind
	)

{
UINT   Entry;
int    Found = MIB_TBL_POS_END;
UINT   ErrStat;

   if (VarBind->name.ids[PRNTQ_FIELD_SUBID] < PRNTQ_FIRST_FIELD ||
       VarBind->name.ids[PRNTQ_FIELD_SUBID] > PRNTQ_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Print Queue table with the info from server
   if ( SNMPAPI_ERROR == MIB_prntq_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   // Prefix # 118016
   // make sure  MIB_prntq_lmget doesn't invalid the global MIB_PrintQTable.Table
   if (MIB_PrintQTable.Table)
      Found = MIB_prntq_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_prntq_copyfromtable( Entry,
                                      VarBind->name.ids[PRNTQ_FIELD_SUBID],
                                      VarBind );

Exit:
   return ErrStat;
} // MIB_prntq_get



//
// MIB_prntq_match
//    Match the target OID with a location in the Print Queue table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_prntq_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_PrintQPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_PrintQPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_PrintQTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_PrintQTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_prntq_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_prntq_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case PRNTQ_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_PrintQTable.Table[Entry].svPrintQName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_PrintQTable.Table[Entry].svPrintQName.stream,
                       MIB_PrintQTable.Table[Entry].svPrintQName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_PrintQTable.Table[Entry].svPrintQName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case PRNTQ_JOBS_FIELD:
         VarBind->value.asnValue.number =
                               MIB_PrintQTable.Table[Entry].svPrintQNumJobs;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Print Queue Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_prntq_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\sess_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    sess_lm.c

Abstract:

    This file contains MIB_sess_lmget, which actually call lan manager
    for the session table, copies it into structures, and sorts it to
    return ready to use by the higher level functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "sess_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)       if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

int __cdecl sess_entry_cmp(
       IN const SESS_ENTRY *A,
       IN const SESS_ENTRY *B
       ) ;

BOOL build_sess_entry_oids( );

void FreeSessTable();

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_sess_lmset
//    Perform the necessary actions to SET a field in the Session Table.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None.
//
UINT MIB_sess_lmset(
        IN AsnObjectIdentifier *Index,
        IN UINT Field,
        IN AsnAny *Value
        )

{
NET_API_STATUS lmCode;
int            Found;
UINT           Entry;
AsnInteger     ErrStat = SNMP_ERRORSTATUS_NOERROR;
char           Client[MAX_PATH];
char           User[MAX_PATH];
#ifdef UNICODE
LPWSTR         UniClient;
LPWSTR         UniUser;
#endif


   // Must make sure the table is in memory
   if ( SNMPAPI_ERROR == MIB_sess_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   // Find a match in the table
   if ( MIB_TBL_POS_FOUND != MIB_sess_match(Index, &Entry, FALSE) )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Check for action on Table
   if ( Value->asnValue.number == SESS_STATE_DELETED )
      {
      strcpy( Client, "\\\\" );
      if (MIB_SessionTable.Table[Entry].svSesClientName.length <= MAX_PATH-3)
        {
        memcpy( &Client[2], MIB_SessionTable.Table[Entry].svSesClientName.stream,
                       MIB_SessionTable.Table[Entry].svSesClientName.length );
        Client[MIB_SessionTable.Table[Entry].svSesClientName.length+2] = '\0';
        }
      else
        {
        ErrStat = SNMP_ERRORSTATUS_GENERR;
        goto Exit;
        }

      if (MIB_SessionTable.Table[Entry].svSesUserName.length <= MAX_PATH-1)
        {
        memcpy( User, MIB_SessionTable.Table[Entry].svSesUserName.stream,
                    MIB_SessionTable.Table[Entry].svSesUserName.length );
        User[MIB_SessionTable.Table[Entry].svSesUserName.length] = '\0';
        }
      else
        {
        ErrStat = SNMP_ERRORSTATUS_GENERR;
        goto Exit;
        }


#ifdef UNICODE
      if (SnmpUtilUTF8ToUnicode(&UniClient,
                                Client,
                                TRUE ))
      {
          ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
          goto Exit;
      }
      if (SnmpUtilUTF8ToUnicode(&UniUser,
                                User,
                                TRUE ))
      {
          SnmpUtilMemFree(UniClient);
          ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
          goto Exit;
      }

      lmCode = NetSessionDel( NULL, UniClient, UniUser );
      SnmpUtilMemFree(UniClient);
      SnmpUtilMemFree(UniUser);
#else
      // Call the LM API to delete it
      lmCode = NetSessionDel( NULL, Client, User );
#endif

      // Check for successful operation
      switch( lmCode )
         {
         case NERR_Success:
            // Make cache be reloaded next time
            cache_table[C_SESS_TABLE].bufptr = NULL;
            break;

         case NERR_ClientNameNotFound:
         case NERR_UserNotFound:
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            break;

         default:
            ErrStat = SNMP_ERRORSTATUS_GENERR;
         }
      }

Exit:
   return ErrStat;
} // MIB_sess_lmset



//
// MIB_sess_lmget
//    Retrieve session table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_sess_lmget(
           )

{

DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr=NULL;
unsigned lmCode;
unsigned i;
SESSION_INFO_2 *DataTable;
SESS_ENTRY *MIB_SessionTableElement ;
int First_of_this_block;
time_t curr_time ;
SNMPAPI nResult = SNMPAPI_NOERROR;
LPSTR tempbuff = NULL;
DWORD resumehandle=0;
DWORD dwAllocatedEntries=0;

   time(&curr_time);    // get the time


//return nResult;  // OPENISSUE  remember the problem with the error
                 // every time a free is done from this call to Enum?


   //
   //
   // If cached, return piece of info.
   //
   //


   if((NULL != cache_table[C_SESS_TABLE].bufptr) &&
      (curr_time <
        (cache_table[C_SESS_TABLE].acquisition_time
                 + cache_expire[C_SESS_TABLE]              ) ) )
        { // it has NOT expired!

        goto Exit ; // the global table is valid

        }

   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //

   // free the old table  LOOK OUT!!
    FreeSessTable();


   First_of_this_block = 0;

   do {  //  as long as there is more data to process

   lmCode =
   NetSessionEnum( NULL,                        // local server
                        NULL,           // get server stats
                        NULL,
                        2,                      // level
                        &bufptr,                // data structure to return
                        MAX_PREFERRED_LENGTH,
                        &entriesread,
                        &totalentries,
                        NULL   //&resumehandle          //  resume handle
                        );


    if(NULL == bufptr)  return nResult ;

    DataTable = (SESSION_INFO_2 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {  // valid so process it, otherwise error

        if(0 == MIB_SessionTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_SessionTable.Table = SnmpUtilMemAlloc(totalentries *
                                                sizeof(SESS_ENTRY) );
                if (NULL == MIB_SessionTable.Table)
                {
                    // free all of the lan man data
                    SafeBufferFree( bufptr );
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
                }
                dwAllocatedEntries = totalentries;
        }

        MIB_SessionTableElement = MIB_SessionTable.Table + First_of_this_block ;

        for(i=0; (i<entriesread) && ((i+First_of_this_block) < dwAllocatedEntries); i++) {  // once for each entry in the buffer
                // increment the entry number

                MIB_SessionTable.Len ++;

                // Stuff the data into each item in the table

                // client name
                MIB_SessionTableElement->svSesClientName.dynamic = TRUE;

#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                        &MIB_SessionTableElement->svSesClientName.stream,
                        DataTable->sesi2_cname,
                        TRUE))
                {
                    MIB_SessionTableElement->svSesClientName.stream = NULL;
                    MIB_SessionTableElement->svSesClientName.length = 0;
                    MIB_SessionTableElement->svSesClientName.dynamic = FALSE;
                }
                else
                {
                    MIB_SessionTableElement->svSesClientName.length = 
                        strlen (MIB_SessionTableElement->svSesClientName.stream);
                }
#else
                MIB_SessionTableElement->svSesClientName.stream = SnmpUtilMemAlloc (
                                strlen( DataTable->sesi2_cname )+1 ) ;
                MIB_SessionTableElement->svSesClientName.length =
                                strlen( DataTable->sesi2_cname ) ;
                memcpy( MIB_SessionTableElement->svSesClientName.stream,
                        DataTable->sesi2_cname,
                        strlen( DataTable->sesi2_cname ) ) ;
#endif

                // user name
                MIB_SessionTableElement->svSesUserName.dynamic = TRUE;


#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                        &MIB_SessionTableElement->svSesUserName.stream,
                        DataTable->sesi2_username,
                        TRUE))
                {
                    MIB_SessionTableElement->svSesUserName.length = 0;
                    MIB_SessionTableElement->svSesUserName.stream = NULL;
                    MIB_SessionTableElement->svSesUserName.dynamic = FALSE;
                }
                else
                {
                    MIB_SessionTableElement->svSesUserName.length =
                        strlen(MIB_SessionTableElement->svSesUserName.stream);
                }
#else
                MIB_SessionTableElement->svSesUserName.stream = SnmpUtilMemAlloc (
                    strlen( DataTable->sesi2_username ) + 1 ) ;
                MIB_SessionTableElement->svSesUserName.length =
                    strlen( DataTable->sesi2_username ) ;

                memcpy( MIB_SessionTableElement->svSesUserName.stream,
                        DataTable->sesi2_username,
                        strlen( DataTable->sesi2_username ) ) ;
#endif
                // number of connections
                MIB_SessionTableElement->svSesNumConns =
                        // DataTable->sesi2_num_conns ; LM_NOT_THERE
                        0 ;  // so get ready in case somebody implements

                // number of opens
                MIB_SessionTableElement->svSesNumOpens =
                        DataTable->sesi2_num_opens ;

                // session time
                MIB_SessionTableElement->svSesTime =
                        DataTable->sesi2_time ;

                // session idle time
                MIB_SessionTableElement->svSesIdleTime =
                        DataTable->sesi2_idle_time ;

                // client type parsing

                // first convert from unicode if needed
#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                        &tempbuff,
                        DataTable->sesi2_cltype_name,
                        TRUE))
                {
                    MIB_SessionTableElement->svSesClientType = 0 ;
                }
                else
                {
#else
                tempbuff = SnmpUtilMemAlloc( strlen(DataTable->sesi2_cltype_name) + 1 );
                memcpy( tempbuff,
                        DataTable->sesi2_cltype_name,
                        strlen( DataTable->sesi2_cltype_name ) ) ;
#endif

                // let's assume 0 is undefined but better than garbage ...
                MIB_SessionTableElement->svSesClientType = 0 ;
                if(0==strcmp(   "DOWN LEVEL",
                                tempbuff))
                        MIB_SessionTableElement->svSesClientType = 1 ;
                else if(0==strcmp("DOS LM",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 2 ;
                else if(0==strcmp("DOS LM 2.0",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 3 ;
                else if(0==strcmp("OS/2 LM 1.0",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 4 ;
                else if(0==strcmp("OS/2 LM 2.0",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 5 ;
                else if(0==strcmp("DOS LM 2.1",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 6 ;
                else if(0==strcmp("OS/2 LM 2.1",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 7 ;
                else if(0==strcmp("AFP 1.1",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 8 ;
                else if(0==strcmp("AFP 2.0",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 9 ;
                else if(0==strcmp("NT",
                                  tempbuff))
                        MIB_SessionTableElement->svSesClientType = 10 ;
                SnmpUtilMemFree(tempbuff);
                tempbuff = NULL;
#ifdef UNICODE
                }
#endif

                // state is always active, set uses to indicate delete request
                MIB_SessionTableElement->svSesState = 1; //always active


                DataTable ++ ;  // advance pointer to next sess entry in buffer
                MIB_SessionTableElement ++ ;  // and table entry

        } // for each entry in the data table


        // free all of the lan man data
        SafeBufferFree( bufptr ) ;

        // indicate where to start adding on next pass, if any
        First_of_this_block += i ;

        } // if data is valid to process
    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    if (! build_sess_entry_oids())
    {
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: build_sess_entry_oids failed\n."));

        FreeSessTable();
        cache_table[C_SESS_TABLE].bufptr = NULL;
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

   // Sort the table information using MSC QuickSort routine
   qsort( (void *)&MIB_SessionTable.Table[0], (size_t)MIB_SessionTable.Len,
          (size_t)sizeof(SESS_ENTRY), sess_entry_cmp );

   //
   //
   // Cache table
   //
   //

   if(0 != MIB_SessionTable.Len) {

        cache_table[C_SESS_TABLE].acquisition_time = curr_time ;

        cache_table[C_SESS_TABLE].bufptr = bufptr ;
   }


   //
   //
   // Return piece of information requested
   //
   //

Exit:
   return nResult;
} // MIB_sess_get

//
// MIB_sess_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl sess_entry_cmp(
       IN const SESS_ENTRY *A,
       IN const SESS_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_sess_cmp


//
//    None.
//
BOOL build_sess_entry_oids(
       )

{
    AsnOctetString OSA ;
    AsnObjectIdentifier UserNameOid ;
    SESS_ENTRY *SessEntry ;
    unsigned i;

    // start pointer at 1st guy in the table
    SessEntry = MIB_SessionTable.Table ;

    // now iterate over the table, creating an oid for each entry
    for( i=0; i<MIB_SessionTable.Len ; i++)  {
        // for each entry in the session table

        // copy the client name into the oid buffer first
        if (! MakeOidFromStr( &SessEntry->svSesClientName, &SessEntry->Oid ))
        {
            return FALSE;
        }

        // copy the user name into a temporary oid buffer
        if (! MakeOidFromStr( &SessEntry->svSesUserName, &UserNameOid ))
        {
            return FALSE;
        }

        // append the two entries forming the index
        if (! SnmpUtilOidAppend( &SessEntry->Oid, &UserNameOid ))
        {
            SnmpUtilOidFree( &UserNameOid );
            return FALSE;
        }

        // free the temporary buffer
        SnmpUtilOidFree( &UserNameOid );

        SessEntry++; // point to the next guy in the table

    } // for
    return TRUE;

} // build_sess_entry_oids

void FreeSessTable()
{
    UINT i;
    SESS_ENTRY *MIB_SessionTableElement ;

    MIB_SessionTableElement = MIB_SessionTable.Table ;

    if (MIB_SessionTableElement)
    {
        // iterate over the whole table
        for(i=0; i<MIB_SessionTable.Len ;i++)
        {
            // free any alloc'ed elements of the structure
            SnmpUtilOidFree(&(MIB_SessionTableElement->Oid));
            SnmpUtilMemFree(MIB_SessionTableElement->svSesClientName.stream);
            SnmpUtilMemFree(MIB_SessionTableElement->svSesUserName.stream);

            MIB_SessionTableElement ++ ;  // increment table entry
        }
        SnmpUtilMemFree(MIB_SessionTable.Table) ; // free the base Table
    }
    MIB_SessionTable.Table = NULL ;    // just for safety
    MIB_SessionTable.Len = 0 ;         // just for safety
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\prnt_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    prnt_tbl.h

Abstract:

    Print Queue Table processing routine and structure definitions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef prnt_tbl_h
#define prnt_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define PRNTQ_NAME_FIELD       1
#define PRNTQ_JOBS_FIELD       2

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the print queue table
typedef struct printq_entry
           {
           AsnObjectIdentifier Oid;
	   AsnDisplayString svPrintQName;    // Index
	   AsnInteger       svPrintQNumJobs;
	   }  PRINTQ_ENTRY;

   // Print Queue table definition
typedef struct
           {
	   UINT         Len;
	   PRINTQ_ENTRY *Table;
           } PRINTQ_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern PRINTQ_TABLE     MIB_PrintQTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_prntq_lmget(
           void
           );

//------------------------------- END ---------------------------------------

#endif /* prnt_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\resolve.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    resolve.c

Abstract:

    High level routines to process the variable binding list.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mib.h"
#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

AsnInteger ResolveVarBind(
              IN RFC1157VarBind *VarBind, // Variable Binding to resolve
              IN UINT PduAction           // Action specified in PDU
              );

SNMPAPI SnmpExtensionQuery(
           IN BYTE ReqType,               // 1157 Request type
           IN OUT RFC1157VarBindList *VarBinds, // Var Binds to resolve
           OUT AsnInteger *ErrorStatus,         // Error status returned
           OUT AsnInteger *ErrorIndex           // Var Bind containing error
           );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//
// ResolveVarBind
//    Resolve a variable binding.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
AsnInteger ResolveVarBind(
              IN RFC1157VarBind *VarBind, // Variable Binding to resolve
              IN UINT PduAction           // Action specified in PDU
              )

{
MIB_ENTRY            *MibPtr;
AsnObjectIdentifier  TempOid;
AsnInteger           nResult;


   // Lookup OID in MIB
   MibPtr = MIB_get_entry( &VarBind->name );

   // Check to see if OID is between LM variables
   if ( MibPtr == NULL && PduAction == MIB_ACTION_GETNEXT )
      {
      UINT I;


      //
      // OPENISSUE - Should change to binary search
      //
      // Search through MIB to see if OID is within the LM MIB's scope
      I = 0;
      while ( MibPtr == NULL && I < MIB_num_variables )
         {
         // Construct OID with complete prefix for comparison purposes
         if (SnmpUtilOidCpy( &TempOid, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            nResult = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &TempOid, &Mib[I].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree( &TempOid );
            nResult = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }

         // Check for OID in MIB
         if ( 0 > SnmpUtilOidCmp(&VarBind->name, &TempOid) )
            {
            MibPtr = &Mib[I];
            PduAction = MIB_ACTION_GETFIRST;
            }

         // Free OID memory before copying another
         SnmpUtilOidFree( &TempOid );

         I++;
         } // while
      } // if

   // If OID not within scope of LM MIB, then no such name
   if ( MibPtr == NULL )
      {
      nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Call MIB function to apply requested operation
   if ( MibPtr->MibFunc == NULL )
      {
      // If not GET-NEXT, then error
      if ( PduAction != MIB_ACTION_GETNEXT && PduAction != MIB_ACTION_GETFIRST )
         {
         nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
         goto Exit;
         }

      // Since this is AGGREGATE, use GET-FIRST on next variable, then return
      nResult = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                             MibPtr->MibNext, VarBind );
      }
   else
      {
      // Make complete OID of MIB name
      if (SnmpUtilOidCpy( &TempOid, &MIB_OidPrefix ) == SNMPAPI_ERROR)
         {
         nResult = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
         goto Exit;
         }
      if (SnmpUtilOidAppend( &TempOid, &MibPtr->Oid ) == SNMPAPI_ERROR)
         {
         SnmpUtilOidFree( &TempOid );
         nResult = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
         goto Exit;
         }

      if ( MibPtr->Type == MIB_TABLE && !SnmpUtilOidCmp(&TempOid, &VarBind->name) )
         {
         if ( PduAction == MIB_ACTION_GETNEXT )
            {
            // Supports GET-NEXT on a MIB table's root node
            PduAction = MIB_ACTION_GETFIRST;
            }
         else
            {
            nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            SnmpUtilOidFree( &TempOid );
            goto Exit;
            }
         }

      nResult = (*MibPtr->MibFunc)( PduAction, MibPtr, VarBind );

      // Free temp memory
      SnmpUtilOidFree( &TempOid );
      }

Exit:
   return nResult;
} // ResolveVarBind

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// SnmpExtensionQuery
//    Loop through var bind list resolving each var bind name to an entry
//    in the LAN Manager MIB.
//
// Notes:
//    Table sets are handled on a case by case basis, because in some cases
//    more than one entry in the Var Bind list will be needed to perform a
//    single SET on the LM MIB.  This is due to the LM API calls.
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI SnmpExtensionQuery(
           IN BYTE ReqType,               // 1157 Request type
           IN OUT RFC1157VarBindList *VarBinds, // Var Binds to resolve
           OUT AsnInteger *ErrorStatus,         // Error status returned
           OUT AsnInteger *ErrorIndex           // Var Bind containing error
           )

{
    UINT    I;
    SNMPAPI nResult;


    //
    //
    // OPENISSUE - Support is not available for TABLE SETS.
    //
    //
    nResult = SNMPAPI_NOERROR;

    *ErrorIndex = 0;
    // Loop through Var Bind list resolving var binds
    for ( I=0;I < VarBinds->len;I++ )
    {
        *ErrorStatus = ResolveVarBind( &VarBinds->list[I], ReqType );

        // Check for GET-NEXT past end of MIB
        if ( *ErrorStatus == SNMP_ERRORSTATUS_NOSUCHNAME &&
            ReqType == MIB_ACTION_GETNEXT )
        {
            // Set Var Bind pointing to next enterprise past LM MIB
            SnmpUtilOidFree( &VarBinds->list[I].name );
            if (! SnmpUtilOidCpy( &VarBinds->list[I].name, &MIB_OidPrefix ))
            {
                *ErrorStatus = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                *ErrorIndex = I+1;
                goto Exit;
            }
            *ErrorStatus = SNMP_ERRORSTATUS_NOERROR;
            VarBinds->list[I].name.ids[MIB_PREFIX_LEN-1] ++;
        }

        if ( *ErrorStatus != SNMP_ERRORSTATUS_NOERROR )
        {
            *ErrorIndex = I+1;
            goto Exit;
        }
    }

Exit:
   return nResult;
} // SnmpExtensionQuery

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\prnt_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    prnt_lm.c

Abstract:

    This file contains the routines which actually call Lan Manager and
    retrieve the contents of the print queue table, including cacheing.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <winspool.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>
//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "prnt_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)   if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)         if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------


int __cdecl prnt_entry_cmp(
       IN const PRINTQ_ENTRY *A,
       IN const PRINTQ_ENTRY *B
       ) ;

BOOL build_prnt_entry_oids( );

void FreePrintQTable();

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_prnt_lmget
//    Retrieve print queue table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_prntq_lmget(
       )

{

DWORD entriesread = 0;              // init number of table entries read
DWORD bytesNeeded = 0;              // init size needed
DWORD dwLastError = ERROR_SUCCESS;  // init last error to no error
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
PRINTER_INFO_2 *DataTable;
PRINTQ_ENTRY *MIB_PrintQTableElement ;
int First_of_this_block;
time_t curr_time ;
BOOL result;
SNMPAPI nResult = SNMPAPI_NOERROR;


    time(&curr_time);    // get the time

    //
    //
    // If cached, return piece of info.
    //
    //

    if((NULL != cache_table[C_PRNT_TABLE].bufptr) &&
        (curr_time <
            (cache_table[C_PRNT_TABLE].acquisition_time
             + cache_expire[C_PRNT_TABLE]              ) ) )
    { // it has NOT expired!
        
        goto Exit ; // the global table is valid
    
    }
    
    //
    // remember to free the existing data
    //
    FreePrintQTable();


    //
    //
    // Do network call to gather information and put it in a nice array
    //
    //

    // call it with zero length buffer to get the size
    //
    result = EnumPrinters(
                    PRINTER_ENUM_SHARED |
                    PRINTER_ENUM_LOCAL,     // what type to enum
                    NULL,                   // local server
                    2,                      // level
                    NULL,                   // where to put it
                    0,                      // max of above
                    &bytesNeeded,           // additional bytes req'd
                    &entriesread );         // how many we got this time

    if (result)
    {
        // When there is no table entries from spooler *and* spooler is 
        // running, we'll be here.
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: EnumPrinters returns TRUE, bytesNeeded=0x%08lx\n",
            bytesNeeded
            ));
        
        goto Exit; // get out with 0 entries in the table
    }
    // Assert: result == FALSE
    dwLastError = GetLastError();           // save last error
    
    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: LMMIB2: EnumPrinters returns FALSE, bytesNeeded=0x%08lx, dwLastError=0x%08lx\n",
        bytesNeeded, dwLastError
        ));
    
    if (ERROR_INSUFFICIENT_BUFFER != dwLastError)
    {
        //
        // EnumPrinters Failed and the last error is not 
        // ERROR_INSUFFICIENT_BUFFER, we'll bail out with 0 entries in the 
        // table.
        // For example, if spooler service was down, we will be here.
        //
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: EnumPrinters failed, lasterror != ERROR_INSUFFICIENT_BUFFER, bytesNeeded=%d\n",
            bytesNeeded
            ));
        
        goto Exit; // get out with 0 entries in the table, so getnext will work
    }
    // Assert: dwLastError == ERROR_INSUFFICIENT_BUFFER

    bufptr = SnmpUtilMemAlloc(bytesNeeded); // SnmpUtilMemAlloc the buffer
    if(NULL==bufptr)
    {
        nResult = SNMPAPI_ERROR;
        goto Exit ;      // can't allocate memory, error out
    }


    // then read the rest of it
    // call it again
    result = EnumPrinters(
                PRINTER_ENUM_SHARED |
                PRINTER_ENUM_LOCAL,     // what type to enum
                NULL,                   // local server
                2,                      // level
                bufptr,                 // where to put it
                bytesNeeded,            // max of above
                &bytesNeeded,           // additional bytes req'd
                &entriesread );         // how many we got this time
    

    if (!result) {
       // Signal error
       SafeFree( bufptr ); 
       nResult = SNMPAPI_ERROR;
       goto Exit;
    }


    DataTable = (PRINTER_INFO_2 *) bufptr ;

    
    if(0 == MIB_PrintQTable.Len) {  // 1st time, alloc the whole table
        // alloc the table space
        MIB_PrintQTable.Table = SnmpUtilMemAlloc(entriesread *
                                                    sizeof(PRINTQ_ENTRY) );
        // prefix bug 445181
        if (MIB_PrintQTable.Table == NULL) {
            // free the table
            SafeFree( bufptr ) ;
            // Signal error
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }
    }
    
    MIB_PrintQTableElement = MIB_PrintQTable.Table  ;
    
    for(i=0; i<entriesread; i++) {  // once for each entry in the buffer
        
        // increment the entry number
        
        MIB_PrintQTable.Len ++;
        
        // Stuff the data into each item in the table
        
        // client name
        MIB_PrintQTableElement->svPrintQName.dynamic = TRUE;
        
        #ifdef UNICODE
        if (SnmpUtilUnicodeToUTF8(
            &MIB_PrintQTableElement->svPrintQName.stream,
            DataTable->pPrinterName,
            TRUE))
        {
            MIB_PrintQTableElement->svPrintQName.stream = NULL;
            MIB_PrintQTableElement->svPrintQName.length = 0;
            MIB_PrintQTableElement->svPrintQName.dynamic = FALSE;
        }
        else
        {
            MIB_PrintQTableElement->svPrintQName.length = 
                strlen (MIB_PrintQTableElement->svPrintQName.stream);
        }
        #else
        MIB_PrintQTableElement->svPrintQName.stream = SnmpUtilMemAlloc (
                strlen( DataTable->pPrinterName ) + 1 ) ;
        MIB_PrintQTableElement->svPrintQName.length =
                strlen( DataTable->pPrinterName ) ;

        memcpy( MIB_PrintQTableElement->svPrintQName.stream,
            DataTable->pPrinterName,
            strlen( DataTable->pPrinterName ) ) ;
        #endif
        
        // number of connections
        MIB_PrintQTableElement->svPrintQNumJobs =
            DataTable->cJobs;
        
            
        MIB_PrintQTableElement ++ ;  // and table entry
    
        DataTable ++ ;  // advance pointer to next sess entry in buffer
        
    } // for each entry in the data table
    
    // free all of the printer enum data
    if(NULL!=bufptr)                // free the table
        SnmpUtilMemFree( bufptr ) ;
    
    


    // iterate over the table populating the Oid field
    if (! build_prnt_entry_oids())
    {
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: build_prnt_entry_oids failed\n."));

        FreePrintQTable();
        cache_table[C_PRNT_TABLE].bufptr = NULL;
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // Sort the table information using MSC QuickSort routine
    qsort( &MIB_PrintQTable.Table[0], MIB_PrintQTable.Len,
            sizeof(PRINTQ_ENTRY), prnt_entry_cmp );

    //
    //
    // Cache table
    //
    //

    if(0 != MIB_PrintQTable.Len) {
    
        cache_table[C_PRNT_TABLE].acquisition_time = curr_time ;

        cache_table[C_PRNT_TABLE].bufptr = bufptr ;
    }

    //
    //
    // Return piece of information requested in global table
    //
    //

Exit:
    return nResult;
} // MIB_prnt_get

//
// MIB_prnt_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl prnt_entry_cmp(
       IN const PRINTQ_ENTRY *A,
       IN const PRINTQ_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_prnt_cmp


//
//    None.
//
BOOL build_prnt_entry_oids(
       )

{
    AsnOctetString OSA ;
    PRINTQ_ENTRY *PrintQEntry ;
    unsigned i;

    // start pointer at 1st guy in the table
    PrintQEntry = MIB_PrintQTable.Table ;

    // now iterate over the table, creating an oid for each entry
    for( i=0; i<MIB_PrintQTable.Len ; i++)  {
        // for each entry in the session table

        OSA.stream = PrintQEntry->svPrintQName.stream ;
        OSA.length =  PrintQEntry->svPrintQName.length ;
        OSA.dynamic = TRUE;

        // Make the entry's OID from string index
        if (! MakeOidFromStr( &OSA, &PrintQEntry->Oid ))
        {
            return FALSE;
        }

        PrintQEntry++; // point to the next guy in the table

    } // for
    return TRUE;

} // build_prnt_entry_oids

void FreePrintQTable()
{
    UINT i;
    PRINTQ_ENTRY *MIB_PrintQTableElement;

    MIB_PrintQTableElement = MIB_PrintQTable.Table;
    if (MIB_PrintQTableElement) 
    {
        // iterate over the whole table
        for(i=0; i<MIB_PrintQTable.Len ;i++) 
        {
            // free any alloc'ed elements of the structure
            SnmpUtilOidFree(&(MIB_PrintQTableElement->Oid));
            SnmpUtilMemFree(MIB_PrintQTableElement->svPrintQName.stream);
            MIB_PrintQTableElement ++; // increment table entry
        }
        SnmpUtilMemFree(MIB_PrintQTable.Table); // free the base Table
    }
    MIB_PrintQTable.Table = NULL;
    MIB_PrintQTable.Len = 0; 
}

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\sess_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    sess_tbl.h

Abstract:

    Definition of all structures used by the Session table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

#ifndef sess_tbl_h
#define sess_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define SESS_CLIENT_FIELD      1
#define SESS_USER_FIELD        2
#define SESS_NUMCONS_FIELD     3
#define SESS_NUMOPENS_FIELD    4
#define SESS_TIME_FIELD        5
#define SESS_IDLETIME_FIELD    6
#define SESS_CLIENTTYPE_FIELD  7
#define SESS_STATE_FIELD       8

   // State definitions
#define SESS_STATE_ACTIVE      1
#define SESS_STATE_DELETED     2

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the session table
typedef struct sess_entry
           {
           AsnObjectIdentifier Oid;
	   AsnDisplayString svSesClientName; // Index
	   AsnDisplayString svSesUserName;   // Index
	   AsnInteger       svSesNumConns;
	   AsnInteger       svSesNumOpens;
	   AsnCounter       svSesTime;
	   AsnCounter       svSesIdleTime;
	   AsnInteger       svSesClientType;
	   AsnInteger       svSesState;
	   } SESS_ENTRY;

   // Session table definition
typedef struct
           {
	   UINT       Len;
	   SESS_ENTRY *Table;
           } SESSION_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern SESSION_TABLE    MIB_SessionTable ;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_sess_lmget(
           void
	   );

UINT MIB_sess_lmset(
        IN AsnObjectIdentifier *Index,
	IN UINT Field,
	IN AsnAny *Value
	);

int MIB_sess_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos,
       IN BOOL Next
       );

//------------------------------- END ---------------------------------------

#endif /* sess_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\sess_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    sess_tbl.c

Abstract:

    All routines to support opertions on the LM MIB session table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "sess_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Session table
static UINT                sessSubids[] = { 2, 20, 1 };
static AsnObjectIdentifier MIB_SessPrefix = { 3, sessSubids };

SESSION_TABLE MIB_SessionTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SESS_FIELD_SUBID       (MIB_SessPrefix.idLength+MIB_OidPrefix.idLength)

#define SESS_FIRST_FIELD       SESS_CLIENT_FIELD
#define SESS_LAST_FIELD        SESS_STATE_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_sess_get(
        IN OUT RFC1157VarBind *VarBind
        );

int MIB_sess_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos,
       IN BOOL Next
       );

UINT MIB_sess_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_sess_func
//    High level routine for handling operations on the session table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_sess_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        )

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Session table with the info from server
         if ( SNMPAPI_ERROR == MIB_sess_lmget() )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_SessionTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { SESS_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };

         AsnObjectIdentifier tmpOid;
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (! SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_SessPrefix ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_SessionTable.Table[0].Oid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_sess_get( VarBind );
         break;

      case MIB_ACTION_GETNEXT:
         // Fill the Session table with the info from server
         if ( SNMPAPI_ERROR == MIB_sess_lmget() )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Determine which field
         Field = VarBind->name.ids[SESS_FIELD_SUBID];

        // Lookup OID in table
         if (Field < SESS_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = SESS_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > SESS_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_sess_match( &VarBind->name, &Entry, TRUE );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_SessionTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > SESS_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_SessionTable.Len-1 )
               {
               Entry = 0;
               Field ++;

               /* item not implemented. Skip */

               if (Field == SESS_NUMCONS_FIELD) {
                   Field++;
               }

               if ( Field > SESS_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;
         AsnObjectIdentifier tmpOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (! SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_SessPrefix ))
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_SessionTable.Table[Entry].Oid ))
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_sess_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         // Make sure OID is long enough
         if ( SESS_FIELD_SUBID + 1 > VarBind->name.idLength )
            {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
            }

         // Get field number
         Field = VarBind->name.ids[SESS_FIELD_SUBID];

         // If the field being set is not the STATE field, error
         if ( Field != SESS_STATE_FIELD )
            {
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
            }

         // Check for proper type before setting
         if ( ASN_INTEGER != VarBind->value.asnType )
            {
            ErrStat = SNMP_ERRORSTATUS_BADVALUE;
            goto Exit;
            }

         // Make sure that the value is valid
         if ( VarBind->value.asnValue.number < SESS_STATE_ACTIVE &&
              VarBind->value.asnValue.number > SESS_STATE_DELETED )
            {
            ErrStat = SNMP_ERRORSTATUS_BADVALUE;
            goto Exit;
            }

         ErrStat = MIB_sess_lmset( &VarBind->name, Field, &VarBind->value );

         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_sess_func



//
// MIB_sess_get
//    Retrieve session table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_sess_get(
        IN OUT RFC1157VarBind *VarBind
        )

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[SESS_FIELD_SUBID] < SESS_FIRST_FIELD ||
       VarBind->name.ids[SESS_FIELD_SUBID] > SESS_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Session table with the info from server
   if ( SNMPAPI_ERROR == MIB_sess_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_sess_match( &VarBind->name, &Entry, FALSE );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   if ( VarBind->name.ids[SESS_FIELD_SUBID] == SESS_NUMCONS_FIELD )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_sess_copyfromtable( Entry, VarBind->name.ids[SESS_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_sess_get



//
// MIB_sess_match
//    Match the target OID with a location in the Session table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_sess_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos,
       IN BOOL Next
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_SessPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_SessPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_SessionTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_SessionTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;
         if (Next) {
             while ( ( (*Pos) + 1 < MIB_SessionTable.Len ) &&
                     !SnmpUtilOidCmp( &TempOid, &MIB_SessionTable.Table[(*Pos)+1].Oid)) {
                 (*Pos)++;
             }
         }

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_sess_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_sess_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case SESS_CLIENT_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_SessionTable.Table[Entry].svSesClientName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_SessionTable.Table[Entry].svSesClientName.stream,
                       MIB_SessionTable.Table[Entry].svSesClientName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_SessionTable.Table[Entry].svSesClientName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case SESS_USER_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_SessionTable.Table[Entry].svSesUserName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_SessionTable.Table[Entry].svSesUserName.stream,
                       MIB_SessionTable.Table[Entry].svSesUserName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_SessionTable.Table[Entry].svSesUserName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case SESS_NUMCONS_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesNumConns;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SESS_NUMOPENS_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesNumOpens;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SESS_TIME_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesTime;
         VarBind->value.asnType = ASN_RFC1155_COUNTER;
         break;

      case SESS_IDLETIME_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesIdleTime;
         VarBind->value.asnType = ASN_RFC1155_COUNTER;
         break;

      case SESS_CLIENTTYPE_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesClientType;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SESS_STATE_FIELD:
         VarBind->value.asnValue.number =
                               MIB_SessionTable.Table[Entry].svSesState;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Session Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_sess_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\shar_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    shar_lm.c

Abstract:

    This file contains MIB_shar_lmget, which actually call lan manager
    for the share table, copies it into structures, and sorts it to
    return ready to use by the higher level functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "shar_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)   if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

int __cdecl shar_entry_cmp(
       IN const SHARE_ENTRY *A,
       IN const SHARE_ENTRY *B
       ) ;

BOOL build_shar_entry_oids( );
void FreeShareTable();

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_shar_lmget
//    Retrieve sharion table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_shares_lmget(
       )

{

    DWORD entriesread;
    DWORD totalentries;
    LPBYTE bufptr;
    unsigned lmCode;
    unsigned i;
    SHARE_INFO_2 *DataTable;
    SHARE_ENTRY *MIB_ShareTableElement ;
    int First_of_this_block;
    time_t curr_time ;
    SNMPAPI nResult = SNMPAPI_NOERROR;
    DWORD resumehandle=0;
    DWORD dwAllocatedEntries=0;


    time(&curr_time);   // get the time


    //
    //
    // If cached, return piece of info.
    //
    //


    if((NULL != cache_table[C_SHAR_TABLE].bufptr) &&
      (curr_time <
        (cache_table[C_SHAR_TABLE].acquisition_time
             + cache_expire[C_SHAR_TABLE]              ) ) )
    { // it has NOT expired!
        
        goto Exit ; // the global table is valid
    
    }
    
    //
    //
    // Do network call to gather information and put it in a nice array
    //
    //

    
    //
    // remember to free the existing data
    //

    FreeShareTable();

    
    First_of_this_block = 0;
    
    do {  //  as long as there is more data to process

        lmCode =
         NetShareEnum(NULL,      // local server
            2,                  // level 2,
            &bufptr,            // data structure to return
            MAX_PREFERRED_LENGTH,
            &entriesread,
            &totalentries,
            &resumehandle       //  resume handle
            );

        //
        // Filter out all the Admin shares (name ending with $).
        //
        AdminFilter(2,&entriesread,bufptr);


        DataTable = (SHARE_INFO_2 *) bufptr ;

        if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {  // valid so process it, otherwise error
    
            if(0 == MIB_ShareTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_ShareTable.Table = SnmpUtilMemAlloc(totalentries *
                        sizeof(SHARE_ENTRY) );
                // prefix bugs 445180
                if (MIB_ShareTable.Table == NULL) {
                    // free all of the lan man data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
                }
                dwAllocatedEntries = totalentries;
            }
    
            MIB_ShareTableElement = MIB_ShareTable.Table + First_of_this_block ;
    
            for(i=0; (i<entriesread) && ((i+First_of_this_block) < dwAllocatedEntries); i++) {  // once for each entry in the buffer
                // increment the entry number
        
                MIB_ShareTable.Len ++;
        
                // Stuff the data into each item in the table
        
                // share name
                MIB_ShareTableElement->svShareName.dynamic = TRUE;
        
            #ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                    &MIB_ShareTableElement->svShareName.stream,
                    DataTable->shi2_netname,
                    TRUE))
                {
                    MIB_ShareTableElement->svShareName.length = 0;
                    MIB_ShareTableElement->svShareName.stream = NULL;
                    MIB_ShareTableElement->svShareName.dynamic = FALSE;
                }
                else
                {
                    MIB_ShareTableElement->svShareName.length = 
                    strlen(MIB_ShareTableElement->svShareName.stream);
                }
            #else
                MIB_ShareTableElement->svShareName.stream = SnmpUtilMemAlloc (
                        strlen( DataTable->shi2_netname ) + 1 ) ;
                MIB_ShareTableElement->svShareName.length =
                        strlen( DataTable->shi2_netname ) ;
                memcpy( MIB_ShareTableElement->svShareName.stream,
                DataTable->shi2_netname,
                strlen( DataTable->shi2_netname ) ) ;
            #endif
        
                // Share Path
                MIB_ShareTableElement->svSharePath.dynamic = TRUE;
        
            #ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                    &MIB_ShareTableElement->svSharePath.stream,
                    DataTable->shi2_path,
                    TRUE))
                {
                    MIB_ShareTableElement->svSharePath.length = 0;
                    MIB_ShareTableElement->svSharePath.stream = NULL;
                    MIB_ShareTableElement->svSharePath.dynamic = FALSE;
                }
                else
                {
                    MIB_ShareTableElement->svSharePath.length =
                    strlen(MIB_ShareTableElement->svSharePath.stream);
                }
            #else
                MIB_ShareTableElement->svSharePath.stream = SnmpUtilMemAlloc (
                strlen( DataTable->shi2_path ) + 1 ) ;
                MIB_ShareTableElement->svSharePath.length =
                strlen( DataTable->shi2_path ) ;

                memcpy( MIB_ShareTableElement->svSharePath.stream,
                DataTable->shi2_path,
                strlen( DataTable->shi2_path ) ) ;
            #endif
        
                // Share Comment/Remark
                MIB_ShareTableElement->svShareComment.dynamic = TRUE;
        
            #ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                    &MIB_ShareTableElement->svShareComment.stream,
                    DataTable->shi2_remark,
                    TRUE))
                {
                    MIB_ShareTableElement->svShareComment.length = 0;
                    MIB_ShareTableElement->svShareComment.stream = NULL;
                    MIB_ShareTableElement->svShareComment.dynamic = FALSE;
                }
                else
                {
                    MIB_ShareTableElement->svShareComment.length =
                    strlen(MIB_ShareTableElement->svShareComment.stream);
                }
            #else
                MIB_ShareTableElement->svShareComment.stream = SnmpUtilMemAlloc (
                        strlen( DataTable->shi2_remark ) + 1 ) ;
                MIB_ShareTableElement->svShareComment.length =
                        strlen( DataTable->shi2_remark ) ;

                memcpy( MIB_ShareTableElement->svShareComment.stream,
                DataTable->shi2_remark,
                strlen( DataTable->shi2_remark ) ) ;
            #endif
        
                DataTable ++ ;  // advance pointer to next shar entry in buffer
                MIB_ShareTableElement ++ ;  // and table entry
        
            } // for each entry in the data table
    
    
            // free all of the lan man data
            SafeBufferFree( bufptr ) ;
    
            // indicate where to start adding on next pass, if any
            First_of_this_block += i ;
    
        } // if data is valid to process
        else
        {
            // Signal error
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    if (! build_shar_entry_oids())
    {
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: build_prnt_entry_oids failed\n."));

        FreeShareTable();
        cache_table[C_SHAR_TABLE].bufptr = NULL;
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

   // Sort the table information using MSC QuickSort routine
   qsort( &MIB_ShareTable.Table[0], MIB_ShareTable.Len,
          sizeof(SHARE_ENTRY), shar_entry_cmp );

   //
   //
   // Cache table
   //
   //


   if(0 != MIB_ShareTable.Len) {
    
    cache_table[C_SHAR_TABLE].acquisition_time = curr_time ;

    cache_table[C_SHAR_TABLE].bufptr = bufptr ;
   }

   //
   //
   // Return piece of information requested
   //
   //

Exit:
   return nResult;
} // MIB_shar_get

//
// MIB_shar_cmp
//    Routine for sorting the sharion table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl shar_entry_cmp(
       IN const SHARE_ENTRY *A,
       IN const SHARE_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_shar_cmp


//
//    None.
//
BOOL build_shar_entry_oids(
       )

{
    AsnOctetString OSA ;
    SHARE_ENTRY *ShareEntry ;
    unsigned i;

    // start pointer at 1st guy in the table
    ShareEntry = MIB_ShareTable.Table ;

    // now iterate over the table, creating an oid for each entry
    for( i=0; i<MIB_ShareTable.Len ; i++)  {
        // for each entry in the sharion table

        OSA.stream = ShareEntry->svShareName.stream ;
        OSA.length =  ShareEntry->svShareName.length ;
        OSA.dynamic = FALSE;

        // Make the entry's OID from string index
        if (! MakeOidFromStr( &OSA, &ShareEntry->Oid ))
        {
            return FALSE;
        }

        ShareEntry++; // point to the next guy in the table

    } // for
    return TRUE;

} // build_shar_entry_oids


VOID
AdminFilter(
    DWORD           Level,
    LPDWORD         pEntriesRead,
    LPBYTE          ShareInfo
    )

/*++

Routine Description:

    This function filters out the admin shares (ones denoted by a
    a $ as the last character in the name) from a NetShareEnum
    buffer.

    This function only supports info levels 0,1, and 2.  If any other
    level is passed in, the function doesn't perform the filter
    operation.

Arguments:

    Level - Indicates the info level of the enumeration buffer passed in.

    pEntriesRead - Pointer to a location which on entry indicates the
        number of entries to be filtered.  On exit it will indicate
        the number of entries after filtering.

    ShareInfo - Pointer to the buffer containing the enumerated structures.

Return Value:

    none.

--*/
{
    LPBYTE          pFiltered = ShareInfo;
    DWORD           filteredEntries=0;
    DWORD           i;
    DWORD           entrySize;
    DWORD           namePtrOffset;
    LPWSTR          pName;

    switch(Level) {
    case 0:
        entrySize = sizeof(SHARE_INFO_0);
        namePtrOffset = (DWORD)((LPBYTE)&(((LPSHARE_INFO_0)ShareInfo)->shi0_netname) -
                         ShareInfo);
        break;
    case 1:
        entrySize = sizeof(SHARE_INFO_1);
        namePtrOffset = (DWORD)((LPBYTE)&(((LPSHARE_INFO_1)ShareInfo)->shi1_netname) -
                         ShareInfo);
        break;
    case 2:
        entrySize = sizeof(SHARE_INFO_2);
        namePtrOffset = (DWORD)((LPBYTE)&(((LPSHARE_INFO_2)ShareInfo)->shi2_netname) -
                         ShareInfo);
        break;
    default:
        return;
    }

    for (i=0; i < *pEntriesRead; i++) {
        pName = *((LPWSTR *)(ShareInfo+namePtrOffset));
        if (pName[wcslen(pName)-1] != L'$') {
            filteredEntries++;
            if (pFiltered != ShareInfo) {
                memcpy(pFiltered, ShareInfo,entrySize);
            }
            pFiltered += entrySize;
        }
        ShareInfo += entrySize;
    }
    *pEntriesRead = filteredEntries;
}

void FreeShareTable()
{
    UINT i;
    SHARE_ENTRY *MIB_ShareTableElement ;
     
    MIB_ShareTableElement = MIB_ShareTable.Table ;

    if (MIB_ShareTableElement)
    {
        // iterate over the whole table
        for(i=0; i<MIB_ShareTable.Len ;i++)
        {
            // free any alloc'ed elements of the structure
            SnmpUtilOidFree(&(MIB_ShareTableElement->Oid));
            SnmpUtilMemFree(MIB_ShareTableElement->svShareName.stream);
            SnmpUtilMemFree(MIB_ShareTableElement->svSharePath.stream);
            SnmpUtilMemFree(MIB_ShareTableElement->svShareComment.stream);
        
            MIB_ShareTableElement ++ ;  // increment table entry
        }
        SnmpUtilMemFree(MIB_ShareTable.Table) ; // free the base Table
    }
    MIB_ShareTable.Table = NULL ;   // just for safety
    MIB_ShareTable.Len = 0 ;        // just for safety
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\srvc_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvc_lm.c

Abstract:

    This file contains MIB_srvc_lmget, which actually call lan manager
    for the srvce table, copies it into structures, and sorts it to
    return ready to use by the higher level functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "srvc_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)   if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

int __cdecl srvc_entry_cmp(
       IN const SRVC_ENTRY *A,
       IN const SRVC_ENTRY *B
       ) ;

BOOL build_srvc_entry_oids( );

void FreeSrvcTable();
//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_srvc_lmget
//    Retrieve srvcion table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_srvcs_lmget(
       )

{
DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
SERVICE_INFO_2 *DataTable;
SRVC_ENTRY *MIB_SrvcTableElement ;
int First_of_this_block;
time_t curr_time ;
SNMPAPI nResult = SNMPAPI_NOERROR;
DWORD resumehandle=0;
#ifdef UNICODE
LPSTR stream;
#endif
DWORD dwAllocatedEntries=0;


    time(&curr_time);   // get the time


    //
    //
    // If cached, return piece of info.
    //
    //


   if((NULL != cache_table[C_SRVC_TABLE].bufptr) &&
      (curr_time <
        (cache_table[C_SRVC_TABLE].acquisition_time
             + cache_expire[C_SRVC_TABLE]              ) ) )
    { // it has NOT expired!
        
        goto Exit ; // the global table is valid
    
    }
    
    //
    //
    // Do network call to gather information and put it in a nice array
    //
    //

    
    //
    // remember to free the existing data
    //

    FreeSrvcTable();

    First_of_this_block = 0;
    
    do {  //  as long as there is more data to process

        lmCode =
            NetServiceEnum( NULL,       // local server
                    2,                  // level 2
                    &bufptr,            // data structure to return
                    MAX_PREFERRED_LENGTH,
                    &entriesread,
                    &totalentries,
                    &resumehandle       //  resume handle
                    );

        DataTable = (SERVICE_INFO_2 *) bufptr ;

        if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {  // valid so process it, otherwise error
    
            if(0 == MIB_SrvcTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_SrvcTable.Table = SnmpUtilMemAlloc(totalentries *
                                                        sizeof(SRVC_ENTRY) );
                // prefix bugs 445185 and 445186
                if (MIB_SrvcTable.Table == NULL) {
                    // free all of the lan man data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit; 
                }
                dwAllocatedEntries = totalentries;
            }
    
            MIB_SrvcTableElement = MIB_SrvcTable.Table + First_of_this_block ;
    
            for(i=0; (i<entriesread) && ((i+First_of_this_block) < dwAllocatedEntries); i++) {  // once for each entry in the buffer
                // increment the entry number
        
                MIB_SrvcTable.Len ++;
        
                // Stuff the data into each item in the table
        
                MIB_SrvcTableElement->svSvcName.dynamic = TRUE;

            #ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                        &MIB_SrvcTableElement->svSvcName.stream,
                        DataTable->svci2_display_name,
                        TRUE))
                {
                    MIB_SrvcTableElement->svSvcName.length = 0;
                    MIB_SrvcTableElement->svSvcName.stream = NULL;
                    MIB_SrvcTableElement->svSvcName.dynamic = FALSE;
                }
                else
                {
                    MIB_SrvcTableElement->svSvcName.length =
                        strlen(MIB_SrvcTableElement->svSvcName.stream);
                }

            #else
                // service name
                MIB_SrvcTableElement->svSvcName.stream = SnmpUtilMemAlloc (
                        strlen( DataTable->svci2_display_name ) + 1) ;

                memcpy( MIB_SrvcTableElement->svSvcName.stream,
                        DataTable->svci2_display_name,
                        strlen( DataTable->svci2_display_name ) + 1) ;

                MIB_SrvcTableElement->svSvcName.length =
                        strlen( MIB_SrvcTableElement->svSvcName.stream )) ;
            #endif
        
                MIB_SrvcTableElement->svSvcInstalledState =
                                    (DataTable->svci2_status & 0x03) + 1;
                MIB_SrvcTableElement->svSvcOperatingState =
                                ((DataTable->svci2_status>>2) & 0x03) + 1;
                MIB_SrvcTableElement->svSvcCanBeUninstalled =
                                ((DataTable->svci2_status>>4) & 0x01) + 1;
                MIB_SrvcTableElement->svSvcCanBePaused =
                                ((DataTable->svci2_status>>5) & 0x01) + 1;
        
                DataTable ++ ;  // advance pointer to next srvc entry in buffer
                MIB_SrvcTableElement ++ ;  // and table entry
        
            } // for each entry in the data table
    
    
            // free all of the lan man data
            SafeBufferFree( bufptr ) ;
    
            // indicate where to start adding on next pass, if any
            First_of_this_block += i ;
    
        } // if data is valid to process
        else
        {
            // Signal error
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    if (! build_srvc_entry_oids())
    {
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: build_srvc_entry_oids failed\n."));

        FreeSrvcTable();
        cache_table[C_SRVC_TABLE].bufptr = NULL;
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // Sort the table information using MSC QuickSort routine
    qsort( &MIB_SrvcTable.Table[0], MIB_SrvcTable.Len,
              sizeof(SRVC_ENTRY), srvc_entry_cmp );

    //
    //
    // Cache table
    //
    //


    if(0 != MIB_SrvcTable.Len) {
    
        cache_table[C_SRVC_TABLE].acquisition_time = curr_time ;

        cache_table[C_SRVC_TABLE].bufptr = bufptr ;
    }

    //
    //
    // Return piece of information requested
    //
    //
Exit:
   return nResult;
} // MIB_srvc_get

//
// MIB_srvc_cmp
//    Routine for sorting the srvcion table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl srvc_entry_cmp(
       IN const SRVC_ENTRY *A,
       IN const SRVC_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_srvc_cmp


//
//    None.
//
BOOL build_srvc_entry_oids(
       )

{
    AsnOctetString OSA ;
    SRVC_ENTRY *SrvcEntry ;
    unsigned i;

    // start pointer at 1st guy in the table
    SrvcEntry = MIB_SrvcTable.Table ;

    // now iterate over the table, creating an oid for each entry
    for( i=0; i<MIB_SrvcTable.Len ; i++)  {
        // for each entry in the srvc table

        OSA.stream =  SrvcEntry->svSvcName.stream;
        OSA.length =  SrvcEntry->svSvcName.length;
        OSA.dynamic = FALSE;

        // Make the entry's OID from string index
        if (! MakeOidFromStr( &OSA, &SrvcEntry->Oid ))
        {
            return FALSE;
        }

        SrvcEntry++; // point to the next guy in the table

    } // for
    return TRUE;
} // build_srvc_entry_oids

void FreeSrvcTable()
{
    UINT i;
    SRVC_ENTRY *MIB_SrvcTableElement ;

    MIB_SrvcTableElement = MIB_SrvcTable.Table ;
    if (MIB_SrvcTableElement)
    { 
        // iterate over the whole table
        for(i=0; i<MIB_SrvcTable.Len ;i++)
        {
            // free any alloc'ed elements of the structure
            SnmpUtilOidFree(&(MIB_SrvcTableElement->Oid));
            SnmpUtilMemFree(MIB_SrvcTableElement->svSvcName.stream);
        
            MIB_SrvcTableElement ++ ;  // increment table entry
        }
        SnmpUtilMemFree(MIB_SrvcTable.Table) ;  // free the base Table
    }
    MIB_SrvcTable.Table = NULL ;    // just for safety
    MIB_SrvcTable.Len = 0 ;     // just for safety
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\shar_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    shar_tbl.h

Abstract:

    Define all structures and routines used by the share table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef shar_tbl_h
#define shar_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define SHARE_NAME_FIELD        1
#define SHARE_PATH_FIELD        2
#define SHARE_COMMENT_FIELD     3

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the share table
typedef struct share_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString svShareName;    // Index
	   AsnDisplayString svSharePath;
	   AsnDisplayString svShareComment;
	   } SHARE_ENTRY;

   // Share table definition
typedef struct
           {
	   UINT        Len;
	   SHARE_ENTRY *Table;
           } SHARE_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern SHARE_TABLE      MIB_ShareTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_shares_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* shar_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\snmptst4.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    snmptst4.c

Abstract:

    Driver routine to invoke an test the Extension Agent DLL.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <windows.h>


//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>
#include <authapi.h>

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

typedef AsnObjectIdentifier View; // temp until view is defined...

int __cdecl main(
    IN int  argumentCount,
    IN char *argumentVector[])
    {
    HANDLE  hExtension;
    FARPROC initAddr;
    FARPROC queryAddr;
    FARPROC trapAddr;

    DWORD  timeZeroReference;
    HANDLE hPollForTrapEvent;
    View   supportedView;

    INT i;
    INT numQueries = 10;
    UINT typ;

    extern INT nLogLevel;
    extern INT nLogType;

    nLogLevel = 15;
    nLogType  = 1;

    // avoid compiler warning...
    UNREFERENCED_PARAMETER(argumentCount);
    UNREFERENCED_PARAMETER(argumentVector);

    timeZeroReference = GetCurrentTime()/10;

    // load the extension agent dll and resolve the entry points...
    if (GetModuleHandle("lmmib2.dll") == NULL)
        {
        if ((hExtension = LoadLibrary("lmmib2.dll")) == NULL)
            {
            dbgprintf(1, "error on LoadLibrary %d\n", GetLastError());

            }
        else if ((initAddr = GetProcAddress(hExtension,
                 "SnmpExtensionInit")) == NULL)
            {
            dbgprintf(1, "error on GetProcAddress %d\n", GetLastError());
            }
        else if ((queryAddr = GetProcAddress(hExtension,
                 "SnmpExtensionQuery")) == NULL)
            {
            dbgprintf(1, "error on GetProcAddress %d\n",
                              GetLastError());

            }
        else if ((trapAddr = GetProcAddress(hExtension,
                 "SnmpExtensionTrap")) == NULL)
            {
            dbgprintf(1, "error on GetProcAddress %d\n",
                      GetLastError());

            }
        else
            {
            // initialize the extension agent via its init entry point...
            (*initAddr)(
                timeZeroReference,
                &hPollForTrapEvent,
                &supportedView);
            }
        } // end if (Already loaded)

    // create a trap thread to respond to traps from the extension agent...

    //rather than oomplicate this test routine, will poll for these events
    //below.  normally this would be done by another thread in the extendible
    //agent.


    // loop here doing repetitive extension agent get queries...
    // poll for potential traps each iteration (see note above)...

    //block...
         {
         RFC1157VarBindList varBinds;
         AsnInteger         errorStatus;
         AsnInteger         errorIndex;
         UINT OID_Prefix[] = { 1, 3, 6, 1, 4, 1, 77 };
         AsnObjectIdentifier MIB_OidPrefix = { 7, OID_Prefix };


	 errorStatus = 0;
	 errorIndex  = 0;
         varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
         varBinds.len = 1;
         varBinds.list[0].name.idLength = MIB_OidPrefix.idLength;
         varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT) *
                                               varBinds.list[0].name.idLength );
         memcpy( varBinds.list[0].name.ids, MIB_OidPrefix.ids,
                 sizeof(UINT)*varBinds.list[0].name.idLength );
         varBinds.list[0].value.asnType = ASN_NULL;

         do
            {
	    printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
                                        printf( "   " );
            (*queryAddr)( (AsnInteger)ASN_RFC1157_GETNEXTREQUEST,
                          &varBinds,
		          &errorStatus,
		          &errorIndex
                          );
            printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
	    if ( errorStatus )
	       {
               printf( "\nErrorstatus:  %lu\n\n", errorStatus );
	       }
	    else
	       {
               printf( "\n  =  " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	       }
            putchar( '\n' );
            }
         while ( varBinds.list[0].name.ids[7-1] != 78 );

         // Free the memory
         SnmpUtilVarBindListFree( &varBinds );


#if 0

            // query potential traps (see notes above)
            if (hPollForTrapEvent != NULL)
                {
                DWORD dwResult;

                if      ((dwResult = WaitForSingleObject(hPollForTrapEvent,
                         0/*immediate*/)) == 0xffffffff)
                    {
                    dbgprintf(1, "error on WaitForSingleObject %d\n",
                        GetLastError());
                    }
                else if (dwResult == 0 /*signaled*/)
                    {
                    AsnObjectIdentifier enterprise;
                    AsnInteger          genericTrap;
                    AsnInteger          specificTrap;
                    AsnTimeticks        timeStamp;
                    RFC1157VarBindList  variableBindings;

                    while(
                        (*trapAddr)(&enterprise, &genericTrap, &specificTrap,
                                    &timeStamp, &variableBindings)
                        )
                        {
                        printf("trap: gen=%d spec=%d time=%d\n",
                            genericTrap, specificTrap, timeStamp);

                        //also print data

                        } // end while ()

                    } // end if (trap ready)

                } // end if (handling traps)
#endif


         } // block


    return 0;

    } // end main()


//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\srvc_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvc_tbl.c

Abstract:

    All routines to support operations on the LM MIB Service Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "srvc_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Service table
static UINT                srvcSubids[] = { 2, 3, 1 };
static AsnObjectIdentifier MIB_SrvcPrefix = { 3, srvcSubids };

SRVC_TABLE   MIB_SrvcTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SRVC_FIELD_SUBID       (MIB_SrvcPrefix.idLength+MIB_OidPrefix.idLength)

#define SRVC_FIRST_FIELD       SRVC_NAME_FIELD
#define SRVC_LAST_FIELD        SRVC_PAUSED_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_srvcs_get(
        IN OUT RFC1157VarBind *VarBind
    );

int MIB_srvcs_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_srvcs_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_srvcs_func
//    High level routine for handling operations on the Service table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_srvcs_func(
    IN UINT Action,
    IN MIB_ENTRY *MibPtr,
    IN OUT RFC1157VarBind *VarBind
    )

{
    int     Found;
    UINT    Entry;
    UINT    Field;
    UINT    ErrStat;


    switch ( Action )
    {
        case MIB_ACTION_GETFIRST:
            // Fill the Service table with the info from server
            if ( SNMPAPI_ERROR == MIB_srvcs_lmget() )
            {
                ErrStat = SNMP_ERRORSTATUS_GENERR;
                goto Exit;
            }

            // If no elements in table, then return next MIB var, if one
            if ( MIB_SrvcTable.Len == 0 )
            {
                if ( MibPtr->MibNext == NULL )
                {
                    ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                    goto Exit;
                }

                // Do get first on the next MIB var
                ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                       VarBind );
                break;
            }

            //
            // Place correct OID in VarBind
            // Assuming the first field in the first record is the "start"
            {
                UINT temp_subs[] = { SRVC_FIRST_FIELD };
                AsnObjectIdentifier FieldOid = { 1, temp_subs };
                AsnObjectIdentifier tmpOid;
         
                tmpOid = VarBind->name; // keep a copy (structure copy)
                if (! SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
                {
                    VarBind->name = tmpOid; // restore
                    ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                    goto Exit;
                }
                if (! SnmpUtilOidAppend( &VarBind->name, &MIB_SrvcPrefix ))
                {
                    SnmpUtilOidFree(&VarBind->name);
                    VarBind->name = tmpOid; // restore
                    ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                    goto Exit;
                }
                if (! SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
                {
                    SnmpUtilOidFree(&VarBind->name);
                    VarBind->name = tmpOid; // restore
                    ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                    goto Exit;
                }
                if (! SnmpUtilOidAppend( &VarBind->name, &MIB_SrvcTable.Table[0].Oid ))
                {
                    SnmpUtilOidFree(&VarBind->name);
                    VarBind->name = tmpOid; // restore
                    ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                    goto Exit;
                }
                // free the original VarBind->name
                SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

        case MIB_ACTION_GET:
            ErrStat = MIB_srvcs_get( VarBind );
            break;

        case MIB_ACTION_GETNEXT:
            // Fill the Service Table with the info from server
            if ( SNMPAPI_ERROR == MIB_srvcs_lmget() )
            {
                ErrStat = SNMP_ERRORSTATUS_GENERR;
                goto Exit;
            }

            // Determine which field
            Field = VarBind->name.ids[SRVC_FIELD_SUBID];

            // Lookup OID in table
            if (Field < SRVC_FIRST_FIELD)
            {
                Entry = 0;                 // will take the first entry into the table
                Field = SRVC_FIRST_FIELD;  // and the first column of the table
                Found = MIB_TBL_POS_BEFORE;
            }
            else if (Field > SRVC_LAST_FIELD)
                Found = MIB_TBL_POS_END;
            else
                Found = MIB_srvcs_match( &VarBind->name, &Entry );

            // Index not found, but could be more fields to base GET on
            if ((Found == MIB_TBL_POS_BEFORE && MIB_SrvcTable.Len == 0) ||
                  Found == MIB_TBL_POS_END )
            {
                // Index not found in table, get next from field
                // Field ++;

                // Make sure not past last field
//            if ( Field > SRVC_LAST_FIELD )
//               {
               // Get next VAR in MIB
                ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                       MibPtr->MibNext,
                                                       VarBind );
                break;
//               }
            }

            // Get next TABLE entry
            if ( Found == MIB_TBL_POS_FOUND )
            {
                Entry ++;
                if ( Entry > MIB_SrvcTable.Len-1 )
                {
                    Entry = 0;
                    Field ++;
                    if ( Field > SRVC_LAST_FIELD )
                    {
                        // Get next VAR in MIB
                        ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                             MibPtr->MibNext,
                                                             VarBind );
                        break;
                    }
                }
            }

            //
            // Place correct OID in VarBind
            // Assuming the first field in the first record is the "start"
            {
                UINT temp_subs[1];
                AsnObjectIdentifier FieldOid;
                AsnObjectIdentifier tmpOid;

                temp_subs[0]      = Field;
                FieldOid.idLength = 1;
                FieldOid.ids      = temp_subs;
                
                tmpOid = VarBind->name; // keep a copy (structure copy)
                if (! SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
                {
                    VarBind->name = tmpOid; // restore
                    ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                    goto Exit;
                }
                if (! SnmpUtilOidAppend( &VarBind->name, &MIB_SrvcPrefix ))
                {
                    SnmpUtilOidFree(&VarBind->name);
                    VarBind->name = tmpOid; // restore
                    ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                    goto Exit;
                }
                if (! SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
                {
                    SnmpUtilOidFree(&VarBind->name);
                    VarBind->name = tmpOid; // restore
                    ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                    goto Exit;
                }
                if (! SnmpUtilOidAppend( &VarBind->name, &MIB_SrvcTable.Table[Entry].Oid ))
                {
                    SnmpUtilOidFree(&VarBind->name);
                    VarBind->name = tmpOid; // restore
                    ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
                    goto Exit;
                }
                // free the original VarBind->name
                SnmpUtilOidFree(&tmpOid);
            }

            ErrStat = MIB_srvcs_copyfromtable( Entry, Field, VarBind );

            break;

        case MIB_ACTION_SET:
            ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
            break;

        default:
            ErrStat = SNMP_ERRORSTATUS_GENERR;
    }

Exit:
    return ErrStat;
} // MIB_srvcs_func



//
// MIB_srvcs_get
//    Retrieve Service Table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_srvcs_get(
        IN OUT RFC1157VarBind *VarBind
    )

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[SRVC_FIELD_SUBID] < SRVC_FIRST_FIELD ||
       VarBind->name.ids[SRVC_FIELD_SUBID] > SRVC_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Service Table with the info from server
   if ( SNMPAPI_ERROR == MIB_srvcs_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_srvcs_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_srvcs_copyfromtable( Entry, VarBind->name.ids[SRVC_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_srvcs_get



//
// MIB_srvcs_match
//    Match the target OID with a location in the Service Table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_srvcs_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_SrvcPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_SrvcPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_SrvcTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_SrvcTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_srvcs_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_srvcs_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case SRVC_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_SrvcTable.Table[Entry].svSvcName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_SrvcTable.Table[Entry].svSvcName.stream,
                       MIB_SrvcTable.Table[Entry].svSvcName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_SrvcTable.Table[Entry].svSvcName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case SRVC_INSTALLED_FIELD:
         // Set value of var bind
         VarBind->value.asnValue.number =
                            MIB_SrvcTable.Table[Entry].svSvcInstalledState;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SRVC_OPERATING_FIELD:
         // Set value of var bind
         VarBind->value.asnValue.number =
                            MIB_SrvcTable.Table[Entry].svSvcOperatingState;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SRVC_UNINSTALLED_FIELD:
         // Set value of var bind
         VarBind->value.asnValue.number =
                      MIB_SrvcTable.Table[Entry].svSvcCanBeUninstalled;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      case SRVC_PAUSED_FIELD:
         // Set value of var bind
         VarBind->value.asnValue.number =
                                MIB_SrvcTable.Table[Entry].svSvcCanBePaused;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Services Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_srvcs_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\shar_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    shar_tbl.c

Abstract:

    All routines to perform operations on the Share Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "shar_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Share table
static UINT                shareSubids[] = { 2, 27, 1 };
static AsnObjectIdentifier MIB_SharePrefix = { 3, shareSubids };

SHARE_TABLE      MIB_ShareTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SHARE_FIELD_SUBID      (MIB_SharePrefix.idLength+MIB_OidPrefix.idLength)

#define SHARE_FIRST_FIELD       SHARE_NAME_FIELD
#define SHARE_LAST_FIELD        SHARE_COMMENT_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_shares_get(
        IN OUT RFC1157VarBind *VarBind
	);

int MIB_shares_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_shares_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_shares_func
//    High level routine for handling operations on the Share table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_shares_func(
	IN UINT Action,
        IN MIB_ENTRY *MibPtr,
	IN OUT RFC1157VarBind *VarBind
	)

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Share Table with the info from server
         MIB_shares_lmget();

         // If no elements in table, then return next MIB var, if one
         if ( MIB_ShareTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { SHARE_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };

          // prefix bug 445188
         AsnObjectIdentifier tmpOid;
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_SharePrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_ShareTable.Table[0].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_shares_get( VarBind );
	 break;

      case MIB_ACTION_GETNEXT:
         // Fill the Share table with the info from server
         MIB_shares_lmget();

         // Determine which field
         Field = VarBind->name.ids[SHARE_FIELD_SUBID];

        // Lookup OID in table
         if (Field < SHARE_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = SHARE_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > SHARE_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_shares_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_ShareTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > SHARE_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_ShareTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > SHARE_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;
         
         AsnObjectIdentifier tmpOid; // Prefix bug 445187

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         // Prefix bug 445187
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_SharePrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_ShareTable.Table[Entry].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_shares_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
	 break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_shares_func



//
// MIB_shares_get
//    Retrieve Share table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_shares_get(
        IN OUT RFC1157VarBind *VarBind
	)

{
UINT   Entry;
int    Found = MIB_TBL_POS_END;
UINT   ErrStat;

   if (VarBind->name.ids[SHARE_FIELD_SUBID] < SHARE_FIRST_FIELD ||
       VarBind->name.ids[SHARE_FIELD_SUBID] > SHARE_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Share table with the info from server
   MIB_shares_lmget();

   // Prefix # 118017
   // make sure  MIB_shares_lmget doesn't invalid the global MIB_ShareTable.Table
   if (MIB_ShareTable.Table)
      Found = MIB_shares_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_shares_copyfromtable( Entry, VarBind->name.ids[SHARE_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_shares_get



//
// MIB_shares_match
//    Match the target OID with a location in the Share table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_shares_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_SharePrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_SharePrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_ShareTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_ShareTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_shares_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_shares_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case SHARE_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_ShareTable.Table[Entry].svShareName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_ShareTable.Table[Entry].svShareName.stream,
                       MIB_ShareTable.Table[Entry].svShareName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_ShareTable.Table[Entry].svShareName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case SHARE_PATH_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_ShareTable.Table[Entry].svSharePath.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_ShareTable.Table[Entry].svSharePath.stream,
                       MIB_ShareTable.Table[Entry].svSharePath.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_ShareTable.Table[Entry].svSharePath.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case SHARE_COMMENT_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_ShareTable.Table[Entry].svShareComment.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_ShareTable.Table[Entry].svShareComment.stream,
                       MIB_ShareTable.Table[Entry].svShareComment.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_ShareTable.Table[Entry].svShareComment.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Share Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_shares_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\srvc_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvc_tbl.h

Abstract:

    Define all of the structures and routines used in the service table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

#ifndef srvc_tbl_h
#define srvc_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define SRVC_NAME_FIELD        1
#define SRVC_INSTALLED_FIELD   2
#define SRVC_OPERATING_FIELD   3
#define SRVC_UNINSTALLED_FIELD 4
#define SRVC_PAUSED_FIELD      5

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the service table
typedef struct srvc_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString svSvcName;            // Index
	   AsnInteger       svSvcInstalledState;
	   AsnInteger       svSvcOperatingState;
	   AsnInteger       svSvcCanBeUninstalled;
	   AsnInteger       svSvcCanBePaused;
	   } SRVC_ENTRY;

   // Service table definition
typedef struct
           {
	   UINT       Len;
	   SRVC_ENTRY *Table;
           } SRVC_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern SRVC_TABLE       MIB_SrvcTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_srvcs_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* srvc_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\srvr_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvr_lm.c

Abstract:

    This file contains the routines which actually call Lan Manager and
    retrieve the contents of the domain server table, including cacheing.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "srvr_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)   if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

int __cdecl srvr_entry_cmp(
       IN const DOM_SERVER_ENTRY *A,
       IN const DOM_SERVER_ENTRY *B
       ) ;

BOOL build_srvr_entry_oids( );

void FreeDomServerTable();

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_srvr_lmget
//    Retrieve domain server table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_svsond_lmget()
{
    DWORD               entriesread  = 0;
    DWORD               totalentries = 0;
    LPBYTE              bufptr       = NULL;
    unsigned            lmCode;
    unsigned            i;
    SERVER_INFO_100     *DataTable;
    DOM_SERVER_ENTRY    *MIB_DomServerTableElement ;
    int                 First_of_this_block;
    time_t              curr_time ;
    SNMPAPI             nResult = SNMPAPI_NOERROR;
    DWORD               resumehandle=0;
    DWORD               dwAllocatedEntries=0;



    time(&curr_time);   // get the time


    //
    //
    // If cached, return piece of info.
    //
    //
    if((NULL != cache_table[C_SRVR_TABLE].bufptr) && 
       (curr_time < (cache_table[C_SRVR_TABLE].acquisition_time + cache_expire[C_SRVR_TABLE]))
      )
    { // it has NOT expired!
        goto Exit ; // the global table is valid
    }


    // free the old table  LOOK OUT!!
    FreeDomServerTable();

    First_of_this_block = 0;
    do
    {
        //  as long as there is more data to process


        //
        //
        // Do network call to gather information and put it in a nice array
        //
        //
        lmCode = NetServerEnum(
                    NULL,           // local server NT_PROBLEM
                    100,            // level 100
                    &bufptr,        // data structure to return
                    MAX_PREFERRED_LENGTH,  
                    &entriesread,
                    &totalentries,
                    SV_TYPE_SERVER,
                    NULL,
                    &resumehandle       //  resume handle
                );

        DataTable = (SERVER_INFO_100 *) bufptr ;

        if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {
            // valid so process it, otherwise error

            if(0 == MIB_DomServerTable.Len)
            {
                // 1st time, alloc the whole table
                // alloc the table space
                MIB_DomServerTable.Table = SnmpUtilMemAlloc(totalentries * sizeof(DOM_SERVER_ENTRY) );
                if (MIB_DomServerTable.Table == NULL)
                {
                    // free all of the lan man data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
                }
                dwAllocatedEntries = totalentries;
            }

            MIB_DomServerTableElement = MIB_DomServerTable.Table + First_of_this_block ;

            for(i=0; (i<entriesread) && ((i+First_of_this_block) < dwAllocatedEntries); i++)
            {
                // once for each entry in the buffer
                // increment the entry number

                MIB_DomServerTable.Len ++;

                // Stuff the data into each item in the table
                MIB_DomServerTableElement->domServerName.dynamic = TRUE;
#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                    &MIB_DomServerTableElement->domServerName.stream,
                    DataTable->sv100_name,
                    TRUE))
                {
                    MIB_DomServerTableElement->domServerName.stream = NULL;
                    MIB_DomServerTableElement->domServerName.length = 0;
                    MIB_DomServerTableElement->domServerName.dynamic = FALSE;
                }
                else
                {
                    MIB_DomServerTableElement->domServerName.length =
                        strlen(MIB_DomServerTableElement->domServerName.stream);
                }
#else
                MIB_DomServerTableElement->domServerName.stream = SnmpUtilMemAlloc(strlen( DataTable->sv100_name ) + 1 );
                MIB_DomServerTableElement->domServerName.length = strlen( DataTable->sv100_name ) ;

                // client name
                memcpy(
                    MIB_DomServerTableElement->domServerName.stream,
                    DataTable->sv100_name,
                    strlen(DataTable->sv100_name)) ;
#endif

                MIB_DomServerTableElement ++ ;  // and table entry
                DataTable ++ ;  // advance pointer to next sess entry in buffer

            } // for each entry in the data table


            // free all of the lan man data
            SafeBufferFree( bufptr ) ;

            // indicate where to start adding on next pass, if any
            First_of_this_block += i ;

        } // if data is valid to process
        else
        {
            // if ERROR_NO_BROWSER_SERVERS_FOUND we are not running in an NetBIOS environment
            // in this case we will have an empty table.
            nResult = (lmCode == ERROR_NO_BROWSER_SERVERS_FOUND) ? SNMPAPI_NOERROR : SNMPAPI_ERROR;
            goto Exit;
        }

    } while (ERROR_MORE_DATA == lmCode) ;


    // iterate over the table populating the Oid field
    if (! build_srvr_entry_oids())
    {
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: build_srvr_entry_oids failed\n."));

        FreeDomServerTable();
        cache_table[C_SRVR_TABLE].bufptr = NULL;
        nResult = SNMPAPI_ERROR;
        goto Exit;

    }

    // Sort the table information using MSC QuickSort routine
    qsort( &MIB_DomServerTable.Table[0], MIB_DomServerTable.Len,
          sizeof(DOM_SERVER_ENTRY), srvr_entry_cmp );

    //
    //
    // Cache table
    //
    //

    if(0 != MIB_DomServerTable.Len)
    {
        cache_table[C_SRVR_TABLE].acquisition_time = curr_time ;
        cache_table[C_SRVR_TABLE].bufptr = bufptr ;
    }

    //
    //
    // Return piece of information requested
    //
    //
    Exit:
    return nResult;
} // MIB_srvr_get

//
// MIB_srvr_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl srvr_entry_cmp(
       IN const DOM_SERVER_ENTRY *A,
       IN const DOM_SERVER_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_srvr_cmp


//
//    None.
//
BOOL build_srvr_entry_oids(
       )

{
    AsnOctetString OSA ;
    DOM_SERVER_ENTRY *DomServerEntry ;
    unsigned i;

    // start pointer at 1st guy in the table
    DomServerEntry = MIB_DomServerTable.Table ;

    // now iterate over the table, creating an oid for each entry
    for( i=0; i<MIB_DomServerTable.Len ; i++)  {
        // for each entry in the session table

        OSA.stream = DomServerEntry->domServerName.stream ;
        OSA.length =  DomServerEntry->domServerName.length ;
        OSA.dynamic = FALSE;

        // Make the entry's OID from string index
        if (! MakeOidFromStr( &OSA, &DomServerEntry->Oid ))
        {
            return FALSE;
        }

        DomServerEntry++; // point to the next guy in the table

    } // for
    return TRUE;
} // build_srvr_entry_oids

void FreeDomServerTable()
{
    UINT i;
    DOM_SERVER_ENTRY    *MIB_DomServerTableElement ;
    
    MIB_DomServerTableElement = MIB_DomServerTable.Table ;
    if (MIB_DomServerTableElement)
    {
        // iterate over the whole table
        for(i=0; i<MIB_DomServerTable.Len ;i++)
        {
            // free any alloc'ed elements of the structure
            SnmpUtilOidFree(&(MIB_DomServerTableElement->Oid));
            SnmpUtilMemFree(MIB_DomServerTableElement->domServerName.stream);

            MIB_DomServerTableElement ++ ;      // increment table entry
        }
        SnmpUtilMemFree(MIB_DomServerTable.Table) ;    // free the base Table
    }
    MIB_DomServerTable.Table = NULL ;   // just for safety
    MIB_DomServerTable.Len = 0 ;        // just for safety
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\user_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    user_lm.c

Abstract:

    This file contains the routines which actually call Lan Manager and
    retrieve the contents of the user table, including cacheing.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "user_tbl.h"
#include "lmcache.h"


//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)       if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------


int __cdecl user_entry_cmp(
       IN const USER_ENTRY *A,
       IN const USER_ENTRY *B
       ) ;

BOOL build_user_entry_oids( );

void FreeUserTable();
//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_user_lmget
//    Retrieve print queue table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_users_lmget(
           )

{

DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
USER_INFO_0 *DataTable;
USER_ENTRY *MIB_UserTableElement ;
int First_of_this_block;
LPSTR ansi_string;
time_t curr_time ;
SNMPAPI nResult = SNMPAPI_NOERROR;
DWORD resumehandle=0;
DWORD dwAllocatedEntries=0;


    time(&curr_time);    // get the time


    //
    //
    // If cached, return piece of info.
    //
    //


    if((NULL != cache_table[C_USER_TABLE].bufptr) &&
        (curr_time <
            (cache_table[C_USER_TABLE].acquisition_time
                 + cache_expire[C_USER_TABLE]              ) ) )
        { // it has NOT expired!

        goto Exit ; // the global table is valid

        }

    //
    //
    // Do network call to gather information and put it in a nice array
    //
    //

    //
    // remember to free the existing data
    //

    FreeUserTable();

   First_of_this_block = 0;

   do {  //  as long as there is more data to process


        lmCode =
        NetUserEnum(    NULL,                   // local server
                        0,                      // level 0, no admin priv.
            FILTER_NORMAL_ACCOUNT,
                        &bufptr,                // data structure to return
                        MAX_PREFERRED_LENGTH,
                        &entriesread,
                        &totalentries,
                        &resumehandle           //  resume handle
                        );


    DataTable = (USER_INFO_0 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {  // valid so process it, otherwise error

        if(0 == MIB_UserTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_UserTable.Table = SnmpUtilMemAlloc(totalentries *
                                                sizeof(USER_ENTRY) );
                // prefix bugs 445183 and 445184
                if (MIB_UserTable.Table == NULL) {
                    // free all of the lan man data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit; 
                }
                dwAllocatedEntries = totalentries;
        }

        MIB_UserTableElement = MIB_UserTable.Table + First_of_this_block ;

        for(i=0; (i<entriesread) && ((i+First_of_this_block) < dwAllocatedEntries); i++) {  // once for each entry in the buffer


                // increment the entry number

                MIB_UserTable.Len ++;

                // Stuff the data into each item in the table

                // convert the undocumented unicode to something readable
                if (SnmpUtilUnicodeToUTF8(
                        &ansi_string,
                        DataTable->usri0_name,
                        TRUE )) // auto alloc the space for ansi
                {
                    MIB_UserTableElement->svUserName.stream = NULL;
                    MIB_UserTableElement->svUserName.length = 0;
                    MIB_UserTableElement->svUserName.dynamic = FALSE;
                }
                else
                {
                    // client name
                    MIB_UserTableElement->svUserName.stream = ansi_string;
                    MIB_UserTableElement->svUserName.length = strlen( ansi_string ) ;
                    MIB_UserTableElement->svUserName.dynamic = TRUE;
                }

                ansi_string = NULL;
                MIB_UserTableElement ++ ;  // and table entry

                DataTable ++ ;  // advance pointer to next sess entry in buffer

        } // for each entry in the data table

        // free all of the lan man data
        SafeBufferFree( bufptr ) ;

        // indicate where to start adding on next pass, if any
        First_of_this_block += i ;

        } // if data is valid to process
    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    if (! build_user_entry_oids())
    {
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: build_user_entry_oids failed\n."));

        FreeUserTable();
        cache_table[C_USER_TABLE].bufptr = NULL;
        nResult = SNMPAPI_ERROR;
        goto Exit;

    }

   // Sort the table information using MSC QuickSort routine
   qsort( &MIB_UserTable.Table[0], MIB_UserTable.Len,
          sizeof(USER_ENTRY), user_entry_cmp );

   //
   //
   // Cache table
   //
   //


   if(0 != MIB_UserTable.Len) {

        cache_table[C_USER_TABLE].acquisition_time = curr_time ;

        cache_table[C_USER_TABLE].bufptr = bufptr ;
   }

   //
   //
   // Return piece of information requested
   //
   //
Exit:
   return nResult;
} // MIB_user_get

//
// MIB_user_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl user_entry_cmp(
       IN const USER_ENTRY *A,
       IN const USER_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_user_cmp


//
//    None.
//
BOOL build_user_entry_oids(
       )

{
    AsnOctetString OSA ;
    USER_ENTRY *UserEntry ;
    unsigned i;

    // start pointer at 1st guy in the table
    UserEntry = MIB_UserTable.Table ;

    // now iterate over the table, creating an oid for each entry
    for( i=0; i<MIB_UserTable.Len ; i++)  {
        // for each entry in the session table

        OSA.stream = UserEntry->svUserName.stream ;
        OSA.length =  UserEntry->svUserName.length ;
        OSA.dynamic = FALSE;

        // Make the entry's OID from string index
        if (! MakeOidFromStr( &OSA, &UserEntry->Oid ))
        {
            return FALSE;
        }

        UserEntry++; // point to the next guy in the table

    } // for
    return TRUE;
} // build_user_entry_oids

void FreeUserTable()
{
    UINT i;
    USER_ENTRY *MIB_UserTableElement ;
     
    MIB_UserTableElement = MIB_UserTable.Table ;

    if (MIB_UserTableElement)
    {
        // iterate over the whole table
        for(i=0; i<MIB_UserTable.Len ;i++)
        {
            // free any alloc'ed elements of the structure
            SnmpUtilOidFree(&(MIB_UserTableElement->Oid));
            SnmpUtilMemFree(MIB_UserTableElement->svUserName.stream);

            MIB_UserTableElement ++ ;  // increment table entry
        }
        SnmpUtilMemFree(MIB_UserTable.Table) ;    // free the base Table
    }
    MIB_UserTable.Table = NULL ;       // just for safety
    MIB_UserTable.Len = 0 ;            // just for safety
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\srvr_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvr_tbl.c

Abstract:

    Routines to perform operations on the Domain Server Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "srvr_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Domain Server table
static UINT                svsondSubids[] = { 4, 6, 1 };
static AsnObjectIdentifier MIB_DomServerPrefix = { 3, svsondSubids };

DOM_SERVER_TABLE MIB_DomServerTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SRVR_FIELD_SUBID   (MIB_DomServerPrefix.idLength+MIB_OidPrefix.idLength)

#define SRVR_FIRST_FIELD       SRVR_NAME_FIELD
#define SRVR_LAST_FIELD        SRVR_NAME_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_svsond_get(
        IN OUT RFC1157VarBind *VarBind
    );

int MIB_svsond_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_svsond_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_svsond_func
//    High level routine for handling operations on the Domain Server table
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
UINT MIB_svsond_func(
    IN UINT Action,
        IN MIB_ENTRY *MibPtr,
    IN OUT RFC1157VarBind *VarBind
    )

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Domain Server table with the info from server
         if ( SNMPAPI_ERROR == MIB_svsond_lmget() )
        {
        ErrStat = SNMP_ERRORSTATUS_GENERR;
        goto Exit;
        }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_DomServerTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { SRVR_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };
         AsnObjectIdentifier tmpOid;

         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (! SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_DomServerPrefix ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_DomServerTable.Table[0].Oid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_svsond_get( VarBind );
     break;

      case MIB_ACTION_GETNEXT:
         // Fill the Domain Server table with the info from server
         if ( SNMPAPI_ERROR == MIB_svsond_lmget() )
        {
        ErrStat = SNMP_ERRORSTATUS_GENERR;
        goto Exit;
        }

         // Determine which field
         Field = VarBind->name.ids[SRVR_FIELD_SUBID];

         // Lookup OID in table
         if (Field < SRVR_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = SRVR_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > SRVR_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
            Found = MIB_svsond_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_DomServerTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > SRVR_LAST_FIELD )
//               {
                if ( MibPtr->MibNext == NULL )
                   {
                   ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                   goto Exit;
                   }
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_DomServerTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > SRVR_LAST_FIELD )
                  {
                  if ( MibPtr->MibNext == NULL )
                       {
                       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
                       goto Exit;
                       }
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;
         AsnObjectIdentifier tmpOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (! SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_DomServerPrefix ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_DomServerTable.Table[Entry].Oid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_svsond_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
     break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_svsond_func



//
// MIB_svsond_get
//    Retrieve Domain Server table information.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None.
//
UINT MIB_svsond_get(
        IN OUT RFC1157VarBind *VarBind
    )

{
UINT   Entry;
int    Found = MIB_TBL_POS_END;
UINT   ErrStat;

   if (VarBind->name.ids[SRVR_FIELD_SUBID] < SRVR_FIRST_FIELD ||
       VarBind->name.ids[SRVR_FIELD_SUBID] > SRVR_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Domain Server table with the info from server
   if ( SNMPAPI_ERROR == MIB_svsond_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }
   // Prefix # 447299
   // make sure  MIB_svsond_lmget doesn't invalid the global MIB_DomServerTable.Table
   if (MIB_DomServerTable.Table)
   {
       Found = MIB_svsond_match( &VarBind->name, &Entry );
   }
   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_svsond_copyfromtable( Entry, VarBind->name.ids[SRVR_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_svsond_get



//
// MIB_svsond_match
//    Match the target OID with a location in the Domain Server table
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None
//
int MIB_svsond_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_DomServerPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_DomServerPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_DomServerTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_DomServerTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



UINT MIB_svsond_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case SRVR_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_DomServerTable.Table[Entry].domServerName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_DomServerTable.Table[Entry].domServerName.stream,
                       MIB_DomServerTable.Table[Entry].domServerName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_DomServerTable.Table[Entry].domServerName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Domain Server Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_svsond_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\testdll.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    testdll.c

Abstract:

    LAN Manager MIB 2 Extension Agent DLL.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <windows.h>


//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

//#include <stdio.h>


//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>
#include <time.h>
#include <lm.h>

#include "hash.h"
#include "mib.h"
#include "lmcache.h"    // for cleanup the cache by SnmpExtensionClose

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

DWORD timeZero = 0;

extern void FreePrintQTable();
extern void FreeSessTable();
extern void FreeShareTable();
extern void FreeSrvcTable();
extern void FreeDomServerTable();
extern void FreeUserTable();
extern void FreeWkstaUsesTable();
extern void FreeDomOtherDomainTable();

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

BOOL DllEntryPoint(
    HINSTANCE   hInstDLL,
    DWORD       dwReason,
    LPVOID      lpReserved)
    {
    switch(dwReason)
        {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hInstDLL );
            break;
        case DLL_PROCESS_DETACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;

        } // end switch()

    return TRUE;

    } // end DllEntryPoint()


BOOL SnmpExtensionInit(
    IN  DWORD  timeZeroReference,
    OUT HANDLE *hPollForTrapEvent,
    OUT AsnObjectIdentifier *supportedView)
    {
    // record time reference from extendible agent
    timeZero = timeZeroReference;

    // setup trap notification
    *hPollForTrapEvent = NULL;

    // tell extendible agent what view this extension agent supports
    *supportedView = MIB_OidPrefix; // NOTE!  structure copy

    // Initialize MIB access hash table
    MIB_HashInit();

    return TRUE;

    } // end SnmpExtensionInit()


BOOL SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger          *genericTrap,
    OUT AsnInteger          *specificTrap,
    OUT AsnTimeticks        *timeStamp,
    OUT RFC1157VarBindList  *variableBindings)
    {

    return FALSE;

    } // end SnmpExtensionTrap()


// This function is implemented in file RESOLVE.C

#if 0
BOOL SnmpExtensionQuery(
    IN BYTE requestType,
    IN OUT RFC1157VarBindList *variableBindings,
    OUT AsnInteger *errorStatus,
    OUT AsnInteger *errorIndex)
    {

    } // end SnmpExtensionQuery()
#endif


VOID SnmpExtensionClose()
{
    UINT i;

    for (i=0; i < MAX_CACHE_ENTRIES ; ++i)
    {
        switch (i)
        {
        case C_PRNT_TABLE:
            FreePrintQTable();
            break;
            
        case C_SESS_TABLE:
            FreeSessTable();
            break;

        case C_SHAR_TABLE:
            FreeShareTable();
            break;
            
        case C_SRVC_TABLE:
            FreeSrvcTable();
            break;

        case C_SRVR_TABLE:
            FreeDomServerTable();
            break;

        case C_USER_TABLE:
            FreeUserTable();
            break;

        case C_USES_TABLE:
            FreeWkstaUsesTable();
            break;
        
        case C_ODOM_TABLE:
            FreeDomOtherDomainTable();
            break;

        default:
            if (cache_table[i].bufptr)
            {
                NetApiBufferFree(cache_table[i].bufptr);
            }
            cache_table[i].acquisition_time = 0;
            cache_table[i].entriesread = 0;
            cache_table[i].totalentries = 0;
            break;
        }   
    }
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\srvr_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    srvr_tbl.h

Abstract:

    Define all of the structures and routines used in the server table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef srvr_tbl_h
#define srvr_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define SRVR_NAME_FIELD        1

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the domain server table
typedef struct dom_server_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString domServerName; // Index
	   } DOM_SERVER_ENTRY;

   // Domain server table definition
typedef struct
           {
	   UINT             Len;
	   DOM_SERVER_ENTRY *Table;
           } DOM_SERVER_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern DOM_SERVER_TABLE MIB_DomServerTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_svsond_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* srvr_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\user_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    user_tbl.c

Abstract:

    All routines to perform operations on the User Table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "user_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Users table
static UINT                userSubids[] = { 2, 25, 1 };
static AsnObjectIdentifier MIB_UserPrefix = { 3, userSubids };

USER_TABLE MIB_UserTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define USER_FIELD_SUBID       (MIB_UserPrefix.idLength+MIB_OidPrefix.idLength)

#define USER_FIRST_FIELD       USER_NAME_FIELD
#define USER_LAST_FIELD        USER_NAME_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_users_get(
        IN OUT RFC1157VarBind *VarBind
	);

int MIB_users_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       );

UINT MIB_users_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_users_func
//    High level routine for handling operations on the Users table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_users_func(
	IN UINT Action,
        IN MIB_ENTRY *MibPtr,
	IN OUT RFC1157VarBind *VarBind
	)

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Users Table with the info from server
         if ( SNMPAPI_ERROR == MIB_users_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_UserTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { USER_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };

         // prefix bug 445189
         AsnObjectIdentifier tmpOid;
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_UserPrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_UserTable.Table[0].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_users_get( VarBind );
	 break;

      case MIB_ACTION_GETNEXT:
         // Fill the Users table with the info from server
         if ( SNMPAPI_ERROR == MIB_users_lmget() )
	    {
	    ErrStat = SNMP_ERRORSTATUS_GENERR;
	    goto Exit;
	    }

         // Determine which field
         Field = VarBind->name.ids[USER_FIELD_SUBID];

         // Lookup OID in table
         if (Field < USER_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = USER_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > USER_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_users_match( &VarBind->name, &Entry );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_UserTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > USER_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_UserTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > USER_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;

         AsnObjectIdentifier tmpOid; // Prefix bug 445189

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;

          // Prefix bug 445189
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ) == SNMPAPI_ERROR)
            {
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_UserPrefix ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &FieldOid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         if (SnmpUtilOidAppend( &VarBind->name, &MIB_UserTable.Table[Entry].Oid ) == SNMPAPI_ERROR)
            {
            SnmpUtilOidFree(&VarBind->name);
            VarBind->name = tmpOid; // restore
            ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
            goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_users_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
	 break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_users_func



//
// MIB_users_get
//    Retrieve Users table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_users_get(
        IN OUT RFC1157VarBind *VarBind
	)

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[USER_FIELD_SUBID] < USER_FIRST_FIELD ||
       VarBind->name.ids[USER_FIELD_SUBID] > USER_LAST_FIELD)
   {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
   }

   // Fill the Users table with the info from server
   if ( SNMPAPI_ERROR == MIB_users_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_users_match( &VarBind->name, &Entry );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_users_copyfromtable( Entry,
                                      VarBind->name.ids[USER_FIELD_SUBID],
                                      VarBind );

Exit:
   return ErrStat;
} // MIB_users_get



//
// MIB_users_match
//    Match the target OID with a location in the Users table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_users_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;


   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_UserPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_UserPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_UserTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_UserTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
}



//
// MIB_users_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_users_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case USER_NAME_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_UserTable.Table[Entry].svUserName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_UserTable.Table[Entry].svUserName.stream,
                       MIB_UserTable.Table[Entry].svUserName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_UserTable.Table[Entry].svUserName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error Users Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_users_copyfromtable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\test.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    test.c

Abstract:

    Test the LM MIB and its supporting functions.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mib.h"
#include "mibfuncs.h"
#include "hash.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

SNMPAPI SnmpExtensionQuery(
	   IN AsnInteger ReqType,               // 1157 Request type
	   IN OUT RFC1157VarBindList *VarBinds, // Var Binds to resolve
	   OUT AsnInteger *ErrorStatus,         // Error status returned
	   OUT AsnInteger *ErrorIndex           // Var Bind containing error
	   );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

BYTE pBuffer[2000];
UINT nLength;
SnmpMgmtCom Msg;
MIB_ENTRY *MibPtr;
void *pResult;

void main( )

{

   //
   // Init hashing system
   //
   MIB_HashInit();

   //
   // Title
   //
   printf( "Tests for MIB root:  " );
   SnmpUtilPrintOid( &MIB_OidPrefix ); printf( "\n--------------------------\n\n" );

   //
   // Display significant Mib variables
   //
   printf( "Common start:  " );
   SnmpUtilPrintOid( &Mib[MIB_COM_START].Oid );
   putchar( '\n' );
   printf( "Server start:  " );
   SnmpUtilPrintOid( &Mib[MIB_SV_START].Oid );
   putchar( '\n' );
   printf( "Workstation start:  " );
   SnmpUtilPrintOid( &Mib[MIB_WKSTA_START].Oid );
   putchar( '\n' );
   printf( "Domain start:  " );
   SnmpUtilPrintOid( &Mib[MIB_DOM_START].Oid );
   putchar( '\n' );

   printf( "Last MIB variable:  " );
   SnmpUtilPrintOid( &Mib[MIB_num_variables-1].Oid );
   putchar( '\n' );
   putchar( '\n' );

   //
   // Specific tests for integrity
   //

   printf( "FIRST leaf get\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 1, 1, 0 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      SnmpUtilPrintOid( &varBinds.list[0].name ); printf ( "  =  " );
      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                          &varBinds,
			  &errorStatus,
			  &errorIndex
                          );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "LAST leaf get\n" );

      {
#if 1
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 4, 5, 0 };
#else
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 4, 7, 0 };
#endif
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      SnmpUtilPrintOid( &varBinds.list[0].name ); printf ( "  =  " );
      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                          &varBinds,
			  &errorStatus,
			  &errorIndex
                          );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET on an AGGREGATE\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      SnmpUtilPrintOid( &varBinds.list[0].name ); printf ( "  =  " );
      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                          &varBinds,
			  &errorStatus,
			  &errorIndex
                          );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET on a TABLE root\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 3, 8, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      SnmpUtilPrintOid( &varBinds.list[0].name ); printf ( "  =  " );
      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                          &varBinds,
			  &errorStatus,
			  &errorIndex
                          );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET on a NON existent variable\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 100, 8 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      SnmpUtilPrintOid( &varBinds.list[0].name ); printf ( "  =  " );
      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                          &varBinds,
			  &errorStatus,
			  &errorIndex
                          );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT on hole with MIB-TABLE following\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20, 0 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "   " );
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "\n  =  " );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT on hole with MIB-AGGREGATE following\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 26, 0 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "   " );
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "\n  =  " );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT on hole with LEAF following\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 4, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "   " );
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "\n  =  " );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT on variable BEFORE Beginning of LM MIB\n" );

      {
      UINT itemn[]                 = { 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "   " );
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "\n  =  " );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT on variable past end of MIB\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 2 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "   " );
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( "\n  =  " );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	 }
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on Server Description\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 1, 0 };
      BYTE *Value                  = "This server sux";
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_RFC1213_DISPSTRING;
      varBinds.list[0].value.asnValue.string.stream = Value;
      varBinds.list[0].value.asnValue.string.length = strlen( Value );
      varBinds.list[0].value.asnValue.string.dynamic = FALSE;

      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nSET Errorstatus:  %lu\n\n", errorStatus );

      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         printf( "New Value:  " );
	 SnmpUtilPrintAsnAny( &varBinds.list[0].value ); putchar( '\n' );
	 }
      printf( "\nGET Errorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "Try and SET Server Description with WRONG type\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 1, 0 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_INTEGER;

      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nSET Errorstatus:  %lu\n\n", errorStatus );

      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         printf( "New Value:  " );
         SnmpUtilPrintAsnAny( &varBinds.list[0].value ); putchar( '\n' );
	 }

      printf( "\nGET Errorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "Try and SET a LEAF that is READ-ONLY\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 1, 1, 0 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_INTEGER;

      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nSET Errorstatus:  %lu\n\n", errorStatus );

      SnmpExtensionQuery( ASN_RFC1157_GETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
         {
         printf( "New Value:  " );
	 SnmpUtilPrintAsnAny( &varBinds.list[0].value ); putchar( '\n' );
	 }
      printf( "\nGET Errorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on the odom table to add entry\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 4, 4, 1, 1, 4, 'T', 'O', 'D', 'D' };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_RFC1213_DISPSTRING;
      varBinds.list[0].value.asnValue.string.length = 4;
      varBinds.list[0].value.asnValue.string.stream = "TODD";
      varBinds.list[0].value.asnValue.string.dynamic = FALSE;

      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on root of session table\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );

      varBinds.list[0].value.asnType         = ASN_INTEGER;
      varBinds.list[0].value.asnValue.number = 2;
      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on root entry of session table\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );

      varBinds.list[0].value.asnType         = ASN_INTEGER;
      varBinds.list[0].value.asnValue.number = 2;
      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on an invalid field in session table\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      // Get entry in the session table to delete
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );

      // Adjust to set a bad field
      varBinds.list[0].name.ids[11] = 7;
      varBinds.list[0].value.asnType         = ASN_INTEGER;
      varBinds.list[0].value.asnValue.number = 2;
      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET with invalid type on field in session table\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      // Get entry in the session table to delete
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );

      // Adjust to set the svSesState to DELETED
      varBinds.list[0].name.ids[11]  = 8;
      varBinds.list[0].value.asnType = ASN_NULL;
      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on non-existent entry in session table\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20, 1, 8, 1, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );

      varBinds.list[0].value.asnType         = ASN_INTEGER;
      varBinds.list[0].value.asnValue.number = 2;
      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "SET on the session table to delete entry\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1, 2, 20 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus       = 0;
      AsnInteger errorIndex        = 0;

      varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
      varBinds.len = 1;
      varBinds.list[0].name.idLength = sizeof itemn / sizeof(UINT);
      varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                             varBinds.list[0].name.idLength );
      memcpy( varBinds.list[0].name.ids, &itemn,
              sizeof(UINT)*varBinds.list[0].name.idLength );
      varBinds.list[0].value.asnType = ASN_NULL;

      // Get entry in the session table to delete
      SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );

      // Adjust to set the svSesState to DELETED
      varBinds.list[0].name.ids[11] = 8;
      varBinds.list[0].value.asnType         = ASN_INTEGER;
      varBinds.list[0].value.asnValue.number = 2;

      
      printf( "SET:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
      printf( " to " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
      SnmpExtensionQuery( ASN_RFC1157_SETREQUEST,
                             &varBinds,
			     &errorStatus,
			     &errorIndex
                             );
      printf( "\nErrorstatus:  %lu\n\n", errorStatus );

      // Free the memory
      SnmpUtilVarBindListFree( &varBinds );
      }

   printf( "GET-NEXT starting from ROOT of LM MIB\n" );

      {
      UINT itemn[]                 = { 1, 3, 6, 1, 4, 1, 77, 1 };
      RFC1157VarBindList varBinds;
      AsnInteger errorStatus;
      AsnInteger errorIndex;
      BOOL Continue                = TRUE;
      time_t Time;

      while ( Continue )
         {
	 errorStatus = 0;
	 errorIndex  = 0;
         varBinds.list = (RFC1157VarBind *)SnmpUtilMemAlloc( sizeof(RFC1157VarBind) );
         varBinds.len = 1;
SnmpUtilOidCpy( &varBinds.list[0].name, &MIB_OidPrefix );
#if 0
         varBinds.list[0].name.idLength = MIB_PREFIX_LEN;
         varBinds.list[0].name.ids = (UINT *)SnmpUtilMemAlloc( sizeof(UINT)*
                                               varBinds.list[0].name.idLength );
         memcpy( varBinds.list[0].name.ids, &itemn,
                 sizeof(UINT)*varBinds.list[0].name.idLength );
#endif
         varBinds.list[0].value.asnType = ASN_NULL;

         do
            {
            Time = time( NULL );
            printf( "Time:  %s", ctime(&Time) );
	    printf( "GET-NEXT of:  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
                                        printf( "   " );
            SnmpExtensionQuery( ASN_RFC1157_GETNEXTREQUEST,
                                &varBinds,
			        &errorStatus,
			        &errorIndex
                                );
            printf( "\n  is  " ); SnmpUtilPrintOid( &varBinds.list[0].name );
	    if ( errorStatus )
	       {
               printf( "\nErrorstatus:  %lu\n\n", errorStatus );
	       }
	    else
	       {
               printf( "\n  =  " ); SnmpUtilPrintAsnAny( &varBinds.list[0].value );
	       }
            putchar( '\n' );
            }
         while ( varBinds.list[0].name.ids[MIB_PREFIX_LEN-1] != 1 );

         // Free the memory
         SnmpUtilVarBindListFree( &varBinds );

	 // Prompt for next pass
	 printf( "Press ENTER to continue, CTRL-C to quit\n" );
	 getchar();
         } // while continue
      }
} // test

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\user_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    user_tbl.h

Abstract:

    Define all structures and routines for user table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef user_tbl_h
#define user_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define USER_NAME_FIELD        1

//--------------------------- PUBLIC STRUCTS --------------------------------


   // Entries in the user table
typedef struct user_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString svUserName; // Index
	   } USER_ENTRY;

   // User table definition
typedef struct
           {
	   UINT       Len;
	   USER_ENTRY *Table;
           } USER_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern USER_TABLE       MIB_UserTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_users_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* user_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\uses_lm.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    uses_lm.c

Abstract:

    This file contains the routines which actually call Lan Manager and
    retrieve the contents of the workstation uses table, including cacheing.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#ifdef WIN32
#include <windows.h>
#include <lm.h>
#endif

#include <tchar.h>
#include <string.h>
#include <search.h>
#include <stdlib.h>
#include <time.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------


#include "mib.h"
#include "mibfuncs.h"
#include "uses_tbl.h"
#include "lmcache.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define SafeBufferFree(x)       if(NULL != x) NetApiBufferFree( x )
#define SafeFree(x)             if(NULL != x) SnmpUtilMemFree( x )

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

int __cdecl uses_entry_cmp(
       IN const WKSTA_USES_ENTRY *A,
       IN const WKSTA_USES_ENTRY *B
       ) ;

BOOL build_uses_entry_oids( );

void FreeWkstaUsesTable();

//--------------------------- PUBLIC PROCEDURES -----------------------------


//
// MIB_wsuses_lmget
//    Retrieve workstation uses table information from Lan Manager.
//    If not cached, sort it and then
//    cache it.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI MIB_wsuses_lmget(
           )

{

DWORD entriesread;
DWORD totalentries;
LPBYTE bufptr;
unsigned lmCode;
unsigned i;
USE_INFO_1 *DataTable;
WKSTA_USES_ENTRY *MIB_WkstaUsesTableElement ;
int First_of_this_block;
time_t curr_time ;
SNMPAPI nResult = SNMPAPI_NOERROR;
DWORD resumehandle=0;
DWORD dwAllocatedEntries=0;


   time(&curr_time);    // get the time


   //
   //
   // If cached, return piece of info.
   //
   //

   if((NULL != cache_table[C_USES_TABLE].bufptr) &&
      (curr_time <
        (cache_table[C_USES_TABLE].acquisition_time
                 + cache_expire[C_USES_TABLE]              ) ) )
        { // it has NOT expired!

        goto Exit ; // the global table is valid

        }


   //
   //
   // Do network call to gather information and put it in a nice array
   //
   //

   // free the old table  LOOK OUT!!

   FreeWkstaUsesTable();


   First_of_this_block = 0;

   do {  //  as long as there is more data to process

   lmCode =
        NetUseEnum(     NULL,   // local server
        1,                      // level 1, no admin priv.
        &bufptr,                // data structure to return
        MAX_PREFERRED_LENGTH,
        &entriesread,
        &totalentries,
        &resumehandle           //  resume handle
        );


    DataTable = (USE_INFO_1 *) bufptr ;

    if((NERR_Success == lmCode) || (ERROR_MORE_DATA == lmCode))
        {  // valid so process it, otherwise error

        if(0 == MIB_WkstaUsesTable.Len) {  // 1st time, alloc the whole table
                // alloc the table space
                MIB_WkstaUsesTable.Table = SnmpUtilMemAlloc(totalentries *
                                                sizeof(WKSTA_USES_ENTRY) );
                // prefix bugs 445182
                if (MIB_WkstaUsesTable.Table == NULL) {
                    // free all of the lan man data
                    SafeBufferFree( bufptr ) ;
                    // Signal error
                    nResult = SNMPAPI_ERROR;
                    goto Exit; 
                }
                dwAllocatedEntries = totalentries;
        }

        MIB_WkstaUsesTableElement = MIB_WkstaUsesTable.Table + First_of_this_block ;

        for(i=0; (i<entriesread) && ((i+First_of_this_block) < dwAllocatedEntries); i++) {  // once for each entry in the buffer


                // increment the entry number

                MIB_WkstaUsesTable.Len ++;

                // Stuff the data into each item in the table

                // client name
                MIB_WkstaUsesTableElement->useLocalName.dynamic = TRUE;

#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                        &MIB_WkstaUsesTableElement->useLocalName.stream,
                        DataTable->ui1_local,
                        TRUE))
                {
                    MIB_WkstaUsesTableElement->useLocalName.length = 0;
                    MIB_WkstaUsesTableElement->useLocalName.stream = NULL;
                    MIB_WkstaUsesTableElement->useLocalName.dynamic = FALSE;
                }
                else
                {
                    MIB_WkstaUsesTableElement->useLocalName.length =
                        strlen(MIB_WkstaUsesTableElement->useLocalName.stream);
                }
#else
                MIB_WkstaUsesTableElement->useLocalName.stream = SnmpUtilMemAlloc (
                                strlen( DataTable->ui1_local ) + 1 ) ;
                MIB_WkstaUsesTableElement->useLocalName.length =
                                strlen( DataTable->ui1_local ) ;
                memcpy( MIB_WkstaUsesTableElement->useLocalName.stream,
                        DataTable->ui1_local,
                        strlen( DataTable->ui1_local ) ) ;
#endif

                // remote name
                MIB_WkstaUsesTableElement->useRemote.dynamic = TRUE;

#ifdef UNICODE
                if (SnmpUtilUnicodeToUTF8(
                        &MIB_WkstaUsesTableElement->useRemote.stream,
                        DataTable->ui1_remote,
                        TRUE))
                {
                    MIB_WkstaUsesTableElement->useRemote.length = 0;
                    MIB_WkstaUsesTableElement->useRemote.stream = NULL;
                    MIB_WkstaUsesTableElement->useRemote.dynamic = FALSE;
                }
                else
                {
                    MIB_WkstaUsesTableElement->useRemote.length = 
                        strlen(MIB_WkstaUsesTableElement->useRemote.stream);
                }
#else
                MIB_WkstaUsesTableElement->useRemote.stream = SnmpUtilMemAlloc (
                                strlen( DataTable->ui1_remote ) + 1 ) ;
                MIB_WkstaUsesTableElement->useRemote.length =
                                strlen( DataTable->ui1_remote ) ;

                memcpy( MIB_WkstaUsesTableElement->useRemote.stream,
                        DataTable->ui1_remote,
                        strlen( DataTable->ui1_remote ) ) ;
#endif

                // status
                MIB_WkstaUsesTableElement->useStatus =
                                DataTable->ui1_status ;


                MIB_WkstaUsesTableElement ++ ;  // and table entry

                DataTable ++ ;  // advance pointer to next sess entry in buffer

        } // for each entry in the data table

        // free all of the lan man data
        SafeBufferFree( bufptr ) ;


        // indicate where to start adding on next pass, if any
        First_of_this_block += i ;

        } // if data is valid to process
    else
       {
       // Signal error
       nResult = SNMPAPI_ERROR;
       goto Exit;
       }

    } while (ERROR_MORE_DATA == lmCode) ;

    // iterate over the table populating the Oid field
    if (! build_uses_entry_oids())
    {
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: LMMIB2: build_uses_entry_oids failed\n."));

        FreeWkstaUsesTable();
        cache_table[C_USES_TABLE].bufptr = NULL;
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

   // Sort the table information using MSC QuickSort routine
   qsort( &MIB_WkstaUsesTable.Table[0], MIB_WkstaUsesTable.Len,
          sizeof(WKSTA_USES_ENTRY), uses_entry_cmp );

   //
   //
   // Cache table
   //
   //

   if(0 != MIB_WkstaUsesTable.Len) {

        cache_table[C_USES_TABLE].acquisition_time = curr_time ;

        cache_table[C_USES_TABLE].bufptr = bufptr ;
   }


   //
   //
   // Return piece of information requested
   //
   //
Exit:
   return nResult;
} // MIB_uses_get

//
// MIB_uses_cmp
//    Routine for sorting the session table.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
int __cdecl uses_entry_cmp(
       IN const WKSTA_USES_ENTRY *A,
       IN const WKSTA_USES_ENTRY *B
       )

{
   // Compare the OID's
   return SnmpUtilOidCmp( (AsnObjectIdentifier *)&A->Oid,
                       (AsnObjectIdentifier *)&B->Oid );
} // MIB_uses_cmp


//
//    None.
//
BOOL build_uses_entry_oids(
       )

{
    AsnOctetString OSA ;
    AsnObjectIdentifier RemoteOid ;
    WKSTA_USES_ENTRY *WkstaUsesEntry ;
    unsigned i;

    // start pointer at 1st guy in the table
    WkstaUsesEntry = MIB_WkstaUsesTable.Table ;

    // now iterate over the table, creating an oid for each entry
    for( i=0; i<MIB_WkstaUsesTable.Len ; i++)  {
        // for each entry in the session table

        // copy the local name into the oid buffer first
        if (! MakeOidFromStr( &WkstaUsesEntry->useLocalName, &WkstaUsesEntry->Oid ))
        {
            return FALSE;
        }

        // copy the remote name into a temporary oid buffer
        if (! MakeOidFromStr( &WkstaUsesEntry->useRemote, &RemoteOid ))
        {
            return FALSE;
        }

        // append the two entries forming the index
        if (! SnmpUtilOidAppend( &WkstaUsesEntry->Oid, &RemoteOid ))
        {
            SnmpUtilOidFree(&RemoteOid);
            return FALSE;
        }

        // free the temporary buffer
        SnmpUtilOidFree( &RemoteOid );

        WkstaUsesEntry++; // point to the next guy in the table

    } // for
    return TRUE;
} // build_uses_entry_oids

void FreeWkstaUsesTable()
{
    UINT i;
    WKSTA_USES_ENTRY *MIB_WkstaUsesTableElement;

    MIB_WkstaUsesTableElement = MIB_WkstaUsesTable.Table ;
    if (MIB_WkstaUsesTableElement)
    {
        // iterate over the whole table
        for(i=0; i<MIB_WkstaUsesTable.Len ;i++)
        {
            // free any alloc'ed elements of the structure
            SnmpUtilOidFree(&(MIB_WkstaUsesTableElement->Oid));
            SnmpUtilMemFree(MIB_WkstaUsesTableElement->useLocalName.stream);
            SnmpUtilMemFree(MIB_WkstaUsesTableElement->useRemote.stream);

            MIB_WkstaUsesTableElement ++ ;  // increment table entry
        }
        SnmpUtilMemFree(MIB_WkstaUsesTable.Table) ; // free the base Table
    }
    MIB_WkstaUsesTable.Table = NULL ;  // just for safety
    MIB_WkstaUsesTable.Len = 0 ;       // just for safety
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpeldl.h ===
#ifndef SNMPELDLL_H
#define SNMPELDLL_H

extern  DWORD           SnmpEvLogProc(void);
extern  HANDLE          hMutex;                                 // handle for mutex object
extern  VOID            WriteTrace(UINT nLvl, LPSTR CONST szStuff, ...);
extern  TCHAR           szTraceFileName[];                      // trace filename
extern  DWORD           nTraceLevel;                            // trace level
extern  BOOL            fTraceFileName;                         // trace filename param existance flag
extern  BOOL            fMsgModule;                             // flag indicating registry read for message module
extern  HMODULE         hMsgModule;                             // handle to message module


        LPTSTR          lpszEventLogs = (LPTSTR) NULL;          // pointer to event log name array
        PHANDLE         phEventLogs = (PHANDLE) NULL;           // Pointer to event log handle array
        PHMODULE        phPrimHandles = (PHMODULE) NULL;        // pointer to primary module handle array
        UINT            uNumEventLogs = 0;                      // Number of event logs present
        INT             iLogNameSize = 0;                       // size of event log name array
        UINT            nMaxTrapSize = 0;                       // maximum trap size

        HKEY            hkRegResult = (HKEY) NULL;              // handle to Parameters registry entry
        HANDLE          hWriteEvent = (HANDLE) NULL;            // handle to write log events
        HANDLE          hStopAll = (HANDLE) NULL;               // handle to global dll shutdown event
        HANDLE          hServThrd = (HANDLE) NULL;              // handle to SNMPELPT thread
        HANDLE          hEventNotify = (HANDLE) NULL;           // handle to notify SNMPELDL that a trap is ready to process
        HANDLE          hRegChanged = (HANDLE) NULL;            // handle to registry key changed event

        BOOL            fGlobalTrim = TRUE;                     // global message trimming flag (trim msg first or insertion strings first)
        BOOL            fThresholdEnabled = TRUE;               // global threshold checking enabled flag
        BOOL            fTrimFlag = FALSE;                      // global trimming flag (do or don't do trimming at all)
        BOOL            fTrapSent = FALSE;                      // global trap sent flag
        BOOL            fRegNotify = FALSE;                     // registry notification initialization flag
        BOOL            fRegOk = FALSE;                         // registry notification in effect flag
        BOOL            fLogInit = FALSE;                       // indicate log file registry information not yet read
        BOOL            fThreshold = FALSE;                     // global performance threshold flag
        BOOL            fSendThresholdTrap = FALSE;             // indicator to send threshold reached trap
        BOOL            fDoLogonEvents = TRUE;                  // do we need to send logon events

        TCHAR           szBaseOID[MAX_PATH+1] = TEXT("");       // base enterprise OID
        TCHAR           szSupView[MAX_PATH+1] = TEXT("");       // supported view OID

        DWORD           dwTimeZero;                             // time zero reference
        DWORD           dwThresholdCount;                       // threshold count for performance
        DWORD           dwThresholdTime;                        // time in seconds for threshold for performance
        DWORD           dwTrapCount = 0;                        // number of traps sent
        DWORD           dwTrapStartTime = 0;                    // time when first trap in time period sent
        DWORD           dwLastBootTime = 0;                     // time the last boot occurred
        DWORD           dwTrapQueueSize = 0;

        // WinSE Bug# 15128, Windows Bug# 293698  
        // default is INFINITE ==> no polling (wait for system notification)
        DWORD           g_dwEventLogPollTime = (DWORD)INFINITE; // time in millsecs to poll for event logs
        // WINSE Bug# 30362, Windows Bug# 659770
        // default is 9999 which is a sufficient large sub-identifier to avoid 
        // conflict between the formation of Enterprise OID and VarBind OID
        const DWORD     g_dwDefaultVarBindPrefixSubId = 9999; 
        DWORD           g_dwVarBindPrefixSubId = g_dwDefaultVarBindPrefixSubId;

        PVarBindQueue   lpVarBindQueue = (PVarBindQueue) NULL;  // pointer to first varbind queue entry
        PSourceHandleList   lpSourceHandleList = (PSourceHandleList) NULL;  // pointer to first source/handle entry

        AsnObjectIdentifier thresholdOID;                       // OID used for threshold reached trap
        RFC1157VarBindList  thresholdVarBind;                   // varbind list used for threshold reached trap
const   TCHAR           lpszThreshold[] = TEXT("SNMP EventLog Extension Agent is quiescing trap processing due to performance threshold parameters.");


#endif                          // end of snmpeldl.h definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\uses_tbl.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    uses_tbl.c

Abstract:

    Routines to perform operations on the Workstation Uses table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <stdio.h>
#include <memory.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include <snmp.h>
#include <snmputil.h>

#include "mibfuncs.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "uses_tbl.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

   // Prefix to the Uses table
static UINT                usesSubids[] = { 3, 8, 1 };
static AsnObjectIdentifier MIB_UsesPrefix = { 3, usesSubids };

WKSTA_USES_TABLE MIB_WkstaUsesTable = { 0, NULL };

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define USES_FIELD_SUBID       (MIB_UsesPrefix.idLength+MIB_OidPrefix.idLength)

#define USES_FIRST_FIELD       USES_LOCAL_FIELD
#define USES_LAST_FIELD        USES_STATUS_FIELD

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------


//--------------------------- PRIVATE PROTOTYPES ----------------------------

UINT MIB_wsuses_get(
        IN OUT RFC1157VarBind *VarBind
        );

int MIB_wsuses_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos,
       IN BOOL Next
       );

UINT MIB_wsuses_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        );

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// MIB_wsuses_func
//    High level routine for handling operations on the uses table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_wsuses_func(
        IN UINT Action,
        IN MIB_ENTRY *MibPtr,
        IN OUT RFC1157VarBind *VarBind
        )

{
int     Found;
UINT    Entry;
UINT    Field;
UINT    ErrStat;


   switch ( Action )
      {
      case MIB_ACTION_GETFIRST:
         // Fill the Uses table with the info from server
         if ( SNMPAPI_ERROR == MIB_wsuses_lmget() )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // If no elements in table, then return next MIB var, if one
         if ( MIB_WkstaUsesTable.Len == 0 )
            {
            if ( MibPtr->MibNext == NULL )
               {
               ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
               goto Exit;
               }

            // Do get first on the next MIB var
            ErrStat = (*MibPtr->MibNext->MibFunc)( Action, MibPtr->MibNext,
                                                   VarBind );
            break;
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[] = { USES_FIRST_FIELD };
         AsnObjectIdentifier FieldOid = { 1, temp_subs };
         AsnObjectIdentifier tmpOid;

         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (! SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_UsesPrefix ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_WkstaUsesTable.Table[0].Oid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         //
         // Let fall through on purpose
         //

      case MIB_ACTION_GET:
         ErrStat = MIB_wsuses_get( VarBind );
         break;

      case MIB_ACTION_GETNEXT:
         // Fill the Uses table with the info from server
         if ( SNMPAPI_ERROR == MIB_wsuses_lmget() )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Determine which field
         Field = VarBind->name.ids[USES_FIELD_SUBID];

         // Lookup OID in table
         if (Field < USES_FIRST_FIELD)
         {
             Entry = 0;                 // will take the first entry into the table
             Field = USES_FIRST_FIELD;  // and the first column of the table
             Found = MIB_TBL_POS_BEFORE;
         }
         else if (Field > USES_LAST_FIELD)
             Found = MIB_TBL_POS_END;
         else
             Found = MIB_wsuses_match( &VarBind->name, &Entry, TRUE );

         // Index not found, but could be more fields to base GET on
         if ((Found == MIB_TBL_POS_BEFORE && MIB_WkstaUsesTable.Len == 0) ||
              Found == MIB_TBL_POS_END )
            {
            // Index not found in table, get next from field
//            Field ++;

            // Make sure not past last field
//            if ( Field > USES_LAST_FIELD )
//               {
               // Get next VAR in MIB
               ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                      MibPtr->MibNext,
                                                      VarBind );
               break;
//               }
            }

         // Get next TABLE entry
         if ( Found == MIB_TBL_POS_FOUND )
            {
            Entry ++;
            if ( Entry > MIB_WkstaUsesTable.Len-1 )
               {
               Entry = 0;
               Field ++;
               if ( Field > USES_LAST_FIELD )
                  {
                  // Get next VAR in MIB
                  ErrStat = (*MibPtr->MibNext->MibFunc)( MIB_ACTION_GETFIRST,
                                                         MibPtr->MibNext,
                                                         VarBind );
                  break;
                  }
               }
            }

         //
         // Place correct OID in VarBind
         // Assuming the first field in the first record is the "start"
         {
         UINT temp_subs[1];
         AsnObjectIdentifier FieldOid;
         AsnObjectIdentifier tmpOid;

         temp_subs[0]      = Field;
         FieldOid.idLength = 1;
         FieldOid.ids      = temp_subs;
         
         tmpOid = VarBind->name; // keep a copy (structure copy)
         if (! SnmpUtilOidCpy( &VarBind->name, &MIB_OidPrefix ))
            {
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_UsesPrefix ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &FieldOid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         if (! SnmpUtilOidAppend( &VarBind->name, &MIB_WkstaUsesTable.Table[Entry].Oid ))
            {
             SnmpUtilOidFree(&VarBind->name);
             VarBind->name = tmpOid; // restore
             ErrStat = SNMP_ERRORSTATUS_RESOURCEUNAVAILABLE;
             goto Exit;
            }
         // free the original VarBind->name
         SnmpUtilOidFree(&tmpOid);
         }

         ErrStat = MIB_wsuses_copyfromtable( Entry, Field, VarBind );

         break;

      case MIB_ACTION_SET:
         ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
         break;

      default:
         ErrStat = SNMP_ERRORSTATUS_GENERR;
      }

Exit:
   return ErrStat;
} // MIB_wsuses_func



//
// MIB_wsuses_get
//    Retrieve Uses table information.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_wsuses_get(
        IN OUT RFC1157VarBind *VarBind
        )

{
UINT   Entry;
int    Found;
UINT   ErrStat;

   if (VarBind->name.ids[USES_FIELD_SUBID] < USES_FIRST_FIELD ||
       VarBind->name.ids[USES_FIELD_SUBID] > USES_LAST_FIELD)
       {
       ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
       goto Exit;
       }

   // Fill the Uses table with the info from server
   if ( SNMPAPI_ERROR == MIB_wsuses_lmget() )
      {
      ErrStat = SNMP_ERRORSTATUS_GENERR;
      goto Exit;
      }

   Found = MIB_wsuses_match( &VarBind->name, &Entry, FALSE );

   // Look for a complete OID match
   if ( Found != MIB_TBL_POS_FOUND )
      {
      ErrStat = SNMP_ERRORSTATUS_NOSUCHNAME;
      goto Exit;
      }

   // Copy data from table
   ErrStat = MIB_wsuses_copyfromtable( Entry, VarBind->name.ids[USES_FIELD_SUBID],
                                     VarBind );

Exit:
   return ErrStat;
} // MIB_wsuses_get



//
// MIB_wsuses_match
//    Match the target OID with a location in the Uses table
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None
//
int MIB_wsuses_match(
       IN AsnObjectIdentifier *Oid,
       OUT UINT *Pos,
       IN BOOL Next
       )

{
AsnObjectIdentifier TempOid;
int                 nResult;

   // Remove prefix including field reference
   TempOid.idLength = Oid->idLength - MIB_OidPrefix.idLength -
                      MIB_UsesPrefix.idLength - 1;
   TempOid.ids = &Oid->ids[MIB_OidPrefix.idLength+MIB_UsesPrefix.idLength+1];

   *Pos = 0;
   while ( *Pos < MIB_WkstaUsesTable.Len )
      {
      nResult = SnmpUtilOidCmp( &TempOid, &MIB_WkstaUsesTable.Table[*Pos].Oid );
      if ( !nResult )
         {
         nResult = MIB_TBL_POS_FOUND;
         if (Next) {
             while ( ( (*Pos) + 1 < MIB_WkstaUsesTable.Len ) &&
                     !SnmpUtilOidCmp( &TempOid, &MIB_WkstaUsesTable.Table[(*Pos)+1].Oid)) {
                 (*Pos)++;
             }
         }

         goto Exit;
         }

      if ( nResult < 0 )
         {
         nResult = MIB_TBL_POS_BEFORE;

         goto Exit;
         }

      (*Pos)++;
      }

   nResult = MIB_TBL_POS_END;

Exit:
   return nResult;
} // MIB_wsuses_match



//
// MIB_wsuses_copyfromtable
//    Copy requested data from table structure into Var Bind.
//
// Notes:
//
// Return Codes:
//    None.
//
// Error Codes:
//    None.
//
UINT MIB_wsuses_copyfromtable(
        IN UINT Entry,
        IN UINT Field,
        OUT RFC1157VarBind *VarBind
        )

{
UINT ErrStat;


   // Get the requested field and save in var bind
   switch( Field )
      {
      case USES_LOCAL_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_WkstaUsesTable.Table[Entry].useLocalName.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_WkstaUsesTable.Table[Entry].useLocalName.stream,
                       MIB_WkstaUsesTable.Table[Entry].useLocalName.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_WkstaUsesTable.Table[Entry].useLocalName.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case USES_REMOTE_FIELD:
         // Alloc space for string
         VarBind->value.asnValue.string.stream = SnmpUtilMemAlloc( sizeof(char)
                       * MIB_WkstaUsesTable.Table[Entry].useRemote.length );
         if ( VarBind->value.asnValue.string.stream == NULL )
            {
            ErrStat = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
            }

         // Copy string into return position
         memcpy( VarBind->value.asnValue.string.stream,
                       MIB_WkstaUsesTable.Table[Entry].useRemote.stream,
                       MIB_WkstaUsesTable.Table[Entry].useRemote.length );

         // Set string length
         VarBind->value.asnValue.string.length =
                          MIB_WkstaUsesTable.Table[Entry].useRemote.length;
         VarBind->value.asnValue.string.dynamic = TRUE;

         // Set type of var bind
         VarBind->value.asnType = ASN_RFC1213_DISPSTRING;
         break;

      case USES_STATUS_FIELD:
         VarBind->value.asnValue.number =
                               MIB_WkstaUsesTable.Table[Entry].useStatus;
         VarBind->value.asnType = ASN_INTEGER;
         break;

      default:
         SNMPDBG(( SNMP_LOG_TRACE, "LMMIB2: Internal Error WorkstationUses Table\n" ));
         ErrStat = SNMP_ERRORSTATUS_GENERR;

         goto Exit;
      }

   ErrStat = SNMP_ERRORSTATUS_NOERROR;

Exit:
   return ErrStat;
} // MIB_wsuses_copyfromtable

//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpeldl.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

        SNMPELDL.CPP


Abstract:

        This module is the main extension agent DLL for the SNMP Event Log
        Extension Agent DLL.

        Standard tracing and logging routines are defined in this module.

        DLL initialization and termination routines are defined here.

        SNMP trap initialization and processing is defined here.

        Spawning of the log processing thread is done in this routine.

Author:

        Randy G. Braze (Braze Computing Services) Created 16 October 1994


Revision History:
        9 Feb 99    FlorinT: Removed warning event logs on startup (when registry parameters are not found)

        16 Dec 98   FlorinT: Added LoadPrimaryModuleParams and 'EALoad.*' files

        1 Dec 98    FlorinT: Remove psupportedView - it is freed by the SNMP master agent

        7 Feb 96    Moved tracing and logging to separate module.
                        Restructured building of varbinds to be outside of trap generation.
                        Calculated trap buffer length correctly.
                        Created varbind queue and removed event log buffer queue.

        28 Feb 96   Added code to support a performance threshold reached indicator.
                        Removed pointer references to varbindlist and enterpriseoid.

        10 Mar 96   Removed OemToChar coding and registry checking.
                        Modifications to read log file names from EventLog registry entries and not
                        from specific entries in the SNMP Extension Agent's registry entries.
                        Included SnmpMgrStrToOid as an internal function, as opposed to using the function
                        provided by MGMTAPI.DLL. SNMPTRAP.EXE will be called if MGMTAPI is called, which
                        will disable other agents from being able to receive any traps. All references
                        to MGMTAPI.DLL and MGMTAPI.H will be removed.
                        Added a ThresholdEnabled flag to the registry to indicate if the threshold values
                        were to be monitored or ignored.

        13 Mar 96   Modified StrToOid routine to append the BaseEnterpriseOID to the specified string
                        if the string passed does not start with a period. Otherwise, the string is
                        converted as normal.
                        Changed TraceFileName parameter in the registry from REG_SZ to REG_EXPAND_SZ.
                        Modified registry reading routine to accept REG_EXPAND_SZ parameters.
                        Added additional tracing.

        07 May 96   Removed SnmpUtilOidFree and use two SNMP_free. One for the OID's ids array and
                        one for the OID itself. Also added psupportedView to free memory at exit.

        26 Jun 96   Modified the StrToOid function such that strings without leading "." have the base
                        OID appended instead of strings with a leading ".".

--*/

extern "C"
{
#include <stdlib.h>
#include <errno.h>          // for ERANGE
#include <windows.h>        // windows definitions
#include <string.h>         // string declarations
#include "limits.h"         // for INT_MAX
#include <snmp.h>           // snmp definitions
#include <snmpexts.h>       // extension agent definitions
#include "snmpelea.h"       // global dll definitions
#include "snmpeldl.h"       // module specific definitions
#include "snmpelmg.h"       // message definitions
}

extern  VOID                FreeVarBind(UINT,RFC1157VarBindList     *);
#include "snmpelep.h"       // c++ variables and definitions
#include "EALoad.h"         // parameters loading functions



// MikeCure 4/3/98 hotfix for SMS Bug1 #20521
//===========================================
BOOL EnablePrivilege(VOID);


VOID
ResetGlobals(
    IN  VOID
    )

/*++

Routine Description:

        This routine is used to reset/init all globals variables.
        
        This is to handle the case that SNMP.exe calls our entry points with 
        the following sequence:
        1. Our DLL is attached to SNMP process
        2. SnmpExtensionInit
        3. SnmpExtensionClose
        4. Our DLL is not detached from SNMP process
        5. SnmpExtensionInit

Arguments:

        None


Return Value:

        None

--*/
{
    WriteTrace(0x0a,"ResetGlobals: Entering extension agent ResetGlobals routine\n");

    lpszEventLogs = (LPTSTR) NULL;          // pointer to event log name array
    phEventLogs = (PHANDLE) NULL;           // Pointer to event log handle array
    phPrimHandles = (PHMODULE) NULL;        // pointer to primary module handle array
    uNumEventLogs = 0;                      // Number of event logs present
    iLogNameSize = 0;                       // size of event log name array
    nMaxTrapSize = 0;                       // maximum trap size
    
    hkRegResult = (HKEY) NULL;              // handle to Parameters registry entry
    hWriteEvent = (HANDLE) NULL;            // handle to write log events
    hStopAll = (HANDLE) NULL;               // handle to global dll shutdown event
    hServThrd = (HANDLE) NULL;              // handle to SNMPELPT thread
    hEventNotify = (HANDLE) NULL;           // handle to notify SNMPELDL that a trap is ready to process
    hRegChanged = (HANDLE) NULL;            // handle to registry key changed event
    
    fGlobalTrim = TRUE;                     // global message trimming flag (trim msg first or insertion strings first)
    fThresholdEnabled = TRUE;               // global threshold checking enabled flag
    fTrimFlag = FALSE;                      // global trimming flag (do or don't do trimming at all)
    fTrapSent = FALSE;                      // global trap sent flag
    fRegNotify = FALSE;                     // registry notification initialization flag
    fRegOk = FALSE;                         // registry notification in effect flag
    fLogInit = FALSE;                       // indicate log file registry information not yet read
    fThreshold = FALSE;                     // global performance threshold flag
    fSendThresholdTrap = FALSE;             // indicator to send threshold reached trap
    fDoLogonEvents = TRUE;                  // do we need to send logon events

    szBaseOID[MAX_PATH] = 0;                // base enterprise OID
    szSupView[MAX_PATH] = 0;                // supported view OID

    dwTimeZero = 0;                         // time zero reference
    dwThresholdCount = THRESHOLD_COUNT;     // threshold count for performance
    dwThresholdTime = THRESHOLD_TIME;       // time in seconds for threshold for performance

    dwTrapCount = 0;                        // number of traps sent
    dwTrapStartTime = 0;                    // time when first trap in time period sent
    dwLastBootTime = 0;                     // time the last boot occurred
    dwTrapQueueSize = 0;
    
    // WinSE Bug# 15128, Windows Bug# 293698  
    // default is INFINITE ==> no polling (wait for system notification)
    g_dwEventLogPollTime = (DWORD)INFINITE; // time in millsecs to poll for event logs
    
    lpVarBindQueue = (PVarBindQueue) NULL;  // pointer to first varbind queue entry
    lpSourceHandleList = (PSourceHandleList) NULL;  // pointer to first source/handle entry

    // tracing globals
    szTraceFileName[MAX_PATH] = 0;          // file name for trace information (from registry)
    szTraceFileName[0] = 0;                 // init to null tracing filename
    fTraceFileName = FALSE;                 // flag indicating registry read for trace file name    
    fMsgModule = FALSE;                     // flag indicating registry read for message module
    hMsgModule = NULL;                      // handle to message module

    hMutex = NULL;                          // handle for mutex object

}

BOOL
StrToOid(   
        IN              PCHAR                    lpszStr,
        IN      OUT     AsnObjectIdentifier     *asnOid
    )

/*++

Routine Description:

        This routine will convert the string passed to an OID.


Arguments:

        lpszStr -       Address of a null terminated string in the form n.n...n.

        asnOid  -       Address of converted OID of the input string.


Return Value:

        TRUE    -       If the string was successfully converted.

        FALSE   -       If the string could not be converted.

--*/

{
    CHAR    tokens[] = TEXT(".");           // delimiters to scan for
    CHAR    *token;                         // token returned
    UINT    nTokens;                        // number of tokens located
    UINT    i;                              // temporary counter
    CHAR    szString[MAX_PATH*2+1];         // temporary string holder
    CHAR    szOrgString[MAX_PATH*2+1];      // temporary string holder
    CHAR    *szStopString;                  // temporary string pointer
    BOOL    fOk;                            // used by WRAP_STRCAT_A macro
    // ensures null terminated strings
    szString[MAX_PATH*2]    = 0;
    szOrgString[MAX_PATH*2] = 0;

    WriteTrace(0x0a,"StrToOid: Entering routine to convert string to OID\n");
    WriteTrace(0x00,"StrToOid: String to convert is %s\n", lpszStr);

    nTokens = 0;                                            // reset counter

    if ( strlen(lpszStr) == 0 )
    {
        WriteTrace(0x14,"StrToOid: No strings found. Exiting with FALSE\n");
        return(FALSE);
    }

    if (lpszStr[0] != '.')
    {
        WriteTrace(0x0a,"StrToOid: BaseOID will not be appended to this OID\n");
        strncpy(szString, lpszStr, MAX_PATH*2); // copy original string
    }
    else
    {
        WriteTrace(0x0a,"StrToOid: BaseOID %s will be appended to this OID\n", szBaseOID);
        strncpy(szString, szBaseOID, MAX_PATH*2);   // copy in base OID
        WRAP_STRCAT_A(szString, TEXT("."), MAX_PATH*2);        // stick in the .
        WRAP_STRCAT_A(szString, lpszStr, MAX_PATH*2);          // add in requested string
    }

    strncpy(szOrgString, szString, MAX_PATH*2);        // save this string

    token = strtok(szString, tokens);       // get first token

    while (token != NULL)
    {
        szStopString = token;                           // set pointer to string
        strtoul(token, &szStopString, 10);      // check for valid values
        if (errno == ERANGE)
        {
            errno = 0;
            WriteTrace(0x14,"StrToOid: strtoul overflow or underflow. Exiting with FALSE\n");
            return(FALSE);
        }
        if ( (token == szStopString) || (*szStopString != NULL) )
        {
            WriteTrace(0x14,"StrToOid: String contains a non-numeric value. Exiting with FALSE\n");
            WriteLog(SNMPELEA_NON_NUMERIC_OID);
            return(FALSE);
        }

        nTokens++;                                              // increment number of tokens found
        token = strtok(NULL, tokens);   // get next token
    }

    if (nTokens == 0)
    {
        WriteTrace(0x14,"StrToOid: No strings found. Exiting with FALSE\n");
        return(FALSE);
    }

    WriteTrace(0x00,"StrToOid: %lu tokens found\n", nTokens);
    WriteTrace(0x0a,"StrToOid: Allocating storage for OID\n");

    asnOid->ids = (UINT *) SNMP_malloc(nTokens * sizeof(UINT));     // allocate integer array

    if (asnOid->ids == NULL)
    {
        WriteTrace(0x14,"StrToOid: Unable to allocate integer array for OID structure. Exiting with FALSE\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_OID_ARRAY);
        return(FALSE);
    }

    WriteTrace(0x00,"StrToOid: OID integer array storage allocated at %08X\n", asnOid->ids);

    asnOid->idLength = nTokens;                     // set size of array
    strncpy(szString, szOrgString, MAX_PATH*2);     // copy original string
    token = strtok(szString, tokens);               // get first token
    i = 0;                                          // set index to 0

    while (token != NULL)
    {
        asnOid->ids[i++] = strtoul(token, &szStopString, 10);   // convert string to number
        token = strtok(NULL, tokens);                           // get next token
    }

    if (nTraceLevel == 0)
    {
        for (i = 0; i < nTokens; i++)
        {
            WriteTrace(0x00,"StrToOid: OID[%lu] is %lu\n",
                        i, asnOid->ids[i]);
        }
    }

    WriteTrace(0x0a,"StrToOid: Exiting routine with TRUE\n");
    return(TRUE);

Error:
    WriteTrace(0x14,"StrToOid: Unable to do strcat. Exiting with FALSE\n");
    return (FALSE);
}


VOID
CloseStopAll(
    IN  VOID
    )

/*++

Routine Description:

        This routine will close the event handle used to terminate the extension agent dll.


Arguments:

        None


Return Value:

        None

--*/

{
    LONG    lastError;                              // for GetLastError()

    if (hStopAll == NULL)
    {
            return;
    }

    WriteTrace(0x0a,"CloseStopAll: Closing handle to service shutdown event %08X\n",
                    hStopAll);
    if ( !CloseHandle(hStopAll) )
    {
        lastError = GetLastError(); // save status
        WriteTrace(0x14,"CloseStopAll: Error closing handle for service shutdown event %08X; code %lu\n",
                        hStopAll, lastError);
        WriteLog(SNMPELEA_ERROR_CLOSING_STOP_AGENT_HANDLE,
                    HandleToUlong(hStopAll), lastError);
    }
    
    // reset handle
    hStopAll = NULL;
}


VOID
CloseEventNotify(
    IN  VOID
    )

/*++

Routine Description:

        This routine will close the event handle used to notify SNMPELDL that a
        trap is waiting to be sent.


Arguments:

        None


Return Value:

        None

--*/

{
    LONG    lastError;                              // for GetLastError()

    if (hEventNotify == NULL)
    {
            return;
    }

    WriteTrace(0x0a,"CloseEventNotify: Closing handle to event notify event %08X\n",
            hEventNotify);
    if ( !CloseHandle(hEventNotify) )       // close log processing routine shutdown event handle
    {
            lastError = GetLastError(); // save error status
            WriteTrace(0x14,"CloseEventNotify: Error closing handle for StopLog event %08X; code %lu\n",
                    hEventNotify, lastError);
            WriteLog(SNMPELEA_ERROR_CLOSING_STOP_LOG_EVENT_HANDLE,
                    HandleToUlong(hEventNotify), lastError);
    }
    
    // reset handle
    hEventNotify = NULL;
}


VOID
CloseRegNotify(
    IN  VOID
    )

/*++

Routine Description:

        This routine will close the event handle used to notify SNMPELDL that a
        registry key value has changed.


Arguments:

        None


Return Value:

        None

--*/

{
    LONG    lastError;                              // for GetLastError()

    if (hRegChanged == NULL)
    {
            return;
    }

    WriteTrace(0x0a,"CloseRegNotify: Closing handle to registry key changed notify event %08X\n",
            hRegChanged);
    if ( !CloseHandle(hRegChanged) )        // close event handle
    {
            lastError = GetLastError(); // save error status
            WriteTrace(0x14,"CloseRegNotify: Error closing handle for registry key changed event %08X; code %lu\n",
                    hRegChanged, lastError);
            WriteLog(SNMPELEA_ERROR_CLOSING_REG_CHANGED_EVENT_HANDLE,
                    HandleToUlong(hRegChanged), lastError);
    }

    // reset handle
    hRegChanged = NULL;
}


VOID
CloseRegParmKey(
    IN  VOID
    )

/*++

Routine Description:

        This routine will close the registry key handle used to read the Parameters information
        from the registry.


Arguments:

        None


Return Value:

        None

--*/

{
    LONG    lastError;

    if (hkRegResult == NULL)
    {
            return;
    }

    WriteTrace(0x0a,"CloseRegParmKey: Closing Parameter key in registry\n");
    if ( (lastError = RegCloseKey(hkRegResult)) != ERROR_SUCCESS )  // close handle
    {
            WriteTrace(0x14,"CloseRegParmKey: Error closing handle for Parameters registry key %08X; code %lu\n",
                    hkRegResult, lastError);
            WriteLog(SNMPELEA_ERROR_CLOSING_REG_PARM_KEY,
                    HandleToUlong(hkRegResult), lastError);
    }

    // reset handle
    hkRegResult = NULL;
}

VOID
CloseLogs(
        IN      VOID
        )

/*++

Routine Description:

        This routine is called to close the currently open event logs. It is
        called when the agent is terminating normally and if an error is
        encountered during agent initialization.


Arguments:

        None


Return Value:

        None


--*/

{
    UINT   uVal;                                        // temporary counter

    WriteTrace(0x0a,"CloseLogs: Closing event logs\n");
    
    for (uVal = 0; uVal < uNumEventLogs; uVal++)
    {
        if (phEventLogs && (*(phEventLogs+uVal) != NULL))
        {
            WriteTrace(0x00,"CloseLogs: Closing event log %s, handle %lu at %08X\n",
                            lpszEventLogs+uVal*(MAX_PATH+1), uVal, *(phEventLogs+uVal));
            CloseEventLog(*(phEventLogs+uVal));
        }
        if (phPrimHandles && (*(phPrimHandles+uVal) != (HMODULE) NULL))
        {
            WriteTrace(0x00,"CloseLogs: Freeing PrimaryModule for event log %s, handle %lu at %08X\n",
                            lpszEventLogs+uVal*(MAX_PATH+1), uVal, *(phPrimHandles+uVal));
            FreeLibrary(*(phPrimHandles+uVal));
        }
    }
    
    WriteTrace(0x0a,"CloseLogs: Freeing memory for event log handles at address %08X\n",
                phEventLogs);
    SNMP_free( (LPVOID) phEventLogs );          // free event log handle array
    phEventLogs = (PHANDLE) NULL; 

    WriteTrace(0x0a,"CloseLogs: Freeing memory for PrimaryModule handles at address %08X\n",
                phPrimHandles);
    SNMP_free( (LPVOID) phPrimHandles );        // free primary module handle array
    phPrimHandles = (PHMODULE) NULL; 
    
    WriteTrace(0x0a,"CloseLogs: Freeing memory for event log names at address %08X\n",
                lpszEventLogs);
    SNMP_free( (LPVOID) lpszEventLogs );        // free log name array
    lpszEventLogs = (LPTSTR) NULL;
}


extern "C" {
BOOL
Position_to_Log_End(
        IN      HANDLE  hLog
        )

/*++

Routine Description:

        Position_to_Log_End is called during DLL initialization. After each
        event log file is successfully opened, it is necessary to position each
        event log file to the current end of file. This way, only the events
        logged after the DLL has been started are reported. This routine will
        position the requested log to the end of file.

        Positioning to the end of the event log file is done by first getting
        the number of the oldest event log record. This value is then added to
        the number of event log records minus one. The resulting value is the
        record number of the last record in the event log file. ReadEventLog is
        called, specifying the seek parameter, to position to that exact record
        number.


Arguments:

        hLog                    -       Handle of the log file to position to end of file.


Return Value:

        TRUE    -       If the log was successfully positioned to end of file.

        FALSE   -       If the log was not positioned to end of file.


--*/

{
    LONG                lastError;                      // last error code
    PEVENTLOGRECORD     lpBuffer;                       // address of data buffer
    PEVENTLOGRECORD     lpOrigBuffer;                   // address of data buffer
    DWORD               nBytesRead;                     // number of bytes read
    DWORD               nMinNumberofBytesNeeded;        // remainder if buffer too small
    DWORD               dwOldestRecord;                 // oldest record number in event log
    DWORD               dwRecords;                      // total number of records in event log
    DWORD               uRecordNumber;                  // current log position

    WriteTrace(0x0a,"Position_to_Log_End: Entering position to end of log routine\n");
    WriteTrace(0x00,"Position_to_Log_End: Handle is %08X\n",hLog);

    if (!hLog)                     // if handle is invalid
    {                              //    then we cannot position correctly
        WriteTrace(0x14,"Position_to_Log_End: Handle for end of log is invalid - %08X\n",
                        hLog);
        WriteTrace(0x14,"Position_to_Log_End: Log position to end failed\n");
        WriteLog(SNMPELEA_LOG_HANDLE_INVALID, HandleToUlong(hLog)); // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);            // log the message

        return FALSE;              // exit function
    }

    WriteTrace(0x0a,"Position_to_Log_End: Allocating log buffer\n");

    lpBuffer = (PEVENTLOGRECORD) SNMP_malloc(LOG_BUF_SIZE);  // allocate memory for buffer

    if (lpBuffer == (PEVENTLOGRECORD) NULL)              // if memory allocation failed
    {                                  //    then can't position log file
        WriteTrace(0x14,"Position_to_Log_End: Position to end of log for handle %08X failed\n",
                        hLog);
        WriteTrace(0x14,"Position_to_Log_End: Buffer memory allocation failed\n");
        WriteLog(SNMPELEA_ERROR_LOG_BUFFER_ALLOCATE, HandleToUlong(hLog));  // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);                    // log the message

        return FALSE;                  //    exit the function
    }

    WriteTrace(0x00,"Position_to_Log_End: Log buffer memory allocated at %08X\n", lpBuffer);
    WriteTrace(0x0a,"Position_to_Log_End: Positioning to last record\n");

    WriteTrace(0x0a,"Position_to_Log_End: Getting oldest event log record\n");
    if ( !GetOldestEventLogRecord(hLog, &dwOldestRecord) )
    {
        lastError = GetLastError();       // get last error code

        WriteTrace(0x0a,"Position_to_Log_End: Freeing log event record buffer %08X\n",
                        lpBuffer);
        SNMP_free(lpBuffer);                   // free up buffer memory

        WriteTrace(0x14,"Position_to_Log_End: GetOldestEventLogRecord for log handle %08X failed with code %lu\n",
            hLog, lastError);
        WriteLog(SNMPELEA_ERROR_LOG_GET_OLDEST_RECORD, HandleToUlong(hLog), lastError); // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);                                // log the message

        return FALSE;
    }

    WriteTrace(0x00,"Position_to_Log_End: Oldest event log record is %lu\n",dwOldestRecord);

    WriteTrace(0x00,"Position_to_Log_End: Getting number of event log records\n");
    if ( !GetNumberOfEventLogRecords(hLog, &dwRecords) )
    {
        lastError = GetLastError();       // get last error code

        WriteTrace(0x0a,"Position_to_Log_End: Freeing log event record buffer\n");
        SNMP_free(lpBuffer);                   // free up buffer memory

        WriteTrace(0x14,"Position_to_Log_End: GetNumberOfEventLogRecords for log handle %08X failed with code %lu\n",
            hLog, lastError);
        WriteLog(SNMPELEA_ERROR_LOG_GET_NUMBER_RECORD, HandleToUlong(hLog), lastError); // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);                                // log the message

        return FALSE;
    }

    WriteTrace(0x00,"Position_to_Log_End: Number of event log records is %lu\n",dwRecords);

    uRecordNumber = dwOldestRecord + dwRecords - 1;         // current EOF

    WriteTrace(0x00,"Position_to_Log_End: Positioning to record #%lu\n",
                    uRecordNumber);

    if ( !ReadEventLog(hLog,                    // log file handle to read
                EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ,    // seek forward to specific record
                uRecordNumber,                                  // record # to position to
                lpBuffer,                                       // buffer to return log record in
                LOG_BUF_SIZE,                                   // size of buffer
                &nBytesRead,                                    // return bytes read this time
                &nMinNumberofBytesNeeded))              // return bytes needed for next full record
    {
        lastError = GetLastError();             // get last error code

        WriteTrace(0x0a,"Position_to_Log_End: Freeing log event record buffer %08X\n",
                        lpBuffer);
        SNMP_free(lpBuffer);                   // free buffer memory

        if (lastError == ERROR_HANDLE_EOF)
        {
            WriteTrace(0x00,"Position_to_Log_End: Handle %08X positioned at EOF\n",hLog);
            WriteTrace(0x0a,"Position_to_Log_End: Returning from position to end of log function\n");

            return TRUE;
        }

        WriteTrace(0x14,"Position_to_Log_End: SEEK to record in event log %08X failed with code %lu\n",
            hLog, lastError);
        WriteLog(SNMPELEA_ERROR_LOG_SEEK, HandleToUlong(hLog), lastError); // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);                   // log the message

        WriteTrace(0x00,"Position_to_Log_End: BytesRead is %lu\n", nBytesRead);
        WriteTrace(0x00,"Position_to_Log_End: MinNumberofBytesNeeded is %lu\n",
                    nMinNumberofBytesNeeded);

        return FALSE;
    }

    WriteTrace(0x0a,"Position_to_Log_End: Reading any residual records\n");
        lpOrigBuffer = lpBuffer;            // save original buffer address
        nBytesRead = 0;                     // reset byte count to nothing first
        lastError = 0;                      // show no current error

    while (ReadEventLog(hLog,
        EVENTLOG_FORWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
        0,
        lpBuffer,
        LOG_BUF_SIZE,
        &nBytesRead,
        &nMinNumberofBytesNeeded))
    {
                while (nBytesRead)
                {
                        WriteTrace(0x00,"Position_to_Log_End: Number of bytes read for residual read is %lu\n",
                                nBytesRead);
                        uRecordNumber = lpBuffer->RecordNumber; // save record number
                        nBytesRead -= lpBuffer->Length;         // reduce by this record count
                        lpBuffer = (PEVENTLOGRECORD) ((LPBYTE) lpBuffer +
                                lpBuffer->Length);                              // point to next record
                }
                lpBuffer = lpOrigBuffer;                // reload original address
    }

    lastError = GetLastError();                     // get last error code

    WriteTrace(0x0a,"Position_to_Log_End: Checking for EOF return\n");


    WriteTrace(0x0a,"Position_to_Log_End: Freeing event log buffer memory %08X\n",
                lpOrigBuffer);
    SNMP_free(lpOrigBuffer);                                    // free buffer memory

    if ( (lastError == ERROR_HANDLE_EOF) ||     // if at the last record now
                 (lastError == NO_ERROR) )              // if no error occured
    {
        WriteTrace(0x00,"Position_to_Log_End: Handle %08X positioned at EOF; record #%lu\n",
                        hLog, uRecordNumber);
        WriteTrace(0x0a,"Position_to_Log_End: Returning from position to end of log function\n");

        return TRUE;                   // return all okay
    }
    else                              // otherwise
    {
        WriteTrace(0x14,"Position_to_Log_End: Read for handle %08X failed with code %lu\n",
                        hLog, lastError);
        WriteTrace(0x14,"Position_to_Log_End: Log not positioned to end\n");
        WriteLog(SNMPELEA_ERROR_READ_LOG_EVENT, HandleToUlong(hLog), lastError); // log error message
        WriteLog(SNMPELEA_ERROR_LOG_END);                         // log the message

        return FALSE;                  // give bad return code
    }
}
}

extern "C" {
BOOL
Read_Registry_Parameters(
        IN VOID
        )

/*++

Routine Description:

        Read_Registry_Parameters is called during SNMP trap initialization. The
        registry information is read to determine the trace file name (TraceFileName),
        the level of tracing desired (TraceLevel), the base enterprise OID (BaseEnterpriseOID),
        the supported view (SupportedView), and the message trimming flag (TrimMessage).
        Also, the names of the event logs to monitor are read from the registry.
        If no event logs are specified, the routine will terminate, as there is no work to perform.

        If, during the course of reading the registry information, a parameter
        is encountered that is not expected, an event log record is written and
        the parameter is ignored.

        The registry layout is as follows:

        HKEY_LOCAL_MACHINE
                SOFTWARE
                        Microsoft
                                SNMP_EVENTS
                                        EventLog
                                                Parameters
                                                        TraceFileName                   (REG_EXPAND_SZ)
                                                        TraceLevel                      (REG_DWORD)
                                                        BaseEnterpriseOID               (REG_SZ)
                                                        SupportedView                   (REG_SZ)
                                                        TrimMessage                     (REG_DWORD)
                                                        MaxTrapSize                     (REG_DWORD)
                                                        TrimFlag                        (REG_DWORD)
                                                        ThresholdEnabled                (REG_DWORD)
                                                        ThresholdFlag                   (REG_DWORD)
                                                        ThresholdCount                  (REG_DWORD)
                                                        ThresholdTime                   (REG_DWORD)
                                                        LastBootTime                    (REG_DWORD)
                                                        EventLogPollTime                (REG_DWORD)
                                                        VarBindPrefixSubId              (REG_DWORD)

Arguments:

        None


Return Value:

        TRUE    -       If registry parameters were processed successfully.

        FALSE   -       If registry parameters could not be read or if there were
                                no event logs specified to monitor.


--*/

{
    LONG    lastError;                      // return code from GetLastError()
    LONG    status;                         // status of API calls
    HKEY    hkResult, hkResult2;            // handle returned from API
    DWORD   iValue;                         // temporary counter
    DWORD   dwType;                         // type of the parameter read
    TCHAR   parmName[MAX_PATH+1];           // name of the parameter read
    DWORD   nameSize;                       // length of parameter name
    TCHAR   parm[MAX_PATH+1];               // value of the parameter
    DWORD   parmSize;                       // length of the parm value
    HANDLE  hLogFile;                       // handle from log open
    UINT    uVal;                           // loop counter
    BOOL    fTrimMsg = FALSE;               // registry info found flags
    BOOL    fBaseOID = FALSE;               // registry info found flags
    BOOL    fSupView = FALSE;               // registry info found flags
    BOOL    fTrapSize = FALSE;              // registry info found flags
    BOOL    fTrimFlg = FALSE;               // registry info found flags
    BOOL    fThresholdFlg = FALSE;          // registry info found flags
    BOOL    fThresholdCountFlg = FALSE;     // registry info found flags
    BOOL    fThresholdTimeFlg = FALSE;      // registry info found flags
    BOOL    fTraceLevelFlg = FALSE;         // registry info found flags
    BOOL    fThresholdEnabledFlg = FALSE;   // registry info found flags
    BOOL    fThresholdOff = FALSE;          // temporary flag
    DWORD   nReadBytes = 0;                 // number of bytes read from profile information
    TCHAR   lpszLog[MAX_PATH+1];            // temporary registry name
    BOOL    fLastBootFlg = FALSE;           // registry info found flag
    PHANDLE phTmpEventLogs = (PHANDLE) NULL;// Pointer to event log handle array
    LPTSTR  lpszTmpEventLogs = (LPTSTR) NULL;  // pointer to event log name array
    PHMODULE phTmpPrimHandles = (PHMODULE) NULL;  // pointer to primary module handle array
    BOOL     fOk;                           // used by WRAP_STRCAT_A macro
    
    WriteTrace(0x0a,"Read_Registry_Parameters: Entering routine\n");

    parmName[MAX_PATH] = 0;
    parm[MAX_PATH]     = 0;
    lpszLog[MAX_PATH]  = 0;

    if (fSendThresholdTrap)
    {
        WriteTrace(0x0a,"Read_Registry_Parameters: Routined entered due to threshold performance parameters reached and modified.\n");

        if ( hRegChanged != NULL )
        {
            if ( (lastError = RegNotifyChangeKeyValue(
                    hkRegResult,                                            // handle of key to watch
                    TRUE,                                                                                                   // watch subkey stuff
                    REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,    // types of changes to notify on
                    hRegChanged,                                            // event to signal when change
                    TRUE)) == ERROR_SUCCESS )                               // asynchronous processing
            {
                WriteTrace(0x0a,"Read_Registry_Parameters: Notification of registry key changes was successful.\n");
                fRegOk = TRUE;                          // show registry notification is in effect
            }
            else
            {
                WriteTrace(0x14,"Read_Registry_Parameters: Notification of registry key changes failed with code of %lu\n",
                        lastError);
                WriteLog(SNMPELEA_REG_NOTIFY_CHANGE_FAILED, lastError);
                WriteTrace(0x14,"Read_Registry_Parameters: Initialization continues, but registry changes will require a restart of SNMP\n");
                CloseRegNotify();
            }
        }

        WriteTrace(0x0a,"Read_Registry_Parameters: Exiting Read_Registry_Parameters routine with TRUE.\n");
        return(TRUE);
    }

    WriteTrace(0x0a,"Read_Registry_Parameters: Opening %s\n", EXTENSION_PARM);

    if (fThreshold && fThresholdEnabled)    // if threshold checking enabled and threshold reached
    {
            fThresholdOff = TRUE;                           // indicate that we're not sending traps right now
    }
    else
    {
            fThresholdOff = FALSE;                          // otherwise, indicate we are sending traps right now
    }

    if (hkRegResult == NULL)
    {
        if ((status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, EXTENSION_PARM, 0,
                KEY_READ | KEY_SET_VALUE, &hkRegResult))
                != ERROR_SUCCESS)                   // open registry information
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Error in RegOpenKeyEx for Parameters = %lu \n",
                        status);
            WriteLog(SNMPELEA_NO_REGISTRY_PARAMETERS, status);   // log error message
            return(FALSE);                                  // failed -- can't continue
        }
    }

    if (!fRegNotify)
    {
        WriteTrace(0x0a,"Read_Registry_Parameters: Creating event for registry change notification\n");
        fRegNotify = TRUE;                              // set flag to show initialization complete

        if ( (hRegChanged = CreateEvent(
                (LPSECURITY_ATTRIBUTES) NULL,
                FALSE,
                FALSE,
                (LPTSTR) NULL)) == NULL)
        {
            lastError = GetLastError(); // save error status
            WriteTrace(0x14,"Read_Registry_Parameters: Error creating registry change notification event; code %lu\n",
                    lastError);
            WriteLog(SNMPELEA_ERROR_CREATING_REG_CHANGE_EVENT, lastError);

            WriteTrace(0x14,"Read_Registry_Parameters: No registry notification will be performed. Continuing with initialization.\n");
        }
        else
        {
            WriteTrace(0x00,"Read_Registry_Parameters: Registry key changed event handle is %08X\n",
                    hRegChanged);
        }
    }

    if ( hRegChanged != NULL )
    {
        if ( (lastError = RegNotifyChangeKeyValue(
                hkRegResult,                                                                                    // handle of key to watch
                TRUE,                                                                                                   // watch subkey stuff
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,    // types of changes to notify on
                hRegChanged,                                                                                    // event to signal when change
                TRUE)) == ERROR_SUCCESS )                                                               // asynchronous processing
        {
            WriteTrace(0x0a,"Read_Registry_Parameters: Notification of registry key changes was successful.\n");
            fRegOk = TRUE;                          // show registry notification is in effect
        }
        else
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Notification of registry key changes failed with code of %lu\n",
                    lastError);
            WriteLog(SNMPELEA_REG_NOTIFY_CHANGE_FAILED, lastError);
            WriteTrace(0x14,"Read_Registry_Parameters: Initialization continues, but registry changes will require a restart of SNMP\n");
            CloseRegNotify();
        }
    }

    iValue = 0;                              // read first parameter
    nameSize = MAX_PATH;                     // can't be greater than this, size in TCHARs
    parmSize = sizeof(parm) - sizeof(TCHAR); // can't be greater than this, size in bytes
    g_dwEventLogPollTime = (DWORD) INFINITE; // default value is not to poll Event Logs
    g_dwVarBindPrefixSubId = g_dwDefaultVarBindPrefixSubId; // default prefix sub-identifier for VarBinds

    while ((status = RegEnumValue(hkRegResult, iValue, parmName, &nameSize, 0,
                &dwType, (LPBYTE)&parm, &parmSize)) != ERROR_NO_MORE_ITEMS)
    {                                     // read until no more values
        if (status != ERROR_SUCCESS)          // if error during read
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Error reading registry value is %lu for index %lu (Parameters)\n",
                                status, iValue);            // show error information
            WriteLog(SNMPELEA_ERROR_REGISTRY_PARAMETER_ENUMERATE,
                                (DWORD) status, iValue);   // log error message

            fRegOk = FALSE;                                         // don't want to do notify now
            CloseRegNotify();                                       // close event handle
            CloseRegParmKey();                                      // close registry key
            return(FALSE);                                          // indicate stop
        }

        WriteTrace(0x00,"Read_Registry_Parameters: Parameter read is %s, length is %lu\n",
                        parmName, strlen(parmName));

        switch (dwType)
        {
            case REG_SZ : // if we have a string
            {
                WriteTrace(0x00,"Read_Registry_Parameters: Parameter type is REG_SZ\n");

                if ( _stricmp(parmName,EXTENSION_BASE_OID) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: BaseEnterpriseOID parameter matched\n");
                    strncpy(szBaseOID,parm,MAX_PATH);         // save base OID
                    fBaseOID = TRUE;                        // indicate parameter read
                }
                else if ( _stricmp(parmName,EXTENSION_TRACE_FILE) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: TraceFileName parameter matched\n");
                    strncpy(szTraceFileName,parm,MAX_PATH);   // save filename
                    fTraceFileName = TRUE;                  // indicate parameter read
                }
                else if ( _stricmp(parmName,EXTENSION_SUPPORTED_VIEW) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: SupportedView parameter matched\n");
                    strncpy(szSupView,parm,MAX_PATH);         // save supported view OID
                    fSupView = TRUE;                        // indicate parameter read
                }
                else                          // otherwise, bad value read
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value name: %s\n",parmName );
                    WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value contents %s\n",parm );
                }
            }
            break;

            case REG_DWORD :// if double word parameter
            {
                WriteTrace(0x00,"Read_Registry_Parameters: Parameter type is REG_DWORD\n");

                if ( _stricmp(parmName,EXTENSION_TRACE_LEVEL) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: TraceLevel parameter matched\n");
                    nTraceLevel = *((DWORD *)parm); // copy registry trace level
                    fTraceLevelFlg = TRUE;                  //indicate parameter read
                    break;
                }
                else if ( _stricmp(parmName,EXTENSION_TRIM) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global TrimMessage parameter matched\n");
                    fGlobalTrim = (*((DWORD *)parm) == 1);          // set global message trim flag
                    fTrimMsg = TRUE;         // show parameter found
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_MAX_TRAP_SIZE) == 0 )
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Maximum Trap Size parameter matched\n");
                    nMaxTrapSize = *((DWORD *)parm);                // get trap size
                    fTrapSize = TRUE;                               // show parameter found
                    break;
                }
                else if ( _stricmp(parmName,EXTENSION_TRIM_FLAG) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global trap trimming flag TrimFlag parameter matched\n");
                    fTrimFlag = (*((DWORD *)parm) == 1);    // set global trim flag
                    fTrimFlg = TRUE;                // show parameter found
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_THRESHOLD_ENABLED) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global threshold checking flag ThresholdEnabled parameter matched\n");
                    fThresholdEnabled = (*((DWORD *)parm) == 1);    // set global threshold enabled flag
                    fThresholdEnabledFlg = TRUE;
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_THRESHOLD_FLAG) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global preformance threshold flag Threshold parameter matched\n");
                    fThreshold = (*((DWORD *)parm) == 1);   // set global performance threshold flag
                    fThresholdFlg = TRUE;
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_THRESHOLD_COUNT) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global preformance threshold count ThresholdCount parameter matched\n");
                    dwThresholdCount = *((DWORD *)parm);    // set global performance threshold count
                    fThresholdCountFlg = TRUE;
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_THRESHOLD_TIME) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global preformance threshold time ThresholdTime parameter matched\n");
                    dwThresholdTime = *((DWORD *)parm);     // set global performance threshold time
                    fThresholdTimeFlg = TRUE;
                    break;                                  // exit case
                }
                else if (fDoLogonEvents && (_stricmp(parmName,EXTENSION_LASTBOOT_TIME) == 0))
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Initialization last boot time parameter matched\n");
                    dwLastBootTime = *((DWORD *)parm);  // set global last boot time
                    fLastBootFlg = TRUE;
                    break;                                  // exit case
                }
                else if ( _stricmp(parmName,EXTENSION_EVENT_LOG_POLL_TIME) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global Event Log poll time EventLogPollTime parameter matched\n");
                    DWORD dwEventLogPollTime = *((DWORD *)parm);     // registry poll time in seconds

                    WriteTrace(0x00,"Read_Registry_Parameters: EventLogPollTime parameter found in registry of %lu.\n",
                                    dwEventLogPollTime);
                    
                    // check for underflow and overflow values
                    if ( (dwEventLogPollTime != 0) && (dwEventLogPollTime <= ((DWORD)INFINITE/1000)) )
                    {
                        g_dwEventLogPollTime = dwEventLogPollTime * 1000; // poll time in milliseconds
                    }
                    else
                    {
                        WriteTrace(0x00,"Read_Registry_Parameters: reset EventLogPollTime parameter to %lu.\n",
                                    g_dwEventLogPollTime);
                    }
                    break;       
                }
                else if ( _stricmp(parmName,EXTENSION_VARBIND_PREFIX_SUB_ID) == 0)
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Global VarBindPrefixSubId parameter matched\n");
                    DWORD dwVarBindPrefixSubId = *((DWORD *)parm);

                    WriteTrace(0x00,"Read_Registry_Parameters: VarBindPrefixSubId parameter found in registry of %lu.\n",
                                    dwVarBindPrefixSubId);
                    
                    // 2147483647 (INT_MAX) is the largest sub-identifier for  
                    // 32-bit signed representation.
                    // 0 is an invalid sub-identifier, but we'll consider it as
                    // "no VarBind prefix sub-identifier is appended to the 
                    // BaseEnterpriseOID to form VarBind OID in a trap"
                    if ( dwVarBindPrefixSubId <= (DWORD)INT_MAX )
                    {
                        g_dwVarBindPrefixSubId = dwVarBindPrefixSubId;
                    }
                    else
                    {
                        WriteTrace(0x00,"Read_Registry_Parameters: reset VarBindPrefixSubId parameter to %lu.\n",
                                    g_dwVarBindPrefixSubId);
                    }
                    break;       
                }
                else                                                    // otherwise, bad parameter read
                {
                    WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value name: %s\n",parmName );
                    WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value contents: %lu\n",parm );
                }
            }
            break;

            default :   // if not above, bad value read
            {
                WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value name: %s\n",parmName );
                WriteTrace(0x00,"Read_Registry_Parameters: Unknown Registry value contents not displayed\n" );
            }
        } // end switch

        nameSize = MAX_PATH;                  // reset maximum length, size in TCHARs
        parmSize = sizeof(parm) - sizeof(TCHAR); // reset maximum length, size in bytes
        iValue++;                             // request next parameter value

    } // end while

    if (!fRegOk)
    {
        CloseRegParmKey();                                      // close registry key
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking BaseEnterpriseOID read from registry\n");
    
    if ( !fBaseOID )
    {
        WriteTrace(0x14,"Read_Registry_Parameters: BaseEnterpriseOID parameter not found in registry\n");
        WriteLog(SNMPELEA_NO_REGISTRY_BASEOID_PARAMETER);
        return(FALSE);                                          // exit - can't continue
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking SupportedView read from registry\n");
    
    if ( !fSupView )
    {
        WriteTrace(0x14,"Read_Registry_Parameters: SupportedView parameter not found in registry\n");
        WriteLog(SNMPELEA_NO_REGISTRY_SUPVIEW_PARAMETER);
        return(FALSE);                                          // exit - can't continue
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking TraceFileName read from registry\n");
    
    if ( !fTraceFileName )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TraceFileName parameter not found in registry, defaulting to %s.\n",
                        szTraceFileName);
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TraceFileName parameter found in registry of %s.\n", szTraceFileName);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking TraceLevel read from registry\n");
    
    if ( !fTraceLevelFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TraceLevel parameter not found in registry, defaulting to %lu.\n",
                        nTraceLevel);
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TraceLevel parameter found in registry of %lu.\n", nTraceLevel);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking MaxTrapSize read from registry\n");
    
    if ( !fTrapSize )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: MaxTrapSize parameter not found in registry, defaulting to %lu.\n",
                        MAX_TRAP_SIZE);
        nMaxTrapSize = MAX_TRAP_SIZE;
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: MaxTrapSize parameter found in registry of %lu.\n", nMaxTrapSize);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking TrimFlag read from registry\n");

    if ( !fTrimFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TrimFlag parameter not found in registry, defaulting to %lu.\n",
                        fTrimFlag);
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TrimFlag parameter found in registry of %lu.\n", fTrimFlag);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking TrimFlag read from registry\n");

    if ( !fTrimMsg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TrimMessage parameter not found in registry, defaulting to %lu.\n",
                        fGlobalTrim);
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: TrimMessage parameter found in registry of %lu.\n", fGlobalTrim);
    }


    WriteTrace(0x00,"Read_Registry_Parameters: Checking ThresholdEnabled parameter read from registry\n");

    if ( !fThresholdEnabledFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdEnabled parameter not found in registry, defaulting to 1.\n");
                fThresholdEnabled = TRUE;
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdEnabled parameter found in registry of %lu.\n", fThresholdEnabled);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking Threshold parameter read from registry\n");
    
    if ( !fThresholdFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: Threshold parameter not found in registry, defaulting to 0.\n");
        fThreshold = FALSE;
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: Threshold parameter found in registry of %lu.\n", fThreshold);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking ThresholdCount parameter read from registry\n");
    
    if ( !fThresholdCountFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdCount parameter not found in registry, defaulting to %lu.\n",
                        THRESHOLD_COUNT);
        dwThresholdCount = THRESHOLD_COUNT;
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdCount parameter found in registry of %lu.\n",
                dwThresholdCount);

        if (dwThresholdCount < 2)
        {
            WriteTrace(0x00,"Read_Registry_Parameters: ThresholdCount is an invalid value -- a minimum of 2 is used.\n");
            dwThresholdCount = 2;
            WriteLog(SNMPELEA_REGISTRY_LOW_THRESHOLDCOUNT_PARAMETER, dwThresholdCount);
        }
    }

    WriteTrace(0x00,"Read_Registry_Parameters: Checking ThresholdTime parameter read from registry\n");
    
    if ( !fThresholdTimeFlg )
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdTime parameter not found in registry, defaulting to %lu.\n",
                        THRESHOLD_TIME);
        dwThresholdTime = THRESHOLD_TIME;
    }
    else
    {
        WriteTrace(0x00,"Read_Registry_Parameters: ThresholdTime parameter found in registry of %lu.\n",
                dwThresholdTime);
        if (dwThresholdTime < 1)
        {
            WriteTrace(0x00,"Read_Registry_Parameters: ThresholdTime is an invalid value -- a minimum of 1 is used.\n");
            dwThresholdTime = 1;
            WriteLog(SNMPELEA_REGISTRY_LOW_THRESHOLDTIME_PARAMETER, dwThresholdTime);
        }
    }

    if ( (fThresholdEnabled && !fThreshold && fThresholdOff) ||
            (!fThresholdEnabled && fThresholdOff) )
    {
        WriteTrace(0x0a,"Read_Registry_Parameters: Threshold values have been reset. Trap processing resumed.\n");
        WriteLog(SNMPELEA_THRESHOLD_RESUMED);

        if (fLogInit)
        {
            for (DWORD inum = 0; inum < uNumEventLogs; inum++)
            {
                Position_to_Log_End(phEventLogs[inum]);
            }
        }
    }

    if ( fThresholdEnabled && fThreshold && !fThresholdOff )
    {
        WriteTrace(0x0a,"Read_Registry_Parameters: Threshold values have been set. Trap processing will not be done.\n");
        WriteLog(SNMPELEA_THRESHOLD_SET);
    }

    WriteTrace(0x00,"Read_Registry_Parameters: BaseEnterpriseOID is %s\n", szBaseOID);
    WriteTrace(0x00,"Read_Registry_Parameters: SupportedView is %s\n", szSupView);
    WriteTrace(0x00,"Read_Registry_Parameters: Global TrimFlag value is %lu (trim yes/no)\n", fTrimFlag);
    WriteTrace(0x00,"Read_Registry_Parameters: Global TrimMessage value is %lu (trim msg/ins str first)\n", fGlobalTrim);

    if (fLogInit)
    {
        WriteTrace(0x00,"Read_Registry_Parameters: Reread of registry parameters is complete\n");
        WriteTrace(0x0a,"Read_Registry_Parameters: Exiting Read_Registry_Parameters with TRUE\n");
        return(TRUE);
    }

    fLogInit = TRUE;                                // indicate not to read log information again

    WriteTrace(0x0a,"Read_Registry_Parameters: Opening %s\n", EVENTLOG_BASE);

    if ((status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, EVENTLOG_BASE, 0,
         (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS), &hkResult))
         != ERROR_SUCCESS)                   // open for log names
    {
        WriteTrace(0x14,"Read_Registry_Parameters: Error in RegOpenKeyEx for EventLog = %lu\n",
                        status);
        WriteLog(SNMPELEA_NO_REGISTRY_LOG_NAME, status); // log error message
        return(FALSE);                        // if error, service stop
    }

    iValue = 0;             // read first parameter
    parmSize = MAX_PATH+1;  // maximum parameter size in TCHARs for RegEnumKey

    while ((status = RegEnumKey(hkResult, iValue, (char *) &parm, parmSize)) != ERROR_NO_MORE_ITEMS)
    {                                     // read until no more entries
        if (status != ERROR_SUCCESS)          // if error during read
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Error reading registry value is %lu for index %lu (EventLogFiles)\n",
                                status, iValue);            // show error information
            WriteLog(SNMPELEA_ERROR_REGISTRY_LOG_NAME_ENUMERATE, status, iValue);  // log the error message
            RegCloseKey(hkResult);             // close registry
            return(FALSE);                     // indicate service stop
        }

        // MikeCure 4/3/98 hotfix for SMS Bug1 #20521
        //===========================================
        EnablePrivilege();

        hLogFile = OpenEventLog( (LPTSTR) NULL, parm);

        if (hLogFile == NULL)
        {                         // did log file open?
            lastError = GetLastError(); // save error code
            WriteTrace(0x14,"Read_Registry_Parameters: Error in EventLogOpen = %lu\n",
                        lastError);
            WriteTrace(0x14,"Read_Registry_Parameters: Log file name: %s\n",parm);

            WriteLog(SNMPELEA_ERROR_OPEN_EVENT_LOG, parm, lastError);  // log the error message
            continue;                // failed -- forget this one
        }

        if ( !Position_to_Log_End(hLogFile) )
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Unable to position to end of log. DLL terminated.\n");
            WriteLog(SNMPELEA_ERROR_LOG_END);
            WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);
            RegCloseKey(hkResult);      // close registry
            CloseEventLog(hLogFile);    // close handle to event log
            return(FALSE);              // exit with error
        }

        phTmpEventLogs = (PHANDLE) SNMP_realloc( (LPVOID) phEventLogs,
                                    (uNumEventLogs+1) * sizeof(HANDLE));
                                                                 // reallocate array space
        if (phTmpEventLogs == (PHANDLE) NULL)
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Unable to reallocate log event array\n");
            WriteLog(SNMPELEA_REALLOC_LOG_EVENT_ARRAY);
            RegCloseKey(hkResult);      // close registry
            CloseEventLog(hLogFile);    // close handle to event log
            return(FALSE);              // exit with error
        }

        phEventLogs = phTmpEventLogs;   // transfer value

        WriteTrace(0x00,"Read_Registry_Parameters: Event log array reallocated at %08X\n",
                phEventLogs);

        *(phEventLogs+uNumEventLogs) = hLogFile; // save handle
                               

        lpszTmpEventLogs = (LPTSTR) SNMP_realloc( (LPVOID) lpszEventLogs,
                                                iLogNameSize + MAX_PATH + 1 );

        if (lpszTmpEventLogs == (LPTSTR) NULL)
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Unable to reallocate log name array\n");
            WriteLog(SNMPELEA_REALLOC_LOG_NAME_ARRAY);
            RegCloseKey(hkResult);      // close registry
            uNumEventLogs++;            // account for saved handle
            return(FALSE);              // exit with error
        }

        lpszEventLogs = lpszTmpEventLogs;   // transfer value

        WriteTrace(0x00,"Read_Registry_Parameters: Event log name array reallocated at %p\n",
                lpszEventLogs);

        iLogNameSize += MAX_PATH + 1;
        lpszEventLogs[iLogNameSize-1] = 0; // null terminated the last TCHAR
        strncpy(lpszEventLogs+uNumEventLogs*(MAX_PATH+1), parm, MAX_PATH);

        phTmpPrimHandles = (PHMODULE) SNMP_realloc( (LPVOID) phPrimHandles,
                                        (uNumEventLogs+1) * sizeof(HANDLE));
                                                                 // reallocate array space
        if (phTmpPrimHandles == (PHMODULE) NULL)
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Unable to reallocate PrimaryModule handle array\n");
            WriteLog(SNMPELEA_REALLOC_PRIM_HANDLE_ARRAY);
            RegCloseKey(hkResult);      // close registry
            uNumEventLogs++;            // account for saved handle
            return(FALSE);              // exit with error
        }

        phPrimHandles = phTmpPrimHandles;   // transfer value

        WriteTrace(0x00,"Read_Registry_Parameters: PrimaryModule handle array reallocated at %08X\n",
                phPrimHandles);


        strncpy(lpszLog, EVENTLOG_BASE, MAX_PATH);  // copy base registry name
        WRAP_STRCAT_A(lpszLog, parm, MAX_PATH);     // add on the log file name read

        WriteTrace(0x0a,"Read_Registry_Parameters: Opening registry for PrimaryModule for %s\n", lpszLog);
        // e.g. open HKLM\SYSTEM\CCS\Services\EventLog\Applicaiton subkey
        if ( (status = RegOpenKeyEx(            // open the registry to read the name
                HKEY_LOCAL_MACHINE,             // of the message module DLL
                lpszLog,                        // registry key to open
                0,
                KEY_READ,
                &hkResult2) ) != ERROR_SUCCESS)
        {
            WriteTrace(0x14,"Read_Registry_Parameters: Unable to open EventLog service registry key %s; RegOpenKeyEx returned %lu\n",
                        lpszLog, status);                       // write trace event record
            WriteLog(SNMPELEA_CANT_OPEN_REGISTRY_PARM_DLL, lpszLog, status);
            WriteTrace(0x0a,"Read_Registry_Parameters: Exiting Read_Registry_Parameters with FALSE\n");
            RegCloseKey(hkResult);              // close registry
            uNumEventLogs++;                    // account for saved handle
            return(FALSE);                      // return
        }

        parmSize = sizeof(parm) - sizeof(TCHAR);// maximum parameter size in bytes for RegQueryValueEx
        if ( (status = RegQueryValueEx(         // look up module name
                hkResult2,                      // handle to registry key
                EXTENSION_PRIM_MODULE,          // key to look up
                0,                              // ignored
                &dwType,                        // address to return type value
                (LPBYTE) parm,                  // where to return message module name
                &parmSize) ) != ERROR_SUCCESS)  // size of message module name field
        {
            WriteTrace(0x14,"Read_Registry_Parameters: No PrimaryModule registry key for %s; RegQueryValueEx returned %lu\n",
                    lpszEventLogs+uNumEventLogs*(MAX_PATH+1), status);                      // write trace event record
            *(phPrimHandles+uNumEventLogs) = (HMODULE) NULL;
        }
        else
        {
            DWORD retCode;
            tPrimaryModuleParms PMParams;

            PMParams.dwParams = PMP_PARAMMSGFILE;
            retCode = LoadPrimaryModuleParams(hkResult2, parm, PMParams);
            if (retCode != ERROR_SUCCESS)
            {
                WriteTrace(0x14, "Read_Registry_Parameters: LoadPrimaryModuleParams failed with errCode = %lu\n", retCode);
                *(phPrimHandles+uNumEventLogs) = NULL;
            }
            else
                *(phPrimHandles+uNumEventLogs) = PMParams.hModule;
        }

        RegCloseKey(hkResult2);                         // close registry key

        WriteTrace(0x00,"Read_Registry_Parameters: Log file name is %s\n",
                lpszEventLogs+uNumEventLogs*(MAX_PATH+1));
        WriteTrace(0x00,"Read_Registry_Parameters: Log handle #%lu is %08X\n",
                uNumEventLogs,hLogFile);
        WriteTrace(0x00,"Read_Registry_Parameters: PrimaryModule handle #%lu is %08X\n",
                uNumEventLogs,*(phPrimHandles+uNumEventLogs));

        uNumEventLogs++;  
        parmSize = MAX_PATH+1;                // reset to maximum in TCHARs for RegEnumKey
        iValue++;                             // read next parameter

    } // end while

    RegCloseKey(hkResult);                   // close registry info

    WriteTrace(0x00,"Read_Registry_Parameters: Number of handles acquired is %lu\n",
                uNumEventLogs);
    for (uVal = 0; uVal < uNumEventLogs; uVal++)
    {
        WriteTrace(0x00,"Read_Registry_Parameters: Handle # %lu\t%08X\t%s\n", uVal,
                *(phEventLogs+uVal), lpszEventLogs+uVal*(MAX_PATH+1));
    }

    if (uNumEventLogs)                       // if we have logs opened
    {
        return(TRUE);                        // then we can say all okay
    }
    else
    {
        WriteTrace(0x14,"Read_Registry_Parameters: Registry contains no log file entries to process\n");
        //WriteLog(SNMPELEA_NO_REGISTRY_EVENT_LOGS);     // log error message
        return(FALSE);                      // if not, then not okay
    }

Error:

    WriteTrace(0x14,"Read_Registry_Parameters: Unable to do strcat to %s.\n",
               lpszLog);                       // write trace event record
    WriteTrace(0x0a,"Read_Registry_Parameters: Exiting Read_Registry_Parameters with FALSE\n");
    RegCloseKey(hkResult);              // close registry
    uNumEventLogs++;                    // account for saved handle
    return(FALSE);                      
}                                       // request stop
}

//nadir
VOID
CloseSourceHandles(VOID)
{
   PSourceHandleList    lpSource;
   UINT lastError;

   lpSource = lpSourceHandleList;

   while (lpSource != (PSourceHandleList)NULL)
   {
      if ( !FreeLibrary(lpSource->handle) )                     // free msg dll
      {
         lastError = GetLastError();                            // get error code
         WriteTrace(0x14,"CloseSourceHandles: Error freeing message dll is %lu.\n", lastError);
         WriteLog(SNMPELEA_ERROR_FREEING_MSG_DLL, lastError);
      }

      lpSourceHandleList = lpSource->Next;
      SNMP_free(lpSource);
      lpSource = lpSourceHandleList;
   }
}



//nadir




extern "C" {
BOOL
APIENTRY
DllMain(
        IN      HINSTANCE   hDll,
        IN      DWORD       dwReason,
        IN      LPVOID      lpReserved
        )

/*++

Routine Description:

        SNMPEventLogDllMain is the dll initialization and termination routine.

        Once this termination request is received, the appropriate events will be
        signaled, notifying the subordinate threads that they should terminate
        to accomodate service termination.

Arguments:

        hDll            -       Handle to the DLL. Unreferenced.

        dwReason        -       Reason this routine was entered (process/thread attach/detach).

        lpReserved      -       Reserved. Unreferenced.

Return Value:

        TRUE    -       If initialization or termination was successful.

        FALSE   -       If initialization or termination was unsuccessful.

--*/

{
    DWORD       lastError;                              // to save GetLastError() return code

    UNREFERENCED_PARAMETER(hDll);
    UNREFERENCED_PARAMETER(lpReserved);

    WriteTrace(0x0a,"SNMPEventLogDllMain: Entering SNMPEventLogDllMain routine.....\n");


    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            WriteTrace(0x0a,"SNMPEventLogDllMain: Reason code indicates process attach\n");
            DisableThreadLibraryCalls( hDll );

            break;

        case DLL_PROCESS_DETACH:
                WriteTrace(0x0a,"SNMPEventLogDllMain: Reason code indicates process detach\n");
                break;

        case DLL_THREAD_ATTACH:
                WriteTrace(0x0a,"SNMPEventLogDllMain: Reason code indicates thread attach\n");
                break;

        case DLL_THREAD_DETACH:
                WriteTrace(0x0a,"SNMPEventLogDllMain: Reason code indicates thread detach\n");
                break;

        default:
                WriteTrace(0x0a,"SNMPEventLogDllMain: Unknown reason code indicated in SNMPEventLogDllMain\n");
                break;

    } // end switch()

    WriteTrace(0x0a,"SNMPEventLogDllMain: Exiting SNMPEventLogDllMain routine with TRUE\n");
    return(TRUE);
}
}


extern "C" {
BOOL
APIENTRY
SnmpExtensionInit(
        IN      DWORD                           dwTimeZeroReference,
        OUT     HANDLE                          *hPollForTrapEvent,
        OUT     AsnObjectIdentifier     *supportedView
        )

/*++

Routine Description:

        SnmpExtensionInit is the extension dll initialization routine.

        This routine will create the event used to notify the manager agent that an event
        has occurred and that a trap should be generated. The TimeZeroReference will be
        saved and will be used by the trap generation routine to insert the time reference
        into the generated trap.

        The registry will be queried to determine which event logs will be used for tracking.
        These event log names are validated to insure that they are real log names. Event logs
        are opened and their handles are saved for event log processing.

        An event is created to notify the log processing thread of DLL termination. Then the
        log processing thread is spawned to handle all further event processing.

        The registry is then read to get the value for the supported view for this extension
        agent DLL. The registry layout for this routine is as follows:

        Registry
                Machine
                        SOFTWARE
                                Microsoft
                                        SNMP_EVENTS
                                                EventLog
                                                        Parameters
                                                                TraceFileName       (REG_SZ)
                                                                TraceLevel          (REG_DWORD)
                                                                BaseEnterpriseOID   (REG_SZ)
                                                                SupportedView       (REG_SZ)
                                                                TrimMessage         (REG_DWORD)
                                                                MaxTrapSize         (REG_DWORD)
                                                                TrimFlag            (REG_DWORD)
                                                                ThresholdEnabled    (REG_DWORD)
                                                                ThresholdFlag       (REG_DWORD)
                                                                ThresholdCount      (REG_DWORD)
                                                                ThresholdTime       (REG_DWORD)

Arguments:

        dwTimeZeroReference     -       Specifies a time-zero reference for the extension agent.

        hPollForTrapEvent       -       Pointer to an event handle for an event that will be asserted
                                                        when the SnmpExtensionTrap entry point should be polled by the
                                                        manager agent.

        supportedView           -       Points to an AsnObjectIdentifier specifying the MIB sub-tree
                                                        supported by this extension agent. Read from the registry.

Return Value:

        TRUE    -       If initialization or termination was successful.

        FALSE   -       If initialization or termination was unsuccessful.

--*/

{
    LONG    lastError;                      // for GetLastError()
    DWORD   dwThreadID;                     // for CreateThread()

    WriteTrace(0x0a,"SnmpExtensionInit: Entering extension agent SnmpExtensionInit routine\n");
    
    WriteTrace(0x14,"SnmpExtensionInit: SNMP Event Log Extension Agent DLL is starting\n");
    WriteLog(SNMPELEA_STARTED);

    ResetGlobals();

    if ( (hWriteEvent = RegisterEventSource(
                                            (LPTSTR) NULL,
                                            EVNTAGNT_NAME) )
                                                            == NULL)
    {
        WriteTrace(0x20,"SnmpExtensionInit: Unable to log application events; code is %lu\n",
                        GetLastError() );
        WriteTrace(0x20,"SnmpExtensionInit: SNMP Event Log Extension Agent DLL initialization abnormal termination\n");
        WriteTrace(0x0a,"SnmpExtensionInit: Exiting SnmpExtensionInit routine with FALSE\n");
        return(FALSE);                  // error initializing
    }

    WriteTrace(0x0a,"SnmpExtensionInit: Creating event for extension DLL shutdown\n");    
    if ( (hStopAll= CreateEvent(
            (LPSECURITY_ATTRIBUTES) NULL,
            TRUE, // changed to manual reset event
            FALSE,
            (LPTSTR) NULL)) == NULL)
    {
        lastError = GetLastError(); // save error status
        WriteTrace(0x14,"SnmpExtensionInit: Error creating stop extension DLL event; code %lu\n",
                        lastError);
        WriteLog(SNMPELEA_ERROR_CREATING_STOP_AGENT_EVENT, lastError);
            
        WriteTrace(0x14,"SnmpExtensionInit: SNMPELEA DLL abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);      // log error message
        WriteTrace(0x0a,"SnmpExtensionInit: Exiting SnmpExtensionInit routine with FALSE\n");

        goto Error;
    }    
    WriteTrace(0x00,"SnmpExtensionInit: Extension DLL shutdown event handle is %08X\n",
                    hStopAll);
        
    if ( !Read_Registry_Parameters() )
    {
        WriteTrace(0x14,"SnmpExtensionInit: Error during registry initialization processing\n");
        WriteLog(SNMPELEA_REGISTRY_INIT_ERROR);

        WriteTrace(0x14,"SnmpExtensionInit: SNMP Event Log Extension Agent DLL abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);

        WriteTrace(0x0a,"SnmpExtensionInit: Exiting extension agent SnmpExtensionInit routine with FALSE\n");
        goto Error;                                  // exit init routine
    }


    WriteTrace(0x0a,"SnmpExtensionInit: Creating event for manager agent trap event notification\n");

    if ( (hEventNotify = CreateEvent(
        (LPSECURITY_ATTRIBUTES) NULL,
        FALSE,
        FALSE,
        (LPTSTR) NULL)) == NULL)
    {
        lastError = GetLastError(); // save error status
        WriteTrace(0x14,"SnmpExtensionInit: Error creating EventNotify event; code %lu\n",
            lastError);
        WriteLog(SNMPELEA_ERROR_CREATING_EVENT_NOTIFY_EVENT, lastError);

        WriteTrace(0x14,"SnmpExtensionInit: SNMP Event Log Extension Agent DLL abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);      // log error message
        WriteTrace(0x0a,"SnmpExtensionInit: Exiting extension agent SnmpExtensionInit routine with FALSE\n");
        goto Error;
    }

    WriteTrace(0x00,"SnmpExtensionInit: Manager agent trap event notification handle is %08X\n",
                hEventNotify);

    WriteTrace(0x0a,"SnmpExtensionInit: Creating thread for event log processing routine\n");

    if ( (hServThrd = CreateThread(
        (LPSECURITY_ATTRIBUTES) NULL,           // security attributes
        0,                                      // initial thread stack size
        (LPTHREAD_START_ROUTINE) SnmpEvLogProc, // starting address of thread
        0,                                      // no arguments
        0,                                      // creation flags
        &dwThreadID) ) == NULL )                // returned thread id
    {
        lastError = GetLastError();                     // save error status
        WriteTrace(0x14,"SnmpExtensionInit: Error creating event log processing thread; code %lu\n",
            lastError);
        WriteLog(SNMPELEA_ERROR_CREATING_LOG_THREAD, lastError);    // log error message

        WriteTrace(0x14,"SnmpExtensionInit: SNMP Event Log Extension Agent DLL abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);      // log error message
        WriteTrace(0x0a,"SnmpExtensionInit: Exiting extension agent SnmpExtensionInit routine with FALSE\n");
        goto Error;
    }

    WriteTrace(0x00,"SnmpExtensionInit: Handle to event log processing routine thread is %08X\n",
                hServThrd);

    if (!StrToOid(szSupView, supportedView))
    {
        WriteTrace(0x14,"SnmpExtensionInit: Unable to convert supported view string to OID\n");
        WriteLog(SNMPELEA_SUPVIEW_CONVERT_ERROR);

        WriteTrace(0x14,"SnmpExtensionInit: SNMP Event Log Extension Agent DLL abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);      // log error message
        WriteTrace(0x0a,"SnmpExtensionInit: Exiting extension agent SnmpExtensionInit routine with FALSE\n");

        goto Error;
    }

    dwTimeZero = dwTimeZeroReference;                       // save time zero reference
    *hPollForTrapEvent = hEventNotify;                      // return handle to event

    WriteTrace(0x0a,"SnmpExtensionInit: Exiting extension agent SnmpExtensionInit routine with TRUE\n");
    return(TRUE);

Error:
    SnmpExtensionClose();

    return(FALSE);
}
}

extern "C" {
VOID
APIENTRY
SnmpExtensionClose()
{
    DWORD   lastError;      // to save GetLastError() return code
    DWORD   dwThreadID;
    DWORD   dwWaitResult;
    BOOL    Itworked;

    WriteTrace(0x0a,"SnmpExtensionClose: Entering extension agent SnmpExtensionClose routine.\n");
    if (hStopAll && !SetEvent(hStopAll) )
    {
        lastError = GetLastError(); // save error status
        WriteTrace(0x14,"SnmpExtensionClose: Error setting dll termination event %08X in process detach; code %lu\n",
            hStopAll, lastError);
        WriteLog(SNMPELEA_ERROR_SET_AGENT_STOP_EVENT, HandleToUlong(hStopAll), lastError);  // log error message
    }
    else
    {
        WriteTrace(0x0a,"SnmpExtensionClose: Shutdown event %08X is now complete\n",
                                hStopAll);
    }

    if (hServThrd)
    {
        WriteTrace(0x0a,"SnmpExtensionClose: Waiting for event log processing thread %08X to terminate\n", hServThrd);
        WriteTrace(0x0a,"SnmpExtensionClose: Checking for thread exit code value\n");
        Itworked = GetExitCodeThread(hServThrd, &dwThreadID);
        WriteTrace(0x0a,"SnmpExtensionClose: Thread exit code value is %lu\n",dwThreadID);

        if (!Itworked || (dwThreadID == STILL_ACTIVE))
        {
            if (!Itworked)
            {
                lastError = GetLastError();
                WriteTrace(0x14,"SnmpExtensionClose: GetExitCodeThread returned FALSE, reason code %lu\n",
                        lastError);
                WriteLog(SNMPELEA_GET_EXIT_CODE_THREAD_FAILED, lastError);
            }
            else
            {
                WriteTrace(0x0a,"SnmpExtensionClose: Thread exit code indicates still active. Will wait...\n");
            }

            // wait for the child to end
            WriteTrace(0x0a,"SnmpExtensionClose: About to wait...\n");
            // bug# 277187: removal of TerminateThread by waiting until hServThrd has gone
            dwWaitResult = WaitForSingleObject(hServThrd, INFINITE);
            
            WriteTrace(0x0a,"SnmpExtensionClose: Finished wait...\n");

            switch (dwWaitResult)
            {
            case WAIT_FAILED:
                lastError = GetLastError(); // save error status
                WriteTrace(0x14,"SnmpExtensionClose: Error on WaitForSingleObject/log processing thread %08X; code %lu\n",
                        hServThrd, lastError);
                WriteLog(SNMPELEA_ERROR_WAIT_LOG_THREAD_STOP,
                        HandleToUlong(hServThrd), lastError);    // log error message
                break;
            case WAIT_OBJECT_0 :
                WriteTrace(0x0a,"SnmpExtensionClose: Event log processing thread %08X has terminated!\n",hServThrd);
                break;
            case WAIT_TIMEOUT :
                WriteTrace(0x14,"SnmpExtensionClose: Event log processing thread %08X has not terminated within 30 seconds; terminating thread\n",
                        hServThrd);
                WriteLog(SNMPELEA_LOG_THREAD_STOP_WAIT_30,
                        HandleToUlong(hServThrd));  // log error message
                break;
            default :
                WriteTrace(0x14,"SnmpExtensionClose: Unknown result from WaitForSingleObject waiting on log processing thread %08X termination is %lu\n",
                        hServThrd, dwWaitResult );
                WriteLog(SNMPELEA_WAIT_LOG_STOP_UNKNOWN_RETURN,
                        HandleToUlong(hServThrd), dwWaitResult);  // log error message
            }
        }

        WriteTrace(0x0a,"SnmpExtensionClose: Checking for thread exit code again\n");
        Itworked = GetExitCodeThread(hServThrd, &dwThreadID);
        WriteTrace(0x0a,"SnmpExtensionClose: Thread exit code value is %lu\n",dwThreadID);

        WriteTrace(0x0a,"SnmpExtensionClose: Closing handle to log processing thread %08X\n",
                hServThrd);
        if ( !CloseHandle(hServThrd) )
        {
            lastError = GetLastError(); // save error status
            WriteTrace(0x14,"SnmpExtensionClose: Error closing handle for log processing thread %08X; code %lu\n",
                    hServThrd, lastError);
            WriteLog(SNMPELEA_ERROR_CLOSING_STOP_LOG_THREAD_HANDLE,
                    HandleToUlong(hServThrd), lastError); // log error message
        }
        hServThrd = NULL;
    }

    CloseStopAll();                     // close event handle
    CloseEventNotify();                 // close event handle
    if (fRegOk)
    {
        CloseRegNotify();               // close event handle
        CloseRegParmKey();              // close registry key
        fRegOk = FALSE;
    }
    CloseLogs();                        // close all open log files
    CloseSourceHandles();

    WriteLog(SNMPELEA_STOPPED);
    if (hWriteEvent)
    {
        DeregisterEventSource(hWriteEvent); // no longer a need for logging
        hWriteEvent = NULL;
    }
    WriteTrace(0x14,"SnmpExtensionClose: SNMPELEA Event Log Extension Agent DLL has terminated\n");
}
}


BOOL
BuildThresholdTrap(
    IN  VOID
    )

/*++

Routine Description:

        This routine will build the threshold trap.


Arguments:

        None


Return Value:

        TRUE if created varbind, FALSE if an error occurred.

--*/

{
        TCHAR   szBuf[MAX_PATH+1];      // for OID conversion
        UINT    i;                      // counter
        BOOL    fOk;                    // used by WRAP_STRCAT_A macro

        WriteTrace(0x0a,"BuildThresholdTrap: Building static variable bindings for threshold trap\n");
        WriteTrace(0x00,"BuildThresholdTrap: &thresholdVarBind is at %08X\n", &thresholdVarBind);
        WriteTrace(0x00,"BuildThresholdTrap: thresholdVarBind is %08X\n", thresholdVarBind);

        WriteTrace(0x00,"BuildThresholdTrap: BaseEnterpriseOID value read is %s\n", szBaseOID);

        if ( !StrToOid((char *) &szBaseOID, &thresholdOID) )
        {
            WriteTrace(0x14,"BuildThresholdTrap: Unable to convert OID from BaseEnterpriseOID\n");
            WriteLog(SNMPELEA_CANT_CONVERT_ENTERPRISE_OID);
            return(FALSE);
        }

        szBuf[MAX_PATH] = 0;
        strncpy(szBuf, szBaseOID, MAX_PATH);            // copy base string
        WRAP_STRCAT_A(szBuf, TEXT(".1.0"), MAX_PATH);   // tack on for varbind OID

        thresholdVarBind.list = (RFC1157VarBind *) SNMP_malloc(sizeof(RFC1157VarBind)); // allocate storage for varbind

        if (thresholdVarBind.list == NULL)
        {
             WriteTrace(0x14,"BuildThresholdTrap: Unable to allocate storage for varbind\n");
             WriteLog(SNMPELEA_ERROR_ALLOC_VAR_BIND);
             return(FALSE);
        }

        WriteTrace(0x00,"BuildThresholdTrap: Storage allocated for varbind entry at address at %08X\n",
                thresholdVarBind.list);

        thresholdVarBind.len = 1;               // set # of varbinds

        WriteTrace(0x00,"BuildThresholdTrap: Number of varbinds present set to %lu\n",
                thresholdVarBind.len);

        TCHAR * tempthreshmsg = (TCHAR *) SNMP_malloc(strlen(lpszThreshold) + 1);

        if (tempthreshmsg == NULL)
        {
            WriteTrace(0x14,"BuildThresholdTrap: Unable to allocate tempthreshmsg\n");
            SNMP_free(thresholdVarBind.list);
            thresholdVarBind.list = NULL;
            thresholdVarBind.len = 0;
            return (FALSE);
        }
        strcpy(tempthreshmsg, lpszThreshold);

        thresholdVarBind.list[0].value.asnValue.string.length = strlen(tempthreshmsg);  // get string length
        thresholdVarBind.list[0].value.asnValue.string.stream = (PUCHAR) tempthreshmsg; // point to string
        thresholdVarBind.list[0].value.asnValue.string.dynamic = TRUE;  // indicate not dynamically allocated
        thresholdVarBind.list[0].value.asnType = ASN_RFC1213_DISPSTRING;        // indicate type of object

        if ( !StrToOid((char *) &szBuf, &thresholdVarBind.list[0].name) )
        {
            WriteTrace(0x14,"BuildThresholdTrap: Unable to convert OID from BaseEnterpriseOID\n");
            WriteLog(SNMPELEA_CANT_CONVERT_ENTERPRISE_OID);
            SNMP_free(thresholdVarBind.list[0].value.asnValue.string.stream);
            SNMP_free(thresholdVarBind.list);
            thresholdVarBind.list = NULL;
            thresholdVarBind.len = 0;
            return (FALSE);
        }

        if (nTraceLevel == 0)
        {
            WriteTrace(0x00,"BuildThresholdTrap: Varbind entry length is %lu\n",
                    thresholdVarBind.list[0].value.asnValue.string.length);
            WriteTrace(0x00,"BuildThresholdTrap: Varbind entry string is %s\n",
                    thresholdVarBind.list[0].value.asnValue.string.stream);
            WriteTrace(0x00,"BuildThresholdTrap: Varbind OID length is %lu\n",
                    thresholdVarBind.list[0].name.idLength);

            for (i = 0; i < thresholdVarBind.list[0].name.idLength; i++)
            {
                    WriteTrace(0x00,"BuildThresholdTrap: Varbind OID[%lu] is %lu\n",
                            i, thresholdVarBind.list[0].name.ids[i]);
            }
        }

        WriteTrace(0x00,"BuildThresholdTrap: &thresholdOID is at %08X\n", &thresholdOID);
        WriteTrace(0x00,"BuildThresholdTrap: thresholdOID is %08X\n", thresholdOID);
        WriteTrace(0x00,"BuildThresholdTrap: &thresholdVarBind is at %08X\n", &thresholdVarBind);
        WriteTrace(0x00,"BuildThresholdTrap: thresholdVarBind is %08X\n", thresholdVarBind);
        WriteTrace(0x0a,"BuildThresholdTrap: Variable bindings for threshold trap have been built\n");

        return (TRUE);

Error:
        WriteTrace(0x14,"BuildThresholdTrap: Unable to append .1.0 to %s\n", szBuf);
        return (FALSE);
}


extern "C" {
BOOL
APIENTRY
SnmpExtensionTrap(
    IN  OUT AsnObjectIdentifier *enterprise,
        OUT AsnInteger          *genericTrap,
        OUT AsnInteger          *specificTrap,
        OUT AsnTimeticks        *timeStamp,
    IN  OUT RFC1157VarBindList  *variableBindings
        )

/*++

Routine Description:

        SnmpExtensionTrap is the extension dll trap processing routine.

        This routine will query the log processing output queue to determine if a trap has been
        generated and needs to be returned. A Mutex object is used to synchronize processing
        between this thread and the log event processing thread.

Arguments:

        enterprise              -       Points to an OID indicating the originating enterprise generating the trap.

        genericTrap             -       Points to an indication of the generic trap. Always indicates specific.

        specificTrap            -       Points to an indication of the specific trap generated. This is the
                                                        event log message number.

        timeStamp               -       Points to a variable to receive the time stamp.

        variableBindings        -       Points to a list of variable bindings.

Return Value:

        TRUE    -       Valid trap data is being returned.

        FALSE   -       No traps were on the queue to process.

--*/

{
    LONG                    lastError;              // GetLastError value
    UINT                    i,j;                    // counter
    DWORD                   status, dwTimeNow;      // status variable and temp time holder
    HANDLE                  hWaitList[2];           // wait list
    PVarBindQueue   lpNewVarBindQueue;              // temporary pointer
    DWORD                   dwOne = 1;                              // for registry setting

    WriteTrace(0x0a,"SnmpExtensionTrap: Entering SnmpExtensionTrap routine\n");
    
    hWaitList[0] = hMutex;                          // mutex handle
    hWaitList[1] = hStopAll;                        // DLL termination event handle

    WriteTrace(0x00,"SnmpExtensionTrap: Varbind list upon entry is %08X\n", variableBindings);
    WriteTrace(0x00,"SnmpExtensionTrap: Varbind queue upon entry is %08X\n", lpVarBindQueue);
    WriteTrace(0x00,"SnmpExtensionTrap: Handle to Mutex object is %08X\n", hMutex);
    WriteTrace(0x0a,"SnmpExtensionTrap: Waiting for Mutex object to become available\n");

    while (TRUE)
    {
         status = WaitForMultipleObjects(
                 2,                             // only two objects to wait on
                 (CONST PHANDLE) &hWaitList,        // address of array of event handles
                 FALSE,                          // only one event is required
                 1000);                          // only wait one second

        lastError = GetLastError();                     // save any error conditions
        WriteTrace(0x0a,"SnmpExtensionTrap: WaitForMulitpleObjects returned a value of %lu\n", status);

        switch (status)
        {
            case WAIT_FAILED:
                 WriteTrace(0x14,"SnmpExtensionTrap: Error waiting for mutex event array is %lu\n",
                         lastError);                                     // trace error message
                 WriteLog(SNMPELEA_ERROR_WAIT_ARRAY, lastError); // log error message
                 WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with FALSE\n");
                 return(FALSE);                                  // get out now
            case WAIT_TIMEOUT:
                    WriteTrace(0x0a,"SnmpExtensionTrap: Mutex object not available yet. Wait will continue.\n");
                 continue;                                               // retry the wait
            case WAIT_ABANDONED:
                    WriteTrace(0x14,"SnmpExtensionTrap: Mutex object has been abandoned.\n");
                 WriteLog(SNMPELEA_MUTEX_ABANDONED);
                 WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with FALSE\n");
                 return(FALSE);                                  // get out now
            case 1:
                 WriteTrace(0x0a,"SnmpExtensionTrap: DLL shutdown detected. Wait abandoned.\n");
                 WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with FALSE\n");
                 return(FALSE);
            case 0:
                 WriteTrace(0x0a,"SnmpExtensionTrap: Mutex object acquired.\n");
                 break;
            default:
                    WriteTrace(0x14,"SnmpExtensionTrap: Undefined error encountered in WaitForMultipleObjects. Wait abandoned.\n");
                 WriteLog(SNMPELEA_ERROR_WAIT_UNKNOWN);
                 WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with FALSE\n");
                 return(FALSE);                                  // get out now
        }   // end switch for processing WaitForMultipleObjects

        break;                  // if we get here, then we've got the Mutex object

    }   // end while true for acquiring Mutex object

    while (TRUE)
    {
        if ( lpVarBindQueue == (PVarBindQueue) NULL )
        {
            WriteTrace(0x0a,"SnmpExtensionTrap: Varbind queue pointer indicates no more data to process\n");

            WriteTrace(0x0a,"SnmpExtensionTrap: Releasing mutex object %08X\n", hMutex);
            if (!ReleaseMutex(hMutex))
            {
                lastError = GetLastError();             // get error information
                WriteTrace(0x14,"SnmpExtensionTrap: Unable to release mutex object for reason code %lu\n",
                        lastError);
                WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
            }

            WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with FALSE\n");
            return(FALSE);                          // exit and indicate pointers are valid
        }

        if (lpVarBindQueue->fProcessed)
        {
            dwTrapQueueSize--;
            WriteTrace(0x0a,"SnmpExtensionTrap: Current queue pointer indicates processed trap\n");
            WriteTrace(0x00,"SnmpExtensionTrap: Freeing processed trap storage\n");

            WriteTrace(0x00,"SnmpExtensionTrap: Freeing enterprise OID %08X\n",
                    lpVarBindQueue->enterprise);
            SNMP_free(lpVarBindQueue->enterprise->ids);                     // free enterprise OID
            SNMP_free(lpVarBindQueue->enterprise);
            WriteTrace(0x00,"SnmpExtensionTrap: Saving forward buffer pointer %08X\n",
                    lpVarBindQueue->lpNextQueueEntry);
            lpNewVarBindQueue = lpVarBindQueue->lpNextQueueEntry;   // save forward pointer

// The following will free the storage for the VarBindQueue entry. This includes:
//              enterprise
//              dwEventTime
//              dwEventID
//              lpVariableBindings
//              fProcessed
//              lpNextQueueEntry

            WriteTrace(0x00,"SnmpExtensionTrap: Freeing varbind list pointer %08X\n",
                    lpVarBindQueue->lpVariableBindings);
            // the code here assume the trap retriever free'ed
            // individual varbinds pointed by lpVariableBindings
            SNMP_free(lpVarBindQueue->lpVariableBindings);    // free varbind list pointer
            WriteTrace(0x00,"SnmpExtensionTrap: Freeing varbind queue entry storage %08X\n",
                    lpVarBindQueue);
            SNMP_free(lpVarBindQueue);          // free remaining storage
            lpVarBindQueue = lpNewVarBindQueue; // reset current pointer
            WriteTrace(0x00,"SnmpExtensionTrap: Setting current buffer pointer to %08X\n",
                    lpVarBindQueue);
            WriteTrace(0x0a,"SnmpExtensionTrap: Reentering process loop for next buffer entry\n");

            //While cleaning up check to see if threshold trap needs to be sent

            if (fThresholdEnabled && fThreshold && fSendThresholdTrap)
            {
                WriteTrace(0x0a,"SnmpExtensionTrap: Sending trap to indicate performance threshold has been reached.\n");
                fSendThresholdTrap = FALSE;             // reset indicator

                WriteTrace(0x0a,"SnmpExtensionTrap: Delete all varbind entries\n");

                //delete all the entries in the varbind queue.
                while ( lpVarBindQueue != (PVarBindQueue) NULL )
                {
                    lpNewVarBindQueue = lpVarBindQueue->lpNextQueueEntry;   // save forward pointer
                    FreeVarBind(lpVarBindQueue->lpVariableBindings->len,
                                        lpVarBindQueue->lpVariableBindings);    // free varbind information
                    SNMP_free(lpVarBindQueue->enterprise->ids);                 // free enterprise OID field
                    SNMP_free(lpVarBindQueue->enterprise);                      // free enterprise OID field
                    SNMP_free(lpVarBindQueue->lpVariableBindings->list);        // free varbind storage
                    SNMP_free(lpVarBindQueue->lpVariableBindings);              // free varbind list storage
                    SNMP_free(lpVarBindQueue);                                  // free varbind entry
                    lpVarBindQueue = lpNewVarBindQueue;                         // reset current pointer
                }

                WriteTrace(0x0a,"SnmpExtensionTrap: Deleted all entries, releasing mutex object %08X\n", hMutex);

                if (!ReleaseMutex(hMutex))
                {
                    lastError = GetLastError();             // get error information
                    WriteTrace(0x14,"SnmpExtensionTrap: Unable to release mutex object for reason code %lu\n",
                                lastError);
                    WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
                }

                if (!BuildThresholdTrap())
                {
                    return (FALSE);
                }

                *enterprise = *(&thresholdOID);                                 // point to enterprise OID field
                *genericTrap = SNMP_GENERICTRAP_ENTERSPECIFIC;  // indicate a specific type trap
                *timeStamp = GetCurrentTime() - dwTimeZero;             // get time reference for trap
                *specificTrap = SNMPELEA_THRESHOLD_REACHED & 0x0000ffff;        // get log message number
                *variableBindings = *(&thresholdVarBind);               // get varbind list pointer

                if (nTraceLevel == 0)
                {
                    WriteTrace(0x00,"SnmpExtensionTrap: *enterprise is %08X\n", *enterprise);
                    WriteTrace(0x00,"SnmpExtensionTrap: &thresholdOID is %08X\n", &thresholdOID);
                    WriteTrace(0x00,"SnmpExtensionTrap: *timeStamp is %08X\n", *timeStamp);
                    WriteTrace(0x00,"SnmpExtensionTrap: *variableBindings is %08X\n", *variableBindings);
                    WriteTrace(0x00,"SnmpExtensionTrap: &thresholdVarBind is %08X\n", &thresholdVarBind);
                    WriteTrace(0x00,"SnmpExtensionTrap: *specificTrap is %08X\n", *specificTrap);
                    WriteTrace(0x00,"SnmpExtensionTrap: SNMPELEA_THRESHOLD_REACHED is %08X\n", SNMPELEA_THRESHOLD_REACHED & 0x0000ffff);

                    WriteTrace(0x00,"SnmpExtensionTrap: Number of entries in enterprise OID is %lu\n",
                            enterprise->idLength);

                    for (i = 0; i < enterprise->idLength; i++)
                    {
                        WriteTrace(0x00,"SnmpExtensionTrap: Enterprise OID[%lu] is %lu\n",
                                    i, enterprise->ids[i]);
                    }

                    for (i = 0; i < variableBindings->len; i++)
                    {
                        WriteTrace(0x00,"SnmpExtensionTrap: Variable binding %lu is %s, length %lu\n",
                                i, variableBindings->list[i].value.asnValue.string.stream,
                                variableBindings->list[i].value.asnValue.string.length
                                );

                        WriteTrace(0x00,"SnmpExtensionTrap: OID for this binding is (number of %lu):\n",
                                variableBindings->list[i].name.idLength);
                        WriteTrace(0x00,"SnmpExtensionTrap: ");

                        for (j = 0; j < variableBindings->list[i].name.idLength; j++)
                        {
                                WriteTrace(MAXDWORD,"%lu.", variableBindings->list[i].name.ids[j]);
                        }
                        WriteTrace(MAXDWORD,"\n");
                    }
                }

                WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with TRUE\n");
                return(TRUE);                           // exit and indicate pointers are valid
            }

            continue;                                   // reenter loop
        }

        *enterprise = *(lpVarBindQueue->enterprise);    // point to enterprise OID field
        *genericTrap = SNMP_GENERICTRAP_ENTERSPECIFIC;  // indicate a specific type trap
        *timeStamp = lpVarBindQueue->dwEventTime;       // get time reference for trap
        *specificTrap = lpVarBindQueue->dwEventID;      // get event log message number
        *variableBindings = *(lpVarBindQueue->lpVariableBindings);      // get varbind list pointer

        if (nTraceLevel == 0)
        {
            WriteTrace(0x00,"SnmpExtensionTrap: *enterprise is %08X\n", *enterprise);
            WriteTrace(0x00,"SnmpExtensionTrap: *(lpVarBindQueue->enterprise) is %08X\n",
                    lpVarBindQueue->enterprise);
            WriteTrace(0x00,"SnmpExtensionTrap: *variableBindings is %08X\n", *variableBindings);
            WriteTrace(0x00,"SnmpExtensionTrap: *(lpVarBindQueue->VariableBindings) is %08X\n",
                    lpVarBindQueue->lpVariableBindings);

            WriteTrace(0x00,"SnmpExtensionTrap: Number of entries in enterprise OID is %lu\n",
                    enterprise->idLength);

            for (i = 0; i < enterprise->idLength; i++)
            {
                WriteTrace(0x00,"SnmpExtensionTrap: Enterprise OID[%lu] is %lu\n",
                            i, enterprise->ids[i]);
            }

            for (i = 0; i < variableBindings->len; i++)
            {
                WriteTrace(0x00,"SnmpExtensionTrap: Variable binding %lu is %s, length %lu\n",
                        i, variableBindings->list[i].value.asnValue.string.stream,
                        variableBindings->list[i].value.asnValue.string.length
                        );

                WriteTrace(0x00,"SnmpExtensionTrap: OID for this binding is (number of %lu):\n",
                        variableBindings->list[i].name.idLength);
                WriteTrace(0x00,"SnmpExtensionTrap: ");

                for (j = 0; j < variableBindings->list[i].name.idLength; j++)
                {
                    WriteTrace(MAXDWORD,"%lu.", variableBindings->list[i].name.ids[j]);
                }
                WriteTrace(MAXDWORD,"\n");
            }
        }

        lpVarBindQueue->fProcessed = TRUE;     // indicate this entry processed
        break;
    }

    WriteTrace(0x0a,"SnmpExtensionTrap: Releasing mutex object %08X\n", hMutex);
    if (!ReleaseMutex(hMutex))
    {
        lastError = GetLastError();             // get error information
        WriteTrace(0x14,"SnmpExtensionTrap: Unable to release mutex object for reason code %lu\n",
                lastError);
        WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
    }

    if (fThresholdEnabled)
    {
        if (!fThreshold)
        {
            dwTimeNow = GetTickCount() / 1000;  // get current time information

            if (dwTrapStartTime == 0)
            {
                dwTrapCount = 1;                // indicate first trap sent
                dwTrapStartTime = dwTimeNow;    // set start time
            }
            else
            {
                if ( (dwTimeNow - dwTrapStartTime) >= dwThresholdTime )
                {
                    WriteTrace(0x0a,"SnmpExtensionTrap:     Threshold time has been exceeded. Resetting threshold values.\n");
                    dwTrapCount = 1;                // reset to 1 trap sent
                    dwTrapStartTime = dwTimeNow;    // set start time
                }
                else
                {
                    if (++dwTrapCount >= dwThresholdCount)
                    {
                        WriteTrace(0x0a,"SnmpExtensionTrap: Threshold count has been reached within defined performance parameters.\n");
                        WriteTrace(0x0a,"SnmpExtensionTrap: Further traps will not be sent without operator intervention.\n");
                        WriteLog(SNMPELEA_THRESHOLD_REACHED);

                        fThreshold = TRUE;          // indicate performance stuff active
                        fSendThresholdTrap = TRUE;  // indicate to send the threshold reached trap next time

                        dwTrapCount = 0;                // reset trap count
                        dwTrapStartTime = 0;            // indicate start time is invalid

                        if ( (lastError = RegSetValueEx(
                                hkRegResult,                // registry key opened
                                EXTENSION_THRESHOLD_FLAG,   // which key value to set
                                NULL,                       // reserved
                                REG_DWORD,                  // type of value to set
                                (const LPBYTE) &dwOne,      // address of value to set to
                                sizeof(DWORD)               // size of the data value
                                            ) != ERROR_SUCCESS)
                            )
                        {
                            WriteTrace(0x14,"SnmpExtensionTrap: Unable to set registry key for threshold reached; RegSetValueEx returned %lu\n",
                                        lastError);
                            WriteLog(SNMPELEA_SET_VALUE_FAILED, lastError);
                        }

                        WriteTrace(0x0a,"SnmpExtensionTrap: Threshold reached flag has been set in the registry\n");
                    }
                    else
                    {
                        WriteTrace(0x00,"SnmpExtensionTrap: Threshold count is %lu; time elapsed is %08X\n",
                                    dwTrapCount, dwTimeNow - dwTrapStartTime);
                    }
                }
            }
        }
    }

    WriteTrace(0x0a,"SnmpExtensionTrap: Exiting SnmpExtensionTrap routine with TRUE\n");
    return(TRUE);                                                                   // indicate that trap data is valid
}
}


extern "C" {
BOOL
APIENTRY
SnmpExtensionQuery(
    IN          BYTE                    requestType,
    IN  OUT     RFC1157VarBindList      *variableBindings,
    OUT         AsnInteger              *errorStatus,
    OUT         AsnInteger              *errorIndex
        )

/*++

Routine Description:

        SnmpExtensionQuery is the extension dll query processing routine.

        This routine is not supported and always returns an error.

Arguments:

        requestType                     -       Points to an OID indicating the originating enterprise generating the trap.

        variableBindings        -       Points to a list of variable bindings.

        errorStatus                     -       Points to a variable to receive the error status. Always ASN_ERRORSTATUS_NOSUCHNAME.

        errorIndex                      -       Points to a variable to receive the resulting error index. Always 0.

Return Value:

        Always returns TRUE.

--*/

{
    WriteTrace(0x0a,"SnmpExtensionQuery: Entering SnmpExtensionQuery routine\n");

    *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME; // indicate we don't know what they're asking for
    *errorIndex = 1;                            // indicate that it's the first varbind
                                                // show it's the first parameter

    if (requestType == MIB_ACTION_GETNEXT)
    {
        AsnObjectIdentifier oidOutOfView;

        // initialize oidOutOfView.ids, to avoid heap corruption when
        // when free-ed if StrToOid failed.
        oidOutOfView.ids = NULL;
        if (variableBindings != NULL && 
            StrToOid(szSupView, &oidOutOfView) &&
            oidOutOfView.idLength > 0)
        {
            UINT iVar;

            oidOutOfView.ids[oidOutOfView.idLength-1]++;

            for (iVar = 0; iVar < variableBindings->len; iVar++)
            {
                RFC1157VarBind *pVarBind;

                pVarBind = &(variableBindings->list[iVar]);
                SnmpUtilOidFree(&(pVarBind->name));
                if (! SnmpUtilOidCpy(&(pVarBind->name), &oidOutOfView))
                {
                    SnmpUtilOidFree(&oidOutOfView);
                    *errorStatus = SNMP_ERRORSTATUS_GENERR;
                    *errorIndex = iVar+1;       // iVar+1th varbind failed
                    return(SNMPAPI_NOERROR);    // return to caller 
                }
            }
            *errorStatus = SNMP_ERRORSTATUS_NOERROR;
            *errorIndex = 0;
        }

        SnmpUtilOidFree(&oidOutOfView);
    }


    WriteTrace(0x0a,"SnmpExtensionQuery: Exiting SnmpExtensionQuery routine\n");
    return(SNMPAPI_NOERROR);    // return to caller
}
}


// MikeCure 4/3/98 hotfix for SMS Bug1 #20521
//=============================================================================
//
//      EnablePrivileges()
//
//      Notes:  Added a new function to set the proper privileges on the
//              security log With NT 5 and NT4 SP5, the default privileges
//              no longer have access implicitely allowed. Now we've got to
//              grant explicit access.
//
//      Routine Description:
//              This routine enables all privileges in the token.
//
//      Arguments:
//              None.
//
//      Return Value:
//              BOOL.
//
//=============================================================================
BOOL EnablePrivilege(VOID)
{
    HANDLE Token;
    ULONG ReturnLength;
    PTOKEN_PRIVILEGES NewState;
    LUID Luid;
    BOOL Result;
    
    Token = NULL;
    NewState = NULL;
    
    Result = OpenProcessToken( GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &Token
        );
    if (Result) {
        ReturnLength = 4096;
        NewState = (PTOKEN_PRIVILEGES) malloc( ReturnLength );
        Result = (BOOL)(NewState != NULL);
        if (Result) {
            Result = GetTokenInformation( Token,            // TokenHandle
                TokenPrivileges,  // TokenInformationClass
                NewState,         // TokenInformation
                ReturnLength,     // TokenInformationLength
                &ReturnLength     // ReturnLength
                );
            
            if (Result) {
                //
                // Enable Security Privilege
                //
                Result = LookupPrivilegeValue(  NULL,
                    "SeSecurityPrivilege",
                    &Luid
                    );
                
                    if (Result) {
                    
                    NewState->PrivilegeCount = 1;
                    NewState->Privileges[0].Luid = Luid;
                    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                    
                    Result = AdjustTokenPrivileges( Token,          // TokenHandle
                        FALSE,          // DisableAllPrivileges
                        NewState,       // NewState (OPTIONAL)
                        ReturnLength,   // BufferLength
                        NULL,           // PreviousState (OPTIONAL)
                        &ReturnLength   // ReturnLength
                        );
                }       
            }
        }
                
        if (NewState != NULL) {
            free( NewState );
        }
        
        if (Token != NULL) {
            CloseHandle( Token );
        }
    }
    return( Result );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntagnt\eaload.cpp ===
#include <windows.h>        // windows definitions
#include <snmp.h>           // snmp definitions
#include "snmpelea.h"       // global dll definitions
#include "snmpelmg.h"
#include "snmpelep.h"
#include "EALoad.h"

// Returns in 'Params' the requested parameters (identified by Params.dwParams field)
DWORD LoadPrimaryModuleParams(
         IN  HKEY hkLogFile,               // opened registry key to HKLM\System\CurrentControlSet\Services\EventLog\<LogFile>
         IN  LPCTSTR tchPrimModule,        // name of the PrimaryModule as it is defined in the "PrimaryModule" value of the key above
         OUT tPrimaryModuleParms &Params)  // allocated output buffer, ready to receive the values for the requested parameters
{
    DWORD retCode;
    HKEY  hkPrimaryModule;

    // open the 'HKLM\SYSTEM\CurrentControlSet\Services\EventLog\<LogFile>\<PrimaryModule>' registry key
    retCode = RegOpenKeyEx(
                hkLogFile,
                tchPrimModule,
                0,
                KEY_READ,
                &hkPrimaryModule);
    if (retCode != ERROR_SUCCESS)
        return retCode;

    if (Params.dwParams & PMP_PARAMMSGFILE) // "ParameterMessageFile" is requested
    {
        DWORD dwRequired;
        DWORD dwType;
        TCHAR tszParamMsgFileName[MAX_PATH+1];
        DWORD dwParamMsgFileLen = sizeof(tszParamMsgFileName) - sizeof(TCHAR);
        tszParamMsgFileName[MAX_PATH] = 0;

        // get the 'ParameterMessageFile' value from the '<PrimaryModule>' key
        retCode = RegQueryValueEx(
                    hkPrimaryModule,
                    EXTENSION_PARM_MODULE,
                    0,
                    &dwType,
                    (LPBYTE) tszParamMsgFileName,
                    &dwParamMsgFileLen);
        if (retCode == ERROR_SUCCESS)
        {
            TCHAR tszExpandedFileName[MAX_PATH+1];

            dwRequired = ExpandEnvironmentStrings(
                            tszParamMsgFileName,
                            tszExpandedFileName,
                            MAX_PATH+1);
            if ((dwRequired != 0) && (dwRequired <= MAX_PATH+1))
            {
                Params.hModule = (HMODULE) LoadLibraryEx(tszExpandedFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
                if (Params.hModule == NULL)
                {
                    retCode = GetLastError();
                    WriteLog(SNMPELEA_CANT_LOAD_PRIM_DLL, tszParamMsgFileName, retCode);
                }
            }
            else
                retCode = GetLastError();
        }
    }

    RegCloseKey(hkPrimaryModule);

    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpelea.h ===
#ifndef SNMPELEA_H
#define SNMPELEA_H

//
// NTSTATUS
//

typedef LONG NTSTATUS;
/*lint -e624 */  // Don't complain about different typedefs.   // winnt
typedef NTSTATUS *PNTSTATUS;
/*lint +e624 */  // Resume checking for different typedefs.    // winnt

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

// begin_winnt
#define APPLICATION_ERROR_MASK       0x20000000
#define ERROR_SEVERITY_SUCCESS       0x00000000
#define ERROR_SEVERITY_INFORMATIONAL 0x40000000
#define ERROR_SEVERITY_WARNING       0x80000000
#define ERROR_SEVERITY_ERROR         0xC0000000
// end_winnt

typedef HMODULE *PHMODULE;

#define HANDLESIZE      sizeof(HANDLE)
#define EVENTRECSIZE    sizeof(EVENTLOGRECORD)
#define LOG_BUF_SIZE    4096
#define EVENTIDSIZE     4
#define MAX_QUEUE_SIZE  20

#define HALFMAXDWORD    0x80000000

#define SERVICE_ROOT                        TEXT("SYSTEM\\CurrentControlSet\\Services\\")
#define EXTENSION_ROOT                      TEXT("SOFTWARE\\Microsoft\\SNMP_EVENTS\\EventLog\\")
#define EXTENSION_SOURCES                   TEXT("SOFTWARE\\Microsoft\\SNMP_EVENTS\\EventLog\\Sources\\")

#define EVNTAGNT_NAME                       TEXT("EvntAgnt")
#define EVENTLOG_BASE       SERVICE_ROOT    TEXT("EventLog\\")
#define EVENTLOG_ROOT       EVENTLOG_BASE   TEXT("Application\\")
#define EVENTLOG_SERVICE    EVENTLOG_ROOT   EVNTAGNT_NAME

#define EXTENSION_PARM      EXTENSION_ROOT  TEXT("Parameters")

#define EXTENSION_MSG_MODULE                TEXT("EventMessageFile")
#define EXTENSION_PARM_MODULE               TEXT("ParameterMessageFile")
#define EXTENSION_PRIM_MODULE               TEXT("PrimaryModule")

#define EXTENSION_TRACE_FILE                TEXT("TraceFileName")
#define EXTENSION_TRACE_LEVEL               TEXT("TraceLevel")
#define EXTENSION_BASE_OID                  TEXT("BaseEnterpriseOID")
#define EXTENSION_SUPPORTED_VIEW            TEXT("SupportedView")
#define EXTENSION_TRIM                      TEXT("TrimMessage")
#define EXTENSION_MAX_TRAP_SIZE             TEXT("MaxTrapSize")
#define EXTENSION_TRIM_FLAG                 TEXT("TrimFlag")

#define EXTENSION_ENTERPRISE_OID            TEXT("EnterpriseOID")
#define EXTENSION_APPEND                    TEXT("Append")
#define EXTENSION_COUNT                     TEXT("Count")
#define EXTENSION_TIME                      TEXT("Time")
#define EXTENSION_THRESHOLD_FLAG            TEXT("Threshold")
#define EXTENSION_THRESHOLD_ENABLED         TEXT("ThresholdEnabled")
#define EXTENSION_THRESHOLD_COUNT           TEXT("ThresholdCount")
#define EXTENSION_THRESHOLD_TIME            TEXT("ThresholdTime")
#define EXTENSION_LASTBOOT_TIME             TEXT("LastBootTime")
#define EXTENSION_EVENT_LOG_POLL_TIME       TEXT("EventLogPollTime")
#define EXTENSION_VARBIND_PREFIX_SUB_ID     TEXT("VarBindPrefixSubId")

#define MUTEX_NAME                          TEXT("SnmpEventLogMutex")   // Mutex name

typedef struct  _VarBindQueue {
            DWORD               dwEventID;              // event ID
            DWORD               dwEventTime;            // time this event occurred
            BOOL                fProcessed;             // buffer processed flag
            AsnObjectIdentifier *enterprise;            // enterprise OID
            RFC1157VarBindList  *lpVariableBindings;    // variable bindings list
    struct  _VarBindQueue       *lpNextQueueEntry;      // pointer to next buffer structure
} VarBindQueue, *PVarBindQueue;

typedef struct    _SourceHandleList {
         HINSTANCE   handle;
         TCHAR       sourcename[MAX_PATH+1];
   struct _SourceHandleList   *Next;
} SourceHandleList, *PSourceHandleList;

const   UINT    MAX_TRAP_SIZE=4096;         // a guess provided by Microsoft
const   UINT    BASE_PDU_SIZE=300;          // a guess provided by Microsoft

const   UINT    THRESHOLD_COUNT=500;        // default performance threshold count
const   UINT    THRESHOLD_TIME=300;         // default performance threshold time in seconds

#endif                  // end of snmpelea.h definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\lmmib2\uses_tbl.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    uses_tbl.h

Abstract:

    Define the structures and routines used in the workstation uses table.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef uses_tbl_h
#define uses_tbl_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#define USES_LOCAL_FIELD       1
#define USES_REMOTE_FIELD      2
#define USES_STATUS_FIELD      3

//--------------------------- PUBLIC STRUCTS --------------------------------

   // Entries in the workstation uses table
typedef struct wksta_uses_entry
           {
	   AsnObjectIdentifier Oid;
	   AsnDisplayString    useLocalName; // Index
	   AsnDisplayString    useRemote;    // Index
	   AsnInteger          useStatus;
	   } WKSTA_USES_ENTRY;

   // Workstation uses table definition
typedef struct
           {
	   UINT             Len;
	   WKSTA_USES_ENTRY *Table;
           } WKSTA_USES_TABLE;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern WKSTA_USES_TABLE MIB_WkstaUsesTable;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI MIB_wsuses_lmget(
           void
	   );

//------------------------------- END ---------------------------------------

#endif /* uses_tbl_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntagnt\eaload.h ===
#ifndef _EALOAD_H
#define _EALOAD_H

// Primary Module Parameters
//---------------------------
// "ParameterMessageFile" param flag
#define PMP_PARAMMSGFILE    0x00000001

typedef struct
{
    DWORD   dwParams;   // bitmask of PMP_* values, identifying the valid parameters in the structure
    HMODULE hModule;    // place holder for the "ParameterMessageFile" param
} tPrimaryModuleParms;

// Returns in 'Params' the requested parameters (identified by Params.dwParams field)
DWORD LoadPrimaryModuleParams(
         IN  HKEY hkLogFile,               // opened registry key to HKLM\System\CurrentControlSet\Services\EventLog\<LogFile>
         IN  LPCTSTR tchPrimModule,        // name of the PrimaryModule as it is defined in the "PrimaryModule" value of the key above
         OUT tPrimaryModuleParms &Params); // allocated output buffer, ready to receive the values for the requested parameters

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntagnt\snmptrlg.h ===
#ifndef	SNMPELTRLG_H
#define	SNMPELTRLG_H

extern	HANDLE	hWriteEvent;		// handle to write event log records

TCHAR	szTraceFileName[MAX_PATH+1] = TEXT("");	// file name for trace information (from registry)
TCHAR	szelMsgModuleName[MAX_PATH+1] = TEXT("");	// space for expanded DLL message module

BOOL	fTraceFileName = FALSE;		// flag indicating registry read for trace file name
UINT	nTraceLevel = 0x20;			// trace level for message information

HMODULE	hMsgModule;					// handle to message module
BOOL	fMsgModule = FALSE;			// flag indicating registry read for message module

#endif	// end of SNMPTRLG.H definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\errors.h ===
#ifndef _ERRORS_H
#define _ERRORS_H

#define WARN_SILENT     0
#define WARN_ERROR      1
#define WARN_ALERT      3
#define WARN_CHECKPOINT 5
#define WARN_ATTENTION  8
#define WARN_TRACK      10

DWORD _E(DWORD dwErrCode,
         DWORD dwMsgId,
         ...);

DWORD _W(DWORD dwWarnLevel,
         DWORD dwMsgId,
         ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\errors.cpp ===
#include <stdafx.h>
#include "Errors.h"
#include "EventCmd.h"

DWORD _E(DWORD dwErrCode,
         DWORD dwMsgId,
         ...)
{
    va_list arglist;
    LPSTR   pBuffer;

    gStrMessage.LoadString(dwMsgId);
    pBuffer = NULL;
    va_start(arglist, dwMsgId);
    if (FormatMessageA(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            gStrMessage,
            0,
            0,
            (LPSTR)(&pBuffer),
            1,
            &arglist))
    {
        CharToOemA(pBuffer, pBuffer);

        printf("[Err%05u] %s", dwErrCode, pBuffer);
        fflush(stdout);
        LocalFree(pBuffer);
    }
    return dwErrCode;
}

DWORD _W(DWORD dwWarnLevel,
         DWORD dwMsgId,
         ...)
{
    if (dwWarnLevel <= gCommandLine.GetVerboseLevel())
    {
        va_list arglist;
        LPSTR   pBuffer;

        gStrMessage.LoadString(dwMsgId);
        pBuffer = NULL;
        va_start(arglist, dwMsgId);
        if (FormatMessageA(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                gStrMessage,
                0,
                0,
                (LPSTR)(&pBuffer),
                1,
                &arglist))
        {
            CharToOemA(pBuffer, pBuffer);

            printf("[Wrn%02u] %s", dwWarnLevel, pBuffer);
            fflush(stdout);
            LocalFree(pBuffer);
        }
    }

    return dwWarnLevel;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\eventcmd.cpp ===
#include <stdafx.h>
#include "EventCmd.h"
#include "Errors.h"
#include "Parser.h"
#include "Registry.h"
#include "SNMPCtrl.h"

CString      gStrMessage;
CCommandLine gCommandLine;

void PrintUsage(char *szCmdName)
{
    gStrMessage.LoadString(100);
    gStrMessage.AnsiToOem();
    printf("%s", gStrMessage);
}

void PrintBanner()
{
    gStrMessage.LoadString(101);
    gStrMessage.AnsiToOem();
    printf("%s", gStrMessage);
}

void InitThreadOutputCodepage()
{
    setlocale (LC_COLLATE, ".OCP");  // sets the sort order 
    setlocale (LC_MONETARY, ".OCP"); // sets the currency formatting rules
    setlocale (LC_NUMERIC, ".OCP");  // sets the formatting of numerals
    setlocale (LC_TIME, ".OCP");     // defines the date/time formatting

    SetThreadUILanguage(0);    
}

int _cdecl main(int argc, char *argv[])
{
    int retCode;

    InitThreadOutputCodepage();
    PrintBanner();

    retCode = gCommandLine.ParseCmdLine(argc, argv);
    if (retCode != ERROR_SUCCESS)
        return retCode;
    _W(WARN_CHECKPOINT, IDS_CHKP_WRN01);

    retCode = gParser.ParseInputFile();
    if (retCode != ERROR_SUCCESS)
        return retCode;
    _W(WARN_CHECKPOINT, IDS_CHKP_WRN02, gCommandLine.m_szFileName);

    retCode = gRegistry.Connect();
    if (retCode != ERROR_SUCCESS)
        return retCode;
    _W(WARN_CHECKPOINT, IDS_CHKP_WRN03, gCommandLine.m_szSystem == NULL ? "localhost" : gCommandLine.m_szSystem);

    retCode = gParser.ProcessCommands();
    if (retCode != ERROR_SUCCESS)
        return retCode;
    _W(WARN_CHECKPOINT, IDS_CHKP_WRN04);

    if (gCommandLine.m_nFlags & CMDLINE_FLG_NORESTART)
    {
        if (gRegistry.m_dwFlags & REG_FLG_NEEDRESTART)
            _W(WARN_ALERT, IDS_ALRT_WRN05);
    }
    else
    {
        if (gRegistry.m_dwFlags & REG_FLG_NEEDRESTART)
        {
            if (!gSNMPController.IsSNMPRunning())
                _W(WARN_ATTENTION, IDS_ATTN_WRN06);

            else
            {
                _W(WARN_CHECKPOINT, IDS_CHKP_WRN07);
                retCode = gSNMPController.StopSNMP();
                if (retCode != ERROR_SUCCESS)
                    return retCode;

                _W(WARN_CHECKPOINT, IDS_CHKP_WRN08);
                retCode = gSNMPController.StartSNMP();
                if (retCode != ERROR_SUCCESS)
                    return retCode;

                _W(WARN_CHECKPOINT, IDS_CHKP_WRN09);
            }
        }
        else
            _W(WARN_ATTENTION, IDS_ATTN_WRN10);
    }

    return retCode;
}

CCommandLine::CCommandLine()
{
    m_szFileName = NULL;
    m_szSystem = NULL;
    m_nVerboseLevel = WARN_CHECKPOINT;
    m_nFlags = 0;
}

CCommandLine::~CCommandLine()
{
    if (m_szFileName)
        delete m_szFileName;
    if (m_szSystem)
        delete m_szSystem;
}

DWORD CCommandLine::ParseCmdLine(int argc, char *argv[])
{
    enum
    {
        STATE_ANY,
        STATE_ARG_VERBOSE,
        STATE_ARG_SYSTEM
    } state = STATE_ANY;

    for (int i=1; i<argc; i++)
    {
        switch(state)
        {
        case STATE_ANY:
            if (strchr(CMDLINE_DELIM,argv[i][0]) != NULL)
            {
                if (strchr(CMDLINE_OPTION_HELP, argv[i][1]) != NULL &&
                    argv[i][2] == '\0')
                {
                    PrintUsage(argv[0]);
                    return ERROR_NO_DATA;
                }
                if (strchr(CMDLINE_OPTION_VERBOSE, argv[i][1]) != NULL)
                {
                    if (argv[i][2] != '\0')
                    {
                        m_nVerboseLevel = atoi(argv[i]+2);
                        _W(WARN_ATTENTION,IDS_ATTN_WRN11, m_nVerboseLevel);
                    }
                    else
                        state = STATE_ARG_VERBOSE;
                    break;
                }
                if (strchr(CMDLINE_OPTION_SYSTEM, argv[i][1]) != NULL &&
                    argv[i][2] == '\0')
                {
                    state = STATE_ARG_SYSTEM;
                    break;
                }
                if (strchr(CMDLINE_OPTION_NORESTART, argv[i][1]) != NULL &&
                    argv[i][2] == '\0')
                {
                    m_nFlags |= CMDLINE_FLG_NORESTART;
                    break;
                }
                else
                    _W(WARN_ALERT,IDS_ALRT_WRN12, argv[i]);
            }
            else
            {
                if (m_szFileName != NULL)
                {
                    _W(WARN_ALERT,
                       IDS_ALRT_WRN13,
                       argv[i]);
                    delete m_szFileName;
                }
                m_szFileName = new char[strlen(argv[i])+1];
                if (m_szFileName == NULL)
                    return _E(ERROR_OUTOFMEMORY, IDS_ERR01);
                strcpy(m_szFileName, argv[i]);
            }
            break;
        case STATE_ARG_VERBOSE:
            m_nVerboseLevel = atoi(argv[i]);
            _W(WARN_ATTENTION,IDS_ATTN_WRN14, m_nVerboseLevel);
            state = STATE_ANY;
            break;
        case STATE_ARG_SYSTEM:
            if (m_szSystem != NULL)
            {
                _W(WARN_ALERT,
                   IDS_ALRT_WRN15,
                   argv[i]);
                delete m_szSystem;
            }
            m_szSystem = new char[strlen(argv[i])+1];
            if (m_szSystem == NULL)
                return _E(ERROR_OUTOFMEMORY, IDS_ERR01);
            strcpy(m_szSystem, argv[i]);
            state = STATE_ANY;
            break;
        }
    }

    if (m_szFileName == NULL)
    {
        PrintUsage(argv[0]);
        return ERROR_NO_DATA;
    }

    return ERROR_SUCCESS;
}

DWORD CCommandLine::GetVerboseLevel()
{
    return m_nVerboseLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpelep.h ===
#ifndef SNMPELEA_P_H
#define SNMPELEA_P_H

	// prototype definitions for all log message functions

extern VOID WriteLog(NTSTATUS);
extern VOID WriteLog(NTSTATUS, DWORD);
extern VOID WriteLog(NTSTATUS, DWORD, DWORD);
extern VOID WriteLog(NTSTATUS, LPTSTR, DWORD, DWORD);
extern VOID WriteLog(NTSTATUS, DWORD, LPTSTR, LPTSTR, DWORD);
extern VOID WriteLog(NTSTATUS, DWORD, LPTSTR, DWORD, DWORD);
extern VOID WriteLog(NTSTATUS, LPTSTR, DWORD);
extern VOID WriteLog(NTSTATUS, LPTSTR);
extern VOID WriteLog(NTSTATUS, LPCTSTR, LPCTSTR);

// macros wrappers to use strcat safely
#define WRAP_STRCAT_A(pszDest, pszSrc, cbDest) \
    do\
        {\
        fOk = (strlen((pszDest))+strlen((pszSrc))+1) <= (cbDest);\
        if (!fOk) { goto Error; }\
        else { strcat((pszDest), (pszSrc)); }\
        }\
    while (FALSE)

#define WRAP_STRCAT_A_2(pszDest, pszSrc, cbDest) \
    do\
        {\
        fOk = (strlen((pszDest))+strlen((pszSrc))+1) <= (cbDest);\
        if (!fOk) { return (FALSE); }\
        else { strcat((pszDest), (pszSrc)); }\
        }\
    while (FALSE)

#endif						// end of snmpelep.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntagnt\snmptrlg.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    SNMPTRLG.CPP


Abstract:

    This module is the tracing and logging routines for the SNMP Event Log
    Extension Agent DLL.

Author:

    Randy G. Braze (Braze Computing Services) Created 7 February 1996


Revision History:


--*/

extern "C" {

#include <windows.h>        // windows definitions
#include <stdio.h>          // standard I/O functions
#include <stdlib.h>         // standard library definitions
#include <stdarg.h>         // variable length arguments stuff
#include <string.h>         // string declarations
#include <time.h>           // time declarations

#include <snmp.h>           // snmp definitions
#include "snmpelea.h"       // global dll definitions
#include "snmptrlg.h"       // module specific definitions
#include "snmpelmg.h"       // message definitions

}


VOID
TraceWrite(
    IN CONST BOOL  fDoFormat,   // flag for message formatting
    IN CONST BOOL  fDoTime,     // flag for date/time prefixing
    IN CONST LPSTR szFormat,    // trace message to write
    IN OPTIONAL ...             // other printf type operands
    )

/*++

Routine Description:

    TraceWrite will write information provided to the trace file. Optionally,
    it will prepend the date and timestamp to the information. If requested,
    printf type arguments can be passed and they will be substituted just as
    printf builds the message text. Sometimes this routine is called from
    WriteTrace and sometimes it is called from other functions that need to
    generate a trace file record. When called from WriteTrace, no formatting
    is done on the buffer (WriteTrace has already performed the required
    formatting). When called from other functions, the message text may or
    may not require formatting, as specified by the calling function.


Arguments:

    fDoFormat   -   TRUE or FALSE, indicating if the message text provided
                    requires formatting as a printf type function.

    fDoTime     -   TRUE or FALSE, indicating if the date/timestamp should be
                    added to the beginning of the message text.

    szFormat    -   NULL terminated string containing the message text to be
                    written to the trace file. If fDoFormat is true, then this
                    text will be in the format of a printf statement and will
                    contain substitution parameters strings and variable names
                    to be substituted will follow.

    ...         -   Optional parameters that are used to complete the printf
                    type statement. These are variables that are substituted
                    for strings specified in szFormat. These parameters will
                    only be specified and processed if fDoFormat is TRUE.


Return Value:

    None
    

--*/

{
    static CHAR  szBuffer[LOG_BUF_SIZE];
    static FILE  *FFile;
    static SYSTEMTIME NowTime;
    va_list arglist;

    // don't even attempt to open the trace file if
    // the name is ""
    if (szTraceFileName[0] == TEXT('\0'))
        return;

    FFile = fopen(szTraceFileName,"a");     // open trace file in append mode
    if ( FFile != NULL )                    // if file opened okay
    {
        if ( fDoTime )                      // are we adding time?
        {
            GetLocalTime(&NowTime);         // yep, get it
            fprintf(FFile, "%02i/%02i/%02i %02i:%02i:%02i ",
                NowTime.wMonth,
                NowTime.wDay,
                NowTime.wYear,
                NowTime.wHour,
                NowTime.wMinute,
                NowTime.wSecond);           // file printf to add date/time
        }

        if ( fDoFormat )                    // if we need to format the buffer
        {
          szBuffer[LOG_BUF_SIZE-1] = 0;
          va_start(arglist, szFormat);
          _vsnprintf(szBuffer, LOG_BUF_SIZE-1, szFormat, arglist);  // perform substitution
          va_end(arglist);
          fwrite(szBuffer, strlen(szBuffer), 1, FFile);           // write data to the trace file
        }
        else                                // if no formatting required
        {
            fwrite(szFormat, strlen(szFormat), 1, FFile);   // write message to the trace file
        }

        fflush(FFile);                      // flush buffers first
        fclose(FFile);                      // close the trace file
    }
}                                           // end TraceWrite function


VOID LoadMsgDLL(
    IN VOID
    )

/*++

Routine Description:

    LoadMsgDLL is called to load the SNMPELMG.DLL module which contains the
    message and format information for all messages in the SNMP extension agent DLL.
    It is necessary to call this routine only in the event that an event log
    record cannot be written. If this situation occurs, then the DLL will be
    loaded in an attempt to call FormatMessage and write this same information
    to the trace file. This routine is called only once and only if the
    event log write fails.


Arguments:

    None


Return Value:

    None
    

--*/

{
    TCHAR szXMsgModuleName[MAX_PATH+1]; // space for DLL message module
    DWORD nFile = sizeof(szXMsgModuleName)-sizeof(TCHAR); // max size for DLL message module name in bytes
    DWORD dwType;                       // type of message module name
    DWORD status;                       // status from registry calls
    DWORD cbExpand;                     // byte count for REG_EXPAND_SZ parameters
    HKEY  hkResult;                     // handle to registry information

    // ensure null terminated string
    szXMsgModuleName[MAX_PATH]  = 0;     
    if ( (status = RegOpenKeyEx(        // open the registry to read the name
        HKEY_LOCAL_MACHINE,             // of the message module DLL
        EVENTLOG_SERVICE,
        0,
        KEY_READ,
        &hkResult) ) != ERROR_SUCCESS)
    {
        TraceWrite(TRUE, TRUE,          // if we can't find it
            "LoadMessageDLL: Unable to open EventLog service registry key; RegOpenKeyEx returned %lu\n",
            status);                    // write trace event record
        hMsgModule = (HMODULE) NULL;    // set handle null
        return;                         // return
    }
    else
    {
        if ( (status = RegQueryValueEx( // look up module name
            hkResult,                   // handle to registry key
            EXTENSION_MSG_MODULE,       // key to look up
            0,                          // ignored
            &dwType,                    // address to return type value
            (LPBYTE) szXMsgModuleName,  // where to return message module name
            &nFile) ) != ERROR_SUCCESS) // size of message module name field
        {
            TraceWrite(TRUE, TRUE,      // if we can't find it
                "LoadMessageDLL: Unable to open EventMessageFile registry key; RegQueryValueEx returned %lu\n",
                status);                // write trace event record
            hMsgModule = (HMODULE) NULL;    // set handle null
            RegCloseKey(hkResult);      // close the registry key
            return;                     // return
        }

        RegCloseKey(hkResult);      // close the registry key

        cbExpand = ExpandEnvironmentStrings(    // expand the DLL name
            szXMsgModuleName,                   // unexpanded DLL name
            szelMsgModuleName,                  // expanded DLL name
            MAX_PATH+1);                          // max size of expanded DLL name in TCHARs

        if (cbExpand == 0 || cbExpand > MAX_PATH+1)       // if it didn't expand correctly
        {
            TraceWrite(TRUE, TRUE,      // didn't have enough space
                "LoadMessageDLL: Unable to expand message module %s; expanded size required is %lu bytes\n",
                szXMsgModuleName, cbExpand);    // log error message
            hMsgModule = (HMODULE) NULL;    // set handle null
            return;                         // and exit
        }

        if ( (hMsgModule = (HMODULE) LoadLibraryEx(szelMsgModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE) )   // load the message module name
            == (HMODULE) NULL )         // if module didn't load
        {
            TraceWrite(TRUE, TRUE,      // can't load message dll
                "LoadMessageDLL: Unable to load message module %s; LoadLibraryEx returned %lu\n",
                szelMsgModuleName, GetLastError() );  // log error message
        }
    }

    return;                             // exit routine

}


VOID
FormatTrace(
    IN CONST NTSTATUS nMsg,         // message number to format
    IN CONST LPVOID   lpArguments   // strings to insert
    )

/*++

Routine Description:

    FormatTrace will write the message text specified by nMsg to the trace
    file. If supplied, the substitution arguments supplied by lpArguments
    will be inserted in the message. FormatMessage is called to format the
    message text and insert the substitution arguments into the text. The
    text of the message is loaded from the SNMPELMG.DLL message module as
    specified in the Eventlog\Application\Snmpelea registry entry under the key of
    EventMessageFile. This information is read, the file name is expanded and
    the message module is loaded. If the message cannot be formatted, then
    a record is written to the trace file indicating the problem.


Arguments:

    nMsg        -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be written.

    lpArguments -   This is a pointer to an array of strings that will be
                    substituted in the message text specified. If this value
                    is NULL, there are no substitution values to insert.


Return Value:

    None
    

--*/

{
    static DWORD nBytes;            // return value from FormatMessage
    static LPTSTR lpBuffer = NULL;  // temporary message buffer

    if ( !fMsgModule ) {            // if we don't have dll loaded yet
        fMsgModule = TRUE;          // indicate we've looked now
        LoadMsgDLL();               // load the DLL
    }

    if ( hMsgModule ) {

        nBytes = FormatMessage(     // see if we can format the message
            FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
            FORMAT_MESSAGE_ARGUMENT_ARRAY |     // indicate an array of string inserts
            FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
            (LPVOID) hMsgModule,                // handle to message module
            nMsg,                               // message number to get
            (ULONG) NULL,                       // specify no language
            (LPTSTR) &lpBuffer,                 // address for buffer pointer
            80,                                 // minimum space to allocate
            (va_list* )lpArguments);            // address of array of pointers

        if (nBytes == 0) {              // format is not okay
            TraceWrite(TRUE, TRUE,
                "FormatTrace: Error formatting message number %08X is %lu\n",
                nMsg, GetLastError() ); // trace the problem
        }
        else {                          // format is okay
            TraceWrite(FALSE, TRUE, lpBuffer);       // log the message in the trace file
        }

		// LocalFree ignores NULL parameter
		if ( LocalFree(lpBuffer) != NULL ) {    // free buffer storage
			TraceWrite(TRUE, TRUE,
                    "FormatTrace: Error freeing FormatMessage buffer is %lu\n",
                    GetLastError() );
		}
        lpBuffer = NULL;

    }
    else {
        TraceWrite(TRUE, TRUE,
            "FormatTrace: Unable to format message number %08X; message DLL handle is null.\n",
            nMsg); // trace the problem
    }

    return;                         // exit routine
}


USHORT
MessageType(
    IN CONST NTSTATUS nMsg
    )

/*++

Routine Description:

    MessageType is used to return the severity type of an NTSTATUS formatted
    message number. This information is needed to log the appropriate event
    log information when writing a record to the system event log. Acceptable
    message types are defined in NTELFAPI.H.


Arguments:

    nMsg        -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be analyzed.


Return Value:

    Unsigned short integer containing the message severity as described in
    NTELFAPI.H. If no message type is matched, the default of informational
    is returned.

--*/

{
    switch ((ULONG) nMsg >> 30) {           // get message type
    case (SNMPELEA_SUCCESS) :
        return(EVENTLOG_SUCCESS);           // success message

    case (SNMPELEA_INFORMATIONAL) :
        return(EVENTLOG_INFORMATION_TYPE);  // informational message

    case (SNMPELEA_WARNING) :
        return(EVENTLOG_WARNING_TYPE);      // warning message

    case (SNMPELEA_ERROR) :
        return(EVENTLOG_ERROR_TYPE);        // error message

    default:
        return(EVENTLOG_INFORMATION_TYPE);  // default to informational
    }
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber
    )

/*++

Routine Description:

    WriteLog is called to write message text to the system event log. This is
    a C++ overloaded function. In case a log record cannot be written
    to the system event log, TraceWrite is called to write the appropriate
    message text to the trace file.


Arguments:

    nMsgNumber  -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be written to the event log.


Return Value:

    None

--*/

{
    static USHORT wLogType;         // to hold event log type
    static BOOL   fReportEvent;     // return flag from report event

    if (hWriteEvent != NULL)        // if we have previous log access ability
    {
        wLogType = MessageType(nMsgNumber); // get message type

        fReportEvent = ReportEvent( // write message
            hWriteEvent,            // handle to log file
            wLogType,               // message type
            0,                      // message category
            nMsgNumber,             // message number
            NULL,                   // user sid
            0,                      // number of strings
            0,                      // data length
            0,                      // pointer to string array
            (PVOID) NULL);          // data address

        if ( !fReportEvent )        // did the event log okay?
        {                           // not if we get here.....
            TraceWrite(TRUE, TRUE,  // show error in trace file
                "WriteLog: Error writing to system event log is %lu\n",
                GetLastError() );
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    else                            // if we can't write to event log
    {
        TraceWrite(FALSE, TRUE,     // show error in trace file
            "WriteLog: Unable to write to system event log; handle is null\n");
        FormatTrace(nMsgNumber, NULL);  // format trace information
    }
    return;                         // exit the function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,           // message number to log
    IN DWORD dwCode                   // code to pass to message
    )

/*++

Routine Description:

    WriteLog is called to write message text to the system event log. This is
    a C++ overloaded function. In case a log record cannot be written
    to the system event log, TraceWrite is called to write the appropriate
    message text to the trace file.


Arguments:

    nMsgNumber  -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be written to the event log.

    dwCode      -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.


Return Value:

    None

--*/

{
    static USHORT wLogType;             // to hold event log type
    static TCHAR  *lpszEventString[1];  // array of strings to pass to event logger
    static BOOL   fReportEvent;         // return flag from report event

    lpszEventString[0] = new TCHAR[34]; // allocate space for string conversion

    if (hWriteEvent != NULL)            // if we have previous log access ability
    {
        if ( lpszEventString[0] != (TCHAR *) NULL ) // if storage allocated
        {
            wLogType = MessageType(nMsgNumber);     // get message type

            _ultoa(dwCode, lpszEventString[0], 10); // convert to string

            fReportEvent = ReportEvent( // write message
                hWriteEvent,            // handle to log file
                wLogType,               // message type
                0,                      // message category
                nMsgNumber,             // message number
                NULL,                   // user sid
                1,                      // number of strings
                0,                      // data length
                (const char **) lpszEventString,        // pointer to string array
                NULL);                  // data address

            if ( !fReportEvent )        // did the event log okay?
            {                           // not if we get here.....
                TraceWrite(TRUE, TRUE,  // write trace file record
                    "WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);   // format trace information
            }
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace file record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    else                                // if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,         // write trace file record
            "WriteLog: Unable to write to system event log; handle is null\n");

        if ( lpszEventString[0] != (TCHAR *) NULL ) // if storage allocated
        {
            _ultoa(dwCode, lpszEventString[0], 10); // convert to string
            FormatTrace(nMsgNumber, lpszEventString);   // format trace information
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace file record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    delete [] lpszEventString[0];          // free storage
    return;                             // exit function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN DWORD dwCode1,
    IN DWORD dwCode2
    )

/*++

Routine Description:

    WriteLog is called to write message text to the system event log. This is
    a C++ overloaded function. In case a log record cannot be written
    to the system event log, TraceWrite is called to write the appropriate
    message text to the trace file.


Arguments:

    nMsgNumber  -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be written to the event log.

    dwCode1     -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.

    dwCode2     -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.


Return Value:

    None

--*/

{
    static USHORT wLogType;             // to hold event log type
    static TCHAR  *lpszEventString[2];  // array of strings to pass to event logger
    static BOOL   fReportEvent;         // return flag from report event

    lpszEventString[0] = new TCHAR[34]; // allocate space for string conversion
    lpszEventString[1] = new TCHAR[34]; // allocate space for string conversion

    if (hWriteEvent != NULL)            // if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) )   // if storage allocated
        {
            wLogType = MessageType(nMsgNumber); // get message type

            _ultoa(dwCode1, lpszEventString[0], 10);    // convert to string
            _ultoa(dwCode2, lpszEventString[1], 10);    // convert to string

            fReportEvent = ReportEvent( // write message
                hWriteEvent,            // handle to log file
                wLogType,               // message type
                0,                      // message category
                nMsgNumber,             // message number
                NULL,                   // user sid
                2,                      // number of strings
                0,                      // data length
                (const char **) lpszEventString,        // pointer to string array
                NULL);                  // data address

            if ( !fReportEvent )        // did the event log okay?
            {                           // not if we get here.....
                TraceWrite(TRUE, TRUE,  // write a trace file entry
                    "WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);   // format trace information
            }
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace file record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    else                                // if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,         // write trace file entry
            "WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) )   // if storage allocated
        {
            _ultoa(dwCode1, lpszEventString[0], 10);    // convert to string
            _ultoa(dwCode2, lpszEventString[1], 10);    // convert to string
            FormatTrace(nMsgNumber, lpszEventString);   // format trace information
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace file record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    delete [] lpszEventString[0];          // free storage
    delete [] lpszEventString[1];          // free storage
    return;                             // exit function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN DWORD dwCode1,
    IN LPTSTR lpszText1,
    IN LPTSTR lpszText2,
    IN DWORD dwCode2
    )

/*++

Routine Description:

    WriteLog is called to write message text to the system event log. This is
    a C++ overloaded function. In case a log record cannot be written
    to the system event log, TraceWrite is called to write the appropriate
    message text to the trace file.


Arguments:

    nMsgNumber  -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be written to the event log.

    dwCode1     -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.

    lpszText1   -   This contains a string parameter that is to be substituted
                    into the message text.

    lpszText2   -   This contains a string parameter that is to be substituted
                    into the message text.

    dwCode2     -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.


Return Value:

    None

--*/

{
    static USHORT wLogType;             // to hold event log type
    static TCHAR  *lpszEventString[4];  // array of strings to pass to event logger
    static BOOL   fReportEvent;         // return flag from report event

    lpszEventString[0] = new TCHAR[34]; // allocate space for string conversion
    lpszEventString[1] = new TCHAR[MAX_PATH+1]; // allocate space for string conversion
    lpszEventString[2] = new TCHAR[MAX_PATH+1]; // allocate space for string conversion
    lpszEventString[3] = new TCHAR[34]; // allocate space for string conversion

    if (hWriteEvent != NULL)            // if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) &&
             (lpszEventString[3] != (TCHAR *) NULL) )   // if storage allocated
        {
            // ensures null terminated strings
            lpszEventString[1][MAX_PATH] = 0;
            lpszEventString[2][MAX_PATH] = 0;

            wLogType = MessageType(nMsgNumber);         // get message type

            _ultoa(dwCode1, lpszEventString[0], 10);    // convert to string
            strncpy(lpszEventString[1],lpszText1,MAX_PATH); // copy the string
            strncpy(lpszEventString[2],lpszText2,MAX_PATH); // copy the string
            _ultoa(dwCode2, lpszEventString[3], 10);    // convert to string

            fReportEvent = ReportEvent( // write message
                hWriteEvent,            // handle to log file
                wLogType,               // message type
                0,                      // message category
                nMsgNumber,             // message number
                NULL,                   // user sid
                4,                      // number of strings
                0,                      // data length
                (const char **) lpszEventString,        // pointer to string array
                NULL);                  // data address

            if ( !fReportEvent )        // did the event log okay?
            {                           // not if we get here.....
                TraceWrite(TRUE, TRUE,  // write trace file record
                    "WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);   // format trace information
            }
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace file record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    else                                // if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,         // write trace file record
            "WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) &&
             (lpszEventString[3] != (TCHAR *) NULL) )   // if storage allocated
        {
            // ensures null terminated strings
            lpszEventString[1][MAX_PATH] = 0;
            lpszEventString[2][MAX_PATH] = 0;

            _ultoa(dwCode1, lpszEventString[0], 10);    // convert to string
            strncpy(lpszEventString[1],lpszText1,MAX_PATH); // copy the string
            strncpy(lpszEventString[2],lpszText2,MAX_PATH); // copy the string
            _ultoa(dwCode2, lpszEventString[3], 10);    // convert to string
            FormatTrace(nMsgNumber, lpszEventString);   // format trace information
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace file record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    delete [] lpszEventString[0];          // free storage
    delete [] lpszEventString[1];          // free storage
    delete [] lpszEventString[2];          // free storage
    delete [] lpszEventString[3];          // free storage
    return;                             // exit function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN DWORD dwCode1,
    IN LPTSTR lpszText,
    IN DWORD dwCode2,
    IN DWORD dwCode3
    )

/*++

Routine Description:

    WriteLog is called to write message text to the system event log. This is
    a C++ overloaded function. In case a log record cannot be written
    to the system event log, TraceWrite is called to write the appropriate
    message text to the trace file.


Arguments:

    nMsgNumber  -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be written to the event log.

    dwCode1     -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.

    lpszText    -   This contains a string parameter that is to be substituted
                    into the message text.

    dwCode2     -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.

    dwCode3     -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.


Return Value:

    None

--*/

{
    static USHORT wLogType;             // to hold event log type
    static TCHAR  *lpszEventString[4];  // array of strings to pass to event logger
    static BOOL   fReportEvent;         // return flag from report event

    lpszEventString[0] = new TCHAR[34]; // allocate space for string conversion
    lpszEventString[1] = new TCHAR[MAX_PATH+1]; // allocate space for string conversion
    lpszEventString[2] = new TCHAR[34]; // allocate space for string conversion
    lpszEventString[3] = new TCHAR[34]; // allocate space for string conversion

    if (hWriteEvent != NULL)            // if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) &&
             (lpszEventString[3] != (TCHAR *) NULL) )   // if storage allocated
        {
            lpszEventString[1][MAX_PATH] = 0;   // ensures null terminated string
            wLogType = MessageType(nMsgNumber); // get message type

            _ultoa(dwCode1, lpszEventString[0], 10);    // convert to string
            strncpy(lpszEventString[1],lpszText,MAX_PATH);  // copy the string
            _ultoa(dwCode2, lpszEventString[2], 10);    // convert to string
            _ultoa(dwCode3, lpszEventString[3], 10);    // convert to string

            fReportEvent = ReportEvent( // write message
                hWriteEvent,            // handle to log file
                wLogType,               // message type
                0,                      // message category
                nMsgNumber,             // message number
                NULL,                   // user sid
                4,                      // number of strings
                0,                      // data length
                (const char **) lpszEventString,        // pointer to string array
                NULL);                  // data address

            if ( !fReportEvent )        // did the event log okay?
            {                           // not if we get here.....
                TraceWrite(TRUE, TRUE,  // write trace file record
                    "WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);   // format trace information
            }
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace file record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    else                                // if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,         // write trace file record
            "WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) &&
             (lpszEventString[3] != (TCHAR *) NULL) )   // if storage allocated
        {
            lpszEventString[1][MAX_PATH] = 0;   // ensures null terminated string

            _ultoa(dwCode1, lpszEventString[0], 10);    // convert to string
            strncpy(lpszEventString[1],lpszText,MAX_PATH);  // copy the string
            _ultoa(dwCode2, lpszEventString[2], 10);    // convert to string
            _ultoa(dwCode3, lpszEventString[3], 10);    // convert to string
            FormatTrace(nMsgNumber, lpszEventString);   // format trace information
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace file record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    delete [] lpszEventString[0];          // free storage
    delete [] lpszEventString[1];          // free storage
    delete [] lpszEventString[2];          // free storage
    delete [] lpszEventString[3];          // free storage
    return;                             // exit the function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN LPTSTR lpszText,
    IN DWORD dwCode1,
    IN DWORD dwCode2
    )

/*++

Routine Description:

    WriteLog is called to write message text to the system event log. This is
    a C++ overloaded function. In case a log record cannot be written
    to the system event log, TraceWrite is called to write the appropriate
    message text to the trace file.


Arguments:

    nMsgNumber  -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be written to the event log.

    lpszText    -   This contains a string parameter that is to be substituted
                    into the message text.

    dwCode1     -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.

    dwCode2     -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.


Return Value:

    None

--*/

{
    static USHORT wLogType;             // to hold event log type
    static TCHAR  *lpszEventString[3];  // array of strings to pass to event logger
    static BOOL   fReportEvent;         // return flag from report event

    lpszEventString[0] = new TCHAR[MAX_PATH+1]; // allocate space for string conversion
    lpszEventString[1] = new TCHAR[34]; // allocate space for string conversion
    lpszEventString[2] = new TCHAR[34]; // allocate space for string conversion

    if (hWriteEvent != NULL)            // if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) )   // if storage allocated
        {
            lpszEventString[0][MAX_PATH] = 0; // ensures null terminated string
            wLogType = MessageType(nMsgNumber); // get message type

            strncpy(lpszEventString[0],lpszText,MAX_PATH);  // copy the string
            _ultoa(dwCode1, lpszEventString[1], 10);    // convert to string
            _ultoa(dwCode2, lpszEventString[2], 10);    // convert to string

            fReportEvent = ReportEvent( // write message
                hWriteEvent,            // handle to log file
                wLogType,               // message type
                0,                      // message category
                nMsgNumber,             // message number
                NULL,                   // user sid
                3,                      // number of strings
                0,                      // data length
                (const char **) lpszEventString,        // pointer to string array
                NULL);                  // data address

            if ( !fReportEvent )        // did the event log okay?
            {                           // not if we get here.....
                TraceWrite(TRUE, TRUE,  // write trace file record
                    "WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);   // format trace information
            }
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace file record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    else                                // if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,         // write trace file record
            "WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) &&
             (lpszEventString[2] != (TCHAR *) NULL) )   // if storage allocated
        {
            lpszEventString[0][MAX_PATH] = 0; // ensures null terminated string

            strncpy(lpszEventString[0],lpszText,MAX_PATH);      // copy the string
            _ultoa(dwCode1, lpszEventString[1], 10);    // convert to string
            _ultoa(dwCode2, lpszEventString[2], 10);    // convert to string
            FormatTrace(nMsgNumber, lpszEventString);   // format trace information
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace file record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    delete [] lpszEventString[0];          // free storage
    delete [] lpszEventString[1];          // free storage
    delete [] lpszEventString[2];          // free storage
    return;                             // exit the function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN LPTSTR lpszText,
    IN DWORD dwCode
    )

/*++

Routine Description:

    WriteLog is called to write message text to the system event log. This is
    a C++ overloaded function. In case a log record cannot be written
    to the system event log, TraceWrite is called to write the appropriate
    message text to the trace file.


Arguments:

    nMsgNumber  -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be written to the event log.

    lpszText    -   This contains a string parameter that is to be substituted
                    into the message text.

    dwCode      -   This is a double word code that is to be converted to a
                    string and substituted appropriately in the message text.


Return Value:

    None

--*/

{
    static USHORT wLogType;             // to hold event log type
    static TCHAR  *lpszEventString[2];  // array of strings to pass to event logger
    static BOOL   fReportEvent;         // return flag from report event

    lpszEventString[0] = new TCHAR[MAX_PATH+1]; // allocate space for string conversion
    lpszEventString[1] = new TCHAR[34]; // allocate space for string conversion

    if (hWriteEvent != NULL)            // if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) )   // if storage allocated
        {
            lpszEventString[0][MAX_PATH] = 0; // ensures null terminated string
            wLogType = MessageType(nMsgNumber);     // get message type

            strncpy(lpszEventString[0],lpszText,MAX_PATH);  // copy the string
            _ultoa(dwCode, lpszEventString[1], 10); // convert to string

            fReportEvent = ReportEvent( // write message
                hWriteEvent,            // handle to log file
                wLogType,               // message type
                0,                      // message category
                nMsgNumber,             // message number
                NULL,                   // user sid
                2,                      // number of strings
                0,                      // data length
                (const char **) lpszEventString,        // pointer to string array
                NULL);                  // data address

            if ( !fReportEvent )        // did the event log okay?
            {                           // not if we get here.....
                TraceWrite(TRUE, TRUE,  // write trace record
                    "WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);   // format trace information
            }
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    else                                // if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,         // write trace record
            "WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&
             (lpszEventString[1] != (TCHAR *) NULL) )   // if storage allocated
        {
            lpszEventString[0][MAX_PATH] = 0; // ensures null terminated string

            strncpy(lpszEventString[0],lpszText,MAX_PATH);  // copy the string
            _ultoa(dwCode, lpszEventString[1], 10);     // convert to string
            FormatTrace(nMsgNumber, lpszEventString);   // format trace information
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    delete [] lpszEventString[0];          // free storage
    delete [] lpszEventString[1];          // free storage
    return;                             // exit function
}


VOID
WriteLog(
    IN NTSTATUS nMsgNumber,
    IN LPTSTR lpszText
    )

/*++

Routine Description:

    WriteLog is called to write message text to the system event log. This is
    a C++ overloaded function. In case a log record cannot be written
    to the system event log, TraceWrite is called to write the appropriate
    message text to the trace file.


Arguments:

    nMsgNumber  -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be written to the event log.

    lpszText    -   This contains a string parameter that is to be substituted
                    into the message text.


Return Value:

    None

--*/

{
    static USHORT wLogType;             // to hold event log type
    static TCHAR  *lpszEventString[1];  // array of strings to pass to event logger
    static BOOL   fReportEvent;         // return flag from report event

    lpszEventString[0] = new TCHAR[MAX_PATH+1]; // allocate space for string conversion

    if (hWriteEvent != NULL)            // if we have previous log access ability
    {
        if ( lpszEventString[0] != (TCHAR *) NULL ) // if storage allocated
        {
            lpszEventString[0][MAX_PATH] = 0; // ensures null terminated string
            wLogType = MessageType(nMsgNumber);     // get message type

            strncpy(lpszEventString[0],lpszText,MAX_PATH);  // copy the string

            fReportEvent = ReportEvent( // write message
                hWriteEvent,            // handle to log file
                wLogType,               // message type
                0,                      // message category
                nMsgNumber,             // message number
                NULL,                   // user sid
                1,                      // number of strings
                0,                      // data length
                (const char **) lpszEventString,        // pointer to string array
                NULL);                  // data address

            if ( !fReportEvent )        // did the event log okay?
            {                           // not if we get here.....
                TraceWrite(TRUE, TRUE,  // write trace file record
                    "WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);   // format trace information
            }
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    else                                // if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,         // write trace record
            "WriteLog: Unable to write to system event log; handle is null\n");

        if ( lpszEventString[0] != (TCHAR *) NULL ) // if storage allocated
        {
            lpszEventString[0][MAX_PATH] = 0; // ensures null terminated string

            strncpy(lpszEventString[0],lpszText,MAX_PATH);  // copy the string
            FormatTrace(nMsgNumber, lpszEventString);   // format trace information
        }
        else
        {
            TraceWrite(FALSE, TRUE,     // write trace record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    delete [] lpszEventString[0];          // free storage
    return;                             // exit function
}


VOID
WriteLog(
    IN  NTSTATUS    nMsgNumber,
    IN  LPCTSTR     lpszText1,
    IN  LPCTSTR     lpszText2
    )

/*++

Routine Description:

    WriteLog is called to write message text to the system event log. This is
    a C++ overloaded function. In case a log record cannot be written
    to the system event log, TraceWrite is called to write the appropriate
    message text to the trace file.


Arguments:

    nMsgNumber  -   This is the message number in SNMPELMG.H in NTSTATUS format
                    that is to be written to the event log.

    lpszText    -   This contains a string parameter that is to be substituted
                    into the message text.


Return Value:

    None

--*/

{
    static USHORT wLogType;             // to hold event log type
    static TCHAR  *lpszEventString[2];  // array of strings to pass to event logger
    static BOOL   fReportEvent;         // return flag from report event

    lpszEventString[0] = new TCHAR[MAX_PATH+1]; // allocate space for string conversion
    lpszEventString[1] = new TCHAR[MAX_PATH+1]; // allocate space for string conversion

    if (hWriteEvent != NULL)            // if we have previous log access ability
    {
        if ( (lpszEventString[0] != (TCHAR *) NULL ) &&
             (lpszEventString[1] != (TCHAR *) NULL ) )  // if storage allocated
        {
            // ensures null terminated strings
            lpszEventString[0][MAX_PATH] = 0;
            lpszEventString[1][MAX_PATH] = 0;
            wLogType = MessageType(nMsgNumber);     // get message type

            strncpy(lpszEventString[0],lpszText1,MAX_PATH); // copy the string
            strncpy(lpszEventString[1],lpszText2,MAX_PATH); // copy the string

            fReportEvent = ReportEvent( // write message
                hWriteEvent,            // handle to log file
                wLogType,               // message type
                0,                      // message category
                nMsgNumber,             // message number
                NULL,                   // user sid
                2,                      // number of strings
                0,                      // data length
                (const char **) lpszEventString,        // pointer to string array
                NULL);                  // data address

            if ( !fReportEvent )        // did the event log okay?
            {                           // not if we get here.....
                TraceWrite(TRUE, TRUE,  // write trace file record
                    "WriteLog: Error writing to system event log is %lu\n",
                    GetLastError() );
                FormatTrace(nMsgNumber, lpszEventString);   // format trace information
            }
        }
        else                            // if we can't allocate memory
        {
            TraceWrite(FALSE, TRUE,     // write trace record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    else                                // if we can't write to system log
    {
        TraceWrite(FALSE, TRUE,         // write trace record
            "WriteLog: Unable to write to system event log; handle is null\n");

        if ( (lpszEventString[0] != (TCHAR *) NULL) &&  // if storage allocated
             (lpszEventString[1] != (TCHAR *) NULL ) )
        {
            // ensures null terminated strings
            lpszEventString[0][MAX_PATH] = 0;
            lpszEventString[1][MAX_PATH] = 0;

            strncpy(lpszEventString[0],lpszText1,MAX_PATH); // copy the string
            strncpy(lpszEventString[1],lpszText2,MAX_PATH); // copy the string
            FormatTrace(nMsgNumber, lpszEventString);   // format trace information
        }
        else
        {
            TraceWrite(FALSE, TRUE,     // write trace record
                "WriteLog: Error allocating memory for system event log write\n");
            FormatTrace(nMsgNumber, NULL);  // format trace information
        }
    }
    delete [] lpszEventString[0];          // free storage
    delete [] lpszEventString[1];          // free storage
    return;                             // exit function
}


extern "C" {
VOID
WriteTrace(
    IN CONST UINT  nLevel,           // level of trace message
    IN CONST LPSTR szFormat,         // trace message to write
    IN ...                           // other printf type operands
    )

/*++

Routine Description:

    WriteTrace is called to write the requested trace information to the trace
    file specified in the configuration registry. The key to the trace file
    name is \SOFTWARE\Microsoft\SNMP_EVENTS\EventLog\Parameters\TraceFile.
    The registry information is only read for the first time WriteTrace is called.

    The TraceLevel parameter is also used to determine if the level of this
    message is part of a group of messages being traced. If the level of this
    message is greater than or equal the TraceLevel parameter, then this
    message will be sent to the file, otherwise the message is ignored.


Arguments:

    nLevel      -   This is the trace level of the message being logged.

    szFormat    -   This is the string text of the message to write to the
                    trace file. This string is in the format of printf strings
                    and will be formatted accordingly.


Return Value:

    None

--*/

{

    static  CHAR    szBuffer[LOG_BUF_SIZE];
    static  TCHAR   szFile[MAX_PATH+1];
    static  DWORD   nFile = sizeof(szFile)-sizeof(TCHAR); // size in bytes for RegQueryValueEx
    static  DWORD   dwLevel;
    static  DWORD   dwType;
    static  DWORD   nLvl = sizeof(DWORD);
    static  DWORD   status;
    static  HKEY    hkResult;
    static  DWORD   cbExpand;
            va_list arglist;


    if ( !fTraceFileName )           // if we haven't yet read registry
    {
        szFile[MAX_PATH] = 0;
        fTraceFileName = TRUE;       // set flag to not open registry info again
        if ( (status = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            EXTENSION_PARM,
            0,
            KEY_READ,
            &hkResult) ) != ERROR_SUCCESS)
        {
            WriteLog(SNMPELEA_NO_REGISTRY_PARAMETERS,status);    // write log/trace event record
        }
        else
        {
            if ( (status = RegQueryValueEx(         // look up trace file name
                hkResult,
                EXTENSION_TRACE_FILE,
                0,
                &dwType,
                (LPBYTE) szFile,
                &nFile) ) == ERROR_SUCCESS)
            {
                if (dwType != REG_SZ)       // we have a bad value.
                {
                    WriteLog(SNMPELEA_REGISTRY_TRACE_FILE_PARAMETER_TYPE, szTraceFileName);  // write log/trace event record
                }
                else
                    strncpy(szTraceFileName, szFile,MAX_PATH);
            }
            else
            {
                WriteLog(SNMPELEA_NO_REGISTRY_TRACE_FILE_PARAMETER,szTraceFileName);  // write log/trace event record
            }

            if ( (status = RegQueryValueEx(         // look up trace level
                hkResult,
                EXTENSION_TRACE_LEVEL,
                0,
                &dwType,
                (LPBYTE) &dwLevel,
                &nLvl) ) == ERROR_SUCCESS)
            {
                if (dwType == REG_DWORD)
                    nTraceLevel = dwLevel;  // copy registry trace level
                else
                    WriteLog(SNMPELEA_REGISTRY_TRACE_LEVEL_PARAMETER_TYPE, nTraceLevel);  // write log/trace event record
            }
            else
            {
                WriteLog(SNMPELEA_NO_REGISTRY_TRACE_LEVEL_PARAMETER,nTraceLevel); // write log/trace event record
            }

            status = RegCloseKey(hkResult);

        } // end else registry lookup successful

    } // end Trace information registry processing

    // return if we are not supposed to trace this message
    if ( nLevel < nTraceLevel )      // are we tracing this message
    {
        return;                      // nope, just exit
    }

    // if the value could not be read from the registry (we still have the default value)
    // then we have no file name, so return.
    if (szTraceFileName[0] == TEXT('\0'))
        return;

   szBuffer[LOG_BUF_SIZE-1] = 0;
   va_start(arglist, szFormat);
   _vsnprintf(szBuffer, LOG_BUF_SIZE-1, szFormat, arglist);
   va_end(arglist);

   if (nLevel == MAXDWORD)
    {
        TraceWrite(FALSE, FALSE, szBuffer);
    }
    else
    {
        TraceWrite(FALSE, TRUE, szBuffer);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpelpt.h ===
#ifndef SNMPELPT_H
#define SNMPELPT_H

extern  PVarBindQueue       lpVarBindQueue;                     // pointer to varbind queue
extern  PSourceHandleList   lpSourceHandleList;                     // pointer to source/handle list
extern  DWORD               dwTimeZero;                         // time zero reference
extern  BOOL                fTrimFlag;                          // trimming flag
extern  PHANDLE             phEventLogs;                        // Opened Event Log Handles
extern  PHMODULE            phPrimHandles;                      // PrimaryModule file handle array
extern  UINT                uNumEventLogs;                      // Number of Opened Event Logs
extern  LPTSTR              lpszEventLogs;                      // event log name array
extern  DWORD               nTraceLevel;                        // current trace level

extern  INT                 iLogNameSize;                       // size of event log name array
extern  UINT                nMaxTrapSize;                       // maximum size of trap

extern  VOID                WriteTrace(UINT nLvl, LPSTR CONST szStuff, ...);

extern  HANDLE              hWriteEvent;                        // handle to write log events
extern  HANDLE              hStopAll;                           // handle to global dll shutdown event
extern  HANDLE              hEventNotify;                       // handle to notify dll that trap is ready
extern  HANDLE              hRegChanged;                        // handle to registry key changed event
extern  TCHAR               szBaseOID[MAX_PATH+1];              // base OID from registry
extern  TCHAR               szSupView[MAX_PATH+1];              // supported view from registry
extern  TCHAR               szelMsgModuleName[MAX_PATH+1];      // expanded DLL message module
extern  BOOL                fGlobalTrim;                        // global trim message flag
extern  BOOL                fRegOk;                             // registry notification in effect flag
extern  BOOL                Read_Registry_Parameters(VOID);     // reread registry parameters function
extern  BOOL                fThreshold;                         // global performance threshold reached flag
extern  BOOL                fThresholdEnabled;                  // global threshold enabled flag
extern  BOOL                fDoLogonEvents;
extern  DWORD               dwLastBootTime;
extern  DWORD               dwTrapQueueSize;
extern  BOOL                Position_to_Log_End(HANDLE  hLog);  // set the position of the eventlog to past last record
extern  HKEY                hkRegResult;
extern  DWORD               g_dwEventLogPollTime;               // time in millsecs to poll for event logs
extern  DWORD               g_dwVarBindPrefixSubId;             // prefix sub-identifier for VarBind
typedef struct  _REGSTRUCT  {
    TCHAR   szOID[2*MAX_PATH+1];        // string area for EnterpriseOID field
    BOOL    fAppend;                    // append flag
    BOOL    fLocalTrim;                 // local message trim flag
    DWORD   nCount;                     // count field
    DWORD   nTime;                      // time field
}   REGSTRUCT, *PREGSTRUCT;

typedef struct  _CNTTABSTRUCT   {
    TCHAR   log[MAX_PATH+1];            // log file for entry
    DWORD   event;                      // event id
    TCHAR   source[MAX_PATH+1];         // source for event
    DWORD   curcount;                   // current count for event
    DWORD   time;                       // last time of event from GetCurrentTime()
    struct  _CNTTABSTRUCT   *lpNext;    // pointer to next entry in the table
}   COUNTTABLE, *PCOUNTTABLE;

PCOUNTTABLE         lpCountTable = (PCOUNTTABLE) NULL;  // address of count/time table
HANDLE              hMutex = NULL;                      // handle for mutex object

#endif                              // end of snmpelpt.h definitions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntagnt\snmpelpt.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    SNMPELPT.CPP


Abstract:

    This routine is the event log processing thread for the SNMP Event Log Agent DLL.
    The function of this routine is to wait for an event to occur, as indicated by an
    event log record, check the registry to determine if the event is being tracked,
    then to return a buffer to the processing agent DLL indicating that an SNMP trap
    should be sent to the extension agent. An event is posted complete when a buffer is
    built and ready for trap processing.

    In order to maintain data integrity between this thread and the processing agent
    thread, a MUTEX object is used to synchronize access to the trap buffer queue. If
    an error occurs, an event log message and trace records are written to indicate the
    problem and the event is ignored.

    When the extension agent is terminated, the processing agent DLL receives control
    in the process detach routine. An event is posted complete to indicate to this thread
    that processing should be terminated and all event logs should be closed.

Author:

    Randy G. Braze  Created 16 October 1994


Revision History:

    7 Feb 96    Restructured building of varbinds to be outside of trap generation.
                Calculated trap buffer length correctly.
                Created varbind queue and removed event log buffer queue.

    28 Feb 96   Added code to support a performance threshold reached indicator.
                Removed inclusion of base OID information from varbind OIDs.
                Added conversion from OEM to current code page for varbind data.
                Removed pointer references to varbindlist and enterpriseoid.
                Fixed memory leak for not freeing storage arrays upon successful build of trap.

    10 Mar 96   Removed OemToChar coding and registry checking.
                Modifications to read log file names from EventLog registry entries and not
                from specific entries in the SNMP Extension Agent's registry entries.
                Included SnmpMgrStrToOid as an internal function, as opposed to using the function
                provided by MGMTAPI.DLL. SNMPTRAP.EXE will be called if MGMTAPI is called, which
                will disable other agents from being able to receive any traps. All references
                to MGMTAPI.DLL and MGMTAPI.H will be removed.
                Added a ThresholdEnabled flag to the registry to indicate if the threshold values
                were to be monitored or ignored.

    15 Mar 96   Modified to move the sources for the eventlog in the registry down below a new
                key called Sources.

    07 May 96   Removed SnmpUtilOidFree and use two SNMP_free. One for the OID's ids array and
                one for the OID itself.

    22 May 96   Edited FreeVarBind to make sure we only freed memory we allocated.

    26 Jun 96   Added code to make sure message dlls were not loaded and unloaded (leaks) just have
                a list of handles to the loaded dlls and free them at the end. Also plugged some other
                memory leaks. Added a function to make sure the CountTable is kept tidy.


--*/

extern "C" {
#include <windows.h>        // basic windows applications information
#include <winperf.h>
#include <stdlib.h>
#include <malloc.h>         // needed for memory allocations
#include <string.h>         // string stuff
#include <snmp.h>           // snmp stuff
// #include <mgmtapi.h>     // snmp mgr definitions
#include <TCHAR.H>
#include <time.h>

#include "snmpelea.h"       // global dll definitions
#include "snmpelpt.h"       // module specific definitions
#include "snmpelmg.h"       // message definitions
}
#include <new> // prefix bug 445191
#include "snmpelep.h"       // c++ definitions and variables
extern  BOOL                StrToOid(PCHAR str, AsnObjectIdentifier *oid);




void
TidyCountTimeTable(
    IN      LPTSTR      lpszLog,            // pointer to log file name
    IN      LPTSTR      lpszSource,         // pointer to source of event
    IN      DWORD       nEventID            // event ID
    )

/*++

Routine Description:

    TidyCountTimeTable is called to remove items from the lpCountTable which no longer
    have a count greater than 1.


Arguments:

    lpszLog     -   Pointer to the log file for this event.

    lpszSource  -   Pointer to source for this event.

    nEventID    -   Event ID.


Return Value:

    None.
    

--*/

{
    PCOUNTTABLE lpTable;                // temporary fields
    PCOUNTTABLE lpPrev;

    WriteTrace(0x0a,"TidyCountTimeTable: Entering TidyCountTimeTable routine\n");
    
    if (lpCountTable == NULL)
    {
        WriteTrace(0x0a,"TidyCountTimeTable: Empty table, exiting TidyCountTimeTable\n");
        return;
    }

    // if we get here, then a table exists and must be scanned for a current entry

    lpTable = lpCountTable;                         // start with first table pointer
    lpPrev = NULL;                                  // set previous to NULL

    while (TRUE)
    {
        WriteTrace(0x0a,"TidyCountTimeTable: Checking entry %08X\n", lpTable);

        if ((strcmp(lpTable->log,lpszLog) != 0) ||
            (strcmp(lpTable->source,lpszSource) != 0) ||
            (lpTable->event != nEventID)
            )
        {
            if (lpTable->lpNext == NULL)
            {
                WriteTrace(0x0a,"TidyCountTimeTable: Entry not found\n");       
                break;
            }

            lpPrev = lpTable;
            lpTable = lpTable->lpNext;              // point to next entry
            continue;                               // continue the loop
        }

        if (lpPrev == NULL)
        {
            WriteTrace(0x0a,"TidyCountTimeTable: Freeing first entry in lpCountTable at %08X\n", lpTable);
            lpCountTable = lpCountTable->lpNext;
            SNMP_free(lpTable);
        }
        else
        {
            WriteTrace(0x0a,"TidyCountTimeTable: Freeing entry in lpCountTable at %08X\n", lpTable);
            lpPrev->lpNext = lpTable->lpNext;
            SNMP_free(lpTable);
        }

        break;
    }
    
    WriteTrace(0x0a,"TidyCountTimeTable: Exiting TidyCountTimeTable\n");
    return;
}

BOOL
CheckCountTime(
    IN      LPTSTR      lpszLog,            // pointer to log file name
    IN      LPTSTR      lpszSource,         // pointer to source of event
    IN      DWORD       nEventID,           // event ID
    IN      DWORD       dwTime,             // time of event
    IN      PREGSTRUCT  regStruct           // pointer to registry structure
    )

/*++

Routine Description:

    CheckCountTime is called to determine if a specific event with count and/or time
    values specified in the registry have met the indicated criteria. If an entry does
    not exist in the current table of entries, a new entry is added for later tracking.


Arguments:

    lpszLog     -   Pointer to the log file for this event.

    lpszSource  -   Pointer to source for this event.

    nEventID    -   Event ID.

    regStruct   -   Pointer to a structure where data read from the registry is provided.


Return Value:

    TRUE    -   If a trap should be sent. Count and/or time value criteria satisified.

    FALSE   -   If no trap should be sent.


--*/

{
    PCOUNTTABLE lpTable;                // temporary field
    DWORD       dwTimeDiff = 0;             // temporary field

    WriteTrace(0x0a,"CheckCountTime: Entering CheckCountTime routine\n");
    if (lpCountTable == NULL)
    {
        WriteTrace(0x0a,"CheckCountTime: Count/Time table is currently empty. Adding entry.\n");
        lpCountTable = (PCOUNTTABLE) SNMP_malloc(sizeof(COUNTTABLE));
        if (lpCountTable == NULL)
        {
            WriteTrace(0x14,"CheckCountTime: Unable to acquire storage for Count/Time table entry.\n");
            WriteLog(SNMPELEA_COUNT_TABLE_ALLOC_ERROR);
            return(FALSE);
        }
        // ensures null terminated strings
        (lpCountTable->log)[MAX_PATH]     = 0;
        (lpCountTable->source)[MAX_PATH] = 0;
        lpCountTable->lpNext = NULL;                // set forward pointer to null
        strncpy(lpCountTable->log,lpszLog,MAX_PATH);          // copy log file name to table
        strncpy(lpCountTable->source,lpszSource,MAX_PATH);    // copy source name to table
        lpCountTable->event = nEventID;             // copy event id to table
        lpCountTable->curcount = 0;                 // set table count to 0
        lpCountTable->time = dwTime;                // set table time to event time
        WriteTrace(0x0a,"CheckCountTime: New table entry is %08X\n", lpCountTable);
    }

    // if we get here, then a table exists and must be scanned for a current entry

    lpTable = lpCountTable;                         // start with first table pointer

    while (TRUE)
    {
        WriteTrace(0x0a,"CheckCountTime: Checking entry %08X\n", lpTable);

        if ((strcmp(lpTable->log,lpszLog) != 0) ||
            (strcmp(lpTable->source,lpszSource) != 0) ||
            (lpTable->event != nEventID)
            )
        {
            if (lpTable->lpNext == NULL)
            {
                break;
            }
            lpTable = lpTable->lpNext;              // point to next entry
            continue;                               // continue the loop
        }

        dwTimeDiff = dwTime - lpTable->time;        // compute elapsed time in seconds

        WriteTrace(0x0a,"CheckCountTime: Entry information located in table at %08X\n", lpTable);
        WriteTrace(0x00,"CheckCountTime: Entry count value is %lu\n",lpTable->curcount);
        WriteTrace(0x00,"CheckCountTime: Entry last time value is %08X\n",lpTable->time);
        WriteTrace(0x00,"CheckCountTime: Entry current time value is %08X\n",dwTime);
        WriteTrace(0x00,"CheckCountTime: Time difference is %lu\n",dwTimeDiff);
        WriteTrace(0x00,"CheckCountTime: Registry count is %lu, time is %lu\n",
            regStruct->nCount, regStruct->nTime);

        if (regStruct->nTime)
        {
            WriteTrace(0x0a,"CheckCountTime: Time value is being checked\n");
            if (dwTimeDiff > regStruct->nTime)
            {
                WriteTrace(0x0a,"CheckCountTime: Specified time parameters exceeded for entry. Resetting table information.\n");
                lpTable->time = dwTime;                 // reset time field
                lpTable->curcount = 1;                  // reset count field
                WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with FALSE\n");
                return(FALSE);
            }
        }

        if (++lpTable->curcount >= regStruct->nCount)
        {
            WriteTrace(0x0a,"CheckCountTime: Count field has been satisfied for entry\n");
            lpTable->curcount = 0;                      // reset count field for event
            lpTable->time = dwTime;                     // reset time field
            WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with TRUE\n");
            return(TRUE);
        }
        else
        {
            WriteTrace(0x0a,"CheckCountTime: Count field not satisfied for entry\n");
            WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with FALSE\n");
            return(FALSE);
        }
    }

    // if we get here, then a table entry does not exist for the current entry

    lpTable->lpNext = (PCOUNTTABLE) SNMP_malloc(sizeof(COUNTTABLE));    // allocate storage for new entry
    lpTable = lpTable->lpNext;              // set table pointer

    // prefix bug 445190
    if (lpTable == NULL)
    {
        WriteTrace(0x14,"CheckCountTime: Unable to acquire storage for Count/Time table entry.\n");
        WriteLog(SNMPELEA_COUNT_TABLE_ALLOC_ERROR);
        return(FALSE);
    }

    lpTable->lpNext = NULL;                 // set forward pointer to NULL
    // ensures null terminated strings
    (lpCountTable->log)[MAX_PATH]     = 0;
    (lpCountTable->source)[MAX_PATH] = 0;
    strncpy(lpTable->log,lpszLog,MAX_PATH);           // copy log file name to table
    strncpy(lpTable->source,lpszSource,MAX_PATH);     // copy source name to table
    lpTable->event = nEventID;              // copy event id to table
    lpTable->curcount = 0;                  // set table count to 0
    lpTable->time = dwTime;                 // set table time to event time
    WriteTrace(0x0a,"CheckCountTime: New table entry added at %08X\n", lpTable);

    if (regStruct->nTime)
    {
        WriteTrace(0x0a,"CheckCountTime: Time value is being checked\n");
        if (dwTimeDiff > regStruct->nTime)
        {
            WriteTrace(0x0a,"CheckCountTime: Specified time parameters exceeded for entry. Resetting table information.\n");
            lpTable->time = dwTime;                 // reset time field
            lpTable->curcount = 1;                  // reset count field
            WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with FALSE\n");
            return(FALSE);
        }
    }

    if (++lpTable->curcount >= regStruct->nCount)
    {
        WriteTrace(0x0a,"CheckCountTime: Count field has been satisfied for entry\n");
        lpTable->curcount = 0;                      // reset count field for event
        lpTable->time = dwTime;                     // reset time field
        WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with TRUE\n");
        return(TRUE);
    }
    else
    {
        WriteTrace(0x0a,"CheckCountTime: Count field not satisfied for entry\n");
        WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with FALSE\n");
        return(FALSE);
    }

//  default exit point (should never occur)

    WriteTrace(0x0a,"CheckCountTime: Exiting CheckCountTime with FALSE\n");
    return(FALSE);
}

BOOL
GetRegistryValue(
    IN      LPTSTR      sourceName,         // source name for event
    IN      LPTSTR      eventID,            // event ID for event
    IN      LPTSTR      logFile,            // log file of event
    IN      DWORD       timeGenerated,      // time this event was generated
    IN  OUT PREGSTRUCT  regStruct           // pointer to registry structure to return
    )

/*++

Routine Description:

    GetRegistryValue is called to read a specific key value from the system registry.


Arguments:

    sourceName      -   Specifies the source name from the event log.

    eventID         -   This the event ID from the event log record.

    regStruct       -   Pointer to a structure where data will be returned from the registry.


Return Value:

    TRUE    -   If a registry entry is located and all parameters could be read.

    FALSE   -   If no registry entry exists or some other error occurs.


--*/

{
    LONG    status;                     // registry read results
    HKEY    hkResult;                   // handle returned from API
    DWORD   iValue;                     // temporary counter
    DWORD   dwType;                     // type of the parameter read
    DWORD   nameSize;                   // length of parameter name
    DWORD   nReadBytes = 0;             // number of bytes read from profile information
    LPTSTR  lpszSourceKey;              // temporary string for registry source key
    LPTSTR  lpszEventKey;               // temporary string for registry event key
    TCHAR   temp[2*MAX_PATH+1];         // temporary string

    WriteTrace(0x0a,"GetRegistryValue: Entering GetRegistryValue function\n");

    if (fThresholdEnabled && fThreshold)
    {
        WriteTrace(0x0a,"GetRegistryValue: Performance threshold flag is on. No data will be processed.\n");
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);
    }

    if ( (lpszSourceKey = (LPTSTR) SNMP_malloc(strlen(EXTENSION_SOURCES)+strlen(sourceName)+2)) == NULL )
    {
        WriteTrace(0x14,"GetRegistryValue: Unable to allocate registry source key storage. Trap not sent.\n");
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);
    }

    if ( (lpszEventKey = (LPTSTR) SNMP_malloc(strlen(EXTENSION_SOURCES)+strlen(sourceName)+strlen(eventID)+3)) == NULL )
    {
        WriteTrace(0x14,"GetRegistryValue: Unable to allocate registry event key storage. Trap not sent.\n");
        SNMP_free(lpszSourceKey);
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);
    }
    // no overflow here, enough size has just been allocated
    strcpy(lpszSourceKey,EXTENSION_SOURCES);    // start with root
    strcat(lpszSourceKey,sourceName);           // append the source name
    strcpy(lpszEventKey,lpszSourceKey);         // build prefix for event key
    strcat(lpszEventKey,TEXT("\\"));            // add the backslash
    strcat(lpszEventKey,eventID);               // complete it with the event ID

    WriteTrace(0x00,"GetRegistryValue: Opening registry key for %s\n",lpszEventKey);

    if ((status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszEventKey, 0,
        (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS), &hkResult))
        != ERROR_SUCCESS)                   // open registry information
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            lpszEventKey, status);
        SNMP_free(lpszSourceKey);           // free storage
        SNMP_free(lpszEventKey);            // free storage
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);                  // show nothing exists
    }

    nameSize = sizeof(iValue);          // set field length
    if ( (status = RegQueryValueEx(     // look up count
        hkResult,                       // handle to registry key
        EXTENSION_COUNT,                // key to look up
        0,                              // ignored
        &dwType,                        // address to return type value
        (LPBYTE) &iValue,               // where to return count field
        &nameSize) ) != ERROR_SUCCESS)  // size of count field
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            EXTENSION_COUNT, status);
        regStruct->nCount = 0;          // set default value
    }
    else
    {
        regStruct->nCount = iValue;     // save returned value
        WriteTrace(0x00,"GetRegistryValue: Count field is %lu\n", regStruct->nCount);
    }
    
    nameSize = sizeof(iValue);
    if ( (status = RegQueryValueEx(     // look up local trim
        hkResult,                       // handle to registry key
        EXTENSION_TRIM,                 // key to look up
        0,                              // ignored
        &dwType,                        // address to return type value
        (LPBYTE) &iValue,               // where to return count field
        &nameSize) ) != ERROR_SUCCESS)  // size of count field
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            EXTENSION_TRIM, status);
        WriteTrace(0x00,"GetRegistryValue: Using default of global trim message flag of %lu\n",
            fGlobalTrim);
        regStruct->fLocalTrim = fGlobalTrim;    // set default value
    }
    else
    {
        regStruct->fLocalTrim = ((iValue == 1) ? TRUE : FALSE); // save returned value
        WriteTrace(0x00,"GetRegistryValue: Local message trim field is %lu\n", regStruct->fLocalTrim);
    }

    nameSize = sizeof(iValue);
    if ( (status = RegQueryValueEx(     // look up time
        hkResult,                       // handle to registry key
        EXTENSION_TIME,                 // key to look up
        0,                              // ignored
        &dwType,                        // address to return type value
        (LPBYTE) &iValue,               // where to return time field
        &nameSize) ) != ERROR_SUCCESS)  // size of time field
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            EXTENSION_TIME, status);
        regStruct->nTime = 0;           // set default value
    }
    else
    {
        regStruct->nTime = iValue;      // save returned value
        WriteTrace(0x00,"GetRegistryValue: Time field is %lu\n", regStruct->nTime);
    }

    RegCloseKey(hkResult);              // close registry key for event
    SNMP_free(lpszEventKey);            // free the storage for the event key

    WriteTrace(0x00,"GetRegistryValue: Opening registry key for %s\n",lpszSourceKey);

    if ((status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszSourceKey, 0,
        (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS), &hkResult))
        != ERROR_SUCCESS)                   // open registry information
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            lpszSourceKey, status);
        SNMP_free(lpszSourceKey);           // free storage
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);                  // show nothing exists
    }

    nameSize = sizeof(regStruct->szOID)-sizeof(TCHAR);  // set field length, size in bytes
    // caller ensures (regStruct->szOID)[2*MAX_PATH] == 0 for null terminated string
    if ( (status = RegQueryValueEx(     // look up EnterpriseOID
        hkResult,                       // handle to registry key
        EXTENSION_ENTERPRISE_OID,       // key to look up
        0,                              // ignored
        &dwType,                        // address to return type value
        (LPBYTE) regStruct->szOID,      // where to return OID string field
        &nameSize) ) != ERROR_SUCCESS)  // size of OID string field
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            EXTENSION_ENTERPRISE_OID, status);
        SNMP_free(lpszSourceKey);           // free storage
        RegCloseKey(hkResult);          // close the registry key
        WriteTrace(0x0a,"GetRegistryValue: Exiting GetRegistryValue function with FALSE\n");
        return(FALSE);                  // indicate error
    }

    WriteTrace(0x00,"GetRegistryValue: EnterpriseOID field is %s\n", regStruct->szOID);

    nameSize = sizeof(iValue);          // set field length
    if ( (status = RegQueryValueEx(     // look up time
        hkResult,                       // handle to registry key
        EXTENSION_APPEND,               // key to look up
        0,                              // ignored
        &dwType,                        // address to return type value
        (LPBYTE) &iValue,               // where to return time field
        &nameSize) ) != ERROR_SUCCESS)  // size of time field
    {
        WriteTrace(0x00,"GetRegistryValue: No registry entry exists for %s. RegOpenKeyEx returned %lu\n",
            EXTENSION_APPEND, status);
        regStruct->fAppend = TRUE;      // default to true
    }
    else
    {
        regStruct->fAppend = ((iValue == 1) ? TRUE : FALSE);        // reflect append flag
        WriteTrace(0x00,"GetRegistryValue: Append field is %lu\n", regStruct->fAppend);
    }

    RegCloseKey(hkResult);              // close registry key for source
    SNMP_free(lpszSourceKey);               // free the storage for the source key

    if (regStruct->fAppend)
    {
        // note: regStruct->szOID is 2*MAX_PATH+1, szBaseOID is MAX_PATH+1
        temp[2*MAX_PATH] = 0; // ensures null terminated string
        strncpy(temp,regStruct->szOID,2*MAX_PATH);              // copy enterprise suffix temporarily
        strcpy(regStruct->szOID, szBaseOID);                    // copy base enterprise oid first
        strcpy(regStruct->szOID+strlen(szBaseOID), TEXT("."));  // add the .
        strncpy(regStruct->szOID+strlen(szBaseOID)+1, temp, 
                2*MAX_PATH-strlen(regStruct->szOID));     // now add the suffix
        WriteTrace(0x0a,"GetRegistryValue: Appended enterprise OID is %s\n", regStruct->szOID);
    }

    if ((regStruct->nCount > 1) || regStruct->nTime)
    {
        WriteTrace(0x0a,"GetRegistryValue: Values found for Count and/or Time for this entry\n");

        if (regStruct->nCount == 0)
        {
            regStruct->nCount = 2;      // set a default value of 2
        }

        if (!CheckCountTime(logFile, sourceName, atol(eventID), timeGenerated, regStruct))
        {
            WriteTrace(0x0a,"GetRegistryValue: Count/Time values not met for this entry\n");
            WriteTrace(0x0a,"GetRegistryValue: Exiting ReadRegistryValue with FALSE\n");
            return(FALSE);              // indicate nothing to send
        }
    }
    else
    {
        TidyCountTimeTable(logFile, sourceName, atol(eventID));
    }

    WriteTrace(0x0a,"GetRegistryValue: Exiting ReadRegistryValue with TRUE\n");
    return(TRUE);                       // indicate got all of the data
}


VOID
StopAll(
     IN VOID
     )

/*++

Routine Description:

    This routine is called to write trace and log records and notify the
    other DLL threads that this thread is terminating.

Arguments:

    None

Return Value:

    None


--*/

{
    LONG    lastError;              // for GetLastError()

    WriteTrace(0x0a,"StopAll: Signaling DLL shutdown event %08X from Event Log Processing thread.\n",
        hStopAll);

    if (hStopAll && !SetEvent(hStopAll) )
    {
        lastError = GetLastError(); // save error code status
        WriteTrace(0x14,"StopAll: Error signaling DLL shutdown event %08X in SNMPELPT; code %lu\n",
            hStopAll, lastError);
        WriteLog(SNMPELEA_ERROR_SET_AGENT_STOP_EVENT,
            HandleToUlong(hStopAll), lastError);  // log error message
    }
}


VOID
DoExitLogEv(
     IN DWORD dwReturn
    )

/*++

Routine Description:

    This routine is called to write trace and log records when SnmpEvLogProc is
    terminating.

Arguments:

    dwReturn    -   Value to return in ExitThread.

Return Value:

    None

Notes:

    ExitThread is used to return control to the caller. A return code of 1 is
    supplied to indicate that a problem was encountered. A return code of 0
    is supplied to indicate that no problems were encountered.

--*/

{
    PCOUNTTABLE lpTable;            // pointer to count table address

    if (dwReturn)
    {
        WriteTrace(0x14,"DoExitLogEv: SnmpEvLogProc has encountered an error.\n");
    }

    if (lpCountTable != NULL)
    {
        WriteTrace(0x0a,"DoExitLogEv: Count/Time table has storage allocated. Freeing table.\n");
        lpTable = lpCountTable;     // start at first entry

        while (lpCountTable != NULL)
        {
            WriteTrace(0x00,"DoExitLogEv: Freeing Count/Time table entry at %08X\n", lpCountTable);
            lpTable = lpCountTable->lpNext;             // get pointer to next entry
            SNMP_free(lpCountTable);                            // free this storage
            lpCountTable = lpTable;                     // set to next entry
        }
    }

    WriteTrace(0x0a,"DoExitLogEv: Exiting SnmpEvLogProc routine.....\n");
    ExitThread(dwReturn);
}


VOID
CloseEvents(
     IN PHANDLE phWaitEventPtr
     )

/*++

Routine Description:

    This routine is called to close event handles that are open and to free
    the storage currently allocated to those handles.

Arguments:

    phWaitEventPtr  -   This is the pointer to the array of event handles used
                        for notification of a log event.

Return Value:

    None


--*/

{
    UINT    i;                      // temporary loop counter
    LONG    lastError;              // last API error code

    for (i = 0; i < uNumEventLogs; i++)
    {
        WriteTrace(0x0a,"CloseEvents: Closing handle for wait event %lu - %08X\n",
            i, *(phWaitEventPtr+i));

        if ( (*(phWaitEventPtr+i) != NULL) && !CloseHandle(*(phWaitEventPtr+i)) )
        {
            lastError = GetLastError();     // save error status
            WriteTrace(0x14,"CloseEvents: Error closing event handle %08X is %lu\n",
                *(phWaitEventPtr+i), lastError);    // trace error message
            WriteLog(SNMPELEA_ERROR_CLOSE_WAIT_EVENT_HANDLE,
                HandleToUlong(*(phWaitEventPtr+i)), lastError); // trace error message
        }
    }

    WriteTrace(0x0a,"CloseEvents: Freeing memory for wait event list %08X\n",
        phWaitEventPtr);
    SNMP_free( (LPVOID) phWaitEventPtr );        // Free the memory
}


BOOL
ReopenLog(
    IN DWORD    dwOffset,       // offset into event handle array
    IN PHANDLE  phWaitEventPtr  // event handle array pointer
    )

/*++

Routine Description:

    This routine is called to close and reopen an event log that has been
    cleared. When this happens, the handle becomes invalid and the log must
    be reopened and the NotifyChangeEventLog API must be called again.

Arguments:

    dwOffset    -   This field contains the index into the handle pointer
                    array of the currently invalid handle. This invalid
                    handle will be replaced with the valid handle if the
                    function is successful.

Return Value:

    TRUE    -   If the log was successfully reopened and a new NotifyChangeEventLog
                was issued successfully.

    FALSE   -   If the log could not be opened or the NotifyChangeEventLog failed.


--*/

{
    HANDLE      hLogHandle;         // temporary for log file handle
    LPTSTR      lpszLogName;        // name of this log file
    LONG        lastError;          // temporary for GetLastError;

    hLogHandle = *(phEventLogs+dwOffset);   // load the current handle
    lpszLogName = lpszEventLogs+dwOffset*(MAX_PATH+1);

    WriteTrace(0x14,"ReopenLog: Log file %s has been cleared; reopening log\n",
        lpszLogName);

    CloseEventLog(hLogHandle);  // first, close old handle
    *(phEventLogs+dwOffset) = NULL;

    hLogHandle = OpenEventLog( (LPTSTR) NULL, lpszLogName);

    if (hLogHandle == NULL)
    {                         // did log file open?
        lastError = GetLastError(); // save error code
        WriteTrace(0x14,"ReopenLog: Error in EventLogOpen for %s = %lu \n",
            lpszLogName, lastError);

        WriteLog(SNMPELEA_ERROR_OPEN_EVENT_LOG, lpszLogName, lastError);  // log the error message
        return(FALSE);                // failed -- forget this one
    }

    WriteTrace(0x00,"ReopenLog: New handle for %s is %08X\n",
        lpszLogName, hLogHandle);
    *(phEventLogs+dwOffset) = hLogHandle;   // save new handle now

    WriteTrace(0x00,"ReopenLog: Reissuing NotifyChangeEventLog for log\n");
    if (!NotifyChangeEventLog(*(phEventLogs+dwOffset),
        *(phWaitEventPtr+dwOffset)))
    {
        lastError = GetLastError();
        WriteTrace(0x14,"ReopenLog: NotifyChangeEventLog failed with code %lu\n",
            lastError);
        WriteLog(SNMPELEA_ERROR_LOG_NOTIFY, lastError); // log error message
        return(FALSE);
    }

    WriteTrace(0x00,"ReopenLog: ChangeNotify was successful\n");
    return(TRUE);
}


VOID
DisplayLogRecord(
    IN PEVENTLOGRECORD  pEventBuffer,
    IN DWORD            dwSize,
    IN DWORD            dwNeeded
    )

/*++

Routine Description:

    This routine is called to display the event log record after reading it.

Arguments:

    pEventBuffer    -   This is a pointer to an EVENTLOGRECORD structure
                        containing the current event log record.

    dwSize          -   Contains the size in bytes of the amount of data
                        just read into the buffer specified on the
                        ReadEventLog.

    dwNeeded        -   Contains the size in bytes of the amount of storage
                        required to read the next log record if GetLastError()
                        returns ERROR_INSUFFICIENT_BUFFER.

Return Value:

    None

--*/

{
    PCHAR   pcString;               // temporary string pointer
    UINT    j;                      // temporary loop counter

    if (nTraceLevel)                // if not maximum tracing
    {
        return;                     // just get out
    }

    WriteTrace(0x00,"DisplayLogRecord: Values from ReadEventLog follow:\n");
    WriteTrace(0x00,"DisplayLogRecord: EventSize = %lu EventNeeded = %lu\n",
        dwSize, dwNeeded);

    WriteTrace(0x00,"DisplayLogRecord: Event Log Buffer contents follow:\n");
    WriteTrace(0x00,"DisplayLogRecord: Length = %lu Record Number = %lu\n",
        pEventBuffer->Length, pEventBuffer->RecordNumber);
    WriteTrace(0x00,"DisplayLogRecord: Time generated = %08X Time written = %08X\n",
        pEventBuffer->TimeGenerated, pEventBuffer->TimeWritten);
    WriteTrace(0x00,"DisplayLogRecord: Event ID = %lu (%08X) Event Type = %04X\n",
        pEventBuffer->EventID, pEventBuffer->EventID, pEventBuffer->EventType);
    WriteTrace(0x00,"DisplayLogRecord: Num Strings = %lu EventCategory = %04X\n",
        pEventBuffer->NumStrings, pEventBuffer->EventCategory);
    WriteTrace(0x00,"DisplayLogRecord: String Offset = %lu Data Length = %lu\n",
        pEventBuffer->StringOffset, pEventBuffer->DataLength);
    WriteTrace(0x00,"DisplayLogRecord: Data Offset = %lu\n",
        pEventBuffer->DataOffset);

    pcString = (PCHAR) pEventBuffer + EVENTRECSIZE;
    WriteTrace(0x00,"DisplayLogRecord: EventBuffer address is %08X\n", pEventBuffer);
    WriteTrace(0x00,"DisplayLogRecord: EVENTRECSIZE is %lu\n",EVENTRECSIZE);

    WriteTrace(0x00,"DisplayLogRecord: String pointer is assigned address %08X\n",
        pcString);
    WriteTrace(0x00,"DisplayLogRecord: SourceName[] = %s\n", pcString);
    pcString += strlen(pcString) + 1;

    WriteTrace(0x00,"DisplayLogRecord: Computername[] = %s\n", pcString);
    pcString = (PCHAR) pEventBuffer + pEventBuffer->StringOffset;

    WriteTrace(0x00,"DisplayLogRecord: String pointer is assigned address %08X\n",
        pcString);
    for (j = 0; j < pEventBuffer->NumStrings; j++)
    {
        WriteTrace(0x00,"DisplayLogRecord: String #%lu ->%s\n", j, pcString);
        pcString += strlen(pcString) + 1;
    }
}


BOOL
AddBufferToQueue(
     IN PVarBindQueue   lpVarBindEntry  // pointer to varbind entry structure
     )

/*++

Routine Description:

    This routine will add a varbind entry to the queue of traps to send.


Arguments:

    lpVarBindEntry  -   This is a pointer to a varbind entry.

Return Value:

    TRUE    -   The varbind entry was successfully added to the queue.

    FALSE   -   The varbind entry could not be added to the queue.

Notes:


--*/

{
    PVarBindQueue   pBuffer;        // temporary pointer
    HANDLE          hWaitList[2];   // wait event array
    LONG            lastError;      // for GetLastError()
    DWORD           status;         // for wait

    WriteTrace(0x0a,"AddBufferToQueue: Entering AddBufferToQueue function\n");

    if (fThresholdEnabled && fThreshold)
    {
        WriteTrace(0x0a,"AddBufferToQueue: Performance threshold flag is on. No data will be processed.\n");
        WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue function with FALSE\n");
        return(FALSE);
    }

    WriteTrace(0x00,"AddBufferToQueue: Current buffer pointer is %08X\n", lpVarBindQueue);
    WriteTrace(0x00,"AddBufferToQueue: Adding buffer address %08X to queue\n", lpVarBindEntry);

    hWaitList[0] = hMutex;              // mutex handle
    hWaitList[1] = hStopAll;            // DLL termination event handle

    WriteTrace(0x00,"AddBufferToQueue: Handle to Mutex object is %08X\n", hMutex);
    WriteTrace(0x0a,"AddBufferToQueue: Waiting for Mutex object to become available\n");

    while (TRUE)
    {
        status = WaitForMultipleObjects(
            2,                              // only two objects to wait on
            (CONST PHANDLE) &hWaitList,     // address of array of event handles
            FALSE,                          // only one event is required
            1000);                          // only wait one second

        lastError = GetLastError();         // save any error conditions
        WriteTrace(0x0a,"AddBufferToQueue: WaitForMulitpleObjects returned a value of %lu\n", status);
        // bug# 277187 note: status will be 0 if both mutex and hStopAll are in signal state
        // we should check if we have to shutdown first.
        if (WAIT_OBJECT_0 == WaitForSingleObject (hStopAll, 0))
        {
            WriteTrace(0x0a,"AddBufferToQueue: DLL shutdown detected. Wait abandoned.\n");
            WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue routine with FALSE\n");
            return(FALSE);
        }
        switch (status)
        {
            case WAIT_FAILED:
                WriteTrace(0x14,"AddBufferToQueue: Error waiting for mutex event array is %lu\n",
                    lastError);                 // trace error message
                WriteLog(SNMPELEA_ERROR_WAIT_ARRAY, lastError); // log error message
                WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue routine with FALSE\n");
                return(FALSE);                  // get out now
            case WAIT_TIMEOUT:
                WriteTrace(0x0a,"AddBufferToQueue: Mutex object not available yet. Wait will continue.\n");
                continue;                       // retry the wait
            case WAIT_ABANDONED:
                WriteTrace(0x14,"AddBufferToQueue: Mutex object has been abandoned.\n");
                WriteLog(SNMPELEA_MUTEX_ABANDONED);
                WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue routine with FALSE\n");
                return(FALSE);                  // get out now
            case 1:
                WriteTrace(0x0a,"AddBufferToQueue: DLL shutdown detected. Wait abandoned.\n");
                WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue routine with FALSE\n");
                return(FALSE);
            case 0:
                WriteTrace(0x0a,"AddBufferToQueue: Mutex object acquired.\n");
                break;
            default:
                WriteTrace(0x14,"AddBufferToQueue: Undefined error encountered in WaitForMultipleObjects. Wait abandoned.\n");
                WriteLog(SNMPELEA_ERROR_WAIT_UNKNOWN);
                WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue routine with FALSE\n");
                return(FALSE);                  // get out now
        }   // end switch for processing WaitForMultipleObjects

        if (dwTrapQueueSize > MAX_QUEUE_SIZE)
        {
            WriteTrace(0x14,"AddBufferToQueue: queue too big -- posting notification event %08X\n",
                hEventNotify);
            
            if ( !SetEvent(hEventNotify) )
            {
                lastError = GetLastError();             // get error return codes
                WriteTrace(0x14,"AddBufferToQueue: Unable to post event %08X; reason is %lu\n",
                    hEventNotify, lastError);
                WriteLog(SNMPELEA_CANT_POST_NOTIFY_EVENT, HandleToUlong(hEventNotify), lastError);
            }
            else
            {
                if (!ReleaseMutex(hMutex))
                {
                    lastError = GetLastError();     // get error information
                    WriteTrace(0x14,"AddBufferToQueue: Unable to release mutex object for reason code %lu\n",
                        lastError);
                    WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
                }
                else
                {
                    Sleep(1000);    //try and let the other thread get the mutex
                    continue;       //and try and get the mutex again...
                }
            }
        }
        break;          // if we get here, then we've got the Mutex object

    }   // end while true for acquiring Mutex object

    if (lpVarBindQueue == (PVarBindQueue) NULL)
    {
        dwTrapQueueSize = 1;
        WriteTrace(0x0a,"AddBufferToQueue: Current queue is empty. Adding %08X as first queue entry\n",
            lpVarBindEntry);
        lpVarBindQueue = lpVarBindEntry;        // indicate first in queue

        WriteTrace(0x0a,"AddBufferToQueue: Releasing mutex object %08X\n", hMutex);
        if (!ReleaseMutex(hMutex))
        {
            lastError = GetLastError();     // get error information
            WriteTrace(0x14,"AddBufferToQueue: Unable to release mutex object for reason code %lu\n",
                lastError);
            WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
        }

        WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue function with TRUE\n");
        return(TRUE);                       // show added to queue
    }

    WriteTrace(0x0a,"AddBufferToQueue: Queue is not empty. Scanning for end of queue.\n");
    pBuffer = lpVarBindQueue;           // starting point

    while (pBuffer->lpNextQueueEntry != (PVarBindQueue) NULL)
    {
        WriteTrace(0x00,"AddBufferToQueue: This buffer address is %08X, next buffer pointer is %08X\n",
            pBuffer, pBuffer->lpNextQueueEntry);
        pBuffer = pBuffer->lpNextQueueEntry;    // point to next buffer
    }

    WriteTrace(0x0a,"AddBufferToQueue: Adding buffer address %08X as next buffer pointer in %08X\n",
        lpVarBindEntry, pBuffer);
    pBuffer->lpNextQueueEntry = lpVarBindEntry; // add to end of chain
    dwTrapQueueSize++;

    WriteTrace(0x0a,"AddBufferToQueue: Releasing mutex object %08X\n", hMutex);
    if (!ReleaseMutex(hMutex))
    {
        lastError = GetLastError();     // get error information
        WriteTrace(0x14,"AddBufferToQueue: Unable to release mutex object for reason code %lu\n",
            lastError);
        WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
    }

    WriteTrace(0x0a,"AddBufferToQueue: Exiting AddBufferToQueue function with TRUE\n");
    return(TRUE);                           // show added to queue
}

HINSTANCE
AddSourceHandle(
    IN LPTSTR   lpszModuleName
    )
{
    PSourceHandleList   pNewModule;
    
    pNewModule = (PSourceHandleList) SNMP_malloc(sizeof(SourceHandleList));

    if (pNewModule == NULL)
    {
        WriteTrace(0x14,"AddSourceHandle: Unable to acquire storage for source/handle entry.\n");
        WriteLog(SNMPELEA_COUNT_TABLE_ALLOC_ERROR);

        return NULL;
    }

    pNewModule->handle = NULL;
    (pNewModule->sourcename)[MAX_PATH] = 0; // ensures null terminated string
    _tcsncpy(pNewModule->sourcename, lpszModuleName, MAX_PATH);

    // load the module as a data file; we look only for messages
    pNewModule->handle = LoadLibraryEx(lpszModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
    
    // loading the module failed
    if (pNewModule->handle == (HINSTANCE) NULL )
    {
        DWORD dwError = GetLastError();

        WriteTrace(
            0x14,
            "AddSourceHandle: Unable to load message module %s; LoadLibraryEx returned %lu\n",
            lpszModuleName,
            dwError);

        WriteLog(
            SNMPELEA_CANT_LOAD_MSG_DLL,
            lpszModuleName,
            dwError);

        WriteTrace(0x0a,"AddSourceHandle: Exiting AddSourceHandle with NULL.\n");

        SNMP_free(pNewModule);

        return NULL;

    }

    pNewModule->Next = lpSourceHandleList;  // set forward pointer
    lpSourceHandleList = pNewModule;        //add item to list.

    return pNewModule->handle;
}

HINSTANCE
FindSourceHandle(
    IN LPTSTR   lpszSource
    )
{
   PSourceHandleList    lpSource;

    if (lpSourceHandleList == (PSourceHandleList) NULL)
    {
        return ((HINSTANCE) NULL);
    }

    lpSource = lpSourceHandleList;

    while (lpSource != (PSourceHandleList) NULL)
    {
        if (_tcscmp(lpszSource, lpSource->sourcename) == 0)
        {
            return (lpSource->handle);
        }
        lpSource = lpSource->Next;
    }

    return ((HINSTANCE) NULL);
}





VOID
ScanParameters(
    IN  OUT LPTSTR  *lpStringArray,                 // pointer to array of insertion strings
    IN      UINT    nNumStr,                        // number of insertion strings
    IN  OUT PUINT   nStringsSize,                   // address of size of all insertion strings
    IN      LPTSTR  lpszSrc,                        // pointer to source name for event
    IN      LPTSTR  lpszLog,                        // pointer to the registry name for this source
    IN      HMODULE hPrimModule                     // handle to secondary message module DLL
     )

/*++

Routine Description:

    This routine will scan the insertion strings looking for occurances of %%n, where
    n is a number indicating a substitution parameter value. If no occurances of %%n are found,
    then the routine simply returns without making any modifications.

    If any occurance of %%n is found in the buffer, secondary parameter substitution is then
    required. FormatMessage is called, without any insertion strings. The event ID is the
    value of n following the %%. The message module DLL is one of the following:

    Registry
        Machine
            SYSTEM
                CurrentControlSet
                    Services
                        EventLog
                            LogFile (Security, Application, System, etc.)
                                Source
                                    ParameterMessageFile        REG_EXPAND_SZ

                                    - or -

                                PrimaryModule                   REG_SZ

    If the ParameterMessageFile does not exist for the indicated source, then the PrimaryModule
    value will be used for the LogFile key. If this value does not exist, or if any error occurs
    when loading any of these DLL's, or if the parameter value cannot be found, the %%n value is
    replaced with a NULL string and processing continues.

Arguments:

    lpStringArray   -   Pointer to an array of insertion strings.

    nNumStr         -   Number of insertion strings in lpStrArray.

    nStringsSize    -   Pointer to total size of all insertion strings in lpStrArray.

    lpszSrc         -   Pointer to the source name for this event.

    lpszLog         -   Pointer to the registry event source name.

    hPrimModule     -   Secondary parameter module DLL handle for this event.

Return Value:

    None.

Notes:


--*/

{
    LONG            lastError;                          // return code from GetLastError
    TCHAR           szXParmModuleName[MAX_PATH+1];      // space for DLL message module
    TCHAR           szParmModuleName[MAX_PATH+1];       // space for expanded DLL message module
    BOOL            bExistParmModule;                   // says whether a ParmModuleName is specified or not
    DWORD           nFile = sizeof(szXParmModuleName)-sizeof(TCHAR); // max size for DLL message module name in bytes
    DWORD           dwType;                             // type of message module name
    DWORD           status;                             // status from registry calls
    DWORD           cbExpand;                           // byte count for REG_EXPAND_SZ parameters
    HKEY            hkResult;                           // handle to registry information
    HINSTANCE       hParmModule;                        // handle to message module DLL
    UINT            nBytes;                             // temporary field
    UINT            i;                                  // temporary counter
    LPTSTR          lpParmBuffer=NULL;
    LPTSTR          lpszString, lpStartDigit, lpNew;
    UINT            nStrSize, nSubNo, nParmSize, nNewSize, nOffset;
    PSourceHandleList   lpsource;                       //pointer to source/handle list


    WriteTrace(0x0a,"ScanParameters: Entering ScanParameters routine\n");
    WriteTrace(0x00,"ScanParameters: Size of original insertion strings is %lu\n", *nStringsSize);

    WriteTrace(0x0a,"ScanParameters: Opening registry for parameter module for %s\n", lpszLog);

    if ( (status = RegOpenKeyEx(        // open the registry to read the name
        HKEY_LOCAL_MACHINE,             // of the message module DLL
        lpszLog,                        // registry key to open
        0,
        KEY_READ,
        &hkResult) ) != ERROR_SUCCESS)
    {
        WriteTrace(0x14,"ScanParameters: Unable to open EventLog service registry key %s; RegOpenKeyEx returned %lu\n",
            lpszLog, status);           // write trace event record
        WriteLog(SNMPELEA_CANT_OPEN_REGISTRY_PARM_DLL, lpszLog, status);
        WriteTrace(0x0a,"ScanParameters: Exiting ScanParameters\n");
        return;                         // return
    }

    szXParmModuleName[MAX_PATH] = 0;        //ensures null terminated string
    if ( (status = RegQueryValueEx(         // look up module name
        hkResult,                           // handle to registry key
        EXTENSION_PARM_MODULE,              // key to look up
        0,                                  // ignored
        &dwType,                            // address to return type value
        (LPBYTE) szXParmModuleName,         // where to return parameter module name
        &nFile) ) != ERROR_SUCCESS)         // size of parameter module name field
    {
        WriteTrace(0x14,"ScanParameters: No ParameterMessageFile registry key for %s; RegQueryValueEx returned %lu\n",
            lpszLog, status);           // write trace event record

        bExistParmModule = FALSE;
    }
    else
    {
        WriteTrace(0x0a,"ScanParameters: ParameterMessageFile value read was %s\n", szXParmModuleName);
        cbExpand = ExpandEnvironmentStrings(    // expand the DLL name
            szXParmModuleName,                  // unexpanded DLL name
            szParmModuleName,                   // expanded DLL name
            MAX_PATH+1);                        // max size of expanded DLL name

        if (cbExpand == 0 || cbExpand > MAX_PATH+1)      // if it didn't expand correctly
        {
            WriteTrace(0x14,"ScanParameters: Unable to expand parameter module %s; expanded size required is %lu bytes\n",
                szXParmModuleName, cbExpand);   // log error message
            WriteLog(SNMPELEA_CANT_EXPAND_PARM_DLL, szXParmModuleName, cbExpand);

            bExistParmModule = FALSE;
        }
        else
        {
            WriteTrace(0x0a,"ScanParameters: ParameterMessageFile expanded to %s\n", szParmModuleName);

            bExistParmModule = TRUE;
        }
    }
    // at this point either bExistParmModule = FALSE 
    // or we have the ';' separated list of ParmModules
    // in szParmModuleName

    WriteTrace(0x0a,"ScanParameters: Closing registry key for parameter module\n");
    RegCloseKey(hkResult);      // close the registry key

    // for each insertion string
    for (i = 0; i < nNumStr; i++)
    {
        WriteTrace(0x00,"ScanParameters: Scanning insertion string %lu: %s\n",
            i, lpStringArray[i]);
        nStrSize = strlen(lpStringArray[i]);    // get size of insertion string
        lpszString = lpStringArray[i];          // set initial pointer

        // for each sub string identifier in the insertion string
        while (nStrSize > 2)
        {
            if ( (lpStartDigit = strstr(lpszString, TEXT("%%"))) == NULL )
            {
                WriteTrace(0x00,"ScanParameters: No secondary substitution parameters found\n");
                break;
            }

            nOffset = (UINT)(lpStartDigit - lpStringArray[i]);  // calculate offset in buffer of %%
            lpStartDigit += 2;                  // point to start of potential digit
            lpszString = lpStartDigit;          // set new string pointer
            nStrSize = strlen(lpszString);      // calculate new string length

            if (nStrSize == 0)
            {
                WriteTrace(0x00,"ScanParameters: %% found, but remainder of string is null\n");
                break;
            }

            nSubNo = atol(lpStartDigit);        // convert to long integer

            if (nSubNo == 0 && *lpStartDigit != '0')
            {
                WriteTrace(0x0a,"ScanParameters: %% found, but following characters were not numeric\n");
                lpszString--;                   // back up 1 byte
// DBCS start
// not need
//              if(WHATISCHAR(lpszString-1, 2) == CHAR_DBCS_TRAIL)
//                  lpszString--;
// DBCS end
                nStrSize = strlen(lpszString);  // recalculate length
                continue;                       // continue parsing the string
            }

            // initialize nBytes to 0 to make clear no message formatting was done.
            nBytes = 0;
            lastError = 0;

            // if there is a parameter file, look for into it for the secondary substitution strings
            if (bExistParmModule)
            {
                LPTSTR pNextModule = szParmModuleName;

                // for each module name in ParameterMessageFile list of modules
                while (pNextModule != NULL)
                {
                    // look for the next delimiter and change it with a string terminator
                    // in order to isolate the first module name - pointed by pNextModule
                    LPTSTR pDelim = _tcschr(pNextModule, _T(';'));
                    if (pDelim != NULL)
                        *pDelim = _T('\0');

                    WriteTrace(
                        0x0a,
                        "ScanParameters: Looking up secondary substitution string %lu in ParameterMessageFile %s\n",
                        nSubNo,
                        pNextModule);

                    // get the handle to the module (load the module now if need be)
                    hParmModule = FindSourceHandle(pNextModule);
                    if (!hParmModule)
                        hParmModule = AddSourceHandle(pNextModule);

                    // careful to restore the szParmModuleName string to its original content
                    // we need this as far as the scanning should be done for each of the insertion strings
                    if (pDelim != NULL)
                        *pDelim = _T(';');
                    
                    // it's not clear whether FormatMessage() allocates any memory in lpParmBuffer when it fails
                    // so initialize the pointer here, and free it in case of failure. LocalFree is harmless on
                    // NULL pointer.
                    lpParmBuffer = NULL;

                    // if we have a valid parameter module handle at this point,
                    // format the insertion string using this module
                    if (hParmModule != NULL)
                    {
                        nBytes = FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                            FORMAT_MESSAGE_IGNORE_INSERTS |     // ignore inserted strings
                            FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
                            (LPVOID) hParmModule,               // use parameter file
                            nSubNo,                             // parameter number to get
                            (ULONG) NULL,                       // specify no language
                            (LPTSTR) &lpParmBuffer,             // address for buffer pointer
                            80,                                 // minimum space to allocate
                            NULL);                              // no inserted strings

                        lastError = GetLastError();
                    }

                    // if the formatting succeeds, break the loop (szParmModuleName should
                    // be at this point exactly as it was when the loop was entered)
                    if (nBytes != 0)
                        break;

                    LocalFree(lpParmBuffer);
                    lpParmBuffer = NULL;

                    // move on to the next module name
                    pNextModule = pDelim != NULL ? pDelim + 1 : NULL;
                }
            }

            if (nBytes == 0)
            {

                WriteTrace(0x0a,"ScanParameters: ParameterMessageFile did not locate parameter - error %lu\n",
                    lastError);
//              WriteLog(SNMPELEA_PARM_NOT_FOUND, nSubNo, lastError);
                LocalFree(lpParmBuffer);    // free storage
                lpParmBuffer = NULL;

                WriteTrace(0x0a,"ScanParameters: Searching PrimaryModule for parameter\n");

                nBytes = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                    FORMAT_MESSAGE_IGNORE_INSERTS |     // ignore inserted strings
                    FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
                    (LPVOID) hPrimModule,               // use parameter file
                    nSubNo,                             // parameter number to get
                    (ULONG) NULL,                       // specify no language
                    (LPTSTR) &lpParmBuffer,             // address for buffer pointer
                    80,                                 // minimum space to allocate
                    NULL);                              // no inserted strings

                if (nBytes == 0)
                {
                    lastError = GetLastError(); // get error code
                    WriteTrace(0x0a,"ScanParameters: PrimaryModule did not locate parameter - error %lu\n",
                        lastError);
                    WriteLog(SNMPELEA_PRIM_NOT_FOUND, nSubNo, lastError);
                    LocalFree(lpParmBuffer);    // free storage
                    lpParmBuffer = NULL;
                }
            }

            nParmSize = 2;                  // set initialize parameter size (%%)

            while (strlen(lpszString))
            {
                if (!isdigit(*lpszString))
                {
                    break;                  // exit if no more digits
                }

                nParmSize++;                // increment parameter size
// DBCS start
                if (IsDBCSLeadByte(*lpszString))
                    lpszString++;
// DBCS end
                lpszString++;               // point to next byte
            }

            nNewSize = strlen(lpStringArray[i])+nBytes-nParmSize+1; // calculate new length
            nStrSize = strlen(lpStringArray[i])+1;  // get original length
            WriteTrace(0x00,"ScanParameters: Original string length is %lu, new string length is %lu\n",
                nStrSize, nNewSize);

            if (nNewSize > nStrSize)
            {
                lpNew = (TCHAR *) SNMP_realloc(lpStringArray[i], nNewSize);

                if ( lpNew == NULL)
                {
                    WriteTrace(0x14,"ScanParameters: Unable to reallocate storage for insertion strings. Scanning terminated.\n");
                    WriteLog(SNMPELEA_REALLOC_INSERTION_STRINGS_FAILED);
                    WriteTrace(0x00,"ScanParameters: Size of new insertion strings is %lu\n", *nStringsSize);
                    LocalFree(lpParmBuffer);// no need to set lpParmBuffer to NULL here
                    return;                 // return
                }

                WriteTrace(0x0a,"ScanParameters: Insertion string reallocated to %08X\n", lpNew);
                lpStringArray[i] = lpNew;                   // set new pointer
                lpStartDigit = lpStringArray[i] + nOffset;  // point to new start of current %%
                lpszString = lpStartDigit+nBytes;           // set new start of scan spot
                *nStringsSize += nBytes-nParmSize;          // calculate new total size
                WriteTrace(0x00,"ScanParameters: Old size of all insertion strings was %lu, new size is %lu\n",
                    *(nStringsSize)-nBytes+nParmSize, *nStringsSize);

                nStrSize = strlen(lpStartDigit)+1;          // calculate length of remainder of string
                memmove(lpStartDigit+nBytes-nParmSize,      // destination address
                    lpStartDigit,                           // source address
                    nStrSize);                              // amount of data to move

                memmove(lpStartDigit,                       // destination address
                    lpParmBuffer,                           // source address
                    nBytes);                                // amount of data to move
            }
            else
            {
                WriteTrace(0x0a,"ScanParameters: New size of string is <= old size of string\n");
                lpStartDigit -= 2;                  // now point to %%
                lpszString = lpStartDigit;          // set new start of scan spot
                *nStringsSize -= nParmSize;         // calculate new total size

                nStrSize = strlen(lpStartDigit+nParmSize)+1;// calculate length of remainder of string
                memmove(lpStartDigit,                       // destination address
                    lpStartDigit+nParmSize,                 // source address
                    nStrSize);                              // amount of data to move
            }

            if (nBytes)
            {
                LocalFree(lpParmBuffer);
                lpParmBuffer = NULL;
                // nBytes resets to 0 in the beginning of the while loop
            }
            
            WriteTrace(0x00,"ScanParameters: New insertion string is %s\n",
                lpStringArray[i]);
            nStrSize = strlen(lpszString);  // get length of remainder of string
        }
    }

    WriteTrace(0x00,"ScanParameters: Size of new insertion strings is %lu\n", *nStringsSize);
    WriteTrace(0x0a,"ScanParameters: Exiting ScanParameters routine\n");
}


VOID
FreeArrays(
     IN UINT    nCount,         // number of array entries to free
     IN PUINT   lpStrLenArray,  // pointer to string length array
     IN LPTSTR  *lpStringArray, // pointer to string pointer array
     IN BOOL    DelStrs = TRUE
     )

/*++

Routine Description:

    This routine will free the allocated storage for strings in case of an error when
    building the varbind entries.


Arguments:

    nCount          -   This is a count of the number of entries to free

    lpStrLenArray   -   This is a pointer to the string length array to be freed.

    lpStringArray   -   This is a pointer to the string array to be freed.

    DelStrs         -   Should the strings be deleted?

Return Value:

    None.

Notes:


--*/

{
    if (DelStrs)
    {
        WriteTrace(0x00,"FreeArrays: Freeing storage for strings and string length arrays\n");

        for (UINT j=0; j < nCount+5; j++)
        {
            if (lpStrLenArray[j] != 0)
            {
                WriteTrace(0x0a,"FreeArrays: Freeing string storage at address %08X\n",
                    lpStringArray[j]);
                SNMP_free(lpStringArray[j]);
            }
        }

        WriteTrace(0x0a,"FreeArrays: Freeing storage for string array %08X\n", lpStringArray);
        SNMP_free(lpStringArray);
    }
    else
        WriteTrace(0x00,"FreeArrays: Freeing storage for string length array only\n");

    WriteTrace(0x0a,"FreeArrays: Freeing storage for string length array %08X\n", lpStrLenArray);
    SNMP_free(lpStrLenArray);

    return;
}


VOID
FreeVarBind(
    IN  UINT                count,
    IN  RFC1157VarBindList  *varBind
    )

/*++

Routine Description:

    FreeVarBind will free the storage allocated to the indicated varbind and associated
    varbind list.

Arguments:

    count   -   Number of entries to free.

    varBind -   Pointer to the varbind list structure.

Return Value:

    None.

--*/

{
    UINT    j;                      // counter

    WriteTrace(0x0a,"FreeVarBind: Entering FreeVarBind routine\n");
    WriteTrace(0x00,"FreeVarBind: Varbind list is %08X\n", varBind);
    WriteTrace(0x00,"FreeVarBind: varBind->list is %08X\n", varBind->list);

    for (j=0; j < count; j++)
    {
        WriteTrace(0x00,"FreeVarBind: Freeing OID #%lu ids at %08X\n", j, &varBind->list[j].name.ids);
        SNMP_free((&varBind->list[j].name)->ids);
        WriteTrace(0x00,"FreeVarBind: Freeing  varbind stream #%lu at %08X\n", j, &varBind->list[j].value.asnValue.string.stream);
        SNMP_free((&varBind->list[j].value.asnValue.string)->stream);

//22 May 96****************************************************************************************************
//Varbind was allocated as an array in BuildTrapBuffer and so one SNMP_free should be called after this method

//      WriteTrace(0x0a,"FreeVarBind: Freeing varbind %lu at %08X\n",
//          j, &varBind->list[j]);
//      SnmpUtilVarBindFree(&varBind->list[j]);
    }

//22 May 96***************************************************************************************************
//Let the procedure that calls this procedure delete the varBind object

//  WriteTrace(0x0a,"FreeVarBind: Freeing varbind list %08X\n", varBind);
//  SnmpUtilVarBindListFree(varBind);
    WriteTrace(0x0a,"FreeVarBind: Exiting FreeVarBind routine\n");
    return;                                         // exit
}


UINT
TrimTrap(
    IN  OUT RFC1157VarBindList  *varBind,
    IN  OUT UINT                size,
    IN      BOOL                fTrimMessage
    )

/*++

Routine Description:

    TrimTrap will trim the trap in order to keep the trap size below 4096 bytes (SNMP
    maximum packet size). The global trim flag will be used to determine if data should be
    trimmed or omitted.

Arguments:

    varBind -   Pointer to the varbind list structure.

    size    -   Current size, upon entry, of the entire trap structure.

Return Value:

    None.

Notes:

    This routine does not correctly trim the trap data. Microsoft indicated that this routine
    currently was not required, thus no calls are being made to this routine.

--*/

{
    UINT    i;                          // counter
    UINT    nTrim;                      // temporary variable
    UINT    nVarBind;                   // temporary variable

    WriteTrace(0x0a,"TrimTrap: Entering TrimTrap routine\n");

    nTrim = size - nMaxTrapSize;        // see how much we have to trim
    WriteTrace(0x00,"TrimTrap: Trimming %lu bytes\n", nTrim);
    WriteTrace(0x00,"TrimTrap: Trap size is %lu bytes\n", size);

    if (fTrimMessage)                   // if we're trimming the message text first
    {
        WriteTrace(0x0a,"TrimTrap: Registry values indicate EventLog text to be trimmed first\n");

        nVarBind = varBind->list[0].value.asnValue.string.length;

        if (nVarBind > nTrim)
        {
            WriteTrace(0x0a,"TrimTrap: EventLog text size is greater than amount to trim. Trimming EventLog text only\n");
            WriteTrace(0x00,"TrimTrap: EventLog text size is %lu, trim amount is %lu\n",
                nVarBind, nTrim);

            varBind->list[0].value.asnValue.string.length -= nTrim;
            *(varBind->list[0].value.asnValue.string.stream + nVarBind + 1) = '\0'; // add null pointer for tracing

            WriteTrace(0x00,"TrimTrap: New EventLog text is %s\n",
                varBind->list[0].value.asnValue.string.stream);
            WriteTrace(0x0a,"TrimTrap: Exiting TrimTrap routine\n");

            size -= nTrim;      // drop by length of string
            return(size);                           // exit
        }

        WriteTrace(0x0a,"TrimTrap: EventLog text size is less than or equal to the amount to trim. Zeroing varbinds.\n");
        WriteTrace(0x0a,"TrimTrap: Zeroing EventLog text.\n");

        size -= nVarBind;

        WriteTrace(0x00,"TrimTrap: Trimming off %lu bytes from EventLog text.\n", nVarBind);
        WriteTrace(0x00,"TrimTrap: New size is now %lu bytes.\n", size);

        varBind->list[0].value.asnValue.string.length = 0;
        *(varBind->list[0].value.asnValue.string.stream) = '\0';    // make it null

        i = varBind->len-1;     // set index counter

        while (size > nMaxTrapSize && i != 0)
        {
            nVarBind = varBind->list[i].value.asnValue.string.length;

            WriteTrace(0x0a,"TrimTrap: Trap size is %lu, max size is %lu. Zeroing varbind entry %lu of size %lu.\n",
                size, nMaxTrapSize, i, nVarBind);

            size -= nVarBind;
            varBind->list[i].value.asnValue.string.length = 0;          // set length
            *(varBind->list[i--].value.asnValue.string.stream) = '\0';  // make it null
        }

        WriteTrace(0x0a,"TrimTrap: Trap size is now %lu.\n", size);

        if (size > nMaxTrapSize)
        {
            WriteTrace(0x14,"TrimTrap: All varbinds have been zeroed, but trap still too large.\n");
            WriteLog(SNMPELEA_TRIM_FAILED);
            return(0);          // exit
        }

        return(size);           // exit
    }
    else
    {
        WriteTrace(0x0a,"TrimTrap: Registry values indicate varbind insertion strings to be trimmed first\n");

        i = varBind->len-1;     // set index counter

        while ( (size > nMaxTrapSize) && (i != 0) )
        {
            nVarBind = varBind->list[i].value.asnValue.string.length;

            WriteTrace(0x0a,"TrimTrap: Trap size is %lu, max size is %lu. Zeroing varbind entry %lu of size %lu.\n",
                size, nMaxTrapSize, i, nVarBind);

            size -= nVarBind;
            varBind->list[i].value.asnValue.string.length = 0;          // set length
            *(varBind->list[i--].value.asnValue.string.stream) = '\0';  // make it null
        }

        if (size <= nMaxTrapSize)
        {
            WriteTrace(0x0a,"TrimTrap: Trap size is now %lu.\n", size);
            WriteTrace(0x0a,"TrimTrap: Exiting TrimTrap routine\n");
            return(size);
        }

        nVarBind = varBind->list[0].value.asnValue.string.length;   // get length of event log text

        WriteTrace(0x0a,"TrimTrap: All insertion strings removed. Only EventLog text remains of size %lu.\n",
            nVarBind);

        nTrim = size - nMaxTrapSize;        // compute how much to trim

        WriteTrace(0x00,"TrimTrap: Need to trim %lu bytes from Event Log text.\n", nTrim);

        if (nVarBind < nTrim)
        {
            WriteTrace(0x14,"TrimTrap: Data to be trimmed exceeds data in trap.\n");
            WriteLog(SNMPELEA_TRIM_FAILED);
            return(0);
        }

        varBind->list[0].value.asnValue.string.length -= nTrim;

        WriteTrace(0x00,"TrimTrap: EventLog text string length is now %lu\n",
            varBind->list[0].value.asnValue.string.length);

        *(varBind->list[0].value.asnValue.string.stream + nVarBind + 1) = '\0'; // add null pointer for tracing

        WriteTrace(0x00,"TrimTrap: New EventLog text is %s\n",
            varBind->list[0].value.asnValue.string.stream);

        size -= nTrim;      // drop by length of string

        WriteTrace(0x0a,"TrimTrap: Trap size is now %lu.\n", size);
        WriteTrace(0x0a,"TrimTrap: Exiting TrimTrap routine\n");

        return(size);                           // exit
    }

    WriteTrace(0x0a,"TrimTrap: Exiting TrimTrap routine. Default return.\n");
    return(size);                           // exit
}


BOOL
BuildTrapBuffer(
     IN PEVENTLOGRECORD EventBuffer,        // Event Record from Event Log
     IN REGSTRUCT       rsRegStruct,        // Registry information structure
     IN LPTSTR          lpszLogFile,        // log file name for event
     IN HMODULE         hPrimModule         // handle to secondary parameter module
     )

/*++

Routine Description:

    This routine will build the buffer that contains the variable bindings for the
    trap data to be sent. Coordination between this routine and the trap sending thread
    is done with a MUTEX object. This thread will block until the object can be acquired
    or until it is notified that the agent DLL is terminating.


Arguments:

    EventBuffer -   This is a pointer to a buffer containing the event log text.

    rsRegStruct -   This is a structure containing registry information that relates
                    to the information contained on the event log buffer.

    lpszLogFile -   The name of the log file read for this event. Used to read the
                    registry to get the message file DLL and then to acquire the text
                    of the message for this event id.

    hPrimModule -   Handle to the module loaded for secondary parameter insertions for
                    secondary insertion strings. This is the PrimaryModule as specified
                    in the registry for each log file.

Return Value:

    TRUE    -   A trap buffer was successfully built and added to the queue.

    FALSE   -   A trap buffer could not be constructed or the DLL is terminating.

Notes:


--*/

{
    LONG            lastError;                          // return code from GetLastError
    TCHAR           szXMsgModuleName[MAX_PATH+1];       // space for DLL message module
    TCHAR           szMsgModuleName[MAX_PATH+1];        // space for expanded DLL message module
    DWORD           nFile = sizeof(szXMsgModuleName)-sizeof(TCHAR);// max size for DLL message module name in bytes
    DWORD           dwType;                             // type of message module name
    DWORD           status;                             // status from registry calls
    DWORD           cbExpand;                           // byte count for REG_EXPAND_SZ parameters
    HKEY            hkResult;                           // handle to registry information
    HINSTANCE       hMsgModule;                         // handle to message module DLL
    LPTSTR          *lpStringArray;                     // pointer to array of strings
    PUINT           lpStrLenArray;                      // pointer to array of string lengths
    LPTSTR          lpszSource;                         // pointer to source name
    PSID            psidUserSid;                        // pointer to user sid
    LPTSTR          lpszString;                         // pointer to inserted strings
    UINT            size;                               // size of trap buffer
    UINT            nStringSize;                        // temporary field
    UINT            nBytes;                             // temporary field
    UINT            i, j;                               // temporary counters
    TCHAR           lpszLog[MAX_PATH+1];                // temporary registry name
    LPTSTR          lpBuffer;                           // pointer to event log text
    DWORD           cchReferencedDomain = MAX_PATH+1;   // size of referenced domain
    TCHAR           lpszReferencedDomain[MAX_PATH+1];   // referenced domain
    TCHAR           szTempBuffer[MAX_PATH*2+1];         // temporary buffer
    DWORD           nBuffer;                            // temporary size field
    SID_NAME_USE    snu;                                // SID name use field
    PVarBindQueue   varBindEntry;                       // pointer to varbind queue entry
    PSourceHandleList   lpsource;                       //pointer to source/handle list
    TCHAR           szTempBuffer2[MAX_PATH*2+1];
    BOOL            fOk;                                // variabled used by WRAP_STRCAT_A
                                                        // or WRAP_STRCAT_A_2 macros
    WriteTrace(0x0a,"BuildTrapBuffer: Entering BuildTrapBuffer\n");

    if (fThresholdEnabled && fThreshold)
    {
        WriteTrace(0x0a,"BuildTrapBuffer: Performance threshold flag is on. No data will be processed.\n");
        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer function with FALSE\n");
        return(FALSE);
    }

    WriteTrace(0x00,"BuildTrapBuffer: Notify event handle is %08X\n", hEventNotify);

    nBuffer = MAX_PATH*2+1;                             // reset length field to default
    lpszSource = (LPTSTR) EventBuffer + EVENTRECSIZE;   // point to source name
    psidUserSid = (PSID) ( (LPTSTR) EventBuffer + EventBuffer->UserSidOffset);  // point to user sid
    lpszString = (LPTSTR) EventBuffer + EventBuffer->StringOffset;  // point to first string

    WriteTrace(0x00,"BuildTrapBuffer: Source name is %s, length is %u\n", lpszSource, strlen(lpszSource));
    WriteTrace(0x00,"BuildTrapBuffer: Computer name is %s, length is %u\n",
        lpszSource+strlen(lpszSource)+1, strlen(lpszSource+strlen(lpszSource)+1) );
    WriteTrace(0x00,"BuildTrapBuffer: Pointer to User SID is %08X\n", psidUserSid);
    WriteTrace(0x00,"BuildTrapBuffer: First inserted string is %s\n", lpszString);

    // WRAP_STRCAT_A_2 macro returns FALSE if error in strcat
    lpszLog[MAX_PATH] = 0;
    strncpy(lpszLog, EVENTLOG_BASE, MAX_PATH);     // copy base registry name
    WRAP_STRCAT_A_2(lpszLog, lpszLogFile,MAX_PATH);     // add on the log file name read
    WRAP_STRCAT_A_2(lpszLog, TEXT("\\"),MAX_PATH);      // tack on backslash
    WRAP_STRCAT_A_2(lpszLog, lpszSource,MAX_PATH);      // add on the source name

    WriteTrace(0x0a,"BuildTrapBuffer: Opening registry for message module for %s\n", lpszLog);

    if ( (status = RegOpenKeyEx(        // open the registry to read the name
        HKEY_LOCAL_MACHINE,             // of the message module DLL
        lpszLog,                        // registry key to open
        0,
        KEY_READ,
        &hkResult) ) != ERROR_SUCCESS)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to open EventLog service registry key %s; RegOpenKeyEx returned %lu\n",
            lpszLog, status);           // write trace event record
        WriteLog(SNMPELEA_CANT_OPEN_REGISTRY_MSG_DLL, lpszLog, status);
        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                  // return
    }

    if ( (status = RegQueryValueEx( // look up module name
        hkResult,                   // handle to registry key
        EXTENSION_MSG_MODULE,       // key to look up
        0,                          // ignored
        &dwType,                    // address to return type value
        (LPBYTE) szXMsgModuleName,  // where to return message module name
        &nFile) ) != ERROR_SUCCESS) // size of message module name field
    {
        WriteTrace(0x14,"BuildTrapBuffer: No EventMessageFile registry key for %s; RegQueryValueEx returned %lu\n",
            lpszLog, status);           // write trace event record
        WriteLog(SNMPELEA_NO_REGISTRY_MSG_DLL, lpszLog, status);
        RegCloseKey(hkResult);      // close the registry key
        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                  // return
    }

    RegCloseKey(hkResult);      // close the registry key

    cbExpand = ExpandEnvironmentStrings(    // expand the DLL name
        szXMsgModuleName,                   // unexpanded DLL name
        szMsgModuleName,                    // expanded DLL name
        MAX_PATH+1);                        // max size of expanded DLL name

    if (cbExpand == 0 || cbExpand > MAX_PATH+1)      // if it didn't expand correctly
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to expand message module %s; expanded size required is %lu bytes\n",
            szXMsgModuleName, cbExpand);    // log error message
        WriteLog(SNMPELEA_CANT_EXPAND_MSG_DLL, szXMsgModuleName, cbExpand);
        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                  // return
    }
    //---- at this point, szMsgModuleName is the value for "EventMessageFile" parameter----
    //---- it might be one module name or a ';' separated list of module names

    // alloc here the array of pointer to varbind values
    // the first 5 varbind are:
    // 1.3.1.0 - message description 
    // 1.3.2.0 - user name
    // 1.3.3.0 - system name
    // 1.3.4.0 - event type
    // 1.3.5.0 - event category
    // the rest varbinds are one for each insertion string
    nStringSize = 0;
    lpStringArray = (LPTSTR *) SNMP_malloc((EventBuffer->NumStrings+5) * sizeof(LPTSTR) );

    if (lpStringArray == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for string array\n");
        WriteLog(SNMPELEA_INSERTION_STRING_ARRAY_ALLOC_FAILED);
        return(FALSE);
    }

    WriteTrace(0x00,"BuildTrapBuffer: String array allocated at %08X\n", lpStringArray);
    lpStrLenArray = (PUINT) SNMP_malloc((EventBuffer->NumStrings+5) * sizeof(UINT) );

    if (lpStrLenArray == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for string length array\n");
        WriteLog(SNMPELEA_INSERTION_STRING_LENGTH_ARRAY_ALLOC_FAILED);
        SNMP_free(lpStringArray);
        return(FALSE);
    }

    for (i = 0; i < (UINT) EventBuffer->NumStrings+5; i++)
    {
        lpStrLenArray[i] = 0;
    }

    WriteTrace(0x00,"BuildTrapBuffer: String length array allocated at %08X\n", lpStrLenArray);

    if (EventBuffer->NumStrings)
    {
        for (i = 5; i < (UINT) EventBuffer->NumStrings+5; i++)
        {
            lpStrLenArray[i] = _tcslen(lpszString);     // get size of insertion string
            WriteTrace(0x00,"BuildTrapBuffer: String %lu is %s, size of %lu\n",
                i, lpszString, lpStrLenArray[i]);

            lpStringArray[i] = (TCHAR *) SNMP_malloc(lpStrLenArray[i]+1);

            if ( lpStringArray[i] == NULL)
            {
                WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for insertion string\n");
                WriteLog(SNMPELEA_INSERTION_STRING_ALLOC_FAILED);

                FreeArrays(i, lpStrLenArray, lpStringArray);

                WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
                return(FALSE);                  // return
            }

            WriteTrace(0x00,"BuildTrapBuffer: Insertion string %lu address at %08X\n",
                i, lpStringArray[i]);
            strcpy(lpStringArray[i],lpszString);    // copy string to storage
            
            nStringSize += lpStrLenArray[i]+1;      // accumulate total insertion string length
            lpszString += lpStrLenArray[i]+1;       // point to next insertion string
        }

        ScanParameters(&lpStringArray[5],   // address of insertion string array
            EventBuffer->NumStrings,        // number of insertion strings in array
            &nStringSize,                   // address of size of all insertion strings
            lpszSource,                     // pointer to source name for event
            lpszLog,                        // pointer to registry name
            hPrimModule);                   // handle to secondary parameter scan module

        for (i=5; i < (UINT) EventBuffer->NumStrings+5; i++)
        {
            WriteTrace(0x00,"BuildTrapBuffer: Scanned string %lu is %s\n",
                i, lpStringArray[i]);

            // the insertion string might have been enlarged with substrings. Need to recompute their length
            lpStrLenArray[i] = _tcslen(lpStringArray[i]);
        }

    }

    LPTSTR pNextModule = szMsgModuleName;
    while (pNextModule != NULL)
    {
        LPTSTR pDelim = _tcschr(pNextModule, _T(';'));
        if (pDelim != NULL)
            *pDelim = _T('\0');

        //nadir
        //-------<We need now the 'EventMessageFile'>-----
        if ( _tcscmp(pNextModule, szelMsgModuleName) == 0)
        {
            WriteTrace(0x14,"BuildTrapBuffer: Request to trap extension agent log event ignored.\n");
            WriteLog(SNMPELEA_LOG_EVENT_IGNORED);

            FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);

            WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
            return(FALSE);                  // simply exit now
        }

        if ((hMsgModule = FindSourceHandle(pNextModule)) == NULL)
           hMsgModule = AddSourceHandle(pNextModule);

        if (hMsgModule != NULL)
        {
            //-------<At this point format the message>--------
            lpBuffer = NULL;

            nBytes = FormatMessage(                 // see if we can format the message
                FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                (EventBuffer->NumStrings ? FORMAT_MESSAGE_ARGUMENT_ARRAY : 0 ) | // indicate an array of string inserts
                FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
                (LPVOID) hMsgModule,                // handle to message module
                EventBuffer->EventID,               // message number to get
                (ULONG) NULL,                       // specify no language
                (LPTSTR) &lpBuffer,                 // address for buffer pointer
                80,                                 // minimum space to allocate
                EventBuffer->NumStrings ? (va_list*) &lpStringArray[5] : NULL); // address of array of pointers

            // store here the last error encountered while formatting (will be used to catch
            // the error condition at the end of all the iterations)
            lastError = GetLastError();

            // the event was formatted successfully so break the loop
            if (nBytes != 0)
                break;

            // is not clear whether FormatMessage is not allocating the buffer on failure.
            // just in case, free it here. As it was initialized to NULL, this call shouldn't harm
            LocalFree(lpBuffer);
            lpBuffer = NULL;
        }

        // try the next module
        pNextModule = pDelim != NULL ? pDelim + 1 : NULL;
        //--------------
    }

    // the event could not be formatted by any of the 'EventMessageFile' modules. Will bail out
    if (nBytes == 0)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Error formatting message number %lu (%08X) is %lu\n",
            EventBuffer->EventID, EventBuffer->EventID, lastError); // trace the problem
        WriteLog(SNMPELEA_CANT_FORMAT_MSG, EventBuffer->EventID, lastError);
        LocalFree(lpBuffer);                    // free storage

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");

        return FALSE;
    }

    WriteTrace(0x00,"BuildTrapBuffer: Formatted message: %s\n", lpBuffer);  // log the message in the trace file

    lpStrLenArray[0] = strlen(lpBuffer);            // set varbind length
    lpStringArray[0] = (TCHAR *) SNMP_malloc(lpStrLenArray[0] + 1); // get storage for varbind string

    if ( lpStringArray[0] == NULL)
    {
        lpStrLenArray[0] = 0;                   // reset so storage isn't freed
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for insertion string\n");
        WriteLog(SNMPELEA_INSERTION_STRING_ALLOC_FAILED);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage
        LocalFree(lpBuffer);                    // free storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                  // return
    }

    WriteTrace(0x00,"BuildTrapBuffer: Insertion string 0 address at %08X\n",
        lpStringArray[0]);

    strcpy(lpStringArray[0], lpBuffer);             // copy buffer to varbind

    if ( LocalFree(lpBuffer) != NULL )          // free buffer storage
    {
        lastError = GetLastError();             // get error codes
        WriteTrace(0x14,"BuildTrapBuffer: Error freeing FormatMessage buffer is %lu\n",lastError);
        WriteLog(SNMPELEA_FREE_LOCAL_FAILED, lastError);
    }
    // No need to set lpBuffer to NULL here, it is not used anymore from here
    
    // ensures null terminated strings
    szTempBuffer[2*MAX_PATH] = 0;
    szTempBuffer2[2*MAX_PATH] = 0;
    if (EventBuffer->UserSidLength)
    {
        if ( !LookupAccountSid(                     // lookup account name
                NULL,                               // system to lookup account on
                psidUserSid,                        // pointer to SID for this account
                szTempBuffer,                       // return account name in this buffer
                &nBuffer,                           // pointer to size of account name returned in TCHARs
                lpszReferencedDomain,               // domain where account was found
                &cchReferencedDomain,               // pointer to size of domain name in TCHARs
                &snu) )                             // sid name use field pointer
        {
            lastError = GetLastError();             // get reason call failed
            WriteTrace(0x14,"BuildTrapBuffer: Unable to acquire account name for event, reason %lu. Unknown is used.\n",
                lastError);
            WriteLog(SNMPELEA_SID_UNKNOWN, lastError);
            strcpy(szTempBuffer,TEXT("Unknown"));   // set default account name
            nBuffer = strlen(szTempBuffer);         // set default size
        }
    }
    else
    {
        WriteTrace(0x0a,"BuildTrapBuffer: UserSidLength was 0. No SID is present. Unknown is used.\n");
        strcpy(szTempBuffer,TEXT("Unknown"));       // set default account name
        nBuffer = strlen(szTempBuffer);             // set default size
    }

    lpStringArray[1] = (TCHAR *) SNMP_malloc(nBuffer + 1);  // get storage for varbind string

    if ( lpStringArray[1] == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for insertion string\n");
        WriteLog(SNMPELEA_INSERTION_STRING_ALLOC_FAILED);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                  // return
    }

    WriteTrace(0x00,"BuildTrapBuffer: Insertion string 1 address at %08X\n",
        lpStringArray[1]);

    strcpy(lpStringArray[1], szTempBuffer);             // copy buffer to varbind
    lpStrLenArray[1] = nBuffer;                         // set varbind length

    lpStringArray[2] = (TCHAR *) SNMP_malloc(strlen(lpszSource + strlen(lpszSource) + 1) + 1);  // allocate storage for string
    if (lpStringArray[2] == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for computer name string. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_COMPUTER_NAME_STORAGE);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Insertion string 2 address at %08X\n",
        lpStringArray[2]);

    strcpy(lpStringArray[2], lpszSource + strlen(lpszSource) + 1);  // copy to varbind
    lpStrLenArray[2] = strlen(lpStringArray[2]);                // get actual string length

    _ultoa(EventBuffer->EventType, szTempBuffer, 10);   // convert to string
    lpStrLenArray[3] = strlen(szTempBuffer);            // get actual string length

    lpStringArray[3] = (TCHAR *) SNMP_malloc(lpStrLenArray[3] + 1); // allocate storage for string

    if (lpStringArray[3] == NULL)
    {
        lpStrLenArray[3] = 0;                   // reset to 0 so storage isn't freed
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for event type string. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_EVENT_TYPE_STORAGE);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Insertion string 3 address at %08X\n",
        lpStringArray[3]);

    strcpy(lpStringArray[3], szTempBuffer);     // copy string to varbind

    _ultoa(EventBuffer->EventCategory, szTempBuffer, 10);   // convert to string
    lpStrLenArray[4] = strlen(szTempBuffer);                // get actual string length

    lpStringArray[4] = (TCHAR *) SNMP_malloc(lpStrLenArray[4] + 1); // allocate storage for string

    if (lpStringArray[4] == NULL)
    {
        lpStrLenArray[4] = 0;                   // reset to 0 so storage isn't freed
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for event category string. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_EVENT_CATEGORY_STORAGE);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Insertion string 4 address at %08X\n",
        lpStringArray[4]);

    strcpy(lpStringArray[4], szTempBuffer);     // copy string to varbind

//
//  At this point, we have everything we need to actually build the varbind entries
//  We will now allocate the storage for the varbind queue entry, allocate the varbind list
//  and point to the data that we have previously constructed.
//
//  Storage allocated will be freed by SNMP or by the TrapExtension routine after the trap
//  has been sent. If an error conditions occurs during the building of the varbind, then
//  any allocated storage must be freed in this routine.
//

    varBindEntry = (PVarBindQueue) SNMP_malloc(sizeof(VarBindQueue));   // get varbind queue entry storage

    if (varBindEntry == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for varbind queue entry. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_VARBIND_ENTRY_STORAGE);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);      // free allocated storage

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Storage allocated for varbind queue entry at address at %08X\n",
        varBindEntry);

    varBindEntry->lpNextQueueEntry = NULL;                              // set forward pointer to null
    varBindEntry->dwEventID = EventBuffer->EventID;                     // set event id
    varBindEntry->dwEventTime = EventBuffer->TimeGenerated - dwTimeZero;// set event time
    varBindEntry->fProcessed = FALSE;                                   // indicate trap not processed yet

    varBindEntry->lpVariableBindings = (RFC1157VarBindList *) SNMP_malloc(sizeof(RFC1157VarBindList));  // allocate storage for varbind list

    if (varBindEntry->lpVariableBindings == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for varbind list. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOC_VARBIND_LIST_STORAGE);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);  // free allocated storage
        SNMP_free(varBindEntry);                                            // free varbind entry

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Storage allocated for varbind list at address at %08X\n",
        varBindEntry->lpVariableBindings);

    varBindEntry->lpVariableBindings->list = (RFC1157VarBind *) SNMP_malloc(
        (EventBuffer->NumStrings+5) * sizeof(RFC1157VarBind));  // allocate storage for varbinds

    if (varBindEntry->lpVariableBindings->list == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for varbind. Trap not sent.\n");
        WriteLog(SNMPELEA_ERROR_ALLOC_VAR_BIND);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);  // free allocated storage
        SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
        SNMP_free(varBindEntry);                                            // free varbind entry

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Storage allocated for varbind array at address at %08X\n",
        varBindEntry->lpVariableBindings->list);

    varBindEntry->lpVariableBindings->len = EventBuffer->NumStrings+5;      // set # of varbinds

    WriteTrace(0x00,"BuildTrapBuffer: Number of varbinds present set to %lu\n",
        varBindEntry->lpVariableBindings->len);

    varBindEntry->enterprise = (AsnObjectIdentifier *) SNMP_malloc(sizeof(AsnObjectIdentifier));    // allocate storage for entprise OID

    if (varBindEntry->enterprise == NULL)
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to allocate storage for enterprise OID. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_ALLOC_ENTERPRISE_OID);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);  // free allocated storage
        SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
        SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
        SNMP_free(varBindEntry);                                            // free varbind entry

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x00,"BuildTrapBuffer: Storage allocated for enterprise OID at address at %08X\n",
        varBindEntry->enterprise);

    if ( !StrToOid((char *) rsRegStruct.szOID, varBindEntry->enterprise) )
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to convert OID from buffer. Trap not sent.\n");
        WriteLog(SNMPELEA_CANT_CONVERT_ENTERPRISE_OID);

        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray);  // free allocated storage
        SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
        SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
        SNMP_free(varBindEntry->enterprise);                                // free storage for enterprise OID
        SNMP_free(varBindEntry);                                            // free varbind entry

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    size = BASE_PDU_SIZE + (varBindEntry->enterprise->idLength) * sizeof(UINT);
    size += varBindEntry->lpVariableBindings->len * sizeof(RFC1157VarBind);

    for (i = 0; i < varBindEntry->lpVariableBindings->len; i++)
    {

//remove the #if 0 if no control characters are to be left in the varbinds
#if 0
        char *tmp = lpStringArray[i];

        for (int m=0; m < lpStrLenArray[i]; m++)
        {
            if (!tmp)
            {
                break;
            }

            if ((*tmp < 32) || (*tmp > 126))
            {
                *tmp = 32; //32 is the space char
            }

            tmp++;
        }
#endif

        WriteTrace(0x00,"BuildTrapBuffer: String %lu is %s\n", i, lpStringArray[i]);

        varBindEntry->lpVariableBindings->list[i].value.asnValue.string.length = lpStrLenArray[i];  // get string length
        size += lpStrLenArray[i];                                                                   // add to total size
        varBindEntry->lpVariableBindings->list[i].value.asnValue.string.stream = (PUCHAR) lpStringArray[i]; // point to string
        varBindEntry->lpVariableBindings->list[i].value.asnValue.string.dynamic = TRUE;             // indicate dynamically allocated
        varBindEntry->lpVariableBindings->list[i].value.asnType = ASN_RFC1213_DISPSTRING;           // indicate type of object

        if (g_dwVarBindPrefixSubId == 0)
        {
            // we won't prepend a sub-identifier here
            strcpy(szTempBuffer, TEXT("."));
        }
        else
        {
            // WINSE Bug# 30362, Windows Bug# 659770
            // forming a string of: ".sub-identifier.", where sub-identifier is
            // the string representation of g_dwVarBindPrefixSubId
            strcpy(szTempBuffer, TEXT("."));
            _ultoa(g_dwVarBindPrefixSubId, szTempBuffer2, 10);
            WRAP_STRCAT_A(szTempBuffer, szTempBuffer2, MAX_PATH*2);
            WRAP_STRCAT_A(szTempBuffer, TEXT("."), MAX_PATH*2); 
        }
        _ultoa(i+1, szTempBuffer2, 10);                 // convert loop counter to string
        WRAP_STRCAT_A(szTempBuffer, szTempBuffer2, MAX_PATH*2);                
        WRAP_STRCAT_A(szTempBuffer, TEXT(".0"), MAX_PATH*2);               // stick in the .0
        WriteTrace(0x00,"BuildTrapBuffer: Current OID name is %s\n", szTempBuffer);

        if ( !StrToOid((char *)&szTempBuffer, &varBindEntry->lpVariableBindings->list[i].name) )
        {
            WriteTrace(0x14,"BuildTrapBuffer: Unable to convert appended OID for variable binding %lu. Trap not sent.\n",i);
            FreeVarBind(i+1, varBindEntry->lpVariableBindings);                 // free varbind information
            SNMP_free(varBindEntry->enterprise->ids);                           // free enterprise OID field
            SNMP_free(varBindEntry->enterprise);                            // free enterprise OID field
            SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
            SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
            SNMP_free(varBindEntry);                                            // free varbind entry
                
            for (int k = i + 1; k < EventBuffer->NumStrings + 5; k++)
            {
                if (lpStrLenArray[k] != 0)
                    SNMP_free(lpStringArray[k]);
            }

            FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray, FALSE);   // free allocated storage
            WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string array %08X\n", lpStringArray);
            SNMP_free(lpStringArray);
            return (FALSE);
        }

        WriteTrace(0x00,"BuildTrapBuffer: Current OID address is %08X\n", &varBindEntry->lpVariableBindings->list[i].name);

        size += varBindEntry->lpVariableBindings->list[i].name.idLength * sizeof(UINT);
    }

    WriteTrace(0x0a,"BuildTrapBuffer: All variable bindings have been built, size of %lu\n",
        size);

    if (fTrimFlag)                      // call trim routine if requested
    {
        if (size > nMaxTrapSize)                            // if trap is too big to send
        {
            size = TrimTrap(varBindEntry->lpVariableBindings, size, rsRegStruct.fLocalTrim);    // trim trap data
            WriteTrace(0x0a,"BuildTrapBuffer: TrimTrap returned new size of %lu\n", size);

            if (size == 0 || size > nMaxTrapSize)
            {
                WriteTrace(0x14,"BuildTrapBuffer: TrimTrap could not trim buffer. Trap not sent\n");
                WriteLog(SNMPELEA_TRIM_TRAP_FAILURE);

                FreeVarBind(varBindEntry->lpVariableBindings->len, varBindEntry->lpVariableBindings);   // free varbind information
                SNMP_free(varBindEntry->enterprise->ids);                           // free enterprise OID field
                SNMP_free(varBindEntry->enterprise);                            // free enterprise OID field
                FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray, FALSE);   // free allocated storage
                SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
                SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
                SNMP_free(varBindEntry);                                                // free varbind entry
                WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string array %08X\n", lpStringArray);
                SNMP_free(lpStringArray);
                WriteTrace(0x00,"BuildTrapBuffer: Notify event handle is %08X\n", hEventNotify);
                WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
                return(FALSE);                              // exit, all is not well
            }
        }
    }

    if ( !AddBufferToQueue(varBindEntry) )          // add this buffer to the queue
    {
        WriteTrace(0x14,"BuildTrapBuffer: Unable to add trap buffer to queue. Trap not sent.\n");

        FreeVarBind(varBindEntry->lpVariableBindings->len, varBindEntry->lpVariableBindings);   // free varbind information
        SNMP_free(varBindEntry->enterprise->ids);                           // free enterprise OID field
        SNMP_free(varBindEntry->enterprise);
        FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray, FALSE);   // free allocated storage
        WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string array %08X\n", lpStringArray);
        SNMP_free(lpStringArray);
        SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
        SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
        SNMP_free(varBindEntry);                                            // free varbind entry

        WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with FALSE\n");
        return(FALSE);                          // exit
    }

    WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string array %08X\n", lpStringArray);
    SNMP_free(lpStringArray);

    WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string length array %08X\n", lpStrLenArray);
    SNMP_free(lpStrLenArray);

    WriteTrace(0x00,"BuildTrapBuffer: Notify event handle is %08X\n", hEventNotify);
    WriteTrace(0x0a,"BuildTrapBuffer: Exiting BuildTrapBuffer with TRUE\n");

    return(TRUE);                               // exit, all is well

Error:
    WriteTrace(0x14,"BuildTrapBuffer: WRAP_STRCAT_A failed on variable binding %lu. Trap not sent.\n",i);
    FreeVarBind(i+1, varBindEntry->lpVariableBindings);                 // free varbind information
    SNMP_free(varBindEntry->enterprise->ids);                           // free enterprise OID field
    SNMP_free(varBindEntry->enterprise);                            // free enterprise OID field
    SNMP_free(varBindEntry->lpVariableBindings->list);                  // free varbind storage
    SNMP_free(varBindEntry->lpVariableBindings);                        // free varbind list storage
    SNMP_free(varBindEntry);                                            // free varbind entry
            
    for (int k = i + 1; k < EventBuffer->NumStrings + 5; k++)
    {
        if (lpStrLenArray[k] != 0)
            SNMP_free(lpStringArray[k]);
    }

    FreeArrays(EventBuffer->NumStrings, lpStrLenArray, lpStringArray, FALSE);   // free allocated storage
    WriteTrace(0x0a,"BuildTrapBuffer: Freeing storage for string array %08X\n", lpStringArray);
    SNMP_free(lpStringArray);
    return (FALSE);
}

void Position_LogfilesToBootTime(BOOL* fValidHandles, PHANDLE phWaitEventPtr, DWORD* dwRecId)
{
    UINT count;
    HANDLE  hLogHandle;
    PEVENTLOGRECORD EventBuffer;
    PEVENTLOGRECORD pOrigEventBuffer;
    DWORD dwBufferSize = LOG_BUF_SIZE;
    DWORD lastError;
    BOOL fContinue;
    DWORD dwEventSize;
    DWORD dwEventNeeded;

    EventBuffer = (PEVENTLOGRECORD) SNMP_malloc(dwBufferSize);
    pOrigEventBuffer = EventBuffer;     // save start of buffer

    if ( EventBuffer == NULL )
    {
        WriteTrace(0x14,"Position_LogfilesToBootTime: Error allocating memory for log event record\n");
        WriteTrace(0x14,"Position_LogfilesToBootTime: Alert will not be processed\n");
        WriteLog(SNMPELEA_ERROR_LOG_BUFFER_ALLOCATE_BAD);   // log error message
        return;
    }

    for (count = 0; count < uNumEventLogs; count++)
    {
        if (!fValidHandles[count])
        {
            continue;
        }

        hLogHandle = *(phEventLogs+count);
        fContinue = TRUE;

        while(fContinue)    // read event log until EOF or boot time
        {
            EventBuffer = pOrigEventBuffer;
            WriteTrace(0x00,"Position_LogfilesToBootTime: Log event buffer is at address %08X\n",
                EventBuffer);
            WriteTrace(0x0a,"Position_LogfilesToBootTime: Reading log event for handle %08X\n",
                hLogHandle);

            if ( !ReadEventLog(hLogHandle,
                EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ,
                0,
                (LPVOID) EventBuffer,
                dwBufferSize,
                &dwEventSize,
                &dwEventNeeded) )
            {
                lastError = GetLastError();     // save error status
                
                if (lastError == ERROR_INSUFFICIENT_BUFFER)
                {
                    EventBuffer = (PEVENTLOGRECORD) SNMP_realloc((void*)EventBuffer, dwEventNeeded);

                    if ( EventBuffer == NULL )
                    {
                        WriteTrace(0x14,"Position_LogfilesToBootTime: Error reallocating memory for log event record\n");
                        WriteTrace(0x14,"Position_LogfilesToBootTime: Alert will not be processed\n");
                        WriteLog(SNMPELEA_ERROR_LOG_BUFFER_ALLOCATE_BAD);   // log error message
                        break;
                    }

                    pOrigEventBuffer = EventBuffer;
                    dwBufferSize = dwEventNeeded;

                    if (!ReadEventLog(hLogHandle, EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ, 0,
                        (LPVOID) EventBuffer, dwBufferSize, &dwEventSize, &dwEventNeeded))
                    {
                        lastError = GetLastError();
                    }
                }

                if (lastError != ERROR_SUCCESS)
                {
                    if (lastError == ERROR_HANDLE_EOF)
                    {
                        WriteTrace(0x0a,"Position_LogfilesToBootTime: END OF FILE of event log is reached\n");
                    }
                    else
                    {//doesn't matter what the error was, reset the eventlog handle
                        if ( !ReopenLog(count, phWaitEventPtr) )    // reopen log?
                        {
                            fValidHandles[count]= FALSE; //this log is no good!
                            break;                  // if no reopen, exit loop
                        }

                        if (lastError == ERROR_EVENTLOG_FILE_CHANGED)
                        {       // then log file must have been cleared
                            hLogHandle = *(phEventLogs+count); // load new handle
                            continue;                   // if okay, must reread records
                        }
                        else
                        {//Unknown Error! Get to the last record and continue
                            WriteTrace(0x14,"Position_LogfilesToBootTime: Error reading event log %08X record is %lu\n",
                                hLogHandle, lastError);
                            WriteLog(SNMPELEA_ERROR_READ_LOG_EVENT,
                                HandleToUlong(hLogHandle), lastError);  // log error message

                            DisplayLogRecord(EventBuffer,   // display log record
                                dwEventSize,                // size of this total read
                                dwEventNeeded);             // needed for next read
                            
                            hLogHandle = *(phEventLogs+count); // load new handle

                            if (!Position_to_Log_End(hLogHandle))
                            {
                                fValidHandles[count]= FALSE; //this log is no good!
                                break;
                            }
                        }
                    }
                    break;          // exit: finished reading this event log
                }
            } // end unable to ReadEventLog

            while (dwEventSize)
            {
                DisplayLogRecord(EventBuffer,   // display log record
                    dwEventSize,                // size of this total read
                    dwEventNeeded);             // needed for next read

                if (EventBuffer->TimeGenerated > dwLastBootTime)
                {
                    dwRecId[count] = EventBuffer->RecordNumber;
                }
                else
                {
                    fContinue = FALSE;
                    break;
                }

                dwEventSize -= EventBuffer->Length;     // drop by length of this record
                EventBuffer = (PEVENTLOGRECORD) ((LPBYTE) EventBuffer +
                    EventBuffer->Length);               // point to next record
            }
        } // end while(TRUE) , finished reading this event log
    } //end while(count <= uNumEventLogs)

    WriteTrace(0x0a,"Position_LogfilesToBootTime: Freeing log event buffer %08X\n",
        pOrigEventBuffer);
    SNMP_free(pOrigEventBuffer);  // free event log record buffer
}

DWORD  GetLastBootTime()
{
    HKEY hKeyPerflib009;
    DWORD retVal = 0;

    LONG status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009"),
    0, KEY_READ, &hKeyPerflib009);

    if (status != ERROR_SUCCESS)
    {
        return retVal;
    }

    DWORD dwMaxValueLen = 0;
    status = RegQueryInfoKey( hKeyPerflib009,
        NULL, NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, &dwMaxValueLen, NULL, NULL);


    if (status != ERROR_SUCCESS || dwMaxValueLen == 0)
    {
        RegCloseKey(hKeyPerflib009);
        return retVal;
    }

    DWORD BufferSize = dwMaxValueLen + 1;
    // prefix bug 445191
    unsigned char* lpNameStrings = new (std::nothrow) unsigned char[BufferSize];
    if (lpNameStrings == NULL)
    {
        RegCloseKey(hKeyPerflib009);
        return retVal;
    }
    // since we are here the counters should be accessible.
    // in case we fail to load them, just bail out.
    status = RegQueryValueEx( hKeyPerflib009,
                TEXT("Counter"), NULL, NULL, lpNameStrings, &BufferSize );
    if (status != ERROR_SUCCESS || BufferSize == 0)
    {
        RegCloseKey(hKeyPerflib009);
        delete [] lpNameStrings;
        return retVal;
    }
    RegCloseKey(hKeyPerflib009);
    
    DWORD dwTime = 0;
    DWORD dwSystem = 0;

    for(TCHAR* lpCurrentString = (TCHAR*)lpNameStrings; *lpCurrentString;
         lpCurrentString += (_tcslen(lpCurrentString)+1) )
    {
        DWORD dwCounter = _ttol( lpCurrentString );
        lpCurrentString += (_tcslen(lpCurrentString)+1);

        if (0 == _tcsicmp((LPTSTR)lpCurrentString, TEXT("System")))
        {
            dwSystem = dwCounter;

            if (dwTime != 0)
            {
                break;
            }
        }
        else if (0 == _tcsicmp((LPTSTR)lpCurrentString, TEXT("System Up Time")))
        {
            dwTime = dwCounter;

            if (dwSystem != 0)
            {
                break;
            }

        }
    }

    BufferSize = dwMaxValueLen + 1; // restore buffer size

    PPERF_DATA_BLOCK PerfData = (struct _PERF_DATA_BLOCK *)lpNameStrings;
    TCHAR sysBuff[40];
    _ultot(dwSystem, (TCHAR*)sysBuff, 10);
    DWORD tmpBuffsz = BufferSize;
    status = RegQueryValueEx(HKEY_PERFORMANCE_DATA,
                               sysBuff,
                               NULL,
                               NULL,
                               (LPBYTE) PerfData,
                               &BufferSize);

    
    while (status == ERROR_MORE_DATA)
    {
        if (BufferSize <= tmpBuffsz)
        {
            tmpBuffsz = tmpBuffsz * 2;
            BufferSize = tmpBuffsz;
        }

        delete [] PerfData;
        // prefix bug 445191
        PerfData = (struct _PERF_DATA_BLOCK *) new (std::nothrow) unsigned char[BufferSize];
        if (PerfData == NULL)
        {
            return retVal;
        }
        status = RegQueryValueEx(HKEY_PERFORMANCE_DATA,
                               sysBuff,
                               NULL,
                               NULL,
                               (LPBYTE) PerfData,
                               &BufferSize);
    }

    if (status == ERROR_SUCCESS)
    {

        // 5/22/98 mikemid Fix for SMS Bug1 #20662
        // SNMP trap agent fails with an invalid event handle only on NT 3.51.
        // Now I have no idea why it fails after we close this key but it does. A
        // debugger shows that the WaitForMultipleObjects() event array contains valid
        // event handles, yet commenting out this next line allows this to work properly.
        // The SNMP trap service doesn't even use this key.
        // According to the docs, we want to close this key after using it "so that
        // network transports and drivers can be removed or installed". Well, since this
        // is an already open system key, and we're local anyway, this shouldn't affect
        // anything else.
        // I'm chalking this one up as "extreme weirdness in NT 3.51".
        //===============================================================================
        RegCloseKey(HKEY_PERFORMANCE_DATA); // Bug# 293912 close this key because it caused  
                                            // problem in cluster-registry replication on Win2K.

        PPERF_OBJECT_TYPE PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfData +
                                                            PerfData->HeaderLength);

        for(DWORD i=0; (i < PerfData->NumObjectTypes) && (retVal == 0); i++ )
        {
            if (PerfObj->ObjectNameTitleIndex == dwSystem)
            {
                PPERF_COUNTER_DEFINITION PerfCntr = (PPERF_COUNTER_DEFINITION) ((PBYTE)PerfObj +
                                                                    PerfObj->HeaderLength);
                //only ever one instance of system so no need to check
                //for instances of system, just get the counter block.
                PPERF_COUNTER_BLOCK PtrToCntr = (PPERF_COUNTER_BLOCK) ((PBYTE)PerfObj +
                                PerfObj->DefinitionLength );

                // Retrieve all counters.
                for(DWORD j=0; j < PerfObj->NumCounters; j++ )
                {
                    if (dwTime == PerfCntr->CounterNameTitleIndex)
                    {
                        //got the time counter, get the data!
                        FILETIME timeRebootf;
                        memcpy(&timeRebootf, ((PBYTE)PtrToCntr + PerfCntr->CounterOffset), sizeof(FILETIME));
                        SYSTEMTIME timeReboots;

                        if (FileTimeToSystemTime(&timeRebootf, &timeReboots))
                        {
                            struct tm timeReboott;
                            timeReboott.tm_year = timeReboots.wYear - 1900;
                            timeReboott.tm_mon = timeReboots.wMonth - 1;
                            timeReboott.tm_mday = timeReboots.wDay;
                            timeReboott.tm_hour = timeReboots.wHour;
                            timeReboott.tm_min = timeReboots.wMinute;
                            timeReboott.tm_sec = timeReboots.wSecond;
                            timeReboott.tm_isdst = 0;
                            time_t tt = mktime(&timeReboott);
                            
                            if(tt != 0xffffffff)
                            {
                                tt -= _timezone;
                                retVal = (DWORD) tt;
                            }
                        }

                        break;
                    }

                    // Get the next counter.
                    PerfCntr = (PPERF_COUNTER_DEFINITION)((PBYTE)PerfCntr +
                                    PerfCntr->ByteLength);
                }
            }

            PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfObj + PerfObj->TotalByteLength);
        }
    }

    if (PerfData != NULL)
    {
        delete [] PerfData;
    }

    return retVal;
}


extern "C" {
DWORD
SnmpEvLogProc(
     IN VOID
     )

/*++

Routine Description:

    This is the log processing routine for the SNMP event log extension agent DLL.
    This is where control is passed from DLL initialization in order to determine
    if an event log entry is to generate an SNMP trap.

    An event is created for every log event handle that is opened.
    NotifyChangeEventLog is then called for each log event handle in turn, to allow
    the associated event to be signaled when a change is made to an event log.

    At this point the function waits on the list of events waiting for a log
    event to occur or for a request from the DLL process termination routine to
    shutdown. If a log eventoccurs, the log event record is analyzed, information
    extracted from the registry and, if requested, a trap buffer is built and sent to
    the trap processing routine. This routine is scheduled via a notification event.

    Once the DLL termination event is signaled, all event handles are
    closed and the thread is terminated. This returns control to process termination
    routine in the main DLL.


Arguments:

    None.

Return Value:

    A double word return value is required by the CreateThread API. This
    routine will return a value of zero (0) if all functions performed as
    expected. A value of 1 is returned if a problem was encountered.


Notes:

    ExitThread is used to return control. The return(0) statementat the end of this
    function is include only to avoid a compiler error.


--*/

{

    PHANDLE         phWaitEventPtr = NULL;     // points to Wait Event Handles
    HANDLE          hLogHandle = NULL;         // handle to log stuff
    HMODULE         hPrimHandle = NULL;        // handle to secondary parameter insertion module
    DWORD           dwEventOccur;              // event number from wait
    PEVENTLOGRECORD EventBuffer = NULL;        // Event Record from Event Log
    PEVENTLOGRECORD pOrigEventBuffer = NULL;   // original event buffer pointer
    DWORD           dwEventSize;               // for create event
    DWORD           dwEventNeeded;             // for create event
    UINT            i;                         // temporary loop variable
    LPTSTR          lpszThisModuleName = NULL ;// temporary for module name
    LPTSTR          lpszLogName = NULL;        // temporary for log name
    TCHAR           szThisEventID[34];         // temporary for event ID
    ULONG           ulValue;                   // temporary for event ID
    DWORD           lastError;                 // status of last function error
    REGSTRUCT       rsRegistryInfo;            // structure for registry information
    BOOL            fNewTrap = FALSE;          // trap ready flag
    BOOL*           fValidHandles = NULL;
    DWORD*          dwRecId = NULL;
    DWORD           dwBufferSize = LOG_BUF_SIZE;
    DWORD           dwReadOptions;
    BOOL            fErrorOut = FALSE;         // exit thread with error or not

    WriteTrace(0x0a,"SnmpEvLogProc: Entering SnmpEvLogProc routine....\n");
    WriteTrace(0x00,"SnmpEvLogProc: Value of hStopAll is %08X\n",hStopAll);
    WriteTrace(0x00,"SnmpEvLogProc: Value of phEventLogs is %08X\n",phEventLogs);

    for (i = 0; i < uNumEventLogs; i++)
    {
        WriteTrace(0x00,"SnmpEvLogProc: Event log %s(%lu) has handle of %08X\n",
            lpszEventLogs+i*(MAX_PATH+1), i, *(phEventLogs+i));
    }

//  WaitEvent structure: all notify-event-write first, stop DLL event, registry change event last

    if (fRegOk)
    {
        phWaitEventPtr = (PHANDLE) SNMP_malloc((uNumEventLogs+2) * HANDLESIZE);
    }
    else
    {
        phWaitEventPtr = (PHANDLE) SNMP_malloc((uNumEventLogs+1) * HANDLESIZE);
    }

    if (phWaitEventPtr == (PHANDLE) NULL)
    {
        WriteTrace(0x14,"SnmpEvLogProc: Unable to allocate memory for wait event array\n");
        WriteLog(SNMPELEA_CANT_ALLOCATE_WAIT_EVENT_ARRAY);
        WriteTrace(0x14,"SnmpEvLogProc: SnmpEvLogProc abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);  // log error message

        fErrorOut = TRUE;
        goto Exit;
    }

    fValidHandles = (BOOL*) SNMP_malloc((uNumEventLogs) * sizeof(BOOL));
    
    if (fValidHandles == (BOOL*) NULL)
    {
        WriteTrace(0x14,"SnmpEvLogProc: Unable to allocate memory for boolean array\n");
        WriteLog(SNMPELEA_ALLOC_EVENT);
        WriteTrace(0x14,"SnmpEvLogProc: SnmpEvLogProc abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);  // log error message

        fErrorOut = TRUE;
        goto Exit;
    }

    dwRecId = (DWORD*) SNMP_malloc((uNumEventLogs) * sizeof(DWORD));
    
    if (dwRecId == (DWORD*) NULL)
    {
        WriteTrace(0x14,"SnmpEvLogProc: Unable to allocate memory for record ID array\n");
        WriteLog(SNMPELEA_ALLOC_EVENT);
        WriteTrace(0x14,"SnmpEvLogProc: SnmpEvLogProc abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);  // log error message

        fErrorOut = TRUE;
        goto Exit;
    }

    for (i = 0; i < uNumEventLogs; i++)
    {
        WriteTrace(0x00,"SnmpEvLogProc: CreateEvent/ChangeNotify loop pass %lu\n",i);
        fValidHandles[i] = TRUE;
        dwRecId[i] = 0;

        if ( (hLogHandle = CreateEvent(
            (LPSECURITY_ATTRIBUTES) NULL,
            FALSE,
            FALSE,
            (LPTSTR) NULL)) == NULL )
        {
            lastError = GetLastError();     // save error status
            WriteTrace(0x14,"SnmpEvLogProc: Error creating event for log notify is %lu\n",
                lastError);
            WriteLog(SNMPELEA_ERROR_CREATE_LOG_NOTIFY_EVENT, lastError);    // log error message

            fErrorOut = TRUE;
            goto Exit;
        }
        else
        {
            *(phWaitEventPtr+i) = hLogHandle;
        }

        WriteTrace(0x00,"SnmpEvLogProc: CreateEvent returned handle of %08X\n",
            hLogHandle);
        WriteTrace(0x00,"SnmpEvLogProc: Handle address is %08X\n",phWaitEventPtr+i);
        WriteTrace(0x00,"SnmpEvLogProc: Handle contents by pointer is %08X\n",
            *(phWaitEventPtr+i));

        // Associate each event log to its notify-event-write event handle
        WriteTrace(0x00,"SnmpEvLogProc: ChangeNotify on log handle %08X\n",
            *(phEventLogs+i));
        WriteTrace(0x00,"SnmpEvLogProc: Address of log handle %08X\n",phEventLogs+i);

        if (!NotifyChangeEventLog(*(phEventLogs+i),*(phWaitEventPtr+i)))
        {
            lastError = GetLastError();
            WriteTrace(0x14,"SnmpEvLogProc: NotifyChangeEventLog failed with code %lu\n",
                lastError);
            WriteLog(SNMPELEA_ERROR_LOG_NOTIFY, lastError); // log error message

            // skip change notification from this eventlog
        }
        else
        {
            WriteTrace(0x00,"SnmpEvLogProc: ChangeNotify was successful\n");
        }

    } // end for

    *(phWaitEventPtr+uNumEventLogs) = hStopAll; // set shutdown event

    if (fRegOk)
    {
        *(phWaitEventPtr+uNumEventLogs+1) = hRegChanged;    // set registry changed event
    }

    WriteTrace(0x00,"SnmpEvLogProc: Termination event is set to %08X\n",
        *(phWaitEventPtr+uNumEventLogs));
    WriteTrace(0x00,"SnmpEvLogProc: Address of termination event is %08X\n",
        phWaitEventPtr+uNumEventLogs);
    WriteTrace(0x00,"SnmpEvLogProc: On entry, handle value is %08X\n",
        hStopAll);

    if (fRegOk)
    {
        WriteTrace(0x00,"SnmpEvLogProc: Registry notification event is set to %08X\n",
            *(phWaitEventPtr+uNumEventLogs+1));
        WriteTrace(0x00,"SnmpEvLogProc: Address of registry notification event is %08X\n",
            phWaitEventPtr+uNumEventLogs+1);
        WriteTrace(0x00,"SnmpEvLogProc: On entry, handle value is %08X\n",
            hRegChanged);
    }

    hMutex = CreateMutex(                   // create mutex object
        NULL,                               // no security attributes
        TRUE,                               // initial ownership desired
        MUTEX_NAME);                        // name of mutex object

    lastError = GetLastError();             // get any error codes

    WriteTrace(0x0a,"SnmpEvLogProc: CreateMutex returned handle of %08X and reason code of %lu\n",
        hMutex, lastError);

    if (hMutex == NULL)
    {
        WriteTrace(0x14,"SnmpEvLogProc: Unable to create Mutex object %s, reason code %lu\n",
            MUTEX_NAME, lastError);
        WriteLog(SNMPELEA_CREATE_MUTEX_ERROR, MUTEX_NAME, lastError);
        WriteTrace(0x14,"SnmpEvLogProc: SnmpEvLogProc abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);  // log error message
        
        fErrorOut = TRUE;
        goto Exit;
    }

    WriteTrace(0x0a,"SnmpEvLogProc: Created mutex object handle is %08X\n", hMutex);

    WriteTrace(0x0a,"SnmpEvLogProc: Releasing mutex object %08X\n", hMutex);
    if (!ReleaseMutex(hMutex))
    {
        lastError = GetLastError();     // get error information
        WriteTrace(0x14,"SnmpEvLogProc: Unable to release mutex object for reason code %lu\n",
            lastError);
        WriteLog(SNMPELEA_RELEASE_MUTEX_ERROR, lastError);
    }

    if (fDoLogonEvents)
    {
        DWORD dwboot = GetLastBootTime();

        if ((dwLastBootTime == 0) || (dwboot > dwLastBootTime))
        {
            RegSetValueEx(hkRegResult, EXTENSION_LASTBOOT_TIME, 0, REG_DWORD, (CONST BYTE *)&dwboot, 4);
        }

        if (dwboot > dwLastBootTime)
        {
            dwLastBootTime = dwboot;
        }
        else
        {
            fDoLogonEvents = FALSE;
        }
    }

// Wait repeatedly for any event in phWaitEventPtr to occur
    EventBuffer = (PEVENTLOGRECORD) SNMP_malloc(dwBufferSize);
    pOrigEventBuffer = EventBuffer;     // save start of buffer
    WriteTrace(0x0a,"SnmpEvLogProc: Allocating memory for log event record\n");

    if ( EventBuffer == NULL )
    {
        WriteTrace(0x14,"SnmpEvLogProc: Error allocating memory for log event record\n");
        WriteLog(SNMPELEA_ERROR_LOG_BUFFER_ALLOCATE_BAD);   // log error message
        WriteTrace(0x14,"SnmpEvLogProc: SnmpEvLogProc abnormal initialization\n");
        WriteLog(SNMPELEA_ABNORMAL_INITIALIZATION);  // log error message

        fErrorOut = TRUE;
        goto Exit;
    }

    // ensures null terminated string when calling GetRegistryValue()
    rsRegistryInfo.szOID[2*MAX_PATH] = 0;
    while (TRUE)
    {
        fNewTrap = FALSE;               // reset trap built indicator
        WriteTrace(0x0a,"SnmpEvLogProc: Waiting for event to occur\n");

        WriteTrace(0x0a,"SnmpEvLogProc: Normal event wait in progress\n");

        if (fDoLogonEvents && !(fThresholdEnabled && fThreshold))
        {
            fDoLogonEvents = FALSE;
            dwEventOccur = 0;
            Position_LogfilesToBootTime(fValidHandles, phWaitEventPtr, dwRecId);
        }
        else
        {
            if (!fRegOk)
            {
                if (nTraceLevel == 0)
                {
                    for (i = 0; i < uNumEventLogs+1; i++)
                    {
                        WriteTrace(0x00,"SnmpEvLogProc: Event handle %lu is %08X\n", i, *(phWaitEventPtr+i));
                    }
                }

                dwEventOccur = WaitForMultipleObjects(
                    uNumEventLogs+1,                // number of events
                    phWaitEventPtr,                 // array of event handles
                    FALSE,                          // no overlapped i/o
                    g_dwEventLogPollTime);          // either INFINITE or user specified registry value
            }
            else
            {
                if (nTraceLevel == 0)
                {
                    for (i = 0; i < uNumEventLogs+2; i++)
                    {
                        WriteTrace(0x00,"SnmpEvLogProc: Event handle %lu is %08X\n", i, *(phWaitEventPtr+i));
                    }
                }
                dwEventOccur = WaitForMultipleObjects(
                    uNumEventLogs+2,                // number of events
                    phWaitEventPtr,                 // array of event handles
                    FALSE,                          // no overlapped i/o
                    g_dwEventLogPollTime);          // either INFINITE or user specified registry value
            }
        }

        lastError = GetLastError();     // save error status
        WriteTrace(0x0a,"SnmpEvLogProc: EventOccur value: %lu\n", dwEventOccur);

        if (dwEventOccur == WAIT_FAILED)                        // Wait didn't work
        {
            WriteTrace(0x14,"SnmpEvLogProc: Error waiting for event array is %lu\n",
                lastError);                 // trace error message
            WriteLog(SNMPELEA_ERROR_WAIT_ARRAY, lastError); // log error message
            
            fErrorOut = TRUE;
            goto Exit;
        }

        if (dwEventOccur != WAIT_TIMEOUT)
        {
            dwEventOccur -= WAIT_OBJECT_0; // normalize array index
        }
        // note that hStopAll is a manual reset event object
        if (WAIT_OBJECT_0 == WaitForSingleObject (hStopAll, 0))
        {
            WriteTrace(0x0a,"SnmpEvLogProc: Event detected DLL shutdown\n");

            goto Exit;
        }

        if (fRegOk)
        {
            if (dwEventOccur == uNumEventLogs+1)
            {
                WriteTrace(0x0a,"SnmpEvLogProc: Event detected registry key change. Rereading registry parameters.\n");
                if (!Read_Registry_Parameters())
                {
                    WriteTrace(0x14,"SnmpEvLogProc: Error reading registry information. DLL is terminating.\n");
                    WriteLog(SNMPELEA_REGISTRY_INIT_ERROR);

                    fErrorOut = TRUE;
                    goto Exit;
                }
                else
                {
                    WriteTrace(0x0a,"SnmpEvLogProc: Registry parameters have been refreshed.\n");
                    continue;                       // skip other event log processing stuff
                }
            }
        }

        DWORD dwEvnt = 0;
        DWORD count = 0;

        while (count <= uNumEventLogs)
        {
            if (WAIT_OBJECT_0 == WaitForSingleObject (hStopAll, 0))
            {
                WriteTrace(0x0a,"SnmpEvLogProc: Event detected DLL shutdown\n");
                
                goto Exit;
            }

            dwEvnt++;

            if (dwEvnt == uNumEventLogs)
            {
                dwEvnt = 0;
            }

            if (!fValidHandles[dwEvnt])
            {
                count++;
                continue;
            }

            hLogHandle = *(phEventLogs+dwEvnt);
            hPrimHandle = *(phPrimHandles+dwEvnt);
            lpszLogName = lpszEventLogs+dwEvnt*(MAX_PATH+1);

            WriteTrace(0x0a,"SnmpEvLogProc: Event detected log record written for %s - %lu - %08X\n",
                lpszLogName, dwEvnt, hLogHandle);

            if (fThresholdEnabled && fThreshold)
            {
                WriteTrace(0x0a,"SnmpEvLogProc: Performance threshold flag is on. No data will be processed.\n");
                break;
            }

            while(TRUE)                         // read event log until EOF
            {
                if (WAIT_OBJECT_0 == WaitForSingleObject (hStopAll, 0))
                {
                    WriteTrace(0x0a,"SnmpEvLogProc: Event detected DLL shutdown\n");

                    goto Exit;
                }

                EventBuffer = pOrigEventBuffer;
                WriteTrace(0x00,"SnmpEvLogProc: Log event buffer is at address %08X\n",
                    EventBuffer);
                WriteTrace(0x0a,"SnmpEvLogProc: Reading log event for handle %08X\n",
                    hLogHandle);
                
                if (dwRecId[dwEvnt] != 0)
                {
                    dwReadOptions = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
                }
                else
                {
                    dwReadOptions = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ;
                }

                if ( !ReadEventLog(hLogHandle,
                    dwReadOptions,
                    dwRecId[dwEvnt],
                    (LPVOID) EventBuffer,
                    dwBufferSize,
                    &dwEventSize,
                    &dwEventNeeded) )
                {
                    lastError = GetLastError();     // save error status
                    
                    // mikemid 12/01/97, hotfix for SMS Bug1 # 11963.
                    // If we ran out of buffer space, take the returned value in dwEventNeeded
                    // and realloc a big enough buffer to load in the data.
                    //========================================================================
                    if (lastError == ERROR_INSUFFICIENT_BUFFER)
                    {
                        

                        EventBuffer = (PEVENTLOGRECORD) SNMP_realloc((void*)EventBuffer, dwEventNeeded);

                        if ( EventBuffer == NULL )
                        {
                            WriteTrace(0x14,"SnmpEvLogProc: Error reallocating memory for log event record\n");
                            WriteTrace(0x14,"SnmpEvLogProc: Alert will not be processed\n");
                            WriteLog(SNMPELEA_ERROR_LOG_BUFFER_ALLOCATE_BAD);   // log error message
                            
                            break;
                        }

                        lastError = ERROR_SUCCESS;
                        
                        // transfer values
                        pOrigEventBuffer = EventBuffer;
                        dwBufferSize = dwEventNeeded;

                        if (!ReadEventLog(hLogHandle, dwReadOptions, dwRecId[dwEvnt],
                            (LPVOID) EventBuffer, dwBufferSize, &dwEventSize, &dwEventNeeded))
                        {
                            lastError = GetLastError();
                            dwRecId[dwEvnt] = 0;
                        }
                    }

                    if (lastError != ERROR_SUCCESS)
                    {
                        if (lastError == ERROR_HANDLE_EOF)
                        {
                            WriteTrace(0x0a,"SnmpEvLogProc: END OF FILE of event log is reached\n");
                            count++;
                        }
                        else
                        {   //doesn't matter what the error was, reset the eventlog handle
                            if ( !ReopenLog(dwEvnt, phWaitEventPtr) )   // reopen log?
                            {
                                fValidHandles[dwEvnt]= FALSE; //this log is no good!
                                count++;
                                break;                  // if no reopen, exit loop
                            }

                            if (lastError == ERROR_EVENTLOG_FILE_CHANGED)
                            {   // then log file must have been cleared
                                hLogHandle = *(phEventLogs+dwEvnt); // load new handle
                                continue;                   // if okay, must reread records
                            }
                            else
                            {   //Unknown Error! Get to the last record and continue
                                WriteTrace(0x14,"SnmpEvLogProc: Error reading event log %08X record is %lu\n",
                                    hLogHandle, lastError);
                                WriteLog(SNMPELEA_ERROR_READ_LOG_EVENT,
                                        HandleToUlong(hLogHandle), lastError);  // log error message
                                hLogHandle = *(phEventLogs+dwEvnt); // load new handle
                                count++;

                                if (!Position_to_Log_End(hLogHandle))
                                {
                                    fValidHandles[dwEvnt]= FALSE; //this log is no good!
                                    CloseEventLog(hLogHandle);  
                                    *(phEventLogs+dwEvnt) = NULL; 
                                    break;
                                }
                            }
                        }

                        break;          // exit: finished reading this event log
                    }
                } // end unable to ReadEventLog
                
                dwRecId[dwEvnt] = 0;
                count = 0;
                
                while (dwEventSize)
                {
                    if (WAIT_OBJECT_0 == WaitForSingleObject (hStopAll, 0))
                    {
                        WriteTrace(0x0a,"SnmpEvLogProc: Event detected DLL shutdown\n");
                        goto Exit;
                    }

                    DisplayLogRecord(EventBuffer,   // display log record
                        dwEventSize,                // size of this total read
                        dwEventNeeded);             // needed for next read

                    WriteTrace(0x00,"SnmpEvLogProc: Preparing to read config file values\n");

                    lpszThisModuleName = (LPTSTR) EventBuffer + EVENTRECSIZE;

                    ulValue = EventBuffer->EventID;
    //              ulValue = ulValue & 0x0000FFFF; // trim off high order stuff
                    _ultoa(ulValue, szThisEventID, 10);

                    WriteTrace(0x00,"SnmpEvLogProc: Event ID converted to ASCII\n");
                    WriteTrace(0x00,"SnmpEvLogProc: Source is %s. Event ID is %s.\n",
                        lpszThisModuleName,
                        szThisEventID);

                    if ( GetRegistryValue(
                        lpszThisModuleName,
                        szThisEventID,
                        lpszLogName,
                        EventBuffer->TimeGenerated,
                        &rsRegistryInfo) )
                    {
                        WriteTrace(0x0a,"SnmpEvLogProc: This event is being tracked -- formatting trap buffer\n");
                        if ( !BuildTrapBuffer(EventBuffer, rsRegistryInfo, lpszLogName, hPrimHandle) )
                        {
                            WriteTrace(0x14,"SnmpEvLogProc: Unable to build trap buffer. Trap not sent.\n");
                        }
                        else
                        {
                            fNewTrap = TRUE;            // indicate a new trap buffer built
                        }

                        WriteTrace(0x00,"SnmpEvLogProc: Notify event handle is %08X\n", hEventNotify);  
                    }

                    dwEventSize -= EventBuffer->Length;     // drop by length of this record
                    EventBuffer = (PEVENTLOGRECORD) ((LPBYTE) EventBuffer +
                        EventBuffer->Length);               // point to next record

                }

            } // end while(TRUE) , finished reading this event log

            if (fNewTrap)
            {
                WriteTrace(0x0a,"SnmpEvLogProc: A new trap buffer was added -- posting notification event %08X\n",
                    hEventNotify);
                if ( !SetEvent(hEventNotify) )
                {
                    lastError = GetLastError();             // get error return codes
                    WriteTrace(0x14,"SnmpEvLogProc: Unable to post event %08X; reason is %lu\n",
                        hEventNotify, lastError);
                    WriteLog(SNMPELEA_CANT_POST_NOTIFY_EVENT, HandleToUlong(hEventNotify), lastError);
                }
                fNewTrap = FALSE;
            }
        } //end while(count < uNumEventLogs)
    } // end while(TRUE) loop

Exit:

    // cleanup if necessary
    if (phWaitEventPtr != (PHANDLE) NULL)
    {
        CloseEvents(phWaitEventPtr);    // close event handles
        phWaitEventPtr = NULL;
    }

    WriteTrace(0x0a,"SnmpEvLogProc: Closing mutex handle %08X\n", hMutex);
    if (hMutex)
    {
        CloseHandle(hMutex);
        hMutex = NULL;
    }
    
    WriteTrace(0x0a,"SnmpEvLogProc: Freeing event log record buffer %08X\n", pOrigEventBuffer);
    SNMP_free(pOrigEventBuffer);  // free event log record buffer if necessary
    SNMP_free(fValidHandles);     // free array of flags if necessary
    SNMP_free(dwRecId);           // free array of record id if necessary

    if (fErrorOut)
    {
        WriteTrace(0x0a,"SnmpEvLogProc: Exiting SnmpEvLogProc via abnormal shutdown\n");
        StopAll();                  // indicate dll in shutdown
        DoExitLogEv(1);             // exit this thread
    }
    else
    {
        WriteTrace(0x0a,"SnmpEvLogProc: Exiting SnmpEvLogProc via normal shutdown\n");
        DoExitLogEv(0);             // exit this thread
    }
    return(0);                      // to appease the compiler

} // end of SnmpEvLogProc

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\operation.h ===
#ifndef _EVENTOP_H
#define _EVENTOP_H

typedef enum
{
    OP_ADD_EVENT,
    OP_DEL_EVENT,
    OP_ADD_TRAP,
    OP_DEL_TRAP
} tOperation;

class COperation
{
protected:
    tOperation m_Operation;
    COperation *m_pNextOperation;

    DWORD CheckedStrToDword(DWORD & dwDword, char *szDword);
public:
    COperation(tOperation operation);
    virtual ~COperation();

    virtual DWORD   ParseCmdArgs() = 0;
    COperation*     Insert(COperation *pOperation);
    COperation*     GetNextOp();

    virtual DWORD   ProcessCommand() = 0;
};

class COpEvents : public COperation
{
    char    *m_szEventSource;
    DWORD   m_dwEventID;
    DWORD   m_dwCount;
    DWORD   m_dwTime;
public:
    COpEvents(tOperation operation);
    ~COpEvents();

    DWORD   ParseCmdArgs();
    DWORD   ProcessCommand();
};

class COpTraps : public COperation
{
    char    *m_szCommunity;
    char    *m_szAddress;
public:
    COpTraps(tOperation operation);
    ~COpTraps();

    DWORD   ParseCmdArgs();
    DWORD   ProcessCommand();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\parser.h ===
#include "Operation.h"

#ifndef _PARSER_H
#define _PARSER_H

#define INPUT_BUFFER_SZ     256
#define INPUT_TOKEN_SZ      80

#define TOKEN_SZ_BLANKS        " \t\n\r"
#define TOKEN_CH_COM_DELIM     ';'
#define TOKEN_CH_NL            '\n'
#define TOKEN_CH_STR_DELIM     '\"'

#define KEYWORD_PRAGMA         "#pragma"
#define KEYWORD_CMD_ADD_EVENT  "ADD"
#define KEYWORD_CMD_DEL_EVENT  "DELETE"
#define KEYWORD_CMD_ADD_TRAP   "ADD_TRAP_DEST"
#define KEYWORD_CMD_DEL_TRAP   "DELETE_TRAP_DEST"

class COperation;

class CParser
{
    COperation  *m_pOperList;

    int          m_fdInput;
    char         m_szInput[INPUT_BUFFER_SZ];
    char        *m_pInput;

    DWORD OpenInputFile();
    DWORD ReloadInputBuffer();
    DWORD AdvanceInputPointer();
public:
    DWORD        m_nLineNo;
    DWORD        m_nTokenNo;

    CParser();
    ~CParser();

    DWORD GetNextToken(char *pToken, int nSizeToken);
    DWORD UnGetToken(char *szToken);
    DWORD CheckUnGetToken(char *pMatchToken, char *pToken);

    DWORD ParseInputFile();
    DWORD ParseCommand(tOperation opType);

    DWORD ProcessCommands();
};

extern CParser gParser;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\registry.h ===
#ifndef _REGISTRY_H
#define _REGISTRY_H

#define REGPATH_SNMPTRAPS   "SYSTEM\\CurrentControlSet\\Services\\SNMP\\Parameters\\TrapConfiguration"
#define REGPATH_EVNTAGENT   "Software\\Microsoft\\SNMP_EVENTS\\EventLog\\Sources"

#define REG_SRC_ENTOID     "EnterpriseOID"
#define REG_SRC_APPEND     "Append"

#define REG_EVNT_COUNT     "Count"
#define REG_EVNT_ID        "FullID"
#define REG_EVNT_TIME      "Time"

#define REG_FLG_NEEDRESTART 1

class CRegistry
{
    HKEY    m_hRegRoot;
    HKEY    m_hRegSnmpTraps;
    HKEY    m_hRegEvntSources;

    DWORD ConfigureRegSource(HKEY hRegSource, char *szEventSource);
    DWORD ConfigureRegEvent(HKEY hRegEvent, DWORD dwEventID, DWORD dwCount, DWORD dwTime);
    DWORD ScanForTrap(HKEY hRegCommunity, char *szAddress, char *szName, DWORD & nNameLen);

public:
    DWORD   m_dwFlags;

    CRegistry();
    ~CRegistry();

    DWORD Connect();

    DWORD AddEvent(char *szEventSource, DWORD dwEventID, DWORD dwCount, DWORD dwTime);
    DWORD DelEvent(char *szEventSource, DWORD dwEventID);
    DWORD AddTrap(char *szCommunity, char *szAddress);
    DWORD DelTrap(char *szCommunity, char *szAddress);
};

extern CRegistry gRegistry;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\registry.cpp ===
#include <stdafx.h>
#include "Errors.h"
#include "EventCmd.h"
#include "Registry.h"
#include "Operation.h"

CRegistry gRegistry;

DWORD CRegistry::ConfigureRegSource(HKEY hRegSource, char *szEventSource)
{
    DWORD retCode;
    char *szSourceOID;
    char *szEventDup;
    int   nIndex;
    DWORD dwAppend;

    szSourceOID = new char[4*strlen(szEventSource) + 9];
    if (szSourceOID == NULL)
        return _E(ERROR_OUTOFMEMORY, IDS_ERR01);

    nIndex = sprintf(szSourceOID, "%u.", strlen(szEventSource));
    for (szEventDup = szEventSource; *szEventDup != '\0'; szEventDup++)
        nIndex += sprintf(szSourceOID+nIndex,"%d.",*szEventDup);

    if (nIndex == 0)
    {
        retCode = _E(ERROR_FUNCTION_FAILED, IDS_ERR05, szEventSource);
        goto done;
    }
    szSourceOID[--nIndex]='\0';

    retCode = RegSetValueEx(
                hRegSource,
                REG_SRC_ENTOID,
                0,
                REG_SZ,
                (const BYTE *)szSourceOID,
                nIndex);
    if (retCode != ERROR_SUCCESS)
    {
        retCode = _E(retCode, IDS_ERR11, REG_SRC_ENTOID, szEventSource);
        goto done;
    }

    dwAppend = 1;
    retCode = RegSetValueEx(
                hRegSource,
                REG_SRC_APPEND,
                0,
                REG_DWORD,
                (const BYTE *)&dwAppend,
                sizeof(DWORD));
    if (retCode != ERROR_SUCCESS)
    {
        retCode = _E(retCode, IDS_ERR11, REG_SRC_APPEND, szEventSource);
        goto done;
    }

    _W(WARN_TRACK, IDS_TRCK_WRN33, szEventSource);
done:
    delete szSourceOID;
    return retCode;
}

DWORD CRegistry::ConfigureRegEvent(HKEY hRegEvent, DWORD dwEventID, DWORD dwCount, DWORD dwTime)
{
    DWORD retCode = ERROR_SUCCESS;

    retCode = RegSetValueEx(
                hRegEvent,
                REG_EVNT_ID,
                0,
                REG_DWORD,
                (const BYTE *)&dwEventID,
                sizeof(DWORD));
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR13, REG_EVNT_ID, dwEventID);
    retCode = RegSetValueEx(
                hRegEvent,
                REG_EVNT_COUNT,
                0,
                REG_DWORD,
                (const BYTE *)&dwCount,
                sizeof(DWORD));
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR13, REG_EVNT_COUNT, dwEventID);
    retCode = RegSetValueEx(
                hRegEvent,
                REG_EVNT_TIME,
                0,
                REG_DWORD,
                (const BYTE *)&dwTime,
                sizeof(DWORD));
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR13, REG_EVNT_TIME, dwEventID);

    return retCode;
}

DWORD CRegistry::ScanForTrap(HKEY hRegCommunity, char *szAddress, char *szName, DWORD & nNameLen)
{
    DWORD   retCode;
    DWORD   nMaxName = 1;
    char    szDataBuffer[64];

    for (DWORD i = 0, iNameLen = nNameLen, iDataLen = 64;
         (retCode = RegEnumValue(
                     hRegCommunity,
                     i,
                     szName,
                     &iNameLen,
                     0,
                     NULL,
                     (BYTE *)szDataBuffer,
                     &iDataLen)) == ERROR_SUCCESS;
         i++, iNameLen = nNameLen, iDataLen = 64)
    {
        DWORD nNameNum;

        if (strcmp(szDataBuffer, szAddress) == 0)
            return ERROR_ALREADY_EXISTS;

        nNameNum = atoi(szName);
        if (nMaxName <= nNameNum)
            nMaxName = nNameNum+1;
    }

    if (retCode != ERROR_NO_MORE_ITEMS)
        return _E(retCode, IDS_ERR12);

    nNameLen = sprintf(szName, "%u", nMaxName);
    retCode = ERROR_SUCCESS;

    return retCode;
}

CRegistry::CRegistry()
{
    m_hRegRoot = HKEY_LOCAL_MACHINE;
    m_hRegSnmpTraps = NULL;
    m_hRegEvntSources = NULL;
    m_dwFlags = 0;
}

CRegistry::~CRegistry()
{
    if (m_hRegRoot != HKEY_LOCAL_MACHINE)
        RegCloseKey(m_hRegRoot);
    if (m_hRegSnmpTraps != NULL)
        RegCloseKey(m_hRegSnmpTraps);
    if (m_hRegEvntSources != NULL)
        RegCloseKey(m_hRegEvntSources);
}

DWORD CRegistry::Connect()
{
    DWORD retCode = ERROR_SUCCESS;

    if (gCommandLine.m_szSystem != NULL)
    {
        _W(WARN_ATTENTION,IDS_ATTN_WRN34, gCommandLine.m_szSystem);
        retCode = RegConnectRegistry(gCommandLine.m_szSystem, HKEY_LOCAL_MACHINE, &m_hRegRoot);
    }
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR14, gCommandLine.m_szSystem);
    return retCode;
}

DWORD CRegistry::AddEvent(char *szEventSource, DWORD dwEventID, DWORD dwCount, DWORD dwTime)
{
    DWORD retCode;
    DWORD dwDisposition;
    HKEY  hRegSource;
    HKEY  hRegEvent;
    char  szEventID[64];

    if (m_hRegEvntSources == NULL)
    {
        retCode = RegOpenKeyEx(
                    m_hRegRoot,
                    REGPATH_EVNTAGENT,
                    0,
                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                    &m_hRegEvntSources);
        if (retCode != ERROR_SUCCESS)
            return _E(retCode, IDS_ERR15);
    }

    retCode = RegCreateKeyEx(
                m_hRegEvntSources,
                szEventSource,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hRegSource,
                &dwDisposition);
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR16, szEventSource);
    if (dwDisposition == REG_CREATED_NEW_KEY)
    {
        retCode = ConfigureRegSource(hRegSource, szEventSource);
        if (retCode != ERROR_SUCCESS)
        {
            RegCloseKey(hRegSource);
            return retCode;
        }
    }
    sprintf(szEventID,"%u",dwEventID);
    retCode = RegCreateKeyEx(
                hRegSource,
                szEventID,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hRegEvent,
                &dwDisposition);
    if (retCode != ERROR_SUCCESS)
    {
        RegCloseKey(hRegSource);
        return _E(retCode, IDS_ERR17, szEventSource);
    }

    retCode = ConfigureRegEvent(hRegEvent, dwEventID, dwCount, dwTime);

    _W(WARN_ATTENTION, IDS_ATTN_WRN35,
        dwDisposition == REG_CREATED_NEW_KEY ? "new" : "existing",
        dwEventID);
 
    RegCloseKey(hRegSource);
    RegCloseKey(hRegEvent);

    return retCode;
}

DWORD CRegistry::DelEvent(char *szEventSource, DWORD dwEventID)
{
    DWORD       retCode;
    char        szEventID[64];
    DWORD       nSzEventID = 64;
    HKEY        hRegSource;
    FILETIME    ft;

    if (m_hRegEvntSources == NULL)
    {
        retCode = RegOpenKeyEx(
                    m_hRegRoot,
                    REGPATH_EVNTAGENT,
                    0,
                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                    &m_hRegEvntSources);
        if (retCode != ERROR_SUCCESS)
            return _E(retCode, IDS_ERR18);
    }

    retCode = RegOpenKeyEx(
                m_hRegEvntSources,
                szEventSource,
                0,
                KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                &hRegSource);
    if (retCode != ERROR_SUCCESS)
    {
        _W(WARN_ATTENTION, IDS_ATTN_WRN36, szEventSource);
        return ERROR_SUCCESS;
    }

    sprintf(szEventID,"%u",dwEventID);

    retCode = RegDeleteKey(hRegSource, szEventID);
    if (retCode != ERROR_SUCCESS)
    {
        _W(WARN_ATTENTION, IDS_ATTN_WRN37, szEventID);
        RegCloseKey(hRegSource);
        return ERROR_SUCCESS;
    }

    _W(WARN_ATTENTION, IDS_ATTN_WRN38, dwEventID);

    retCode = RegEnumKeyEx(
                hRegSource,
                0,
                szEventID,
                &nSzEventID,
                0,
                NULL,
                NULL,
                &ft);
    RegCloseKey(hRegSource);
    if (retCode == ERROR_NO_MORE_ITEMS)
    {
        retCode = RegDeleteKey(m_hRegEvntSources, szEventSource);
        if (retCode != ERROR_SUCCESS)
            return _E(retCode, IDS_ERR19, szEventSource);
        _W(WARN_TRACK, IDS_TRCK_WRN39, szEventSource);
        retCode = ERROR_SUCCESS;
    }
    else if (retCode != ERROR_SUCCESS)
    {
        _W(WARN_TRACK, IDS_TRCK_WRN40, retCode, szEventSource);
        retCode = ERROR_SUCCESS;
    }

    return retCode;
}

DWORD CRegistry::AddTrap(char *szCommunity, char *szAddress)
{
    DWORD   retCode;
    DWORD   dwDisposition;
    char    szTrapName[64];
    DWORD   nLenTrapName = 64;
    HKEY    hRegCommunity;

    if (m_hRegSnmpTraps == NULL)
    {
        retCode = RegOpenKeyEx(
                    m_hRegRoot,
                    REGPATH_SNMPTRAPS,
                    0,
                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                    &m_hRegSnmpTraps);
        if (retCode != ERROR_SUCCESS)
            return _E(retCode, IDS_ERR20);
    }

    retCode = RegCreateKeyEx(
                m_hRegSnmpTraps,
                szCommunity,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hRegCommunity,
                &dwDisposition);
    if (retCode != ERROR_SUCCESS)
        return _E(retCode, IDS_ERR21, szCommunity);
    if (dwDisposition == REG_CREATED_NEW_KEY)
        _W(WARN_TRACK, IDS_TRCK_WRN41, szCommunity);
        
    retCode = ScanForTrap(hRegCommunity, szAddress, szTrapName, nLenTrapName);
    if (retCode != ERROR_SUCCESS)
    {
        RegCloseKey(hRegCommunity);
        if (retCode == ERROR_ALREADY_EXISTS)
        {
            _W(WARN_ATTENTION, IDS_ATTN_WRN42, szAddress, szTrapName);
            retCode = ERROR_SUCCESS;
        }
        return retCode;
    }

    retCode = RegSetValueEx(
                hRegCommunity,
                szTrapName,
                0,
                REG_SZ,
                (const BYTE*)szAddress,
                strlen(szAddress));
    
    if (retCode != ERROR_SUCCESS)
        _E(retCode, IDS_ERR22, szAddress);
    else
    {
        m_dwFlags |= REG_FLG_NEEDRESTART;
        _W(WARN_ATTENTION, IDS_ATTN_WRN43, szAddress);
    }

    RegCloseKey(hRegCommunity);
    return retCode;
}

DWORD CRegistry::DelTrap(char *szCommunity, char *szAddress)
{
    DWORD   retCode;
    char    szTrapName[64];
    DWORD   nLenTrapName = 64;
    HKEY    hRegCommunity;

    if (m_hRegSnmpTraps == NULL)
    {
        retCode = RegOpenKeyEx(
                    m_hRegRoot,
                    REGPATH_SNMPTRAPS,
                    0,
                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                    &m_hRegSnmpTraps);
        if (retCode != ERROR_SUCCESS)
            return _E(retCode, IDS_ERR23);
    }

    if ((retCode = RegOpenKeyEx(
                    m_hRegSnmpTraps,
                    szCommunity,
                    0,
                    KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
                    &hRegCommunity)) == ERROR_SUCCESS  &&
        (retCode = ScanForTrap(hRegCommunity, szAddress, szTrapName, nLenTrapName)) == ERROR_ALREADY_EXISTS)
    {
        retCode = RegDeleteValue(
                    hRegCommunity,
                    szTrapName);
    
        if (retCode != ERROR_SUCCESS)
        {
            RegCloseKey(hRegCommunity);
            return _E(retCode, IDS_ERR24, szAddress);
        }
        else
        {
            m_dwFlags |= REG_FLG_NEEDRESTART;
            _W(WARN_ATTENTION, IDS_ATTN_WRN44, szAddress);
        }
    }
    else
    {
        _W(WARN_ATTENTION, IDS_ATTN_WRN45, szAddress, szCommunity);
        retCode = ERROR_SUCCESS;
    }

    retCode =  RegEnumValue(
                hRegCommunity,
                0,
                szTrapName,
                &nLenTrapName,
                0,
                NULL,
                NULL,
                NULL);

    RegCloseKey(hRegCommunity);

    if (retCode == ERROR_NO_MORE_ITEMS)
    {
        retCode = RegDeleteKey(m_hRegSnmpTraps, szCommunity);
        if (retCode != ERROR_SUCCESS)
            _W(WARN_ERROR, IDS_ERRO_WRN46, retCode, szCommunity);
        else
            _W(WARN_TRACK, IDS_TRCK_WRN47, szCommunity);
        retCode = ERROR_SUCCESS;
    }
    else if (retCode != ERROR_SUCCESS)
    {
        _W(WARN_TRACK, IDS_TRCK_WRN48, retCode, szCommunity);
        retCode = ERROR_SUCCESS;
    }
 
    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\parser.cpp ===
#include <stdafx.h>
#include "Parser.h"
#include "EventCmd.h"
#include "Errors.h"

CParser gParser;

CParser::CParser()
{
    m_pOperList = NULL;
    m_fdInput   = -1;
    m_nLineNo   = 1;
    m_nTokenNo  = 0;
    m_pInput    = m_szInput;
}

CParser::~CParser()
{
    if (m_fdInput != -1)
        _close(m_fdInput);
    if (m_pOperList != NULL)
        delete m_pOperList;
}

DWORD CParser::OpenInputFile()
{
    DWORD retCode;

    m_fdInput = _open(gCommandLine.m_szFileName, _O_RDONLY | _O_BINARY);
    retCode = GetLastError();
    if (retCode != ERROR_SUCCESS)
        _E(retCode, IDS_ERR08, gCommandLine.m_szFileName);
    else
        retCode = ReloadInputBuffer();

    return retCode;
}

DWORD CParser::ReloadInputBuffer()
{
    DWORD retCode;
    int   nBuf;

    m_pInput = m_szInput;
    nBuf = _read(m_fdInput, m_szInput, INPUT_BUFFER_SZ);
    retCode = GetLastError();
    if (retCode != ERROR_SUCCESS)
        _E(retCode, IDS_ERR09, m_nLineNo);
    else if (nBuf < INPUT_BUFFER_SZ)
        m_szInput[nBuf] = '\0';
    return retCode;
}

DWORD CParser::AdvanceInputPointer()
{
    DWORD retCode = ERROR_SUCCESS;

    if (*m_pInput == '\0')
    {
        _W(WARN_TRACK, IDS_TRCK_WRN27, m_nLineNo, m_nTokenNo);
        return ERROR_END_OF_MEDIA;
    }

    if (*m_pInput == TOKEN_CH_NL)
    {
        m_nLineNo++;
        m_nTokenNo;
        m_nTokenNo = 0;
    }

    if (m_pInput < m_szInput + INPUT_BUFFER_SZ - 1)
        m_pInput++;
    else
        retCode = ReloadInputBuffer();

    if (retCode == ERROR_SUCCESS && *m_pInput == '\0')
    {
        _W(WARN_TRACK, IDS_TRCK_WRN28, m_nLineNo, m_nTokenNo);
        retCode = ERROR_END_OF_MEDIA;
    }

    return retCode;
}

DWORD CParser::GetNextToken(char * pToken, int nSizeToken)
{
    int   i;
    DWORD nLineStrDelim;
    DWORD nTokenStrDelim;
    enum
    {
        STATE_BLANKS,
        STATE_COMMENT,
        STATE_TOKEN
    } state = STATE_BLANKS;
    DWORD retCode = ERROR_SUCCESS;

    while (retCode == ERROR_SUCCESS)
    {
        if (state == STATE_BLANKS)
        {
            if (*m_pInput == TOKEN_CH_COM_DELIM)
                state = STATE_COMMENT;
            else if (strchr(TOKEN_SZ_BLANKS, *m_pInput) == NULL)
                break;
        }
        else if (state == STATE_COMMENT)
        {
            if (*m_pInput == TOKEN_CH_NL)
                state = STATE_BLANKS;
        }

        retCode = AdvanceInputPointer();
    }

    i = 0;
    state = STATE_BLANKS;
    m_nTokenNo++;

    while (retCode == ERROR_SUCCESS &&
           *m_pInput != TOKEN_CH_COM_DELIM)
    {
        if (state == STATE_BLANKS)
        {
            if (strchr(TOKEN_SZ_BLANKS, *m_pInput) != NULL)
                break;
            if (*m_pInput == TOKEN_CH_STR_DELIM)
            {
                state = STATE_TOKEN;
                nLineStrDelim = m_nLineNo;
                nTokenStrDelim = m_nTokenNo;
                retCode = AdvanceInputPointer();
                continue;
            }
        }
        if (state == STATE_TOKEN)
        {
            if (*m_pInput == TOKEN_CH_STR_DELIM)
            {
                state = STATE_BLANKS;
                retCode = AdvanceInputPointer();
                break;
            }
        }
        pToken[i++] = *m_pInput;
        if (i >= nSizeToken)
        {
            return _E(ERROR_BUFFER_OVERFLOW, IDS_ERR04,
                      m_nLineNo, m_nTokenNo, nSizeToken);
        }
        retCode = AdvanceInputPointer();
    }

    pToken[i] = '\0';

    if (state == STATE_TOKEN)
    {
        _W(WARN_ERROR, IDS_ERRO_WRN29,
           nLineStrDelim, nTokenStrDelim);
    }

    if (i > 0 && retCode == ERROR_END_OF_MEDIA)
        retCode = ERROR_SUCCESS;

    return retCode;
}

DWORD CParser::UnGetToken(char *szToken)
{
    int nTokenLen;
    char *pInsertion;

    nTokenLen = strlen(szToken) + 2;

    if (m_pInput - m_szInput < nTokenLen)
    {
        int nDrift = nTokenLen - (int)(m_pInput - m_szInput);

        memmove(m_pInput + nDrift, m_pInput, INPUT_BUFFER_SZ - (size_t)(m_pInput - m_szInput) - nDrift);
        m_pInput += nDrift;

        if (_lseek(m_fdInput, -nDrift, SEEK_CUR) == -1)
        {
            return _E(GetLastError(), IDS_ERR10);
        }
    }

    pInsertion = m_pInput = m_pInput - nTokenLen;
    *pInsertion++ = '\"';
    strcpy(pInsertion, szToken);
    pInsertion += nTokenLen - 2;
    *pInsertion = '\"';
    m_nTokenNo--;
    return ERROR_SUCCESS;
}

DWORD CParser::CheckUnGetToken(char *pMatchToken, char *pToken)
{
    DWORD retCode = ERROR_SUCCESS;

    if (strcmp(pMatchToken, pToken) == 0 &&
        (retCode = UnGetToken(pToken)) == ERROR_SUCCESS)
        retCode = ERROR_INVALID_PARAMETER;
    return retCode;
}

DWORD CParser::ParseInputFile()
{
    DWORD retCode;
    DWORD dwSkipLine;
    enum
    {
        STATE_READ,
        STATE_SKIP
    } state = STATE_READ;


    retCode = OpenInputFile();

    if (retCode == ERROR_SUCCESS)
    {
        while(1)
        {
            char  szToken[INPUT_TOKEN_SZ];

            retCode = GetNextToken(szToken, INPUT_TOKEN_SZ);
            if (retCode != ERROR_SUCCESS)
                break;

            if (state == STATE_SKIP)
            {
                if (m_nLineNo == dwSkipLine)
                    continue;
                state = STATE_READ;
            }

            if (state == STATE_READ)
            {
                if (strcmp(szToken, KEYWORD_PRAGMA) != 0)
                {
                    _W(WARN_ALERT, IDS_ALRT_WRN30, m_nLineNo, m_nTokenNo);
                    dwSkipLine = m_nLineNo;
                    state = STATE_SKIP;
                    continue;
                }

                retCode = GetNextToken(szToken, INPUT_TOKEN_SZ);
                if (retCode != ERROR_SUCCESS)
                {
                    _W(WARN_ALERT, IDS_ALRT_WRN31, m_nLineNo, m_nTokenNo);
                    dwSkipLine = m_nLineNo;
                    state = STATE_SKIP;
                    continue;
                }

                if (_stricmp(szToken, KEYWORD_CMD_ADD_EVENT) == 0)
                    retCode = ParseCommand(OP_ADD_EVENT);
                else if (_stricmp(szToken, KEYWORD_CMD_DEL_EVENT) == 0)
                    retCode = ParseCommand(OP_DEL_EVENT);
                else if (_stricmp(szToken, KEYWORD_CMD_ADD_TRAP) == 0)
                    retCode = ParseCommand(OP_ADD_TRAP);
                else if (_stricmp(szToken, KEYWORD_CMD_DEL_TRAP) == 0)
                    retCode = ParseCommand(OP_DEL_TRAP);
                else
                {
                    retCode = ERROR_INVALID_OPERATION;
                    _W(WARN_ALERT, IDS_ALRT_WRN32,
                       m_nLineNo, m_nTokenNo, szToken);
                }

                if (retCode != ERROR_SUCCESS)
                {
                    dwSkipLine = m_nLineNo;
                    state = STATE_SKIP;
                    retCode = ERROR_SUCCESS;
                    continue;
                }
            }
        }
    }

    if (retCode == ERROR_END_OF_MEDIA)
        retCode = ERROR_SUCCESS;
    return retCode;
}

DWORD CParser::ParseCommand(tOperation opType)
{
    DWORD       retCode = ERROR_SUCCESS;
    COperation  *pOperation;

    switch(opType)
    {
    case OP_ADD_EVENT:
    case OP_DEL_EVENT:
        pOperation = new COpEvents(opType);
        break;
    case OP_ADD_TRAP:
    case OP_DEL_TRAP:
        pOperation = new COpTraps(opType);
        break;
    }
    if (pOperation == NULL)
        return _E(ERROR_OUTOFMEMORY, IDS_ERR01);

    retCode = pOperation->ParseCmdArgs();
    if (retCode == ERROR_SUCCESS)
    {
        if (m_pOperList == NULL)
            m_pOperList = pOperation;
        else
            m_pOperList = m_pOperList->Insert(pOperation);
    }
    else
        delete pOperation;

    return retCode;
}

DWORD CParser::ProcessCommands()
{
    DWORD retCode = ERROR_SUCCESS;
    COperation *pOperation;

    for (pOperation = m_pOperList;
         retCode == ERROR_SUCCESS && pOperation != NULL;
         pOperation = pOperation->GetNextOp())
        retCode = pOperation->ProcessCommand();

    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\operation.cpp ===
#include <stdafx.h>
#include "Errors.h"
#include "Parser.h"
#include "Registry.h"
#include "EventCmd.h"

COperation::COperation(tOperation operation)
{
    m_Operation = operation;
    m_pNextOperation = NULL;
}

COperation::~COperation()
{
    if (m_pNextOperation)
        delete m_pNextOperation;
}

COperation* COperation::Insert(COperation *pOperation)
{
    if (pOperation->m_Operation < m_Operation)
    {
        pOperation->m_pNextOperation = this;
        return pOperation;
    }

    if (m_pNextOperation == NULL)
        m_pNextOperation = pOperation;
    else
        m_pNextOperation = m_pNextOperation->Insert(pOperation);

    return this;
}

COperation* COperation::GetNextOp()
{
    return m_pNextOperation;
}

DWORD COperation::CheckedStrToDword(DWORD & dwDword, char *szDword)
{
    dwDword = 0;
    while (*szDword != '\0')
    {
        if (*szDword < '0' || *szDword > '9')
            return ERROR_BAD_FORMAT;
        dwDword *= 10;
        dwDword += (*szDword++ - '0');
    }

    return ERROR_SUCCESS;
}

COpEvents::COpEvents(tOperation operation) : COperation(operation)
{
    m_szEventSource = NULL;
    m_dwEventID = 0;
    m_dwCount = 1;
    m_dwTime = 0;
}

COpEvents::~COpEvents()
{
    if (m_szEventSource != NULL)
        delete m_szEventSource;
}

DWORD COpEvents::ParseCmdArgs()
{
    DWORD retCode;
    char szToken[INPUT_TOKEN_SZ];

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) != ERROR_SUCCESS ||
        (retCode = gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken)) != ERROR_SUCCESS)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN16,
           gParser.m_nLineNo,
           gParser.m_nTokenNo);
        return retCode;
    }

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) != ERROR_SUCCESS ||
        (retCode = gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken)) != ERROR_SUCCESS)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN17,
           gParser.m_nLineNo,
           gParser.m_nTokenNo);
        return retCode;
    }
    if (m_szEventSource != NULL)
        delete m_szEventSource;
    m_szEventSource = new char[sizeof(szToken) + 1];
    strcpy(m_szEventSource, szToken);

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) != ERROR_SUCCESS ||
        (retCode = gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken)) != ERROR_SUCCESS ||
        (retCode = CheckedStrToDword(m_dwEventID, szToken)) != ERROR_SUCCESS)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN18,
           gParser.m_nLineNo,
           gParser.m_nTokenNo);
        return retCode;
    }

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) == ERROR_SUCCESS)
    {
        if (gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken) != ERROR_SUCCESS)
            goto done;

        if ((retCode = CheckedStrToDword(m_dwCount, szToken)) != ERROR_SUCCESS)
        {
            _W(WARN_ALERT, IDS_ALRT_WRN19,
               gParser.m_nLineNo,
               gParser.m_nTokenNo);
            return retCode;
        }
    }

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) == ERROR_SUCCESS)
    {
        if (gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken) != ERROR_SUCCESS)
            goto done;

        if ((retCode = CheckedStrToDword(m_dwTime, szToken)) != ERROR_SUCCESS)
        {
            _W(WARN_ALERT, IDS_ALRT_WRN20,
               gParser.m_nLineNo,
               gParser.m_nTokenNo);
            return retCode;
        }
    }

    if (m_dwCount <= 1 && m_dwTime > 0)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN21,
           gParser.m_nLineNo,
           gParser.m_nTokenNo,
           m_dwTime);
        m_dwTime = 0;
    }

    if (m_dwCount >= 2 && m_dwTime == 0)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN22,
           gParser.m_nLineNo,
           gParser.m_nTokenNo,
           m_dwCount,
           m_dwTime);
    }

done:
    retCode = ERROR_SUCCESS;

    if (m_dwCount >= 2 && m_dwTime == 0)
        m_dwTime = 1;

    _W(WARN_ATTENTION, IDS_ALRT_WRN23,
        m_Operation == OP_ADD_EVENT ? "ADD" : "DELETE",
        m_szEventSource,
        m_dwEventID,
        m_dwCount,
        m_dwTime);

    return retCode;
};

DWORD COpEvents::ProcessCommand()
{
    DWORD retCode;

    switch(m_Operation)
    {
    case OP_ADD_EVENT:
        retCode = gRegistry.AddEvent(m_szEventSource, m_dwEventID, m_dwCount, m_dwTime);
        break;
    case OP_DEL_EVENT:
        retCode = gRegistry.DelEvent(m_szEventSource, m_dwEventID);
        break;
    default:
        return _E(ERROR_INTERNAL_ERROR, IDS_ERR02, m_Operation);
    }

    return retCode;
}

COpTraps::COpTraps(tOperation operation) : COperation(operation)
{
    m_szCommunity = NULL;
    m_szAddress = NULL;
}

COpTraps::~COpTraps()
{
    if (m_szCommunity != NULL)
        delete m_szCommunity;
    if (m_szAddress != NULL)
        delete m_szAddress;
}

DWORD COpTraps::ParseCmdArgs()
{
    DWORD retCode;
    char szToken[INPUT_TOKEN_SZ];

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) != ERROR_SUCCESS ||
        (retCode = gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken)) != ERROR_SUCCESS)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN24,
               gParser.m_nLineNo,
               gParser.m_nTokenNo);
        return retCode;
    }
    if (m_szCommunity != NULL)
        delete m_szCommunity;
    m_szCommunity = new char[strlen(szToken)+1];
    if (m_szCommunity == NULL)
        return _E(ERROR_OUTOFMEMORY, IDS_ERR01);
    strcpy(m_szCommunity, szToken);

    if ((retCode = gParser.GetNextToken(szToken, INPUT_TOKEN_SZ)) != ERROR_SUCCESS ||
        (retCode = gParser.CheckUnGetToken(KEYWORD_PRAGMA, szToken)) != ERROR_SUCCESS)
    {
        _W(WARN_ALERT, IDS_ALRT_WRN25,
           gParser.m_nLineNo,
           gParser.m_nTokenNo);
    }
    if (m_szAddress != NULL)
        delete m_szAddress;
    m_szAddress = new char [strlen(szToken) + 1];
    if (m_szAddress == NULL)
        return _E(ERROR_OUTOFMEMORY, IDS_ERR01);
    strcpy(m_szAddress, szToken);

    _W(WARN_ATTENTION, IDS_ATTN_WRN26,
        m_Operation == OP_ADD_TRAP ? "ADD_TRAP_DEST" : "DELETE_TRAP_DEST",
        m_szCommunity,
        m_szAddress);
    
    return ERROR_SUCCESS;
}

DWORD COpTraps::ProcessCommand()
{
    DWORD retCode;

    switch(m_Operation)
    {
    case OP_ADD_TRAP:
        retCode = gRegistry.AddTrap(m_szCommunity, m_szAddress);
        break;
    case OP_DEL_TRAP:
        retCode = gRegistry.DelTrap(m_szCommunity, m_szAddress);
        break;
    default:
        return _E(ERROR_INTERNAL_ERROR, IDS_ERR03, m_Operation);
    }

    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\eventcmd.h ===
#ifndef _EVENTCMD_H
#define _EVENTCMD_H

#define CMDLINE_DELIM               "-/"
#define CMDLINE_OPTION_HELP         "hH?"
#define CMDLINE_OPTION_VERBOSE      "vV"
#define CMDLINE_OPTION_SYSTEM       "sS"
#define CMDLINE_OPTION_NORESTART    "nN"

#define CMDLINE_FLG_NORESTART       1

#define IDS_MSG_HELP                100
#define IDS_MSG_CPYRGHT             101

#define IDS_CHKP_WRN01              111
#define IDS_CHKP_WRN02              112
#define IDS_CHKP_WRN03              113
#define IDS_CHKP_WRN04              114
#define IDS_ALRT_WRN05              115
#define IDS_ATTN_WRN06              116
#define IDS_CHKP_WRN07              117
#define IDS_CHKP_WRN08              118
#define IDS_CHKP_WRN09              119
#define IDS_ATTN_WRN10              120
#define IDS_ATTN_WRN11              121
#define IDS_ALRT_WRN12              122
#define IDS_ALRT_WRN13              123
#define IDS_ATTN_WRN14              124
#define IDS_ALRT_WRN15              125
#define IDS_ALRT_WRN16              126
#define IDS_ALRT_WRN17              127
#define IDS_ALRT_WRN18              128
#define IDS_ALRT_WRN19              129
#define IDS_ALRT_WRN20              130
#define IDS_ALRT_WRN21              131
#define IDS_ALRT_WRN22              132
#define IDS_ALRT_WRN23              133
#define IDS_ALRT_WRN24              134
#define IDS_ALRT_WRN25              135
#define IDS_ATTN_WRN26              136
#define IDS_TRCK_WRN27              137
#define IDS_TRCK_WRN28              138
#define IDS_ERRO_WRN29              139
#define IDS_ALRT_WRN30              140
#define IDS_ALRT_WRN31              141
#define IDS_ALRT_WRN32              142
#define IDS_TRCK_WRN33              143
#define IDS_ATTN_WRN34              144
#define IDS_ATTN_WRN35              145
#define IDS_ATTN_WRN36              146
#define IDS_ATTN_WRN37              147
#define IDS_ATTN_WRN38              148
#define IDS_TRCK_WRN39              149
#define IDS_TRCK_WRN40              150
#define IDS_TRCK_WRN41              151
#define IDS_ATTN_WRN42              152
#define IDS_ATTN_WRN43              153
#define IDS_ATTN_WRN44              154
#define IDS_ATTN_WRN45              155
#define IDS_ERRO_WRN46              156
#define IDS_TRCK_WRN47              157
#define IDS_TRCK_WRN48              158
#define IDS_TRCK_WRN49              159
#define IDS_TRCK_WRN50              160
#define IDS_ERR01               500
#define IDS_ERR02               501
#define IDS_ERR03               503
#define IDS_ERR04               504
#define IDS_ERR05               505
#define IDS_ERR06               506
#define IDS_ERR07               507
#define IDS_ERR08               508
#define IDS_ERR09               509
#define IDS_ERR10               510
#define IDS_ERR11               511
#define IDS_ERR12               512
#define IDS_ERR13               513
#define IDS_ERR14               514
#define IDS_ERR15               515
#define IDS_ERR16               516
#define IDS_ERR17               517
#define IDS_ERR18               518
#define IDS_ERR19               519
#define IDS_ERR20               520
#define IDS_ERR21               521
#define IDS_ERR22               522
#define IDS_ERR23               523
#define IDS_ERR24               524
#define IDS_ERR25               525
#define IDS_ERR26               526
#define IDS_ERR27               527
#define IDS_ERR28               528
#define IDS_ERR29               529
#define IDS_ERR30               530
#define IDS_ERR31               531

class CCommandLine
{
public:
    char    *m_szFileName;
    char    *m_szSystem;
    DWORD   m_nVerboseLevel;
    DWORD   m_nFlags;

    CCommandLine();
    ~CCommandLine();

    DWORD ParseCmdLine(int argc, char *argv[]);
    DWORD GetVerboseLevel();
};

extern CString      gStrMessage;
extern CCommandLine gCommandLine;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\snmpctrl.cpp ===
#include <stdafx.h>
#include "Errors.h"
#include "SNMPCtrl.h"
#include "EventCmd.h"

CSNMPController gSNMPController;

CSNMPController::CSNMPController()
{
    m_hSNMPService = NULL;
    m_hServiceController = NULL;
}

CSNMPController::~CSNMPController()
{
    if (m_hSNMPService != NULL)
        CloseServiceHandle(m_hSNMPService);
    if (m_hServiceController != NULL)
        CloseServiceHandle(m_hServiceController);
}

DWORD CSNMPController::LoadSvcHandle()
{
    if (m_hSNMPService == NULL)
    {
        if (m_hServiceController == NULL)
        {
            m_hServiceController = OpenSCManager(
                gCommandLine.m_szSystem,
		        "ServicesActive",
		        GENERIC_EXECUTE);

            if (m_hServiceController == NULL)
                return _E(GetLastError(), IDS_ERR25);
        }
	
	    m_hSNMPService = OpenService(
            m_hServiceController,
            "SNMP",
            SERVICE_CONTROL_INTERROGATE | SERVICE_START | SERVICE_STOP);

        if (m_hSNMPService == NULL)
            return _E(GetLastError(), IDS_ERR26);
    }
    return ERROR_SUCCESS;
}

BOOL CSNMPController::IsSNMPRunning()
{
    SERVICE_STATUS snmpStatus;

    if (LoadSvcHandle() != ERROR_SUCCESS)
        return FALSE;

    if (!QueryServiceStatus(m_hSNMPService, &snmpStatus))
        return _E(GetLastError(), IDS_ERR27);

    _W(WARN_TRACK, IDS_TRCK_WRN49, snmpStatus.dwCurrentState);

    return snmpStatus.dwCurrentState == SERVICE_RUNNING;
}

DWORD CSNMPController::StartSNMP()
{
    DWORD           retCode;
    SERVICE_STATUS  svcStatus;
    DWORD           dwRetries;

    if ((retCode = LoadSvcHandle()) != ERROR_SUCCESS)
        return retCode;

    if (!StartService(m_hSNMPService, 0, NULL))
        return _E(GetLastError(), IDS_ERR28);

    for (dwRetries = 10; dwRetries > 0; dwRetries--)
    {
        printf("."); fflush(stdout);
        if (!QueryServiceStatus(m_hSNMPService, &svcStatus))
            return _E(GetLastError(), IDS_ERR29);
        if (svcStatus.dwCurrentState == SERVICE_RUNNING)
            break;
        if (svcStatus.dwCurrentState == SERVICE_START_PENDING)
        {
            if (svcStatus.dwWaitHint < 200)
                svcStatus.dwWaitHint = 200;
            if (svcStatus.dwWaitHint > 1000)
                svcStatus.dwWaitHint = 1000;
            Sleep(svcStatus.dwWaitHint);
        }
        else
            return _E(ERROR_INVALID_STATE, IDS_ERR06, svcStatus.dwWaitHint);
    }
    printf("\n");

    return retCode;
}

DWORD CSNMPController::StopSNMP()
{
    DWORD           retCode;
    SERVICE_STATUS  svcStatus;
    DWORD           dwRetries;

    if ((retCode = LoadSvcHandle()) != ERROR_SUCCESS)
        return retCode;

    if (!ControlService(m_hSNMPService, SERVICE_CONTROL_STOP, &svcStatus))
    {
        retCode = GetLastError();
        if (retCode == ERROR_SERVICE_NOT_ACTIVE)
        {
            _W(WARN_TRACK, IDS_TRCK_WRN50);
            return ERROR_SUCCESS;
        }
        return _E(GetLastError(), IDS_ERR30);
    }

    for (dwRetries = 10; dwRetries > 0; dwRetries--)
    {
        printf("."); fflush(stdout);
        if (!QueryServiceStatus(m_hSNMPService, &svcStatus))
            return _E(GetLastError(), IDS_ERR31);
        if (svcStatus.dwCurrentState == SERVICE_STOPPED)
            break;
        if (svcStatus.dwCurrentState == SERVICE_STOP_PENDING)
        {
            if (svcStatus.dwWaitHint < 200)
                svcStatus.dwWaitHint = 200;
            if (svcStatus.dwWaitHint > 1000)
                svcStatus.dwWaitHint = 1000;
            Sleep(svcStatus.dwWaitHint);
        }
        else
            return _E(ERROR_INVALID_STATE, IDS_ERR06, svcStatus.dwWaitHint);
    }
    printf("\n");

    if (dwRetries == 0)
        return _E(ERROR_TIMEOUT, IDS_ERR07);

    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include <stdio.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>       // MFC template classes

#include <locale.h>         // locale support for console app. 
#include <winnlsp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntcmd\snmpctrl.h ===
#ifndef _SNMPCTRL_H
#define _SNMPCTRL_H

class CSNMPController
{
    SC_HANDLE    m_hServiceController;
    SC_HANDLE    m_hSNMPService;

public:
    CSNMPController();
    ~CSNMPController();

    DWORD LoadSvcHandle();
    BOOL  IsSNMPRunning();
    DWORD StartSNMP();
    DWORD StopSNMP();
};

extern CSNMPController gSNMPController;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\dlgsavep.h ===
// dlgsavep.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgSaveProgress dialog

class CDlgSaveProgress : public CDialog
{
// Construction
public:
	CDlgSaveProgress(BOOL bIsSaving = FALSE);   // standard constructor
    BOOL StepProgress(LONG nSteps = 1);
    void SetStepCount(LONG nSteps);

// Dialog Data
	//{{AFX_DATA(CDlgSaveProgress)
	enum { IDD = IDD_SAVE_PROGRESS };
	CProgressCtrl	m_progress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgSaveProgress)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgSaveProgress)
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void ProgressYield();
    BOOL m_bWasCanceled;
    BOOL m_bIsSaving;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\eventrap.cpp ===
// eventrap.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "eventrap.h"
#include "trapdlg.h"
#include "globals.h"
#include "utils.h"
#include "trapreg.h"
#include "busy.h"
#include "dlgsavep.h"

/////////////////////////////////////////////////////////////////////////////
// CEventrapApp

BEGIN_MESSAGE_MAP(CEventrapApp, CWinApp)
        //{{AFX_MSG_MAP(CEventrapApp)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEventrapApp construction

CEventrapApp::CEventrapApp()
{
        // TODO: add construction code here,
        // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEventrapApp object

CEventrapApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CEventrapApp initialization


LPCTSTR GetNextParam(LPTSTR pszDst, LPCTSTR pszSrc, LONG nchDst)
{
        // Skip any leading white space
        while((*pszSrc==' ') || (*pszSrc=='\t')) {
                ++pszSrc;
        }

        // Reserve a byte for the null terminator
        ASSERT(nchDst >= 1);
        --nchDst;

        // Copy the next parameter to the destination buffer.
        while (nchDst > 0) {
                INT iCh = *pszSrc;
                if ((iCh == 0) || (iCh==' ') || (iCh=='\t')) {
                        break;
                }
                ++pszSrc;
                *pszDst++ = (TCHAR)iCh;
                --nchDst;
        }
        *pszDst = 0;

        return pszSrc;
}

void ParseParams(CStringArray& asParams, LPCTSTR pszParams)
{
        TCHAR szParam[MAX_STRING];
        while(pszParams != NULL) {
                pszParams = GetNextParam(szParam, pszParams, MAX_STRING);
                if (szParam[0] == 0) {
                        break;
                }
                asParams.Add(szParam);
        }
}


BOOL CEventrapApp::InitInstance()
{

    GetThousandSeparator(&g_chThousandSep);

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    CStringArray asParams;
    ParseParams(asParams, m_lpCmdLine);


    SCODE sc;
    LPCTSTR pszComputerName = NULL;

    switch(asParams.GetSize()) {
    case 0:
        break;
    case 1:
        if (!asParams[0].IsEmpty()) {
            pszComputerName = asParams[0];
        }
        break;
    default:
        AfxMessageBox(IDS_ERR_INVALID_ARGUMENT);
        return FALSE;
        break;
    }


    CBusy busy;

    g_reg.m_pdlgLoadProgress = new CDlgSaveProgress;
    g_reg.m_pdlgLoadProgress->Create(IDD_LOAD_PROGRESS, NULL);
    g_reg.m_pdlgLoadProgress->BringWindowToTop();

	//if the local machine is the same as
	//the machine name passed as an argument
	//don't use a machine name.
	if (NULL != pszComputerName)
	{
		TCHAR t_buff[MAX_COMPUTERNAME_LENGTH + 1];
		DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;

		if (GetComputerName(t_buff, &dwLen))
		{
			if (_tcsicmp(t_buff, pszComputerName) == 0)
			{
				pszComputerName = NULL;
			}
		}
	}

    sc = g_reg.Connect(pszComputerName);
    if ((sc==S_LOAD_CANCELED) || FAILED(sc)) {
        delete g_reg.m_pdlgLoadProgress;
        g_reg.m_pdlgLoadProgress = NULL;
        return FALSE;
    }


    // Read the current event to trap configuration from the registry
    sc = g_reg.Deserialize();
    if ((sc==S_LOAD_CANCELED) || FAILED(sc)) {
        delete g_reg.m_pdlgLoadProgress;
        g_reg.m_pdlgLoadProgress = NULL;
        return FALSE;
    }

    CEventTrapDlg* pdlg = new CEventTrapDlg;
    m_pMainWnd = pdlg;
    pdlg->Create(IDD_EVNTTRAPDLG, NULL);
    pdlg->BringWindowToTop();

    // Since we are running a modeless dialog, return TRUE so that the message
    // pump is run.

	return TRUE;
}

int CEventrapApp::ExitInstance()
{
    return CWinApp::ExitInstance();
}

BOOL CEventrapApp::ProcessMessageFilter(int code, LPMSG lpMsg)
{
    // TODO: Add your specialized code here and/or call the base class

    return CWinApp::ProcessMessageFilter(code, lpMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\busy.cpp ===
//****************************************************************************
//
//  Copyright (c) 1994, Microsoft Corporation
//
//  File:  BUSY.CPP
//
//  Implementation file for the CBusy class.
//
//  History:
//
//      Scott V. Walker, SEA     6/30/94    Created.
//
//****************************************************************************

#include "stdafx.h"

#include "portable.h"

#include "busy.h"

//****************************************************************************
//
//  CBusy::CBusy
//
//****************************************************************************
CBusy::CBusy(CWnd *pParentWnd, LPCTSTR pszText)
{
    SetBusy(pParentWnd, pszText);
}

//****************************************************************************
//
//  CBusy::CBusy
//
//****************************************************************************
CBusy::CBusy(CWnd *pParentWnd, UINT nID)
{
    CString sText;

    sText.LoadString(nID);
    SetBusy(pParentWnd, sText);
}

//****************************************************************************
//
//  CBusy::CBusy
//
//****************************************************************************
CBusy::CBusy(CWnd *pParentWnd)
{
    SetBusy(pParentWnd, _T(""));
}

//****************************************************************************
//
//  CBusy::CBusy
//
//****************************************************************************
CBusy::CBusy()
{
    SetBusy(NULL, _T(""));
}

//****************************************************************************
//
//  CBusy::SetBusy
//
//****************************************************************************
void CBusy::SetBusy(CWnd *pParentWnd, LPCTSTR pszText)
{
    m_pParentWnd = pParentWnd;

    m_hOldCursor = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

    if (m_pParentWnd != NULL)
    {
        TCHAR szOldText[255];

        // Retrieve the current text and save it 'til later.
        szOldText[0] = '\0';
        m_pParentWnd->SendMessage(WM_BUSY_GETTEXT, 255, (LPARAM)szOldText);
        m_sOldText = szOldText;

        if (pszText == NULL)
            pszText = _T("");

        m_pParentWnd->SendMessage(WM_BUSY_SETTEXT, 0, (LPARAM)pszText);
    }
}

//****************************************************************************
//
//  CBusy::~CBusy
//
//****************************************************************************
CBusy::~CBusy()
{
    ::SetCursor(m_hOldCursor);

    if (m_pParentWnd != NULL)
    {
        m_pParentWnd->SendMessage(WM_BUSY_SETTEXT, 0,
            (LPARAM)(LPCTSTR)m_sOldText);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\dlgsavep.cpp ===
// dlgsavep.cpp : implementation file
//

#include "stdafx.h"
#include "eventrap.h"
#include "dlgsavep.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgSaveProgress dialog


CDlgSaveProgress::CDlgSaveProgress(BOOL bIsSaving)
	: CDialog(CDlgSaveProgress::IDD, NULL)
{
	//{{AFX_DATA_INIT(CDlgSaveProgress)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_bWasCanceled = FALSE;
    m_bIsSaving = bIsSaving;    // May indicate loading or saving.
}


void CDlgSaveProgress::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgSaveProgress)
	DDX_Control(pDX, IDC_PROGRESS, m_progress);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDlgSaveProgress, CDialog)
	//{{AFX_MSG_MAP(CDlgSaveProgress)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDlgSaveProgress message handlers

void CDlgSaveProgress::OnCancel()
{
	// TODO: Add extra cleanup here
    if (!m_bIsSaving) {
        // Cancel is currently enabled only for a load
        m_bWasCanceled = TRUE;	
    	CDialog::OnCancel();
    }
}

void CDlgSaveProgress::ProgressYield()
{
    MSG msg;

    // Remove all available messages for any window that belongs to
    // the current application.
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        // Translate and siapatch the given message if the window handle is
        // null or the given message is not for the modeless dialog box hwnd.
        if (!m_hWnd || !IsDialogMessage(&msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}


BOOL CDlgSaveProgress::StepProgress(LONG nSteps)
{
    ProgressYield();
    while (--nSteps >= 0) {
        m_progress.StepIt();
    }

    return m_bWasCanceled;
}

void CDlgSaveProgress::SetStepCount(LONG nSteps)
{
#if _MFC_VER >= 0x0600
    m_progress.SetRange32(0, nSteps);
#else
    m_progress.SetRange(0, nSteps);
#endif
    m_progress.SetPos(0);
    m_progress.SetStep(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\eventrap.h ===
// eventrap.h : main header file for the EVENTRAP application
//

#ifndef __AFXWIN_H__
        #error include 'stdafx.h' before including this file for PCH
#endif

/////////////////////////////////////////////////////////////////////////////
// CEventrapApp:
// See eventrap.cpp for the implementation of this class
//

class CEventrapApp : public CWinApp
{
public:
        CEventrapApp();

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CEventrapApp)
	public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
        virtual BOOL ProcessMessageFilter(int code, LPMSG lpMsg);
	//}}AFX_VIRTUAL

// Implementation

        //{{AFX_MSG(CEventrapApp)
                // NOTE - the ClassWizard will add and remove member functions here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\busy.h ===
//****************************************************************************
//
//  Copyright (c) 1994, Microsoft Corporation
//
//  File:  BUSY.H
//
//  The classes defined here are:
//
//     CBusy    Utility class to indicate to the user that the app is busy.
//              When an instance is constructed, it changes the cursor to the
//              wait cursor.  If a parent window is provided it will receive a
//              message to set the text of its status indicator to a specified
//              string.  This is useful for windows that have a status bar or
//              some other textual indication of status.  When the instance is
//              destructed, the cursor is restored and the parent window is
//              sent a message to reset its status indicator.
//
//  History:
//
//      Scott V. Walker, SEA    6/30/94    Created.
//
//****************************************************************************
#ifndef _BUSY_H_
#define _BUSY_H_

//****************************************************************************
//
//  Messages sent to parent window.
//
//----------------------------------------------------------------------------
//
//  WM_BUSY_GETTEXT
//
//  This message is sent by the CBusy to retrieve the current status indicator
//  text.  The CBusy will restore this text when it destructs.
//
//  wparam = nLength;           // Length of buffer.
//  lparam = (LPARAM)pStr;      // Pointer to buffer to copy data into.
//
//----------------------------------------------------------------------------
//
//  WM_BUSY_SETTEXT
//
//  This message is sent by the CBusy to inform the window to set its status
//  indicator to the given string.
//
//  wparam is unused.
//  lparam = (LPARAM)pStr;      // Pointer to buffer containing status text.
//
//  Return value = n/a.
//
//****************************************************************************

#define WM_BUSY_GETTEXT     (WM_USER + 0x75)
#define WM_BUSY_SETTEXT     (WM_USER + 0x76)

//****************************************************************************
//
//  CLASS:  CBusy
//
//  When you construct a CBusy, you have the option of specifying a parent
//  window and a string ID.  If these are provided, The CBusy will send
//  WM_BUSY_GETTEXT and WM_BUSY_SETTEXT messages to the window during
//  construction and destruction.  The parent window can respond to these
//  messages by modifying a text status indicator (such as a status bar) to
//  display the specified string.  Use these by constructing a local instance
//  at the top of a function.  When the function goes out of scope (no matter
//  where the return is encountered), the instance will be destructed, causing
//  the busy indications (cursor and text) to be restored.
//
//----------------------------------------------------------------------------
//
//  CBusy::CBusy
//
//  Constructor.  When an instance is constructed, it sets the cursor to the
//  wait cursor and optionally notifies a specified window to change its
//  status indicator.
//
//  Parameters:
//      CWnd *pParentWnd    Optional parent window.  If provided, the CBusy
//                          sends WM_BUSY_GETTEXT and WM_BUSY_SETTEXT
//                          messages to the given window.
//      const char *pszText Optional string.  If provided (and if a parent
//                          window is specified), the CBusy passes it in the
//                          WM_BUSY_SETTEXT message to the parent window.  If
//                          not provided, the parent window is sent an empty
//                          string.
//
//      If parameter 2 is a UINT, CBusy will treat it as a string ID and do a
//      LoadString. 
//
//****************************************************************************

class CBusy : public CObject
{

private:

    CWnd *m_pParentWnd;
    HCURSOR m_hOldCursor;
    CString m_sOldText;

private:

    void SetBusy(CWnd *pParentWnd, LPCTSTR pszText);

public:

    CBusy(CWnd *pParentWnd, LPCTSTR pszText);
    CBusy(CWnd *pParentWnd, UINT nID);
    CBusy(CWnd *pParentWnd);
    CBusy();
    ~CBusy();
};

#endif // _BUSY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\evntfind.cpp ===
// evntfind.cpp : implementation file
//

#include "stdafx.h"
#include "eventrap.h"
#include "evntfind.h"
#include "source.h"
#include "globals.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEventFindDlg dialog


CEventFindDlg::CEventFindDlg(CWnd* pParent)
	: CDialog(CEventFindDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEventFindDlg)
	m_sFindWhat = _T("");
	m_bMatchWholeWord = FALSE;
	m_bMatchCase = FALSE;
	//}}AFX_DATA_INIT

    m_pSource = NULL;
    m_bSearchInTree = TRUE;
    m_bMatchCase = FALSE;
    m_bMatchWholeWord = FALSE;
    m_iFoundWhere = I_FOUND_NOTHING;
}

CEventFindDlg::~CEventFindDlg()
{
    m_pSource->m_pdlgFind = NULL;
}


BOOL CEventFindDlg::Create(CSource* pSource, UINT nIDTemplate, CWnd* pParentWnd)
{
    m_pSource = pSource;
    return CDialog::Create(nIDTemplate, pParentWnd);
}

void CEventFindDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEventFindDlg)
	DDX_Text(pDX, IDC_EDIT_FIND_WHAT, m_sFindWhat);
	DDX_Check(pDX, IDC_CHECK_MATCH_WHOLEWORD, m_bMatchWholeWord);
	DDX_Check(pDX, IDC_CHECK_MATCH_CASE, m_bMatchCase);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEventFindDlg, CDialog)
	//{{AFX_MSG_MAP(CEventFindDlg)
	ON_BN_CLICKED(IDC_CHECK_MATCH_WHOLEWORD, OnCheckMatchWholeword)
	ON_BN_CLICKED(IDC_CHECK_MATCH_CASE, OnCheckMatchCase)
	ON_EN_CHANGE(IDC_EDIT_FIND_WHAT, OnChangeEditFindWhat)
	ON_BN_CLICKED(IDC_RADIO_SEARCH_DESCRIPTIONS, OnRadioSearchDescriptions)
	ON_BN_CLICKED(IDC_RADIO_SEARCH_SOURCES, OnRadioSearchSources)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_BN_CLICKED(IDC_FIND_OK, OnOK)
	ON_BN_CLICKED(IDC_FIND_CANCEL, OnCancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEventFindDlg message handlers



void CEventFindDlg::OnCheckMatchWholeword() 
{
	CButton *pButton = (CButton*)GetDlgItem(IDC_CHECK_MATCH_WHOLEWORD);
	if (pButton != NULL)
        m_bMatchWholeWord = pButton->GetCheck() != 0;
}

void CEventFindDlg::OnCheckMatchCase() 
{
	CButton *pButton = (CButton*)GetDlgItem(IDC_CHECK_MATCH_CASE);
	if (pButton != NULL)
        m_bMatchCase = pButton->GetCheck() != 0;
}

void CEventFindDlg::OnCancel() 
{
	CDialog::OnCancel();
    delete this;
}

void CEventFindDlg::OnChangeEditFindWhat() 
{
    CWnd* pwndEdit = GetDlgItem(IDC_EDIT_FIND_WHAT);
	CButton* pbtnWholeWord = (CButton*) GetDlgItem(IDC_CHECK_MATCH_WHOLEWORD);
	CString sText;

    // Get the search string and check to see if it contains any spaces.	
	pwndEdit->GetWindowText(sText);
	if (sText.Find(_T(' ')) ==-1) {
        // It does not contain a space.  Enable the window.
		if (!pbtnWholeWord->IsWindowEnabled()) {
			pbtnWholeWord->EnableWindow();
		}
	}
	else {
        // The search string contained a space, disable the whole-word button
        // and uncheck it if necessary.
		if (pbtnWholeWord->IsWindowEnabled()) {
			if (pbtnWholeWord->GetCheck() == 1) {
				// The "whole word" button was checked, so uncheck it and
				// disable the button.
			
				pbtnWholeWord->SetCheck(0);
			}
			pbtnWholeWord->EnableWindow(FALSE);
		}
	}	
	
}

BOOL CEventFindDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
    int idButton = m_bSearchInTree ? IDC_RADIO_SEARCH_SOURCES : IDC_RADIO_SEARCH_DESCRIPTIONS;
	CButton *pButton = (CButton*)GetDlgItem(idButton);
	if (pButton != NULL)
		pButton->SetCheck(1);

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CEventFindDlg::OnRadioSearchDescriptions() 
{
    m_bSearchInTree = FALSE;
}

void CEventFindDlg::OnRadioSearchSources() 
{
    m_bSearchInTree = TRUE;
}



BOOL CEventFindDlg::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CDialog::OnCommand(wParam, lParam);
}

void CEventFindDlg::OnOK() 
{
	// Get the Find What text.
	CEdit* pEdit = (CEdit*) GetDlgItem(IDC_EDIT_FIND_WHAT);
	if (pEdit == NULL)
		return; // Can't do anything.

	// Empty Find What string; nothing to do.
	pEdit->GetWindowText(m_sFindWhat);
	if (m_sFindWhat.IsEmpty())
		return;
    pEdit->SetSel(0, -1);

	BOOL bFound = m_pSource->Find(m_bSearchInTree, m_sFindWhat, m_bMatchWholeWord, m_bMatchCase);
    SetFocus();

	// Put the focus on the parent window.
    if (bFound) {
        if (m_bSearchInTree) {
            m_iFoundWhere = I_FOUND_IN_TREE;
        }
        else {
            m_iFoundWhere = I_FOUND_IN_LIST;
        }
    }
	else {
		CString sMsg;
		sMsg.LoadString(IDS_MSG_TEXTNOTFOUND);				
		MessageBox(sMsg, NULL, MB_OK | MB_ICONINFORMATION);
	}
	
}



FOUND_WHERE CEventFindDlg::Find(CSource* pSource)
{
    m_pSource = pSource;
    DoModal();
    return m_iFoundWhere;
}

BOOL CEventFindDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                   AfxGetApp()->m_pszHelpFilePath,
                   HELP_WM_HELP,
                   (ULONG_PTR)g_aHelpIDs_IDD_EVENTFINDDLG);
	}
	
	return TRUE;
}

void CEventFindDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (this == pWnd)
		return;

    ::WinHelp (pWnd->m_hWnd,
		       AfxGetApp()->m_pszHelpFilePath,
		       HELP_CONTEXTMENU,
		       (ULONG_PTR)g_aHelpIDs_IDD_EVENTFINDDLG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\evntprop.cpp ===
//***********************************************************************
// evntprop.cpp
//
// This file contains the implementation of the event properties dialog.
//
// Author: SEA
//
// History:
//      20-Febuary-1996     Larry A. French
//          Made various changes to this code.  However, much of it is
//          legacy code and in dire need of being rewritten.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//
//************************************************************************


#include "stdafx.h"
#include "resource.h"
#include "eventrap.h"
#include "evntprop.h"
#include "trapreg.h"
#include "globals.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define MAX_EVENT_COUNT   32767
#define MAX_TIME_INTERVAL 32767



#define IsWithinRange(value, lower, upper) (((value) >= (lower)) && ((value) <= (upper)))

void RangeError(int iLower, int iUpper)
{
    
    TCHAR szBuffer[1024];
    CString sFormat;
    sFormat.LoadString(IDS_ERR_RANGE);
    _stprintf(szBuffer, (LPCTSTR) sFormat, iLower, iUpper);
    AfxMessageBox(szBuffer);
}


/////////////////////////////////////////////////////////////////////////////
// CEventPropertiesDlg dialog


CEventPropertiesDlg::CEventPropertiesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEventPropertiesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEventPropertiesDlg)
	m_sDescription = _T("");
	m_sSource = _T("");
	m_sEventId = _T("");
	m_sLog = _T("");
	m_sSourceOID = _T("");
	m_sFullEventID = _T("");
	//}}AFX_DATA_INIT
}

BOOL CEventPropertiesDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

    m_spinEventCount.SetRange(1, MAX_EVENT_COUNT);
    if (m_iEventCount==0) {
        m_spinEventCount.SetPos(1);
    } else {
        m_spinEventCount.SetPos(m_iEventCount);
    }


    if (m_iTimeInterval == 0) {
        m_btnWithinTime.SetCheck(0);
        m_spinTimeInterval.SetRange(0, MAX_TIME_INTERVAL);
    }
    else {
        m_btnWithinTime.SetCheck(1);
        m_spinTimeInterval.SetRange(1, MAX_TIME_INTERVAL);
    }
    m_spinTimeInterval.SetPos(m_iTimeInterval);

    m_edtTimeInterval.EnableWindow(m_btnWithinTime.GetCheck() == 1);
    m_spinTimeInterval.EnableWindow(m_btnWithinTime.GetCheck() == 1);

    // If this is not a custom configuration, do not let the user
    // modify the configuration.
    if ((g_reg.GetConfigType() != CONFIG_TYPE_CUSTOM) || (g_reg.m_bRegIsReadOnly)) {
        m_btnOK.EnableWindow(FALSE);
    }
    m_bDidEditEventCount = FALSE;

    OnWithintime();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}





void CEventPropertiesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CEventPropertiesDlg)
	DDX_Control(pDX, IDC_WITHINTIME, m_btnWithinTime);
	DDX_Control(pDX, IDC_EVENTCOUNTSPN, m_spinEventCount);
	DDX_Control(pDX, IDC_TIMEINTRVLSPN, m_spinTimeInterval);
	DDX_Control(pDX, IDC_TIMEINTERVAL, m_edtTimeInterval);
	DDX_Control(pDX, IDC_EVENTCOUNT, m_edtEventCount);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Text(pDX, IDC_DESCRIPTION, m_sDescription);
	DDV_MaxChars(pDX, m_sDescription, 2048);
	DDX_Text(pDX, ID_STAT_SOURCE, m_sSource);
	DDV_MaxChars(pDX, m_sSource, 256);
	DDX_Text(pDX, ID_STAT_EVENTID, m_sEventId);
	DDX_Text(pDX, ID_STAT_LOG, m_sLog);
	DDX_Text(pDX, IDC_EDIT_ENTERPRISEOID, m_sSourceOID);
	DDX_Text(pDX, IDC_EDIT_FULL_EVENT_ID, m_sFullEventID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEventPropertiesDlg, CDialog)
	//{{AFX_MSG_MAP(CEventPropertiesDlg)
	ON_BN_CLICKED(IDC_WITHINTIME, OnWithintime)
	ON_COMMAND(ID_HELP, OnHelp)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEventPropertiesDlg message handlers

void CEventPropertiesDlg::OnOK() 
{
	// TODO: Add extra validation here
    int iLower, iUpper;
    CString sText;

    m_spinEventCount.GetRange(iLower, iUpper);

    // Validate the event count edit item and set m_iEventCount
    m_edtEventCount.GetWindowText(sText);
    if (!IsDecimalInteger(sText)) {
        RangeError(iLower, iUpper);
        m_edtEventCount.SetSel(0, -1);
        m_edtEventCount.SetFocus();
        return;
    }

    m_iEventCount = _ttoi(sText);

    if (!IsWithinRange(m_iEventCount, iLower, iUpper)) {
        RangeError(iLower, iUpper);
        sText.Format(_T("%u"), m_iEventCount);
        m_edtEventCount.SetWindowText(sText);
        m_edtEventCount.SetSel(0, -1);
        m_edtEventCount.SetFocus();
        return;
    }

    // Validate the time interval and set m_iTimeInterval        
    m_spinTimeInterval.GetRange(iLower, iUpper);
    m_edtTimeInterval.GetWindowText(sText);
    if (!IsDecimalInteger(sText)) {            
        RangeError(iLower, iUpper);
        m_edtTimeInterval.SetSel(0, -1);
        m_edtTimeInterval.SetFocus();
        return;
    }

    m_iTimeInterval = _ttoi(sText);
	if (m_btnWithinTime.GetCheck() == 1) {                          
		if (m_iEventCount < 2) {
			AfxMessageBox(IDS_ERR_PROP_TIME1);
            m_edtEventCount.SetSel(0, -1);
            m_edtEventCount.SetFocus();
            return;
		}

		if (m_iTimeInterval < 1) {
			AfxMessageBox(IDS_ERR_PROP_TIME2);
            sText.Format(_T("%u"), m_iTimeInterval);
            m_edtTimeInterval.SetWindowText(sText);
            m_edtTimeInterval.SetSel(0, -1);
            m_edtTimeInterval.SetFocus();
            return;
		}

        if (!IsWithinRange(m_iTimeInterval, iLower, iUpper)) {
            RangeError(iLower, iUpper);
            sText.Format(_T("%u"), m_iTimeInterval);
            m_edtTimeInterval.SetWindowText(sText);
            m_edtTimeInterval.SetSel(0, -1);
            m_edtTimeInterval.SetFocus();
            return;
        }
	}
	else if (m_iEventCount < 1) {	
		AfxMessageBox(IDS_ERR_PROP_TIME_LESS_THAN_TWO);
        m_edtEventCount.SetSel(0, -1);
        return;
	}

    CDialog::OnOK();

    // We don't set the g_reg.m_bIsDirty flag here because we want to see if the
    // user actually changed the current settings.  This check is made in 
    // CEventPropertiesDlg::EditEventProperties on a per-event basis.
}


void CEventPropertiesDlg::OnWithintime() 
{
	// The WithinTime checkbox was clicked.
	// Enable/disable the TimeInterval control.

    
    // Check to see if the count field has been edited.  If it has been edited,
    // mark the field as being dirty.

    if (m_edtEventCount.IsDirty() || m_spinEventCount.IsDirty()) {
        m_bDidEditEventCount = TRUE;
    }

    int iEventCount;
    int iTemp;
    SCODE sc = m_edtEventCount.GetValue(iEventCount);
    if (FAILED(sc)) {
        m_spinEventCount.GetRange(iEventCount, iTemp);
        m_spinEventCount.SetPos(iEventCount);
        m_bDidEditEventCount = FALSE;
    }

	if (m_btnWithinTime.GetCheck() == 1) {
        m_edtTimeInterval.EnableWindow(TRUE);
        m_spinTimeInterval.EnableWindow(TRUE);

        if (iEventCount < 2) {
            // If the event count is less than two, it will flip to two when the spin button's
            // range is set.  In this event, we make it appear as if the user never edited the
            // value so that it will flip back when the check box is unchecked.
            m_bDidEditEventCount = FALSE;
            m_bDidFlipEventCount = TRUE;
            m_edtEventCount.ClearDirty();
            m_spinEventCount.ClearDirty();
            m_spinEventCount.SetPos(2);
        }


   	    m_spinEventCount.SetRange(2, MAX_EVENT_COUNT);
	    m_spinTimeInterval.SetRange(1, MAX_TIME_INTERVAL);
	}
	else {
        m_edtTimeInterval.EnableWindow(FALSE);
        m_spinTimeInterval.EnableWindow(FALSE);

   	    m_spinEventCount.SetRange(1, MAX_EVENT_COUNT);
        m_spinEventCount.SetPos(iEventCount);
	    m_spinTimeInterval.SetRange(0, MAX_TIME_INTERVAL);
		m_spinTimeInterval.SetPos(0);


        // If the initial event count was one and we flipped it to two when the "within time"
        // button was clicked, then flip it back to one now if it was not edited.
        if (m_bDidFlipEventCount) {       
            if (!m_bDidEditEventCount) {
                m_spinEventCount.SetPos(1);
            }
            m_bDidFlipEventCount = FALSE;
        }
	}
	m_spinTimeInterval.SetRedraw();
}



//***************************************************************************
//
//  CEventPropertiesDlg::MakeLabelsBold
//
//  This method makes the static labels bold to enhance the appearance of
//  the dialog.
//
//	This method should be called after CDIalog::InitDialog.
//
//  Parameters:
//		None.
//
//  Returns:
//		Nothing.
//
//  Status:
//		The MFC2.0 library makes the labels invisible when an attempt
//		is made to change the font of a static item.  I've tried this with
//		MFC4.0 and it works.  
//      
//***************************************************************************
void CEventPropertiesDlg::MakeLabelsBold()
{
#if 0
	CFont* pfontDefault;
	LOGFONT lf;

 	// Get the LOGFONT for the default static item font and then
	// switch the logfont weight to bold.
	pfontDefault = m_statSource.GetFont();
	pfontDefault->GetObject(sizeof(lf), &lf);
	lf.lfWeight = FW_BOLD;

	// Create a bold font with all other characteristics the same as the
	// default font.  Then switch all labels to a bold font. 
	CFont fontNew;
	if (fontNew.CreateFontIndirect(&lf)) {
		m_statSource.SetFont(&fontNew, TRUE);
		m_statLog.SetFont(&fontNew, TRUE);
		m_statEventID.SetFont(&fontNew, TRUE);
		m_statEnterpriseOID.SetFont(&fontNew, TRUE);		
	}

#endif //0
}





//********************************************************************
// CEventPropertiesDlg::EditEventProperties
//
// Edit the properties of a number of events.
//
// Parameters:
//      CEventArray& aEvents
//          An array of CEvent pointers.  These are the events that
//          are to be edited.
//
// Returns:
//      BOOL
//          TRUE if the user clicked OK and the events were edited.
//          FALSE if the user clicked Cancel and the events were not
//          edited.
//
//******************************************************************
BOOL CEventPropertiesDlg::EditEventProperties(CXEventArray& aEvents)
{
    LONG nEvents = aEvents.GetSize();
    if (nEvents == 0) {
        return TRUE;
    }


    // The first event is taken as a representative of the other
    // events.  Copy the appropriate data from this event to the
    // dialog.
    CString sText;

    CXEvent* pEvent = aEvents[0];
    CXEventSource* pEventSource = pEvent->m_pEventSource;
    CXEventLog* pEventLog = pEventSource->m_pEventLog;

    LONG iEvent;
    BOOL bMultipleSources = FALSE;
    BOOL bMultipleLogs = FALSE;
    for (iEvent=0; iEvent < nEvents; ++iEvent) {
        pEvent = aEvents[iEvent];
        if (pEvent->m_pEventSource != pEventSource) {
            bMultipleSources = TRUE;
        }
        if (pEvent->m_pEventSource->m_pEventLog != pEventLog) {
            bMultipleLogs = TRUE;
        }
    }

    if (bMultipleSources) {
        m_sSource.LoadString(IDS_MULTIPLE_SEL);
        m_sSourceOID.LoadString(IDS_MULTIPLE_SEL);
    }
    else {    
        m_sSource = pEventSource->m_sName;
        pEventSource->GetEnterpriseOID(m_sSourceOID, TRUE);
    }

    if (bMultipleLogs) {        
        m_sLog.LoadString(IDS_MULTIPLE_SEL);
    }
    else {
        m_sLog = pEventSource->m_pEventLog->m_sName;
    }

    // Copy the initial values.
    m_iTimeInterval = (int) pEvent->m_dwTimeInterval;
    m_iEventCount = pEvent->m_dwCount;
    m_bDidFlipEventCount = FALSE;
//    m_bWithinTime = (m_iTimeInterval != 0);


    if (nEvents > 1) {
        m_sEventId.LoadString(IDS_MULTIPLE_SEL);
        m_sDescription.LoadString(IDS_MULTIPLE_SEL);
        m_sFullEventID.LoadString(IDS_MULTIPLE_SEL);
    }
    else {
        pEvent->m_message.GetShortId(m_sEventId);
        m_sDescription = pEvent->m_message.m_sText;
        DecString(m_sFullEventID, pEvent->m_message.m_dwId);
    }

    
    // Put up the dialog and let the user edit the data.
    BOOL bDidCancel = (DoModal() == IDCANCEL);
    if (bDidCancel) {
        // The user canceled the dialog, so do nothing.
        return FALSE;
    }

    // Control comes here if the user clicked OK.  Now we need to copy the
    // user's settings to each event that we are editing and mark the registry
    // as dirty if any of the settings changed.
    for (iEvent=0; iEvent < nEvents; ++iEvent) {
        pEvent = aEvents[iEvent];
        if (pEvent->m_dwTimeInterval != (DWORD) m_iTimeInterval) {
            g_reg.SetDirty(TRUE);
            pEvent->m_dwTimeInterval = (DWORD) m_iTimeInterval;
        }

        if (pEvent->m_dwCount !=  (DWORD) m_iEventCount) {
            g_reg.SetDirty(TRUE);
            pEvent->m_dwCount = m_iEventCount;
        }
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CEditField

CEditField::CEditField()
{
    m_bIsDirty = FALSE;
}

CEditField::~CEditField()
{
}


BEGIN_MESSAGE_MAP(CEditField, CEdit)
	//{{AFX_MSG_MAP(CEditField)
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditField message handlers

void CEditField::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default	
	CEdit::OnChar(nChar, nRepCnt, nFlags);
    m_bIsDirty = TRUE;
}

SCODE CEditField::GetValue(int& iValue)
{
    CString sValue;
    GetWindowText(sValue);
    if (!IsDecimalInteger(sValue)) {
        return E_FAIL;
    }

    iValue = _ttoi(sValue);
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CEditSpin

CEditSpin::CEditSpin()
{
    m_bIsDirty = FALSE;
    m_iSetPos = 0;
}

CEditSpin::~CEditSpin()
{
}


BEGIN_MESSAGE_MAP(CEditSpin, CSpinButtonCtrl)
	//{{AFX_MSG_MAP(CEditSpin)
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditSpin message handlers

void CEditSpin::OnLButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	CSpinButtonCtrl::OnLButtonUp(nFlags, point);
    if (GetPos() != m_iSetPos) {
        m_bIsDirty = TRUE;
    }
}


int CEditSpin::SetPos(int iPos)
{
    int iResult = CSpinButtonCtrl::SetPos(iPos);
    m_iSetPos = GetPos();
    m_bIsDirty = FALSE;
    return iResult;
}


void CEditSpin::SetRange(int iLower, int iUpper)
{
	int iPos = GetPos();
    CSpinButtonCtrl::SetRange(iLower, iUpper);

	if (iPos < iLower) {
		iPos = iLower;
	}
	
	if (iPos > iUpper) {
		iPos = iUpper;
	}

	SetPos(iPos);
    SetRedraw();

    m_iSetPos = iLower;
    m_bIsDirty = FALSE;
}


BOOL CEditSpin::IsDirty()
{
    int iCurPos = GetPos();

    return (m_bIsDirty || (m_iSetPos != iCurPos));
}

BOOL CEventPropertiesDlg::OnHelpInfo(HELPINFO *pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW &&
        pHelpInfo->iCtrlId != IDD_NULL)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                   AfxGetApp()->m_pszHelpFilePath,
                   HELP_WM_HELP,
                   (ULONG_PTR)g_aHelpIDs_IDD_PROPERTIESDLG);
	}
	
	return TRUE;
}

void CEventPropertiesDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (pWnd == this)
		return;

    ::WinHelp (pWnd->m_hWnd,
		       AfxGetApp()->m_pszHelpFilePath,
		       HELP_CONTEXTMENU,
		       (ULONG_PTR)g_aHelpIDs_IDD_PROPERTIESDLG);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\evntfind.h ===
#ifndef _evntfind_h
#define _evntfind_h

// evntfind.h : header file
//
class CSource;

enum FOUND_WHERE {
    I_FOUND_NOTHING,
    I_FOUND_IN_TREE,
    I_FOUND_IN_LIST
};

/////////////////////////////////////////////////////////////////////////////
// CEventFindDlg dialog
class CEventFindDlg : public CDialog
{
// Construction
public:
	CEventFindDlg(CWnd* pParent = NULL);   // standard constructor
    BOOL Create(CSource* pSource, UINT nIDTemplate, CWnd* pParentWnd=NULL);

    ~CEventFindDlg();
    FOUND_WHERE Find(CSource* pSource);

// Dialog Data
    FOUND_WHERE m_iFoundWhere;

	//{{AFX_DATA(CEventFindDlg)
	enum { IDD = IDD_EVENTFINDDLG };
	CString	m_sFindWhat;
	BOOL	m_bMatchWholeWord;
	BOOL	m_bMatchCase;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEventFindDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEventFindDlg)
	afx_msg void OnCheckMatchWholeword();
	afx_msg void OnCheckMatchCase();
	afx_msg void OnChangeEditFindWhat();
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioSearchDescriptions();
	afx_msg void OnRadioSearchSources();
	afx_msg BOOL OnHelpInfo(HELPINFO*);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnOK();
	afx_msg void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    CSource* m_pSource;
    BOOL m_bSearchInTree;
//    BOOL m_bMatchCase;
//    BOOL m_bWholeWord;
};


#endif //_evntfind_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\ewhelparr.h ===
#define	IDH_ETD_ADD	10005103
#define	IDH_ETD_BUTTON_EXPORT	10005110
#define	IDH_ETD_EVENTLIST	10005102
#define	IDH_ETD_FIND	10005105
#define	IDH_ETD_LV_SOURCES	10005107
#define	IDH_ETD_PROPERTIES	10005109
#define	IDH_ETD_RADIO_CUSTOM	10005100
#define	IDH_ETD_RADIO_DEFAULT	10005101
#define	IDH_ETD_REMOVE	10005104
#define	IDH_ETD_SETTINGS	10005108
#define	IDH_ETD_TV_SOURCES	10005106
#define	IDH_ETD_VIEW	10005111
#define IDH_ETD_APPLY	10005112
#define	IDH_EVENTFDLG_CHECK_MATCH_CASE	10005004
#define	IDH_EVENTFDLG_CHECK_MATCH_WHOLEWORD	10005003
#define	IDH_EVENTFDLG_EDIT_FIND_WHAT	10005000
#define	IDH_EVENTFDLG_RADIO_SEARCH_DESCRIPTIONS	10005002
#define	IDH_EVENTFDLG_RADIO_SEARCH_SOURCES	10005001
#define	IDH_STDLG_BUTTON_RESET	10005306
#define	IDH_STDLG_EDIT_MESSAGELENGTH	10005301
#define	IDH_STDLG_EDIT_TRAP_COUNT	10005307
#define	IDH_STDLG_EDIT_TRAP_SECONDS	10005308
#define	IDH_STDLG_LIMITMSGLNGTH	10005300
#define	IDH_STDLG_RADIO_DISABLE	10005305
#define	IDH_STDLG_RADIO_ENABLE	10005304
#define	IDH_STDLG_RADIO1	10005302
#define	IDH_STDLG_RADIO2	10005303
#define IDH_FIND_CANCEL 10005005
#define IDH_FIND_OK 10005006
//New IDs for IDD_PROPERTIESDLG
#define IDH_STAT_EVENTID 10005203
#define IDH_PROP_DESCRIPTION 10005208
#define IDH_PROP_EDIT_ENTERPRISEOID 10005201
#define IDH_PROP_EDIT_FULL_EVENT_ID 10005204
#define IDH_PROP_EVENTCOUNT 10005205
#define IDH_PROP_TIMEINTERVAL 10005207
#define IDH_PROP_WITHINTIME 10005206
#define IDH_STAT_LOG 10005202
#define IDH_STAT_SOURCE 10005200
//Disable help on instructional text
#define IDH_DISABLEHELP (DWORD(-1))

const DWORD g_aHelpIDs_IDD_EVENTFINDDLG[]=
{
	IDC_RADIO_SEARCH_SOURCES,IDH_EVENTFDLG_RADIO_SEARCH_SOURCES,
	IDC_RADIO_SEARCH_DESCRIPTIONS,IDH_EVENTFDLG_RADIO_SEARCH_DESCRIPTIONS,
	IDC_CHECK_MATCH_WHOLEWORD,IDH_EVENTFDLG_CHECK_MATCH_WHOLEWORD,
	IDC_CHECK_MATCH_CASE,IDH_EVENTFDLG_CHECK_MATCH_CASE,
	IDC_EDIT_FIND_WHAT,IDH_EVENTFDLG_EDIT_FIND_WHAT,
    IDC_FIND_OK, IDH_FIND_OK,
    IDC_FIND_CANCEL, IDH_FIND_CANCEL,
	0,0
};

const DWORD g_aHelpIDs_IDD_EVNTTRAPDLG[]=
{
	IDC_STAT_LABEL0, IDH_ETD_EVENTLIST,
	IDC_EVENTLIST,IDH_ETD_EVENTLIST,
	ID_SETTINGS,IDH_ETD_SETTINGS,
	IDC_STAT_LABEL2, IDH_ETD_LV_SOURCES,
	IDC_LV_SOURCES,IDH_ETD_LV_SOURCES,
	IDC_STAT_LABEL1, IDH_ETD_TV_SOURCES,
	IDC_TV_SOURCES,IDH_ETD_TV_SOURCES,
	ID_FIND,IDH_ETD_FIND,
	ID_BUTTON_EXPORT,IDH_ETD_BUTTON_EXPORT,
	ID_ADD,IDH_ETD_ADD,
	ID_VIEW,IDH_ETD_VIEW,
	IDC_RADIO_DEFAULT,IDH_ETD_RADIO_DEFAULT,
	IDC_RADIO_CUSTOM,IDH_ETD_RADIO_CUSTOM,
	ID_REMOVE,IDH_ETD_REMOVE,
	ID_PROPERTIES,IDH_ETD_PROPERTIES,
	IDC_APPLY,IDH_ETD_APPLY,
	0,0
};


const DWORD g_aHelpIDs_IDD_PROPERTIESDLG[]=
{
    ID_SOURCE_LABEL, IDH_STAT_SOURCE,
    ID_STAT_SOURCE, IDH_STAT_SOURCE,
    ID_OID_LABEL, IDH_PROP_EDIT_ENTERPRISEOID,
	IDC_EDIT_ENTERPRISEOID,IDH_PROP_EDIT_ENTERPRISEOID,
    ID_LOG_LABEL, IDH_STAT_LOG,
    ID_STAT_LOG, IDH_STAT_LOG,
    ID_EVENTID_LABEL, IDH_STAT_EVENTID,
    ID_STAT_EVENTID, IDH_STAT_EVENTID,
    ID_TRAPID_LABEL, IDH_PROP_EDIT_FULL_EVENT_ID,
	IDC_EDIT_FULL_EVENT_ID,IDH_PROP_EDIT_FULL_EVENT_ID,
    ID_THRESHOLD_LABEL, IDH_PROP_EVENTCOUNT,
    IDC_EVENTCOUNT,IDH_PROP_EVENTCOUNT,
	IDC_WITHINTIME,IDH_PROP_WITHINTIME,
	IDC_TIMEINTERVAL,IDH_PROP_TIMEINTERVAL,
	IDC_DESCRIPTION,IDH_PROP_DESCRIPTION,
	0,0
};


const DWORD g_aHelpIDs_IDD_SETTINGSDLG[]=
{
    IDC_LIMITMSGLNGTH,IDH_STDLG_LIMITMSGLNGTH,
    IDC_STAT_TRAP_LENGTH, IDH_STDLG_EDIT_MESSAGELENGTH,
	IDC_EDIT_MESSAGELENGTH,IDH_STDLG_EDIT_MESSAGELENGTH,
    IDC_RADIO1,IDH_STDLG_RADIO1,
	IDC_RADIO2,IDH_STDLG_RADIO2,
    IDC_RADIO_ENABLE,IDH_STDLG_RADIO_ENABLE,
    IDC_RADIO_DISABLE,IDH_STDLG_RADIO_DISABLE,
	IDC_BUTTON_RESET,IDH_STDLG_BUTTON_RESET,
    IDC_STATIC_NTRAPS, IDH_STDLG_EDIT_TRAP_COUNT,
	IDC_EDIT_TRAP_COUNT,IDH_STDLG_EDIT_TRAP_COUNT,
    IDC_STATIC_INTERVAL, IDH_STDLG_EDIT_TRAP_SECONDS,
    IDC_EDIT_TRAP_SECONDS,IDH_STDLG_EDIT_TRAP_SECONDS,
	IDC_STATIC_MSG, IDH_DISABLEHELP,
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\globals.cpp ===
#include "stdafx.h"
#include "trapreg.h"
#include "lcsource.h"
#include "lcevents.h"

CTrapReg g_reg;

// The default value for the comma separator is a comma.  This is replaced by the
// thousands separator generated by GetNumberFormat.
TCHAR g_chThousandSep = _T(','); 

// An array of boolean value to indicate whether the columns of the source and events list controls
// should be sorted in ascending or descending order.
BOOL g_abLcSourceSortAscending[ICOL_LcSource_MAX] = {TRUE, TRUE, TRUE, TRUE};        
BOOL g_abLcEventsSortAscending[ICOL_LcEvents_MAX] = {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\export.h ===
#ifndef _export_h
#define _export_h

class CXEventArray;
class CXEventSource;

class CDlgExport : private CFileDialog
{
public:
    CDlgExport();
    INT_PTR DoModal(CXEventArray& aEvents);

private:
    void GetFilters(LPTSTR pszDst);
    SCODE ExportEvents(CXEventArray& aEvents, CString& sPath, LONG iFileType);

    // Private member data.
    CString m_sFileTitle;
};


#endif //_export_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\export.cpp ===
//***********************************************************************
// export.cpp
//
// This file contains the implementation of the CDlgExport class.  This class
// puts up the "Export Events" dialog and handles writing the events out
// to an export file in the user-selected format.
//
// Author: Larry A. French
//
// History:
//      1-Mar-1996     Larry A. French
//          Wrote it.
//
//      14-May-1996     Larry A. French
//          Fixed a problem where the defines for the file extension included
//          a "." prefix instead of just the base extension.  This caused various
//          problems such as generting file names such as "foo..cnf" when the
//          user just entered "foo".
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//
//************************************************************************


#include "stdafx.h"
#include "busy.h"
#include "export.h"
#include "globals.h"
#include "trapreg.h"
//#include "smsnames.h"

//**************************************************************************
// CDlgExport::CDlgExport
//
// Constructor for the CDlgExport class.
//
//**************************************************************************
CDlgExport::CDlgExport() : CFileDialog(FALSE)
{
    // We need to strip off the "." prefix for the filename extensions
    // so that it is easier to use them.  Ideally we would just change
    // the defines for these extension strings, but since their definitions
    // are in a global file, we will just fix the problem here.
    m_ofn.Flags |= OFN_PATHMUSTEXIST;
    m_sFileTitle.LoadString(IDS_EXPORT_DEFAULT_FILENAME);
}

//**************************************************************
// CDlgExport::GetFilters
//
// Get the filter strings that will be used in CFileDialog.
// These are the filter strings that appear in the drop-down
// file-type combo.  Each filter is described by a pair of
// adjacent strings.  The first string of each pair specifies the
// "type" string that the user sees.  The second string of each
// pair specifies the file extension associated with the file type.
//
// For more information, please see the CFileDialog documentation.
//
// Parameters:
//      LPTSTR pszDst
//          Pointer to the destination buffer.  The size of this
//          buffer should be MAX_STRING, so there will be plenty
//          of room for the filter strings since they are relatively
//          short.  Note that no bounds checking is done on the
//          buffer size.
//
// Returns:
//      The filter strings are returned in the buffer pointed to
//      by pszDst.
//
//****************************************************************
void CDlgExport::GetFilters(LPTSTR pszDst)
{
    CString sText;

    // Set the type1 filter
    sText.LoadString(IDS_EXPORT_CNF_FILTER);
    _tcscpy(pszDst, (LPCTSTR) sText);
    pszDst += sText.GetLength() + 1;

    // Set the type1 extension
    _tcscpy(pszDst, FILE_DEF_EXT);
    pszDst += _tcslen(FILE_DEF_EXT) + 1;

    *pszDst = 0;
}

//*************************************************************************
// CDlgExport::ExportEvents
//
// Write the events to the specified file in the specified file format.
//
// Parameters:
//      CXEventArray& aEvents
//          The array of events to be written to the file.
//
//      CString& sPath
//          The output file's pathname.
//
//      LONG iFileType
//          The output file's format type. This may be EXPORT_TYPE1 or
//          EXPORT_TYPE2.
//
// Returns:
//      SCODE
//          S_OK if everything was successfule, otherwise E_FAIL.
//
//***************************************************************************
SCODE CDlgExport::ExportEvents(CXEventArray& aEvents, CString& sPath, LONG iFileType)
{
    CBusy busy;
    FILE* pfile;

    // Create the export file
    while (TRUE) {
        pfile = _tfopen(sPath, _T("w"));
        if (pfile != NULL) {
            break;
        }

        CString sText;
        sText.LoadString(IDS_ERR_CANT_CREATE_FILE);
        sText = sText + sPath;
        if (AfxMessageBox(sText, MB_RETRYCANCEL) == IDRETRY) {
            continue;
        }
        return E_FAIL;
    }

    // Write the events to the file in the requested format.
    LONG nEvents = aEvents.GetSize();
    for (LONG iEvent = 0; iEvent < nEvents; ++iEvent)
    {
        CXEvent* pEvent = aEvents[iEvent];
        CXEventSource* pEventSource = pEvent->m_pEventSource;
        CXEventLog* pEventLog = pEventSource->m_pEventLog;

        _ftprintf(pfile, _T("#pragma add %s \"%s\" %lu %lu %lu\n"),
                (LPCTSTR) pEventLog->m_sName,
                (LPCTSTR) pEventSource->m_sName,
                pEvent->m_message.m_dwId,
                pEvent->m_dwCount,
                pEvent->m_dwTimeInterval
                );
    }

    fclose(pfile);
    return S_OK;
}


//*************************************************************************************
// CDlgExport::DoModal
//
// This is the only public method for CDlgExport.  It displays the "Export Events" dialog
// and does everthing necessary to write out the event file in the proper format.
//
// Parameters:
//      CXEventArray& aEvents
//          The events that the user wants to export.
//
// Returns:
//      int
//          IDOK if the user exported the events and everything went OK.
//          IDCANCEL if the user canceled the export or an error occurred writing
//          the export file.
//
//**************************************************************************************
INT_PTR CDlgExport::DoModal(CXEventArray& aEvents)
{
    ASSERT(aEvents.GetSize() > 0);

    // Put up a custom CFileDialog with a title of "Export Events"
    CString sTitle;
    sTitle.LoadString(IDS_EXPORT_DIALOG_TITLE);
    m_ofn.lpstrTitle = sTitle;

    // The value to initialize the filename edit item to.  A temporary
    // string is used because we only want to save the file title and
    // not its full path.
    CString sFile = m_sFileTitle;
    m_ofn.lpstrFile = sFile.GetBuffer(MAX_STRING);
    m_ofn.nMaxFile = MAX_STRING - 1;

    // Set the file title, so that when the user clicks OK, its
    // value will be set.
    m_ofn.lpstrFileTitle = m_sFileTitle.GetBuffer(MAX_STRING);
    m_ofn.nMaxFileTitle = MAX_STRING - 1;

    // Set the filters for the different file types.
    TCHAR szFilters[MAX_STRING];
    GetFilters(szFilters);
    m_ofn.lpstrFilter = (LPCTSTR) (void*) szFilters;

    // Put up the dialog.
    INT_PTR iStat = CFileDialog::DoModal();
    m_sFileTitle.ReleaseBuffer();
    sFile.ReleaseBuffer();

    sFile = GetPathName();

    // If the user selected "OK", write out the event file in the selected format.
    if (iStat == IDOK)
    {
        SCODE sc = ExportEvents(aEvents, sFile, m_ofn.nFilterIndex);
        if (FAILED(sc)) {
            iStat = IDCANCEL;
        }
    }
    return iStat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\evntprop.h ===
// evntprop.h : header file
//

#ifndef EVNTPROP_H
#define EVNTPROP_H 

class CXEventArray;
class CXEvent;



/////////////////////////////////////////////////////////////////////////////
// CEditField window

class CEditField : public CEdit
{
// Construction
public:
	CEditField();
    SCODE CEditField::GetValue(int& iValue);

// Attributes
public:

// Operations
public:
    BOOL IsDirty() {return m_bIsDirty; }
    void ClearDirty() {m_bIsDirty = FALSE; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditField)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditField();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditField)
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
    BOOL m_bIsDirty;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CEditSpin window

class CEditSpin : public CSpinButtonCtrl
{
// Construction
public:
	CEditSpin();

// Attributes
public:
    int SetPos(int iPos);
    void SetRange(int nLower, int nUpper);
    BOOL IsDirty();
    void ClearDirty() {m_bIsDirty = FALSE; }

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditSpin)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditSpin();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditSpin)
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private: 
    BOOL m_bIsDirty;
    int m_iSetPos;
};




/////////////////////////////////////////////////////////////////////////////
// CEventPropertiesDlg dialog

class CEventPropertiesDlg : public CDialog
{
// Construction
public:
	CEventPropertiesDlg(CWnd* pParent = NULL);   // standard constructor
    BOOL EditEventProperties(CXEventArray& aEvents);

// Dialog Data
	//{{AFX_DATA(CEventPropertiesDlg)
	enum { IDD = IDD_PROPERTIESDLG };
	CButton	m_btnWithinTime;
	CEditSpin	m_spinEventCount;
	CEditSpin	m_spinTimeInterval;
	CEditField	m_edtTimeInterval;
	CEditField	m_edtEventCount;
	CButton	m_btnOK;
	CString	m_sDescription;
	CString	m_sSource;
	CString	m_sEventId;
	CString	m_sLog;
	CString	m_sSourceOID;
	CString	m_sFullEventID;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEventPropertiesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEventPropertiesDlg)
	virtual void OnOK();
	afx_msg void OnWithintime();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO*);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void MakeLabelsBold();
    CXEvent* m_pEvent;
    BOOL m_bDidEditEventCount;
    BOOL m_bDidFlipEventCount;
    
    int m_iEventCount;
    int m_iTimeInterval;
};

#endif // EVNTPROP_H
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\globals.h ===
#ifndef _globals_h

class CTrapReg;
extern CTrapReg g_reg;
extern TCHAR g_chThousandSep;  // The thousands separator character
extern BOOL g_abLcSourceSortAscending[];
extern BOOL g_abLcEventsSortAscending[];

#define MAX_STRING 1024
#define FILE_DEF_EXT    _T("*.*")

#endif //_globals_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\layout.h ===
//******************************************************************
// layout.h
//
// This file contains the declarations for the code hat lays out the 
// CTrapEventDialog. This is neccessary when the edit/view button changes the 
// dialog form its small (main) view to the extended view.
//
// Author: Larry A. French
//
// History:
//      20-Febuary-96  Wrote it
//
//
// Copyright (C) 1996 Microsoft Corporation.  All rights reserved.
//******************************************************************

#ifndef _layout_h
#define _layout_h

class CEventTrapDlg;
class CMainLayout;
class CExtendedLayout;

class CLayout
{
public:
    CLayout();
    void Initialize(CEventTrapDlg* pdlg);
	void LayoutAndRedraw(BOOL bExtendedView, int cx, int cy);
	void ShowExtendedView(BOOL bShow);
    void LayoutView(BOOL bExtendedView);

private:
    // Private member functions
	void ResizeMainLayout(CMainLayout& layoutMain);
	void ResizeExtendedLayout(CExtendedLayout& layoutExtended);

    // Private member data
    CEventTrapDlg* m_pdlg;
	CSize m_sizeMainViewInitial;
	CSize m_sizeExtendedViewInitial;
	int m_cyMainView;
	int m_cyExtendedView;
};

#endif //_layout_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\layout.cpp ===
//******************************************************************
// layout.cpp
//
// This file contains the code that lays out the CTrapEventDialog.
// This is neccessary when the edit/view button changes the 
// dialog form its small (main) view to the extended view.
//
// Author: Larry A. French
//
// History:
//      20-Febuary-96  Wrote it
//
//
// Copyright (C) 1996 Microsoft Corporation.  All rights reserved.
//******************************************************************

#include "stdafx.h"
#include "layout.h"
#include "trapdlg.h"
#include "trapreg.h"
#include "globals.h"



#define CX_MARGIN 10
#define CY_MARGIN 10
#define CY_LEADING 3
#define CY_DIALOG_FONT 8


class CDlgMetrics
{
public: 
	CDlgMetrics(CEventTrapDlg* pdlg);
	CSize m_sizeMargin;
	CSize m_sizeAddButton;
	CSize m_sizeRemoveButton;
	CSize m_sizeFindButton;
	CSize m_sizeOKButton;
	int m_cyLeading;
    CSize m_sizeLabel0;
	CSize m_sizeLabel1;
	CSize m_sizeLabel2;

    CSize m_sizeConfigTypeBox;
    CSize m_sizeConfigCustomButton;
    CSize m_sizeConfigDefaultButton;
};
		

//*****************************************************************
// CDlgMetrics::CDlgMetrics
//
// Construct an object containing the metrics for the CEventTrapDlg
//
// Parameters:
// 		CEventTrapDlg* pdlg
//			Pointer to an instance of the main event trap dialog.
//			This pointer is used to access members, such as buttons
//			and so on so that they can be measured.
//
// Returns:
//		The members of this class are valid on return.
//
//*****************************************************************
CDlgMetrics::CDlgMetrics(CEventTrapDlg* pdlg)
{
	m_sizeMargin.cx = CX_MARGIN;
	m_sizeMargin.cy = CY_MARGIN;
	m_cyLeading = CY_LEADING;

	CRect rc;

	pdlg->m_btnAdd.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeAddButton = rc.Size();

	pdlg->m_btnFind.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeFindButton = rc.Size();

	pdlg->m_btnRemove.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeRemoveButton = rc.Size();

	pdlg->m_statLabel0.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeLabel0 = rc.Size();

    pdlg->m_statLabel1.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeLabel1 = rc.Size();

	pdlg->m_statLabel2.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeLabel2 = rc.Size();

	pdlg->m_btnOK.GetWindowRect(&rc);
	pdlg->ScreenToClient(&rc);
	m_sizeOKButton = rc.Size();


    if (g_reg.m_bShowConfigTypeBox) {
    	pdlg->m_btnConfigTypeBox.GetWindowRect(&rc);
    	pdlg->ScreenToClient(&rc);
    	m_sizeConfigTypeBox = rc.Size();

    	pdlg->m_btnConfigTypeCustom.GetWindowRect(&rc);
    	pdlg->ScreenToClient(&rc);
    	m_sizeConfigCustomButton = rc.Size();

    	pdlg->m_btnConfigTypeDefault.GetWindowRect(&rc);
    	pdlg->ScreenToClient(&rc);
    	m_sizeConfigDefaultButton = rc.Size();
    }
    else {
        // If the "Configuration type box will not be shown, then the size of the
        // box and the radio buttons in it are all zero.
    	pdlg->m_btnConfigTypeBox.GetWindowRect(&rc);
        m_sizeConfigTypeBox.cx = 0;
        m_sizeConfigTypeBox.cy = 0;

        m_sizeConfigCustomButton.cx = 0;
        m_sizeConfigCustomButton.cy = 0;

        m_sizeConfigDefaultButton.cx = 0;
        m_sizeConfigDefaultButton.cy = 0;
    }
}







//////////////////////////////////////////////////////////////////////
// CLASS: CMainLayout
//
// This class computes the position of various items for the main (small)
// view of the dialog.  The metrics for each of these items is made
// available through public data members.
/////////////////////////////////////////////////////////////////////
class CMainLayout
{
public:
	void Create(CDlgMetrics& metrics, CRect& rc);
	CRect m_rc;
    CRect m_rcLabel0;
	CRect m_rcOKButton;
	CRect m_rcCancelButton;
    CRect m_rcApplyButton;
	CRect m_rcPropertiesButton;
	CRect m_rcSettingsButton;
    CRect m_rcExportButton;
	CRect m_rcViewButton;
	CRect m_rcListView;

    CRect m_rcConfigTypeBox;
    CRect m_rcConfigCustomButton;
    CRect m_rcConfigDefaultButton;
};

//*****************************************************************
// CMainLayout::Create
//
// Construct the layout for the main part of the dialog.  This is
// the part where the add event stuff is hidden. 
//
// Note: The caller is responsible for making sure that the 
// specified rectangle is large enough so that the display 
// still looks good.  For example, it doesn't make sense to shrink
// the listview to a zero size or even negative size.
//
// Parameters:
// 		CDlgMetrics& metrics
//			The dialog metrics containing the size of the things
//			that appear on the dialog and so on.
//
//		CRect& rc
//			The rectangle where the main part of the dialog will be
//			drawn.
//
// Returns:
//		The members of this class are valid on return.
//
//*****************************************************************
void CMainLayout::Create(CDlgMetrics& metrics, CRect& rc)
{
	m_rc = rc;

	// The rectangle for this layout may actually extend beyond the size
	// of the dialog window.  This can occur when the user shrinks the dialog
	// to a size smaller than the minimum for this layout.  
	//
	// Things that are drawn outside of the dialog are clipped.
	//

    // Set the rectangle for the "Configuration Type" groupbox
    m_rcConfigTypeBox.left = rc.left + metrics.m_sizeMargin.cx;
    m_rcConfigTypeBox.top = rc.top + metrics.m_sizeMargin.cy;
    m_rcConfigTypeBox.right = rc.right -  (metrics.m_sizeOKButton.cx + 2 * metrics.m_sizeMargin.cx);
    m_rcConfigTypeBox.bottom = m_rcConfigTypeBox.top + metrics.m_sizeConfigTypeBox.cy;

    // Set the rectangle for the "Custom" radio button within the "Configuration Type" groupbox
    // We place it right in the middle between the top and the bottom of the groupbox.
    m_rcConfigCustomButton.left = m_rcConfigTypeBox.left + metrics.m_sizeMargin.cx;
    m_rcConfigCustomButton.top = m_rcConfigTypeBox.top  + 
                        (metrics.m_sizeConfigTypeBox.cy/2 - metrics.m_sizeConfigCustomButton.cy/2) + CY_DIALOG_FONT/2;
    m_rcConfigCustomButton.right = m_rcConfigCustomButton.left + metrics.m_sizeConfigCustomButton.cx;
    m_rcConfigCustomButton.bottom = m_rcConfigCustomButton.top + metrics.m_sizeConfigCustomButton.cy;

    // Set the rectangle for the "Default" radio button within the "Configuration Type" groupbox
    m_rcConfigDefaultButton.left = m_rcConfigCustomButton.right + metrics.m_sizeMargin.cx;
    m_rcConfigDefaultButton.top = m_rcConfigCustomButton.top;
    m_rcConfigDefaultButton.right = m_rcConfigDefaultButton.left + metrics.m_sizeConfigDefaultButton.cx;
    m_rcConfigDefaultButton.bottom = m_rcConfigCustomButton.bottom;


    m_rcLabel0.left = m_rcConfigTypeBox.left;
    m_rcLabel0.top = m_rcConfigTypeBox.bottom;
    if (metrics.m_sizeConfigTypeBox.cy != 0) {
        // If the configuration type groupbox is present, then the event list
        // should be placed one margin height below it.
    	m_rcLabel0.top += metrics.m_sizeMargin.cy;
    }
    m_rcLabel0.right = m_rcLabel0.left + metrics.m_sizeLabel0.cx;
    m_rcLabel0.bottom = m_rcLabel0.top + metrics.m_sizeLabel0.cy;

	// Set the position of the top events listview.
	m_rcListView.left = m_rcConfigTypeBox.left;
  	m_rcListView.top = m_rcLabel0.bottom + metrics.m_sizeMargin.cy;
	m_rcListView.right = m_rcConfigTypeBox.right;
	m_rcListView.bottom = rc.bottom - metrics.m_sizeMargin.cy;

	// Set the position of the OK button
	m_rcOKButton.left = m_rcListView.right + metrics.m_sizeMargin.cx;
	m_rcOKButton.top = m_rcConfigTypeBox.top;
    if (metrics.m_sizeConfigTypeBox.cy != 0) {
        // If the configuration type groupbox is present, then the OK button should be
        // moved down by half the dialog font height so that it lines up with the
        // top of the groupbox's rectangle instead of the top of the group box's title.
        m_rcOKButton.top += CY_DIALOG_FONT / 2;
    }
	m_rcOKButton.right = m_rcOKButton.left + metrics.m_sizeOKButton.cx;
	m_rcOKButton.bottom = m_rcOKButton.top + metrics.m_sizeOKButton.cy;

	// Compute the vertical distance between buttons.
	int cyDelta = m_rcOKButton.Height() + metrics.m_sizeMargin.cy / 2;
	
	// Set the position of the Cancel button
	m_rcCancelButton = m_rcOKButton;
	m_rcCancelButton.OffsetRect(0, cyDelta);

    // Set the position of the Apply button
    m_rcApplyButton = m_rcCancelButton;
    m_rcApplyButton.OffsetRect(0, cyDelta);

	// Set the position of the settings button	
    m_rcSettingsButton = m_rcApplyButton;
	m_rcSettingsButton.OffsetRect(0, cyDelta);

	// Set the position of the properties button
	m_rcPropertiesButton = m_rcSettingsButton;
	m_rcPropertiesButton.OffsetRect(0, cyDelta);

	// Set the position of the export button	
	m_rcExportButton = m_rcPropertiesButton;
	m_rcExportButton.OffsetRect(0, cyDelta);

	// Set the position of the view button
	m_rcViewButton = m_rcExportButton;
	m_rcViewButton.OffsetRect(0, cyDelta);
}

	

//////////////////////////////////////////////////////////////////////
// CLASS: CExtendedLayout
//
// This class computes the position of various items for the extended
// view of the dialog.  The metrics for each of these items is made
// available through public data members.
/////////////////////////////////////////////////////////////////////
class CExtendedLayout
{
public:
	void Create(CDlgMetrics& metrics, CRect& rc);
	CRect m_rc;
	CRect m_rcTreeView;
	CRect m_rcListView;
	CRect m_rcFindButton;
	CRect m_rcAddButton;
	CRect m_rcRemoveButton;
	CRect m_rcLabel1;
	CRect m_rcLabel2;
private:
};



//*****************************************************************
// CExtendedLayout::Create
//
// Construct the layout for the extended part of the dialog.  This is
// the part where the add event stuff is shown.
//
// Note: The caller is responsible for making sure that the 
// specified rectangle is large enough so that the display 
// still looks good.  For example, it doesn't make sense to shrink
// the listview to a zero size or even negative size.
//
// Parameters:
// 		CDlgMetrics& metrics
//			The dialog metrics containing the size of the things
//			that appear on the dialog and so on.
//
//		CRect& rc
//			The rectangle where the main part of the dialog will be
//			drawn.
//
// Returns:
//		The members of this class are valid on return.
//
//*****************************************************************
void CExtendedLayout::Create(CDlgMetrics& metrics, CRect& rc)
{
	m_rc = rc;

	CRect rcTemp;
	// Calculate the combined width of the treeview and listview.
	// We subtract 3 * CX_MARGIN because there is a margin on 
	// the left and right and another margin to separate the right
	// side of the list view from the button.
	int cxViews = rc.Width() - (2*metrics.m_sizeMargin.cx);
	int cxTreeView = cxViews * 2 / 5;
	int cxListView = cxViews - cxTreeView;


	// Set the location of the add button.  This should be aligned with
	// the left side of the listview and one margin height below the
	// top of the given rectangle.
	m_rcAddButton.left = m_rc.left + metrics.m_sizeMargin.cx/2 + cxTreeView - metrics.m_sizeAddButton.cx;
	m_rcAddButton.top = m_rc.top + metrics.m_cyLeading;
	m_rcAddButton.right = m_rcAddButton.left + metrics.m_sizeAddButton.cx;
	m_rcAddButton.bottom = m_rcAddButton.top + metrics.m_sizeAddButton.cy;

	// Set the location of the remove button.  This should be aligned with the
	// top of the "Add" button and one margin size to the right of the add button.
	m_rcRemoveButton.left = m_rcAddButton.right + metrics.m_sizeMargin.cx;
	m_rcRemoveButton.top = m_rcAddButton.top;
	m_rcRemoveButton.right = m_rcRemoveButton.left + metrics.m_sizeRemoveButton.cx;
	m_rcRemoveButton.bottom = m_rcRemoveButton.top + metrics.m_sizeRemoveButton.cy;


	// Set the location of label1.  This is the label at the top-left
	// of the tree control
	m_rcLabel1.left = m_rc.left + metrics.m_sizeMargin.cx;
	m_rcLabel1.top = m_rcRemoveButton.bottom + metrics.m_cyLeading +  metrics.m_sizeMargin.cy;
	m_rcLabel1.right = m_rcLabel1.left + metrics.m_sizeLabel1.cx; 
	m_rcLabel1.bottom = m_rcLabel1.top + metrics.m_sizeLabel1.cy;


	// Set the location of label2.  This is at the top-left of the list box.
	m_rcLabel2.left = m_rcLabel1.left + cxTreeView;
	m_rcLabel2.top = m_rcLabel1.top;
	m_rcLabel2.right = m_rcLabel2.left + metrics.m_sizeLabel2.cx;
	m_rcLabel2.bottom = m_rcLabel2.top + metrics.m_sizeLabel2.cy;
	
	// Set the location of the tree view.  This is one margin size from
	// the left of m_rc and one margin size below the labels.  The width 
	// has been calulated above.  There is also a margin reserved on the
	// bottom.
	m_rcTreeView.left = m_rc.left + metrics.m_sizeMargin.cx;
	m_rcTreeView.top = m_rcLabel2.bottom + 1; // + metrics.m_sizeMargin.cy;
	m_rcTreeView.right = m_rcTreeView.left + cxTreeView;
	m_rcTreeView.bottom = m_rc.bottom - metrics.m_sizeMargin.cy;
	
	
	// Set the location of the list view.  This is the same height as the
	// tree view and aligned so that its left side is adjacent to the
	// right side of the treeview.  Its width has been calculated above.
	m_rcListView.left = m_rcTreeView.right - 1;
	m_rcListView.top = m_rcTreeView.top;
	m_rcListView.right = m_rcListView.left + cxListView;
	m_rcListView.bottom = m_rcTreeView.bottom;
		

	// Set the location of the find button so that it is aligned with the top of the
	// list view and so that its right side is one margin widh from m_rc.right.
	m_rcFindButton.left = m_rc.right - metrics.m_sizeFindButton.cx - metrics.m_sizeMargin.cx;
	m_rcFindButton.top = m_rcAddButton.top;
	m_rcFindButton.right = m_rcFindButton.left + metrics.m_sizeFindButton.cx;
	m_rcFindButton.bottom = m_rcFindButton.top + metrics.m_sizeFindButton.cy;
}


//************************************************************************
// CLayout::CLayout
//
// Constructor for CLayout. This class is used to layout the items on
// the CEventTrapDialog when it is changed from the large extended view to
// the small main view.  This class also handles resizing the CEventTrapDialog.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//************************************************************************
CLayout::CLayout()
{
    m_pdlg = NULL;
}


//************************************************************************
// CLayout::Initialize
//
// Take a snapshot of various initial attributes of the dialog and its
// items. These attributes are used later to constrain the size of the
// dialog and so on.  
//
// This makes it possible to set certain characteristics of the dialog
// in the resource editor so that they do not need to be hard-coded here.
//
// Parameters:
//      CEventTrapDlg* pdlg
//          Pointer to the dialog that needs to be laid out, resized
//          and so on.
//
// Returns:
//      Nothing.
//
//***********************************************************************
void CLayout::Initialize(CEventTrapDlg* pdlg)
{
    ASSERT(m_pdlg == NULL);
    m_pdlg = pdlg;

    // Dialog layout stuff
	CRect rcWindow;
	pdlg->GetWindowRect(&rcWindow);

	CRect rcClient;
	pdlg->GetClientRect(&rcClient);


	CRect rcEventList;	
	pdlg->m_lcEvents.GetWindowRect(&rcEventList);
	pdlg->ScreenToClient(&rcEventList);
	

	m_sizeMainViewInitial.cx = rcClient.right;
	m_sizeMainViewInitial.cy = 	rcEventList.bottom + CY_MARGIN;


	m_sizeExtendedViewInitial.cx = rcClient.right;
	m_sizeExtendedViewInitial.cy = rcClient.bottom;

	m_cyMainView = 0;
	m_cyExtendedView = 0;
}


//*************************************************************************
// CLayout::ResizeMainLayout
//
// This method resizes and repositions the dialog components that appear
// int the small dialog layout.
//
// Parameters:
//      CMainLayout& layoutMain
//          The layout information for the small (main) layout.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CLayout::ResizeMainLayout(CMainLayout& layoutMain)
{
	m_pdlg->m_btnConfigTypeBox.MoveWindow(&layoutMain.m_rcConfigTypeBox, TRUE);
	m_pdlg->m_btnConfigTypeCustom.MoveWindow(&layoutMain.m_rcConfigCustomButton, TRUE);
	m_pdlg->m_btnConfigTypeDefault.MoveWindow(&layoutMain.m_rcConfigDefaultButton, TRUE);
    
	m_pdlg->m_btnOK.MoveWindow(&layoutMain.m_rcOKButton, TRUE);
	m_pdlg->m_btnCancel.MoveWindow(&layoutMain.m_rcCancelButton, TRUE);
    m_pdlg->m_btnApply.MoveWindow(&layoutMain.m_rcApplyButton, TRUE);
	m_pdlg->m_btnProps.MoveWindow(&layoutMain.m_rcPropertiesButton, TRUE);
	m_pdlg->m_btnSettings.MoveWindow(&layoutMain.m_rcSettingsButton, TRUE);
	m_pdlg->m_btnExport.MoveWindow(&layoutMain.m_rcExportButton, TRUE);
	m_pdlg->m_btnView.MoveWindow(&layoutMain.m_rcViewButton, TRUE);
	m_pdlg->m_lcEvents.MoveWindow(&layoutMain.m_rcListView, TRUE);
}



//*************************************************************************
// CLayout::ResizeExtendedLayout
//
// This method resizes and repositions the dialog components that appear
// int the large (extended) dialog layout.
//
// Parameters:
//      CExtendedLayout& layoutExtended
//          The layout information for the large (extended) layout.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CLayout::ResizeExtendedLayout(CExtendedLayout& layoutExtended)
{
	m_pdlg->m_btnAdd.MoveWindow(&layoutExtended.m_rcAddButton, TRUE);
	m_pdlg->m_btnRemove.MoveWindow(&layoutExtended.m_rcRemoveButton, TRUE);
	m_pdlg->m_btnFind.MoveWindow(&layoutExtended.m_rcFindButton, TRUE);
	m_pdlg->m_statLabel1.MoveWindow(&layoutExtended.m_rcLabel1, TRUE);
	m_pdlg->m_statLabel2.MoveWindow(&layoutExtended.m_rcLabel2, TRUE);
	m_pdlg->m_tcSource.MoveWindow(&layoutExtended.m_rcTreeView, TRUE);
	m_pdlg->m_lcSource.MoveWindow(&layoutExtended.m_rcListView, TRUE);
}




//*************************************************************************
// CLayout::LayoutAndRedraw
//
// This lays out the size and position of each component on the dialog and
// then redraws the dialog according to the new layout.
//
// Parameters:
//      BOOL bExtendedView
//          TRUE if the layout should be for the large (extended) view of
//          the dialog, FALSE if the layout should be for the small (main)
//          view of the dialog.
//
//      int cx
//          The desired width of the dialog in screen units.
//
//      int cy
//          The desired height of the dialog in screen units.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CLayout::LayoutAndRedraw(BOOL bExtendedView, int cx, int cy)
{	
	// If the user sizes the window smaller than its original size, then
	// the window will begin to obscure what is already there rather than
	// try to make things smaller.  This avoids the problems that would 
	// occur if buttons and other controls overlapped each other.
	BOOL bLayoutWidth = TRUE;
	BOOL bLayoutHeight = TRUE;

	if (bExtendedView) {
        // Limit the minimum size of the extended view
		if (cx < m_sizeExtendedViewInitial.cx) {
			cx = m_sizeExtendedViewInitial.cx;
			bLayoutWidth = FALSE;
		}

		if (cy < m_sizeExtendedViewInitial.cy) {
			cy = m_sizeExtendedViewInitial.cy;
			bLayoutHeight = FALSE;
		}
		m_cyExtendedView = cy;
	}
	else {
        // Limit the minimum size for the small (main) view
		if (cx < m_sizeMainViewInitial.cx) {
			cx = m_sizeMainViewInitial.cx;
			bLayoutWidth = FALSE;
		}

		if (cy < m_sizeMainViewInitial.cy) {
			cy = m_sizeMainViewInitial.cy;
			bLayoutHeight = FALSE;
		}
		m_cyMainView = cy;
	}



	CDlgMetrics metrics(m_pdlg);
	CMainLayout layoutMain;
	CExtendedLayout layoutExtended;
	CRect rcMain;
	CRect rcExtended;

	int cyMain = cy;
	if (bExtendedView) {
        // For the extended view, half the space if given to the components that
        // appear on the small (main) layout, and the extended components get 
        // half the space.  Thus, the dialog is split horizontally at the half-way
        // point for the extended view.
		cyMain = cy / 2;
		rcMain.SetRect(0, 0, cx, cy / 2);
		layoutMain.Create(metrics, rcMain);
		ResizeMainLayout(layoutMain);

        // The extended component rectangle's top is at the half-way point. The bottom
        // is at the bottom of the dialog.
		rcExtended.SetRect(0, cy / 2, cx, cy);
		layoutExtended.Create(metrics, rcExtended);
		ResizeExtendedLayout(layoutExtended);
	}
	else {
        // For the small (main) view, use the entire dialog.
		rcMain.SetRect(0, 0, cx, cy);
		layoutMain.Create(metrics, rcMain);
		ResizeMainLayout(layoutMain);
	}
		

	// Redraw the entire client area to fix things up since much
	// of the stuff in the client has moved around.
	CRect rcClient;
	m_pdlg->GetClientRect(&rcClient);
	m_pdlg->InvalidateRect(&rcClient);
	
}


//**************************************************************
// CLayout::LayoutView
//
// This method lays out the position and size of the CEventTrap
// dialog and the items that appear on it.
//
// Parameters:
//      BOOL bExtendedView
//          TRUE if this is a request to layout the extended (large)
//          view of the dialog.  FALSE if this is a request to layout
//          the small (main) view of the dialog.
//
// Returns:
//      Nothing.
//**************************************************************
void CLayout::LayoutView(BOOL bExtendedView)
{
	CRect rcWindow;
	m_pdlg->GetWindowRect(&rcWindow);

	CRect rcClient;
	m_pdlg->GetClientRect(&rcClient);
	m_pdlg->ClientToScreen(&rcClient);

    // cx and cy are the width and height of the dialog in client units
    // respectively.  The code below will calculate new values for cx and
    // cy to reflect the change from extended view to small (main) view
    // or vice-versa.
	int cx = rcClient.Width();
	int cy = rcClient.Height();
	int cxInitial = cx;
	int cyInitial = cy;

    // Compute the margins that intervene between the client
    // rectangle and window rectangle.
	int cxLeftMargin = rcClient.left - rcWindow.left;
	int cyTopMargin = rcClient.top - rcWindow.top;
	int cxRightMargin = rcWindow.right - rcClient.right;
	int cyBottomMargin = rcWindow.bottom - rcClient.bottom;


	CRect rc;
	m_pdlg->GetClientRect(&rc);
	
	if (bExtendedView) {
        // Control comes here if we are changing from the small main view
        // to the larger extended view.  This causes the dialog to flip 
        // back to the previous size of the extended view.  However this
        // is constrained to a minimum of the original dialog size.

        // Save the current height of the main view so that we can flip
        // back to it later.  Assume that the new height will be the
        // height of the extended view when it was flipped the last time.
		m_cyMainView = cy;
		cy = m_cyExtendedView;		

        // Constrain the height so that the mimimum height is what it
        // the initial height was for the extended view.
		if (cx < m_sizeExtendedViewInitial.cx) {
			cx = m_sizeExtendedViewInitial.cx;
		}

		if (cy < m_sizeExtendedViewInitial.cy) {
			cy = m_sizeExtendedViewInitial.cy;
		}


        // The extended view should never be smaller than the main view.
        // This check is necessary when the user resizes the window and
        // then flips the view.
        if (cy < m_cyMainView) {
            cy = m_cyMainView;
        }


		
		rc.SetRect(0, 0, cx, cy);

        // Check to see if the size changed, if not then do nothing.
        // Otherwise, resize the window.
		if ((cxInitial != cx) || (cyInitial != cy)) {			
			m_pdlg->ClientToScreen(&rc);
			rc.left -= cxLeftMargin;
			rc.top -= cyTopMargin;
			rc.right += cxRightMargin;
			rc.bottom += cyBottomMargin;
			m_pdlg->MoveWindow(&rc, TRUE);
		}
		else {
			LayoutAndRedraw(bExtendedView, cx, cy);
		}
	}

    // The main view should never be taller than the extended view.  This may
    // check is necessary if the user resized the window and then flipped to the
    // other view.
    if (m_cyMainView > m_cyExtendedView) {
        m_cyMainView = m_cyExtendedView;
    }

    // Show or hide the items in the extended portion of the dialog.
	ShowExtendedView(bExtendedView);


	if (!bExtendedView) {
		// This used to be an extended view, now we need to
		// go back to just the main view.

		// Save the current extended view height and then flip back to the
        // previously saved main (small) view height.
		m_cyExtendedView = cy;
		cy = m_cyMainView;

        // Constrain the size to be at least as large as the initial size for
        // the main (small) view.		
		if (cx < m_sizeMainViewInitial.cx) {
			cx = m_sizeMainViewInitial.cx;
		}
		if (cy < m_sizeMainViewInitial.cy) {
			cy = m_sizeMainViewInitial.cy;
		}


        // Resize the dialog only if the computed size is different
        // from the current size. Moving the window to resize it will automatically
        // cause it to be layed out correctly.
		if ((cxInitial != cx) || (cyInitial != cy)) {
			rc.SetRect(0, 0, cx, cy);
			m_pdlg->ClientToScreen(&rc);
			rc.left -= cxLeftMargin;
			rc.top -= cyTopMargin;
			rc.right += cxRightMargin;
			rc.bottom += cyBottomMargin;
			m_pdlg->MoveWindow(&rc, TRUE);
		}
		else {
			LayoutAndRedraw(bExtendedView, cx, cy);
		}
	}
}


//**************************************************************
// CLayout::ShowExtendedView
//
// This method shows or hides the dialog items that make up the
// extended portion of the dialog.
//
// Parameters:
//      BOOL bShowExtendedItems
//          TRUE if the extended items should be shown, false if
//          they should be hidden.
//
// Returns:
//      Nothing.
//**************************************************************
void CLayout::ShowExtendedView(BOOL bShowExtendedItems)
{
	m_pdlg->m_btnRemove.ShowWindow(bShowExtendedItems);
	m_pdlg->m_btnAdd.ShowWindow(bShowExtendedItems);
	m_pdlg->m_btnFind.ShowWindow(bShowExtendedItems);
	m_pdlg->m_lcSource.ShowWindow(bShowExtendedItems);
	m_pdlg->m_tcSource.ShowWindow(bShowExtendedItems);
	m_pdlg->m_statLabel1.ShowWindow(bShowExtendedItems);
	m_pdlg->m_statLabel2.ShowWindow(bShowExtendedItems);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\lcevents.cpp ===
// lcevents.cpp : implementation file
//

#include "stdafx.h"
#include "eventrap.h"
#include "lcevents.h"
#include "settings.h"
#include "source.h"
#include "globals.h"
#include "utils.h"
#include "lcsource.h"
#include "busy.h"
#include "trapreg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif




/////////////////////////////////////////////////////////////////////////////
// CLcEvents

CLcEvents::CLcEvents()
{
    m_dwSortColumn = ICOL_LcEvents_LOG;
    m_cxWidestMessage = CX_DEFAULT_DESCRIPTION_WIDTH;
}

CLcEvents::~CLcEvents()
{
}


BEGIN_MESSAGE_MAP(CLcEvents, CListCtrl)
	//{{AFX_MSG_MAP(CLcEvents)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


SCODE CLcEvents::CreateWindowEpilogue()
{
	ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_FULLROWSELECT);
	SetColumnHeadings();
    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CLcEvents message handlers





//***************************************************************************
//  CLcEvents::SelectEvents
//
//  Select the specified events in the list control.
//
//  Parameters:
//		CXEventArray& aEvents
//          An array of event pointers.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::SelectEvents(CXEventArray& aEventsSel)
{
    int iItemFirstSelection = -1;
    LONG nItems = GetSize();
    for (LONG iItem = 0; iItem < nItems; ++iItem) {
        CXEvent* pEventTrapping = GetAt(iItem);

        // If the event associated with this item is in aEvents, then select the item.
        // Otherwise clear selection on the item.
        BOOL bDidFindEvent = FALSE;
        LONG nEventsSel = aEventsSel.GetSize();
        for (LONG iEventSel = 0; iEventSel < nEventsSel; ++iEventSel) {
            CXEvent* pEventSel;
            pEventSel = aEventsSel[iEventSel];
            if ((pEventSel->m_message.m_dwId == pEventTrapping->m_message.m_dwId) &&
                (pEventSel->m_pEventSource == pEventTrapping->m_pEventSource) &&
                (pEventSel->m_pEventSource->m_pEventLog == pEventTrapping->m_pEventSource->m_pEventLog)) {

                bDidFindEvent = TRUE;
                if (iItemFirstSelection == -1) {
                    iItemFirstSelection = iItem;
                }
                break;
            }
        }

        SetItemState(iItem, bDidFindEvent ? LVIS_SELECTED : 0, LVIS_SELECTED);
    }

    // Scroll the first selected item into view.
    if (iItemFirstSelection > 0) {
        EnsureVisible(iItemFirstSelection, FALSE);
    }
}






//***************************************************************************
//
//  CLcEvents::SetColumnHeadings
//
//  Define's the columns for this list control.  The column title, width, and
//  order is defined here.
//
//  Parameters:
//		None.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::SetColumnHeadings()
{
 	static UINT auiResColumnTitle[ICOL_LcEvents_MAX] = {
        IDS_LcEvents_TITLE_LOG,
        IDS_LcEvents_TITLE_SOURCE,
		IDS_LcEvents_TITLE_ID,
		IDS_LcEvents_TITLE_SEVERITY,
        IDS_LcEvents_TITLE_COUNT,
        IDS_LcEvents_TITLE_TIME,
		IDS_LcEvents_TITLE_DESCRIPTION
	};

	static int aiColWidth[ICOL_LcEvents_MAX] = {75, 60, 60, 60, 50, 50, CX_DEFAULT_DESCRIPTION_WIDTH};


    // Build the columns in the AllEventsList control.
    LV_COLUMN lvcol;
    lvcol.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    for (int iCol=0; iCol<ICOL_LcEvents_MAX; ++iCol)
    {
		CString sColTitle;
		sColTitle.LoadString(auiResColumnTitle[iCol]);

        lvcol.pszText = sColTitle.GetBuffer(sColTitle.GetLength());
        lvcol.iSubItem = iCol;
        lvcol.cx = aiColWidth[iCol];
        InsertColumn(iCol, &lvcol);
		sColTitle.ReleaseBuffer();
    }
}



//********************************************************************
// CLcEvents::AddEvents
//
// Add all the events for all the event sources contained in the
// event-log array.   The source is notified that each of these
// events is being trapped.
//
// Parameters:
//      CSource& source
//          The message source container.
//
//      CEventLogArray& aEventLogs
//          An array of event-logs.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CLcEvents::AddEvents(CSource& source, CXEventLogArray& aEventLogs)
{
    // Iterate though all the event logs.
    LONG nLogs = aEventLogs.GetSize();
    for (LONG iLog=0; iLog < nLogs; ++iLog) {
        CXEventLog* pEventLog = aEventLogs[iLog];

        // Iterate through all the event sources within this event log
        LONG nSources = pEventLog->m_aEventSources.GetSize();
        for (LONG iSource = 0; iSource < nSources; ++iSource) {

            // Add all the events for the source to this list control.
            CXEventSource* pEventSource = pEventLog->m_aEventSources[iSource];
            AddEvents(source, pEventSource->m_aEvents);
        }
    }

	if (GetSize() > 0 && !HasSelection())
	{
		SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
	}
}





//***************************************************************************
//
//  CLcEvents::AddEvents
//
//  Add an array of events to this list control.  This involves the following
//      a. Add each event to the list control
//      b. Notify the CLcSource that the event has been modified so that it
//         can update the trapping flag.
//      c. Sort the events by the most recently selected column.
//      d. Make sure that the first item in CEventArray passed in is visible.
//
//  Parameters:
//      CSource& source
//          A reference to the CSource object.  This object must be notified
//          when the trapping status of an event changes.
//
//		CEventArray& aEvents
//          An array containing pointers to the events to add.  This list control
//          then becomes the owner of these events.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::AddEvents(CSource& source, CXEventArray& aEvents)
{
    CBusy busy;

    // Now add them into this list control.  This is where they actually
    LONG nEvents = aEvents.GetSize();
    LONG iEvent;

    // Unselect all the previous items first
    iEvent = -1;
    do
    {
        iEvent = GetNextItem(iEvent, LVNI_SELECTED);
        if (iEvent == -1)
            break;
        SetItemState(iEvent, ~LVIS_SELECTED, LVIS_SELECTED);
    } while (TRUE);

    for (iEvent = 0; iEvent < nEvents; ++iEvent) {
        if ((iEvent < 40 && (iEvent % 10 == 9)) ||
            (iEvent % 100 == 99)) {
            UpdateWindow();
        }

        CXEvent* pEvent = aEvents[iEvent];
        AddEvent(pEvent);
        source.NotifyTrappingChange(pEvent->m_pEventSource, pEvent->m_message.m_dwId, TRUE);
    }

    UpdateDescriptionWidth();

    // Sort the items by the most recently selected column, and then
    // make sure the first item is visible.
    SortItems(m_dwSortColumn);
    if (nEvents > 0) {
        iEvent = FindEvent(aEvents[0]);
        EnsureVisible(iEvent, TRUE);
    }
}


//***************************************************************************
//
//  CLcEvents::AddEvent
//
//  Add an event to the list control. This sets the text for each column in
//  the list view and sets the lParam field of the list-view item to pEvent
//
//
//  Parameters:
//		CEvent* pEvent
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
LONG CLcEvents::AddEvent(CXEvent* pEvent)
{
    // Insert a new item into this list control.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_TEXT | LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcEvents_LOG;
    lvitem.lParam = (LPARAM)pEvent;
    lvitem.cchTextMax = pEvent->m_message.m_sText.GetLength() + 1;
    lvitem.pszText = (LPTSTR)(void*)(LPCTSTR) (pEvent->m_message.m_sText);
    LONG nItem = CListCtrl::InsertItem(&lvitem);

    SetItem(nItem, pEvent);
    SetItemState(nItem, LVIS_SELECTED, LVIS_SELECTED);
    return nItem;
}



//********************************************************************
// CLcEvents::SetItem
//
// Refresh an item from an event.
//
// Parameters:
//      LONG nItem
//
//      CEvent* pEvent
//          Pointer to the event to copy the data from.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CLcEvents::SetItem(LONG nItem, CXEvent* pEvent)
{


    // Check the item index against the array bounds.
    if (nItem < 0 || nItem >= GetItemCount()) {
        ASSERT(FALSE);
        return;
    }

    ASSERT(GetItemData(nItem) == (DWORD) (void*) pEvent);

    // Get the pointer for brevity.
    CXEventSource* pEventSource = pEvent->m_pEventSource;
	CString sText;

    SetItemData(nItem, (DWORD_PTR) (void*) pEvent);

    SetItemText(nItem, ICOL_LcEvents_LOG, (LPTSTR) (LPCTSTR) pEventSource->m_pEventLog->m_sName);

	SetItemText(nItem, ICOL_LcEvents_SOURCE, (LPTSTR)(LPCTSTR) pEventSource->m_sName);

    pEvent->m_message.GetShortId(sText);
    SetItemText(nItem, ICOL_LcEvents_ID, (LPTSTR)(LPCTSTR)sText);

    pEvent->m_message.GetSeverity(sText);
    SetItemText(nItem, ICOL_LcEvents_SEVERITY, (LPTSTR)(LPCTSTR)sText);

    pEvent->GetCount(sText);
    SetItemText(nItem, ICOL_LcEvents_COUNT, (LPTSTR)(LPCTSTR)sText);

    pEvent->GetTimeInterval(sText);
    SetItemText(nItem, ICOL_LcEvents_TIME, (LPTSTR)(LPCTSTR)sText);

    SetItemText(nItem, ICOL_LcEvents_DESCRIPTION, (LPTSTR)(LPCTSTR)pEvent->m_message.m_sText);

}



//***************************************************************************
//
//  CLcEvents::DeleteSelectedEvents.
//
//  Delete all of the currently selected events and the corresponding items.
//
//  Parameters:
//      None.
//
//  Returns:
//      Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::DeleteSelectedEvents(CSource& source)
{

    // Delete all the selected items from the list control.
    // Build an array of event pointers corresponding to the events that are selected
    // in the list control.  Also notify the event source view that the event is no
    // longer being trapped.
   	while (TRUE) {
		int iItem = GetNextItem(-1, LVNI_SELECTED);
		if (iItem == -1) {
			break;
		}
        CXEvent* pEvent = GetAt(iItem);
        DeleteItem(iItem);
        source.NotifyTrappingChange(pEvent->m_pEventSource, pEvent->m_message.m_dwId, FALSE);
        delete pEvent;
	}
    UpdateDescriptionWidth();
}



//***************************************************************************
//
//  CLcEvents::GetAt
//
//  This method returns the event pointer located at the given item index.
//  This allows CLcEvents to be used much as an array.
//
//  Parameters:
//		LONG iItem
//			The item index.
//
//  Returns:
//		A pointer to the CEvent stored at the specified index.
//
//  Status:
//
//***************************************************************************
CXEvent* CLcEvents::GetAt(LONG iItem)
{

	// Setup the LV_ITEM structure to retrieve the lparam field.
	// This field contains the CMessage pointer.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcEvents_LOG;	
    lvitem.iItem = iItem;
    GetItem(&lvitem);

	CXEvent* pEvent = (CXEvent*) (void*) lvitem.lParam;
	return pEvent;
}










//***************************************************************************
//
//  CLcEvents::GetSelectedEvents
//
//  Get the events corresponding to the selected items in this list control.
//  This list control continues to own the event pointers.
//
//  Parameters:
//		CEventArray& aEvents
//			A reference to the event array where the event pointers are returned.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::GetSelectedEvents(CXEventArray& aEvents)
{

	// Clear the message array
	aEvents.RemoveAll();

	// Setup the LV_ITEM structure to retrieve the lparam field.
	// This field contains the CMessage pointer.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcEvents_LOG;

	// Loop to find all the selected items.	
	int nItem = -1;
	while (TRUE) {
		nItem = GetNextItem(nItem, LVNI_SELECTED);
		if (nItem == -1) {
			break;
		}

		// Get the CMessage pointer for this item and add it to the
		// array.
        lvitem.iItem = nItem;
        GetItem(&lvitem);
		CXEvent* pEvent = (CXEvent*) (void*) lvitem.lParam;
		aEvents.Add(pEvent);
	}
}



//***************************************************************************
//
//  CLcEvents::FindEvent
//
//  Find the specified event and return its item number.
//
//  Parameters:
//		CEvent* pEvent
//			A pointer to the event to search for.
//
//  Returns:
//		The item index if the item was found, otherwise -1.
//
//  Status:
//
//***************************************************************************
LONG CLcEvents::FindEvent(CXEvent* pEvent)
{

    LONG nEvents = GetItemCount();
    for (LONG iEvent = 0; iEvent < nEvents; ++iEvent) {
        CXEvent* pEventTemp = GetAt(iEvent);
        if (pEventTemp == pEvent) {
            return iEvent;
        }
    }
    return -1;
}



//***************************************************************************
//
//  CLcEvents::RefreshEvents
//
//  This method is called when the properties of some number of events
//  have changed and the corresponding items in the list control need
//  to be updated.
//
//  Parameters:
//		CEventArray& aEvents
//			The events that need to be refreshed.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::RefreshEvents(CXEventArray& aEvents)
{
    // Iterate through each of the events and refresh them.
    LONG nEvents = aEvents.GetSize();
    for (LONG iEvent = 0; iEvent < nEvents; ++iEvent) {
        CXEvent* pEvent = aEvents[iEvent];
        LONG nEvent = FindEvent(pEvent);
        SetItem(nEvent, pEvent);
    }
}





int CALLBACK CompareEventsProc(LPARAM lParam1, LPARAM lParam2, LPARAM
   lParamSort)
{
    CXEvent* pEvent1 = (CXEvent *)lParam1;
    CXEventSource* pEventSource1 = pEvent1->m_pEventSource;

    CXEvent* pEvent2 = (CXEvent *)lParam2;
    CXEventSource* pEventSource2 = pEvent2->m_pEventSource;


    ASSERT((pEvent1 != NULL) && (pEvent2 != NULL));
    int nResult = 0;
    CString sText1, sText2;

    switch( lParamSort)
    {
    case ICOL_LcEvents_LOG:
        // Sort by log, then by source, then by ID
        nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
            if (nResult == 0) {
                 nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
            }
        }
        break;
    case ICOL_LcEvents_SOURCE:
        // Sort by source, then by Log, then by ID
        nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                 nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
            }
        }
        break;
    case ICOL_LcEvents_ID:
        // Sort by ID, then by log, then by source.
        nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
            }
        }
        break;
    case ICOL_LcEvents_SEVERITY:
        // Sort by severity, then by log, then by source, then by ID
        pEvent1->m_message.GetSeverity(sText1);
        pEvent2->m_message.GetSeverity(sText2);
        nResult = lstrcmp(sText1, sText2);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
                if (nResult == 0) {
                     nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
                }
            }
        }
        break;
    case ICOL_LcEvents_COUNT:
        // Sort by count, then by log, then by source, then by ID
        pEvent1->GetCount(sText1);
        pEvent2->GetCount(sText2);
        nResult = lstrcmp(sText1, sText2);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
                if (nResult == 0) {
                     nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
                }
            }
        }
        break;
    case ICOL_LcEvents_TIME:
        // Sort by time, then by log, then by source, then by ID
        pEvent1->GetTimeInterval(sText1);
        pEvent2->GetTimeInterval(sText2);
        nResult = lstrcmp(sText1, sText2);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
                if (nResult == 0) {
                     nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
                }
            }
        }
        break;
    case ICOL_LcEvents_DESCRIPTION:
        // Sort by description, then by log, then by source, then by ID
        nResult = lstrcmp(pEvent1->m_message.m_sText, pEvent2->m_message.m_sText);
        if (nResult == 0) {
            nResult = lstrcmp(pEventSource1->m_pEventLog->m_sName, pEventSource2->m_pEventLog->m_sName);
            if (nResult == 0) {
                nResult = lstrcmp(pEventSource1->m_sName, pEventSource2->m_sName);
                if (nResult == 0) {
                     nResult = ((LONG) pEvent1->m_message.GetShortId()) - ((LONG) pEvent2->m_message.GetShortId());
                }
            }
        }
        break;
    default:
        ASSERT(FALSE);
        break;
    }


    if (!g_abLcEventsSortAscending[lParamSort]) {
        if (nResult > 0) {
            nResult = -1;
        }
        else if (nResult < 0) {
            nResult = 1;
        }
    }

    return nResult;
}


//***************************************************************************
//
//  CLcEvents::SortItems
//
//  Sort the items in this list control given the column index.  This method
//  hides all details about the sort implementation from this class's clients.
//
//  Parameters:
//		DWORD dwColumn
//			The column to use as the sort key.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CLcEvents::SortItems(DWORD dwColumn)
{
    CListCtrl::SortItems(CompareEventsProc, dwColumn);
    m_dwSortColumn = dwColumn;
}





//****************************************************************************
// CLcEvents::UpdateDescriptionWidth()
//
// Measure the message description string associated with each item and set the
// width of the description column to match the widest message length plus a
// little extra room for slop and appearances.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*****************************************************************************
void CLcEvents::UpdateDescriptionWidth()
{
    LONG cxWidestMessage = CX_DEFAULT_DESCRIPTION_WIDTH;
    LONG nEvents = GetItemCount();
    for (LONG iEvent = 0; iEvent < nEvents; ++iEvent) {
        CXEvent* pEvent = GetAt(iEvent);
        int cx = GetStringWidth(pEvent->m_message.m_sText);
        if (cx > cxWidestMessage) {
            cxWidestMessage = cx;
        }
    }


    // Set the column width to the width of the widest string plus a little extra
    // space for slop and to make it obvious to the user that the complete string
    // is displayed.
    SetColumnWidth(ICOL_LcEvents_DESCRIPTION, cxWidestMessage + CX_DESCRIPTION_SLOP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\lcevents.h ===
#ifndef _lcevents_h
#define _lcevents_h

class CXEventLogArray;
class CXMessageArray;
class CXEventArray;
class CXEvent;
class CSource;
class CLcEvents;



/////////////////////////////////////////////////////////////////////////////
// CLcEvents window
class CEvent;
class CLcEvents : public CListCtrl
{
// Construction
public:
	CLcEvents();
	SCODE CreateWindowEpilogue();


// Attributes
public:

// Operations
public:
    LONG GetSize() {return GetItemCount(); }
    CXEvent* GetAt(LONG iEvent);
    void RemoveAll();
    void RemoveAt(int nIndex, int nCount = 1);
    void AddEvents(CSource& source, CXEventArray& aEvents);
    void AddEvents(CSource& source, CXEventLogArray& aEventLogs);
    void DeleteSelectedEvents(CSource& source);
    void DeleteAt(LONG iEvent);
    BOOL HasSelection() {return GetNextItem(-1, LVNI_SELECTED) != -1; }
    void GetSelectedEvents(CXEventArray& aEvents);
    void RefreshEvents(CXEventArray& aEvents);
    void SetItem(LONG nItem, CXEvent* pEvent);
    LONG FindEvent(CXEvent* pEvent);
    void SortItems(DWORD dwColumn);
    void SelectEvents(CXEventArray& aEvents);

//    BOOL GetItem(LV_ITEM* pItem) const;


// Overrides

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLcEvents)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLcEvents();

	// Generated message map functions
protected:
	//{{AFX_MSG(CLcEvents)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
    void UpdateDescriptionWidth();
    LONG AddEvent(CXEvent* pEvent);
    void CreateEventsNotTrapped(CXMessageArray& amsg, CXEventArray& aevents);
	void SetColumnHeadings();
    DWORD m_dwSortColumn;
    LONG m_cxWidestMessage;

};

enum {ICOL_LcEvents_LOG = 0, 
	  ICOL_LcEvents_SOURCE,
	  ICOL_LcEvents_ID,
	  ICOL_LcEvents_SEVERITY,
      ICOL_LcEvents_COUNT,
      ICOL_LcEvents_TIME,
      ICOL_LcEvents_DESCRIPTION,
	  ICOL_LcEvents_MAX	  
	  };





#endif //_lcevents_h

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\lcsource.h ===
#ifndef _lcsource_h
#define _lcsource_h

#define CX_DEFAULT_DESCRIPTION_WIDTH 100
#define CX_DESCRIPTION_SLOP 25


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLcSource window

class CXMessageArray;
class CXEventSource;
class CXMessage;

class CLcSource : public CListCtrl
{
// Construction
public:
	CLcSource();
	SCODE CreateWindowEpilogue();

// Attributes
public:


// Operations
public:
	BOOL Find(CString sText, BOOL bWholeWord, BOOL bMatchCase);
	SCODE SetEventSource(CXEventSource* pEventSource);
	void SortItems(DWORD dwColumn);
	LONG FindItem(DWORD dwMessageId);
	void RefreshItem(LONG iItem);
	CXMessage* operator[](LONG iItem) {return GetAt(iItem); }
	CXMessage* GetAt(LONG iItem);
	LONG GetSize() {return GetItemCount(); }
    void GetSelectedMessages(CXMessageArray& amsg);
    void NotifyTrappingChange(DWORD dwMessageId, BOOL bIsTrapping);
    LONG SetDescriptionWidth();

// Overrides

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLcSource)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLcSource();

	// Generated message map functions
protected:
	//{{AFX_MSG(CLcSource)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	friend class CSource;
	CSource* m_pSource;

	void SetColumnHeadings();
	SCODE GetMessageLibPath(CString& sLog, CString& sEventSource, CString& sLibPath);
	void AddMessage(CXMessage* pMessage);
    void SetDescriptionWidth(CXMessageArray& aMessages);
	
};

enum {ICOL_LcSource_EVENTID = 0, 
	  ICOL_LcSource_SEVERITY,
	  ICOL_LcSource_TRAPPING,
	  ICOL_LcSource_DESCRIPTION,
	  ICOL_LcSource_MAX	  
	  };


#endif //_lcsource_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\lcsource.cpp ===
#include "stdafx.h"
#include "source.h"
#include "lcsource.h"
#include "regkey.h"
#include "source.h"
#include "utils.h"
#include "globals.h"
#include "busy.h"
#include "trapreg.h"




/////////////////////////////////////////////////////////////////////////////
// CLcSource

CLcSource::CLcSource()
{
}

CLcSource::~CLcSource()
{
}




//***************************************************************************
//
//  CLcSource::AddMessage
//
//  Add a message to the list control. This sets the text for each column in
//  the list view and sets the lParam field of the list-view item to pMessage.
//  
//
//  Parameters:
//		CMessage* pMessage
//
//  Returns:
//		Nothing.
//
//  Status:
//      
//***************************************************************************
void CLcSource::AddMessage(CXMessage* pMessage)
{
	CString sText;
    pMessage->GetShortId(sText);


    // Insert a new item into this list control.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_TEXT | LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcSource_EVENTID;
    lvitem.cchTextMax = MAX_STRING;
    lvitem.lParam = (LPARAM)pMessage;
    lvitem.pszText = (LPTSTR)(LPCTSTR)sText;
    int nItem = InsertItem(&lvitem);

    if (nItem >= 0)
    {
        CXEventSource* pEventSource = pMessage->m_pEventSource;

        // Now set the string value for each sub-item.
		pMessage->GetSeverity(sText); 
		SetItemText(nItem, ICOL_LcSource_SEVERITY, (LPTSTR)(LPCTSTR) sText);

		pMessage->IsTrapping(sText);
        SetItemText(nItem, ICOL_LcSource_TRAPPING, (LPTSTR)(LPCTSTR)sText);
        SetItemText(nItem, ICOL_LcSource_DESCRIPTION, (LPTSTR)(LPCTSTR) pMessage->m_sText);
    }
}


//*******************************************************************
// CXMessageArray::SetDescriptionWidth
//
// Set the width of the description field so that it is wide enough to
// hold the widest message.
//
// Parameters:
//      CXMessageArray& aMessages
//          The message array that will be used to fill the list control.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CLcSource::SetDescriptionWidth(CXMessageArray& aMessages)
{
    LONG cxWidestMessage = CX_DEFAULT_DESCRIPTION_WIDTH;
    LONG nMessages = aMessages.GetSize();
    for (LONG iMessage = 0; iMessage < nMessages; ++iMessage) {
        CXMessage* pMessage = aMessages[iMessage];
        int cx = GetStringWidth(pMessage->m_sText);
        if (cx > cxWidestMessage) {
            cxWidestMessage = cx;
        }
    }

    // Set the column width to the width of the widest string plus a little extra
    // space for slop and to make it obvious to the user that the complete string
    // is displayed.
    SetColumnWidth(ICOL_LcSource_DESCRIPTION, cxWidestMessage + CX_DESCRIPTION_SLOP);
}



//***************************************************************************
//
//  CLcSource::LoadMessages
//
//  Load the messages from the message library module and insert them into
//  this list control.
//
//  Parameters:
//		CMessage* pMessage
//
//  Returns:
//		Nothing.
//
//  Status:
//      
//***************************************************************************
SCODE CLcSource::SetEventSource(CXEventSource* pEventSource)
{
    CBusy busy;

	DeleteAllItems();

    if (pEventSource == NULL) {
        return S_OK;
    }


    UpdateWindow();
    
    //!!!CR: Should do something with the return code in case the
    //!!!CR: messages weren't loaded.
    SCODE sc = pEventSource->LoadMessages();


	// Iterate through each of the messages and insert them into
	// the list control.
    CXMessageArray& aMessages = pEventSource->m_aMessages;

    // Set the width of the description field so that it is wide enough to contain
    // the widest message.
    SetDescriptionWidth(aMessages);

	LONG nMessages = aMessages.GetSize();
	for (LONG iMessage=0; iMessage < nMessages; ++iMessage) {
        if ((iMessage < 40 && (iMessage % 10 == 9)) ||
            (iMessage % 100 == 99)) {
            // Update the window often for the first few messages and less frequently
            // thereafter for a good response time.
            UpdateWindow();
        }

		AddMessage(aMessages[iMessage]);
	}


    SortItems(ICOL_LcSource_EVENTID);
    SetRedraw(TRUE);
    UpdateWindow();
    EnsureVisible(0, FALSE);

	if (GetSize())
		SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);

	return S_OK;
}



BEGIN_MESSAGE_MAP(CLcSource, CListCtrl)
	//{{AFX_MSG_MAP(CLcSource)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLcSource message handlers



//***************************************************************************
//
//  CLcSource::CreateWindowEpilogue()
//
//  This method is called after a window has been created for this list
//  control.  Final initialization is done here.
//
//  Parameters:
//		None.
//
//  Returns:
//		SCODE
//			S_OK if the initialization was successful, otherwise E_FAIL.
//
//  Status:
//      
//***************************************************************************
SCODE CLcSource::CreateWindowEpilogue()
{
	ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_FULLROWSELECT);
	SetColumnHeadings();
	return S_OK;
}

//***************************************************************************
//
//  CLcSource::SetColumnHeadings
//
//  Define's the columns for this list control.  The column title, width, and
//  order is defined here.
//
//  Parameters:
//		None.
//
//  Returns:
//		Nothing.
//
//  Status:
//      
//***************************************************************************
void CLcSource::SetColumnHeadings()
{
 	static UINT auiResColumnTitle[ICOL_LcSource_MAX] = {
		IDS_LcSource_TITLE_EVENT_ID,
		IDS_LcSource_TITLE_SEVERITY,
		IDS_LcSource_TITLE_TRAPPING,
		IDS_LcSource_TITLE_DESCRIPTION
	};

	static int aiColWidth[ICOL_LcSource_MAX] = {60, 75, 60, CX_DEFAULT_DESCRIPTION_WIDTH};

 
    // Build the columns in the AllEventsList control.
    LV_COLUMN lvcol; 
    lvcol.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    
    for (int iCol=0; iCol<ICOL_LcSource_MAX; ++iCol)
    {
		CString sColTitle;
		sColTitle.LoadString(auiResColumnTitle[iCol]);

        lvcol.pszText = sColTitle.GetBuffer(sColTitle.GetLength());
        lvcol.iSubItem = iCol;
        lvcol.cx = aiColWidth[iCol];
        InsertColumn(iCol, &lvcol);
		sColTitle.ReleaseBuffer();
    }
}




//******************************************************************
// CLcSource::Find
//
// Find the specified event source in this list control.
//
// Parameters:
//		CString& sText
//			A string containing the text to search for.
//
//		BOOL bWholeWord
//			TRUE if this is a "whole word" search.  False if it
//			is OK to match a partial word.
//
//		BOOL bMatchCase
//			TRUE if a case-sensitive comparison should be used.
//
// Returns:
//		BOOL
//			TRUE if the string was found, FALSE otherwise.  If the specified
//			text is found, then the selection is set on the corresponding
//			list control item, the item is scrolled into view and the focus
//			is set on the item.
//
//******************************************************************
BOOL CLcSource::Find(CString sText, BOOL bWholeWord, BOOL bMatchCase)
{
    // Don't do anything if the list is empty.
	if (GetSize() == 0) 
		return FALSE;

	if (!bMatchCase) 
		sText.MakeUpper();

    // Get the selected item.
    LONG iItem = GetNextItem(-1, LVNI_SELECTED);    

    // Nothing selected; start from the top of the list.
    if (iItem == -1)
        iItem = 0;


    // Iterate through all of the items starting at one item past
    // the currently selected item. 
	CXMessage* pMessage;
	CString sDescription;
    BOOL bFound = FALSE;
	LONG nItems = GetSize();
    LONG iItemStart = iItem;
	for (long i=0; !bFound && i<nItems; ++i) {
        // Bump the item index to the next one and wrap it if its past the
        // last item.
		iItem = (iItem + 1) % nItems;

        // Get the message description for this item.
		pMessage = GetAt(iItem);
        sDescription = pMessage->m_sText;

		if (!bMatchCase) 
			sDescription.MakeUpper();
        
        if (bWholeWord)	{
            // Compare the whole word.
			bFound = (FindWholeWord(sText, sDescription) != -1);
        }
        else {
	        // Look for a substring.
            if (sDescription.Find(sText) >= 0)  
                bFound = TRUE;
        } 
    }

    // Found a match.
    if (bFound)
    {
        // Unselect the selected item and select the found item.        
        SetItemState(iItemStart, 0, LVIS_SELECTED | LVIS_FOCUSED);
        SetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        EnsureVisible(iItem, FALSE);
        return TRUE;
    }

    return FALSE;
}






//***************************************************************************
//
//  fnCompareCLcSource
//
//  This the item comparison callback method that is called from CLcSource::SortItems. 
//
//  Parameters:
//		LPARAM lParam1
//			This is the lparam for the first item to compare.  This is a pointer to 
//			the associated CMessage object.
//
//		LPARAM lParam2
//			This is the lparam for the second item to compare.  This is a pointer to 
//			the associated CMessage object.
//
//		LPARAM lColumn
//			This is the second parameter that was passed to CListCtrl::SortItems.  This 
//			happens to be the list control column index.
//
//  Returns:
//		Nothing.
//
//  Status:
//      
//***************************************************************************
int CALLBACK fnCompareCLcSource(LPARAM lParam1, LPARAM lParam2, LPARAM lColumn)
{
    // !!!CR: The LPARAM parameters are not event pointers in all cases because
    // !!!CR: each subitem has its own LPARAM. What should I do?

    CXMessage *pmsg1 = (CXMessage *)lParam1;
    CXMessage *pmsg2 = (CXMessage *)lParam2;

    int nResult = 0;
    CString s1, s2;

    if (pmsg1 && pmsg2)
    {
        switch( lColumn)
        {
        case ICOL_LcSource_EVENTID:
        	nResult = ((LONG) pmsg1->GetShortId()) - ((LONG)pmsg2->GetShortId());			
        	break;
        case ICOL_LcSource_SEVERITY:
         	pmsg1->GetSeverity(s1);
        	pmsg2->GetSeverity(s2);
        	nResult = lstrcmpi(s1, s2);
        	break;
        case ICOL_LcSource_TRAPPING:
        	pmsg1->IsTrapping(s1);
        	pmsg2->IsTrapping(s2);
        	nResult = lstrcmpi(s1, s2);
        	break;
        case ICOL_LcSource_DESCRIPTION:
            nResult = lstrcmpi(pmsg1->m_sText, pmsg2->m_sText);
        	break;
        default:
         	ASSERT(FALSE);
            nResult = 0;
            break;
        }
    }

    if (!g_abLcSourceSortAscending[lColumn]) {
        if (nResult > 0) {
            nResult = -1;
        }
        else if (nResult < 0) {
            nResult = 1;
        }
    }

    return(nResult);
}


//***************************************************************************
//
//  CLcSource::SortItems
//
//  Sort the items in this list control given the column index.  This method
//  hides all details about the sort implementation from this class's clients.
//
//  Parameters:
//		DWORD dwColumn
//			The column to use as the sort key.  
//
//  Returns:
//		Nothing.
//
//  Status:
//      
//***************************************************************************
void CLcSource::SortItems(DWORD dwColumn)
{
    CListCtrl::SortItems(fnCompareCLcSource, dwColumn);
}




//***************************************************************************
//
//  CLcSource::GetSelectedMessages
//
//  Fill a message array with pointers to the messages that correspond to
//  the selected items in this list control.  
//
//  Note: This list control continues to own the returned pointers.  The
//  caller should not delete them.
//
//  Parameters:
//		CMessageArray& amsg
//			The message array where the pointers to the selected messages are
//			returned.
//
//  Returns:
//		The message array is filled with pointers to the selected messages.  Do
//		not delete them, because they are owned by this object.
//
//  Status:
//      
//***************************************************************************
void CLcSource::GetSelectedMessages(CXMessageArray& amsg)
{
	// Clear the message array
	amsg.RemoveAll();

	// Setup the LV_ITEM structure to retrieve the lparam field.  
	// This field contains the CMessage pointer.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcSource_EVENTID;

	// Loop to find all the selected items.	
	int nItem = -1;
	while (TRUE) {
		nItem = GetNextItem(nItem, LVNI_SELECTED);
		if (nItem == -1) {
			break;
		}

		// Get the CMessage pointer for this item and add it to the
		// array.
        lvitem.iItem = nItem;
        GetItem(&lvitem);
		CXMessage* pmsg = (CXMessage*) (void*) lvitem.lParam;
		amsg.Add(pmsg);
	}
}




//***************************************************************************
//
//  CLcSource::FindItem
//
//  Search through this list-controls's items to find the one with the
//  specified message ID.  
//
//  Parameters:
//		DWORD dwMessageId
//			The message ID to search for.
//
//  Returns:
//		The index of the item with the specified message ID.  If no such message ID
//		was found, -1 is returned.
//
//  Status:
//      
//***************************************************************************
LONG CLcSource::FindItem(DWORD dwMessageId)
{
	LONG nItems = GetItemCount();
	for (LONG iItem = 0; iItem < nItems; ++iItem) {
        CXMessage* pMessage = GetAt(iItem);
        if (pMessage->m_dwId == dwMessageId) {
            return iItem;
        }
	}
	return -1;
}




//***************************************************************************
//
//  CLcSource::RefreshItem
//
//  This method is called when some aspect of the message has changed and
//  the display needs to be updated.  This occurs when the trapping status
//  of an event changes.  
//
//  Parameters:
//		DWORD dwMessageId
//			The message ID to search for.
//
//  Returns:
//		The index of the item with the specified message ID.  If no such message ID
//		was found, -1 is returned.
//
//  Status:
//      
//***************************************************************************
void CLcSource::RefreshItem(LONG iItem)
{
	CXMessage* pMessage = GetAt(iItem);
    CString sText;

	// Now set the text value for each column in the list control.
    pMessage->GetSeverity(sText);
	SetItemText(iItem, ICOL_LcSource_SEVERITY, (LPTSTR)(LPCTSTR) sText);

    // Check if we are trapping this event.
	pMessage->IsTrapping(sText);
    SetItemText(iItem, ICOL_LcSource_TRAPPING, (LPTSTR)(LPCTSTR)sText);

    SetItemText(iItem, ICOL_LcSource_DESCRIPTION, (LPTSTR)(LPCTSTR)pMessage->m_sText);
}



//***************************************************************************
//
//  CLcSource::GetAt
//
//  This method returns the message pointer located at the given item index.
//  This allows CLcSource to be used much as an array.  
//
//  Parameters:
//		LONG iItem
//			The item index.
//
//  Returns:
//		A pointer to the CMessage stored at the specified index.
//
//  Status:
//      
//***************************************************************************
CXMessage* CLcSource::GetAt(LONG iItem) 
{
	// Setup the LV_ITEM structure to retrieve the lparam field.  
	// This field contains the CMessage pointer.
    LV_ITEM lvitem;
    lvitem.mask = LVIF_PARAM;
    lvitem.iSubItem = ICOL_LcSource_EVENTID;	
    lvitem.iItem = iItem;
    GetItem(&lvitem);

	CXMessage* pMessage = (CXMessage*) (void*) lvitem.lParam;
	return pMessage;
}



//***************************************************************************
// CLcSource::NotifyTrappingChange
//
// This method is called when a message's trapping status changes.  A message
// is considered trapped if it appears in the CLcEvents listbox.
//
// Parameters:
//      DWORD dwMessageId
//          The ID of the message who's trapping status is changing.
//
//      BOOL bIsTrapping
//          TRUE if the message is being trapped, FALSE otherwise.
//
// Returns:
//      Nothing.     
//      
//***************************************************************************
void CLcSource::NotifyTrappingChange(DWORD dwMessageId, BOOL bIsTrapping)
{
    LONG iItem = FindItem(dwMessageId);
    ASSERT(iItem != -1);

    if (iItem != -1) {
        CString sTrapping;
    	sTrapping.LoadString(bIsTrapping ? IDS_IS_TRAPPING : IDS_NOT_TRAPPING);
        SetItemText(iItem, ICOL_LcSource_TRAPPING, (LPTSTR)(LPCTSTR)sTrapping);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\portable.h ===
//****************************************************************************
//
//  Copyright (c) 1992, Microsoft Corporation
//
//  File:  PORTABLE.H
//
//  Definitions to simplify portability between WIN31 and WIN32
//
//****************************************************************************

#ifndef _PORTABLE_H_
#define _PORTABLE_H_

#ifdef _NTWIN
#ifndef WIN32
#define WIN32
#endif
#endif

#ifdef WIN32

#define GET_WM_COMMAND_ID(wp, lp)       LOWORD(wp)
#define GET_WM_COMMAND_CMD(wp, lp)      HIWORD(wp)
#define GET_WM_COMMAND_HWND(wp, lp)     (HWND)(lp)

#define GET_WINDOW_ID(hwnd)         (UINT)GetWindowLong(hwnd, GWL_ID)
#define GET_WINDOW_INSTANCE(hwnd)   (HINSTANCE)GetWindowLong(hwnd, \
                                        GWL_HINSTANCE)

#define LONG2POINT(l, pt)  ((pt).x=(SHORT)LOWORD(l), (pt).y=(SHORT)HIWORD(l))

#ifdef __cplusplus

#define NOTIFYPARENT(hwnd,code) { \
                                    UINT nID; \
                                    nID = GET_WINDOW_ID(hwnd); \
                                    (::SendMessage)(::GetParent(hwnd), \
                                        WM_COMMAND, MAKEWPARAM(nID, code), \
                                        (LPARAM)hwnd); \
                                }

#define SENDCOMMAND(hwnd, cmd)  { \
                                    (::SendMessage)(hwnd, WM_COMMAND, \
                                        MAKEWPARAM(cmd, 0), (LPARAM)0); \
                                }

#define POSTCOMMAND(hwnd, cmd)  { \
                                    (::PostMessage)(hwnd, WM_COMMAND, \
                                        MAKEWPARAM(cmd, 0), (LPARAM)0); \
                                }

#else // !__cplusplus

#define NOTIFYPARENT(hwnd,code) { \
                                    UINT nID; \
                                    nID = GET_WINDOW_ID(hwnd); \
                                    SendMessage(GetParent(hwnd), WM_COMMAND, \
                                        MAKEWPARAM(nID, code), \
                                        (LPARAM)hwnd); \
                                }

#define SENDCOMMAND(hwnd, cmd)  { \
                                    SendMessage(hwnd, WM_COMMAND, \
                                        MAKEWPARAM(cmd, 0), (LPARAM)0); \
                                }

#define POSTCOMMAND(hwnd, cmd)  { \
                                    PostMessage(hwnd, WM_COMMAND, \
                                        MAKEWPARAM(cmd, 0), (LPARAM)0); \
                                }

#endif // __cplusplus

#else // !WIN32

// Some type definitions excluded from win31 sdk...
// Should these ever be defined for win31, GET RID OF THESE!
typedef float FLOAT;
typedef char TCHAR;

#define GET_WM_COMMAND_ID(wp, lp)       LOWORD(wp)
#define GET_WM_COMMAND_CMD(wp, lp)      HIWORD(lp)
#define GET_WM_COMMAND_HWND(wp, lp)     (HWND)LOWORD(lp)

#define GET_WINDOW_ID(hwnd)         (UINT)GetWindowWord(hwnd, GWW_ID)
#define GET_WINDOW_INSTANCE(hwnd)   (HINSTANCE)GetWindowWord(hwnd, \
                                        GWW_HINSTANCE)

#define LONG2POINT(l, pt)  ((pt).x = (int)LOWORD(l), (pt).y = (int)HIWORD(l))

#ifdef __cplusplus

#define NOTIFYPARENT(hwnd,code) { \
                                    UINT nID; \
                                    nID = GET_WINDOW_ID(hwnd); \
                                    (::SendMessage)(::GetParent(hwnd), \
                                        WM_COMMAND, nID, \
                                        MAKELPARAM(hwnd, code)); \
                                }

#define SENDCOMMAND(hwnd, cmd)  { \
                                    (::SendMessage)(hwnd,WM_COMMAND,cmd,0); \
                                }

#define POSTCOMMAND(hwnd, cmd)  { \
                                    (::PostMessage)(hwnd,WM_COMMAND,cmd,0); \
                                }

#else // !__cplusplus

#define NOTIFYPARENT(hwnd,code) { \
                                    UINT nID; \
                                    nID = GET_WINDOW_ID(hwnd); \
                                    SendMessage(GetParent(hwnd), WM_COMMAND, \
                                        nID, MAKELPARAM(hwnd, code)); \
                                }

#define SENDCOMMAND(hwnd, cmd)  { \
                                    SendMessage(hwnd, WM_COMMAND, cmd, 0); \
                                }

#define POSTCOMMAND(hwnd, cmd)  { \
                                    PostMessage(hwnd, WM_COMMAND, cmd, 0); \
                                }

#endif // __cplusplus

#endif // WIN32

#endif // _PORTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\remote.h ===
#ifndef _remote_h
#define _remote_h

//===============================================================================
// Class: CEnvCache
//
// This class caches the system environment variables for remote systems.  This
// cache is used to expand environment variables in the context of a remote system.
// 
// The values of the remote system environment variables are loaded from the
// remote system's registry.
//
//==============================================================================
class CEnvCache
{
public:
	
	CEnvCache();
	SCODE Lookup(LPCTSTR pszMachine, LPCTSTR pszName, CString& sResult);
	SCODE AddMachine(LPCTSTR pszMachine);


private:
	CMapStringToOb m_mapMachine;
	SCODE GetEnvironmentVars(LPCTSTR pszMachine, CMapStringToString* pmapVars);

};

SCODE RemoteExpandEnvStrings(LPCTSTR pszComputerName, CEnvCache& cache, CString& sValue);
SCODE MapPathToUNC(LPCTSTR pszMachineName, CString& sPath);




#endif //_remote_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\regkey.cpp ===
//****************************************************************************
//
//  Copyright (c) 1993,  Microsoft Corp.
//
//  File:  DOMDLGS.H
//
//  Implementation file for registry management classes
//
//  History:
//      Scott V. Walker 10/5/94
//
//****************************************************************************

#include "stdafx.h"

#include "portable.h"

#include "regkey.h"


BOOL g_bLostConnection = FALSE;


//****************************************************************************
//
//  CRegistryValue Implementation
//
//****************************************************************************

IMPLEMENT_DYNAMIC(CRegistryValue, CObject)

//****************************************************************************
//
//  CRegistryValue::CRegistryValue
//
//****************************************************************************
CRegistryValue::CRegistryValue()
{
    m_dwType = REG_NONE;
    m_dwDataLength = 0;
    m_pData = NULL;
}

//****************************************************************************
//
//  CRegistryValue::CRegistryValue
//
//****************************************************************************
CRegistryValue::CRegistryValue(LPCTSTR pszName, DWORD dwType,
    DWORD dwDataLength, LPBYTE pData)
{
    Set(pszName, dwType, dwDataLength, pData);
}

//****************************************************************************
//
//  CRegistryValue::~CRegistryValue
//
//****************************************************************************
CRegistryValue::~CRegistryValue()
{
    Empty();
}

//****************************************************************************
//
//  CRegistryValue::Set
//
//  Sets the value data fields.  The data pointed to by pData is COPIED!
//
//****************************************************************************
void CRegistryValue::Set(LPCTSTR pszName, DWORD dwType,
    DWORD dwDataLength, LPBYTE pData)
{
    Empty();

    m_sName = pszName;
    m_dwType = dwType;
    m_dwDataLength = dwDataLength;
    if (dwDataLength == 0 || pData == NULL)
        m_pData = NULL;
    else
    {
        m_pData = new BYTE[dwDataLength];
        memcpy(m_pData, pData, dwDataLength);
    }
}

//****************************************************************************
//
//  CRegistryValue::Get
//
//  Gets the value data fields.  The data pointed to by m_pData is COPIED
//  into the buffer pointed to by pData... this buffer better be big enough!
//  If pData is NULL, no copy is performed.
//
//****************************************************************************
void CRegistryValue::Get(CString &sName, DWORD &dwType,
    DWORD &dwDataLength, LPBYTE pData)
{
    sName = m_sName;
    dwType = m_dwType;
    dwDataLength = m_dwDataLength;
    if (dwDataLength != 0 && pData != NULL)
        memcpy(pData, m_pData, m_dwDataLength);
}

//****************************************************************************
//
//  CRegistryValue::Empty
//
//  Clear the value data and deletes its data buffer.
//
//****************************************************************************
void CRegistryValue::Empty()
{
    m_sName.Empty();
    m_dwType = REG_NONE;
    m_dwDataLength = 0;
    if (m_pData != NULL)
        delete m_pData;
    m_pData = NULL;
}

//****************************************************************************
//
//  CRegistryValue::operator=
//
//  Assignment operator.  Copies CRegistryValue object.
//
//****************************************************************************
const CRegistryValue& CRegistryValue::operator=(CRegistryValue &other)
{
    Set(other.m_sName, other.m_dwType, other.m_dwDataLength, other.m_pData);

    return *this;
}

//****************************************************************************
//
//  CRegistryKey Implementation
//
//****************************************************************************

IMPLEMENT_DYNAMIC(CRegistryKey, CObject)

//****************************************************************************
//
//  CRegistryKey::CRegistryKey
//
//****************************************************************************
CRegistryKey::CRegistryKey()
{
    // The lost connection status is initialized only once so that if a connection
    // is ever lost we won't waste any time trying to close keys.

    Initialize();
}

//****************************************************************************
//
//  CRegistryKey::Initialize
//
//****************************************************************************
void CRegistryKey::Initialize()
{
    m_bConnected = FALSE;
    m_bOpen = FALSE;
    m_bLocal = TRUE;
    m_bDirty = FALSE;

    m_hkeyConnect = NULL;
    m_hkeyRemote = NULL;
    m_hkeyOpen = NULL;
    m_Sam = 0;

    m_dwSubKeys = 0;
    m_dwMaxSubKey = 0;
    m_dwMaxClass = 0;
    m_dwValues = 0;
    m_dwMaxValueName = 0;
    m_dwMaxValueData = 0;
    m_dwSecurityDescriptor = 0;

    m_ftLastWriteTime.dwLowDateTime = 0;
    m_ftLastWriteTime.dwHighDateTime = 0;

    m_lResult = ERROR_SUCCESS;
}

//****************************************************************************
//
//  CRegistryKey::~CRegistryKey
//
//  Destructor.
//
//****************************************************************************
CRegistryKey::~CRegistryKey()
{
    if (g_bLostConnection) {
        // If we lost the registry connection, it will be useless to do anything.
        return;
    }

    // If we're currently open, then close.
    if (m_bOpen)
        Close(TRUE);

    // If we're currently connected, then disconnect.
    if (m_bConnected)
        Disconnect(TRUE);
}

//****************************************************************************
//
//  CRegistryKey::Connect
//
//****************************************************************************
LONG CRegistryKey::Connect(LPCTSTR pszComputer, HKEY hkey)
{
    if (g_bLostConnection) {
        return RPC_S_SERVER_UNAVAILABLE;
    }

    TCHAR szName[MAX_COMPUTERNAME_LENGTH + 1];
    CString sComputer;
    HKEY hkeyRemote;
    DWORD dwNumChars;

    m_lResult = ERROR_SUCCESS;

    if (m_bConnected)
    {
        m_lResult = Disconnect(TRUE);
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
    }

    // Is this the local machine?

    dwNumChars = MAX_COMPUTERNAME_LENGTH + 1;

    sComputer = pszComputer;
    GetComputerName(szName, &dwNumChars);
    if (sComputer.IsEmpty() || !lstrcmpi(pszComputer, szName))
    {
        // Local

        m_bLocal = TRUE;
        hkeyRemote = NULL;
    }
    else
    {
        // Remote

        m_bLocal = FALSE;
        m_lResult = RegConnectRegistry(pszComputer, hkey, &hkeyRemote);

        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
        lstrcpy(szName, pszComputer);
    }

    m_bConnected = TRUE;
    m_hkeyConnect = hkey;
    m_hkeyRemote = hkeyRemote;
    m_sComputer = szName;

    return ERROR_SUCCESS;
}

//****************************************************************************
//
//  CRegistryKey::Disconnect
//
//****************************************************************************
LONG CRegistryKey::Disconnect(BOOL bForce)
{
    m_lResult = ERROR_SUCCESS;

    if (m_bConnected)
    {
        // Close the open key
        if (m_bOpen)
        {
            m_lResult = Close(bForce);
            if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
                g_bLostConnection = TRUE;                
            }

            if (!bForce && m_lResult != ERROR_SUCCESS)
                return m_lResult;
        }

        // Close the remote connection
        if (!g_bLostConnection) {
            if (!m_bLocal)
            {
                m_lResult = RegCloseKey(m_hkeyRemote);
                if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
                    g_bLostConnection = TRUE;
                }
                if (!bForce && m_lResult != ERROR_SUCCESS)
                    return m_lResult;
            }
        }
    }
    


    
    Initialize();

    return ERROR_SUCCESS;
}

//****************************************************************************
//
//  CRegistryKey::Create
//
//****************************************************************************
LONG CRegistryKey::Create(LPCTSTR pszKeyName, DWORD &dwDisposition,
    LPCTSTR pszClass, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecAttr)
{
    if (g_bLostConnection) {
        return RPC_S_SERVER_UNAVAILABLE;
    }
    
    HKEY hkeyOpen, hkey;

    m_lResult = ERROR_SUCCESS;
    dwDisposition = 0;

    if (m_bOpen)
    {
        m_lResult = Close(TRUE);
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
    }

    // If not connected, default to \\Local_Machine\HKEY_LOCAL_MACHINE
    if (!m_bConnected)
    {
        m_lResult = Connect();
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
    }

    // Attempt to create the specified subkey
    if (m_bLocal)
        hkey = m_hkeyConnect;
    else
        hkey = m_hkeyRemote;

    m_lResult = RegCreateKeyEx(hkey, pszKeyName, 0, (LPTSTR)pszClass,
        REG_OPTION_NON_VOLATILE, samDesired, lpSecAttr, &hkeyOpen,
        &dwDisposition);
    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }
    if (m_lResult != ERROR_SUCCESS)
        return m_lResult;

    m_lResult = RegCloseKey(hkeyOpen);
    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
        return m_lResult;
    }

    return Open(pszKeyName, samDesired);
}

//****************************************************************************
//
//  CRegistryKey::Open
//
//****************************************************************************
LONG CRegistryKey::Open(LPCTSTR pszKeyName, REGSAM samDesired)
{
    if (g_bLostConnection) {
        return RPC_S_SERVER_UNAVAILABLE;
    }


    HKEY hkeyOpen, hkey;
    CString sWork;
    int nPos;

    m_lResult = ERROR_SUCCESS;

    if (m_bOpen)
    {
        m_lResult = Close(TRUE);
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
    }

    // If not connected, default to \\Local_Machine\HKEY_LOCAL_MACHINE
    if (!m_bConnected)
    {
        m_lResult = Connect();
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        if (m_lResult != ERROR_SUCCESS)
            return m_lResult;
    }

    // Attempt to open the specified subkey
    if (m_bLocal)
        hkey = m_hkeyConnect;
    else
        hkey = m_hkeyRemote;
    m_lResult = RegOpenKeyEx(hkey, pszKeyName, 0, samDesired, &hkeyOpen);
    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }
    if (m_lResult != ERROR_SUCCESS)
        return m_lResult;

    // Attempt to get info about this key.

    TCHAR szBuffer[1024 + 1];
    DWORD dwClass, dwSubKeys, dwMaxSubKey, dwMaxClass, dwValues;
    DWORD dwMaxValueName, dwMaxValueData, dwSecurityDescriptor;
    FILETIME ftLastWriteTime;

    dwClass = 1024 + 1;
    m_lResult = RegQueryInfoKey(hkeyOpen, szBuffer, &dwClass, 0, &dwSubKeys, 
        &dwMaxSubKey, &dwMaxClass, &dwValues, &dwMaxValueName,
        &dwMaxValueData, &dwSecurityDescriptor, &ftLastWriteTime);
    
    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
        return m_lResult;
    }

    if (m_lResult != ERROR_SUCCESS)
    {
        RegCloseKey(hkeyOpen);
        return m_lResult;
    }

    // Success! save all the data.

    m_sFullName = pszKeyName;
    nPos = m_sFullName.ReverseFind('\\');
    if (nPos >= 0)
        m_sKeyName = m_sFullName.Mid(nPos + 1);
    else
        m_sKeyName = m_sFullName;

    m_hkeyOpen = hkeyOpen;
    m_bOpen = TRUE;
    m_Sam = samDesired;
    m_sClass = szBuffer;
    m_dwSubKeys = dwSubKeys;
    m_dwMaxSubKey = dwMaxSubKey;
    m_dwMaxClass = dwMaxClass;
    m_dwValues = dwValues;
    m_dwMaxValueName = dwMaxValueName;
    m_dwMaxValueData = dwMaxValueData;
    m_dwSecurityDescriptor = dwSecurityDescriptor;
    m_ftLastWriteTime = ftLastWriteTime;

    return ERROR_SUCCESS;
}

//****************************************************************************
//
//  CRegistryKey::Close
//
//****************************************************************************
LONG CRegistryKey::Close(BOOL bForce)
{
    if (!g_bLostConnection) {

        m_lResult = ERROR_SUCCESS;

        if (!m_bOpen)
            return ERROR_SUCCESS;


        if (m_bDirty)
        {
            m_lResult = RegFlushKey(m_hkeyOpen);
            if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
                g_bLostConnection = TRUE;
            }

            if (!bForce && m_lResult != ERROR_SUCCESS)
                return m_lResult;
        }

        if (!g_bLostConnection) {
            m_lResult = RegCloseKey(m_hkeyOpen);
            if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
                g_bLostConnection = TRUE;
            }

            if (!bForce && m_lResult != ERROR_SUCCESS)
                return m_lResult;
        }
    }

    m_bDirty = FALSE;

    m_hkeyOpen = NULL;
    m_bOpen = FALSE;
    m_sFullName.Empty();
    m_sClass.Empty();
    m_Sam = 0;

    m_dwSubKeys = 0;
    m_dwMaxSubKey = 0;
    m_dwMaxClass = 0;
    m_dwValues = 0;
    m_dwMaxValueName = 0;
    m_dwMaxValueData = 0;
    m_dwSecurityDescriptor = 0;

    m_ftLastWriteTime.dwLowDateTime = 0;
    m_ftLastWriteTime.dwHighDateTime = 0;

    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return RPC_S_SERVER_UNAVAILABLE;
    }
    else {
        m_lResult = ERROR_SUCCESS;
        return ERROR_SUCCESS;
    }
}

//****************************************************************************
//
//  CRegistryKey::EnumValues
//
//  Returns NULL if unsuccessful, returns empty array if successful but open
//  key has no values.
//  NOTE: Caller is responsible for deleting returned string array.
//
//****************************************************************************
CStringArray* CRegistryKey::EnumValues()
{
    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return NULL;
    }
         
    TCHAR szBuffer[1024 + 1];
    DWORD dwLength;
    CStringArray *pArr;
    int i;

    m_lResult = ERROR_SUCCESS;

    if (!m_bOpen || g_bLostConnection)
        return NULL;

    // Enumerate all the values into a string array
    pArr = new CStringArray;
    i = 0;
    m_lResult = ERROR_SUCCESS;
    while (TRUE)
    {
        dwLength = 1024 + 1;
        m_lResult = RegEnumValue(m_hkeyOpen, i, szBuffer, &dwLength, NULL,
            NULL, NULL, NULL);

        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }

        if (m_lResult != ERROR_SUCCESS)
            break;
        if (dwLength > 0)
            pArr->Add(szBuffer);
        i++;
    }

    // Did we find a normal end condition?
    if (m_lResult == ERROR_NO_MORE_ITEMS)
        return pArr;

    delete pArr;
    return NULL;
}

//****************************************************************************
//
//  CRegistryKey::EnumSubKeys
//
//  Returns NULL if unsuccessful, returns empty array if successful but open
//  key has no values.
//  NOTE: Caller is responsible for deleting returned string array.
//
//****************************************************************************
CStringArray* CRegistryKey::EnumSubKeys()
{
    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return NULL;
    }



    TCHAR szBuffer[1024 + 1];
    DWORD dwLength;
    CStringArray *pArr;
    int i;

    m_lResult = ERROR_SUCCESS;

    if (!m_bOpen)
        return NULL;

    // Enumerate all the subkeys into a string array
    pArr = new CStringArray;
    i = 0;

    while (TRUE)
    {
        dwLength = 1024 + 1;
        m_lResult = RegEnumKeyEx(m_hkeyOpen, i, szBuffer, &dwLength, NULL,
            NULL, NULL, NULL);

        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }

        if (m_lResult != ERROR_SUCCESS)
            break;
        if (dwLength > 0)
            pArr->Add(szBuffer);
        i++;
    }

    // Did we find a normal end condition?
    if (m_lResult == ERROR_NO_MORE_ITEMS)
        return pArr;

    delete pArr;
    return NULL;
}

//****************************************************************************
//
//  CRegistryKey::GetValue
//
//  Note: regval is always emptied regardless of success/failure
//
//****************************************************************************
BOOL CRegistryKey::GetValue(LPCTSTR pszValue, CRegistryValue &regval)
{

    DWORD dwLength, dwType;
    BYTE *pBuffer;

    regval.Empty();

    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return FALSE;
    }

    if (!m_bOpen)
    {
        m_lResult = ERROR_INVALID_FUNCTION;
        return FALSE;
    }

    // Find out how big the data is
    m_lResult = RegQueryValueEx(m_hkeyOpen, (LPTSTR)pszValue, NULL, NULL,
        NULL, &dwLength);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    if (dwLength == 0)
        return TRUE;

    // Now make a buffer big enough for it.
    pBuffer = new BYTE[dwLength];
    if (pBuffer == NULL)
        return FALSE;

    m_lResult = RegQueryValueEx(m_hkeyOpen, (LPTSTR)pszValue, NULL, &dwType,
        pBuffer, &dwLength);


    if (m_lResult == ERROR_SUCCESS)
        regval.Set(pszValue, dwType, dwLength, pBuffer);

    delete pBuffer;

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    return TRUE;
}

//****************************************************************************
//
//  CRegistryKey::SetValue
//
//****************************************************************************
BOOL CRegistryKey::SetValue(CRegistryValue &regval)
{
    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return FALSE;
    }

    if (!m_bOpen)
    {
        m_lResult = ERROR_INVALID_FUNCTION;
        return FALSE;
    }
    
    if (regval.m_sName.IsEmpty())
    {
        m_lResult = ERROR_INVALID_DATA;
        return FALSE;
    }

    m_lResult = RegSetValueEx(m_hkeyOpen, regval.m_sName, 0, regval.m_dwType,
        regval.m_pData, regval.m_dwDataLength);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    m_bDirty = TRUE;

    return TRUE;
}

//****************************************************************************
//
//  CRegistryKey::GetSubKey
//
//  Note: If successful, regkey is returned connected and open on the
//  specified key.  If failure, regkey is returned disconnected.
//
//****************************************************************************
BOOL CRegistryKey::GetSubKey(LPCTSTR pszSubKey, CRegistryKey &regkey)
{
    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return FALSE;
    }


    CString sSubKey;

    m_lResult = ERROR_SUCCESS;

    if (!m_bOpen)
        return FALSE;

    m_lResult = regkey.Disconnect(TRUE);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    // Try to connect and open same key
    m_lResult = regkey.Connect(m_sComputer, m_hkeyConnect);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;
    sSubKey = pszSubKey;
    m_lResult = regkey.Open(m_sFullName + "\\" + sSubKey, m_Sam);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
    {
        regkey.Disconnect(TRUE);
        return FALSE;
    }

    return TRUE;
}

//****************************************************************************
//
//  CRegistryKey::CreateSubKey
//
//  Note: If successful, regkey is returned connected and open on the
//  new key; if the key already existed, it is simply opened.  If failure,
//  regkey is returned disconnected.
//
//****************************************************************************
BOOL CRegistryKey::CreateSubKey(
    LPCTSTR pszSubKey, 
    CRegistryKey &regkey,
    LPCTSTR pszClass, 
    LPSECURITY_ATTRIBUTES lpSecAttr,
    BOOL bIsVolatile)
{
    if (g_bLostConnection) {
        m_lResult = RPC_S_SERVER_UNAVAILABLE;
        return FALSE;
    }
 
 
    CString sSubKey, sClass;
    HKEY hkeyOpen;
    DWORD dwDisposition;

    m_lResult = ERROR_SUCCESS;

    if (!m_bOpen)
        return FALSE;

    m_lResult = regkey.Disconnect(TRUE);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    // Try to connect and open same key
    m_lResult = regkey.Connect(m_sComputer, m_hkeyConnect);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;
    sSubKey = pszSubKey;
    sClass = pszClass;
    DWORD dwRegOptions = bIsVolatile ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE;
    m_lResult = RegCreateKeyEx(m_hkeyOpen, sSubKey, 0, (LPTSTR)(LPCTSTR)sClass,
        dwRegOptions, m_Sam, lpSecAttr, &hkeyOpen, &dwDisposition);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
    {
        regkey.Disconnect(TRUE);
        return FALSE;
    }
    m_lResult = RegCloseKey(hkeyOpen);

    if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
        g_bLostConnection = TRUE;
    }

    if (m_lResult != ERROR_SUCCESS)
        return FALSE;

    m_lResult = regkey.Open(m_sFullName + "\\" + sSubKey, m_Sam);

    if (m_lResult != ERROR_SUCCESS)
    {
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }

        regkey.Disconnect(TRUE);
        return FALSE;
    }

    m_bDirty = TRUE;
    if (dwDisposition == REG_CREATED_NEW_KEY)
        regkey.m_bDirty = TRUE;

    return TRUE;
}

//****************************************************************************
//
//  CRegistryKey::DeleteSubKey
//
//****************************************************************************
BOOL CRegistryKey::DeleteSubKey(LPCTSTR pszSubKey)
{
    if (g_bLostConnection) {
        return FALSE;
    }

    CString sSubKey;
    CRegistryKey subkey;
    int i;

    m_lResult = ERROR_SUCCESS;
    sSubKey = pszSubKey;

    if (!m_bOpen)
        return FALSE;

    if (!GetSubKey(sSubKey, subkey))
        return FALSE;

    // Delete all subkeys of the specified subkey (RegDeleteKey limitation)
    CStringArray *parr = subkey.EnumSubKeys();
    for (i=0; i<parr->GetSize(); i++)
    {
        if (!subkey.DeleteSubKey(parr->GetAt(i)))
            return FALSE;
    }
    delete parr;

    subkey.Close(TRUE);

    m_lResult = RegDeleteKey(m_hkeyOpen, sSubKey);
    if (m_lResult != ERROR_SUCCESS) {
        if ((m_lResult == RPC_S_SERVER_UNAVAILABLE) || (m_lResult == RPC_S_CALL_FAILED)) {
            g_bLostConnection = TRUE;
        }
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\regkey.h ===
//****************************************************************************
//
//  Copyright (c) 1995,  Microsoft Corp.
//
//  File:  REGKEY.H
//
//  Definitions for registry management classes
//
//  History:
//      Scott V. Walker, SEA  10/5/94
//
//****************************************************************************
#ifndef _REGKEY_H_
#define _REGKEY_H_

#include <tchar.h>



//****************************************************************************
//
//  CLASS:  CRegistryValue
//
//****************************************************************************
class CRegistryValue : public CObject
{
    DECLARE_DYNAMIC(CRegistryValue)

public:
    CString m_sName;
    DWORD m_dwType;
    DWORD m_dwDataLength;
    LPBYTE m_pData;

public:
    CRegistryValue();
    CRegistryValue(LPCTSTR pszName, DWORD dwType, DWORD dwDataLength,
        LPBYTE pData);
    ~CRegistryValue();

    void Set(LPCTSTR pszName, DWORD dwType, DWORD dwDataLength,
        LPBYTE pData);
    void Get(CString &sName, DWORD &dwType, DWORD &dwDataLength,
        LPBYTE pData = NULL);
    void Empty();
    const CRegistryValue& operator=(CRegistryValue &other);
};

//****************************************************************************
//
//  CLASS:  CRegistryKey
//
//****************************************************************************
class CRegistryKey : public CObject
{
    DECLARE_DYNAMIC(CRegistryKey)

public:
    CString m_sComputer;    // Name of computer we're connected to
    HKEY m_hkeyConnect;     // Handle to current connection key (or NULL)
    HKEY m_hkeyRemote;      // Handle to remote connection key (or NULL)
    BOOL m_bConnected;      // TRUE if currently connected
    BOOL m_bLocal;          // TRUE if connected to the local computer

    HKEY m_hkeyOpen;        // Handle to currently open key (or NULL)
    BOOL m_bOpen;           // TRUE if currently open
    CString m_sFullName;    // Full path name of currently open key
    CString m_sKeyName;     // Name of currently open key
    REGSAM m_Sam;           // Security access mask we opened with

    BOOL m_bDirty;          // TRUE if there are changes pending in this key

    CString m_sClass;       // Class name of key
    DWORD m_dwSubKeys;      // Number of subkeys in this key
    DWORD m_dwMaxSubKey;    // Longest subkey name length
    DWORD m_dwMaxClass;     // Longest class string length
    DWORD m_dwValues;       // Number of value entries in current key
    DWORD m_dwMaxValueName; // Longest value name length
    DWORD m_dwMaxValueData; // Longest value data length
    DWORD m_dwSecurityDescriptor;   // Security descriptor length

    FILETIME m_ftLastWriteTime; // Last modification date for key or values

    LONG m_lResult;         // Last return value from a registry API

public:
    CRegistryKey();
    ~CRegistryKey();

    void Initialize();
    LONG Connect(LPCTSTR pszComputer = NULL,
        HKEY hkey = HKEY_LOCAL_MACHINE);
    LONG Disconnect(BOOL bForce = FALSE);
    LONG Open(LPCTSTR pszKeyName, REGSAM samDesired = KEY_ALL_ACCESS);
    LONG Create(LPCTSTR pszKeyName, DWORD &dwDisposition,
        LPCTSTR pszClass = NULL, REGSAM samDesired = KEY_ALL_ACCESS,
        LPSECURITY_ATTRIBUTES lpSecAttr = NULL);
    LONG Close(BOOL bForce = FALSE);
    CStringArray* EnumValues();
    CStringArray* EnumSubKeys();
    BOOL GetValue(LPCTSTR pszValue, CRegistryValue &regval);
    BOOL SetValue(CRegistryValue &regval);
    BOOL GetSubKey(LPCTSTR pszSubKey, CRegistryKey &regkey);
    BOOL CreateSubKey(LPCTSTR pszSubKey, CRegistryKey &regkey,
        LPCTSTR pszClass = NULL, LPSECURITY_ATTRIBUTES lpSecAttr = NULL, BOOL bIsVolatile = FALSE);
    BOOL DeleteSubKey(LPCTSTR pszSubKey);	
};



class CEventTrapRegistry
{
public:
	CEventTrapRegistry();
	~CEventTrapRegistry();
};

extern BOOL g_bLostConnection;

#endif // _REGKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\settings.cpp ===
//***********************************************************************
// settings.cpp
//
// This file contains the implementation of the "Settings" dialog class.
//
//
// Author: SEA
//
// History:
//      Febuary-1996     Larry A. French
//          Modified the code to fix various problems.  Regrettably, this
//          file still contains a fair amount of legacy code that I didn't
//          have time to fully rewrite.  Also, I did not have time to go 
//          though and fully comment the code.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//
//************************************************************************



// settings.cpp : implementation file
//

#include "stdafx.h"
#include "eventrap.h"
#include "settings.h"
#include "globals.h"
#include "trapreg.h"

// This macro handles comparing bool values for the cases where TRUE can be and
// non-zero value.
#define BOOLS_ARE_DIFFERENT(b1, b2) (((b1) & (!(b2))) || ((!(b1)) & (b2))) 


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

UINT _thrRun(CTrapSettingsDlg *trapDlg)
{
    return trapDlg->thrRun();
}

/////////////////////////////////////////////////////////////////////////////
// CTrapSettingsDlg dialog

UINT CTrapSettingsDlg::thrRun()
{
    HANDLE hEvents[2];
    DWORD retCode;
    CRegistryKey regkey;
    CRegistryValue regval;
    BOOL bThrottleIsTripped = FALSE;

    hEvents[0] = (HANDLE)m_evRegNotification;
    hEvents[1] = (HANDLE)m_evTermination;
    
    if (!g_reg.m_regkeySnmp.GetSubKey(SZ_REGKEY_PARAMETERS, regkey))
        return 0;

    do
    {
        m_evRegNotification.SetEvent();

        if (RegNotifyChangeKeyValue(
                regkey.m_hkeyOpen,
                TRUE,
                REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_NAME,
                (HANDLE)m_evRegNotification,
                TRUE) == ERROR_SUCCESS)
        {
            if (regkey.GetValue(SZ_REGKEY_PARAMS_THRESHOLD, regval) && 
                *(DWORD*)regval.m_pData == THROTTLE_TRIPPED)
                PostMessage(WM_UIREQUEST, UICMD_ENABLE_RESET, TRUE);
            else
                PostMessage(WM_UIREQUEST, UICMD_ENABLE_RESET, FALSE);
        }
    } while(WaitForMultipleObjects(2, hEvents, FALSE, INFINITE) == WAIT_OBJECT_0);

    regkey.Close();

    return 0;
}

CTrapSettingsDlg::CTrapSettingsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTrapSettingsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTrapSettingsDlg)
	m_bLimitMsgLength = FALSE;
	//}}AFX_DATA_INIT
}


#define I_MAX_LONG 0x7fffffffL
#define I_MIN_TRAPCOUNT 2
#define I_MAX_TRAPCOUNT 9999999

#define I_MIN_SECONDS   1
#define I_MAX_SECONDS   9999999

#define I_MIN_MESSAGE_LENGTH 400
#define I_MAX_MESSAGE_LENGTH 0x7fff




SCODE CTrapSettingsDlg::GetMessageLength(LONG* pnChars)
{
    CString sValue;

	CButton* pbtnLimit = (CButton*)GetDlgItem(IDC_LIMITMSGLNGTH);
    BOOL bLimitEnabled = (pbtnLimit->GetCheck() == 1) ? TRUE : FALSE;
        

    m_edtMessageLength.GetWindowText(sValue);
    SCODE sc;
    LONG nChars = _ttol(sValue);
    sc = AsciiToLong(sValue, &nChars);
    if (FAILED(sc))
    {
        // They shouldn't have garbage in this edit control even if
        // they haven't selected a message limit.  Let the user fix it.
        AfxMessageBox(IDS_ERR_SETTINGS_MESSAGELENGTH_NOT_INT);
        m_edtMessageLength.SetFocus();
        m_edtMessageLength.SetSel(0, -1);
        return E_FAIL;
    }


    if (bLimitEnabled)
    {
        if (nChars < I_MIN_MESSAGE_LENGTH || nChars > I_MAX_MESSAGE_LENGTH)
        {
            if (pbtnLimit->GetCheck() == 1)
            {
                CString sError;
                CString sRangeMessage;
                sError.LoadString(IDS_SETTINGS_MESSAGE_LENGTH_RANGE);
                GenerateRangeMessage(sRangeMessage, I_MIN_MESSAGE_LENGTH, I_MAX_MESSAGE_LENGTH);
                sError += sRangeMessage;
                AfxMessageBox(sError);
                sValue.Format(_T("%u"),nChars);
                m_edtMessageLength.SetWindowText(sValue);
                m_edtMessageLength.SetFocus();
                m_edtMessageLength.SetSel(0, -1);
                return E_FAIL;
            }
        }
    }
    *pnChars = nChars;
    return S_OK;
}

SCODE CTrapSettingsDlg::GetTrapsPerSecond(LONG* pnTraps, LONG* pnSeconds)
{
    CString sSeconds;
    CString sTraps;
    CString sError;
    CString sRangeMessage;
    LONG nTraps;
    LONG nSeconds;
    SCODE sc;

    // First make sure that the trap count and seconds fields don't have garbage in them.
    // If a non-integer value is specified, force the user to fix it regardless of whether
    // or not the throttle is enabled.
    m_edtTrapCount.GetWindowText(sTraps);
    sc = AsciiToLong(sTraps, &nTraps);
    if (FAILED(sc))
    {
        AfxMessageBox(IDS_ERR_SETTINGS_TRAPCOUNT_NOT_INT);
        m_edtTrapCount.SetFocus();
        m_edtTrapCount.SetSel(0, -1);
        return E_FAIL;
    }

    m_edtSeconds.GetWindowText(sSeconds);
    sc = AsciiToLong(sSeconds, &nSeconds);
    if (FAILED(sc))
    {
        AfxMessageBox(IDS_ERR_SETTINGS_TRAPSECONDS_NOT_INT);
        m_edtSeconds.SetFocus();
        m_edtSeconds.SetSel(0, -1);
        return E_FAIL;
    }

    BOOL bThrottleEnabled;
    if (GetCheckedRadioButton(IDC_RADIO_ENABLE, IDC_RADIO_DISABLE) == IDC_RADIO_ENABLE)
        bThrottleEnabled = TRUE;
    else
        bThrottleEnabled = FALSE;

    if (bThrottleEnabled)
    {
        if  (nTraps < I_MIN_TRAPCOUNT || nTraps > I_MAX_TRAPCOUNT)
        {
            sError.LoadString(IDS_ERR_SETTINGS_TRAPCOUNT_RANGE);
            GenerateRangeMessage(sRangeMessage, I_MIN_TRAPCOUNT, I_MAX_TRAPCOUNT);
            sError += sRangeMessage;
            AfxMessageBox(sError);
            sTraps.Format(_T("%u"), nTraps);
            m_edtTrapCount.SetWindowText(sTraps);
            m_edtTrapCount.SetFocus();
            m_edtTrapCount.SetSel(0, -1);
            return E_FAIL;
        }
    
        if (nSeconds < I_MIN_SECONDS || nSeconds > I_MAX_SECONDS)
        {
            sError.LoadString(IDS_SETTINGS_TRAPSECONDS_RANGE);
            GenerateRangeMessage(sRangeMessage, I_MIN_SECONDS, I_MAX_SECONDS);
            sError += sRangeMessage;
            AfxMessageBox(sError);
            sSeconds.Format(_T("%u"),nSeconds);
            m_edtSeconds.SetWindowText(sSeconds);
            m_edtSeconds.SetFocus();
            m_edtSeconds.SetSel(0, -1);
            return E_FAIL;
        }
    }
    

    *pnTraps = nTraps;
    *pnSeconds = nSeconds;

    return S_OK;
}

void CTrapSettingsDlg::TerminateBackgroundThread()
{
    if (m_pthRegNotification)
    {
	    m_evTermination.SetEvent();
        WaitForSingleObject(m_pthRegNotification->m_hThread, INFINITE);
    }
}

void CTrapSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTrapSettingsDlg)
	DDX_Control(pDX, IDC_STAT_TRAP_LENGTH, m_statTrapLength);
	DDX_Control(pDX, IDC_EDIT_MESSAGELENGTH, m_edtMessageLength);
	DDX_Control(pDX, IDC_EDIT_TRAP_SECONDS, m_edtSeconds);
	DDX_Control(pDX, IDC_EDIT_TRAP_COUNT, m_edtTrapCount);
	DDX_Control(pDX, IDC_MSGLENGTHSPN, m_spinMessageLength);
	DDX_Control(pDX, IDC_BUTTON_RESET, m_btnResetThrottle);
	DDX_Check(pDX, IDC_LIMITMSGLNGTH, m_bLimitMsgLength);
	//}}AFX_DATA_MAP


    CString sValue;
    if (pDX->m_bSaveAndValidate) {
        // Saving the value trapsize, seconds, and trapcount is handled by 
        // CTrapSettingsDlg::OnOK so that it can set the focus back to the
        // offending item if the value is out of range. If the data transfer
        // fails here, the focus is always set back to the dialog and not
        // the offending item (is there a way around this?)
    }
    else {

        m_spinMessageLength.SetRange(I_MIN_MESSAGE_LENGTH, I_MAX_MESSAGE_LENGTH);
        m_spinMessageLength.SetPos(g_reg.m_params.m_trapsize.m_dwMaxTrapSize);

        DecString(sValue, g_reg.m_params.m_throttle.m_nSeconds);
        m_edtSeconds.SetWindowText(sValue);

        DecString(sValue, g_reg.m_params.m_throttle.m_nTraps);
        m_edtTrapCount.SetWindowText(sValue);


    }            
}


BEGIN_MESSAGE_MAP(CTrapSettingsDlg, CDialog)
	//{{AFX_MSG_MAP(CTrapSettingsDlg)
	ON_BN_CLICKED(IDC_LIMITMSGLNGTH, OnLimitMessageLength)
	ON_BN_CLICKED(IDC_RADIO_DISABLE, OnRadioDisable)
	ON_BN_CLICKED(IDC_RADIO_ENABLE, OnRadioEable)
	ON_BN_CLICKED(IDC_BUTTON_RESET, OnButtonReset)
	ON_COMMAND(ID_HELP, OnHelp)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_WM_CLOSE()
    ON_MESSAGE(WM_UIREQUEST, OnUIRequest)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTrapSettingsDlg message handlers

LRESULT CTrapSettingsDlg::OnUIRequest(WPARAM cmd, LPARAM lParam)
{
    switch(cmd)
    {
    case UICMD_ENABLE_RESET:
        m_btnResetThrottle.EnableWindow((BOOL)lParam);
        break;
    default:
        break;
    }

    return (LRESULT)0;
}

void CTrapSettingsDlg::OnLimitMessageLength() 
{
	// The LimitMsgLength checkbox was clicked.
	// Enable/disable the edit control.

	// Get the controls.
    CButton* pbtnLimitBox = (CButton*) GetDlgItem(IDC_LIMITMSGLNGTH);
    CButton *pRadio1 = (CButton*)GetDlgItem(IDC_RADIO1);
    CButton *pRadio2 = (CButton*)GetDlgItem(IDC_RADIO2);
	
	// It's checked; enable
	if (pbtnLimitBox->GetCheck() == 1)
    {
        m_edtMessageLength.EnableWindow();
		pRadio1->EnableWindow();
		pRadio2->EnableWindow();
        GetDlgItem(IDC_STATIC_BYTES)->EnableWindow();
        m_statTrapLength.EnableWindow();
    }
	// Disable
	else
    {
        m_edtMessageLength.EnableWindow(FALSE);
		pRadio1->EnableWindow(FALSE);
		pRadio2->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_BYTES)->EnableWindow(FALSE);
        m_statTrapLength.EnableWindow(FALSE);
    }
}


BOOL CTrapSettingsDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

    CButton *pRadio1 = (CButton*)GetDlgItem(IDC_RADIO1);
    CButton *pRadio2 = (CButton*)GetDlgItem(IDC_RADIO2);
	

    m_statTrapLength.EnableWindow(m_bLimitMsgLength);


    m_edtMessageLength.EnableWindow(m_bLimitMsgLength);
	if (m_bLimitMsgLength)
    {
		pRadio1->EnableWindow();
		pRadio2->EnableWindow();
        GetDlgItem(IDC_STATIC_BYTES)->EnableWindow();
    }
	// Disable
	else
    {
		pRadio1->EnableWindow(FALSE);
		pRadio2->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_BYTES)->EnableWindow(FALSE);
    }



    if (m_bTrimMessagesFirst)
        CheckRadioButton(IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);
    else
        CheckRadioButton(IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);

    if (m_bThrottleEnabled) 
        CheckRadioButton(IDC_RADIO_ENABLE, IDC_RADIO_DISABLE, IDC_RADIO_ENABLE);
    else
        CheckRadioButton(IDC_RADIO_ENABLE, IDC_RADIO_DISABLE, IDC_RADIO_DISABLE);

    EnableThrottleWindows(m_bThrottleEnabled);

    m_pthRegNotification = AfxBeginThread((AFX_THREADPROC)_thrRun, this);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



void CTrapSettingsDlg::OnOK() 
{

    LONG nchMessageLength;
    LONG nTraps;
    LONG nSeconds;
    SCODE sc = GetMessageLength(&nchMessageLength);
    if (FAILED(sc))
    {
        return;
    }

    sc = GetTrapsPerSecond(&nTraps, &nSeconds);
    if (FAILED(sc))
    {
        return;
    }


    // Pull various values off of the dialog and store them into member variables.
    // Note that there are other member variables that are set directly
    // as a response to user input.
    //===========================================================================
    m_bTrimMessagesFirst = (GetCheckedRadioButton(IDC_RADIO1, IDC_RADIO2) == IDC_RADIO2);
    m_bThrottleEnabled = (GetCheckedRadioButton(IDC_RADIO_ENABLE, IDC_RADIO_DISABLE) == IDC_RADIO_ENABLE);


    if (g_reg.m_params.m_trapsize.m_dwMaxTrapSize != (DWORD) nchMessageLength) {
        g_reg.SetDirty(TRUE);
        g_reg.m_params.m_trapsize.m_dwMaxTrapSize = nchMessageLength;
    }

    if(g_reg.m_params.m_throttle.m_nSeconds != nSeconds) {
        g_reg.SetDirty(TRUE);
        g_reg.m_params.m_throttle.m_nSeconds = nSeconds;
    }

    if (g_reg.m_params.m_throttle.m_nTraps != nTraps) {
        g_reg.SetDirty(TRUE);
        g_reg.m_params.m_throttle.m_nTraps = nTraps;
    }

    TerminateBackgroundThread();
	CDialog::OnOK();
}




BOOL CTrapSettingsDlg::EditSettings()
{
    m_bLimitMsgLength = g_reg.m_params.m_trapsize.m_bTrimFlag;
    m_bTrimMessagesFirst = g_reg.m_params.m_trapsize.m_bTrimMessages;
    m_bThrottleEnabled = g_reg.m_params.m_throttle.m_bIsEnabled;


    // Save the data.
    if (DoModal() == IDOK)
    {
        if (BOOLS_ARE_DIFFERENT(g_reg.m_params.m_trapsize.m_bTrimFlag, m_bLimitMsgLength)) {
            g_reg.m_params.m_trapsize.m_bTrimFlag = m_bLimitMsgLength;
            g_reg.SetDirty(TRUE);
        }

        if (BOOLS_ARE_DIFFERENT(g_reg.m_params.m_trapsize.m_bTrimMessages, m_bTrimMessagesFirst)) {
            g_reg.m_params.m_trapsize.m_bTrimMessages = m_bTrimMessagesFirst;
            g_reg.SetDirty(TRUE);
        }

        if (BOOLS_ARE_DIFFERENT(g_reg.m_params.m_throttle.m_bIsEnabled, m_bThrottleEnabled)) {
            g_reg.m_params.m_throttle.m_bIsEnabled = m_bThrottleEnabled;
            g_reg.SetDirty(TRUE);
        }
                
        return TRUE;
    }
    else {
        return FALSE;
    }

}




void CTrapSettingsDlg::OnRadioDisable() 
{
    EnableThrottleWindows(FALSE);
}

void CTrapSettingsDlg::OnRadioEable() 
{
    EnableThrottleWindows(TRUE);
}

void CTrapSettingsDlg::EnableThrottleWindows(BOOL bEnableThrottle)
{
    m_edtSeconds.EnableWindow(bEnableThrottle);
    GetDlgItem(IDC_STATIC_MSG)->EnableWindow(bEnableThrottle);
    GetDlgItem(IDC_STATIC_NTRAPS)->EnableWindow(bEnableThrottle);
    GetDlgItem(IDC_STATIC_INTERVAL)->EnableWindow(bEnableThrottle);
    m_edtTrapCount.EnableWindow(bEnableThrottle);
}


//****************************************************************
// CTrapSettingsDlg::OnButtonReset
//
// Reset the extension agent so that it starts sending traps again.
// The extension agent will stop sending traps if the throttle limit
// is exceeded (more than x number of traps per second are set).
//
// Parameters:
//      None.
//
// Returns.
//      Nothing.
//
//*****************************************************************
void CTrapSettingsDlg::OnButtonReset() 
{
    if (SUCCEEDED(g_reg.m_params.ResetExtensionAgent())) {
        m_btnResetThrottle.EnableWindow(FALSE);
    }
}

BOOL CTrapSettingsDlg::OnHelpInfo(HELPINFO *pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW &&
        pHelpInfo->iCtrlId != IDC_STATIC_MSG &&
        pHelpInfo->iCtrlId != IDC_STATIC_BYTES)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                   AfxGetApp()->m_pszHelpFilePath,
                   HELP_WM_HELP,
                   (ULONG_PTR)g_aHelpIDs_IDD_SETTINGSDLG);
	}
	
	return TRUE;
}

void CTrapSettingsDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (this == pWnd)
		return;

    ::WinHelp (pWnd->m_hWnd,
		       AfxGetApp()->m_pszHelpFilePath,
		       HELP_CONTEXTMENU,
		       (ULONG_PTR)g_aHelpIDs_IDD_SETTINGSDLG);
}

void CTrapSettingsDlg::OnClose() 
{
    TerminateBackgroundThread();
	CDialog::OnClose();
}

void CTrapSettingsDlg::OnCancel() 
{
    TerminateBackgroundThread();
	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\settings.h ===
// settings.h : header file
//

#ifndef SETTINGS_H
#define	SETTINGS_H

/////////////////////////////////////////////////////////////////////////////
// CTrapSettingsDlg dialog
class CTrapSettingsDlg;
class CEventArray;

// this message is posted by background threads to the UI thread, requesting
// changes in the UI. wParam identifies the UI command (from the #defines below),
// lParam identifies the actual parameters of the command.
#define WM_UIREQUEST (WM_USER + 13)

// the 'enable' state of the 'Reset' button should be changed to the state indicated
// in lParam.
#define UICMD_ENABLE_RESET 1

UINT _thrRun(CTrapSettingsDlg *trapDlg);

class CTrapSettingsDlg : public CDialog
{
// Construction
public:
    UINT thrRun();

	CTrapSettingsDlg(CWnd* pParent = NULL);   // standard constructor
    BOOL EditSettings();

// Dialog Data
	//{{AFX_DATA(CTrapSettingsDlg)
	enum { IDD = IDD_SETTINGSDLG };
	CStatic	m_statTrapLength;
	CEdit	m_edtMessageLength;
	CEdit	m_edtSeconds;
	CEdit	m_edtTrapCount;
	CSpinButtonCtrl	m_spinMessageLength;
	CButton	m_btnResetThrottle;
	BOOL	m_bLimitMsgLength;
	//}}AFX_DATA

    BOOL m_bTrimMessagesFirst;
    BOOL m_bThrottleEnabled;

    CWinThread*     m_pthRegNotification;
    CEvent          m_evTermination;
    CEvent          m_evRegNotification;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTrapSettingsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTrapSettingsDlg)
	afx_msg void OnLimitMessageLength();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnRadioDisable();
	afx_msg void OnRadioEable();
	afx_msg void OnButtonReset();
	afx_msg BOOL OnHelpInfo(HELPINFO*);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnClose();
    afx_msg LRESULT OnUIRequest(WPARAM cmd, LPARAM lParam);
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void EnableThrottleWindows(BOOL bEnableThrottle);
    SCODE GetTrapsPerSecond(LONG* pnTraps, LONG* pnSeconds);
    SCODE GetMessageLength(LONG* pnChars);
    void TerminateBackgroundThread();
};

#endif //SETTINGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\remote.cpp ===
//***********************************************************************
// remote.cpp
//
// This file contains code required to expand environment variables in the
// context of a remote machine. It does this by reading the environment variables
// from the remote machine's registry and caching them here.
//
// This file also contains code required to map local paths read out of the
// remote machine's registry into UNC paths such that c:\foo will be mapped
// to \\machine\c$\foo
//
// Author: Larry A. French
//
// History:
//      19-April-1996     Larry A. French
//          Wrote it.
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//
//************************************************************************


#include "stdafx.h"
#include "remote.h"
#include "trapreg.h"
#include "regkey.h"




CEnvCache::CEnvCache()
{
}


//*****************************************************************
// CEnvCache::GetEnvironmentVars
//
// Read the system environment variables for the remote machine out
// of its registry.
//
// Parameters:
//    LPCTSTR pszMachine
//          Pointer to the remote machine's name.
//
//    CMapStringToString* pmapVars
//          This string to string map is where the environment variables
//          for the machine are returned.
//
// Returns:
//    SCODE
//          S_OK if everything was successful, otherwise E_FAIL.
//
//****************************************************************
SCODE CEnvCache::GetEnvironmentVars(LPCTSTR pszMachine, CMapStringToString* pmapVars)
{
    CRegistryKey regkey;        // SYSTEM\CurrentControlSet\Services\EventLogs
    CRegistryValue regval;

    static TCHAR* apszNames1[] = {
        _T("SourcePath"),
        _T("SystemRoot")
    };

    if (regkey.Connect(pszMachine) != ERROR_SUCCESS) {
        goto CONNECT_FAILURE;
    }


    // First pick up the values for the SourcePath and SystemRoot environment variables and anything elese in
    // apszNames1.
    LONG nEntries;
    LONG iEntry;
    if (regkey.Open(_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), KEY_READ ) == ERROR_SUCCESS) {
        nEntries = sizeof(apszNames1) / sizeof(TCHAR*);
        for (iEntry=0; iEntry<nEntries; ++iEntry) {
            if (regkey.GetValue(apszNames1[iEntry], regval)) {
                pmapVars->SetAt(apszNames1[iEntry], (LPCTSTR) regval.m_pData);
            }
        }
        regkey.Close();
    }

    // Now get the rest of the environment variables.
    if (regkey.Open(_T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"), KEY_READ ) == ERROR_SUCCESS) {
        CStringArray* pasValues = regkey.EnumValues();
        if (pasValues != NULL) {
            nEntries = (LONG)pasValues->GetSize();
            for (iEntry=0; iEntry< nEntries; ++iEntry) {
                CString sValueName =  pasValues->GetAt(iEntry);
                if (regkey.GetValue(sValueName, regval)) {
                    pmapVars->SetAt(sValueName, (LPCTSTR) regval.m_pData);
                }
            }
        }
        regkey.Close();
    }
    return S_OK;

CONNECT_FAILURE:
	return E_FAIL;
}


SCODE CEnvCache::AddMachine(LPCTSTR pszMachine)
{
	CMapStringToString* pmapVars;
	if (m_mapMachine.Lookup(pszMachine, (CObject*&) pmapVars)) {
		// The machine already has an entry, so don't add another
		return E_FAIL;
	}

	pmapVars = new CMapStringToString;
	m_mapMachine.SetAt(pszMachine, pmapVars);

	SCODE sc = GetEnvironmentVars(pszMachine, pmapVars);

	return sc;
}


//******************************************************************
// CEnvCache::Lookup
//
// Lookup an environment variable on the specified machine.
//
// Parameters:
//		LPCTSTR pszMachineName
//			Pointer to the machine name string.
//
//		LPCTSTR pszName
//			Pointer to the name of the environment variable to lookup.
//
//		CString& sValue
//			This is a reference to the place where the environment varaible's
//			value is returned.
//
//
// Returns:
//		SCODE
//			S_OK if the environment variable was found.
//			E_FAIL if the environment varaible was not found.
//
//*******************************************************************
SCODE CEnvCache::Lookup(LPCTSTR pszMachineName, LPCTSTR pszName, CString& sResult)
{
	SCODE sc;
	CMapStringToString* pmapVars;
	// Get a pointer to the machine's cached map of environment variable values.
	// If the map hasn't been loaded yet, do so now and try to get its map again.
	if (!m_mapMachine.Lookup(pszMachineName, (CObject*&) pmapVars)) {
		sc = AddMachine(pszMachineName);
		if (FAILED(sc)) {
			return sc;
		}
		if (!m_mapMachine.Lookup(pszMachineName, (CObject*&) pmapVars)) {
			ASSERT(FALSE);
		}
	}

	// Look for the variable name in the environment name map
	if (pmapVars->Lookup(pszName, sResult)) {
		return S_OK;
	}
	else {
		return E_FAIL;
	}
}



//****************************************************************
// RemoteExpandEnvStrings
//
// Epand a string that may contain environment variables in the
// context of a remote machine.
//
// Parameters:
//		LPCTSTR pszComputerName
//			A pointer to the name of the remote machine.
//
//		CEnvCache& cache
//			The environment variable cache for all machines.  Note: the
//			cached values for a particular machine are loaded when there
//			is a reference to the machine.
//
//		CString& sValue
//			The string to expand.  This string is expanded in-place such
//			that on return, the string will contain the expanded values.
//
// Returns:
//		SCODE
//			S_OK if all strings were expanded
//
//******************************************************************
SCODE RemoteExpandEnvStrings(LPCTSTR pszComputerName, CEnvCache& cache, CString& sValue)
{
	SCODE sc = S_OK;
    LPCTSTR psz = sValue;
	TCHAR ch;
	CString sEnvVarName;
	CString sEnvVarValue;
	CString sResult;
	LPCTSTR pszPercent = NULL;
    while (ch = *psz++) {
        if (ch == _T('%')) {
			pszPercent = psz - 1;

			sEnvVarName = _T("");
            while (ch = *psz) {
				++psz;
                if (ch == _T('%')) {
					SCODE sc;
					sc = cache.Lookup(pszComputerName, sEnvVarName, sEnvVarValue);
					if (SUCCEEDED(sc)) {
						sResult += sEnvVarValue;
						pszPercent = NULL;
					}
					else {
						// If any environment variable is not found, then fail.
						sc = E_FAIL;
					}
					break;
                }
                if (iswspace(ch) || ch==_T(';')) {
                    break;
                }
                sEnvVarName += ch;
            }

			if (pszPercent != NULL) {
				// Control comes here if the opening percent was not matched by a closing
				// percent.
				while(pszPercent < psz) {
					sResult += *pszPercent++;
				}
			}

        }
		else {
			sResult += ch;
		}
    }

	sValue = sResult;		
	return sc;
	
}


//************************************************************
// SplitComplexPath
//
// Split a complex path consisting of several semicolon separated
// paths into separate paths and return them in a string array.
//
// Parameters:
//		LPCTSTR pszComplexPath
//			Pointer to the path that may or may not be composed of
//			several semicolon separated paths.
//
//		CStringArray& saPath
//			The place to return the split paths.
//
// Returns:
//		The individual paths are returned via saPath
//
//*************************************************************
void SplitComplexPath(LPCTSTR pszComplexPath, CStringArray& saPath)
{
	CString sPath;
	while (*pszComplexPath) {
		sPath.Empty();
		while (isspace(*pszComplexPath))  {
			++pszComplexPath;
		}

		while (*pszComplexPath &&
			   (*pszComplexPath != _T(';'))) {
			sPath += *pszComplexPath++;
		}

		if (!sPath.IsEmpty()) {
			saPath.Add(sPath);
		}

		if (*pszComplexPath==_T(';')) {
			++pszComplexPath;
		}
	}
}



//**************************************************************************
// MapPathToUNC
//
// Map a path to the UNC equivallent. Note that this method assumes that
// for each path containing a drive letter that the target machine will have
// the path shared out.  For example, if the path contains a "c:\foodir" prefix, then
// then you can get to "foodir" bygenerating the "\\machine\c$\foodir" path.
//
// Parameters:
//		LPCTSTR pszMachineName
//			Pointer to the machine name.
//
//		CString& sPath
//			Pointer to the path to map.  Upon return, this string will contain
//			the mapped path.
//
// Returns:
//		SCODE
//			S_OK if successful
//			E_FAIL if something went wrong.
//
//**************************************************************************
SCODE MapPathToUNC(LPCTSTR pszMachineName, CString& sPath)
{
	CStringArray saPaths;
	SplitComplexPath(sPath, saPaths);
	sPath.Empty();
	
	
	LPCTSTR pszPath = sPath.GetBuffer(sPath.GetLength() + 1);
	LONG nPaths = (LONG)saPaths.GetSize();
	SCODE sc = S_OK;
	for (LONG iPath=0; iPath < nPaths; ++iPath) {
		pszPath = saPaths[iPath];

		if (isalpha(pszPath[0]) && pszPath[1]==_T(':')) {
			CString sResult;
			sResult += _T("\\\\");
			sResult += pszMachineName;
			sResult += _T('\\');
			sResult += pszPath[0];		// Drive letter
			sResult += _T("$\\");		
			pszPath += 2;
			if (pszPath[0]==_T('\\')) {
				++pszPath;
			}
			sResult += pszPath;
			saPaths[iPath] = sResult;
		}
		else {
			sc = E_FAIL;
		}
		sPath += saPaths[iPath];
		if (iPath < nPaths - 1) {
			sPath += _T("; ");
		}
	}
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by eventrap.rc
//
#define ID_PROPERTIES                   3
#define ID_ADD                          4
#define ID_REMOVE                       5
#define ID_SETTINGS                     6
#define ID_BUTTON_EXPORT                7
#define IDC_APPLY                       8
#define IDS_NOT_TRAPPING                15
#define IDS_IS_TRAPPING                 16
#define IDS_MULTIPLE_SEL                17
#define IDS_MSG_TEXTNOTFOUND            20
#define IDS_MSG_SELECTEVENT             21
#define IDS_MSG_DELETEEVENT             22
#define IDS_COLHDR_TYPE                 23
#define IDS_CANTCONNECT                 24
#define IDS_ALREADYTRAPPING             28
#define IDS_SOMETRAPPING                29
#define IDS_EVENT_SEV_SUCCESS           33
#define IDS_EVENT_SEV_INFORMATIONAL     34
#define IDS_EVENT_SEV_WARNING           35
#define IDS_EVENT_SEV_ERROR             36
#define IDS_LcSource_TITLE_EVENT_ID     37
#define IDS_LcSource_TITLE_TRAPPING     38
#define IDS_LcSource_TITLE_DESCRIPTION  39
#define IDS_LcSource_TITLE_SEVERITY     40
#define IDS_LcEvents_TITLE_LOG          41
#define IDS_LcEvents_TITLE_SOURCE       42
#define IDS_LcEvents_TITLE_ID           43
#define IDS_LcEvents_TITLE_SEVERITY     44
#define IDS_LcEvents_TITLE_COUNT        45
#define IDS_LcEvents_TITLE_TIME         46
#define IDS_LcEvents_TITLE_DESCRIPTION  47
#define IDS_TITLE_EDIT_BUTTON           48
#define IDS_TITLE_VIEW_BUTTON           49
#define IDS_ERR_REGISTRY_CORRUPTED      50
#define IDS_ERR_NOT_INSTALLED           51
#define IDS_WARNING_CANT_READ_CONFIG    53
#define IDS_WARNING_NO_MESSAGE_SELECTED 54
#define IDS_ERR_INVALID_ARGUMENT        56
#define IDS_EXPORT_DIALOG_TITLE         57
#define IDS_EXPORT_DEFAULT_FILENAME     63
#define IDS_EXPORT_CNF_FILTER           67
#define IDS_ERR_CANT_CREATE_FILE        68
#define IDS_WARNING_CANT_WRITE_CONFIG   69
#define IDS_ERR_PROP_TIME1              71
#define IDS_ERR_PROP_TIME2              72
#define IDS_ERR_PROP_TIME_LESS_THAN_TWO 73
#define IDS_RANGE_MESSAGE_PREFIX        76
#define IDS_RANGE_VALUE_SEPARATOR       77
#define IDS_SENTENCE_TERMINATOR         78
#define IDS_ERR_SETTINGS_MESSAGELENGTH_NOT_INT 79
#define IDS_SETTINGS_MESSAGE_LENGTH_RANGE 80
#define IDS_ERR_SETTINGS_TRAPSECONDS_NOT_INT 81
#define IDS_SETTINGS_TRAPSECONDS_RANGE  82
#define IDS_ERR_SETTINGS_TRAPCOUNT_NOT_INT 83
#define IDS_ERR_SETTINGS_TRAPCOUNT_RANGE 84
#define IDS_ERR_REGISTRY_BUSY           85
#define IDS_CONFIGTYPE_DEFAULT          86
#define IDS_CONFIGTYPE_CUSTOM           87
#define IDS_CONFIGTYPE_DEFAULT_PENDING  88
#define IDS_ERR_REG_NO_ACCESS           89
#define IDS_ERR_REG_NO_READ_ACCESS      90
#define IDS_ERR_RANGE                   91
#define IDS_ERROR_NOT_RESPONDING        92
#define IDS_ERR_LOAD_MESSAGE_FILE_FAILED 93
#define IDS_ERR_MESSAGE_NOT_FOUND       94
#define IDR_MAINICON                    128
#define IDD_EVNTTRAPDLG                 129
#define IDD_SETTINGSDLG                 131
#define IDD_PROPERTIESDLG               133
#define IDD_EVENTFINDDLG                134
#define IDB_FOLDERCLOSE                 137
#define IDB_FOLDEROPEN                  138
#define IDC_CURSOR1                     139
#define IDD_ABOUTBOX                    142
#define IDD_SAVE_PROGRESS               144
#define IDD_LOAD_PROGRESS               145
#define IDR_CTXMENUS                    152
#define IDC_PROGRESS                    1000
#define IDC_LIMITMSGLNGTH               1012
#define IDC_EDIT_MESSAGELENGTH          1013
#define IDC_MSGLENGTHSPN                1015
#define ID_FIND                         1022
#define IDC_FIND_OK                     1023
#define IDC_FIND_CANCEL                 1024
#define IDC_EVENTCOUNT                  1025
#define IDC_EVENTCOUNTSPN               1026
#define IDC_WITHINTIME                  1027
#define IDC_TIMEINTRVLSPN               1030
#define IDC_DESCRIPTION                 1031
#define ID_STAT_SOURCE                  1033
#define ID_STAT_LOG                     1035
#define ID_STAT_EVENTID                 1036
#define IDC_EVENTLIST                   1046
#define IDC_TIMEINTERVAL                1048
#define IDC_RADIO1                      1054
#define IDC_RADIO2                      1055
#define ID_VIEW                         1069
#define IDC_TV_SOURCES                  1070
#define IDC_LV_SOURCES                  1071
#define IDC_STAT_LABEL1                 1073
#define IDC_STAT_LABEL2                 1074
#define IDC_EDIT_TRAP_COUNT             1075
#define IDC_STAT_LABEL0                 1075
#define IDC_EDIT_TRAP_SECONDS           1076
#define IDC_RADIO_ENABLE                1077
#define IDC_RADIO_DISABLE               1078
#define IDC_BUTTON_RESET                1079
#define IDC_EDIT_FIND_WHAT              1083
#define IDC_CHECK_MATCH_WHOLEWORD       1084
#define IDC_CHECK_MATCH_CASE            1085
#define IDC_RADIO_SEARCH_SOURCES        1086
#define IDC_RADIO_SEARCH_DESCRIPTIONS   1087
#define IDC_EDIT_ENTERPRISEOID          1097
#define IDC_STAT_GRP_CONFIG_TYPE        1098
#define IDC_RADIO_CUSTOM                1099
#define IDC_RADIO_DEFAULT               1100
#define IDC_STAT_TRAP_LENGTH            1101
#define IDC_EDIT_FULL_EVENT_ID          1103
#define IDC_STATIC_MSG                  1105
#define IDC_STATIC_NTRAPS               1106
#define IDC_STATIC_INTERVAL             1107
#define IDC_STATIC_BYTES                1108
#define IDC_DEFAULT                     1109
#define ID_SOURCE_LABEL                 1110
#define ID_LOG_LABEL                    1111
#define ID_EVENTID_LABEL                1112
#define ID_THRESHOLD_LABEL              1113
#define ID_OID_LABEL                    1115
#define ID_TRAPID_LABEL                 1116
#define IDD_NULL                        -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        168
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         1121
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\source.h ===
#ifndef _source_h
#define _source_h

#include "evntfind.h"

class CTcSource;
class CLcSource;
class CMessage;
class CEventFindDlg;
class CXMessageArray;
class CXEventSource;
class CEventTrapDlg;

class CSource
{
public:
	CSource();	
    ~CSource();
    SCODE Create(CEventTrapDlg* pdlgEventTrap);
	SCODE CreateWindowEpilogue();
	BOOL Find(BOOL bSearchTree, CString sText, BOOL bWholeWord, BOOL bMatchCase);
    void OnFind(CWnd* pwndParent);
    void GetSelectedMessages(CXMessageArray& aMessages);
    void NotifyTrappingChange(CXEventSource* pEventSource, DWORD dwId, BOOL bIsTrapping);
	void NotifyTcSelChanged();
    CXEventSource* m_pEventSource;

private:
	CLcSource* m_plcSource;
	CTcSource* m_ptcSource;
    CEventTrapDlg* m_pdlgEventTrap;

    friend class CEventFindDlg;
    CEventFindDlg* m_pdlgFind;
};


#endif _source_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxcmn.h>         // MFC common control classes
#include <afxmt.h>          // MFC multi threading classes

#include "resource.h"
#include "ewhelparr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\source.cpp ===
//******************************************************************
// source.cpp
//
// This is file contains the implementation of the CSource class.  
//
// The CSource class acts as a container class for the message source,
// which is composed of the source tree control and the message list.
//
// Author: Larry A. French
//
// History:
//      20-Febuary-1996     Larry A. French
//          Wrote it.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//******************************************************************
#include "stdafx.h"
#include "regkey.h"
#include "source.h"
#include "utils.h"
#include "globals.h"

#include "tcsource.h"
#include "lcsource.h"
#include "evntfind.h"
#include "trapdlg.h"




CSource::CSource()
{
    m_pEventSource = NULL;
    m_ptcSource = NULL;
    m_plcSource = NULL;
    m_pdlgEventTrap = NULL;
    m_pdlgFind = NULL;
}


CSource::~CSource()
{
    delete m_pdlgFind;
}

SCODE CSource::Create(CEventTrapDlg* pdlgEventTrap)
{
	m_ptcSource = &pdlgEventTrap->m_tcSource;
	m_ptcSource->m_pSource = this;

	m_plcSource = &pdlgEventTrap->m_lcSource;
	m_plcSource->m_pSource = this;

    m_pdlgEventTrap = pdlgEventTrap;

    return S_OK;
}



//***************************************************************************
// CSource::NotifyTcSelChanged
//
// This method returns an array of pointers to the messages currently selected
// in the CLcEvents list control.  These pointers are owned by g_aEventLogs and
// the caller should not delete them.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//***************************************************************************
void CSource::GetSelectedMessages(CXMessageArray& aMessages)
{
    m_plcSource->GetSelectedMessages(aMessages);
}



//***************************************************************************
// CSource::NotifyTcSelChanged
//
// This method is called when the selection changes in the event-source tree
// control (CTcSource).  When the selection changes, the message list must
// be updated.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//***************************************************************************
void CSource::NotifyTcSelChanged()
{
	m_pEventSource = m_ptcSource->GetSelectedEventSource();
	m_plcSource->SetEventSource(m_pEventSource);
    m_pdlgEventTrap->NotifySourceSelChanged();
}




//***************************************************************************
//
//  CSource::CreateWindowEpilogue()
//
//  This method is called after a window has been created for this list
//  control.  Final initialization is done here.
//
//  Parameters:
//		None.
//
//  Returns:
//		SCODE
//			S_OK if the initialization was successful, otherwise E_FAIL.
//
//  Status:
//      
//***************************************************************************
SCODE CSource::CreateWindowEpilogue()
{
	SCODE scTc = m_ptcSource->CreateWindowEpilogue();
	SCODE scLc = m_plcSource->CreateWindowEpilogue();

	if (FAILED(scTc) || FAILED(scLc)) {
		return E_FAIL;
	}
	
	return S_OK;
}



//******************************************************************
// CSource::Find
//
// Find the specified event source.  This is done by searching either
// the tree or the list control depending on the bSearchTree parameter.
//
// Parameters:
//		BOOL bSearchTree
//			TRUE if the tree should be searched, otherwise the list control
//			is searched.
//
//		CString& sText
//			A string containing the text to search for.
//
//		BOOL bWholeWord
//			TRUE if this is a "whole word" search.  False if it
//			is OK to match a partial word.
//
//		BOOL bMatchCase
//			TRUE if a case-sensitive comparison should be used.
//
// Returns:
//		BOOL
//			TRUE if the string was found, FALSE otherwise.  If the specified
//			text is found, then the selection is set on the corresponding
//			item, the item is scrolled into view and the focus
//			is set on the item.
//
//******************************************************************
BOOL CSource::Find(BOOL bSearchTree, CString sText, BOOL bWholeWord, BOOL bMatchCase)
{
    
	if (bSearchTree) 
		return m_ptcSource->Find(sText, bWholeWord, bMatchCase);
	else 
		return m_plcSource->Find(sText, bWholeWord, bMatchCase);
}




//************************************************************************
// CSource::OnFind
//
// This method is called when the "Find" button in the CEventTrap dialog
// is clicked. 
//
// Parameters:
//      CWnd* pwndParent
//          Pointer to the parent window of the "find" dialog.  This happens
//          to be the CEventTrapDialog.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CSource::OnFind(CWnd* pwndParent)
{
    if (m_pdlgFind == NULL) {
        m_pdlgFind = new CEventFindDlg(pwndParent);
        m_pdlgFind->Create(this, IDD_EVENTFINDDLG, pwndParent);
    }


    m_pdlgFind->BringWindowToTop();
}



//*************************************************************************
// CSource::NotifyTrappingChange
//
// This method is called when an event is added or removed from the
// event list.  This CSource message source container must be notified
// so that the corresponding method can be marked as trapped or not
// trapped in the CLcSource list control.
//
// Parameters:
//      CXEventSource* pEventSource
//          Pointer to the event's event-source
//
//      DWORD dwId
//          The event's ID
//
//      BOOL bIsTrapping
//          TRUE if the event is being trapped, FALSE if not.,
//
// Returns:
//      Nothing.
//*************************************************************************
void CSource::NotifyTrappingChange(CXEventSource* pEventSource, DWORD dwId, BOOL bIsTrapping)
{
    if (pEventSource == m_pEventSource) {
        m_plcSource->NotifyTrappingChange(dwId, bIsTrapping);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\tcsource.h ===
#ifndef _tcsource_h
#define _tcsource_h


/////////////////////////////////////////////////////////////////////////////
// CTcSource window

class CXEventSource;

class CTcSource : public CTreeCtrl
{
// Construction
public:
	CTcSource();
	SCODE CreateWindowEpilogue();
	CXEventSource* GetSelectedEventSource();
	void SelChanged() { m_pSource->NotifyTcSelChanged(); }
	BOOL Find(CString& sText, BOOL bWholeWord, BOOL bMatchCase);

// Attributes
public:
	

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTcSource)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTcSource();

	// Generated message map functions
protected:
	//{{AFX_MSG(CTcSource)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	void LoadImageList();
	SCODE LoadTreeFromRegistry();
	CImageList m_ImageList;	

	friend class CSource;
	CSource* m_pSource;
};

#endif //_tcsource_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\tcsource.cpp ===
#include "stdafx.h"
#include "source.h"
#include "tcsource.h"
#include "regkey.h"
#include "utils.h"
#include "globals.h"
#include "trapreg.h"


/////////////////////////////////////////////////////////////////////////////
// CTcSource

CTcSource::CTcSource()
{
}

CTcSource::~CTcSource()
{
}


BEGIN_MESSAGE_MAP(CTcSource, CTreeCtrl)
	//{{AFX_MSG_MAP(CTcSource)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTcSource message handlers



void CTcSource::LoadImageList()
{
    m_ImageList.Create(16, 16, ILC_COLOR | ILC_MASK, 2, 0);

	CBitmap* pFolder;

    pFolder = new CBitmap;
    pFolder->LoadBitmap(IDB_FOLDERCLOSE);
    m_ImageList.Add(pFolder, (COLORREF)0xff00ff);
	delete pFolder;

    pFolder = new CBitmap;
    pFolder->LoadBitmap(IDB_FOLDEROPEN);
    m_ImageList.Add(pFolder, (COLORREF)0xff00ff);

	delete pFolder;

    SetImageList(&m_ImageList, TVSIL_NORMAL);	
}	

SCODE CTcSource::LoadTreeFromRegistry()
{
    TV_INSERTSTRUCT TreeCtrlItem;
    TreeCtrlItem.hInsertAfter = TVI_LAST;

	// Iterate through each of the event logs and add each log to the tree.
	LONG nLogs = g_reg.m_aEventLogs.GetSize();
    for (LONG iLog=0; iLog < nLogs; ++iLog)
    {
        CXEventLog* pEventLog = g_reg.m_aEventLogs[iLog];

        TreeCtrlItem.hParent = TVI_ROOT;
        TreeCtrlItem.item.pszText = (LPTSTR)(LPCTSTR)pEventLog->m_sName;
        TreeCtrlItem.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
        TreeCtrlItem.item.iImage = 0;
        TreeCtrlItem.item.iSelectedImage = 0;
        TreeCtrlItem.item.lParam = (LPARAM) pEventLog;
        
        HTREEITEM htiParent = InsertItem(&TreeCtrlItem);

        TreeCtrlItem.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
        TreeCtrlItem.hParent = htiParent;
        TreeCtrlItem.item.iImage = 0;
        TreeCtrlItem.item.iSelectedImage = 1;

        // Insert each source as a child.
        LONG nSources = pEventLog->m_aEventSources.GetSize();
        for (LONG iSource = 0; iSource < nSources; ++iSource) {
            CXEventSource* pEventSource = pEventLog->m_aEventSources.GetAt(iSource);
            TreeCtrlItem.item.pszText = (LPTSTR)(LPCTSTR)pEventSource->m_sName;
            TreeCtrlItem.item.lParam = (LPARAM) pEventSource;
            InsertItem(&TreeCtrlItem);
        }
    }
    SortChildren(NULL);
	return S_OK;
}



SCODE CTcSource::CreateWindowEpilogue()
{
	LoadImageList();
	LoadTreeFromRegistry();
	return S_OK;
}


//******************************************************************
// CTcSource::GetSelectedEventSource
//
// Get name of the event source and log for the currently selected
// event source. 
//
// Parameters:
// 		CString& sLog
//			This is where the event log name is returned.
//
// 		CString& sEventSource
//			This is where the name of the event source (application)
//			is returned.
//
// Returns:
//		SCODE
//			S_OK if an event source was selected and the log and event source
//			names are returned.
//
//			E_FAIL if no event source was selected.  The log and event source
//			names are returned as empty when this occurs.
//
//******************************************************************
CXEventSource* CTcSource::GetSelectedEventSource()
{
    HTREEITEM htiParent, htiSelected; 

    // Get the selected item.
    htiSelected = GetSelectedItem();
    if (htiSelected == NULL)
        return NULL;

	// If the selected item is an event source (application), then
	// its parent should be the log.  To get the log name, we must
	// get the parent name.
    htiParent = GetParentItem(htiSelected);
    if (htiParent == NULL)
        return NULL;

	// The application name is the selected item.
    TV_ITEM tvi;
    tvi.hItem = htiSelected;
    tvi.mask = TVIF_HANDLE | TVIF_PARAM;    
    if (GetItem(&tvi) == FALSE)
        return NULL;
    return (CXEventSource*) (void*) tvi.lParam;
}





//******************************************************************
// CTcSource::Find
//
// Find the specified event source in the tree.
//
// Parameters:
//		CString& sText
//			A string containing the text to search for.
//
//		BOOL bWholeWord
//			TRUE if this is a "whole word" search.  False if it
//			is OK to match a partial word.
//
//		BOOL bMatchCase
//			TRUE if a case-sensitive comparison should be used.
//
// Returns:
//		BOOL
//			TRUE if the string was found, FALSE otherwise.  If the specified
//			text is found, then the selection is set on the corresponding
//			tree item.
//
//******************************************************************
BOOL CTcSource::Find(CString& sText, BOOL bWholeWord, BOOL bMatchCase)
{    
    // Search the source tree for sText. We are only looking at the source
    // names, not the types.
                                
    HTREEITEM hCurrentItem, hStartItem, hSourceItem, hRootItem;
    TV_ITEM tvItem;
    CString sSource;
    TCHAR szBuffer[256];
    BOOL bItemFound = FALSE, bCompleteLoop = FALSE;

    // Get the selected item and keep track of it.
    hCurrentItem = GetSelectedItem();
    if (hCurrentItem == NULL)
    {
        // Nothing selected; get the root.
        hCurrentItem = GetRootItem();
        if (hCurrentItem == NULL)
            return FALSE; 
    }    
    hStartItem = hCurrentItem;

    // Loop until we find a match or we are back where we started.
    while (!bItemFound && !bCompleteLoop)
    {
         hSourceItem = NULL;

        // Get the next item.
        
        // Current item is root; get the first child.
        hRootItem = GetParentItem(hCurrentItem);
        if (hRootItem == NULL)
            hSourceItem = GetChildItem(hCurrentItem);
                
        // Current item is a source; get the next sibling.
        else
        {
            hSourceItem = GetNextItem(hCurrentItem, TVGN_NEXT);
            // No sibling; get the parent and set it as the current item.
            if (hSourceItem == NULL)
            {
                 hRootItem = GetParentItem(hCurrentItem);
                if (hRootItem == NULL)
                    return FALSE;  // No parent; something is wrong.
                hCurrentItem = hRootItem;
            }
        }

        // We have a source; get it and compare.
        if (hSourceItem != NULL)
        {
            hCurrentItem = hSourceItem;

            tvItem.mask = TVIF_HANDLE | TVIF_TEXT;
            tvItem.hItem = hSourceItem;
            tvItem.pszText = szBuffer;
            tvItem.cchTextMax = 256;
            if (GetItem(&tvItem) == FALSE)
                return FALSE; // Something is wrong.
            sSource = szBuffer;

            // Compare the whole word.
            if (bWholeWord)
            {
                int nRetVal;

                // No case compare.
                if (bMatchCase)
                    nRetVal = sSource.Compare(sText);
                // Case compare
                else
                    nRetVal = sSource.CompareNoCase(sText);                    

                if (nRetVal == 0)
                    bItemFound = TRUE;
            }

            // Look for a substring.
            else
            {
                // Make everything upper.
                if (!bMatchCase)
                {
                    sSource.MakeUpper();
                    sText.MakeUpper();
                }

                if (sSource.Find(sText) >= 0)
                    bItemFound = TRUE;
            }
        }        

        // Get the next root.
        else
        {    
            hRootItem = GetNextItem(hCurrentItem, TVGN_NEXT);
            // No more roots in the tree; go to the top of the tree.
            if (hRootItem == NULL)
                hCurrentItem = GetRootItem();
            else
                hCurrentItem = hRootItem;
        }

        if (hCurrentItem == hStartItem)
            bCompleteLoop = TRUE;
    }

    // Found a match; select it.
    if (bItemFound)
    {
        SelectItem(hCurrentItem);
        EnsureVisible(hCurrentItem);
        SetFocus();
        return TRUE;
    }

    return FALSE;            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\trapdlg.cpp ===
//******************************************************************
// trapdlg.cpp
//
// This is the source file for eventrap's main dialog.
//
// Author: Larry A. French
//
// History:
//      December-1995       SEA - Wrote it
//          SEA - wrote it.
//
//      20-Febuary-1996     Larry A. French
//          Totally rewrote it to fix the spagetti code and huge
//          methods.  The original author seemed to have little or
//          no ability to form meaningful abstractions.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//******************************************************************

#include "stdafx.h"
#include "Eventrap.h"
#include "trapdlg.h"
#include "evntprop.h"
#include "settings.h"
#include "busy.h"
#include "trapreg.h"
#include "globals.h"
#include "evntfind.h"
#include "export.h"
#include "dlgsavep.h"

//#include "smsalloc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg message handlers

BOOL CAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	CenterWindow();
	
	// TODO: Add extra about dlg initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}


/////////////////////////////////////////////////////////////////////////////
// CEventTrapDlg dialog

CEventTrapDlg::CEventTrapDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CEventTrapDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CEventTrapDlg)
	//}}AFX_DATA_INIT


    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINICON);

    m_source.Create(this);
	m_bExtendedView = FALSE;
    m_bSaveInProgress = FALSE;
}

CEventTrapDlg::~CEventTrapDlg()
{
    PostQuitMessage(0);
}

void CEventTrapDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEventTrapDlg)
	DDX_Control(pDX, IDC_APPLY, m_btnApply);
	DDX_Control(pDX, ID_BUTTON_EXPORT, m_btnExport);
	DDX_Control(pDX, IDC_EVENTLIST, m_lcEvents);
	DDX_Control(pDX, IDC_TV_SOURCES, m_tcSource);
    DDX_Control(pDX, IDC_STAT_LABEL0, m_statLabel0);
	DDX_Control(pDX, IDC_STAT_LABEL1, m_statLabel1);
	DDX_Control(pDX, IDC_STAT_LABEL2, m_statLabel2);
    DDX_Control(pDX, IDC_LV_SOURCES, m_lcSource);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDCANCEL, m_btnCancel);
	DDX_Control(pDX, ID_SETTINGS, m_btnSettings);
	DDX_Control(pDX, ID_PROPERTIES, m_btnProps);
	DDX_Control(pDX, ID_VIEW, m_btnView);
	DDX_Control(pDX, ID_REMOVE, m_btnRemove);
	DDX_Control(pDX, ID_ADD, m_btnAdd);
	DDX_Control(pDX, ID_FIND, m_btnFind);
	DDX_Control(pDX, IDC_STAT_GRP_CONFIG_TYPE, m_btnConfigTypeBox);
    DDX_Control(pDX, IDC_RADIO_CUSTOM, m_btnConfigTypeCustom);
    DDX_Control(pDX, IDC_RADIO_DEFAULT, m_btnConfigTypeDefault);
	//}}AFX_DATA_MAP

}

BEGIN_MESSAGE_MAP(CEventTrapDlg, CDialog)
    //{{AFX_MSG_MAP(CEventTrapDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(ID_ADD, OnAdd)
    ON_BN_CLICKED(ID_PROPERTIES, OnProperties)
    ON_BN_CLICKED(ID_SETTINGS, OnSettings)
	ON_NOTIFY(NM_DBLCLK, IDC_EVENTLIST, OnDblclkEventlist)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_EVENTLIST, OnColumnclickEventlist)
	ON_WM_SIZE()
	ON_BN_CLICKED(ID_VIEW, OnView)
	ON_BN_CLICKED(ID_REMOVE, OnRemove)
	ON_BN_CLICKED(ID_FIND, OnFind)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TV_SOURCES, OnSelchangedTvSources)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LV_SOURCES, OnColumnclickLvSources)
	ON_NOTIFY(NM_DBLCLK, IDC_LV_SOURCES, OnDblclkLvSources)
	ON_BN_CLICKED(ID_BUTTON_EXPORT, OnButtonExport)
	ON_NOTIFY(LVN_KEYDOWN, IDC_EVENTLIST, OnKeydownEventlist)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_EVENTLIST, OnItemchangedEventlist)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LV_SOURCES, OnItemchangedLvSources)
	ON_BN_CLICKED(IDC_RADIO_CUSTOM, OnRadioCustom)
	ON_BN_CLICKED(IDC_RADIO_DEFAULT, OnRadioDefault)
	ON_WM_DRAWITEM()
	ON_COMMAND(ID_HELP, OnHelp)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_BN_CLICKED(IDC_APPLY, OnApply)
	ON_BN_CLICKED(IDC_DEFAULT, OnDefault)
	ON_NOTIFY(TVN_ITEMEXPANDED, IDC_TV_SOURCES, OnTvSourcesExpanded)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEventTrapDlg message handlers

void CEventTrapDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
/*
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
*/
	CDialog::OnSysCommand(nID, lParam);
    m_lcEvents.SetFocus();

}

void CEventTrapDlg::OnDestroy()
{
	CDialog::OnDestroy();
}


// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.
void CEventTrapDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CEventTrapDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


//*************************************************************************
// CEventTrapDlg::OnInitDialog
//
// Initialize the dialog.
//

// Parameters:
//      None.
//
// Returns:
//      BOOL
//          TRUE if Windows should set the focus to the first control
//          in the dialog box.  FALSE if the focus has already been set
//          and Windows should leave it alone.
//
//*************************************************************************
BOOL CEventTrapDlg::OnInitDialog()
{
    CBusy busy;
    CDialog::OnInitDialog();
	CenterWindow();

//    VERIFY(m_lcSource.SubclassDlgItem(IDC_LV_SOURCES, this));


    SetIcon(m_hIcon, TRUE);
    SetIcon(m_hIcon, FALSE);

    m_layout.Initialize(this);

    // Layout the dialog view for the small (non-extended) view
    m_bExtendedView = FALSE;
    m_layout.LayoutView(FALSE);

    // The registry class is keeping a pointer to the 'Apply' pointer in order to
    // enable disable it according to the 'dirty' state.
    g_reg.SetApplyButton(&m_btnApply);

    // Step the progress indicator for loading the configuration.
    // Note that if you add more steps here, you must modify
    // CTrapReg::CTrapReg to account for these extra steps.
    //=========================================================
    g_reg.m_pdlgLoadProgress->StepProgress();
    ++g_reg.m_nLoadSteps;

    CString sText;
    sText.LoadString(IDS_TITLE_EDIT_BUTTON);
    m_btnView.SetWindowText(sText);

    // Notify the message source container and the events list control
    // that this dialog has been initialized so that they can initialize
    // their windows and so on.  Note that this must be called after the
    // g_reg.m_aEventLogs is deserialized because information contained therein
    // will be displayed
	m_source.CreateWindowEpilogue();
    g_reg.m_pdlgLoadProgress->StepProgress();
    ++g_reg.m_nLoadSteps;


    m_lcEvents.CreateWindowEpilogue();			
    g_reg.m_pdlgLoadProgress->StepProgress();
    ++g_reg.m_nLoadSteps;


    m_lcEvents.AddEvents(m_source, g_reg.m_aEventLogs);
    g_reg.m_pdlgLoadProgress->StepProgress();
    ++g_reg.m_nLoadSteps;


    m_sExportTitle.LoadString(IDS_EXPORT_DEFAULT_FILENAME);

    CheckEventlistSelection();
    m_btnAdd.EnableWindow(FALSE);

    if ((g_reg.GetConfigType() == CONFIG_TYPE_CUSTOM)) {
        CheckRadioButton(IDC_RADIO_CUSTOM, IDC_RADIO_DEFAULT, IDC_RADIO_CUSTOM);
    }
    else {
        CheckRadioButton(IDC_RADIO_CUSTOM, IDC_RADIO_DEFAULT, IDC_RADIO_DEFAULT);
    }


    if ((g_reg.GetConfigType() == CONFIG_TYPE_CUSTOM) && !g_reg.m_bRegIsReadOnly) {
        m_btnView.EnableWindow(TRUE);
    }
    else {
        m_btnView.EnableWindow(FALSE);
    }


    // If eventrap will be used without the SMS Admin UI, then we want to hide the
    // configuration type group box because it it meaningless if SMS will not be
    // distributing jobs containing the default configuration.
    if (!g_reg.m_bShowConfigTypeBox) {
    	m_btnConfigTypeBox.ShowWindow(SW_HIDE);
        m_btnConfigTypeCustom.ShowWindow(SW_HIDE);
        m_btnConfigTypeDefault.ShowWindow(SW_HIDE);
    }


    // Now that we know what the configuration type is, we can update the
    // dialog's title.  But first we will save the default dialog title so
    // that we can use it as the base that will be extended with an optional
    // machine name and configuration type.
    GetWindowText(m_sBaseDialogCaption);
    UpdateDialogTitle();

    delete g_reg.m_pdlgLoadProgress;
    g_reg.m_pdlgLoadProgress = NULL;

    // initially, once the registry gets loaded, the dirty state is 'false'
    g_reg.SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


//*************************************************************************
// CEventTrapDlg::OnAdd
//
// Add the messages that are currently selected in the message source list
// to the event list.
//
// The event list is the list control in the upper part of the dialog box.
// The message source list is the list control in the lower-right side of
// the dialog box.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CEventTrapDlg::OnAdd()
{
    CBusy busy;

    // Get an array containing the selected messages
    CXMessageArray aMessages;
    m_source.GetSelectedMessages(aMessages);
    if (aMessages.GetSize() == 0) {
        AfxMessageBox(IDS_WARNING_NO_MESSAGE_SELECTED);
        m_lcEvents.SetFocus();
        return;
    }

    // Create a set of events corresponding to the messages.
    CXEventArray aEvents;
    CXEventArray aEventsAlreadyTrapped;
    LONG nMessages = aMessages.GetSize();
    m_lcEvents.UpdateWindow();

    aEvents.RemoveAll();
    for (LONG iMessage = 0; iMessage < nMessages; ++iMessage) {
        CXMessage* pMessage = aMessages[iMessage];
        CXEvent* pEvent;
        pEvent = pMessage->m_pEventSource->FindEvent(pMessage->m_dwId);
        if (pEvent == NULL) {
            CXEvent* pEvent = new CXEvent(pMessage);
            aEvents.Add(pEvent);
        }
        else {
            aEventsAlreadyTrapped.Add(pEvent);
        }
    }

    if (aEvents.GetSize() > 0) {
        // Now we need to ask the user for the "settings" for these events.
        CEventPropertiesDlg dlg;
        if (!dlg.EditEventProperties(aEvents)) {
            aEvents.DeleteAll();
            m_lcEvents.SetFocus();
            return;
        }

        m_lcEvents.AddEvents(m_source, aEvents);

        aEvents.RemoveAll();
        g_reg.SetDirty(TRUE);
    }

    if (aEventsAlreadyTrapped.GetSize() > 0) {
        m_lcEvents.SelectEvents(aEventsAlreadyTrapped);
        aEventsAlreadyTrapped.RemoveAll();
        if (nMessages == aEventsAlreadyTrapped.GetSize()) {
            AfxMessageBox(IDS_ALREADYTRAPPING);
        }
        else {
            AfxMessageBox(IDS_SOMETRAPPING);
        }
    }
    m_lcEvents.SetFocus();

}








//*************************************************************************
// CEventTrapDlg::OnProperties
//
// Edit the properties of the selected events in the event-list.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CEventTrapDlg::OnProperties()
{
    CXEventArray aEvents;
    m_lcEvents.GetSelectedEvents(aEvents);

    // Nothing selected.
    if (aEvents.GetSize() == 0)
    {
        CString sMsg;
        sMsg.LoadString(IDS_MSG_SELECTEVENT);
        MessageBox(sMsg, NULL, MB_ICONEXCLAMATION);
    }
    else {
        // Put up the dialog to edit the event properties.
        CEventPropertiesDlg dlg;
        if (dlg.EditEventProperties(aEvents)) {
            m_lcEvents.RefreshEvents(aEvents);
        }
    }
    m_lcEvents.SetFocus();
}



//*************************************************************************
// CEventTrapDlg::OnSettings
//
// Edit the global settings.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CEventTrapDlg::OnSettings()
{
    // Setup and load the dialog.
    CTrapSettingsDlg dlg(this);
    dlg.EditSettings();
    m_lcEvents.SetFocus();
}



//*************************************************************************
// CEventTrapDlg::OnRemove
//
// Remove the events currently selected in the CLcEvents list control.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*************************************************************************
void CEventTrapDlg::OnRemove()
{
    // If nothing was selected, warn the user.
    CString sText;
    if (!m_lcEvents.HasSelection()) {
        sText.LoadString(IDS_MSG_SELECTEVENT);
        MessageBox(sText, NULL, MB_ICONEXCLAMATION);
        return;  // Nothing to do.
    }

    // Make sure the user wants to delete these items.
    sText.LoadString(IDS_MSG_DELETEEVENT);
    if (MessageBox(sText, NULL, MB_ICONQUESTION | MB_OKCANCEL) != IDOK)
        return;

    // We must notify the source control that the events are deleted
    // so that the trapping flag can be updated.
    CBusy busy;
    m_lcEvents.DeleteSelectedEvents(m_source);
    g_reg.SetDirty(TRUE);

    // All of the selected events were removed, so now there is no selection
    // and the export and properties buttons should be disabled.
    m_btnProps.EnableWindow(FALSE);
    m_btnExport.EnableWindow(FALSE);
    m_btnRemove.EnableWindow(FALSE);
    m_lcEvents.SetFocus();
}




//*********************************************************************
// CEventTrapDlg::OnOK
//
// This method is called when the "OK" button is clicked.  All we
// have to do is save the current configuration.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnOK()
{
    CBusy busy;

    // Set the save in progress flag so that we aren't interrupted in the
    // middle of writing to the registry.
    m_bSaveInProgress = TRUE;

    // Clear the "lost connection" flag so that the user can attempt to save
    // again.
    SCODE sc = g_reg.Serialize();
    if ((sc == S_SAVE_CANCELED) || FAILED(sc)) {
        // Control comes here if the user elected to cancel the save.  We clear
        // the m_bSaveInProgress dialog so that the user can cancel out of this
        // application altogether if he or she chooses to do so.
        m_bSaveInProgress = FALSE;
        return;
    }

    CDialog::OnOK();
    delete this;
}

//*********************************************************************
// CEventTrapDlg::OnApply
//
// This method is called when the "Apply" button is clicked.  All we
// have to do is save the current configuration.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnApply()
{
    CBusy busy;

    // Set the save in progress flag so that we aren't interrupted in the
    // middle of writing to the registry.
    m_bSaveInProgress = TRUE;

    // Clear the "lost connection" flag so that the user can attempt to save
    // again.
    SCODE sc = g_reg.Serialize();

    // Control comes here if the user elected to cancel the save.  We clear
    // the m_bSaveInProgress dialog so that the user can cancel out of this
    // application altogether if he or she chooses to do so.
    m_bSaveInProgress = FALSE;
}


//********************************************************************
// CEventTrapDlg::OnDblclkEventlist
//
// This method is called when the user double clicks an item within
// the event-list.  This is equivallent to clicking the "Properties"
// button.
//
// Parameters:
//      NMHDR* pNMHDR
//
//      LRESULT* pResult
//
// Returns:
//      Nothing.
//******************************************************************
void CEventTrapDlg::OnDblclkEventlist(NMHDR* pNMHDR, LRESULT* pResult)
{
    OnProperties();
	*pResult = 0;
}





//************************************************************************
// CEventTrapDlg::OnColumnclickEventlist
//
// This method is called when the user click a column header in the
// eventlist.  When this occurs, the event list must be resorted
// according to the criteria for that column.
//
// Ideally, this method would be a member of the CLcEvents class, but the
// class wizard and MFC wouldn't let me do it (MFC4.0 and VC++4.0 do let
// you do it).
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//***********************************************************************
void CEventTrapDlg::OnColumnclickEventlist(NMHDR* pNMHDR, LRESULT* pResult)
{
    CBusy busy;

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    ASSERT(pNMListView->iSubItem < ICOL_LcEvents_MAX);

    // First flip the sort order for the column and then do the sort.
    g_abLcEventsSortAscending[pNMListView->iSubItem] = ! g_abLcEventsSortAscending[pNMListView->iSubItem];
    m_lcEvents.SortItems(pNMListView->iSubItem);
	*pResult = 0;
}




//************************************************************************
// CEventTrapDlg::OnSize
//
// This method is called when the trap dialog changes sizes.  When this
// occurs, the dialog layout must be recalculated because the dialog is
// laid out dynamically.
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//************************************************************************
void CEventTrapDlg::OnSize(UINT nType, int cx, int cy)
{
	CDialog::OnSize(nType, cx, cy);
	if (!::IsWindow(m_btnOK.m_hWnd)) {
		return;
	}

	m_layout.LayoutAndRedraw(m_bExtendedView, cx, cy);
}






//*********************************************************************
// CEventTrapDlg::OnView
//
// This method is called when the user clicks the View/Edit button.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*********************************************************************
void CEventTrapDlg::OnView()
{
    // Flip the normal/extended view type and redo the dialog layout
    // to reflect the change.
	m_bExtendedView = !m_bExtendedView;	
    m_layout.LayoutView(m_bExtendedView);

    // Flip the title of the View/Edit button to the other state.
    CString sText;
    sText.LoadString(m_bExtendedView ? IDS_TITLE_VIEW_BUTTON : IDS_TITLE_EDIT_BUTTON);
    m_btnView.SetWindowText(sText);
    if (m_bExtendedView)
        m_tcSource.SetFocus();
    else
        m_lcEvents.SetFocus();
}




//********************************************************************
// CEventTrapDlg::OnFind
//
// This method is called when the user clicks the "Find" button.  Pass
// the notification onto the CSource object.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnFind()
{
    m_source.OnFind(this);	
}


//********************************************************************
// CEventTrapDlg::OnSelchangedTvSources
//
// This method is changed when the message source treeview selection
// changes.  Ideally, this method would be part of the CTcSource class,
// but MFC3.0 doesn't allow this (or at least you can't do it through
// the VC++ class wizard).  So, the message needs to be passed along
// to the CTcSource class.
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnSelchangedTvSources(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

	
    // We update the window so that the old selection will be unhighlighted
    // immediately. This is useful if it takes a long time to complete
    // the selection change.  Without the update, the user may get the impression
    // that there is a multiple selection.
    m_tcSource.UpdateWindow();
   	m_tcSource.SelChanged();
	*pResult = 0;
}



//*******************************************************************
// CEventTrapDlg::OnColumnclickLvSources
//
// This method is called when a column is clicked in the message source
// listview. When this occurs, the messages must be resorted according
// to the sorting criteria for the clicked column.
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//******************************************************************
void CEventTrapDlg::OnColumnclickLvSources(NMHDR* pNMHDR, LRESULT* pResult)
{
    CBusy busy;

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    ASSERT(pNMListView->iSubItem < ICOL_LcSource_MAX);

    // First flip the sort order for the column and then do the sort.
    g_abLcSourceSortAscending[pNMListView->iSubItem] = ! g_abLcSourceSortAscending[pNMListView->iSubItem];
	m_lcSource.SortItems(pNMListView->iSubItem);
	*pResult = 0;

}


//*******************************************************************
// CEventTrapDlg::OnDblclkLvSources
//
// This method is called when the user double clicks a message in the
// source list.  This is equivallent to clicking the "Add" button.
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CEventTrapDlg::OnDblclkLvSources(NMHDR* pNMHDR, LRESULT* pResult)
{
	OnAdd();
	*pResult = 0;
}



//********************************************************************
// CEventTrapDlg::OnButtonExport
//
// This method is called when the "Export" button is clicked. This is
// where events can be exported by writing a trap-text or trap tool
// files corresponding to the selected events.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnButtonExport()
{
    CXEventArray aEvents;
    m_lcEvents.GetSelectedEvents(aEvents);

    // Nothing selected.
    if (aEvents.GetSize() == 0)
    {
        AfxMessageBox(IDS_MSG_SELECTEVENT, MB_ICONEXCLAMATION);
    }
    else {
        m_dlgExport.DoModal(aEvents);
    }


    m_lcEvents.SetFocus();
}



//*******************************************************************
// CEventTrapDlg::OnCancel
//
// This method is called when the cancel button is clicked.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CEventTrapDlg::OnCancel()
{
    if (m_bSaveInProgress) {
        return;
    }

	CDialog::OnCancel();
    delete this;
}



//********************************************************************
// CEventTrapDlg::CheckEventlistSelection
//
// Check to see if any events are currently selected in the event
// list. If no events are selected, then the buttons that operate on
// events are disabled.  If at least one event is selected  then the
// buttons that operate on events are enabled.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CEventTrapDlg::CheckEventlistSelection()
{
    LONG nSelected = m_lcEvents.GetSelectedCount();
    if (nSelected > 0) {
        m_btnProps.EnableWindow(TRUE);
        m_btnExport.EnableWindow(TRUE);
        m_btnRemove.EnableWindow(TRUE);
    }
    else {
        m_btnProps.EnableWindow(FALSE);
        m_btnExport.EnableWindow(FALSE);
        m_btnRemove.EnableWindow(FALSE);
    }

}



//********************************************************************
// CEventTrapDlg::CheckSourcelistSelection
//
// Check to see if any messages are currently selected in the message
// source list. If no messages are selected, then the "Add" button needs
// to be disabled.  If one or more messages are selected, then the "Add"
// button is enabled, allowing the user to add the message to the event
// list.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*******************************************************************
void CEventTrapDlg::CheckSourcelistSelection()
{
    LONG nSelected = m_lcSource.GetSelectedCount();
    if (nSelected > 0) {
        m_btnAdd.EnableWindow(TRUE);
    }
    else {
        m_btnAdd.EnableWindow(FALSE);
    }
}



//********************************************************************
// CEventTrapDlg::OnKeydownEventlist
//
// This method is called when a keydown message is sent to the
// event list.  There are reasons why we monitor keydown events here:
//
//      1. To delete the selected event when the user hits the delete key.
//
// Parameters:
//      See the MFC documentation.
//
// Returns:
//      Nothing.
//
//********************************************************************
void CEventTrapDlg::OnKeydownEventlist(NMHDR* pNMHDR, LRESULT* pResult)
{

    #define VKEY_DELETE 46
	LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;

    // Check to see if the delete key was entered.  If so, delete the
    // selected event.  Note that events can be deleted only if this
    // is a "Custom" configuration.
    if (pLVKeyDow->wVKey == VKEY_DELETE) {
        if (g_reg.GetConfigType() == CONFIG_TYPE_CUSTOM) {
            if (pLVKeyDow->wVKey == VKEY_DELETE) {
                OnRemove();
            }
        	*pResult = 0;

        } else {
            MessageBeep(MB_ICONQUESTION);
        }
    }

}



//***************************************************************************
// CEventTrapDlg::OnItemchangedEventlist
//
// This method is called when an item changes in the event list.  When this
// occurs, various buttons may have to be enabled or disabled depending on
// whether or not anything is selected.
//
// Parameters:
//      Please see the MFC documentation.
//
// Returns:
//      Nothing.
//
//**************************************************************************
void CEventTrapDlg::OnItemchangedEventlist(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
    CheckEventlistSelection();
	
	*pResult = 0;
}



//***********************************************************************
// CEventTrapDlg::OnItemchangedLvSources
//
// This method is called when an item in the message source list changes.
// When this occurs, buttons such as "Add" and "Remove" may have to
// be enabled or disabled depending on whether or not anything is selected
// in the list.
//
// Parameters:
//      NMHDR* pNMHDR
//
//      LRESULT* pResult
//
// Returns:
//      Nothing.
//
//***********************************************************************

void CEventTrapDlg::OnItemchangedLvSources(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    CheckSourcelistSelection();
	*pResult = 0;
}


//*********************************************************************
// CEventTrapDlg::NotifySourceSelChanged
//
// This method is called when the selection changes in the message source
// list.  When this occurs, buttons such as "Add" and "Remove" may have
// to be enabled or disabled depending on whether or not anything is
// selected in the list.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//*********************************************************************
void CEventTrapDlg::NotifySourceSelChanged()
{
    CheckSourcelistSelection();
}



//*********************************************************************
// CEventTrapDlg::OnRadioCustom
//
// This method is called when the "Custom" radio button in the
// "Configuration Type" groupbox is clicked. When the user selects
// the custom configuration type, he or she is allowed to edit the
// current configuration.  Also the registry will be marked so that
// the next time SMS distributes an "Event to Trap" configuration job,
// the current configuration will not be replaced with the default configuration.
//
// There are three possible configuration states: custom, default, and
// default pending.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//**********************************************************************
void CEventTrapDlg::OnRadioCustom()
{
    CheckRadioButton(IDC_RADIO_CUSTOM, IDC_RADIO_DEFAULT, IDC_RADIO_CUSTOM);
    if (!g_reg.m_bRegIsReadOnly) {
        m_btnView.EnableWindow(TRUE);
    }
    g_reg.SetConfigType(CONFIG_TYPE_CUSTOM);
    UpdateDialogTitle();
}


//*********************************************************************
// CEventTrapDlg::OnRadioDefault
//
// This method is called when the "Default" radio button in the
// "Configuration Type" groupbox is clicked. When the user selects
// the default configuration, he or she is prevented from editing the
// current configuration.  Also the registry will be marked so that
// the next time SMS distributes an "Event to Trap" configuration job,
// the current configuration will be replaced with the default configuration.
//
// There are three possible configuration states: custom, default, and
// default pending.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//**********************************************************************
void CEventTrapDlg::OnRadioDefault()
{
    CheckRadioButton(IDC_RADIO_CUSTOM, IDC_RADIO_DEFAULT, IDC_RADIO_DEFAULT);

    // When the "Default" configuration is slected, the user is not allowed
    // to edit the event list, so if the extended dialog view is currently
    // being displayed, it is flipped back to the non-extended state and
    // the edit button is disabled.
    if (m_bExtendedView) {
        OnView();
    }
    m_btnView.EnableWindow(FALSE);

    // Mark the registry with the current config type so that when the
    // SMS event to trap job comes, it knows that it can overwrite the
    // current settings.
    g_reg.SetConfigType(CONFIG_TYPE_DEFAULT);

    // Update the dialog title to indicate the configuration state.
    UpdateDialogTitle();
}



//**********************************************************************
// CEventTrapDlg::UpdateDialogTitle
//
// This method updates the dialog's title.  The format of the title is
//
//      Event to Trap Translator - Machine Name - [configuration type]
//
// If the registry of the local machine is being edited, then the
// machine name is omitted.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//**********************************************************************
void CEventTrapDlg::UpdateDialogTitle()
{
    // Map the configuration type to a string-table resource id.
    LONG idsConfigType;
    switch(g_reg.GetConfigType()) {
    case CONFIG_TYPE_CUSTOM:
        idsConfigType = IDS_CONFIGTYPE_CUSTOM;
        break;
    case CONFIG_TYPE_DEFAULT:
        idsConfigType = IDS_CONFIGTYPE_DEFAULT;
        break;
    case CONFIG_TYPE_DEFAULT_PENDING:
        idsConfigType = IDS_CONFIGTYPE_DEFAULT_PENDING;
        break;
    default:
        ASSERT(FALSE);
        break;
    }

    CString sConfigType;
    sConfigType.LoadString(idsConfigType);

    CString sCaption = m_sBaseDialogCaption;
    if (!g_reg.m_sComputerName.IsEmpty()) {
        sCaption = sCaption + _T(" - ") + g_reg.m_sComputerName;
    }
    sCaption = sCaption + _T(" - [") + sConfigType + _T(']');
    SetWindowText(sCaption);

}

void CEventTrapDlg::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	// TODO: Add your message handler code here and/or call default
	
	CDialog::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

BOOL CEventTrapDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                   AfxGetApp()->m_pszHelpFilePath,
                   HELP_WM_HELP,
                   (ULONG_PTR)g_aHelpIDs_IDD_EVNTTRAPDLG);
	}
	
	return TRUE;
}

void CEventTrapDlg::OnContextMenu(CWnd* pWnd, CPoint point)
{
	CMenu contextMenus;

    if (this == pWnd)
		return;

	contextMenus.LoadMenu(IDR_CTXMENUS);

	if (pWnd->m_hWnd == m_lcEvents.m_hWnd)
	{
		CMenu * pMenuLcEvents;

		pMenuLcEvents = contextMenus.GetSubMenu(0);

		if (pMenuLcEvents != NULL)
		{

			if (!m_lcEvents.HasSelection())
			{
				pMenuLcEvents->EnableMenuItem(0, MF_GRAYED | MF_BYPOSITION);
				pMenuLcEvents->EnableMenuItem(3, MF_GRAYED | MF_BYPOSITION);
				pMenuLcEvents->EnableMenuItem(5, MF_GRAYED | MF_BYPOSITION);
			}

			pMenuLcEvents->TrackPopupMenu(
				TPM_LEFTALIGN | TPM_LEFTBUTTON,
				point.x,
				point.y,
				this,
				NULL);
		}
	}
	else if (pWnd->m_hWnd == m_lcSource.m_hWnd)
	{
		CMenu *pMenuLcSource;

		pMenuLcSource = contextMenus.GetSubMenu(1);

		if (pMenuLcSource != NULL)
		{
			if (m_lcSource.GetNextItem(-1, LVNI_SELECTED) == -1)
			{
				pMenuLcSource->EnableMenuItem(0, MF_GRAYED | MF_BYPOSITION);
			}

			pMenuLcSource->TrackPopupMenu(
				TPM_LEFTALIGN | TPM_LEFTBUTTON,
				point.x,
				point.y,
				this,
				NULL);
		}
	}
	else
	{
	   ::WinHelp (pWnd->m_hWnd,
              AfxGetApp()->m_pszHelpFilePath,
              HELP_CONTEXTMENU,
              (ULONG_PTR)g_aHelpIDs_IDD_EVNTTRAPDLG);
	}
}

void CEventTrapDlg::OnDefault()
{
	HTREEITEM hti;
	DWORD ctrlID = GetFocus()->GetDlgCtrlID();

	switch(ctrlID)
	{
	case IDC_EVENTLIST:
		if (m_lcEvents.HasSelection())
			OnProperties();
		else
			OnSettings();
		break;
	case IDC_TV_SOURCES:
		hti = m_tcSource.GetSelectedItem();
		if (hti != NULL)
			m_tcSource.Expand(hti, TVE_TOGGLE);
		break;
	case IDC_LV_SOURCES:
		OnAdd();
		m_lcSource.SetFocus();
		break;
	case IDC_RADIO_CUSTOM:
		OnRadioDefault();
		m_btnConfigTypeDefault.SetFocus();
		break;
	case IDC_RADIO_DEFAULT:
		OnRadioCustom();
		m_btnConfigTypeCustom.SetFocus();
		break;
	default:
		OnOK();
	}
}

void CEventTrapDlg::OnTvSourcesExpanded(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    INT          nImage = (pNMTreeView->itemNew.state & TVIS_EXPANDED) ?
                                1 : // node is expanded -> 'open' folder icon is the second in the list
                                0 ; // node is contracted -> 'close' folder icon is the first in the list
	// TODO: Add your control notification handler code here

    m_tcSource.SetItemImage(pNMTreeView->itemNew.hItem, nImage, nImage);

	*pResult = 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\trapdlg.h ===
//******************************************************************
// trapdlg.h
//
// This is the header file for the main dialog for eventrap.
//
// Author: Larry A. French
//
// History:
//      December-1995       SEA - Wrote it
//          SEA - wrote it.
//
//      20-Febuary-1996     Larry A. French
//          Totally rewrote it to fix the spagetti code and huge
//          methods.  The original author seemed to have little or
//          no ability to form meaningful abstractions.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//******************************************************************

#ifndef TRAPDLG_H
#define TRAPDLG_H

#include "regkey.h"
#include "source.h"         // The message source container
#include "tcsource.h"       // The message source tree control
#include "lcsource.h"       // The message source list control
#include "lcevents.h"
#include "trapreg.h"
#include "layout.h"
#include "export.h"


class CMainLayout;
class CExtendedLayout;




/////////////////////////////////////////////////////////////////////////////
// CEventTrapDlg dialog

class CEventTrapDlg : public CDialog
{
// Construction
public:
	CEventTrapDlg(CWnd* pParent = NULL);   // standard constructor
	~CEventTrapDlg();

    BOOL IsExtendedView() {return m_bExtendedView; }
    void NotifySourceSelChanged();

	CSource     m_source;           // The message source


// Dialog Data
	//{{AFX_DATA(CEventTrapDlg)
	enum { IDD = IDD_EVNTTRAPDLG };
	CButton	m_btnApply;
	CButton	m_btnExport;
	CLcEvents	m_lcEvents;
	CTcSource	m_tcSource;
    CStatic m_statLabel0;
    CStatic	m_statLabel1;
	CStatic	m_statLabel2;
	CLcSource m_lcSource;
	CButton	m_btnOK;
	CButton	m_btnCancel;
	CButton	m_btnSettings;
	CButton	m_btnProps;
	CButton	m_btnView;
	CButton	m_btnRemove;
	CButton	m_btnAdd;
	CButton	m_btnFind;
	CButton	m_btnConfigTypeBox;
    CButton m_btnConfigTypeCustom;
    CButton m_btnConfigTypeDefault;
	//}}AFX_DATA



// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEventTrapDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEventTrapDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnAdd();
	afx_msg void OnProperties();
	afx_msg void OnSettings();
	virtual void OnOK();
	afx_msg void OnDblclkEventlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickEventlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnView();
	afx_msg void OnRemove();
	afx_msg void OnFind();
	afx_msg void OnSelchangedTvSources(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickLvSources(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkLvSources(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonExport();
	virtual void OnCancel();
	afx_msg void OnKeydownEventlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedEventlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedLvSources(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRadioCustom();
	afx_msg void OnRadioDefault();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg BOOL OnHelpInfo(HELPINFO*);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnApply();
	afx_msg void OnDefault();
	afx_msg void OnTvSourcesExpanded(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

protected:
    HICON m_hIcon;

private:
    void CheckEventlistSelection();
    void CheckSourcelistSelection();
    void UpdateDialogTitle();


    BOOL m_bSaveInProgress;
	BOOL m_bExtendedView;
    CLayout m_layout;
    CString m_sExportTitle;
    CDlgExport m_dlgExport;
    CString m_sBaseDialogCaption;
};


#endif //TRAPDLG_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\trapreg.h ===
#ifndef _trapreg_h
#define _trapreg_h

#include "regkey.h"
#include "utils.h"

#define MAX_TRAP_SIZE       4096
#define THRESHOLD_COUNT     500
#define THRESHOLD_TIME      300


// Values for the SNMP_EVENTS\Parameters\Threshold flag
#define THROTTLE_RESET 0
#define THROTTLE_TRIPPED 1

// Values for the SNMP_EVENTS\Parameters\ThresholdEnabled flag
#define THROTTLE_DISABLED 0
#define THROTTLE_ENABLED 1

//***************************************************************************
// REGISTRY KEYS
//
// The following strings are registry keys. They should not be internationalized,
// so they are not in the string table.
//
//****************************************************************************
#define SZ_REGKEY_MICROSOFT _T("SOFTWARE\\Microsoft")
#define SZ_REGKEY_SOURCE_EVENTLOG _T("SYSTEM\\CurrentControlSet\\Services\\EventLog")
#define SZ_REGKEY_SNMP_EVENTS  _T("SOFTWARE\\Microsoft\\SNMP_EVENTS")

// These are subkeys under \SOFTWARE\Microsoft\SNMP_EVENTS
#define SZ_REGKEY_EVENTLOG _T("EventLog")
#define SZ_REGKEY_SOURCES _T("EventLog\\Sources")
#define SZ_REGKEY_CURRENTLY_OPEN _T("CurrentlyOpen")

#define SZ_REGKEY_SOURCE_ENTERPRISE_OID _T("EnterpriseOID")
#define SZ_REGKEY_SOURCE_APPEND _T("Append")

#define SZ_REGKEY_PARAMETERS _T("EventLog\\Parameters")
#define SZ_REGKEY_PARAMS _T("Parameters")
#define SZ_REGKEY_PARAMS_BASE_ENTERPRISE_OID _T("BaseEnterpriseOID")
#define SZ_REGKEY_PARAMS_TRIMFLAG _T("TrimFlag")
#define SZ_REGKEY_PARAMS_MAXTRAP_SIZE _T("MaxTrapSize")
#define SZ_REGKEY_PARAMS_TRIM_MESSAGE _T("TrimMessage")
#define SZ_REGKEY_PARAMS_THRESHOLD _T("Threshold")
#define SZ_REGKEY_PARAMS_THRESHOLDENABLED _T("ThresholdEnabled")
#define SZ_REGKEY_PARAMS_THRESHOLDCOUNT _T("ThresholdCount")
#define SZ_REGKEY_PARAMS_THRESHOLDTIME _T("ThresholdTime")

#define SZ_REGKEY_EVENT_COUNT _T("Count")
#define SZ_REGKEY_EVENT_TIME _T("Time")
#define SZ_REGKEY_EVENT_FULLID _T("FullID")
#define SZ_REGKEY_SOURCE_EVENT_MESSAGE_FILE _T("EventMessageFile")
#define SZ_NAME_REGVAL_TRANSLATOR_ENABLED _T("TranslatorEnabled")
#define SZ_NAME_REGVAL_REVISIONCOUNT _T("RevisionCount")
#define SZ_NAME_REGVAL_CONFIGTYPE _T("ConfigurationType")

#define SZ_REGVAL_YES "YES"
#define SZ_REGVAL_NO "NO"

//**********************************************************************
// The number of load steps that are performed in CTrapDlg::OnInitDialog
// This is the number of steps that will be reserved in the progress
// indicator for OnInitDialog
//*********************************************************************
#define LOAD_STEPS_IN_TRAPDLG 5

// 11 setup steps plus 10 steps for the four known event logs
#define LOAD_SETUP_STEP_COUNT 11
#define LOAD_LOG_ARRAY_STEP_COUNT 40
#define LOAD_STEP_COUNT (LOAD_SETUP_STEP_COUNT + LOAD_LOG_ARRAY_STEP_COUNT + LOAD_STEPS_IN_TRAPDLG)

class CDlgSaveProgress;
class CRegistryKey;
class CXEventSource;
class CBaseArray : public CObArray
{
public:
    CBaseArray() {}
    ~CBaseArray() {}
    void DeleteAll();
};

class CXEventSource;
class CXEventLog;

//The registry is made up of logs, that contain sources, that contain events
class CXMessage : public CObject
{
public:
    CXMessage(CXEventSource* pEventSource);
    CXEventSource*  m_pEventSource;
    DWORD           m_dwId;
    CString         m_sText;

    CXMessage& operator=(CXMessage& message);
    DWORD GetShortId() {return LOWORD(m_dwId); }
    void GetShortId(CString& sText);
    void GetSeverity(CString& sSeverity);
    void IsTrapping(CString& sIsTrapping);
    void SetAndCleanText(PMESSAGE_RESOURCE_ENTRY pEntry);
};



class CXMessageArray : private CBaseArray
{
public:
    CXMessageArray();
    ~CXMessageArray() {}
    void Initialize(CXEventSource* pEventSource) {m_pEventSource = pEventSource; }
	CXMessage* GetAt(int nIndex) {return (CXMessage*) CBaseArray::GetAt(nIndex); }
	CXMessage* operator[](int nIndex) {return (CXMessage*) CBaseArray::GetAt(nIndex); }
	void Add(CXMessage* pMessage) { CBaseArray::Add(pMessage); }	
	void RemoveAll() {CBaseArray::RemoveAll(); }
	void DeleteAll() {CBaseArray::DeleteAll(); }
    LONG GetSize() {return (LONG)CBaseArray::GetSize(); }
    SCODE LoadMessages();

    CXMessage* FindMessage(DWORD dwId);
    CXEventSource*  m_pEventSource;

private:
    BOOL m_bDidLoadMessages;
    SCODE GetNextPath(CString& sPathlist, CString& sPath);
};


class CXEvent : public CObject
{
public:
    CXEvent(CXEventSource* pEventSource);
    CXEvent(CXMessage* pMessage);
    ~CXEvent();
    CXEventSource*  m_pEventSource;
    DWORD           m_dwCount;
    DWORD           m_dwTimeInterval;
    CXMessage       m_message;

    SCODE Deserialize(CRegistryKey& regkeyParent, CString& sName);
    SCODE Serialize(CRegistryKey& regkeyParent);

    void GetName(CString& sText) {DecString(sText, m_message.m_dwId); }
    void GetCount(CString& sText);
    void GetTimeInterval(CString& sText);
};


class CXEventArray : public CBaseArray
{
public:
    ~CXEventArray() {}
	CXEvent* GetAt(int nIndex) {return (CXEvent*) CBaseArray::GetAt(nIndex); }
	CXEvent* operator[](int nIndex) {return (CXEvent*) CBaseArray::GetAt(nIndex); }
//	void Add(CXEvent* pEvent) { CBaseArray::Add(pEvent); }	
	void Add(CXEvent* pEvent);
	void RemoveAll() {CBaseArray::RemoveAll(); }
	void DeleteAll() {CBaseArray::DeleteAll(); }
    LONG GetSize() {return (LONG)CBaseArray::GetSize(); }

    SCODE Deserialize(CXEventSource* pEventSource);
    SCODE Serialize(CRegistryKey& regkeyParent);

    CXEvent* FindEvent(DWORD dwId);
    SCODE RemoveEvent(CXEvent* pEvent);
};


class CXEventSource  : public CObject
{
public:
    CXEventSource(CXEventLog* pEventLog, CString& sName);
    ~CXEventSource();

    // Public data members
    CXEventLog*      m_pEventLog;
	CString 	     m_sName;
    CXEventArray     m_aEvents;
    CXMessageArray   m_aMessages;
    CString          m_sLibPath;

    CXMessage* FindMessage(DWORD dwId) {return m_aMessages.FindMessage(dwId); }
    CXEvent* FindEvent(DWORD dwId) {return m_aEvents.FindEvent(dwId); }
    CXEventSource* FindEventSource(CString& sEventSource);

    SCODE Deserialize(CRegistryKey& regkeyParent);
    SCODE Serialize(CRegistryKey& regkeyParent);
    void GetEnterpriseOID(CString& sEnterpriseOID, BOOL bGetFullID=FALSE);
    SCODE LoadMessages() {return m_aMessages.LoadMessages(); }

private:
    SCODE GetLibPath(CRegistryKey& regkey);
};

// CObArray is declared a private base type to ensure strong typing.
class CXEventSourceArray : private CBaseArray
{
public:
    // Base array functionality public member functions.
    ~CXEventSourceArray() {DeleteAll(); }
	CXEventSource* GetAt(int nIndex) {return (CXEventSource*) CBaseArray::GetAt(nIndex); }
	CXEventSource* operator[](int nIndex) {return (CXEventSource*) CBaseArray::GetAt(nIndex); }
	void Add(CXEventSource* pEventSource) { CBaseArray::Add(pEventSource); }	
	void RemoveAll() {CBaseArray::RemoveAll(); }
	void DeleteAll() {CBaseArray::DeleteAll(); }
    LONG GetSize() {return (LONG)CBaseArray::GetSize(); }


    // Public members specific to CXEventSourceArray
    CXEventSource* FindEventSource(CString& sSource);
    LONG FindEvent(CString& sLog, CString& sSource, DWORD dwEventId);


    SCODE Deserialize(CXEventLog* pEventLog);
    SCODE Serialize(CRegistryKey& regkey);
};




class CXEventLog : public CObject
{
public:
    CXEventLog(CString& sName) {m_sName = sName;}
    CXEventSourceArray m_aEventSources;
    CString m_sName;


    SCODE Deserialize();
    SCODE Serialize(CRegistryKey& regkey);
    CXEventSource* FindEventSource(CString& sEventSource);
};

inline CXEventSource* CXEventLog::FindEventSource(CString& sEventSource)
{
    return m_aEventSources.FindEventSource(sEventSource);
}


class CXEventLogArray : private CBaseArray
{
public:
    // Base array functionality public member functions.
    CXEventLogArray() {}
    ~CXEventLogArray() {DeleteAll(); }
	CXEventLog* GetAt(int nIndex) {return (CXEventLog*) CBaseArray::GetAt(nIndex); }
	CXEventLog* operator[](int nIndex) {return (CXEventLog*) CBaseArray::GetAt(nIndex); }
	void Add(CXEventLog* pEventLog) { CBaseArray::Add(pEventLog); }	
	void RemoveAll() {CBaseArray::RemoveAll(); }
	void DeleteAll() {CBaseArray::DeleteAll(); }
    LONG GetSize() {return (LONG)CBaseArray::GetSize(); }


    SCODE Deserialize();
    SCODE Serialize();

    CXEventSource* FindEventSource(CString& sLog, CString& sEventSource);
};



class CTraps
{
public:
    CXEventLogArray m_aEventLogs;
    SCODE Serialize();
    SCODE Deserialize();
};


class CTrapParams
{
public:
    CTrapParams();
    SCODE Serialize();
    SCODE Deserialize();
    SCODE ResetExtensionAgent();
    BOOL ThrottleIsTripped();

    CString m_sBaseEnterpriseOID;
    CString m_sSupportedView;
    CString m_sTracefileName;
    DWORD   m_dwTraceLevel;

    // Data members for the "limit" section of the settings dialog
    struct {
        BOOL    m_bTrimFlag;            // Limit trap length
        BOOL    m_bTrimMessages;        // Trim messages first
        DWORD   m_dwMaxTrapSize;        // Trap length (bytes)
    }m_trapsize;

    // Data members for the "throttle" section of the settings dialog
    struct {
        long m_nTraps;
        long m_nSeconds;
        BOOL m_bIsEnabled;
    }m_throttle;
};

class CTrapReg
{
public:
    CTrapReg();
    ~CTrapReg();
    SCODE Connect(LPCTSTR pszComputerName, BOOL bIsReconnecting = FALSE);
    SCODE Serialize();
    SCODE Deserialize();
    SCODE LockRegistry();
    void UnlockRegistry();
    SCODE SetConfigType(DWORD dwConfigType);
    DWORD GetConfigType() {return m_dwConfigType; }
    void SetApplyButton(CButton *pbtnApply) { m_pbtnApply = pbtnApply; }
    void SetDirty(BOOL bDirty);

    inline BOOL SourceHasTraps(CString& sSource);

    // Public data members.
    CRegistryKey m_regkeySource;        // SYSTEM\CurrentControlSet\Services\EventLogs
    CRegistryKey m_regkeySnmp;          // SOFTWARE\Microsoft\SNMP_EVENTS
    CRegistryKey m_regkeyEventLog;
    CXEventLogArray m_aEventLogs;
    CTrapParams m_params;
    CDlgSaveProgress* m_pdlgSaveProgress;
    CDlgSaveProgress* m_pdlgLoadProgress;
    LONG m_nLoadStepsPerSource;
    LONG m_nLoadStepsPerLog;
    LONG m_nLoadSteps;
    BOOL m_bShowConfigTypeBox;
    BOOL m_bRegIsReadOnly;
    BOOL m_bIsDirty;
    BOOL m_bSomeMessageWasNotFound;
    CString m_sComputerName;
    CButton *m_pbtnApply;

private:
    LONG GetSaveProgressStepCount();
    SCODE BuildSourceHasTrapsMap();
    BOOL m_bNeedToCloseKeys;
    CMapStringToPtr m_mapSourceHasTraps;
    BOOL m_bDidLockRegistry;
    DWORD m_dwConfigType;
};




extern CTrapReg g_trapreg;

enum {
    CONFIG_TYPE_DEFAULT = 0,
    CONFIG_TYPE_CUSTOM,
    CONFIG_TYPE_DEFAULT_PENDING
};


// Error failure values.
enum
{
    E_REGKEY_NOT_FOUND = -1000,
    E_REG_CANT_CONNECT,
    E_REGKEY_NOT_INSTALLED,
    E_REGKEY_CANT_OPEN,
    E_REGKEY_NO_CREATE,
    E_REG_NOT_INSTALLED,
    E_REGKEY_LOST_CONNECTION,
    E_ACCESS_DENIED,
    E_MESSAGE_NOT_FOUND


};

// Success status codes
enum
{
    S_NO_EVENTS = 1000,
    S_NO_SOURCES,
    S_SAVE_CANCELED,
    S_LOAD_CANCELED
};


//*******************************************************************
// CTrapReg::SourceHasTraps
//
// Check to see if traps have been configured for the specified event
// source.
//
// Parameters:
//      CString& sEventSource
//          The name of the event source.
//
// Returns:
//      TRUE if the event source has traps, FALSE otherwise.
//
//********************************************************************
inline BOOL CTrapReg::SourceHasTraps(CString& sEventSource)
{
    LPVOID pVoid;
	CString tmp(sEventSource);
	tmp.MakeUpper();
    return m_mapSourceHasTraps.Lookup(tmp, pVoid);
}


#endif //_trapreg_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\trapreg.cpp ===
//***********************************************************************
// trapreg.cpp
//
// This file contains the implementation of the classes for the objects
// that are read from the registry, manipulated and written back to the
// registry.
//
// Author: Larry A. French
//
// History:
//      20-Febuary-1996     Larry A. French
//          Totally rewrote it to fix the spagetti code and huge
//          methods.  The original author seemed to have little or
//          no ability to form meaningful abstractions.
//
//
// Copyright (C) 1995, 1996 Microsoft Corporation.  All rights reserved.
//
//************************************************************************
//
// Some of the interesting class implementations contained here are:
//
// CTrapReg
//      This is the container class for the registry information.  It is
//      composed of the configuration "parameters" and an EventLog array.
//
// CXEventLogArray
//      This class implements an array of CXEventLog objects, where the
//      event logs are "application", "security", "system" and so on.
//
// CXEventLog
//      This class implements a single event log.  All information
//      relevent to an event log can be accesssed through this class.
//
// CXEventSourceArray
//      Each event log contains an event source array.  The event source
//      represents an application that can generate an Event.
//
// CXEventSource
//      An eventsource represents an application that can generate some
//      number of event-log events.  The event source contains a CXEventArray
//      and CXMessageArray.  The CXEventArray contains all the events
//      that will be converted to traps.  The CXMessageArray contains all the
//      possible messages that a particular event source can generate.
//
// CXMessageArray
//      This class implements an array of CXMessage objects.
//
// CXMessage
//      This class contains all the information relevent to a message
//      that a message source can generate.
//
//
// CXEventArray
//      This class implements an array of CXEvent objects.
//
// CXEvent
//      This class represents an event that the user has selected to be
//      converted to a trap.  The event contains a message plus some
//      additional information.
//
//**************************************************************************
// The Registry:
//
// These classes are loaded from the registry and written back to the
// registry when the user clicks OK.  To understand the format of the
// registry, use the registry editor while looking though the "Serialize"
// and "Deserialize" member function for each of these classes.
//**************************************************************************


#include "stdafx.h"
#include "trapreg.h"
#include "regkey.h"
#include "busy.h"
#include "utils.h"
#include "globals.h"
#include "utils.h"
#include "dlgsavep.h"
#include "remote.h"

///////////////////////////////////////////////////////////////////
// Class: CBaseArray
//
// This class extends the CObArray class by adding the DeleteAll
// method.
//
//////////////////////////////////////////////////////////////////

//****************************************************************
// CBaseArray::DeleteAll
//
// Delete all the objects contained in this array.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//****************************************************************
void CBaseArray::DeleteAll()
{
    LONG nObjects = (LONG)GetSize();
    for (LONG iObject = nObjects-1; iObject >= 0; --iObject) {
        CObject* pObject = GetAt(iObject);
        delete pObject;
    }

    RemoveAll();
}


/////////////////////////////////////////////////////////////////////////////////////
// Class: CTrapReg
//
// This is the container class for all the registry information for eventrap.exe.
//
////////////////////////////////////////////////////////////////////////////////////
CTrapReg::CTrapReg() : m_pdlgLoadProgress(FALSE), m_pbtnApply(FALSE)
{
    m_bNeedToCloseKeys = FALSE;
    m_pdlgSaveProgress = NULL;
    m_pdlgLoadProgress = NULL;
    m_bDidLockRegistry = FALSE;
    m_bRegIsReadOnly = FALSE;
    SetDirty(FALSE);
    m_nLoadSteps = LOAD_STEPS_IN_TRAPDLG;

    m_bShowConfigTypeBox = TRUE;
    m_dwConfigType = CONFIG_TYPE_CUSTOM;
}

CTrapReg::~CTrapReg()
{
    delete m_pdlgSaveProgress;
    delete m_pdlgLoadProgress;


    if (!g_bLostConnection) {
        if (m_bDidLockRegistry) {
            UnlockRegistry();
        }

        if (m_bNeedToCloseKeys) {
            m_regkeySource.Close();
            m_regkeySnmp.Close();
            m_regkeyEventLog.Close();
        }
    }
}




//*********************************************************************************
// CTrapReg::SetConfigType
//
// Set the configuration type to CONFIG_TYPE_CUSTOM or CONFIG_TYPE_DEFAULT
// When the configuration type is changed, the change is reflected in the
// registry immediately so that the config tool can know whether or not it
// should update the event to trap configuration.
//
// Parameters:
//      DWORD dwConfigType
//          This parameter must be CONFIG_TYPE_CUSTOM or CONFIG_TYPE_DEFAULT.
//
// Returns:
//      SCODE
//          S_OK if the configuration type was set, otherwise E_FAIL.
//
//*********************************************************************************
SCODE CTrapReg::SetConfigType(DWORD dwConfigType)
{
    ASSERT(dwConfigType==CONFIG_TYPE_CUSTOM || dwConfigType==CONFIG_TYPE_DEFAULT_PENDING);
    if (dwConfigType != m_dwConfigType) {
        SetDirty(TRUE);
    }
    m_dwConfigType = dwConfigType;
    return S_OK;
}





//*********************************************************************************
// CTrapReg::LockRegistry
//
// Lock the registry to prevent two concurrent edits of the event-to-trap configuration
// information.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if the configuration information was already locked.
//          E_REGKEY_NO_CREATE if the "CurrentlyOpen" registry key can't
//          be created.
//
//**********************************************************************************
SCODE CTrapReg::LockRegistry()
{
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    CRegistryKey regkey;
    if (m_regkeyEventLog.GetSubKey(SZ_REGKEY_CURRENTLY_OPEN, regkey)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }

        if (AfxMessageBox(IDS_ERR_REGISTRY_BUSY, MB_YESNO | MB_ICONSTOP | MB_DEFBUTTON2) == IDNO)
        {
            regkey.Close();
            return E_FAIL;
        }
    }


    // Create the "CurrentlyOpen" key as a volatile key so that it will disappear the next
    // time the machine is restarted in the event that the application that locked the
    // event-to-trap configuration crashed before it could clear this lock.
    if (!m_regkeyEventLog.CreateSubKey(SZ_REGKEY_CURRENTLY_OPEN, regkey, NULL, NULL, TRUE)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }

        AfxMessageBox(IDS_WARNING_CANT_WRITE_CONFIG, MB_OK | MB_ICONSTOP);
        return E_REGKEY_NO_CREATE;
    }
    regkey.Close();
    m_bDidLockRegistry = TRUE;
    return S_OK;
}



//***********************************************************************
// CTrapReg::UnlockRegistry
//
// Unlock the event-to-trap configuration so that others can edit it.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//***********************************************************************
void CTrapReg::UnlockRegistry()
{
    m_regkeyEventLog.DeleteSubKey(SZ_REGKEY_CURRENTLY_OPEN);
}




 	

//***********************************************************************
// CTrapReg::Connect
//
// Connect to a registry.  The registry may exist on a remote computer.
//
// Parameters:
//      LPCTSTR pszComputerName
//          The computer who's registry you want to edit.  An empty string
//          specifies a request to connect to the local machine.
//
// Returns:
//      SCODE
//          S_OK if the connection was made.
//          E_FAIL if an error occurred.  In this event, the appropriate
//          error message boxes will have already been displayed.
//
//***********************************************************************
SCODE CTrapReg::Connect(LPCTSTR pszComputerName, BOOL bIsReconnecting)
{
    SCODE sc;

    g_bLostConnection = FALSE;

    if (pszComputerName) {
        m_sComputerName = pszComputerName;
    }

    // There are eight steps here, plus there are three initial steps in
    // CTrapReg::Deserialize.  After that the step count will be reset
    // and then stepped again for each log where each log will have
    // ten sub-steps.
    if (!bIsReconnecting) {
        m_pdlgLoadProgress->SetStepCount(LOAD_STEP_COUNT);
    }

    CRegistryValue regval;
    CRegistryKey regkeyEventLog;


    if (m_regkeySource.Connect(pszComputerName) != ERROR_SUCCESS) {
        if (m_regkeySource.m_lResult == ERROR_ACCESS_DENIED) {
            AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
            return E_ACCESS_DENIED;
        }
        goto CONNECT_FAILURE;
    }

    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }

    if (m_regkeySnmp.Connect(pszComputerName) != ERROR_SUCCESS) {
        if (m_regkeySnmp.m_lResult == ERROR_ACCESS_DENIED) {
            AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
            return E_ACCESS_DENIED;
        }
        goto CONNECT_FAILURE;
    }
    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }


    // SOFTWARE\\Microsoft\\SNMP_EVENTS
    if (m_regkeySnmp.Open(SZ_REGKEY_SNMP_EVENTS, KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY) != ERROR_SUCCESS) {
        if (m_regkeySnmp.Open(SZ_REGKEY_SNMP_EVENTS, KEY_READ) == ERROR_SUCCESS) {
            m_bRegIsReadOnly = TRUE;
        }
        else {
            // At this point we know the SNMP_EVENTS key could not be opened.  This
            // could either be because we don't have access to the registry or we
            // weren't installed yet. We now check to see if we can access the
            // registry at all.
            CRegistryKey regkeyMicrosoft;
            if (regkeyMicrosoft.Open(SZ_REGKEY_MICROSOFT, KEY_READ) == ERROR_SUCCESS) {
                regkeyMicrosoft.Close();
                AfxMessageBox(IDS_ERR_NOT_INSTALLED, MB_OK | MB_ICONSTOP);
            }
            else {
                // We couldn't even access SOFTWARE\Microsoft, so we know that
                // we don't have access to the registry.
                AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
                return E_ACCESS_DENIED;
            }
        }
        return E_FAIL;

    }
    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }


    //  SYSTEM\\CurrentControlSet\\Services\\EventLog
    if (m_regkeySource.Open(SZ_REGKEY_SOURCE_EVENTLOG, KEY_ENUMERATE_SUB_KEYS | KEY_READ | KEY_QUERY_VALUE ) != ERROR_SUCCESS) {
        m_regkeySnmp.Close();
        AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
        return E_ACCESS_DENIED;
    }

    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }



    if (!m_regkeySnmp.GetSubKey(SZ_REGKEY_EVENTLOG, m_regkeyEventLog)) {
        if (m_regkeySnmp.m_lResult == ERROR_ACCESS_DENIED) {
            AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
            sc = E_ACCESS_DENIED;
        }
        else {
            AfxMessageBox(IDS_WARNING_CANT_READ_CONFIG, MB_OK | MB_ICONSTOP);
            sc = E_REGKEY_NOT_FOUND;
        }
        m_regkeySnmp.Close();
        m_regkeySource.Close();
        return sc;
    }

    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }

    m_bNeedToCloseKeys = TRUE;

    sc = LockRegistry();

    if (FAILED(sc)) {
        if (sc == E_REGKEY_LOST_CONNECTION) {
            return sc;
        }
        else {
            return E_REGKEY_NO_CREATE;
        }
    }
    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }

    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }

    m_bShowConfigTypeBox = TRUE;

    if (FAILED(sc)) {
        if (sc == E_ACCESS_DENIED) {
            AfxMessageBox(IDS_ERR_REG_NO_ACCESS, MB_OK | MB_ICONSTOP);
            return E_ACCESS_DENIED;
        }
        else {
            goto CONNECT_FAILURE;
        }
    }
    if (!bIsReconnecting) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;
    }

    return S_OK;

CONNECT_FAILURE:
        CString sMessage;
        sMessage.LoadString(IDS_CANTCONNECT);
        if (pszComputerName != NULL) {
            sMessage += pszComputerName;
        }
        AfxMessageBox((LPCTSTR) sMessage, MB_OK | MB_ICONSTOP);
        return E_FAIL;
}


//****************************************************************************
// CTrapReg::BuildSourceHasTrapsMap
//
// This method fills the m_mapEventSources CMapStringToPtr object with the
// names of all the event sources that actually have events configured for them.
// When this map is used later, we only need to know whether or not a particular
// entry exists in the map, so the value associated with each entry is irrelevant.
//
// Why do we need m_mapEventSources?  The reason is that we need a quick way to
// determine whether or not a particular source has events configured for it.
// This is used when all the event sources are being enumerated and we need to know
// whether or not to load the messages for the event source (an expensive operation).
// If a particular event source has events configured for it, then we need to load
// the messages so that the message text can be displayed.  This is because the
// event configuration stored in the registry only contains the event id and not the
// message text.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful, otherwise E_FAIL.
//
//******************************************************************************
SCODE CTrapReg::BuildSourceHasTrapsMap()
{


    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.GetSubKey(SZ_REGKEY_SOURCES, regkey)) {
        // For a fresh installation, there is no source subkey.
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        return S_OK;
    }

    CStringArray* pasEventSources = regkey.EnumSubKeys();
    regkey.Close();

    if (pasEventSources == NULL) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        return S_OK;
    }

    CString sEventSource;
    LONG nEventSources = (LONG)pasEventSources->GetSize();
    for (LONG iEventSource = 0; iEventSource < nEventSources; ++iEventSource) {
        sEventSource = pasEventSources->GetAt(iEventSource);
		sEventSource.MakeUpper();
        m_mapSourceHasTraps.SetAt(sEventSource, NULL);
    }
    delete pasEventSources;
    return S_OK;
}


//**************************************************************************
// CTrapReg::Deserialize
//
// Read all the registry information (not including the event source messages) that
// is required by eventrap.exe into this object.  Reading the messages for most
// event sources is delayed until the user actually requests it by selecting
// an event source in the event source tree control.  If an event source has
// events that are being mapped into traps, then the messages for that event
// source are loaded because an event description in the registry does not contain
// the message text.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if a failure was detected. In the event of a failure, all
//          of the appropriate message boxes will have been displayed.
//
//***************************************************************************
SCODE CTrapReg::Deserialize()
{
    m_bSomeMessageWasNotFound = FALSE;
    SetDirty(FALSE);

    // Get the value for the configuration type.
    CRegistryValue regval;
    if (m_regkeyEventLog.GetValue(SZ_NAME_REGVAL_CONFIGTYPE, regval)) {
        m_dwConfigType = *(DWORD*)regval.m_pData;
    }
    else {
        if (g_bLostConnection) {
            AfxMessageBox(IDS_ERROR_NOT_RESPONDING);
            return E_REGKEY_LOST_CONNECTION;
        }

        // If the config type value doesn't exist, assume a custom configuration.
        // This can happen because the setup program doesn't necessarily create
        // this value.
        m_dwConfigType = CONFIG_TYPE_CUSTOM;
    }
    if (m_pdlgLoadProgress->StepProgress()) {
        return S_LOAD_CANCELED;
    }
    ++m_nLoadSteps;


    SCODE sc = BuildSourceHasTrapsMap();
    if (SUCCEEDED(sc)) {
        if (m_pdlgLoadProgress->StepProgress()) {
            return S_LOAD_CANCELED;
        }
        ++m_nLoadSteps;

        // Load the event log list, the current event list and so on.
        sc = m_params.Deserialize();
        if (sc == S_LOAD_CANCELED) {
            return sc;
        }

        if (SUCCEEDED(sc)) {
            if (m_pdlgLoadProgress->StepProgress()) {
                return S_LOAD_CANCELED;
            }
            ++m_nLoadSteps;

            sc = m_aEventLogs.Deserialize();
            if (sc == S_LOAD_CANCELED) {
                return sc;
            }

            if (SUCCEEDED(sc)) {
                if (m_nLoadSteps < LOAD_STEP_COUNT) {
                    if (m_pdlgLoadProgress->StepProgress(LOAD_STEP_COUNT - m_nLoadSteps)) {
                        return S_LOAD_CANCELED;
                    }
                }
            }
        }
    }


    if (FAILED(sc)) {
        if (sc == E_REGKEY_LOST_CONNECTION) {
            AfxMessageBox(IDS_ERROR_NOT_RESPONDING);
        }
        else {
            AfxMessageBox(IDS_WARNING_CANT_READ_CONFIG);
        }

    }
    return sc;
}



//**************************************************************************
// CTrapReg::GetSaveProgressStepCount
//
// Get the number of steps for the save progress dialog.  The number of steps
// is the number of events that will be written to SNMP_EVENTS\EventLog in
// the registry.
//
// Parameters:
//      None.
//
// Returns:
//      The number of steps to use for the save progress dialog.
//
//*************************************************************************
LONG CTrapReg::GetSaveProgressStepCount()
{
    LONG nSteps = 0;
    LONG nEventLogs = m_aEventLogs.GetSize();
    for (LONG iEventLog = 0; iEventLog < nEventLogs; ++iEventLog) {
        CXEventLog* pEventLog = m_aEventLogs[iEventLog];

        LONG nEventSources = pEventLog->m_aEventSources.GetSize();
        for (LONG iEventSource = 0; iEventSource < nEventSources; ++iEventSource) {
            CXEventSource* pEventSource = pEventLog->m_aEventSources.GetAt(iEventSource);
            nSteps += pEventSource->m_aEvents.GetSize();
        }
    }
    return nSteps;
}


//**************************************************************************
// CTrapReg::Serialize
//
// Write eventrap's current configuration out to the registry.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if a failure was detected.  In the event of a failure, all
//          of the appropriate message boxes will have been displayed.
//
//***************************************************************************
SCODE CTrapReg::Serialize()
{
    SCODE sc;
    if (g_bLostConnection) {
        sc = Connect(m_sComputerName, TRUE);
        if (FAILED(sc)) {
            if (g_bLostConnection) {
                AfxMessageBox(IDS_ERROR_NOT_RESPONDING);
                return E_REGKEY_LOST_CONNECTION;
            }
            return S_SAVE_CANCELED;
        }
    }

    if (!m_bIsDirty) {
        // The configuration state was not changed, so there is nothing to do.
        return S_OK;
    }

    LONG nProgressSteps = GetSaveProgressStepCount();
    if (nProgressSteps > 0) {
        m_pdlgSaveProgress = new CDlgSaveProgress;
        m_pdlgSaveProgress->Create(IDD_SAVE_PROGRESS);

        m_pdlgSaveProgress->SetStepCount( nProgressSteps );
    }

    CRegistryValue regval;
    regval.Set(SZ_NAME_REGVAL_CONFIGTYPE, REG_DWORD, sizeof(DWORD), (LPBYTE)&m_dwConfigType);
    if (!m_regkeyEventLog.SetValue(regval)) {
        if (g_bLostConnection) {
            AfxMessageBox(IDS_ERROR_NOT_RESPONDING);
            sc = E_REGKEY_LOST_CONNECTION;
        }
        else {
            AfxMessageBox(IDS_WARNING_CANT_WRITE_CONFIG);
            sc = S_SAVE_CANCELED;
        }
    }
    else {
        sc = m_aEventLogs.Serialize();
        if (sc != S_SAVE_CANCELED) {

            if (SUCCEEDED(sc)) {
                sc = m_params.Serialize();
            }

            if (sc != S_SAVE_CANCELED)
                SetDirty(FALSE);

            if (FAILED(sc)) {
                if (g_bLostConnection) {
                    AfxMessageBox(IDS_ERROR_NOT_RESPONDING);
                }
                else {
                    AfxMessageBox(IDS_WARNING_CANT_WRITE_CONFIG);
                }
            }
        }
    }

    delete m_pdlgSaveProgress;
    m_pdlgSaveProgress = NULL;
    return sc;
}


void CTrapReg::SetDirty(BOOL bDirty)
{
    m_bIsDirty = bDirty;
    if (m_pbtnApply)
    {
        m_pbtnApply->EnableWindow(m_bIsDirty);
    }
}


///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
// Class: CTrapParams
//
// This class represents the information stored in the
// SNMP_EVENTS\EventLog\Parameters registry key.
//
// Question:  Why is it that the horizontal space in the gap between
// the lines at the top of this header appears to be very irregular?
//////////////////////////////////////////////////////////////////


//****************************************************************
// CTrapParams::CTrapParams
//
// Constructor for CTrapParams.
//
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//****************************************************************
CTrapParams::CTrapParams()
{
    m_trapsize.m_bTrimFlag = TRUE;
    m_trapsize.m_dwMaxTrapSize = 4096;
    m_trapsize.m_bTrimMessages = FALSE;
}



//********************************************************************
// CTrapParams::Deserialize
//
// Read the contents of this CTrapParams object from the registry.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if there was a problem reading the required information
//          from the registry.
//********************************************************************
SCODE CTrapParams::Deserialize()
{
    CRegistryKey regkeyParams;
    if (!g_reg.m_regkeySnmp.GetSubKey(SZ_REGKEY_PARAMETERS, regkeyParams)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_REGKEY_NOT_FOUND;
        }
    }


    CRegistryValue regval;

    // !!!CR: There is no longer any reason to load the BASE OID
    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_BASE_ENTERPRISE_OID, regval))
        goto REGISTRY_FAILURE;
    m_sBaseEnterpriseOID = (LPCTSTR)regval.m_pData;

    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_TRIMFLAG, regval))
        m_trapsize.m_bTrimFlag = FALSE;
    else
        m_trapsize.m_bTrimFlag = (*(DWORD*)regval.m_pData == 1);

    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_MAXTRAP_SIZE, regval))
        m_trapsize.m_dwMaxTrapSize = MAX_TRAP_SIZE;
    else
        m_trapsize.m_dwMaxTrapSize = *(DWORD*)regval.m_pData;

    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_TRIM_MESSAGE, regval))
        m_trapsize.m_bTrimMessages = TRUE;
    else
        m_trapsize.m_bTrimMessages = (*(DWORD*)regval.m_pData) != 0;


    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_THRESHOLDENABLED, regval))
        m_throttle.m_bIsEnabled = TRUE;
    else
        m_throttle.m_bIsEnabled = (*(DWORD*)regval.m_pData) != THROTTLE_DISABLED;


    // Threshold trap count.
    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_THRESHOLDCOUNT, regval) ||
        *(DWORD*)regval.m_pData < 2)
        m_throttle.m_nTraps = THRESHOLD_COUNT;
    else
        m_throttle.m_nTraps = *(DWORD*)regval.m_pData;

    // Threshold time in seconds
    if (!regkeyParams.GetValue(SZ_REGKEY_PARAMS_THRESHOLDTIME, regval))
        m_throttle.m_nSeconds = THRESHOLD_TIME;
    else
        m_throttle.m_nSeconds = *(DWORD*)regval.m_pData;


    if (regkeyParams.Close() != ERROR_SUCCESS) {
        goto REGISTRY_FAILURE;
    }
    return S_OK;

REGISTRY_FAILURE:
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }
    else {
        return E_FAIL;
    }
}

//****************************************************************
// CTrapParams::Serialize
//
// Write SNMP_EVENTS\EventLog\Parameters information to the
// registry.
//
// Parameters:
//      None.
//
// Returns:
//      S_OK if everything went OK.
//      E_REGKEY_NOT_FOUND if an expected registry key was missing.
//*****************************************************************
SCODE CTrapParams::Serialize()
{
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }


    // Open the Parameters key.
    // Create simply opens the key if already present.
    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.CreateSubKey(SZ_REGKEY_PARAMETERS, regkey)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_REGKEY_NOT_FOUND;
        }
    }

    CRegistryValue regval;

    // Save the Message Length and the TrimMessage.
    DWORD dwTrim;
    if (m_trapsize.m_bTrimFlag)
        dwTrim = 1;
    else
        dwTrim = 0;
    regval.Set(SZ_REGKEY_PARAMS_TRIMFLAG, REG_DWORD, sizeof(DWORD), (LPBYTE)&dwTrim);
    regkey.SetValue(regval);
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    if (m_trapsize.m_bTrimFlag)
    {
        // Save the maximum trap size
        regval.Set(SZ_REGKEY_PARAMS_MAXTRAP_SIZE, REG_DWORD, sizeof(DWORD), (LPBYTE)&m_trapsize.m_dwMaxTrapSize);
        regkey.SetValue(regval);
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }


        // Save the trim message length
        DWORD dwTrimMessages = m_trapsize.m_bTrimMessages;
        regval.Set(SZ_REGKEY_PARAMS_TRIM_MESSAGE, REG_DWORD, sizeof(DWORD), (LPBYTE)&dwTrimMessages);
        regkey.SetValue(regval);
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
    }

    // Threshold enabled flag
    DWORD dwValue = (m_throttle.m_bIsEnabled ? THROTTLE_ENABLED : THROTTLE_DISABLED);
    regval.Set(SZ_REGKEY_PARAMS_THRESHOLDENABLED, REG_DWORD, sizeof(DWORD), (LPBYTE)&dwValue);
    regkey.SetValue(regval);
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    // If throttle is not enabled, do not write the ThresholdCount and ThresholdTime parameters
    if (m_throttle.m_bIsEnabled)
    {
        // Threshold trap count.
        regval.Set(SZ_REGKEY_PARAMS_THRESHOLDCOUNT, REG_DWORD, sizeof(DWORD), (LPBYTE)&m_throttle.m_nTraps);
        regkey.SetValue(regval);
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }

        // Threshold time in seconds
        regval.Set(SZ_REGKEY_PARAMS_THRESHOLDTIME, REG_DWORD, sizeof(DWORD), (LPBYTE)&m_throttle.m_nSeconds);
        regkey.SetValue(regval);
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
    }

    regkey.Close();
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }
    return S_OK;
}




//*******************************************************************
// CTrapParams::ResetExtensionAgent
//
// Reset the extension agent.  This is done by setting the "Threshold"
// parameter to zero in the registry.  The extension agent monitors this
// value and will reset itself when a zero is written there.
//
// The user may want to reset the extension agent if its throttle limit
// has been tripped.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.  E_FAIL if the extension agent could not
//          be reset.  If a failure occurs, the appropriate message box
//          is displayed.
//
//*********************************************************************
SCODE CTrapParams::ResetExtensionAgent()
{
    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.GetSubKey(SZ_REGKEY_PARAMETERS, regkey)) {
        return E_REGKEY_NOT_FOUND;
    }
    CRegistryValue regval;

    // Set the "Threshold" value under the Parameters key to zero to reset
    // the extension agent.
    DWORD dwValue = THROTTLE_RESET;
    SCODE sc = S_OK;
    regval.Set(SZ_REGKEY_PARAMS_THRESHOLD, REG_DWORD, sizeof(DWORD), (LPBYTE)&dwValue);
    if (!regkey.SetValue(regval)) {
        AfxMessageBox(IDS_WARNING_CANT_WRITE_CONFIG);
        sc = E_FAIL;
    }

    regkey.Close();
    return sc;
}

//***********************************************************************
// CTrapParams::ThrottleIsTripped
//
// Check the registry to determine whether or not the extension agent
// throttle was tripped.
//
// Parameters:
//      None.
//
// Returns:
//      TRUE if the extension agent's throttle was tripped, FALSE otherwise.
//
//************************************************************************
BOOL CTrapParams::ThrottleIsTripped()
{
    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.GetSubKey(SZ_REGKEY_PARAMETERS, regkey)) {
        return FALSE;
    }
    CRegistryValue regval;

    // SNMP_EVENTS\Parameters\Threshold value
    BOOL bThrottleIsTripped = FALSE;
    if (regkey.GetValue(SZ_REGKEY_PARAMS_THRESHOLD, regval)) {
        if (*(DWORD*)regval.m_pData == THROTTLE_TRIPPED) {
            bThrottleIsTripped = TRUE;
        }
    }

    regkey.Close();
    return bThrottleIsTripped;
}


///////////////////////////////////////////////////////////////////
// Class: CXEventLogArray
//
// This class implements an array of CXEventLog objects.
//
//////////////////////////////////////////////////////////////////


//****************************************************************
// CXEventLogArray::Deserialize
//
// Examine the registry find all the event logs and load all the
// relevent information for all the event logs into this array.
//
// Parameters:
//      None.
//
// Returns:
//      S_OK if successful.
//      E_FAIL if a failure was detected.
//
//****************************************************************
SCODE CXEventLogArray::Deserialize()
{
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    CStringArray* pasEventLogs = g_reg.m_regkeySource.EnumSubKeys();
    // Prefix bug 445192
    if (pasEventLogs == NULL)
        return E_FAIL;
    SCODE sc = S_OK;

    // Iterate through all the event log names and create each log.
	LONG nEventLogs = (LONG)pasEventLogs->GetSize();
    if (nEventLogs > 0) {
        g_reg.m_nLoadStepsPerLog = LOAD_LOG_ARRAY_STEP_COUNT / nEventLogs;
    }
    LONG nUnusedSteps = LOAD_LOG_ARRAY_STEP_COUNT -  (nEventLogs * g_reg.m_nLoadStepsPerLog);

    for (LONG iEventLog=0; iEventLog < nEventLogs; ++iEventLog)
    {
        CString sEventLog = pasEventLogs->GetAt(iEventLog);
        CXEventLog* pEventLog = new CXEventLog(sEventLog);
        sc = pEventLog->Deserialize();
        if ((sc==S_LOAD_CANCELED) || FAILED(sc)) {
            delete pEventLog;
            break;
        }
        else if (sc == S_NO_SOURCES) {
            delete pEventLog;
            sc = S_OK;
        }
        else {
            Add(pEventLog);
        }
    }
    delete pasEventLogs;
    if (g_reg.m_pdlgLoadProgress->StepProgress(nUnusedSteps)) {
        sc = S_LOAD_CANCELED;
    }

    return sc;
}


//****************************************************************
// CXEventLogArray::Serialize
//
// Write the current configuration of all the EventLogs out to the
// registry.  Only those logs and sources that actually have events
// are written.
//
// Parameters:
//      None.
//
// Returns:
//      S_OK if successful.
//      E_FAIL if a failure was detected.
//
//****************************************************************
SCODE CXEventLogArray::Serialize()
{
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    // This is where the eventlog stuff should be cleaned up.

    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.CreateSubKey(SZ_REGKEY_EVENTLOG, regkey)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_REGKEY_NOT_FOUND;
        }
    }
    regkey.Close();


    if (!g_reg.m_regkeySnmp.CreateSubKey(SZ_REGKEY_SOURCES, regkey)) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_REGKEY_NOT_FOUND;
        }
    }

    // Delete the keys for the sources and events for which we no longer
    // trap. I'm going to be lazy and just delete them all.
    // !!!CR: It could potentially save a lot of time if this was made smarter
    // !!!CR: so that it only replaced items that had been deleted.
    LONG nEventSources, iEventSource;
    CStringArray* pasEventSources = regkey.EnumSubKeys();
    nEventSources = (LONG)pasEventSources->GetSize();
    for (iEventSource=0; iEventSource<nEventSources; iEventSource++)
    {
        CString sSource;
        sSource = pasEventSources->GetAt(iEventSource);
        regkey.DeleteSubKey(sSource);
    }
    delete pasEventSources;


    SCODE sc = S_OK;
    LONG nEventLogs = GetSize();
    for (LONG iEventLog = 0; iEventLog < nEventLogs; ++iEventLog) {
        sc = GetAt(iEventLog)->Serialize(regkey);
        if (sc == S_SAVE_CANCELED) {
            break;
        }
        else if (g_bLostConnection) {
            sc = E_REGKEY_LOST_CONNECTION;
            break;
        }
    }
    regkey.Close();

    return sc;
}



//****************************************************************
// CXEventLogArray::FindEventSource
//
// Given the name of an event log and the name of the event source
// within the event log, return a pointer to the requested CXEventSource.
//
// Parameters:
//      CString& sLog
//          The name of the event log.
//
//      CString& sEventSource
//          The name of the event source.
//
// Returns:
//      CXEventSource*
//          A pointer to the requested event source if it was found.  NULL
//          if no such event source exists.
//
//****************************************************************
CXEventSource* CXEventLogArray::FindEventSource(CString& sLog, CString& sEventSource)
{
    LONG nLogs = GetSize();
    for (LONG iLog = 0; iLog < nLogs; ++iLog) {
        CXEventLog* pEventLog = GetAt(iLog);
        if (pEventLog->m_sName.CompareNoCase(sLog) == 0) {
            return pEventLog->FindEventSource(sEventSource);
        }
    }
    return NULL;
}





///////////////////////////////////////////////////////////////////
// Class: CXEventLog
//
// This class contains all the information for a particular event log.
//
//////////////////////////////////////////////////////////////////


//************************************************************************
// CXEventLog::Deserialize
//
// Load the contents of this EventLog object from the registry.
//
// Parameters:
//      g_reg is a global parameter.
//
// Returns:
//      SCODE
//          S_OK or S_NO_SOURCES if successful.  E_FAIL if there was
//          a failure of any kind.
//
//************************************************************************
SCODE CXEventLog::Deserialize()
{
    return m_aEventSources.Deserialize(this);
}


//************************************************************************
// CXEventLog::Serialize
//
// Write the current configuration for this log to the registry.
//
// Parameters:
//      CRegistryKey& regkey
//          This registry key points to SOFTWARE\Microsoft\SNMP_EVENTS\EventLog
//
// Returns:
//      SCODE
//          S_OK or S_SAVE_CANCELED if successful.  E_FAIL for an error condition.
//          a failure of any kind.
//
//************************************************************************
SCODE CXEventLog::Serialize(CRegistryKey& regkey)
{
    return m_aEventSources.Serialize(regkey);
}







///////////////////////////////////////////////////////////////////
// Class: CXEventSourceArray
//
// This class implements an array of CXEventSource pointers and
// related methods.
//
//////////////////////////////////////////////////////////////////



//*************************************************************************
// CXEventSourceArray::Deserialize
//
// Load all the information pertaining to the event sources associated with
// the given event log.  This information is loaded from the registry.
//
// Parameters:
//      CXEventLog* pEventLog
//          Pointer to the event log.  The sources associated with this
//          event log are loaded into this object.
//
// Returns:
//      SCODE
//          S_OK or S_NO_SOURCES if successful.  E_FAIL if there was
//          a failure of any kind.
//*************************************************************************
SCODE CXEventSourceArray::Deserialize(CXEventLog* pEventLog)
{

	// Get the registry entry for this log.  This registry key will be
	// used to enumerate the event sources for this log.
    CRegistryKey regkey;
    if (!g_reg.m_regkeySource.GetSubKey(pEventLog->m_sName, regkey)) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerLog)) {
            return S_LOAD_CANCELED;
        }
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_FAIL;
        }
    }


    SCODE sc = S_OK;

	// Enumerate the event sources for this log.
    CStringArray* pasSources = regkey.EnumSubKeys();
    if (pasSources == NULL) {
        regkey.Close();
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerLog)) {
            return S_LOAD_CANCELED;
        }
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_FAIL;
        }
    }


	// Iterate though all the event sources and add them as a sub-item
	// under the log.
	LONG nEventSources = (LONG)pasSources->GetSize();
    LONG nScaledStepSize = 0;
    g_reg.m_nLoadStepsPerSource = 0;
    if (nEventSources > 0) {
        nScaledStepSize = (g_reg.m_nLoadStepsPerLog * 1000) / nEventSources;
        g_reg.m_nLoadStepsPerSource = g_reg.m_nLoadStepsPerLog / nEventSources;
    }
    LONG nLoadSteps = 0;
    LONG nProgress = 0;


    // Set the load progress step count.  Since we don't know how many events are saved
    // for each event source, we will assume some small number for LOAD_STEPS_FOR_SOURCE
    // and divide the actual number of steps up as evenly as possible once we know the actual
    // event count.
    for (LONG iEventSource=0; iEventSource< nEventSources; ++iEventSource)
    {
        nProgress += nScaledStepSize;
        g_reg.m_nLoadStepsPerSource = nProgress / 1000;
        if (g_reg.m_nLoadStepsPerSource > 0) {
            nProgress -= g_reg.m_nLoadStepsPerSource * 1000;
            nLoadSteps += g_reg.m_nLoadStepsPerSource;
        }

        CString sEventSource = pasSources->GetAt(iEventSource);
        CXEventSource* pEventSource = new CXEventSource(pEventLog, sEventSource);
        sc = pEventSource->Deserialize(regkey);
        if ((sc==S_LOAD_CANCELED) || FAILED(sc)) {
            delete pEventSource;
            break;
        }
        else if (sc == S_NO_EVENTS) {
            // If there are no events, then this is not a valid event source.
            delete pEventSource;
            sc = S_OK;
        }
        else {
            Add(pEventSource);
        }
    }
	delete pasSources;
    if (SUCCEEDED(sc)) {
        // We only close the registry key if we succeeded to avoid hanging if we loose
        // a remote connection.
        regkey.Close();
        if (GetSize() == 0) {
            sc = S_NO_SOURCES;
        }
    }
    if (nLoadSteps < g_reg.m_nLoadStepsPerLog) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerLog - nLoadSteps)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerLog - nLoadSteps;
    }
    return sc;
}


//************************************************************************
// CXEventSourceArray::Serialize
//
// Write the current configuration for this event source array to the registry.
//
// Parameters:
//      CRegistryKey& regkey
//          This registry key points to SOFTWARE\Microsoft\SNMP_EVENTS\EventLog\Sources
//
// Returns:
//      SCODE
//          S_OK or S_SAVE_CANCELED if successful.  E_FAIL for an error condition.
//          a failure of any kind.
//
//************************************************************************
SCODE CXEventSourceArray::Serialize(CRegistryKey& regkey)
{
    // Write the subkeys under SNMP_EVENTS\EventLog
    SCODE sc = S_OK;
    LONG nEventSources = GetSize();
    for (LONG iEventSource = 0; iEventSource < nEventSources; ++iEventSource) {
        SCODE scTemp = GetAt(iEventSource)->Serialize(regkey);
        if (g_bLostConnection) {
            sc = E_REGKEY_LOST_CONNECTION;
            break;
        }
        if (FAILED(scTemp)) {
            sc = E_FAIL;
            break;
        }
        if (scTemp == S_SAVE_CANCELED) {
            sc = S_SAVE_CANCELED;
            break;
        }
    }
    return sc;
}


//************************************************************************
// CXEventSourceArray::FindEventSource
//
// Given an event source name, find the specified event source in this
// event source array.
//
// Parameters:
//      CString& sEventSource
//          The name of the event source to search for.
//
// Returns:
//      CXEventSource*
//          Pointer to the event source if it is found, otherwise NULL.
//
//***********************************************************************
CXEventSource* CXEventSourceArray::FindEventSource(CString& sEventSource)
{
    LONG nSources = GetSize();
    for (LONG iSource = 0; iSource < nSources; ++iSource) {
        CXEventSource* pEventSource = GetAt(iSource);
        if (pEventSource->m_sName.CompareNoCase(sEventSource)==0) {
            return pEventSource;
        }
    }
    return NULL;
}


///////////////////////////////////////////////////////////////////
// Class: CXEventSource
//
// This class implements an an event source object.  An event source
// corresponds to an application that can generate events.  The
// event sources are enumerated from the registry in
// "SYSTEM\CurrentControlSet\Services\EventLogs" under each particular
// eventlog found there.
//
// An event source has an array of messages and an array of events
// associated with it.
//
// The message array comes from the message .DLL file(s) pointed to by
// the "EventMessageFile" value attached to the source's key in the registry.
// The message array is read-only in the sense that it is loaded from the
// registry and never written back to it.
//
// The event array comes from SNMP_EVENTS\EventLog\<source-subkey>.  These
// events are loaded when the configuration program starts up and written
// back out when the user clicks "OK".  Note that the events stored in the
// registry contain the event ID, but not the message text.  The message text
// for an event is found by searching the message array in the CXEventSource
// object for the event's ID.
//
//////////////////////////////////////////////////////////////////

//*************************************************************************
// CXEventSource::CXEventSource
//
// Construct the CXEventSource object.
//
// Parameters:
//      CXEventLog* pEventLog
//          Pointer to the event log that contains this event source.
//
//      CString& sName
//          The name of this event source.
//
// Returns:
//      Nothing.
//
//*************************************************************************
CXEventSource::CXEventSource(CXEventLog* pEventLog, CString& sName)
{
    m_pEventLog = pEventLog;
    m_sName = sName;
    m_aMessages.Initialize(this);
}




//************************************************************************
// CXEventSource::~CXEventSource
//
// Destroy thus event source object.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//************************************************************************
CXEventSource::~CXEventSource()
{
    // We must explicitly delete the contents of the event array and message
    // array.  Note that this is different behavior from the CXEventLogArray
    // and CXEventSourceArray.  This is because it was useful to create
    // message and event arrays as temporary containers for a set of pointers.
    // Thus, there were situations where you did not want to delete the
    // objects contained in these arrays when the arrays were destroyed.
    m_aEvents.DeleteAll();
    m_aMessages.DeleteAll();
}


//**********************************************************************
// CXEventSource::Deserialize
//
// Load this event source from the registry given the registry key
// for the event log that contains this source.
//
// Parameters:
//      CRegistryKey& regkeyLog
//          An open registry key for the event log containing this
//          event source.  This key points to somewhere in
//          SYSTEM\CurrentControlSet\Services\EventLog
//
// Returns:
//      SCODE
//          S_OK = the source has events and no errors were encountered.
//          S_NO_EVENTS = the source has no events and no errors were encountered.
//          E_FAIL = an condition was encountered.
//
//***********************************************************************
SCODE CXEventSource::Deserialize(CRegistryKey& regkeyLog)
{
    CRegistryKey regkeySource;
    if (!regkeyLog.GetSubKey(m_sName, regkeySource)) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource;
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }
        else {
            return E_FAIL;
        }
    }

    SCODE sc = E_FAIL;
    if (SUCCEEDED(GetLibPath(regkeySource))) {
        sc = m_aEvents.Deserialize(this);
    }
    else {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }

        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource;
        sc = S_NO_EVENTS;
    }


    regkeySource.Close();
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    // Delay deserializing the messages for this source until they are
    // needed.
    return sc;
}


#if 0
//*************************************************************************
// CXEventSource::GetLibPath
//
// Get the path the the EventMessageFile for this event source.
//
// Parameters:
//      CRegistryKey& regkeySource
//          An open registry key corresponding to this source in
//          SYSTEM\CurrentControlSet\Services\EventLog\<event log>
//
// Returns:
//      SCODE
//          S_OK if successful, otherwise E_FAIL.
//
//*************************************************************************
SCODE CXEventSource::GetLibPath(CRegistryKey& regkeySource)
{
    CRegistryValue regval;
    if (!regkeySource.GetValue(SZ_REGKEY_SOURCE_EVENT_MESSAGE_FILE, regval))
        return E_FAIL;

	TCHAR szLibPath[MAX_STRING];
    if (ExpandEnvironmentStrings((LPCTSTR)regval.m_pData, szLibPath, sizeof(szLibPath)) == 0)
        return E_FAIL;

    m_sLibPath = szLibPath;
    return S_OK;
}
#else
//*************************************************************************
// CXEventSource::GetLibPath
//
// Get the path the the EventMessageFile for this event source.
//
// Parameters:
//      CRegistryKey& regkeySource
//          An open registry key corresponding to this source in
//          SYSTEM\CurrentControlSet\Services\EventLog\<event log>
//
// Returns:
//      SCODE
//          S_OK if successful, otherwise E_FAIL.
//
//*************************************************************************
SCODE CXEventSource::GetLibPath(CRegistryKey& regkeySource)
{
    static CEnvCache cache;



    CRegistryValue regval;
    if (!regkeySource.GetValue(SZ_REGKEY_SOURCE_EVENT_MESSAGE_FILE, regval))
        return E_FAIL;

    SCODE sc = S_OK;
    if (g_reg.m_sComputerName.IsEmpty()) {
        // Editing the local computer computer's registry, so the local environment
        // variables are in effect.

    	TCHAR szLibPath[MAX_STRING];
        if (ExpandEnvironmentStrings((LPCTSTR)regval.m_pData, szLibPath, sizeof(szLibPath)/sizeof(szLibPath[0])))  {
            m_sLibPath = szLibPath;
        }
        else {
            sc = E_FAIL;
        }
    }
    else {
        // Editing a remote computer's registry, so the remote environment strings are in
        // effect.  Also, file paths must be mapped to the UNC path for the machine.  For
        // example, C:Foo will be mapped to \\Machine\C$\Foo
        m_sLibPath = regval.m_pData;
        sc = RemoteExpandEnvStrings(g_reg.m_sComputerName, cache, m_sLibPath);
        if (SUCCEEDED(sc)) {
            sc = MapPathToUNC(g_reg.m_sComputerName, m_sLibPath);
        }
    }

    return S_OK;
}

#endif



//************************************************************************
// CXEventSource::Serialize
//
// Write the configuration information for this event source to the registry.
//
// Parameters:
//      CRegistryKey& regkeyParent
//          An open registry key pointing to SNMP_EVENTS\EventLog\Sources
//
// Returns:
//      SCODE
//          S_OK if successful.
//          S_SAVE_CANCELED if no errors, but the user canceled the save.
//
//************************************************************************
SCODE CXEventSource::Serialize(CRegistryKey& regkeyParent)
{
    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }

    SCODE sc = S_OK;
    if (m_aEvents.GetSize() > 0) {
        CRegistryKey regkey;
        if (!regkeyParent.CreateSubKey(m_sName, regkey)) {
            if (g_bLostConnection) {
                return E_REGKEY_LOST_CONNECTION;
            }
            else {
                return E_REGKEY_NOT_FOUND;
            }
        }

        CString sEnterpriseOID;
        GetEnterpriseOID(sEnterpriseOID);
        CRegistryValue regval;


        regval.Set(SZ_REGKEY_SOURCE_ENTERPRISE_OID,
                   REG_SZ, (sEnterpriseOID.GetLength() + 1) * sizeof(TCHAR),
                   (LPBYTE)(LPCTSTR)sEnterpriseOID);
        regkey.SetValue(regval);


        DWORD dwAppend = 1;
        regval.Set(SZ_REGKEY_SOURCE_APPEND, REG_DWORD, sizeof(DWORD), (LPBYTE) &dwAppend);
        regkey.SetValue(regval);

        sc = m_aEvents.Serialize(regkey);
        regkey.Close();
    }

    if (g_bLostConnection) {
        return E_REGKEY_LOST_CONNECTION;
    }
    return sc;
}


//*******************************************************************
// CXEventSource::GetEnterpriseOID
//
// Get the enterprise OID for this event source.  The enterprise OID
// is composed of a prefix and suffix string concatenated together.  The
// prefix string is an ASCII decimal value for the length of the suffix
// string.  The suffix string is composed by separating each character of
// the name of this source by a "." character.
//
// Parameters:
//      CString& sEnterpriseOID
//          A reference to the string where the enterprise OID for this
//          source will be returned.
//
// Returns:
//      The enterprise OID in via the sEnterpriseOID reference.
//
//********************************************************************
void CXEventSource::GetEnterpriseOID(CString& sEnterpriseOID, BOOL bGetFullID)
{
    CString sValue;


    // Form the prefix string in sEnterpriseOID and compute the length
    // of the prefix and suffix strings.
    DecString(sValue, m_sName.GetLength());
    if (bGetFullID) {
        sEnterpriseOID = g_reg.m_params.m_sBaseEnterpriseOID + _T('.') + sValue;
    }
    else {
        sEnterpriseOID = sValue;
    }

    // Append the suffix string to the prefix string by getting a pointer to
    // the sEnterpriseOID buffer and allocating enough space to hold the
    // combined strings.
    LPCTSTR pszSrc = m_sName;

    // Append the suffix by copying it to the destination buffer and inserting the
    // "." separator characters as we go.
    LONG iCh;
    while (iCh = *pszSrc++) {
        switch(sizeof(TCHAR)) {
        case 1:
            iCh &= 0x0ff;
            break;
        case 2:
            iCh &= 0x0ffffL;
            break;
        default:
            ASSERT(FALSE);
            break;
        }

        DecString(sValue, iCh);
        sEnterpriseOID += _T('.');
        sEnterpriseOID += sValue;
    }
}






///////////////////////////////////////////////////////////////////
// Class: CXEventArray
//
// This class implements an array of pointers to CXEvent objects.
// The events contained in this array correspond to the events that
// the user has configured in the main dialog.  Don't confuse events
// with messages.  Events are the subset of the messages that the
// user has selected to be translated into traps.
//
// For further information on how this CXEventArray fits into the
// scheme of things, please see the CXEventSource class header.
//////////////////////////////////////////////////////////////////


//************************************************************************
// CXEventArray::Deserialize
//
// Read an array of events from the registry for the given
// source.
//
// Parameters:
//      CXEventSource* pEventSource
//          Pointer to the event source who's events should be read.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if an error occurs.
//
//************************************************************************
SCODE CXEventArray::Deserialize(CXEventSource* pEventSource)
{
    if (!g_reg.SourceHasTraps(pEventSource->m_sName)) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource;
        return S_OK;
    }

    // Control comes here if we know that there are events configured
    // for the event source that this event array is part of.  We now
    // need to load the events for this source by enumerating them
    // from SNMP_EVENTS\EventLog\<event source>

    CString sKey;
    sKey = sKey + SZ_REGKEY_SOURCES + _T("\\") + pEventSource->m_sName;
    CRegistryKey regkey;
    if (!g_reg.m_regkeySnmp.GetSubKey(sKey, regkey)) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource;
        return S_OK;
    }


	// Enumerate the events for this source
    CStringArray* pasEvents = regkey.EnumSubKeys();
    if (pasEvents == NULL) {
        if (g_bLostConnection) {
            return E_REGKEY_LOST_CONNECTION;
        }

        regkey.Close();
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource;

        return E_FAIL;
    }



	// Iterate though all the events and add them as a sub-item
	// under the event source.
	LONG nEvents = (LONG)pasEvents->GetSize();
    LONG nStepsDone = 0;
    LONG nEventsPerStep = 0;
    if (g_reg.m_nLoadStepsPerSource > 0) {
        nEventsPerStep = nEvents / g_reg.m_nLoadStepsPerSource;
    }

    for (LONG iEvent=0; iEvent< nEvents; ++iEvent)
    {
        CString sEvent = pasEvents->GetAt(iEvent);
        CXEvent* pEvent = new CXEvent(pEventSource);
        SCODE sc = pEvent->Deserialize(regkey, sEvent);
        if (sc == E_MESSAGE_NOT_FOUND) {
            delete pEvent;
            if (!g_reg.m_bSomeMessageWasNotFound) {
                AfxMessageBox(IDS_ERR_MESSAGE_NOT_FOUND, MB_OK | MB_ICONEXCLAMATION);
                g_reg.m_bSomeMessageWasNotFound = TRUE;
                g_reg.SetDirty(TRUE);
            }

            continue;
        }


        if ((sc == S_LOAD_CANCELED) || FAILED(sc) ) {
            delete pEvent;
            delete pasEvents;
            return sc;
        }

        if (nEventsPerStep > 0) {
            if ((iEvent % nEventsPerStep) == (nEventsPerStep - 1)) {
                if (g_reg.m_pdlgLoadProgress->StepProgress()) {
                    delete pasEvents;
                    return S_LOAD_CANCELED;
                }
                ++g_reg.m_nLoadSteps;
                ++nStepsDone;
            }
        }
    }
	delete pasEvents;
    regkey.Close();
    if (nStepsDone < g_reg.m_nLoadStepsPerSource) {
        if (g_reg.m_pdlgLoadProgress->StepProgress(g_reg.m_nLoadStepsPerSource - nStepsDone)) {
            return S_LOAD_CANCELED;
        }
        g_reg.m_nLoadSteps += g_reg.m_nLoadStepsPerSource - nStepsDone;
    }
    return S_OK;
}


//************************************************************************
// CXEventArray::Serialize
//
// Write the current configuration for the events contained in this array
// out to the registry.
//
// Parameters:
//      CRegistryKey& regkeyParent
//          An open registry key for the source that owns these events.
//          The source key is located in SNMP_EVENTS\EventLogs\<source-key>
//
// Returns:
//      SCODE
//          S_OK = All events saved without errors.
//          S_SAVE_CANCELED = No errors, but the user canceled the save.
//          E_FAIL = An error occurs.
//
//************************************************************************
SCODE CXEventArray::Serialize(CRegistryKey& regkeyParent)
{
    SCODE sc = S_OK;
    LONG nEvents = GetSize();
    for (LONG iEvent = 0; iEvent < nEvents; ++iEvent) {
        SCODE scTemp = GetAt(iEvent)->Serialize(regkeyParent);
        if (scTemp == S_SAVE_CANCELED) {
            sc = S_SAVE_CANCELED;
            break;
        }

        if (FAILED(scTemp)) {
            if (g_bLostConnection) {
                sc = E_REGKEY_LOST_CONNECTION;
            }
            else {
                sc = E_FAIL;
            }
            break;
        }
    }
    return sc;
}


//***********************************************************************
// CXEventArray::Add
//
// Add an event pointer to this array.  Note that there is no assumption
// that the array owns the pointer.  Someone must explicitly call the DeleteAll
// member to delete the pointers stored in this array.
//
// Parameters:
//      CXEvent* pEvent
//          Pointer to the event to add to this array.
//
// Returns:
//      Nothing.
//
//***********************************************************************
void CXEventArray::Add(CXEvent* pEvent)
{
    CBaseArray::Add(pEvent);
}	



//***********************************************************************
// CXEventArray::FindEvent
//
// Given an event id, find the corresponding event in this array.
//
// Note that this array should never contain duplicate events.
//
// Parameters:
//      DWORD dwId
//          The event ID.
//
// Returns:
//      CXEvent*
//          A pointer to the desired event.  NULL if the event was
//          not found.
//
//***********************************************************************
CXEvent* CXEventArray::FindEvent(DWORD dwId)
{
    LONG nEvents = GetSize();
    for (LONG iEvent=0; iEvent < nEvents; ++iEvent) {
        CXEvent* pEvent = GetAt(iEvent);
        if (pEvent->m_message.m_dwId == dwId) {
            return pEvent;
        }
    }
    return NULL;
}



//***********************************************************************
// CXEventArray::FindEvent
//
// Given an event pointer, remove the event from this array.
//
// Parameters:
//      CXEvent* pEventRemove
//          A pointer to the event to remove.
//
// Returns:
//      SCODE
//          S_OK if the event was removed.
//          E_FAIL if the event was not found in this array.
//
//***********************************************************************
SCODE CXEventArray::RemoveEvent(CXEvent* pEventRemove)
{
    // Iterate through the event array to search for the specified event.
    LONG nEvents = GetSize();
    for (LONG iEvent=0; iEvent < nEvents; ++iEvent) {
        CXEvent* pEvent = GetAt(iEvent);
        if (pEvent == pEventRemove) {
            RemoveAt(iEvent);
            return S_OK;
        }
    }
    return E_FAIL;
}




///////////////////////////////////////////////////////////////////
// Class: CXEvent
//
// This class implements an event.  Events are the subset of the
// messages that the user selects to be translated into traps.
// Events, and not messages, are what the user configures.
//
// For further information on how this class fits into the
// scheme of things, please see the CXEventSource class header.
//////////////////////////////////////////////////////////////////

//*********************************************************************
// CXEvent::CXEvent
//
// Construct the event.
//
// Parameters:
//      CXEventSource* pEventSource
//          Pointer to the event source that has the potential to generate
//          this event.
//
// Returns:
//      Nothing.
//
//*********************************************************************
CXEvent::CXEvent(CXEventSource* pEventSource) : m_message(pEventSource)
{
    m_dwCount = 0;
    m_dwTimeInterval = 0;
    m_pEventSource = pEventSource;
    m_pEventSource->m_aEvents.Add(this);
}



//**********************************************************************
// CXEvent::CXEvent
//
// Construct an event.  This form of the constructor creates an event
// directly from a CXMessage object.  This is possible because the
// CXMessage object contains a back-pointer to its source.
//
// Parameters:
//      CXMessage* pMessage
//          Pointer to the message that is used as the event template.
//
// Returns:
//      Nothing.
//**********************************************************************
CXEvent::CXEvent(CXMessage* pMessage) : m_message(pMessage->m_pEventSource)
{
    m_pEventSource = pMessage->m_pEventSource;
    m_message = *pMessage;
    m_dwCount = 0;
    m_dwTimeInterval = 0;
    m_pEventSource->m_aEvents.Add(this);
}


//**********************************************************************
// CXEvent::~CXEvent
//
// Destroy this event.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//**********************************************************************
CXEvent::~CXEvent()
{
    // Remove this event from the source
    m_pEventSource->m_aEvents.RemoveEvent(this);
}


//**********************************************************************
// CXEvent::Deserialize
//
// Read this event from the registry.
//
// Parameters:
//      CRegistryKey& regkeyParent
//          An open registry key pointing to the event source in
//          SNMP_EVENTS\EventLog
//
//      CString& sName
//          The name of the event to load.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if an error occurred.
//
//*********************************************************************
SCODE CXEvent::Deserialize(CRegistryKey& regkeyParent, CString& sName)
{
    CRegistryKey regkey;
    if (!regkeyParent.GetSubKey(sName, regkey)) {
        return E_FAIL;
    }

    SCODE sc = E_FAIL;
    CRegistryValue regval;

    // Get the count and time interval.
    m_dwCount = 0;
    m_dwTimeInterval = 0;
    if (regkey.GetValue(SZ_REGKEY_EVENT_COUNT, regval))  {
        m_dwCount = *(DWORD*)regval.m_pData;
        if (regkey.GetValue(SZ_REGKEY_EVENT_TIME, regval))  {
            m_dwTimeInterval = *(DWORD*)regval.m_pData;
        }
    }


    if (regkey.GetValue(SZ_REGKEY_EVENT_FULLID, regval))   {
        DWORD dwFullId = *(DWORD*)regval.m_pData;

        CXMessage* pMessage = m_pEventSource->FindMessage(dwFullId);
        if (pMessage == NULL) {
            sc = E_MESSAGE_NOT_FOUND;
        }
        else {
            m_message = *pMessage;
            sc = S_OK;
        }
    }

    regkey.Close();
    return sc;
}



//**********************************************************************
// CXEvent::Deserialize
//
// Write the configuration for this event to the registry.
//
// Parameters:
//      CRegistryKey& regkeyParent
//          An open registry key pointing to the event source in
//          SNMP_EVENTS\EventLog
//
// Returns:
//      SCODE
//          S_OK = the event was successful written out.
//          S_SAVE_CANCELED = no errors, but the user canceled the save.
//          E_FAIL = if an error occurred.
//
//*********************************************************************
SCODE CXEvent::Serialize(CRegistryKey& regkeyParent)
{
    if (g_reg.m_pdlgSaveProgress) {
        if (g_reg.m_pdlgSaveProgress->StepProgress()) {
            return S_SAVE_CANCELED;
        }
    }


    CRegistryKey regkey;

    CString sName;
    GetName(sName);
    if (!regkeyParent.CreateSubKey(sName, regkey)) {
        return E_REGKEY_NO_CREATE;
    }

    CRegistryValue regval;
    if (m_dwCount > 0) {
        regval.Set(SZ_REGKEY_EVENT_COUNT, REG_DWORD, sizeof(DWORD), (LPBYTE) &m_dwCount);
        regkey.SetValue(regval);

        if (m_dwTimeInterval > 0) {
            regval.Set(SZ_REGKEY_EVENT_TIME, REG_DWORD, sizeof(DWORD), (LPBYTE) &m_dwTimeInterval);
            regkey.SetValue(regval);
        }
    }

    regval.Set(SZ_REGKEY_EVENT_FULLID, REG_DWORD, sizeof(DWORD), (LPBYTE) &m_message.m_dwId);
    regkey.SetValue(regval);
    regkey.Close();
    return S_OK;
}


//*************************************************************************
// CXEvent::GetCount
//
// Get the ASCII decimal value for the m_dwCount member.
//
// Using this method to do the conversion ensures that the count value is
// presented to the user in a consistent form throughout the program.
//
// Parameters:
//      CString& sText
//          This is where the count value is returned.
//
// Returns:
//      The ASCII value for the count is returned via sText.
//
// Note: m_dwCount and m_dwTimeInterval work together.  A trap is sent only if
// m_dwCount events are registered withing m_dwTimeInterval seconds.
//*************************************************************************
void CXEvent::GetCount(CString& sText)
{
    DecString(sText, (long) m_dwCount);
}



//*************************************************************************
// CXEvent::GetTimeInterval
//
// Get the ASCII decimal value for the m_dwTimeInterval member.
//
// Using this method to do the conversion ensures that the time-interval value is
// presented to the user in a consistent form throughout the program.
//
// Parameters:
//      CString& sText
//          This is where the count value is returned.
//
// Returns:
//      The ASCII value for the count is returned via sText.
//
// Note: m_dwCount and m_dwTimeInterval work together.  A trap is sent only if
// m_dwCount events are registered withing m_dwTimeInterval seconds.
//*************************************************************************
void CXEvent::GetTimeInterval(CString& sText)
{
    DecString(sText, (long) m_dwTimeInterval);
}






///////////////////////////////////////////////////////////////////
// Class: CXMessage
//
// This class implements a message.  Each event source has some
// number of messages associated with it.  A user may select some
// subset of the messages to be converted into "events".  The user
// configures events, not messages.
//
// For further information on how this class fits into the
// scheme of things, please see the CXEventSource class header.
//////////////////////////////////////////////////////////////////


CXMessage::CXMessage(CXEventSource* pEventSource)
{
    m_pEventSource = pEventSource;
}


CXMessage& CXMessage::operator=(CXMessage& message)
{
    m_pEventSource = message.m_pEventSource;
    m_dwId = message.m_dwId;
    m_sText = message.m_sText;
    return *this;
}



//***************************************************************************
//
//  CMessage::GetSeverity
//
//  Get the severity level of the event.  This is the human-readable string
//	corresponding to the top two bits of the event ID.
//
//  Parameters:
//		CString& sSeverity
//			A reference to the place to return the severity string.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CXMessage::GetSeverity(CString& sSeverity)
{
	MapEventToSeverity(m_dwId, sSeverity);
}



//***************************************************************************
//
//  CMessage::GetTrappingString
//
//  This method returns the trapping string "yes" if the event is being
//	trapped and "no" if its not being trapped.
//
//  Parameters:
//		CString& sTrapping
//			A reference to the place to return the trapping string.
//
//  Returns:
//		Nothing.
//
//  Status:
//
//***************************************************************************
void CXMessage::IsTrapping(CString& sIsTrapping)
{
    CXEvent* pEvent = m_pEventSource->FindEvent(m_dwId);
    sIsTrapping.LoadString( pEvent != NULL ? IDS_IS_TRAPPING : IDS_NOT_TRAPPING);
}


//****************************************************************************
//
// CMessage::SetAndCleanText
//
// Set the m_sText data member to a cleaned up version of a source string.
// The text is cleaned by converting all funny whitespace characters such
// as carriage return, tabs and so on to ordinary space characters.  All
// leading space is stripped from the beginning of the string.
//
//****************************************************************************
void CXMessage::SetAndCleanText(PMESSAGE_RESOURCE_ENTRY pEntry)
{
    BOOL    bIsLeadingSpace = TRUE;
    USHORT  i;

    if (pEntry->Flags == 0x00000)   // ANSI char set
    {
        CHAR *pszSrc = (CHAR *)pEntry->Text;
        CHAR chSrc;
        LPTSTR pszDst = m_sText.GetBuffer(strlen(pszSrc) + 1);

        for (i=0; i<pEntry->Length && *pszSrc; i++, pszSrc++)
        {
            chSrc = *pszSrc;
            if (chSrc >= 0x09 && chSrc <= 0x0d)
                chSrc = ' ';
            if (chSrc == ' ' && bIsLeadingSpace)
                    continue;

            *pszDst++ = (TCHAR)chSrc;
            if (bIsLeadingSpace)    // testing only is less costly
                bIsLeadingSpace = FALSE;
        }
        *pszDst = _T('\0');
    }
    else    // UNICODE char set
    {
        wchar_t *pwszSrc = (wchar_t *)pEntry->Text;
        wchar_t wchSrc;
        LPTSTR pszDst = m_sText.GetBuffer(wcslen(pwszSrc) + 1);

        for (i=0; i<pEntry->Length/sizeof(wchar_t) && *pwszSrc; i++, pwszSrc++)
        {
            wchSrc = *pwszSrc;
            if (wchSrc >= (wchar_t)0x09 && wchSrc <= (wchar_t)0x0d)
                wchSrc = (wchar_t)' ';
            if (wchSrc == (wchar_t)' ' && bIsLeadingSpace)
                continue;

            *pszDst++ = (TCHAR)wchSrc;
            if (bIsLeadingSpace)    // testing only is less costly
                bIsLeadingSpace = FALSE;
        }
        *pszDst = _T('\0');
    }

    m_sText.ReleaseBuffer();
}



//****************************************************************************
// CXMessage::GetShortId
//
// This method returns the message's "short ID" that users see for events and
// messages.  The short ID is the ASCII decimal value for the low-order 16 bits
// of the message ID.
//
// Using this method to do the conversion ensures that the short-ID value is
// presented to the user in a consistent form throughout the program.
//
// Parameters:
//      CString& sShortId
//          This is where the ID string is returned.
//
// Returns:
//      The message ID string is returned via sShortId
//
//****************************************************************************
void CXMessage::GetShortId(CString& sShortId)
{
    TCHAR szBuffer[MAX_STRING];
    _ltot((LONG) LOWORD(m_dwId), szBuffer, 10);
    sShortId = szBuffer;
}



///////////////////////////////////////////////////////////////////
// Class: CXMessageArray
//
// This class implements an array of pointers to CXMessage objects.
//
// For further information on how this CXMessageArray fits into the
// scheme of things, please see the CXEventSource class header.
//////////////////////////////////////////////////////////////////


//****************************************************************
// CXMessageArray::CXMessageArray
//
// Constructor.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
//****************************************************************
CXMessageArray::CXMessageArray()
{
    m_bDidLoadMessages = FALSE;
    m_pEventSource = NULL;
}




//*******************************************************************
// CXMessageArray::FindMessage
//
// Search this array for a message given its ID.
//
// Parameters:
//      DWORD dwId
//          The full message ID
//
// Returns:
//      CXMessage*
//          Pointer to the message if it was found.  NULL if it was
//          not found.
//
// Note:
//      Duplicate messages are not allowed in the array, but no code
//      enforces this for the sake of efficiency.
//
//*******************************************************************
CXMessage* CXMessageArray::FindMessage(DWORD dwId)
{
    if (!m_bDidLoadMessages) {
        if (FAILED(LoadMessages())) {
            return NULL;
        }
    }

    LONG nMessages = GetSize();
    for (LONG iMessage = 0; iMessage < nMessages; ++iMessage) {
        CXMessage* pMessage = GetAt(iMessage);
        if (pMessage->m_dwId == dwId) {
            return pMessage;
        }
    }

    return NULL;
}





//****************************************************************************
//
// XProcessMsgTable
//
// This function processes a the message table contained in a message .DLL file
// and adds all the messages it contains to the given CXMessageArray object.
//
// Parameters:
//      HANDLE hModule
//          The module handle for the .DLL file.
//
//      LPCTSTR lpszType
//          Ignored.
//
//      LPTSTR lpszName
//          The name of the module.
//
//      LONG lParam
//          A pointer to a CXMessageArray object where the messages will be
//          stored.
//
// Returns:
//      BOOL
//          Always returns TRUE.
//
//
//****************************************************************************
static BOOL CALLBACK XProcessMsgTable(HANDLE hModule, LPCTSTR lpszType,
    LPTSTR lpszName, LONG_PTR lParam)
{
    CXMessageArray* paMessages = (CXMessageArray*)(LPVOID) (LONG_PTR)lParam;

    // Found a message table.  Process it!
    HRSRC hResource = FindResource((HINSTANCE)hModule, lpszName,
        RT_MESSAGETABLE);
    if (hResource == NULL)
        return TRUE;

    HGLOBAL hMem = LoadResource((HINSTANCE)hModule, hResource);
    if (hMem == NULL)
        return TRUE;

    PMESSAGE_RESOURCE_DATA pMsgTable = (PMESSAGE_RESOURCE_DATA)::LockResource(hMem);
    if (pMsgTable == NULL)
        return TRUE;

    ULONG ulBlock, ulId, ulOffset;

    for (ulBlock=0; ulBlock<pMsgTable->NumberOfBlocks; ulBlock++)
    {
        ulOffset = pMsgTable->Blocks[ulBlock].OffsetToEntries;
        for (ulId = pMsgTable->Blocks[ulBlock].LowId;
            ulId <= pMsgTable->Blocks[ulBlock].HighId; ulId++)

        {
            PMESSAGE_RESOURCE_ENTRY pEntry =
                (PMESSAGE_RESOURCE_ENTRY)((ULONG_PTR)pMsgTable + ulOffset);
            CXMessage *pMessage = new CXMessage(paMessages->m_pEventSource);
            pMessage->m_dwId = (DWORD) ulId;
            pMessage->SetAndCleanText(pEntry);
            paMessages->Add(pMessage);
            ulOffset += pEntry->Length;
        }
    }

    return TRUE;
}


//****************************************************************************
// CXMessageArray::LoadMessages
//
// Load the messages from the message .DLL file(s) for the source into this
// message array.
//
// Parameters:
//      None.
//
// Returns:
//      SCODE
//          S_OK if successful.
//          E_FAIL if an error occurs.
//
//*****************************************************************************
SCODE CXMessageArray::LoadMessages()
{
    ASSERT(m_pEventSource != NULL);
    if (m_bDidLoadMessages) {
        return S_OK;
    }


    CBusy busy;
    CString sLibPathList = m_pEventSource->m_sLibPath;
    CString sLibPath;

	while (GetNextPath(sLibPathList, sLibPath) != E_FAIL) {

	    // Load the library and get a list of all the messages.
	    HINSTANCE hInstMsgFile = LoadLibraryEx((LPCTSTR) sLibPath, NULL,
	        LOAD_LIBRARY_AS_DATAFILE);
	    if (hInstMsgFile == NULL) {
            TCHAR szMessage[MAX_STRING];
            CString sFormat;
            sFormat.LoadString(IDS_ERR_LOAD_MESSAGE_FILE_FAILED);
            _stprintf(szMessage, (LPCTSTR) sFormat, (LPCTSTR) sLibPath);
            AfxMessageBox(szMessage, MB_OK | MB_ICONSTOP);
			continue;
		}

	    EnumResourceNames(hInstMsgFile, RT_MESSAGETABLE,
	        (ENUMRESNAMEPROC)XProcessMsgTable, (LONG_PTR) this);

        GetLastError();

	    FreeLibrary(hInstMsgFile);
	}


    m_bDidLoadMessages = TRUE;
    return S_OK;
}


//**************************************************************
// CXMessageArray::GetNextPath
//
// This function extracts the next path element from a list
// of semi-colon separated paths.  It also removes the extracted
// element and the semi-colon from the path list.
//
// Paramters:
//		CString& sPathlist
//			A reference to a string consisting of one or more paths separated
//			by semi-colons.
//
//		CString& sPath
//			A reference to the place where the extracted path string
//			will be returned.
//
// Returns:
//		SCODE
//			S_OK if a path was extracted, E_FAIL otherwise.
//
//		The path is returned via sPath.  sPathlist is updated
//		so that sPath and the trailing semi-colon is removed
//
//**************************************************************
SCODE CXMessageArray::GetNextPath(CString& sPathlist, CString& sPath)
{
	CString sPathTemp;

	sPath.Empty();
	while (sPath.IsEmpty() && !sPathlist.IsEmpty()) {
		// Copy the next path from the sPathlist to sPath and
		// remove it from sPathlist
		INT ich = sPathlist.Find(_T(';'));
		if (ich == -1) {
			sPathTemp = sPathlist;
			sPathlist = _T("");
		}
		else {
			sPathTemp = sPathlist.Left(ich);
			sPathlist = sPathlist.Right( sPathlist.GetLength() - (ich + 1));
		}

		// Trim any leading or trailing space characters from
		// the path.

		// Find the first non-space character
		LPTSTR pszStart = sPathTemp.GetBuffer(sPathTemp.GetLength() + 1);
		while (*pszStart) {
			if (!_istspace(*pszStart)) {
				break;
			}			
			++pszStart;
		}
        // here, pszStart either points to the 1st non-space character or a string
        // of zero length

        // Find the first non-space character in reverse direction
        LPTSTR pszEnd = pszStart + _tcslen(pszStart); // point to the null character
        if (pszStart != pszEnd)
        {
            pszEnd--; // point to the last character
            while (_istspace(*pszEnd))
            {
                pszEnd--;
            }
            // here, pszEnd points to the first non-space character in reverse direction
            pszEnd++;
            *pszEnd = _T('\0');
        }

		sPath = pszStart;
		sPathTemp.ReleaseBuffer();
	}
	
	if (sPath.IsEmpty()) {
		return E_FAIL;
	}
	else {
		return S_OK;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\utils.cpp ===
#include "stdafx.h"
#include "utils.h"
#include "globals.h"
#include "trapreg.h"

//***************************************************************************
//
//  MapEventToSeverity
//
//  Extract the severity field from the event ID and convert it to a
//  string equivallent.
//
//  Parameters:
//		DWORD dwEvent
//			The full event ID
//
//		CString& sResult
//			The severity code string is returned here.
//
//  Returns:
//		The severity code string is returned via sResult.
//
//  Status:
//
//***************************************************************************
void MapEventToSeverity(DWORD dwEvent, CString& sResult)
{
	//
	//  Values are 32 bit event ID values layed out as follows:
	//
	//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
	//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
	//  +---+-+-+-----------------------+-------------------------------+
	//  |Sev|C|R|     Facility          |               Code            |
	//  +---+-+-+-----------------------+-------------------------------+
	//
	//  where
	//
	//      Sev - is the severity code
	//
	//          00 - Success
	//          01 - Informational
	//          10 - Warning
	//          11 - Error
	//
	//      C - is the Customer code flag
	//
	//      R - is a reserved bit
	//
	//      Facility - is the facility code
	//
	//      Code - is the facility's status code
	//
	//
	// Define the facility codes

	static UINT auiResource[4] =
		{IDS_EVENT_SEV_SUCCESS,
		 IDS_EVENT_SEV_INFORMATIONAL,
		 IDS_EVENT_SEV_WARNING,
		 IDS_EVENT_SEV_ERROR
		 };
	
	int iSeverity = (dwEvent >> 30) & 3;
	sResult.LoadString(auiResource[iSeverity]);
}




//********************************************************************************
// FindSubstring
//
// Find a substring in some text and return an index to the starting
// position of the string if it is found.
//
// Parameters:
//		LPCSTR pszTemplate
//			Pointer to the string to find.
//
//		LPCSTR pszText
//			Pointer to the text that will be searched
//			for the template string.
//
// Returns:
//		An index to the location of the substring within the text if it
//		is found, otherwise -1.
//
//********************************************************************************
LONG FindSubstring(LPCTSTR pszTemplate, LPCTSTR pszText)
{
	if (*pszTemplate == 0) {
		// An empty template string matches anything, so return zero.
		// This should never really happen since it doesn't make much
		// sense to search for nothing.
		return 0;
	}

	LPCTSTR pszTextStart = pszText;
	while (*pszText) {
		// Iterate through the character positions in the text
		// and return the index to the starting char in the string
		// if it is found.
		LPCTSTR pch1 = pszTemplate;
		LPCTSTR pch2 = pszText;

        while (*pch1 && (*pch1 == *pch2))
        {
			++pch1;
			++pch2;
		}

		if (*pch1 == 0) {
			// We reached the end of the template string, so there
			// must have been a match.
			return (LONG)(pszText - pszTextStart);
		}

		++pszText;
	}
	// Failed to find the substring
	return -1;
}


//********************************************************************************
// FindWholeWord
//
// Find a whole word in some text and return an index to the starting
// position of the whole word if it is found.  Whole word means the
// specified template string followed by a whitespace or end of string.
//
// Parameters:
//		LPCSTR pszTemplate
//			Pointer to the "whole word" string to find.
//
//		LPCSTR pszText
//			Pointer to the text that will be searched
//			for the template string.
//
// Returns:
//		An index to the location of the "whole word" substring within the text if it
//		is found, otherwise -1.
//
//********************************************************************************
LONG FindWholeWord(LPCTSTR pszTemplate, LPCTSTR pszText)
{
	if (*pszTemplate == 0) {
		// An empty search string matches anything, so return the index
		// of the first character.
		return 0;
	}


	// Iterate through each character position checking for a whole-word
	// match at each position.
	LONG nchTemplate = _tcslen(pszTemplate);
	LPCTSTR pszTextStart = pszText;
	LPCTSTR pchTextLimit = pszText + (_tcslen(pszText) - nchTemplate);
	while (pszText <= pchTextLimit) {

		// Check to see if the word is contained anywhere within the text
		INT iPos = FindSubstring(pszTemplate, pszText);
		if (iPos == -1) {
			return -1;
		}

		// Point at the location of the template string within the text
		pszText += iPos;

		// Get the prefix character
		INT ichPrefix;
		if (pszText == pszTextStart) {
			// Beginning of line counts as white space.
			ichPrefix = _T(' ');
		}
		else {
			ichPrefix = *(pszText - 1);
		}

		// Get the suffix character.
		INT ichSuffix = pszText[nchTemplate];
		if (ichSuffix == 0) {
			// End of line counts as whitespace
			ichSuffix = _T(' ');
		}

		// To match a whole word, the word must be bounded on either side
		// by whitespace.
		if (isspace(ichPrefix) && isspace(ichSuffix)) {
			return (LONG)(pszText - pszTextStart);
		}

		// Bump the text pointer to the next position so we don't do the
		// same thing all over again.
		++pszText;
	}
	return -1;
}
	

void DecString(CString& sValue, int iValue)
{
    // 32 bytes should be enough to hold any value
    TCHAR szValue[32];
    _itot(iValue, szValue, 10);
    sValue = szValue;
}


void DecString(CString& sValue, long lValue)
{
    // 32 bytes should be enough to hold any value
    TCHAR szValue[32];
    _ltot(lValue, szValue, 10);
    sValue = szValue;
}


void DecString(CString& sValue, DWORD dwValue)
{
    TCHAR szValue[32];
    _ultot(dwValue, szValue, 10);
    sValue = szValue;
}




CList::CList()
{
    m_pndPrev = this;
	m_pndNext = this;
}

void CList::Link(CList*& pndHead)
{
    if (pndHead == NULL)
        pndHead = this;
    else
    {

        m_pndNext = pndHead;
	    m_pndPrev = pndHead->m_pndPrev;
	    m_pndPrev->m_pndNext = this;
	    m_pndNext->m_pndPrev = this;
	}
}

void CList::Unlink(CList*& pndHead)
{
    if (pndHead == this)
	{
	    if (m_pndNext == this)
		    pndHead = NULL;
		else
	        pndHead = m_pndNext;
	}
	
    m_pndPrev->m_pndNext = m_pndNext;
	m_pndNext->m_pndPrev = m_pndPrev;
}




//***************************************************************
// GetFormattedValue
//
// Convert a value to ASCII and insert thousand separator characters
// into resulting value string.
//
// Parameters:
//      CString& sValueDst
//          The place to return the converted value.
//
//      LONG lValue
//          The value to convert.
//
//*****************************************************************
void GetFormattedValue(CString& sValueDst, LONG lValue)
{
    CString sValueSrc;
    DecString(sValueSrc, lValue);

    LONG nch = sValueSrc.GetLength();
    LPCTSTR pszSrc = sValueSrc;

    // Get a buffer as large as the source string plus the largest number of commas
    // plus one for the sign, one for the null terminator plus one character for slop.
    LPTSTR pszDst = sValueDst.GetBuffer(nch + nch / 3 + 3);

    // Copy any leading sign character.
    if ((*pszSrc == _T('+')) || (*pszSrc == _T('-'))) {
        *pszDst++ = *pszSrc++;
        --nch;
    }

    // Now copy the rest of the number and insert thousand separator characters in
    // the appropriate positions.
    LONG nchInitial = nch;
    while (nch > 0) {
        if ((nch % 3) == 0) {
            if (nch != nchInitial) {
                *pszDst++ = g_chThousandSep;
            }
        }
        *pszDst++ = *pszSrc++;
        --nch;
    }
    *pszDst = _T('\0');

    sValueDst.ReleaseBuffer();
}




//**************************************************************
// GenerateRangeMessage
//
// Generate a message indicating that the user should enter a value
// between some numbers nMin and nMax.
//
// Parameters:
//      CString& sMessage
//          The place to return the message.
//
//      LONG nMin
//          The minimum valid value in the range.
//
//      LONG nMax
//          The maximum valid value in the range.
//
//****************************************************************
void GenerateRangeMessage(CString& sMessage, LONG nMin, LONG nMax)
{
    CString sText;

    sMessage.LoadString(IDS_RANGE_MESSAGE_PREFIX);
    sMessage += _T(' ');

    GetFormattedValue(sText, nMin);
    sMessage += sText;
    sMessage += _T(' ');

    sText.LoadString(IDS_RANGE_VALUE_SEPARATOR);
    sMessage += sText;
    sMessage += _T(' ');


    GetFormattedValue(sText, nMax);
    sMessage += sText;

    sText.LoadString(IDS_SENTENCE_TERMINATOR);
    sMessage += sText;
}



//***************************************************************************
// GetThousandSeparator
//
// Get the thousand separator character for the current locale.
//
// Parameters:
//      TCHAR* pchThousandSep
//          Pointer to the place to return the thousand separator character.
//
// Returns:
//      SCODE
//          S_OK if the thousand separator was returned.
//          E_FAIL if the thousand separator was not returned.
//
//**************************************************************************
SCODE GetThousandSeparator(TCHAR* pchThousandSep)
{
// Digit + separator + 3 digits + decimal + two digits + null terminator  + 4 slop
#define MAX_CHARS_THOUSAND 12
    CString sValue;
    LPTSTR pszValue = sValue.GetBuffer(MAX_CHARS_THOUSAND);

    GetNumberFormat(NULL, 0, _T("1000"), NULL, pszValue, MAX_CHARS_THOUSAND);
    sValue.ReleaseBuffer();

    TCHAR ch = sValue[1];
    if (isdigit(ch)) {
        return E_FAIL;
    }
    *pchThousandSep = ch;
    return S_OK;
}



//***********************************************************************
// IsDecimalInteger
//
// This function tests a string to see whether or not it contains a
// valid integer expression.
//
// Parameters:
//      LPCTSTR pszValue
//          Pointer to the string to test.
//
// Returns:
//      BOOL
//          TRUE = The string contained a valid integer expression.
//          FALSE = The string did not contain a valid integer expression.
//
//***********************************************************************
BOOL IsDecimalInteger(LPCTSTR pszValue)
{
    // Accept leading white space
    while (iswspace(*pszValue)) {
        ++pszValue;
    }

    // Accept a leading plus or minus sign
    if ((*pszValue == _T('+'))  ||  (*pszValue == _T('-'))) {
        ++pszValue;
    }

    // Skip a string of consecutive digits with embedded thousand separators
    BOOL bSawThousandSep = FALSE;
    LONG nDigits = 0;
    while (TRUE) {
        if (*pszValue == g_chThousandSep) {
            if (nDigits > 3) {
                return FALSE;
            }

            bSawThousandSep = TRUE;
            nDigits = 0;
        }
        else if (isdigit(*pszValue)) {
            ++nDigits;
        }
        else {
            break;
        }
        ++pszValue;
    }

    if (bSawThousandSep && nDigits != 3) {
        // If a thousand separater was encountered, then there must be
        // three digits to the right of the last thousand separator.
        return FALSE;
    }


    // Accept trailing whitespace
    if (iswspace(*pszValue)) {
        ++pszValue;
    }


    if (*pszValue == _T('\0')) {
        // We reached the end of the string, so it must have been a decimal integer.
        return TRUE;
    }
    else {
        // We did not rech the end of the string, so it couldn't have been a valid
        // decimal integer value.
        return FALSE;
    }
}


//***************************************************************************
// AsciiToLong
//
// This function first validates a string to make sure that it is a properly
// formatted integer expression, and then converts it to a long.  Any embedded
// characters, such as the thousand separator, are stripped out before the
// conversion is done.
//
//
// Parameters:
//      LPCTSTR pszValue
//          Pointer to the string value to convert.
//
//      LONG* plResult
//          Pointer to the place to store the result.
//
// Returns:
//      SCODE
//          S_OK = The string contained a valid integer and the converted
//                 value was returned via plResult.
//          E_FAIL = The string did not contain a properly formatted integer
//                   expression.
//
//
//**************************************************************************
SCODE AsciiToLong(LPCTSTR pszValue, LONG* plResult)
{
    if (!IsDecimalInteger(pszValue)) {
        return E_FAIL;
    }


    // Strip out any superfluous characters, such as the thousand separator
    // before converting from ascii to long.
    CString sStrippedValue;
    LPTSTR pszDst = sStrippedValue.GetBuffer(_tcslen(pszValue) + 1);
    TCHAR ch;
    while (ch = *pszValue++) {
        if (isdigit(ch) || ch==_T('+') || ch==_T('-')) {
            *pszDst++ = ch;
        }
    }
    *pszDst = 0;
    sStrippedValue.ReleaseBuffer();

    *plResult = _ttol(sStrippedValue);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpmib\mibentry.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

Abstract:

Revision history:

--*/
#include <snmp.h>
#include <snmpexts.h>
#include "mibentry.h"
#include "mibfuncs.h"

//-----------------------------------
// OID definitions
//-----------------------------------
static UINT ids_snmp[] = {1,3,6,1,2,1,11};

static UINT ids_snmpInPkts[]                = { 1,0};
static UINT ids_snmpOutPkts[]               = { 2,0};
static UINT ids_snmpInBadVersions[]         = { 3,0};
static UINT ids_snmpInBadCommunityNames[]   = { 4,0};
static UINT ids_snmpInBadCommunityUses[]    = { 5,0};
static UINT ids_snmpInASNParseErrs[]        = { 6,0};
static UINT ids_snmpInTooBigs[]             = { 8,0};
static UINT ids_snmpInNoSuchNames[]         = { 9,0};
static UINT ids_snmpInBadValues[]           = {10,0};
static UINT ids_snmpInReadOnlys[]           = {11,0};
static UINT ids_snmpInGenErrs[]             = {12,0};
static UINT ids_snmpInTotalReqVars[]        = {13,0};
static UINT ids_snmpInTotalSetVars[]        = {14,0};
static UINT ids_snmpInGetRequests[]         = {15,0};
static UINT ids_snmpInGetNexts[]            = {16,0};
static UINT ids_snmpInSetRequests[]         = {17,0};
static UINT ids_snmpInGetResponses[]        = {18,0};
static UINT ids_snmpInTraps[]               = {19,0};
static UINT ids_snmpOutTooBigs[]            = {20,0};
static UINT ids_snmpOutNoSuchNames[]        = {21,0};
static UINT ids_snmpOutBadValues[]          = {22,0};
static UINT ids_snmpOutGenErrs[]            = {24,0};
static UINT ids_snmpOutGetRequests[]        = {25,0};
static UINT ids_snmpOutGetNexts[]           = {26,0};
static UINT ids_snmpOutSetRequests[]        = {27,0};
static UINT ids_snmpOutGetResponses[]       = {28,0};
static UINT ids_snmpOutTraps[]              = {29,0};
static UINT ids_snmpEnableAuthenTraps[]     = {30,0};

//-----------------------------------
// Views description
//-----------------------------------
SnmpMibEntry mib_snmp[] = {
    MIB_COUNTER(snmpInPkts),
    MIB_COUNTER(snmpOutPkts),
    MIB_COUNTER(snmpInBadVersions),
    MIB_COUNTER(snmpInBadCommunityNames),
    MIB_COUNTER(snmpInBadCommunityUses),
    MIB_COUNTER(snmpInASNParseErrs),
    MIB_COUNTER(snmpInTooBigs),
    MIB_COUNTER(snmpInNoSuchNames),
    MIB_COUNTER(snmpInBadValues),
    MIB_COUNTER(snmpInReadOnlys),
    MIB_COUNTER(snmpInGenErrs),
    MIB_COUNTER(snmpInTotalReqVars),
    MIB_COUNTER(snmpInTotalSetVars),
    MIB_COUNTER(snmpInGetRequests),
    MIB_COUNTER(snmpInGetNexts),
    MIB_COUNTER(snmpInSetRequests),
    MIB_COUNTER(snmpInGetResponses),
    MIB_COUNTER(snmpInTraps),
    MIB_COUNTER(snmpOutTooBigs),
    MIB_COUNTER(snmpOutNoSuchNames),
    MIB_COUNTER(snmpOutBadValues),
    MIB_COUNTER(snmpOutGenErrs),
    MIB_COUNTER(snmpOutGetRequests),
    MIB_COUNTER(snmpOutGetNexts),
    MIB_COUNTER(snmpOutSetRequests),
    MIB_COUNTER(snmpOutGetResponses),
    MIB_COUNTER(snmpOutTraps),
    MIB_INTEGER_RW(snmpEnableAuthenTraps),
    MIB_END()
};

//------------------------------------
// Views supported by this MIB
//------------------------------------
SnmpMibView view_snmp = { 
    MIB_VERSION,
    MIB_VIEW_NORMAL,
    MIB_OID(ids_snmp),
    MIB_ENTRIES(mib_snmp),
    {NULL,0}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpmib\dllmain.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

Abstract:

Revision history:

--*/

#include <snmp.h>
#include <snmpexts.h>
#include "mibentry.h"

SnmpTfxHandle    g_tfxHandle;
PSNMP_MGMTVARS   ge_pMgmtVars;
CRITICAL_SECTION g_SnmpMibCriticalSection;
BOOL             g_fSnmpMibCritSecInited = FALSE;

BOOL
SnmpExtensionInit(
    IN     DWORD                 uptimeReference,
       OUT HANDLE *              lpPollForTrapEvent,
       OUT AsnObjectIdentifier * lpFirstSupportedView)
{
    g_tfxHandle = SnmpTfxOpen(1,&view_snmp);

    if (g_tfxHandle == NULL)
        return FALSE;

    *lpFirstSupportedView = view_snmp.viewOid;
    *lpPollForTrapEvent = NULL;

    return TRUE;    
}

// the SNMP master agent calls this function immediately after SnmpExtensionInit
// in order to provide a pointer to the internal service management information.
// No mutex protection is needed so far, as there is no concurrency in writing the
// buffer pointed by this parameter.
BOOL
SnmpExtensionMonitor(
    IN  LPVOID                  pAgentMgmtVars)
{
    ge_pMgmtVars = (PSNMP_MGMTVARS)pAgentMgmtVars;
    return TRUE;
}

BOOL 
SnmpExtensionQuery(
    IN     BYTE                 requestType,
    IN OUT RFC1157VarBindList * variableBindings,
       OUT AsnInteger *         errorStatus,
       OUT AsnInteger *         errorIndex)
{
    // forward to framework
    return SnmpTfxQuery(
                g_tfxHandle,
                requestType,
                variableBindings,
                errorStatus,
                errorIndex);
}

BOOL 
SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger *genericTrap,
    OUT AsnInteger *specificTrap,
    OUT AsnTimeticks *timeStamp,
    OUT RFC1157VarBindList *variableBindings)
{
    // no traps
    return FALSE;
}


BOOL WINAPI
DllMain(
    HINSTANCE       hInstDLL,
    DWORD           fdwReason,
    LPVOID          pReserved)
{
    switch ( fdwReason )
    {
        case DLL_PROCESS_ATTACH :
        {        
            DisableThreadLibraryCalls( hInstDLL );
            __try
            {
                InitializeCriticalSection(&g_SnmpMibCriticalSection);
                g_fSnmpMibCritSecInited = TRUE;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SNMPMIB: DllMain: InitializeCriticalSection failed.\n"));
                return FALSE;
            }
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SNMPMIB: DllMain: InitializeCriticalSection done.\n"));
            break;
        }
        case DLL_PROCESS_DETACH :
        {
            if (g_fSnmpMibCritSecInited)
            {
                DeleteCriticalSection(&g_SnmpMibCriticalSection);
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SNMPMIB: DllMain: DeleteCriticalSection done.\n"));
            }
            break;
        }
        default :
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpmib\mibentry.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

Abstract:

Revision History:

--*/

#include "snmpmgmt.h"

#ifndef _MIBENTRY_H_
#define _MIBENTRY_H_

extern SnmpMibView view_snmp;

#endif // _MIBENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpevnt\evntwin\utils.h ===
#ifndef _utils_h
#define _utils_h


void MapEventToSeverity(DWORD dwEvent, CString& sResult);
extern LONG FindWholeWord(LPCTSTR pszTemplate, LPCTSTR pszText);
extern LONG FindSubstring(LPCTSTR pszTemplate, LPCTSTR pszText);
extern void DecString(CString& sValue, int iValue);
extern void DecString(CString& sValue, long lValue);
extern void DecString(CString& sValue, DWORD dwValue);

extern void GenerateRangeMessage(CString& sMessage, LONG nMin, LONG nMax);
extern SCODE GetThousandSeparator(TCHAR* pch);
extern BOOL IsDecimalInteger(LPCTSTR pszValue);
extern SCODE AsciiToLong(LPCTSTR pszValue, LONG* plResult);


//-------------------------------------------------------
// Class: CList
//
// Description:
//    This class implements a circularly linked list.
//
// Methods:
//-------------------------------------------------------
// CList::CList(void* pValue)
//
// Construct a node and associate the pointer value
// with it.  The pointer is declared to be type
// void* so that this class is as generic as possible.
//
// Input:
//    pValue = Pointer to the value to associate with this node
//
// Returns: Nothing
//
//-------------------------------------------------------
// void Link(CList*& pndHead)
//
// Add this node to the end of the list pointed to by
// pndHead.  If pndHead is NULL, then set pndHead to
// the address of this node.
//
// Input:
//    pndHead = A reference to the head node pointer
//
// Returns: Nothing
//
//-------------------------------------------------------
// void Unlink(CList*& pndHead)
//
// Unlink this node from the list it is on.  If this node
// is the only element on the list, set the value of pndHead
// to NULL to indicate that the list is empty.
//
// Input:
//    pndHead = A reference to the head node pointer.
//
// Returns: nothing
//
//-------------------------------------------------------
// CList* Next()
//
// Return a pointer to the next node in the list.
//
// Input: None
//
// Returns: A pointer to the next node on the list
//
//-------------------------------------------------------
// CList* Prev()
//
// Return a pointer to the previous node in the list.
//
// Input: None
//
// Returns: A pointer to the previous node on the list.
//
//-------------------------------------------------------
// void* Value()
//
// Return the "value pointer" attached to this node.
//
// Input: None
//
// Returns: The node's value.
//
//--------------------------------------------------------
class CList
{
public:
    CList();
    void Link(CList*& pndHead);
	void Unlink(CList*& pndHead);
	CList* Next() {return m_pndNext;}
	CList* Prev() {return m_pndPrev;}
private:
    CList* m_pndPrev;
	CList* m_pndNext;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpmib\mibfuncs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

Abstract:

Revision history:

--*/

#include "snmpmgmt.h"

#ifndef _MIBFUNCS_H_
#define _MIBFUNCS_H_

// SNMPMIB_MGMTVARS is a structure mapped onto the management
// variables defined at the master agent layer. It is another
// view on the memory space covered by the (PSNMP_MGMTVARS)pMibVariables
// defined below.
// !!!When modifying this structure, make sure to check the code in
// snmpMibGetHandler!!! - this structure is scanned based on the assumption it
// contains AsnAny objects only!!!
typedef struct
{
    AsnAny  snmpInPkts;
    AsnAny  snmpOutPkts;
    AsnAny  snmpInBadVersions;
    AsnAny  snmpInBadCommunityNames;
    AsnAny  snmpInBadCommunityUses;
    AsnAny  snmpInASNParseErrs;
    AsnAny  snmpInTooBigs;
    AsnAny  snmpInNoSuchNames;
    AsnAny  snmpInBadValues;
    AsnAny  snmpInReadOnlys;
    AsnAny  snmpInGenErrs;
    AsnAny  snmpInTotalReqVars;
    AsnAny  snmpInTotalSetVars;
    AsnAny  snmpInGetRequests;
    AsnAny  snmpInGetNexts;
    AsnAny  snmpInSetRequests;
    AsnAny  snmpInGetResponses;
    AsnAny  snmpInTraps;
    AsnAny  snmpOutTooBigs;
    AsnAny  snmpOutNoSuchNames;
    AsnAny  snmpOutBadValues;
    AsnAny  snmpOutGenErrs;
    AsnAny  snmpOutGetRequests;
    AsnAny  snmpOutGetNexts;
    AsnAny  snmpOutSetRequests;
    AsnAny  snmpOutGetResponses;
    AsnAny  snmpOutTraps;
    AsnAny  snmpEnableAuthenTraps;
} SNMPMIB_MGMTVARS;


// function handling all the GETs of this MIB
UINT
snmpMibGetHandler(
        UINT actionId,
        AsnAny *objectArray,
        UINT *errorIndex);

// function handling all the SETs of this MIB
UINT
snmpMibSetHandler(
        UINT actionId,
        AsnAny *objectArray,
        UINT *errorIndex);

//----------------------------------------------------------
//  definitions on which rely all the macros from mibentry.c
//----------------------------------------------------------
PSNMP_MGMTVARS  pMibVariables;          // obtained from the SNMP agent in SnmpExtensionMonitor()

#define gf_snmpInPkts                   snmpMibGetHandler
#define gf_snmpOutPkts                  snmpMibGetHandler
#define gf_snmpInBadVersions            snmpMibGetHandler
#define gf_snmpInBadCommunityNames      snmpMibGetHandler
#define gf_snmpInBadCommunityUses       snmpMibGetHandler
#define gf_snmpInASNParseErrs           snmpMibGetHandler
#define gf_snmpInTooBigs                snmpMibGetHandler
#define gf_snmpInNoSuchNames            snmpMibGetHandler
#define gf_snmpInBadValues              snmpMibGetHandler
#define gf_snmpInReadOnlys              snmpMibGetHandler
#define gf_snmpInGenErrs                snmpMibGetHandler
#define gf_snmpInTotalReqVars           snmpMibGetHandler
#define gf_snmpInTotalSetVars           snmpMibGetHandler
#define gf_snmpInGetRequests            snmpMibGetHandler
#define gf_snmpInGetNexts               snmpMibGetHandler
#define gf_snmpInSetRequests            snmpMibGetHandler
#define gf_snmpInGetResponses           snmpMibGetHandler
#define gf_snmpInTraps                  snmpMibGetHandler
#define gf_snmpOutTooBigs               snmpMibGetHandler
#define gf_snmpOutNoSuchNames           snmpMibGetHandler
#define gf_snmpOutBadValues             snmpMibGetHandler
#define gf_snmpOutGenErrs               snmpMibGetHandler
#define gf_snmpOutGetRequests           snmpMibGetHandler
#define gf_snmpOutGetNexts              snmpMibGetHandler
#define gf_snmpOutSetRequests           snmpMibGetHandler
#define gf_snmpOutGetResponses          snmpMibGetHandler
#define gf_snmpOutTraps                 snmpMibGetHandler
#define gf_snmpEnableAuthenTraps        snmpMibGetHandler

#define sf_snmpEnableAuthenTraps        snmpMibSetHandler

#define gb_snmpInPkts                   SNMPMIB_MGMTVARS
#define gb_snmpOutPkts                  SNMPMIB_MGMTVARS
#define gb_snmpInBadVersions            SNMPMIB_MGMTVARS
#define gb_snmpInBadCommunityNames      SNMPMIB_MGMTVARS
#define gb_snmpInBadCommunityUses       SNMPMIB_MGMTVARS
#define gb_snmpInASNParseErrs           SNMPMIB_MGMTVARS
#define gb_snmpInTooBigs                SNMPMIB_MGMTVARS
#define gb_snmpInNoSuchNames            SNMPMIB_MGMTVARS
#define gb_snmpInBadValues              SNMPMIB_MGMTVARS
#define gb_snmpInReadOnlys              SNMPMIB_MGMTVARS
#define gb_snmpInGenErrs                SNMPMIB_MGMTVARS
#define gb_snmpInTotalReqVars           SNMPMIB_MGMTVARS
#define gb_snmpInTotalSetVars           SNMPMIB_MGMTVARS
#define gb_snmpInGetRequests            SNMPMIB_MGMTVARS
#define gb_snmpInGetNexts               SNMPMIB_MGMTVARS
#define gb_snmpInSetRequests            SNMPMIB_MGMTVARS
#define gb_snmpInGetResponses           SNMPMIB_MGMTVARS
#define gb_snmpInTraps                  SNMPMIB_MGMTVARS
#define gb_snmpOutTooBigs               SNMPMIB_MGMTVARS
#define gb_snmpOutNoSuchNames           SNMPMIB_MGMTVARS
#define gb_snmpOutBadValues             SNMPMIB_MGMTVARS
#define gb_snmpOutGenErrs               SNMPMIB_MGMTVARS
#define gb_snmpOutGetRequests           SNMPMIB_MGMTVARS
#define gb_snmpOutGetNexts              SNMPMIB_MGMTVARS
#define gb_snmpOutSetRequests           SNMPMIB_MGMTVARS
#define gb_snmpOutGetResponses          SNMPMIB_MGMTVARS
#define gb_snmpOutTraps                 SNMPMIB_MGMTVARS
#define gb_snmpEnableAuthenTraps        SNMPMIB_MGMTVARS

#define sb_snmpEnableAuthenTraps        SNMPMIB_MGMTVARS

#define REG_KEY_SNMP_PARAMETERS     \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\SNMP\\Parameters")
#define REG_VALUE_AUTH_TRAPS        TEXT("EnableAuthenticationTraps")

#define IsAsnTypeNull(asnObj) (!((asnObj)->asnType))

#endif // _MIBFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\snmp\subagent\snmpmib\mibfuncs.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

Abstract:

Revision history:

--*/

#include <snmp.h>
#include <snmpexts.h>
#include "mibfuncs.h"

extern PSNMP_MGMTVARS   ge_pMgmtVars;
extern CRITICAL_SECTION g_SnmpMibCriticalSection;

UINT
snmpMibGetHandler(
        UINT     actionId,
        AsnAny  *objectArray,
        UINT    *errorIndex)
{
    int i, j, k;
    LONG nOurSnmpEnableAuthenTraps;

    if (ge_pMgmtVars == NULL)
        return MIB_S_ENTRY_NOT_FOUND;

    // get the number of AsnAny structures we have in the MIB's data buffer
    // and be careful not too scan further (it might be that there are more
    // management variables than objects supported by the MIB).
    k = sizeof(SNMPMIB_MGMTVARS) / sizeof(AsnAny);

    for (i = 0; k != 0 && i < NC_MAX_COUNT; i++, k--)
    {
        if (objectArray[i].asnType == ge_pMgmtVars->AsnCounterPool[i].asnType)
        {
            objectArray[i].asnValue = ge_pMgmtVars->AsnCounterPool[i].asnValue;
        }
    }

    for (j = 0; k != 0 && j < NI_MAX_COUNT; j++, k--)
    {
        if (objectArray[i + j].asnType == ge_pMgmtVars->AsnIntegerPool[j].asnType)
        {
            if ((i+j) == (NC_MAX_COUNT + IsnmpEnableAuthenTraps))
            {
                // for nOurSnmpEnableAuthenTraps: enabled(1), disabled(0)
                // for the output value defined by RFC1213: enabled(1), disabled(2)
                nOurSnmpEnableAuthenTraps = ge_pMgmtVars->AsnIntegerPool[j].asnValue.number;
                objectArray[i + j].asnValue.number = (nOurSnmpEnableAuthenTraps == 0) ? 2 : 1;
            }
            else
            {
                objectArray[i + j].asnValue = ge_pMgmtVars->AsnIntegerPool[j].asnValue;
            }
        }
    }

    return MIB_S_SUCCESS;
}


UINT
snmpMibSetHandler(
        UINT     actionId,
        AsnAny  *objectArray,
        UINT    *errorIndex)
{
    // this function is called only for one object: snmpEnableAuthenTraps

    DWORD           dwResult, dwValue , dwValueLen, dwValueType;
    LONG            nOurValue, nInputValue;
    static HKEY     hKey = NULL;
    static DWORD    dwBlocked = 0;         // Has Critical Section entered
    static BOOL     fMatchedValue = FALSE; // Does input SET value match our current value
    
    
    switch(actionId)
    {
        case MIB_ACTION_VALIDATE:
        {
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SNMPMIB: snmpMibSetHandler: Entered MIB_ACTION_VALIDATE\n"));

             
            // On XP or later, Enter/Leave CriticalSection won't raise 
            // exception in low memory
            EnterCriticalSection(&g_SnmpMibCriticalSection);
            ++dwBlocked;
           
           

           // check the type of input set value
            if (ge_pMgmtVars->AsnIntegerPool[IsnmpEnableAuthenTraps].asnType != 
                objectArray[NC_MAX_COUNT + IsnmpEnableAuthenTraps].asnType)
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SNMPMIB: snmpMibSetHandler: invalid type %x.\n",
                    objectArray[NC_MAX_COUNT + IsnmpEnableAuthenTraps].asnType));
                    
                return MIB_S_INVALID_PARAMETER;     
            }

            nOurValue = ge_pMgmtVars->AsnIntegerPool[IsnmpEnableAuthenTraps].asnValue.number;
            nInputValue = objectArray[NC_MAX_COUNT + IsnmpEnableAuthenTraps].asnValue.number;
            // check the range of input set value. enabled(1), disabled(2)
            if ( ( nInputValue< 1) || ( nInputValue > 2) )
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SNMPMIB: snmpMibSetHandler: invalid value %d.\n",
                    nInputValue));

                return MIB_S_INVALID_PARAMETER;
            }

            // ASSERT: nInputValue is either 1 or 2, nOurValue is either 0 or 1

            // avoid to set the registry value if it matched the current one.
            // for nOurValue: enabled(1), disabled(0)
            // for nInputValue: enabled(1), disabled(2)
            if ( (nInputValue==nOurValue) ||
                 ((nInputValue==2) && (nOurValue==0))
               )
            {
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SNMPMIB: snmpMibSetHandler: has same value as the current one.\n"));
                    
                fMatchedValue = TRUE;
                return MIB_S_SUCCESS;
            }
            
            dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    REG_KEY_SNMP_PARAMETERS,
                                    0,
                                    KEY_SET_VALUE,
                                    &hKey);

            if(NO_ERROR != dwResult) 
            {
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SNMPMIB: snmpMibSetHandler: Couldnt open SNMP Parameters key. Error %d.\n",
                    dwResult));
                
                return dwResult;
            }

            return MIB_S_SUCCESS;
        }

        case MIB_ACTION_SET:
        {
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SNMPMIB: snmpMibSetHandler: Entered MIB_ACTION_SET\n"));

            if (fMatchedValue)
            {
                // avoid to set the registry value since it matched the current one
                fMatchedValue = FALSE; 
                return MIB_S_SUCCESS;
            }

            if (!IsAsnTypeNull(&objectArray[NC_MAX_COUNT + IsnmpEnableAuthenTraps])) 
            {
                
                dwValueType = REG_DWORD;
                dwValueLen  = sizeof(DWORD);
                nInputValue = objectArray[NC_MAX_COUNT + IsnmpEnableAuthenTraps].asnValue.number;
                dwValue = (nInputValue == 2) ? 0 : 1;
                // note: the change of registry will cause snmp.exe to refresh
                //       its configuration from registry. 
                // Per SnmpExtensionMonitor MSDN doc., an SNMP extension agent 
                // should not update the memory pointed to by the 
                // pAgentMgmtData parameter.
                dwResult = RegSetValueEx(
                    hKey,
                    REG_VALUE_AUTH_TRAPS,
                    0,
                    dwValueType,
                    (LPBYTE)&dwValue,
                    dwValueLen);
                                
                if (NO_ERROR != dwResult) 
                {
                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "SNMP: SNMPMIB: snmpMibSetHandler: Couldnt write EnableAuthenticationTraps value. Error %d.\n",
                        dwResult
                        ));

                    return dwResult;
                }
            }

            return MIB_S_SUCCESS;
        }

        case MIB_ACTION_CLEANUP:
        {
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SNMPMIB: snmpMibSetHandler: Entered CLEANUP\n"));

            if (hKey) 
            {
                RegCloseKey(hKey);
                hKey = NULL;
            }

            if(dwBlocked)
            {
                --dwBlocked; // decrement block count before leaving CritSect
                LeaveCriticalSection(&g_SnmpMibCriticalSection);
                
            }

            return MIB_S_SUCCESS;
        }

        default:
        {
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SNMPMIB: snmpMibSetHandler: Entered WRONG ACTION\n"));

            return MIB_S_INVALID_PARAMETER;
        }       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\samples\wshsmple\smpletcp.h ===
/********************************************************************/
/**               Copyright(c) Microsoft Corp., 1990-1998          **/
/********************************************************************/
//
//  This file contains public definitions exported to transport layer and
//  application software.
//

//
// IP type definitions.
//
typedef unsigned long   IPAddr;     // An IP address.

//
// The ip_option_information structure describes the options to be
// included in the header of an IP packet. The TTL, TOS, and Flags
// values are carried in specific fields in the header. The OptionsData
// bytes are carried in the options area following the standard IP header.
// With the exception of source route options, this data must be in the
// format to be transmitted on the wire as specified in RFC 791. A source
// route option should contain the full route - first hop thru final
// destination - in the route data. The first hop will be pulled out of the
// data and the option will be reformatted accordingly. Otherwise, the route
// option should be formatted as specified in RFC 791.
//
struct ip_option_information {
    unsigned char      Ttl;             // Time To Live
    unsigned char      Tos;             // Type Of Service
    unsigned char      Flags;           // IP header flags
    unsigned char      OptionsSize;     // Size in bytes of options data
    unsigned char FAR *OptionsData;     // Pointer to options data
}; /* ip_option_information */

#define MAX_OPT_SIZE    40         // Maximum length of IP options in bytes

#define TCP_SOCKET_NODELAY      1
#define TCP_SOCKET_KEEPALIVE    2
#define TCP_SOCKET_OOBINLINE    3
#define TCP_SOCKET_BSDURGENT    4
#define TCP_SOCKET_ATMARK       5
#define TCP_SOCKET_WINDOW       6

#define AO_OPTION_TTL              1
#define AO_OPTION_MCASTTTL         2
#define AO_OPTION_MCASTIF          3
#define AO_OPTION_XSUM             4
#define AO_OPTION_IPOPTIONS        5
#define AO_OPTION_ADD_MCAST        6
#define AO_OPTION_DEL_MCAST        7
#define AO_OPTION_TOS              8
#define AO_OPTION_IP_DONTFRAGMENT  9

typedef struct IPSNMPInfo {
	ulong		ipsi_forwarding;
	ulong		ipsi_defaultttl;
	ulong		ipsi_inreceives;
	ulong		ipsi_inhdrerrors;
	ulong		ipsi_inaddrerrors;
	ulong		ipsi_forwdatagrams;
	ulong		ipsi_inunknownprotos;
	ulong		ipsi_indiscards;
	ulong		ipsi_indelivers;												
	ulong		ipsi_outrequests;
	ulong		ipsi_routingdiscards;
	ulong		ipsi_outdiscards;
	ulong		ipsi_outnoroutes;
	ulong		ipsi_reasmtimeout;
	ulong		ipsi_reasmreqds;
	ulong		ipsi_reasmoks;
	ulong		ipsi_reasmfails;
	ulong		ipsi_fragoks;
	ulong		ipsi_fragfails;
	ulong		ipsi_fragcreates;
	ulong		ipsi_numif;
	ulong		ipsi_numaddr;
	ulong		ipsi_numroutes;
} IPSNMPInfo;

typedef struct IPAddrEntry {
	ulong		iae_addr;
	ulong		iae_index;
	ulong		iae_mask;
	ulong		iae_bcastaddr;
	ulong		iae_reasmsize;
	ushort		iae_context;
	ushort		iae_pad;
} IPAddrEntry;

#define	IP_MIB_STATS_ID					1
#define	IP_MIB_ADDRTABLE_ENTRY_ID		0x102
#define IP_INTFC_FLAG_P2P   1

typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define	IF_MIB_STATS_ID		1
#define	MAX_PHYSADDR_SIZE	8
#define	MAX_IFDESCR_LEN			256

typedef struct IFEntry {
	ulong			if_index;
	ulong			if_type;
	ulong			if_mtu;
	ulong			if_speed;
	ulong			if_physaddrlen;
	uchar			if_physaddr[MAX_PHYSADDR_SIZE];
	ulong			if_adminstatus;
	ulong			if_operstatus;
	ulong			if_lastchange;
	ulong			if_inoctets;
	ulong			if_inucastpkts;
	ulong			if_innucastpkts;
	ulong			if_indiscards;
	ulong			if_inerrors;
	ulong			if_inunknownprotos;
	ulong			if_outoctets;
	ulong			if_outucastpkts;
	ulong			if_outnucastpkts;
	ulong			if_outdiscards;
	ulong			if_outerrors;
	ulong			if_outqlen;
	ulong			if_descrlen;
	uchar			if_descr[1];
} IFEntry;

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to CreateFile when accessing the device.
//
#define DD_TCP_DEVICE_NAME      L"\\Device\\Tcp"
#define DD_UDP_DEVICE_NAME      L"\\Device\\Udp"
#define DD_RAW_IP_DEVICE_NAME   L"\\Device\\RawIp"

#define FSCTL_TCP_BASE     FILE_DEVICE_NETWORK

#define _TCP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_TCP_BASE, function, method, access)

#define IOCTL_TCP_QUERY_INFORMATION_EX  \
            _TCP_CTL_CODE(0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_TCP_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IP_INTFC_INFO_ID                0x103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\samples\wshsmple\wshsmple.c ===
/*++

Copyright (c) 1992 - 1996 Microsoft Corporation

Module Name:

    WshSmple.c

Abstract:

    This module contains necessary routines for the Windows Sockets
    Helper DLL.  This DLL provides the transport-specific support necessary
    for the Windows Sockets DLL to use TCP/IP as a transport.

Revision History:

        Added WinSock 2 support.

--*/

#define UNICODE
#include "wshsmple.h"
#include <tdi.h>

#include <winsock2.h>
#include <ws2tcpip.h>
#include <wsahelp.h>

#include <tdiinfo.h>

#include <smpletcp.h>

#include <nspapi.h>
#include <nspapip.h>

///////////////////////////////////////////////////
#define TCP_NAME L"TCP/IP"
#define UDP_NAME L"UDP/IP"

#define IS_DGRAM_SOCK(type)  (((type) == SOCK_DGRAM) || ((type) == SOCK_RAW))

//
// Define valid flags for WSHOpenSocket2().
//

#define VALID_TCP_FLAGS         (WSA_FLAG_OVERLAPPED)

#define VALID_UDP_FLAGS         (WSA_FLAG_OVERLAPPED |          \
                                 WSA_FLAG_MULTIPOINT_C_LEAF |   \
                                 WSA_FLAG_MULTIPOINT_D_LEAF)

//
// Buffer management constants for GetTcpipInterfaceList().
//

#define MAX_FAST_ENTITY_BUFFER ( sizeof(TDIEntityID) * 10 )
#define MAX_FAST_ADDRESS_BUFFER ( sizeof(IPAddrEntry) * 4 )


//
// Structure and variables to define the triples supported by TCP/IP. The
// first entry of each array is considered the canonical triple for
// that socket type; the other entries are synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE TcpMappingTriples[] = { AF_INET,   SOCK_STREAM, IPPROTO_TCP,
                                       AF_INET,   SOCK_STREAM, 0,
                                       AF_INET,   0,           IPPROTO_TCP,
                                       AF_UNSPEC, 0,           IPPROTO_TCP,
                                       AF_UNSPEC, SOCK_STREAM, IPPROTO_TCP };

MAPPING_TRIPLE UdpMappingTriples[] = { AF_INET,   SOCK_DGRAM,  IPPROTO_UDP,
                                       AF_INET,   SOCK_DGRAM,  0,
                                       AF_INET,   0,           IPPROTO_UDP,
                                       AF_UNSPEC, 0,           IPPROTO_UDP,
                                       AF_UNSPEC, SOCK_DGRAM,  IPPROTO_UDP };

MAPPING_TRIPLE RawMappingTriples[] = { AF_INET,   SOCK_RAW,    0 };

//
// Winsock 2 WSAPROTOCOL_INFO structures for all supported protocols.
//

#define WINSOCK_SPI_VERSION 2
#define UDP_MESSAGE_SIZE    (65535-68)

WSAPROTOCOL_INFOW Winsock2Protocols[] =
    {
        //
        // TCP
        //

        {
            XP1_GUARANTEED_DELIVERY                 // dwServiceFlags1
                | XP1_GUARANTEED_ORDER
                | XP1_GRACEFUL_CLOSE
                | XP1_EXPEDITED_DATA
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_STREAM,                            // iSocketType
            IPPROTO_TCP,                            // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            0,                                      // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [TCP/IP]"                 // szProtocol
        },

        //
        // UDP
        //

        {
            XP1_CONNECTIONLESS                      // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                | XP1_SUPPORT_BROADCAST
                | XP1_SUPPORT_MULTIPOINT
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_DGRAM,                             // iSocketType
            IPPROTO_UDP,                            // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            UDP_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [UDP/IP]"                 // szProtocol
        },

        //
        // RAW
        //

        {
            XP1_CONNECTIONLESS                      // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                | XP1_SUPPORT_BROADCAST
                | XP1_SUPPORT_MULTIPOINT
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO               // dwProviderFlags
                | PFL_HIDDEN,
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_RAW,                               // iSocketType
            0,                                      // iProtocol
            255,                                    // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            UDP_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [RAW/IP]"                 // szProtocol
        }

    };

#define NUM_WINSOCK2_PROTOCOLS  \
            ( sizeof(Winsock2Protocols) / sizeof(Winsock2Protocols[0]) )

//
// The GUID identifying this provider.
//

GUID TcpipProviderGuid = { /* e70f1aa0-ab8b-11cf-8ca3-00805f48a192 */
    0xe70f1aa0,
    0xab8b,
    0x11cf,
    {0x8c, 0xa3, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}
    };

#define TL_INSTANCE 0

//
// Forward declarations of internal routines.
//

INT
SetTdiInformation (
    IN HANDLE TdiConnectionObjectHandle,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN BOOLEAN WaitForCompletion
    );

BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    );

ULONG
MyInetAddr(
    IN LPWSTR String,
    OUT LPWSTR * Terminator
    );

NTSTATUS
GetTcpipInterfaceList(
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned
    );

//
// The socket context structure for this DLL.  Each open TCP/IP socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHTCPIP_SOCKET_CONTEXT {
    INT     AddressFamily;
    INT     SocketType;
    INT     Protocol;
    INT     ReceiveBufferSize;
    DWORD   Flags;
    INT     MulticastTtl;
    UCHAR   IpTtl;
    UCHAR   IpTos;
    UCHAR   IpDontFragment;
    UCHAR   IpOptionsLength;
    UCHAR  *IpOptions;
    ULONG   MulticastInterface;
    BOOLEAN MulticastLoopback;
    BOOLEAN KeepAlive;
    BOOLEAN DontRoute;
    BOOLEAN NoDelay;
    BOOLEAN BsdUrgent;
    BOOLEAN MultipointLeaf;
    BOOLEAN UdpNoChecksum;
    BOOLEAN Reserved3;
    IN_ADDR MultipointTarget;
    HANDLE MultipointRootTdiAddressHandle;

} WSHTCPIP_SOCKET_CONTEXT, *PWSHTCPIP_SOCKET_CONTEXT;

#define DEFAULT_RECEIVE_BUFFER_SIZE 8192
#define DEFAULT_MULTICAST_TTL 1
#define DEFAULT_MULTICAST_INTERFACE INADDR_ANY
#define DEFAULT_MULTICAST_LOOPBACK TRUE

#define DEFAULT_IP_TTL 32
#define DEFAULT_IP_TOS 0

BOOLEAN
DllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need to receive thread attach and detach
        // notifications, so disable them to help application
        // performance.
        //

        DisableThreadLibraryCalls( DllHandle );

        return TRUE;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;

} // SockInitialize

INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNALIGNED SOCKADDR_IN *sockaddr = (PSOCKADDR_IN)Sockaddr;
    ULONG i;

    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->sin_family != AF_INET ) {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_IN) ) {
        return WSAEFAULT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address portion of the sockaddr.
    //

    if ( sockaddr->sin_addr.s_addr == INADDR_ANY ) {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
    } else if ( sockaddr->sin_addr.s_addr == INADDR_BROADCAST ) {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoBroadcast;
    } else if ( sockaddr->sin_addr.s_addr == INADDR_LOOPBACK ) {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoLoopback;
    } else {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;
    }

    //
    // Determine the type of the port (endpoint) in the sockaddr.
    //

    if ( sockaddr->sin_port == 0 ) {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    } else if ( ntohs( sockaddr->sin_port ) < 2000 ) {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoReserved;
    } else {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;
    }

    //
    // Zero out the sin_zero part of the address.  We silently allow
    // nonzero values in this field.
    //

    for ( i = 0; i < sizeof(sockaddr->sin_zero); i++ ) {
        sockaddr->sin_zero[i] = 0;
    }

    return NO_ERROR;

} // WSHGetSockaddrType


INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE, SO_DONTROUTE, and TCP_EXPEDITED_1122.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to getsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( OptionValue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *OptionLength < sizeof(*context) ) {
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            CopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        return NO_ERROR;
    }

    //
    // The only other levels we support here are SOL_SOCKET,
    // IPPROTO_TCP, IPPROTO_UDP, and IPPROTO_IP.
    //

    if ( Level != SOL_SOCKET &&
         Level != IPPROTO_TCP &&
         Level != IPPROTO_UDP &&
         Level != IPPROTO_IP ) {
        return WSAEINVAL;
    }

    //
    // Make sure that the output buffer is sufficiently large.
    //

    if ( *OptionLength < sizeof(int) ) {
        return WSAEFAULT;
    }

    //
    // Handle TCP-level options.
    //

    if ( Level == IPPROTO_TCP ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        switch ( OptionName ) {

        case TCP_NODELAY:

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = context->NoDelay;
            *OptionLength = sizeof(int);
            break;

        case TCP_EXPEDITED_1122:

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = !context->BsdUrgent;
            *OptionLength = sizeof(int);
            break;

        default:

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle UDP-level options.
    //

    if ( Level == IPPROTO_UDP ) {

        switch ( OptionName ) {

        case UDP_NOCHECKSUM :

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = context->UdpNoChecksum;
            *OptionLength = sizeof(int);
            break;

        default :

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle IP-level options.
    //

    if ( Level == IPPROTO_IP ) {


        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IP_TTL:
            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = (int) context->IpTtl;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_TOS:
            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = (int) context->IpTos;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_DONTFRAGMENT:
            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = (int) context->IpDontFragment;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_OPTIONS:
            if ( *OptionLength < context->IpOptionsLength ) {
                return WSAEINVAL;
            }

            ZeroMemory( OptionValue, *OptionLength );

            if (context->IpOptions != NULL) {
                MoveMemory(
                    OptionValue,
                    context->IpOptions,
                    context->IpOptionsLength
                    );
            }

            *OptionLength = context->IpOptionsLength;

            return NO_ERROR;

        default:
            //
            // No match, fall through.
            //
            break;
        }

        //
        // The following IP options are only valid on datagram sockets.
        //

        if ( !IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IP_MULTICAST_TTL:

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = (char)context->MulticastTtl;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_MULTICAST_IF:

            *(PULONG)OptionValue = context->MulticastInterface;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_MULTICAST_LOOP:

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = context->MulticastLoopback;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        default:

            return WSAENOPROTOOPT;
        }
    }

    //
    // Handle socket-level options.
    //

    switch ( OptionName ) {

    case SO_KEEPALIVE:

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        ZeroMemory( OptionValue, *OptionLength );

        *OptionValue = context->KeepAlive;
        *OptionLength = sizeof(int);

        break;

    case SO_DONTROUTE:

        ZeroMemory( OptionValue, *OptionLength );

        *OptionValue = context->DontRoute;
        *OptionLength = sizeof(int);

        break;

    default:

        return WSAENOPROTOOPT;
    }

    return NO_ERROR;

} // WSHGetSocketInformation


INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For TCP/IP, a wildcard address has IP address ==
    0.0.0.0 and port = 0.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    if ( *SockaddrLength < sizeof(SOCKADDR_IN) ) {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_IN);

    //
    // Just zero out the address and set the family to AF_INET--this is
    // a wildcard address for TCP/IP.
    //

    ZeroMemory( Sockaddr, sizeof(SOCKADDR_IN) );

    Sockaddr->sa_family = AF_INET;

    return NO_ERROR;

} // WSAGetWildcardSockaddr


DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;

    mappingLength = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) +
                        sizeof(TcpMappingTriples) + sizeof(UdpMappingTriples)
                        + sizeof(RawMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength ) {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows = sizeof(TcpMappingTriples) / sizeof(TcpMappingTriples[0])
                     + sizeof(UdpMappingTriples) / sizeof(UdpMappingTriples[0])
                     + sizeof(RawMappingTriples) / sizeof(RawMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);
    MoveMemory(
        Mapping->Mapping,
        TcpMappingTriples,
        sizeof(TcpMappingTriples)
        );
    MoveMemory(
        (PCHAR)Mapping->Mapping + sizeof(TcpMappingTriples),
        UdpMappingTriples,
        sizeof(UdpMappingTriples)
        );
    MoveMemory(
        (PCHAR)Mapping->Mapping + sizeof(TcpMappingTriples)
                                + sizeof(UdpMappingTriples),
        RawMappingTriples,
        sizeof(RawMappingTriples)
        );

    //
    // Return the number of bytes we wrote.
    //

    return mappingLength;

} // WSHGetWinsockMapping


INT
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )
{
    return WSHOpenSocket2(
               AddressFamily,
               SocketType,
               Protocol,
               0,           // Group
               0,           // Flags
               TransportDeviceName,
               HelperDllSocketContext,
               NotificationEvents
               );

} // WSHOpenSocket


INT
WSHOpenSocket2 (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    Group - Identifies the group for the new socket.

    Flags - Zero or more WSA_FLAG_* flags as passed into WSASocket().

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context;

    //
    // Determine whether this is to be a TCP, UDP, or RAW socket.
    //

    if ( IsTripleInList(
             TcpMappingTriples,
             sizeof(TcpMappingTriples) / sizeof(TcpMappingTriples[0]),
             *AddressFamily,
             *SocketType,
             *Protocol ) ) {

        //
        // It's a TCP socket. Check the flags.
        //

        if( ( Flags & ~VALID_TCP_FLAGS ) != 0 ) {

            return WSAEINVAL;

        }

        //
        // Return the canonical form of a TCP socket triple.
        //

        *AddressFamily = TcpMappingTriples[0].AddressFamily;
        *SocketType = TcpMappingTriples[0].SocketType;
        *Protocol = TcpMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_STREAM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, DD_TCP_DEVICE_NAME );

    } else if ( IsTripleInList(
                    UdpMappingTriples,
                    sizeof(UdpMappingTriples) / sizeof(UdpMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) ) {

        //
        // It's a UDP socket. Check the flags & group ID.
        //

        if( ( Flags & ~VALID_UDP_FLAGS ) != 0 ||
            Group == SG_CONSTRAINED_GROUP ) {

            return WSAEINVAL;

        }

        //
        // Return the canonical form of a UDP socket triple.
        //

        *AddressFamily = UdpMappingTriples[0].AddressFamily;
        *SocketType = UdpMappingTriples[0].SocketType;
        *Protocol = UdpMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_DGRAM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, DD_UDP_DEVICE_NAME );

    } else if ( IsTripleInList(
                    RawMappingTriples,
                    sizeof(RawMappingTriples) / sizeof(RawMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) )
    {
        UNICODE_STRING  unicodeString;
        NTSTATUS        status;


        //
        // There is no canonicalization to be done for SOCK_RAW.
        //

        if (*Protocol < 0 || *Protocol > 255) {
            return(WSAEINVAL);
        }

        //
        // Indicate the name of the TDI device that will service
        // SOCK_RAW sockets in the internet address family.
        //
        RtlInitUnicodeString(&unicodeString, DD_RAW_IP_DEVICE_NAME);
        RtlInitUnicodeString(TransportDeviceName, NULL);

        TransportDeviceName->MaximumLength = unicodeString.Length +
                                                 (4 * sizeof(WCHAR) +
                                                 sizeof(UNICODE_NULL));

        TransportDeviceName->Buffer = HeapAlloc(GetProcessHeap(), 0,
                                          TransportDeviceName->MaximumLength
                                          );

        if (TransportDeviceName->Buffer == NULL) {
            return(WSAENOBUFS);
        }

        //
        // Append the device name.
        //
        status = RtlAppendUnicodeStringToString(
                     TransportDeviceName,
                     &unicodeString
                     );

        ASSERT(NT_SUCCESS(status));

        //
        // Append a separator.
        //
        TransportDeviceName->Buffer[TransportDeviceName->Length/sizeof(WCHAR)] =
                                                      OBJ_NAME_PATH_SEPARATOR;

        TransportDeviceName->Length += sizeof(WCHAR);

        TransportDeviceName->Buffer[TransportDeviceName->Length/sizeof(WCHAR)] =
                                                      UNICODE_NULL;

        //
        // Append the protocol number.
        //
        unicodeString.Buffer = TransportDeviceName->Buffer +
                                 (TransportDeviceName->Length / sizeof(WCHAR));
        unicodeString.Length = 0;
        unicodeString.MaximumLength = TransportDeviceName->MaximumLength -
                                           TransportDeviceName->Length;

        status = RtlIntegerToUnicodeString(
                     (ULONG) *Protocol,
                     10,
                     &unicodeString
                     );

        TransportDeviceName->Length += unicodeString.Length;

        ASSERT(NT_SUCCESS(status));

    } else {

        //
        // This should never happen if the registry information about this
        // helper DLL is correct.  If somehow this did happen, just return
        // an error.
        //

        return WSAEINVAL;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = HeapAlloc(GetProcessHeap(), 0, sizeof(*context) );
    if ( context == NULL ) {
        return WSAENOBUFS;
    }

    //
    // Initialize the context for the socket.
    //

    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;
    context->ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
    context->Flags = Flags;
    context->MulticastTtl = DEFAULT_MULTICAST_TTL;
    context->MulticastInterface = DEFAULT_MULTICAST_INTERFACE;
    context->MulticastLoopback = DEFAULT_MULTICAST_LOOPBACK;
    context->KeepAlive = FALSE;
    context->DontRoute = FALSE;
    context->NoDelay = FALSE;
    context->BsdUrgent = TRUE;
    context->IpDontFragment = FALSE;
    context->IpTtl = DEFAULT_IP_TTL;
    context->IpTos = DEFAULT_IP_TOS;
    context->IpOptionsLength = 0;
    context->IpOptions = NULL;
    context->MultipointLeaf = FALSE;
    context->UdpNoChecksum = FALSE;
    context->Reserved3 = FALSE;
    context->MultipointRootTdiAddressHandle = NULL;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.  The only times we need to be
    // called is after a connect has completed so that we can turn on
    // the sending of keepalives if SO_KEEPALIVE was set before the
    // socket was connected, when the socket is closed so that we can
    // free context information, and when a connect fails so that we
    // can, if appropriate, dial in to the network that will support the
    // connect attempt.
    //

    *NotificationEvents =
        WSH_NOTIFY_CONNECT | WSH_NOTIFY_CLOSE | WSH_NOTIFY_CONNECT_ERROR;

    if (*SocketType == SOCK_RAW) {
        *NotificationEvents |= WSH_NOTIFY_BIND;
    }

    //
    // Everything worked, return success.
    //

    *HelperDllSocketContext = context;
    return NO_ERROR;

} // WSHOpenSocket


INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;

    //
    // We should only be called after a connect() completes or when the
    // socket is being closed.
    //

    if ( NotifyEvent == WSH_NOTIFY_CONNECT ) {

        ULONG true = TRUE;
        ULONG false = FALSE;

        //
        // If a connection-object option was set on the socket before
        // it was connected, set the option for real now.
        //

        if ( context->KeepAlive ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_KEEPALIVE,
                      &true,
                      sizeof(true),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->NoDelay ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_NODELAY,
                      &true,
                      sizeof(true),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->ReceiveBufferSize != DEFAULT_RECEIVE_BUFFER_SIZE ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_WINDOW,
                      &context->ReceiveBufferSize,
                      sizeof(context->ReceiveBufferSize),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( !context->BsdUrgent ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_BSDURGENT,
                      &false,
                      sizeof(false),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

    } else if ( NotifyEvent == WSH_NOTIFY_CLOSE ) {

        //
        // If this is a multipoint leaf, then remove the multipoint target
        // from the session.
        //

        if( context->MultipointLeaf &&
            context->MultipointRootTdiAddressHandle != NULL ) {

            struct ip_mreq req;

            req.imr_multiaddr = context->MultipointTarget;
            req.imr_interface.s_addr = 0;

            SetTdiInformation(
                context->MultipointRootTdiAddressHandle,
                CL_TL_ENTITY,
                INFO_CLASS_PROTOCOL,
                INFO_TYPE_ADDRESS_OBJECT,
                AO_OPTION_DEL_MCAST,
                &req,
                sizeof(req),
                TRUE
                );

        }

        //
        // Free the socket context.
        //

        if (context->IpOptions != NULL) {
            HeapFree(GetProcessHeap(), 0,
                context->IpOptions
                );
        }

        HeapFree(GetProcessHeap(), 0, context );

    } else if ( NotifyEvent == WSH_NOTIFY_CONNECT_ERROR ) {

        //
        // Return WSATRY_AGAIN to get wsock32 to attempt the connect
        // again.  Any other return code is ignored.
        //

    } else if ( NotifyEvent == WSH_NOTIFY_BIND ) {
        ULONG true = TRUE;

        if ( context->IpDontFragment ) {
            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_IP_DONTFRAGMENT,
                      &true,
                      sizeof(true),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->IpTtl != DEFAULT_IP_TTL ) {
            int value = (int) context->IpTtl;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_TTL,
                      &value,
                      sizeof(int),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->IpTtl != DEFAULT_IP_TOS ) {
            int value = (int) context->IpTos;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_TOS,
                      &value,
                      sizeof(int),
                      FALSE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if (context->IpOptionsLength > 0 ) {
            err = SetTdiInformation(
                        TdiAddressObjectHandle,
                        CO_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_ADDRESS_OBJECT,
                        AO_OPTION_IPOPTIONS,
                        context->IpOptions,
                        context->IpOptionsLength,
                        TRUE
                        );

            if ( err != NO_ERROR ) {
                //
                // Since the set failed, free the options.
                //
                HeapFree(GetProcessHeap(), 0, context->IpOptions);
                context->IpOptions = NULL;
                context->IpOptionsLength = 0;
                return err;
            }
        }

        if( context->UdpNoChecksum ) {
            ULONG flag = FALSE;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CL_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_XSUM,
                      &flag,
                      sizeof(flag),
                      TRUE
                      );

            if( err != NO_ERROR ) {
                return err;
            }
        }
    } else {
        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify


INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE, SO_DONTROUTE, and TCP_EXPEDITED_1122.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT error;
    INT optionValue;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = HeapAlloc(GetProcessHeap(), 0, sizeof(*context) );
            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            CopyMemory( context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHTCPIP_SOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;

        } else {

            PWSHTCPIP_SOCKET_CONTEXT parentContext;
            INT one = 1;
            INT zero = 0;

            //
            // The socket was accept()'ed and it needs to have the same
            // properties as it's parent.  The OptionValue buffer
            // contains the context information of this socket's parent.
            //

            parentContext = (PWSHTCPIP_SOCKET_CONTEXT)OptionValue;

            ASSERT( context->AddressFamily == parentContext->AddressFamily );
            ASSERT( context->SocketType == parentContext->SocketType );
            ASSERT( context->Protocol == parentContext->Protocol );

            //
            // Turn on in the child any options that have been set in
            // the parent.
            //

            if ( parentContext->KeepAlive ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_KEEPALIVE,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( parentContext->DontRoute ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_DONTROUTE,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( parentContext->NoDelay ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            IPPROTO_TCP,
                            TCP_NODELAY,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( parentContext->ReceiveBufferSize != DEFAULT_RECEIVE_BUFFER_SIZE ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_RCVBUF,
                            (PCHAR)&parentContext->ReceiveBufferSize,
                            sizeof(parentContext->ReceiveBufferSize)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( !parentContext->BsdUrgent ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            IPPROTO_TCP,
                            TCP_EXPEDITED_1122,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            return NO_ERROR;
        }
    }

    //
    // The only other levels we support here are SOL_SOCKET,
    // IPPROTO_TCP, IPPROTO_UDP, and IPPROTO_IP.
    //

    if ( Level != SOL_SOCKET &&
         Level != IPPROTO_TCP &&
         Level != IPPROTO_UDP &&
         Level != IPPROTO_IP ) {
        return WSAEINVAL;
    }

    //
    // Make sure that the option length is sufficient.
    //

    if ( OptionLength < sizeof(int) ) {
        return WSAEFAULT;
    }

    optionValue = *(INT UNALIGNED *)OptionValue;

    //
    // Handle TCP-level options.
    //

    if ( Level == IPPROTO_TCP && OptionName == TCP_NODELAY ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Atempt to turn on or off Nagle's algorithm, as necessary.
        //

        if ( !context->NoDelay && optionValue != 0 ) {

            optionValue = TRUE;

            //
            // NoDelay is currently off and the application wants to
            // turn it on.  If the TDI connection object handle is NULL,
            // then the socket is not yet connected.  In this case we'll
            // just remember that the no delay option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_NODELAY,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is enabled for this socket.
            //

            context->NoDelay = TRUE;

        } else if ( context->NoDelay && optionValue == 0 ) {

            //
            // No delay is currently enabled and the application wants
            // to turn it off.  If the TDI connection object is NULL,
            // the socket is not yet connected.  In this case we'll just
            // remember that nodelay is disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_NODELAY,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is disabled for this socket.
            //

            context->NoDelay = FALSE;
        }

        return NO_ERROR;
    }

    if ( Level == IPPROTO_TCP && OptionName == TCP_EXPEDITED_1122 ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Atempt to turn on or off BSD-style urgent data semantics as
        // necessary.
        //

        if ( !context->BsdUrgent && optionValue == 0 ) {

            optionValue = TRUE;

            //
            // BsdUrgent is currently off and the application wants to
            // turn it on.  If the TDI connection object handle is NULL,
            // then the socket is not yet connected.  In this case we'll
            // just remember that the no delay option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_BSDURGENT,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is enabled for this socket.
            //

            context->BsdUrgent = TRUE;

        } else if ( context->BsdUrgent && optionValue != 0 ) {

            //
            // No delay is currently enabled and the application wants
            // to turn it off.  If the TDI connection object is NULL,
            // the socket is not yet connected.  In this case we'll just
            // remember that BsdUrgent is disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_BSDURGENT,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that BSD urgent is disabled for this socket.
            //

            context->BsdUrgent = FALSE;
        }

        return NO_ERROR;
    }

    //
    // Handle UDP-level options.
    //

    if ( Level == IPPROTO_UDP ) {

        switch ( OptionName ) {

        case UDP_NOCHECKSUM :

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            if( TdiAddressObjectHandle != NULL ) {

                ULONG flag;

                //
                // Note that the incoming flag is TRUE if XSUM should
                // be *disabled*, but the flag we pass to TDI is TRUE
                // if it should be *enabled*, so we must negate the flag.
                //

                flag = (ULONG)!optionValue;

                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_XSUM,
                            &flag,
                            sizeof(flag),
                            TRUE
                            );
                if( error != NO_ERROR ) {
                    return error;
                }

            }

            context->UdpNoChecksum = !!optionValue;
            break;

        default :

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle IP-level options.
    //

    if ( Level == IPPROTO_IP ) {

        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IP_TTL:

            //
            // An attempt to change the unicast TTL sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //
            if ( optionValue > 255 || optionValue < 0 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_TTL,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->IpTtl = (uchar) optionValue;

            return NO_ERROR;

        case IP_TOS:
            //
            // An attempt to change the Type Of Service of packets sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //

            if ( optionValue > 255 || optionValue < 0 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_TOS,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->IpTos = (uchar) optionValue;

            return NO_ERROR;

        case IP_MULTICAST_TTL:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // An attempt to change the TTL on multicasts sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //

            if ( optionValue > 255 || optionValue < 0 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCASTTTL,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            context->MulticastTtl = optionValue;

            return NO_ERROR;

        case IP_MULTICAST_IF:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCASTIF,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            context->MulticastInterface = optionValue;

            return NO_ERROR;

        case IP_MULTICAST_LOOP:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // Not currently supported as a settable option.
            //

            return WSAENOPROTOOPT;

        case IP_ADD_MEMBERSHIP:
        case IP_DROP_MEMBERSHIP:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // Make sure that the option buffer is large enough.
            //

            if ( OptionLength < sizeof(struct ip_mreq) ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            OptionName == IP_ADD_MEMBERSHIP ?
                                AO_OPTION_ADD_MCAST : AO_OPTION_DEL_MCAST,
                            OptionValue,
                            OptionLength,
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            context->MulticastInterface = optionValue;

            return NO_ERROR;

        default:
            //
            // No match, fall through.
            //
            break;
        }

        if ( OptionName == IP_OPTIONS ) {
            PUCHAR temp = NULL;


            //
            // Setting IP options.
            //
            if (OptionLength < 0 || OptionLength > MAX_OPT_SIZE) {
                return WSAEINVAL;
            }

            //
            // Make sure we can get memory if we need it.
            //
            if ( context->IpOptionsLength < OptionLength ) {
                temp = HeapAlloc(GetProcessHeap(), 0,
                           OptionLength
                           );

                if (temp == NULL) {
                    return WSAENOBUFS;
                }
            }


            //
            // Try to set these options. If the TDI address object handle
            // is NULL, then the socket is not yet bound.  In this case we'll
            // just remember options and actually set them in WSHNotify()
            // after a bind has completed on the socket.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_IPOPTIONS,
                            OptionValue,
                            OptionLength,
                            TRUE
                            );

                if ( error != NO_ERROR ) {
                    if (temp != NULL) {
                        HeapFree(GetProcessHeap(), 0, temp );
                    }
                    return error;
                }
            }

            //
            // They were successfully set. Copy them.
            //
            if (temp != NULL ) {
                if ( context->IpOptions != NULL ) {
                    HeapFree(GetProcessHeap(), 0, context->IpOptions );
                }
                context->IpOptions = temp;
            }

            MoveMemory(context->IpOptions, OptionValue, OptionLength);
            context->IpOptionsLength = (UCHAR)OptionLength;

            return NO_ERROR;
        }

        if ( OptionName == IP_DONTFRAGMENT ) {

            //
            // Attempt to turn on or off the DF bit in the IP header.
            //
            if ( !context->IpDontFragment && optionValue != 0 ) {

                optionValue = TRUE;

                //
                // DF is currently off and the application wants to
                // turn it on.  If the TDI address object handle is NULL,
                // then the socket is not yet bound.  In this case we'll
                // just remember that the header inclusion option was set and
                // actually turn it on in WSHNotify() after a bind
                // has completed on the socket.
                //

                if ( TdiAddressObjectHandle != NULL ) {
                    error = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CO_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_IP_DONTFRAGMENT,
                                &optionValue,
                                sizeof(optionValue),
                                TRUE
                                );
                    if ( error != NO_ERROR ) {
                        return error;
                    }
                }

                //
                // Remember that header inclusion is enabled for this socket.
                //

                context->IpDontFragment = TRUE;

            } else if ( context->IpDontFragment && optionValue == 0 ) {

                //
                // The DF flag is currently set and the application wants
                // to turn it off.  If the TDI address object is NULL,
                // the socket is not yet bound.  In this case we'll just
                // remember that the flag is turned off.
                //

                if ( TdiAddressObjectHandle != NULL ) {
                    error = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CO_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_IP_DONTFRAGMENT,
                                &optionValue,
                                sizeof(optionValue),
                                TRUE
                                );
                    if ( error != NO_ERROR ) {
                        return error;
                    }
                }

                //
                // Remember that DF flag is not set for this socket.
                //

                context->IpDontFragment = FALSE;
            }

            return NO_ERROR;
        }

        //
        // We don't support this option.
        //
        return WSAENOPROTOOPT;
    }

    //
    // Handle socket-level options.
    //

    switch ( OptionName ) {

    case SO_KEEPALIVE:

        //
        // Atempt to turn on or off keepalive sending, as necessary.
        //

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        if ( !context->KeepAlive && optionValue != 0 ) {

            optionValue = TRUE;

            //
            // Keepalives are currently off and the application wants to
            // turn them on.  If the TDI connection object handle is
            // NULL, then the socket is not yet connected.  In this case
            // we'll just remember that the keepalive option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_KEEPALIVE,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that keepalives are enabled for this socket.
            //

            context->KeepAlive = TRUE;

        } else if ( context->KeepAlive && optionValue == 0 ) {

            //
            // Keepalives are currently enabled and the application
            // wants to turn them off.  If the TDI connection object is
            // NULL, the socket is not yet connected.  In this case
            // we'll just remember that keepalives are disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_KEEPALIVE,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that keepalives are disabled for this socket.
            //

            context->KeepAlive = FALSE;
        }

        break;

    case SO_DONTROUTE:

        //
        // We don't really support SO_DONTROUTE.  Just remember that the
        // option was set or unset.
        //

        if ( optionValue != 0 ) {
            context->DontRoute = TRUE;
        } else if ( optionValue == 0 ) {
            context->DontRoute = FALSE;
        }

        break;

    case SO_RCVBUF:

        //
        // If the receive buffer size is being changed, tell TCP about
        // it.  Do nothing if this is a datagram.
        //

        if ( context->ReceiveBufferSize == optionValue ||
                 IS_DGRAM_SOCK(context->SocketType)
           ) {
            break;
        }

        if ( TdiConnectionObjectHandle != NULL ) {
            error = SetTdiInformation(
                        TdiConnectionObjectHandle,
                        CO_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_CONNECTION,
                        TCP_SOCKET_WINDOW,
                        &optionValue,
                        sizeof(optionValue),
                        TRUE
                        );
            if ( error != NO_ERROR ) {
                return error;
            }
        }

        context->ReceiveBufferSize = optionValue;

        break;

    default:

        return WSAENOPROTOOPT;
    }

    return NO_ERROR;

} // WSHSetSocketInformation


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Enumerates the protocols supported by this helper.

Arguments:

    lpiProtocols - Pointer to a NULL-terminated array of protocol
        identifiers. Only protocols specified in this array will
        be returned by this function. If this pointer is NULL,
        all protocols are returned.

    lpTransportKeyName -

    lpProtocolBuffer - Pointer to a buffer to fill with PROTOCOL_INFO
        structures.

    lpdwBufferLength - Pointer to a variable that, on input, contains
        the size of lpProtocolBuffer. On output, this value will be
        updated with the size of the data actually written to the buffer.

Return Value:

    INT - The number of protocols returned if successful, -1 if not.

--*/

{
    DWORD bytesRequired;
    PPROTOCOL_INFO tcpProtocolInfo;
    PPROTOCOL_INFO udpProtocolInfo;
    BOOL useTcp = FALSE;
    BOOL useUdp = FALSE;
    DWORD i;

    lpTransportKeyName;         // Avoid compiler warnings.

    //
    // Make sure that the caller cares about TCP and/or UDP.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {

        for ( i = 0; lpiProtocols[i] != 0; i++ ) {
            if ( lpiProtocols[i] == IPPROTO_TCP ) {
                useTcp = TRUE;
            }
            if ( lpiProtocols[i] == IPPROTO_UDP ) {
                useUdp = TRUE;
            }
        }

    } else {

        useTcp = TRUE;
        useUdp = TRUE;
    }

    if ( !useTcp && !useUdp ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (sizeof(PROTOCOL_INFO) * 2) +
                        ( (wcslen( TCP_NAME ) + 1) * sizeof(WCHAR)) +
                        ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR));

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in TCP info, if requested.
    //

    if ( useTcp ) {

        tcpProtocolInfo = lpProtocolBuffer;

        tcpProtocolInfo->dwServiceFlags = XP_GUARANTEED_DELIVERY |
                                              XP_GUARANTEED_ORDER |
                                              XP_GRACEFUL_CLOSE |
                                              XP_EXPEDITED_DATA |
                                              XP_FRAGMENTATION;
        tcpProtocolInfo->iAddressFamily = AF_INET;
        tcpProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_IN);
        tcpProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_IN);
        tcpProtocolInfo->iSocketType = SOCK_STREAM;
        tcpProtocolInfo->iProtocol = IPPROTO_TCP;
        tcpProtocolInfo->dwMessageSize = 0;
        tcpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( TCP_NAME ) + 1) * sizeof(WCHAR) ) );
        wcscpy( tcpProtocolInfo->lpProtocol, TCP_NAME );

        udpProtocolInfo = tcpProtocolInfo + 1;
        udpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)tcpProtocolInfo->lpProtocol -
                ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR) ) );

    } else {

        udpProtocolInfo = lpProtocolBuffer;
        udpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR) ) );
    }

    //
    // Fill in UDP info, if requested.
    //

    if ( useUdp ) {

        udpProtocolInfo->dwServiceFlags = XP_CONNECTIONLESS |
                                              XP_MESSAGE_ORIENTED |
                                              XP_SUPPORTS_BROADCAST |
                                              XP_SUPPORTS_MULTICAST |
                                              XP_FRAGMENTATION;
        udpProtocolInfo->iAddressFamily = AF_INET;
        udpProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_IN);
        udpProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_IN);
        udpProtocolInfo->iSocketType = SOCK_DGRAM;
        udpProtocolInfo->iProtocol = IPPROTO_UDP;
        udpProtocolInfo->dwMessageSize = UDP_MESSAGE_SIZE;
        wcscpy( udpProtocolInfo->lpProtocol, UDP_NAME );
    }

    *lpdwBufferLength = bytesRequired;

    return (useTcp && useUdp) ? 2 : 1;

} // WSHEnumProtocols



BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    )

/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/

{
    ULONG i;

    //
    // Walk through the list searching for an exact match.
    //

    for ( i = 0; i < ListLength; i++ ) {

        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //

        if ( AddressFamily == List[i].AddressFamily &&
             SocketType == List[i].SocketType &&
             ( (Protocol == List[i].Protocol) || (SocketType == SOCK_RAW) )
           ) {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;

} // IsTripleInList


INT
SetTdiInformation (
    IN HANDLE TdiConnectionObjectHandle,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN BOOLEAN WaitForCompletion
    )

/*++

Routine Description:

    Performs a TDI action to the TCP/IP driver.  A TDI action translates
    into a streams T_OPTMGMT_REQ.

Arguments:

    TdiConnectionObjectHandle - a TDI connection object on which to perform
        the TDI action.

    Entity - value to put in the tei_entity field of the TDIObjectID
        structure.

    Class - value to put in the toi_class field of the TDIObjectID
        structure.

    Type - value to put in the toi_type field of the TDIObjectID
        structure.

    Id - value to put in the toi_id field of the TDIObjectID structure.

    Value - a pointer to a buffer to set as the information.

    ValueLength - the length of the buffer.

    WaitForCompletion - TRUE if we should wait for the TDI action to
        complete, FALSE if we're at APC level and cannot do a wait.

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    BOOL status;
    PTCP_REQUEST_SET_INFORMATION_EX setInfoEx;
    OVERLAPPED overlap;
    LPOVERLAPPED poverlap;
    static OVERLAPPED ignore_overlap;

    DWORD dwReturn;

    setInfoEx = HeapAlloc (GetProcessHeap (), 
                            0,
                            sizeof (*setInfoEx) + ValueLength);


    if (setInfoEx==NULL) {
        return WSAENOBUFS;
    }
    //
    // Initialize the TDI information buffers.
    //

    setInfoEx->ID.toi_entity.tei_entity = Entity;
    setInfoEx->ID.toi_entity.tei_instance = TL_INSTANCE;
    setInfoEx->ID.toi_class = Class;
    setInfoEx->ID.toi_type = Type;
    setInfoEx->ID.toi_id = Id;

    CopyMemory( setInfoEx->Buffer, Value, ValueLength );
    setInfoEx->BufferSize = ValueLength;

    //
    // If we need to wait for completion of the operation, create an
    // event to wait on.  If we can't wait for completion because we
    // are being called at APC level, we'll use an APC routine to
    // free the heap we allocated above.
    //

    if ( WaitForCompletion ) {

        ZeroMemory ( &overlap, sizeof(OVERLAPPED));
        overlap.hEvent = CreateEventW(
                        NULL,
                        FALSE,
                        FALSE,
                        NULL
                        );

        if (overlap.hEvent == NULL) {

            return WSAENOBUFS;
        }
        poverlap = &overlap;

    } else {
        poverlap = &ignore_overlap;
    }

    //
    // Make the actual TDI action call.  The Streams TDI mapper will
    // translate this into a TPI option management request for us and
    // give it to TCP/IP.
    //

    status = DeviceIoControl(
                 TdiConnectionObjectHandle,
                 IOCTL_TCP_SET_INFORMATION_EX,
                 setInfoEx,
                 sizeof(*setInfoEx) + ValueLength,
                 NULL,
                 0,
                 &dwReturn,	
                 poverlap
                 );	

    {
        C_ASSERT ((IOCTL_TCP_SET_INFORMATION_EX & 3)==METHOD_BUFFERED);
    }
    HeapFree (GetProcessHeap (), 0, setInfoEx);
 
    //
    // If the call pended and we were supposed to wait for completion,
    // then wait.
    //

    if ( status == FALSE && 
            ERROR_IO_PENDING == GetLastError() && 
            WaitForCompletion ) {
        status = GetOverlappedResult (TdiConnectionObjectHandle,
                                        poverlap,
                                        &dwReturn,
                                        TRUE);
    }

    if ( WaitForCompletion ) {
        CloseHandle ( overlap.hEvent );
    }

    if ( !status ) {
        return WSAENOBUFS;
    }

    return NO_ERROR;

} // SetTdiInformation


INT
WINAPI
WSHJoinLeaf (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    )

/*++

Routine Description:

    Performs the protocol-dependent portion of creating a multicast
    socket.

Arguments:

    The following four parameters correspond to the socket passed into
    the WSAJoinLeaf() API:

    HelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    SocketHandle - The handle of the socket used to establish the
        multicast "session".

    TdiAddressObjectHandle - The TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - The TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    The next two parameters correspond to the newly created socket that
    identifies the multicast "session":

    LeafHelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    LeafSocketHandle - The handle of the socket that identifies the
        multicast "session".

    Sockaddr - The name of the peer to which the socket is to be joined.

    SockaddrLength - The length of Sockaddr.

    CallerData - Pointer to user data to be transferred to the peer
        during multipoint session establishment.

    CalleeData - Pointer to user data to be transferred back from
        the peer during multipoint session establishment.

    SocketQOS - Pointer to the flowspecs for SocketHandle, one in each
        direction.

    GroupQOS - Pointer to the flowspecs for the socket group, if any.

    Flags - Flags to indicate if the socket is acting as sender,
        receiver, or both.

Return Value:

    INT - 0 if successful, a WinSock error code if not.

--*/

{

    struct ip_mreq req;
    INT err;
    PWSHTCPIP_SOCKET_CONTEXT context;

    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        TdiAddressObjectHandle == NULL ||
        LeafHelperDllSocketContext == NULL ||
        LeafSocketHandle == INVALID_SOCKET ||
        Sockaddr == NULL ||
        Sockaddr->sa_family != AF_INET ||
        SockaddrLength < sizeof(SOCKADDR_IN) ||
        ( CallerData != NULL && CallerData->len > 0 ) ||
        ( CalleeData != NULL && CalleeData->len > 0 ) ||
        SocketQOS != NULL ||
        GroupQOS != NULL ) {

        return WSAEINVAL;

    }

    //
    // Add membership.
    //

    req.imr_multiaddr = ((LPSOCKADDR_IN)Sockaddr)->sin_addr;
    req.imr_interface.s_addr = 0;

    err = SetTdiInformation(
              TdiAddressObjectHandle,
              CL_TL_ENTITY,
              INFO_CLASS_PROTOCOL,
              INFO_TYPE_ADDRESS_OBJECT,
              AO_OPTION_ADD_MCAST,
              &req,
              sizeof(req),
              TRUE
              );

    if( err == NO_ERROR ) {

        //
        // Record this fact in the leaf socket so we can drop membership
        // when the leaf socket is closed.
        //

        context = LeafHelperDllSocketContext;

        context->MultipointLeaf = TRUE;
        context->MultipointTarget = req.imr_multiaddr;
        context->MultipointRootTdiAddressHandle = TdiAddressObjectHandle;

    }

    return err;

} // WSHJoinLeaf


INT
WINAPI
WSHGetBroadcastSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a broadcast socket address.  A broadcast address
    may be used as a destination for the sendto() API to send a datagram
    to all interested clients.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a broadcast
        address.

    Sockaddr - points to a buffer which will receive the broadcast socket
        address.

    SockaddrLength - receives the length of the broadcast sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{

    LPSOCKADDR_IN addr;

    if( *SockaddrLength < sizeof(SOCKADDR_IN) ) {

        return WSAEFAULT;

    }

    *SockaddrLength = sizeof(SOCKADDR_IN);

    //
    // Build the broadcast address.
    //

    addr = (LPSOCKADDR_IN)Sockaddr;

    ZeroMemory(
        addr,
        sizeof(*addr)
        );

    addr->sin_family = AF_INET;
    addr->sin_addr.s_addr = htonl( INADDR_BROADCAST );

    return NO_ERROR;

} // WSAGetBroadcastSockaddr


INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    )

/*++

Routine Description:

    Retrieves a pointer to the WSAPROTOCOL_INFOW structure(s) describing
    the protocol(s) supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProtocolInfo - Receives a pointer to the WSAPROTOCOL_INFOW array.

    ProtocolInfoEntries - Receives the number of entries in the array.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProtocolInfo == NULL ||
        ProtocolInfoEntries == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"TcpIp" ) == 0 ) {

        *ProtocolInfo = Winsock2Protocols;
        *ProtocolInfoEntries = NUM_WINSOCK2_PROTOCOLS;

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetWSAProtocolInfo


INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    WCHAR string[32];
    INT length;
    LPSOCKADDR_IN addr;

    //
    // Quick sanity checks.
    //

    if( Address == NULL ||
        AddressLength < sizeof(SOCKADDR_IN) ||
        AddressString == NULL ||
        AddressStringLength == NULL ) {

        return WSAEFAULT;

    }

    addr = (LPSOCKADDR_IN)Address;

    if( addr->sin_family != AF_INET ) {

        return WSA_INVALID_PARAMETER;

    }

    //
    // Do the converstion.
    //

    length = wsprintfW(
                 string,
                 L"%d.%d.%d.%d",
                 ( addr->sin_addr.s_addr >>  0 ) & 0xFF,
                 ( addr->sin_addr.s_addr >>  8 ) & 0xFF,
                 ( addr->sin_addr.s_addr >> 16 ) & 0xFF,
                 ( addr->sin_addr.s_addr >> 24 ) & 0xFF
                 );

    if( addr->sin_port != 0 ) {

        length += wsprintfW(
                      string + length,
                      L":%u",
                      ntohs( addr->sin_port )
                      );

    }

    length++;   // account for terminator

    if( *AddressStringLength < (DWORD)length ) {

        return WSAEFAULT;

    }

    *AddressStringLength = (DWORD)length;

    CopyMemory(
        AddressString,
        string,
        length * sizeof(WCHAR)
        );

    return NO_ERROR;

} // WSHAddressToString


INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    )

/*++

Routine Description:

    Fills in a SOCKADDR structure by parsing a human-readable string.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    AddressFamily - The address family to which the string belongs.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    Address - Receives the SOCKADDR structure.

    AddressLength - On input, contains the length of Address. On output,
        contains the number of bytes actually written to Address.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    LPWSTR terminator;
    ULONG ipAddress;
    USHORT port;
    LPSOCKADDR_IN addr;

    //
    // Quick sanity checks.
    //

    if( AddressString == NULL ||
        Address == NULL ||
        AddressLength == NULL ||
        *AddressLength < sizeof(SOCKADDR_IN) ) {

        return WSAEFAULT;

    }

    if( AddressFamily != AF_INET ) {

        return WSA_INVALID_PARAMETER;

    }

    //
    // Convert it.
    //

    ipAddress = MyInetAddr( AddressString, &terminator );

    if( ipAddress == INADDR_NONE ) {
        return WSA_INVALID_PARAMETER;
    }

    if( *terminator == L':' ) {
        WCHAR ch;
        USHORT base;

        terminator++;

        port = 0;
        base = 10;

        if( *terminator == L'0' ) {
            base = 8;
            terminator++;

            if( *terminator == L'x' ) {
                base = 16;
                terminator++;
            }
        }

        while( ch = *terminator++ ) {
            if( iswdigit(ch) ) {
                port = ( port * base ) + ( ch - L'0' );
            } else if( base == 16 && iswxdigit(ch) ) {
                port = ( port << 4 );
                port += ch + 10 - ( iswlower(ch) ? L'a' : L'A' );
            } else {
                return WSA_INVALID_PARAMETER;
            }
        }

    } else {
        port = 0;
    }

    //
    // Build the address.
    //

    ZeroMemory(
        Address,
        sizeof(SOCKADDR_IN)
        );

    addr = (LPSOCKADDR_IN)Address;
    *AddressLength = sizeof(SOCKADDR_IN);

    addr->sin_family = AF_INET;
    addr->sin_port = port;
    addr->sin_addr.s_addr = ipAddress;

    return NO_ERROR;

} // WSHStringToAddress


INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"TcpIp" ) == 0 ) {

        CopyMemory(
            ProviderGuid,
            &TcpipProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid

ULONG
MyInetAddr(
    IN LPWSTR String,
    OUT LPWSTR * Terminator
    )

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    String - A character string representing a number expressed in the
        Internet standard "." notation.

    Terminator - Receives a pointer to the character that terminated
        the conversion.

Return Value:

    If no error occurs, inet_addr() returns an in_addr structure
    containing a suitable binary representation of the Internet address
    given.  Otherwise, it returns the value INADDR_NONE.

--*/

{
        ULONG val, base;
        WCHAR c;
        ULONG parts[4], *pp = parts;

again:
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, other=decimal.
         */
        val = 0; base = 10;
        if (*String == L'0') {
                base = 8, String++;
                if (*String == L'x' || *String == L'X')
                        base = 16, String++;
        }

        while (c = *String) {
                if (iswdigit(c)) {
                        val = (val * base) + (c - L'0');
                        String++;
                        continue;
                }
                if (base == 16 && iswxdigit(c)) {
                        val = (val << 4) + (c + 10 - (islower(c) ? L'a' : L'A'));
                        String++;
                        continue;
                }
                break;
        }
        if (*String == L'.') {
                /*
                 * Internet format:
                 *      a.b.c.d
                 *      a.b.c   (with c treated as 16-bits)
                 *      a.b     (with b treated as 24 bits)
                 */
                /* GSS - next line was corrected on 8/5/89, was 'parts + 4' */
                if (pp >= parts + 3) {
                        *Terminator = String;
                        return ((ULONG) -1);
                }
                *pp++ = val, String++;
                goto again;
        }
        /*
         * Check for trailing characters.
         */
        if (*String && !iswspace(*String) && (*String != L':')) {
                *Terminator = String;
                return (INADDR_NONE);
        }
        *pp++ = val;
        /*
         * Concoct the address according to
         * the number of parts specified.
         */
        switch (pp - parts) {

        case 1:                         /* a -- 32 bits */
                val = parts[0];
                break;

        case 2:                         /* a.b -- 8.24 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
                    *Terminator = String;
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | (parts[1] & 0xffffff);
                break;

        case 3:                         /* a.b.c -- 8.8.16 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xffff)) {
                    *Terminator = String;
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                        (parts[2] & 0xffff);
                break;

        case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xff) || (parts[3] > 0xff)) {
                    *Terminator = String;
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
                break;

        default:
                *Terminator = String;
                return (INADDR_NONE);
        }

        val = htonl(val);
        *Terminator = String;
        return (val);
}

INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    )

/*++

Routine Description:

    Performs queries & controls on the socket. This is basically an
    "escape hatch" for IOCTLs not supported by MSAFD.DLL. Any unknown
    IOCTLs are routed to the socket's helper DLL for protocol-specific
    processing.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    IoControlCode - Control code of the operation to perform.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

    OutputBuffer - Address of the output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to the output buffer.

    Overlapped - Pointer to a WSAOVERLAPPED structure for overlapped
        operations.

    CompletionRoutine - Pointer to a completion routine to call when
        the operation is completed.

    NeedsCompletion - WSAIoctl() can be overlapped, with all the gory
        details that involves, such as setting events, queuing completion
        routines, and posting to IO completion ports. Since the majority
        of the IOCTL codes can be completed quickly "in-line", MSAFD.DLL
        can optionally perform the overlapped completion of the operation.

        Setting *NeedsCompletion to TRUE (the default) causes MSAFD.DLL
        to handle all of the IO completion details iff this is an
        overlapped operation on an overlapped socket.

        Setting *NeedsCompletion to FALSE tells MSAFD.DLL to take no
        further action because the helper DLL will perform any necessary
        IO completion.

        Note that if a helper performs its own IO completion, the helper
        is responsible for maintaining the "overlapped" mode of the socket
        at socket creation time and NOT performing overlapped IO completion
        on non-overlapped sockets.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    INT err;
    NTSTATUS status;

    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        NumberOfBytesReturned == NULL ||
        NeedsCompletion == NULL ) {

        return WSAEINVAL;

    }

    *NeedsCompletion = TRUE;

    switch( IoControlCode ) {

    case SIO_MULTIPOINT_LOOPBACK :
        err = WSHSetSocketInformation(
                  HelperDllSocketContext,
                  SocketHandle,
                  TdiAddressObjectHandle,
                  TdiConnectionObjectHandle,
                  IPPROTO_IP,
                  IP_MULTICAST_LOOP,
                  (PCHAR)InputBuffer,
                  (INT)InputBufferLength
                  );
        break;

    case SIO_MULTICAST_SCOPE :
        err = WSHSetSocketInformation(
                  HelperDllSocketContext,
                  SocketHandle,
                  TdiAddressObjectHandle,
                  TdiConnectionObjectHandle,
                  IPPROTO_IP,
                  IP_MULTICAST_TTL,
                  (PCHAR)InputBuffer,
                  (INT)InputBufferLength
                  );
        break;

    case SIO_GET_INTERFACE_LIST :
        status = GetTcpipInterfaceList(
                     OutputBuffer,
                     OutputBufferLength,
                     NumberOfBytesReturned
                     );

        if( NT_SUCCESS(status) ) {
            err = NO_ERROR;
        } else if( status == STATUS_BUFFER_TOO_SMALL ) {
            err = WSAENOBUFS;
        } else {
            err = WSAENOPROTOOPT;   // SWAG
        }
        break;

    default :
        err = WSAEINVAL;
        break;
    }

    return err;

}   // WSHIoctl


NTSTATUS
GetTcpipInterfaceList(
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned
    )

/*++

Routine Description:

    This routine queries the INTERFACE_INFO array for all supported
    IP interfaces in the system. This is a helper routine for handling
    the SIO_GET_INTERFACE_LIST IOCTL.

Arguments:

    OutputBuffer - Points to a buffer that will receive the INTERFACE_INFO
        array.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to OutputBuffer.

Return Value:

    NTSTATUS - The completion status.

--*/

{

    NTSTATUS status;
    BOOL res;
    HANDLE deviceHandle;
    TCP_REQUEST_QUERY_INFORMATION_EX tcpRequest;
    TDIObjectID objectId;
    IPSNMPInfo snmpInfo;
    IPInterfaceInfo * interfaceInfo;
    IFEntry * ifentry;
    IPAddrEntry * addressBuffer;
    IPAddrEntry * addressScan;
    TDIEntityID * entityBuffer;
    TDIEntityID * entityScan;
    ULONG i, j;
    ULONG entityCount;
    ULONG entityBufferLength;
    ULONG entityType;
    ULONG addressBufferLength;
    LPINTERFACE_INFO outputInterfaceInfo;
    DWORD outputBytesRemaining;
    LPSOCKADDR_IN sockaddr;
    CHAR fastAddressBuffer[MAX_FAST_ADDRESS_BUFFER];
    CHAR fastEntityBuffer[MAX_FAST_ENTITY_BUFFER];
    CHAR ifentryBuffer[sizeof(IFEntry) + MAX_IFDESCR_LEN];
    CHAR interfaceInfoBuffer[sizeof(IPInterfaceInfo) + MAX_PHYSADDR_SIZE];
    DWORD dwReturn;	


    //
    // Setup locals so we know how to cleanup on exit.
    //

    deviceHandle = NULL;
    addressBuffer = NULL;
    entityBuffer = (PVOID)fastEntityBuffer;
    entityBufferLength = sizeof(fastEntityBuffer);
    interfaceInfo = NULL;

    outputInterfaceInfo = OutputBuffer;
    outputBytesRemaining = OutputBufferLength;

    //
    // Open a handle to the TCP/IP device.
    //

    deviceHandle = CreateFile (
                     DD_TCP_DEVICE_NAME,
                     GENERIC_READ | GENERIC_WRITE,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     );
                     

    if( INVALID_HANDLE_VALUE == deviceHandle ) {

        status = STATUS_UNSUCCESSFUL; // general failure
        goto exit;

    }

    //
    // Get the entities supported by the TCP device.
    //

    ZeroMemory(
        &tcpRequest,
        sizeof(tcpRequest)
        );

    tcpRequest.ID.toi_entity.tei_entity = GENERIC_ENTITY;
    tcpRequest.ID.toi_entity.tei_instance = 0;
    tcpRequest.ID.toi_class = INFO_CLASS_GENERIC;
    tcpRequest.ID.toi_type = INFO_TYPE_PROVIDER;
    tcpRequest.ID.toi_id = ENTITY_LIST_ID;

    for( ; ; ) {

        res = DeviceIoControl(
                     deviceHandle,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     entityBuffer,
                     entityBufferLength,
                     &dwReturn,	
                     NULL        // Overlapped
                     );	

        if( res ) {

            status = STATUS_SUCCESS;
            break;

        }

        if( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {

            status = STATUS_UNSUCCESSFUL; // general failure
            goto exit;

        }

        if( entityBuffer != (PVOID)fastEntityBuffer ) {

            HeapFree(GetProcessHeap(), 0,
                entityBuffer
                );

        }

        entityBuffer = HeapAlloc(GetProcessHeap(), 0,
                           entityBufferLength
                           );

        if( entityBuffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;

        }

    }

    entityCount = entityBufferLength / sizeof(*entityBuffer);

    //
    // Scan the entities looking for IP.
    //

    for( i = 0, entityScan = entityBuffer ;
         i < entityCount ;
         i++, entityScan++ ) {

        if( entityScan->tei_entity != CL_NL_ENTITY ) {

            continue;

        }

        ZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        objectId.toi_entity = *entityScan;
        objectId.toi_class = INFO_CLASS_GENERIC;
        objectId.toi_type = INFO_TYPE_PROVIDER;
        objectId.toi_id = ENTITY_TYPE_ID;

        tcpRequest.ID = objectId;

        res = DeviceIoControl(
                     deviceHandle,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     &entityType,
                     sizeof(entityType),
                     &dwReturn,	
                     NULL        // Overlapped
                     );	

        if( !res ) {

            status = STATUS_UNSUCCESSFUL; // general failure
            goto exit;

        }

        if( entityType != CL_NL_IP ) {

            continue;

        }

        //
        // OK, we found an IP entity. Now lookup its addresses.
        // Start by querying the number of addresses supported by
        // this interface.
        //

        ZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        objectId.toi_class = INFO_CLASS_PROTOCOL;
        objectId.toi_id = IP_MIB_STATS_ID;

        tcpRequest.ID = objectId;

        res = DeviceIoControl(
                     deviceHandle,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     &snmpInfo,
                     sizeof(snmpInfo),
                     &dwReturn,	
                     NULL        // Overlapped
                     );	

        if( !res ) {

            status = STATUS_UNSUCCESSFUL; // general failure
            goto exit;

        }

        if( snmpInfo.ipsi_numaddr <= 0 ) {

            continue;

        }

        //
        // This interface has addresses. Cool. Allocate a temporary
        // buffer so we can query them.
        //

        addressBufferLength = snmpInfo.ipsi_numaddr * sizeof(*addressBuffer);

        if( addressBufferLength <= sizeof(fastAddressBuffer) ) {

            addressBuffer = (PVOID)fastAddressBuffer;

        } else {

            addressBuffer = HeapAlloc(GetProcessHeap(), 0,
                                addressBufferLength
                                );

            if( addressBuffer == NULL ) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;

            }

        }

        ZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        objectId.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;

        tcpRequest.ID = objectId;

        res = DeviceIoControl(
                     deviceHandle,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     addressBuffer,
                     addressBufferLength,
                     &dwReturn,	
                     NULL        // Overlapped
                     );	

        if( !res ) {

            status = STATUS_UNSUCCESSFUL; // general failure
            goto exit;

        }

        //
        // Try to get the IFEntry info so we can tell if the interface
        // is "up".
        //

        ifentry = (PVOID)ifentryBuffer;

        ZeroMemory(
            ifentryBuffer,
            sizeof(ifentryBuffer)
            );

        ZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        addressScan = (IPAddrEntry *) addressBuffer;

        CopyMemory(
            &tcpRequest.Context,
            &addressScan->iae_addr,
            sizeof(addressScan->iae_addr)
            );

        objectId.toi_id = IF_MIB_STATS_ID;

        tcpRequest.ID = objectId;
        tcpRequest.ID.toi_entity.tei_entity = IF_ENTITY;

        res = DeviceIoControl(
                     deviceHandle,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     ifentry,
                     sizeof(ifentryBuffer),
                     &dwReturn,	
                     NULL        // Overlapped
                     );	

        if( !res ) {

            ifentry->if_adminstatus = 0;

        }

        //
        // Now scan the list
        //

        for( j = 0, addressScan = addressBuffer ;
             j < snmpInfo.ipsi_numaddr ;
             j++, addressScan++ ) {

            //
            // Skip any entries that don't have IP addresses yet.
            //

            if( addressScan->iae_addr == 0 ) {

                continue;

            }

            //
            // If the output buffer is full, fail the request now.
            //

            if( outputBytesRemaining <= sizeof(*outputInterfaceInfo) ) {

                status = STATUS_BUFFER_TOO_SMALL;
                goto exit;

            }

            //
            // Setup the output structure.
            //

            ZeroMemory(
                outputInterfaceInfo,
                sizeof(*outputInterfaceInfo)
                );

            outputInterfaceInfo->iiFlags = IFF_MULTICAST;

            sockaddr = (LPSOCKADDR_IN)&outputInterfaceInfo->iiAddress;
            sockaddr->sin_addr.s_addr = addressScan->iae_addr;
            if( sockaddr->sin_addr.s_addr == htonl( INADDR_LOOPBACK ) ) {

                outputInterfaceInfo->iiFlags |= IFF_LOOPBACK;

            }

            sockaddr = (LPSOCKADDR_IN)&outputInterfaceInfo->iiNetmask;
            sockaddr->sin_addr.s_addr = addressScan->iae_mask;

            if( addressScan->iae_bcastaddr != 0 ) {

                outputInterfaceInfo->iiFlags |= IFF_BROADCAST;
                sockaddr = (LPSOCKADDR_IN)&outputInterfaceInfo->iiBroadcastAddress;
                sockaddr->sin_addr.s_addr = htonl( INADDR_BROADCAST );

            }

            //
            // for now just assume they're
            // all "up".
            //

//            if( ifentry->if_adminstatus == IF_STATUS_UP )
            {

                outputInterfaceInfo->iiFlags |= IFF_UP;

            }

            //
            // Get the IP interface info for this interface so we can
            // determine if it's "point-to-point".
            //

            interfaceInfo = (PVOID)interfaceInfoBuffer;

            ZeroMemory(
                interfaceInfoBuffer,
                sizeof(interfaceInfoBuffer)
                );

            ZeroMemory(
                &tcpRequest,
                sizeof(tcpRequest)
                );

            CopyMemory(
                &tcpRequest.Context,
                &addressScan->iae_addr,
                sizeof(addressScan->iae_addr)
                );

            objectId.toi_id = IP_INTFC_INFO_ID;

            tcpRequest.ID = objectId;

            res = DeviceIoControl(
                         deviceHandle,
                         IOCTL_TCP_QUERY_INFORMATION_EX,
                         &tcpRequest,
                         sizeof(tcpRequest),
                         interfaceInfo,
                         sizeof(interfaceInfoBuffer),
                         &dwReturn,	
                         NULL        // Overlapped
                         );	

            if( res ) {

                if( interfaceInfo->iii_flags & IP_INTFC_FLAG_P2P ) {

                    outputInterfaceInfo->iiFlags |= IFF_POINTTOPOINT;

                }

            } else {

                //
                // Print something informative here, then press on.
                //

            }

            //
            // Advance to the next output structure.
            //

            outputInterfaceInfo++;
            outputBytesRemaining -= sizeof(*outputInterfaceInfo);

        }

        //
        // Free the temporary buffer.
        //

        if( addressBuffer != (PVOID)fastAddressBuffer ) {

            HeapFree(GetProcessHeap(), 0,
                addressBuffer
                );

        }

        addressBuffer = NULL;

    }

    //
    // Success!
    //

    *NumberOfBytesReturned = OutputBufferLength - outputBytesRemaining;
    status = STATUS_SUCCESS;

exit:

    if( addressBuffer != (PVOID)fastAddressBuffer &&
        addressBuffer != NULL ) {

        HeapFree(GetProcessHeap(), 0,
            addressBuffer
            );

    }

    if( entityBuffer != (PVOID)fastEntityBuffer &&
        entityBuffer != NULL ) {

        HeapFree(GetProcessHeap(), 0,
            entityBuffer
            );

    }

    if( deviceHandle != NULL ) {

        CloseHandle ( deviceHandle );

    }

    return status;

}   // GetTcpipInterfaceList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\samples\wshsmple\wshsmple.h ===
/********************************************************************/
/**               Copyright(c) Microsoft Corp., 1990-1998          **/
/********************************************************************/

#include <excpt.h>
#include <bugcodes.h>
#include <ntiologc.h>
#include <devioctl.h>
#include <windows.h>
typedef LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;

///// From NTDEF.h ////
//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Determine if an argument is present by testing the value of the pointer
// to the argument value.
//

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

typedef UNICODE_STRING *PUNICODE_STRING;


//// From NTDDK.H /////
//
// Define the base asynchronous I/O argument types
//

#define OBJ_NAME_PATH_SEPARATOR ((WCHAR)L'\\')

#if DBG
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PUNICODE_STRING Source
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    ULONG Value,
    ULONG Base,
    PUNICODE_STRING String
    );


///////////////////
// From NTSTATUS.H

//
// MessageId: STATUS_UNSUCCESSFUL
//
// MessageText:
//
//  {Operation Failed}
//  The requested operation was unsuccessful.
//
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)

//
// MessageId: STATUS_BUFFER_TOO_SMALL
//
// MessageText:
//
//  {Buffer Too Small}
//  The buffer is too small to contain the entry.  No information has been
//  written to the buffer.
//
#define STATUS_BUFFER_TOO_SMALL          ((NTSTATUS)0xC0000023L)

//
// MessageId: STATUS_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the API.
//
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)     // ntsubauth

//
// The success status codes 0 - 63 are reserved for wait completion status.
//
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\sockreg\local.h ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    local.h

Abstract:

    Common header file for all sockutil modules.

Author:

    David Treadwell (davidtr) 5-06-92

Revision History:

--*/

#ifndef _LOCAL_
#define _LOCAL_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>

#include <stdio.h>

#endif // _LOCAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\sockreg\sockreg.c ===
//
//  Determine which -- if any -- of these routines are in use
//      in sockets project and dump remainder (hopefully whole directory)
//      this is ancient stuff, most of which has long been superceded
//  They are actually still used.
//

#include "local.h"

#define malloc(x)   RtlAllocateHeap( RtlProcessHeap(), 0, (x) )
#define free(p)     RtlFreeHeap( RtlProcessHeap(), 0, (p) )


#define WORK_BUFFER_SIZE  1024

char VTCPPARM[] = "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcp\\VParameters";
char NTCPPARM[] = "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcp\\Parameters";
char TCPPARM[] = "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters";
char TTCPPARM[] = "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Transient";

#ifdef TRACE
void
UnicodePrint(
    PUNICODE_STRING  UnicodeString
    )

/*++

Routine Description:

    Print a unicode string.

Arguments:

    UnicodeString - pointer to the string.

Return Value:

    None.

--*/
{
    ANSI_STRING ansiString;
    PUCHAR      tempbuffer = (PUCHAR) malloc(WORK_BUFFER_SIZE);

    ansiString.MaximumLength = WORK_BUFFER_SIZE;
    ansiString.Length = 0L;
    ansiString.Buffer = tempbuffer;

    RtlUnicodeStringToAnsiString(&ansiString,
                                 UnicodeString,
                                 FALSE);
    printf("%s", ansiString.Buffer);
    free(tempbuffer);
    return;
}
#endif


NTSTATUS
SockOpenKey(
    PHANDLE HandlePtr,
    PUCHAR  KeyName
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS          status;
    STRING            keyString;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING    unicodeKeyName;

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       TRUE);

#ifdef TRACE
    printf("SockOpenKey = ");
    UnicodePrint(&unicodeKeyName);
    printf("\n");
#endif

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenKey(HandlePtr,
                       KEY_READ,
                       &objectAttributes);

    RtlFreeUnicodeString(&unicodeKeyName);

#ifdef TRACE
    if (!NT_SUCCESS(status)) {
        printf("Failed NtOpenKey for %s => %x\n",
               KeyName,
               status);
    }
#endif

    return status;
}

NTSTATUS
SockOpenKeyEx(
    PHANDLE HandlePtr,
    PUCHAR  KeyName1,
    PUCHAR  KeyName2,
    PUCHAR  KeyName3
    )

{
    NTSTATUS          status;

    status = SockOpenKey(HandlePtr, KeyName1);
    if (NT_SUCCESS(status) || (KeyName2 == NULL && KeyName3 == NULL)) {
        return status;
    }

    status = SockOpenKey(HandlePtr, KeyName2);
    if (NT_SUCCESS(status) || KeyName3 == NULL) {
        return status;
    }

    return SockOpenKey(HandlePtr, KeyName3);
}



NTSTATUS
SockGetSingleValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PUCHAR ValueData,
    PULONG ValueType,
    ULONG  ValueLength
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS                    status;
    ULONG                       resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UNICODE_STRING              uValueName;
    ANSI_STRING                 aValueName;
    UNICODE_STRING              uValueData;
    ANSI_STRING                 aValueData;


#ifdef TRACE
   printf("SockGetSingleValue: %s\n", ValueName);
#endif
    if ((keyValueFullInformation =
            (PKEY_VALUE_FULL_INFORMATION)malloc(WORK_BUFFER_SIZE)) == NULL) {
        return(STATUS_NO_MEMORY);
    }


    RtlZeroMemory(keyValueFullInformation, WORK_BUFFER_SIZE);

    uValueName.Length = 0L;
    uValueName.MaximumLength = WORK_BUFFER_SIZE;

    if ((uValueName.Buffer = (PWSTR)malloc(WORK_BUFFER_SIZE)) == NULL) {
        free(keyValueFullInformation);
        return(STATUS_NO_MEMORY);
    }

    aValueName.MaximumLength = WORK_BUFFER_SIZE;
    aValueName.Length = (USHORT) strlen(ValueName);
    aValueName.Buffer = (PCHAR)ValueName;

    RtlAnsiStringToUnicodeString(&uValueName,
                                 &aValueName,
                                 FALSE);

    status = NtQueryValueKey(KeyHandle,
                             &uValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);

    if (!NT_SUCCESS(status)) {
        free(uValueName.Buffer);
        free(keyValueFullInformation);
        return status;
    }

    *ValueType = keyValueFullInformation->Type;

    if (*ValueType != REG_DWORD && *ValueType != REG_BINARY) {

        aValueData.Length = 0L;

        if (*ValueType == REG_EXPAND_SZ) {

            aValueData.Buffer = (PVOID)uValueName.Buffer;
            aValueData.MaximumLength = WORK_BUFFER_SIZE;

        } else {

            free(uValueName.Buffer);
            aValueData.Buffer = (PCHAR)ValueData;
            aValueData.MaximumLength = (USHORT)ValueLength;

        }

        uValueData.Length = (USHORT)keyValueFullInformation->DataLength;
        uValueData.MaximumLength = (USHORT)keyValueFullInformation->DataLength;
        uValueData.Buffer = (PWSTR)((PCHAR)keyValueFullInformation +
                                      keyValueFullInformation->DataOffset);

        RtlUnicodeStringToAnsiString(&aValueData,
                                     &uValueData,
                                     FALSE);

        if (*ValueType == REG_EXPAND_SZ) {
            resultLength = ExpandEnvironmentStringsA(
                                 aValueData.Buffer,
                                 ValueData,
                                 ValueLength);
            free(aValueData.Buffer);
        }

    } else {
        *((PULONG)ValueData) = *((PULONG)((PCHAR)keyValueFullInformation +
                                 keyValueFullInformation->DataOffset));
        free(uValueName.Buffer);
    }

    free(keyValueFullInformation);
    return status;
}

NTSTATUS
SockSetSingleValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PUCHAR ValueData,
    ULONG  ValueType,
    ULONG  ValueLength
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              uValueName;
    ANSI_STRING                 aValueName;
    UNICODE_STRING              uData;
    ANSI_STRING                 aData;
    BOOL                        fallocatedUdata = FALSE;

#ifdef TRACE
   printf("SockSetSingleValue: %s\n", ValueName);
#endif

    uValueName.Length = 0L;
    uValueName.MaximumLength = WORK_BUFFER_SIZE;

    //
    // Convert the key name to unicode.
    //

    if ((uValueName.Buffer = (PWSTR)malloc(WORK_BUFFER_SIZE)) == NULL) {
        return(STATUS_NO_MEMORY);
    } else {
        aValueName.MaximumLength = WORK_BUFFER_SIZE;
        aValueName.Length = (USHORT) strlen(ValueName);
        aValueName.Buffer = (PCHAR)ValueName;

        RtlAnsiStringToUnicodeString(&uValueName,
                                     &aValueName,
                                     FALSE);
    }

    if ( ValueType == REG_SZ || ValueType == REG_MULTI_SZ ) {

        if ((uData.Buffer = (PWSTR)malloc(WORK_BUFFER_SIZE)) == NULL)
        {
            free( uValueName.Buffer );
            return(STATUS_NO_MEMORY);
        }
        fallocatedUdata = TRUE;
        uData.MaximumLength = WORK_BUFFER_SIZE;

        //
        // Need to convert the value data from ASCII to unicode
        // before writing it to the registry
        //

        aData.Length = (USHORT)ValueLength;
        aData.MaximumLength = aData.Length;
        aData.Buffer = ValueData;

        RtlAnsiStringToUnicodeString(&uData,
                                     &aData,
                                     FALSE);
    } else {
        uData.Buffer = (PWCHAR)ValueData;
        uData.Length = (USHORT)ValueLength;
    }

    status = NtSetValueKey(KeyHandle,
                           &uValueName,
                           0,
                           ValueType,
                           uData.Buffer,
                           uData.Length );

    if ( fallocatedUdata )
    {
        free( uData.Buffer );
    }
    free(uValueName.Buffer);

    return status;
}



FILE *
SockOpenNetworkDataBase(
    IN  char *Database,
    OUT char *Pathname,
    IN  int   PathnameLen,
    IN  char *OpenFlags
    )
{
    PUCHAR     temp;
    HANDLE     myKey;
    NTSTATUS   status;
    ULONG      myType;

    //
    // Try to open both TCP/IP parameters keys, both old stack and new
    // stack.
    //

    status = SockOpenKeyEx(&myKey, VTCPPARM, NTCPPARM, TCPPARM);
    if (!NT_SUCCESS(status)) {
        SetLastError( ERROR_CANTOPEN );
        return(NULL);
    }

    if ((temp=malloc(WORK_BUFFER_SIZE))==NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        NtClose(myKey);
        return(NULL);
    }

    status = SockGetSingleValue(myKey, "DatabasePath", temp, &myType, WORK_BUFFER_SIZE);
    NtClose(myKey);

    if (!NT_SUCCESS(status)) {
        SetLastError( ERROR_CANTREAD );
        free(temp);
        return(NULL);
    }

    if ( ((int) (strlen(temp) + strlen(Database) + 2)) > PathnameLen) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        free(temp);
        return(NULL);
    }

    strcpy(Pathname, temp);
    strcat(Pathname, "\\");
    strcat(Pathname, Database);

    free(temp);
    return(fopen(Pathname, OpenFlags));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\inc\ws2sdp.h ===
/*++

Copyright 2001 (c) Microsoft Corporation. All rights reserved.

Module Name:

    ws2sdp.h

Abstract:

    This module contains definitions for Sockets Direct Protocol (SDP) support.

Revision History:

--*/

#ifndef _WS2SDP_H_
#define _WS2SDP_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Connect data structure
 */
typedef struct _WSASDPCONNECTDATA {
    USHORT Bufs;
    UCHAR  MaxAdverts;
    DWORD  RcvSize1;
    DWORD  RcvSize2;
} WSASDPCONNECTDATA, FAR * LPWSASDPCONNECTDATA;


/*
 * Flag to set Solicited Event bit
 */
#define MSG_SOLICITED   0x10000

#ifdef __cplusplus
}
#endif

#endif // _WS2SDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\inc\ws2help.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ws2help.h

Abstract:

    Contains declarations for the interface to the OS-specific
    WinSock 2.0 helper routines.

Author:

    Keith Moore (keithmo)        19-Jun-1995

Revision History:

--*/

#ifndef _WS2HELP_H_
#define _WS2HELP_H_


#if defined __cplusplus
extern "C" {
#endif


#if !defined(_WS2HELP_)
#define WS2HELPAPI DECLSPEC_IMPORT
#else
#define WS2HELPAPI
#endif


//
//  APC functions.
//

WS2HELPAPI
DWORD
WINAPI
WahOpenApcHelper(
    OUT LPHANDLE HelperHandle
    );

WS2HELPAPI
DWORD
WINAPI
WahCloseApcHelper(
    IN HANDLE HelperHandle
    );

WS2HELPAPI
DWORD
WINAPI
WahOpenCurrentThread(
    IN  HANDLE HelperHandle,
    OUT LPWSATHREADID ThreadId
    );

WS2HELPAPI
DWORD
WINAPI
WahCloseThread(
    IN HANDLE HelperHandle,
    IN LPWSATHREADID ThreadId
    );

WS2HELPAPI
DWORD
WINAPI
WahQueueUserApc(
    IN HANDLE HelperHandle,
    IN LPWSATHREADID ThreadId,
    IN LPWSAUSERAPC ApcRoutine,
    IN ULONG_PTR ApcContext OPTIONAL
    );

//
// Context functions.
//

typedef struct _CONTEXT_TABLE FAR * LPCONTEXT_TABLE;

#define WAH_CONTEXT_FLAG_SERIALIZE  0x00000001

WS2HELPAPI
DWORD
WINAPI
WahCreateContextTable(
    LPCONTEXT_TABLE FAR * Table,
    DWORD Flags
    );

WS2HELPAPI
DWORD
WINAPI
WahDestroyContextTable(
    LPCONTEXT_TABLE Table
    );

WS2HELPAPI
DWORD
WINAPI
WahSetContext(
    LPCONTEXT_TABLE Table,
    SOCKET Socket,
    LPVOID Context
    );

WS2HELPAPI
DWORD
WINAPI
WahGetContext(
    LPCONTEXT_TABLE Table,
    SOCKET Socket,
    LPVOID FAR * Context
    );

WS2HELPAPI
DWORD
WINAPI
WahRemoveContext(
    LPCONTEXT_TABLE Table,
    SOCKET Socket
    );

WS2HELPAPI
DWORD
WINAPI
WahRemoveContextEx(
    LPCONTEXT_TABLE Table,
    SOCKET Socket,
    LPVOID Context
    );

// Handle function

WS2HELPAPI
DWORD
WINAPI
WahOpenHandleHelper(
    OUT LPHANDLE HelperHandle
    );

WS2HELPAPI
DWORD
WINAPI
WahCloseHandleHelper(
    IN HANDLE HelperHandle
    );


WS2HELPAPI
DWORD
WINAPI
WahCreateSocketHandle(
    IN HANDLE           HelperHandle,
    OUT SOCKET          *s
    );

WS2HELPAPI
DWORD
WINAPI
WahCloseSocketHandle(
    IN HANDLE           HelperHandle,
    IN SOCKET           s
    );

WS2HELPAPI
DWORD
WINAPI
WahCompleteRequest(
    IN HANDLE              HelperHandle,
    IN SOCKET              s,
    IN LPWSAOVERLAPPED     lpOverlapped,
    IN DWORD               dwError,
    IN DWORD               cbTransferred
    );

WS2HELPAPI
DWORD
WINAPI
WahEnableNonIFSHandleSupport (
    VOID
    );

WS2HELPAPI
DWORD
WINAPI
WahDisableNonIFSHandleSupport (
    VOID
    );


// Notification handle functions

WS2HELPAPI
DWORD
WINAPI
WahOpenNotificationHandleHelper(
    OUT LPHANDLE HelperHandle
    );

WS2HELPAPI
DWORD
WINAPI
WahCloseNotificationHandleHelper(
    IN HANDLE HelperHandle
    );

WS2HELPAPI
DWORD
WINAPI
WahCreateNotificationHandle(
    IN HANDLE           HelperHandle,
    OUT HANDLE          *h
    );

WS2HELPAPI
DWORD
WINAPI
WahWaitForNotification(
    IN HANDLE           HelperHandle,
    IN HANDLE           h,
    IN LPWSAOVERLAPPED  lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

WS2HELPAPI
DWORD
WINAPI
WahNotifyAllProcesses (
    IN HANDLE           HelperHandle
    );


//
// New handle -> context lookup functions
//
typedef struct _WSHANDLE_CONTEXT {
    LONG        RefCount;   // Context reference count
    HANDLE      Handle;     // Handle that corresponds to context
} WSHANDLE_CONTEXT, FAR * LPWSHANDLE_CONTEXT;

WS2HELPAPI
DWORD
WINAPI
WahCreateHandleContextTable(
    LPCONTEXT_TABLE FAR * Table
    );

WS2HELPAPI
DWORD
WINAPI
WahDestroyHandleContextTable(
    LPCONTEXT_TABLE Table
    );

WS2HELPAPI
LPWSHANDLE_CONTEXT
WINAPI
WahReferenceContextByHandle(
    LPCONTEXT_TABLE Table,
    HANDLE          Handle
    );

WS2HELPAPI
LPWSHANDLE_CONTEXT
WINAPI
WahInsertHandleContext(
    LPCONTEXT_TABLE     Table,
    LPWSHANDLE_CONTEXT  HContext
    );

WS2HELPAPI
DWORD
WINAPI
WahRemoveHandleContext(
    LPCONTEXT_TABLE     Table,
    LPWSHANDLE_CONTEXT  HContext
    );


typedef
BOOL
(WINAPI * LPFN_CONTEXT_ENUMERATOR)(
    LPVOID              EnumCtx,
    LPWSHANDLE_CONTEXT  HContext
    );

WS2HELPAPI
BOOL
WINAPI
WahEnumerateHandleContexts(
    LPCONTEXT_TABLE         Table,
    LPFN_CONTEXT_ENUMERATOR Enumerator,
    LPVOID                  EnumCtx
    );

#define WahReferenceHandleContext(_ctx)  InterlockedIncrement(&(_ctx)->RefCount)
#define WahDereferenceHandleContext(_ctx)  InterlockedDecrement(&(_ctx)->RefCount)

#if defined __cplusplus
}   // extern "C"
#endif


#endif // _WS2HELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\inc\dt_dll.h ===
/*++

Copyright (c) 1995 Intel Corp

File Name:

    dt_dll.h

Abstract:

    This header describes the interface to the WinSock 2 debug/trace
    DLL.  Please see the design spec for more information.

Author:

    Michael A. Grafton

--*/

#ifndef _DT_DLL_H
#define _DT_DLL_H

#include <windows.h>


//
// This type defines a pointer to the Pre/PostApiNotify functions
//

typedef BOOL (WINAPIV * LPFNWSANOTIFY)(
    IN  INT    NotificationCode,
    OUT LPVOID ReturnCode,
    IN  LPSTR  LibraryName,
    ...);

//
// Function prototypes for Pre/PostApiNotify
//

BOOL WINAPIV
WSAPreApiNotify(
    IN  INT    NotificationCode,
    OUT LPVOID ReturnCode,
    IN  LPSTR  LibraryName,
    ...);

BOOL WINAPIV
WSAPostApiNotify(
    IN  INT    NotificationCode,
    OUT LPVOID ReturnCode,
    IN  LPSTR  LibraryName,
    ...);

//
// Pointer to an exception notification function.
//

typedef
VOID
(WINAPI * LPFNWSAEXCEPTIONNOTIFY)(
    IN LPEXCEPTION_POINTERS ExceptionPointers
    );

//
// Function prototype for exception notify.
//

VOID
WINAPI
WSAExceptionNotify(
    IN LPEXCEPTION_POINTERS ExceptionPointers
    );


//
// API function codes for Pre/PostApiNotify functions.  Note:  These must start
// at  1  or more and be fairly densely assigned.  Small gaps can be tolerated.
// Note  that  a  "MAX_DTCODE"  definition  should  be updated if new codes are
// added.
//

#define DTCODE_accept 1
#define DTCODE_bind 2
#define DTCODE_closesocket 3
#define DTCODE_connect 4
#define DTCODE_getpeername 5
#define DTCODE_getsockname 6
#define DTCODE_getsockopt 7
#define DTCODE_htonl 8
#define DTCODE_htons 9
#define DTCODE_ioctlsocket 10
#define DTCODE_listen 11
#define DTCODE_ntohl 12
#define DTCODE_ntohs 13
#define DTCODE_recv 14
#define DTCODE_recvfrom 15
#define DTCODE_select 16
#define DTCODE_send 17
#define DTCODE_sendto 18
#define DTCODE_setsockopt 19
#define DTCODE_shutdown 20
#define DTCODE_socket 21
#define DTCODE_WSAAccept 22
#define DTCODE_WSAAsyncSelect 23
#define DTCODE_WSACancelBlockingCall 24
#define DTCODE_WSACleanup 25
#define DTCODE_WSACloseEvent 26
#define DTCODE_WSAConnect 27
#define DTCODE_WSACreateEvent 28
#define DTCODE_WSADuplicateSocketA 29
#define DTCODE_WSAEnumNetworkEvents 30
#define DTCODE_WSAEnumProtocolsA 31
#define DTCODE_WSAEventSelect 32
#define DTCODE_WSAGetLastError 33
#define DTCODE_WSAGetOverlappedResult 34
#define DTCODE_WSAGetQOSByName 35
#define DTCODE_WSAHtonl 36
#define DTCODE_WSAHtons 37
#define DTCODE_WSAIoctl 38
#define DTCODE_WSAIsBlocking 39
#define DTCODE_WSAJoinLeaf 40
#define DTCODE_WSANtohl 41
#define DTCODE_WSANtohs 42
#define DTCODE_WSARecv 43
#define DTCODE_WSARecvDisconnect 44
#define DTCODE_WSARecvFrom 45
#define DTCODE_WSAResetEvent 46
#define DTCODE_WSASend 47
#define DTCODE_WSASendDisconnect 48
#define DTCODE_WSASendTo 49
#define DTCODE_WSASetBlockingHook 50
#define DTCODE_WSASetEvent 51
#define DTCODE_WSASetLastError 52
#define DTCODE_WSASocketA 53
#define DTCODE_WSAStartup 54
#define DTCODE_WSAUnhookBlockingHook 55
#define DTCODE_WSAWaitForMultipleEvents 56
#define DTCODE_gethostbyaddr 57
#define DTCODE_gethostbyname 58
#define DTCODE_gethostname 59
#define DTCODE_getprotobyname 60
#define DTCODE_getprotobynumber 61
#define DTCODE_getservbyname 62
#define DTCODE_getservbyport 63
#define DTCODE_inet_addr 64
#define DTCODE_inet_ntoa 65
#define DTCODE_WSAAsyncGetHostByAddr 66
#define DTCODE_WSAAsyncGetHostByName 67
#define DTCODE_WSAAsyncGetProtoByName 68
#define DTCODE_WSAAsyncGetProtoByNumber 69
#define DTCODE_WSAAsyncGetServByName 70
#define DTCODE_WSAAsyncGetServByPort 71
#define DTCODE_WSACancelAsyncRequest 72
#define DTCODE_WSPAccept 73
#define DTCODE_WSPAsyncSelect 74
#define DTCODE_WSPBind 75
#define DTCODE_WSPCancelBlockingCall 76
#define DTCODE_WSPCleanup 77
#define DTCODE_WSPCloseSocket 78
#define DTCODE_WSPConnect 79
#define DTCODE_WSPDuplicateSocket 80
#define DTCODE_WSPEnumNetworkEvents 81
#define DTCODE_WSPEventSelect 82
#define DTCODE_WSPGetOverlappedResult 83
#define DTCODE_WSPGetPeerName 84
// The  WSPGetProcTable  function  has  been removed, but the code numbers have
// been kept the same.
// #define DTCODE_WSPGetProcTable 85
#define DTCODE_WSPGetSockName 86
#define DTCODE_WSPGetSockOpt 87
#define DTCODE_WSPGetQOSByName 88
#define DTCODE_WSPIoctl 89
#define DTCODE_WSPJoinLeaf 90
#define DTCODE_WSPListen 91
#define DTCODE_WSPRecv 92
#define DTCODE_WSPRecvDisconnect 93
#define DTCODE_WSPRecvFrom 94
#define DTCODE_WSPSelect 95
#define DTCODE_WSPSend 96
#define DTCODE_WSPSendDisconnect 97
#define DTCODE_WSPSendTo 98
#define DTCODE_WSPSetSockOpt 99
#define DTCODE_WSPShutdown 100
#define DTCODE_WSPSocket 101
#define DTCODE_WSPStartup 102
#define DTCODE_WPUCloseEvent 103
#define DTCODE_WPUCloseSocketHandle 104
#define DTCODE_WPUCreateEvent 105
#define DTCODE_WPUCreateSocketHandle 106
#define DTCODE_WSCDeinstallProvider 107
#define DTCODE_WSCInstallProvider 108
#define DTCODE_WPUModifyIFSHandle 109
#define DTCODE_WPUQueryBlockingCallback 110
#define DTCODE_WPUQuerySocketHandleContext 111
#define DTCODE_WPUQueueApc 112
#define DTCODE_WPUResetEvent 113
#define DTCODE_WPUSetEvent 114
#define DTCODE_WSCEnumProtocols 115
#define DTCODE_WPUGetProviderPath 116
#define DTCODE_WPUPostMessage 117
#define DTCODE_WPUFDIsSet 118
#define DTCODE_WSADuplicateSocketW 119
#define DTCODE_WSAEnumProtocolsW 120
#define DTCODE_WSASocketW 121
#define DTCODE___WSAFDIsSet 122
#define DTCODE_WSAAddressToStringA 123
#define DTCODE_WSAAddressToStringW 124
#define DTCODE_WSAStringToAddressA 125
#define DTCODE_WSAStringToAddressW 126
#define DTCODE_WSALookupServiceBeginA 127
#define DTCODE_WSALookupServiceBeginW 128
#define DTCODE_WSALookupServiceNextA 129
#define DTCODE_WSALookupServiceNextW 130
#define DTCODE_WSALookupServiceEnd 131
//
// WSAGetAddressByName[AW] have been removed.
//
// #define DTCODE_WSAGetAddressByNameA 132
// #define DTCODE_WSAGetAddressByNameW 133
#define DTCODE_WSAInstallServiceClassA 134
#define DTCODE_WSAInstallServiceClassW 135
#define DTCODE_WSASetServiceA 136
#define DTCODE_WSASetServiceW 137
#define DTCODE_WSARemoveServiceClass 138
#define DTCODE_WSAGetServiceClassInfoA 139
#define DTCODE_WSAGetServiceClassInfoW 140
#define DTCODE_WSAEnumNameSpaceProvidersA 141
#define DTCODE_WSAEnumNameSpaceProvidersW 142
#define DTCODE_WSAGetServiceClassNameByClassIdA 143
#define DTCODE_WSAGetServiceClassNameByClassIdW 144
#define DTCODE_NSPAddressToString 145
#define DTCODE_NSPStringToAddress 146
#define DTCODE_NSPLookupServiceBegin 147
#define DTCODE_NSPLookupServiceNext 148
#define DTCODE_NSPLookupServiceEnd 149
#define DTCODE_NSPGetAddressByName 150
#define DTCODE_NSPInstallServiceClass 151
#define DTCODE_NSPSetService 152
#define DTCODE_NSPRemoveServiceClass 153
#define DTCODE_NSPGetServiceClassInfo 154
#define DTCODE_NSPEnumNameSpaceProviders 155
#define DTCODE_NSPGetServiceClassNameByClassId 156
#define DTCODE_WSCGetProviderPath 157
#define DTCODE_WSCInstallNameSpace 158
#define DTCODE_WSCUnInstallNameSpace 159
#define DTCODE_WSCEnableNSProvider 160
#define DTCODE_WSPAddressToString 161
#define DTCODE_WSPStringToAddress 162
#define DTCODE_WSANSPIoctl 163
#define DTCODE_NSPIoctl 164
#define DTCODE_WPUCompleteOverlappedRequest 165
#define DTCODE_WSAProviderConfigChange 166
#define DTCODE_WSCWriteProviderOrder 167
#define DTCODE_WSCWriteNameSpaceOrder 168
#define DTCODE_WSCUpdateProvider 169
#define DTCODE_getaddrinfo 170
#define DTCODE_getnameinfo 171
#define DTCODE_freeaddrinfo 172
#define DTCODE_NSPStartup 173
#define DTCODE_WPUOpenCurrentThread 174
#define DTCODE_WPUCloseThread 175
#ifdef _WIN64
#define DTCODE_WSCEnumProtocols32 176
#define DTCODE_WSCInstallProvider64_32 177
#define DTCODE_WSCDeinstallProvider32 178
#define DTCODE_WSCGetProviderPath32 179
#define DTCODE_WSCUpdateProvider32 180
#define DTCODE_WSCWriteProviderOrder32 181
#define DTCODE_WSCEnumNameSpaceProviders32 182
#define DTCODE_WSCInstallNameSpace32 183
#define DTCODE_WSCUnInstallNameSpace32 184
#define DTCODE_WSCEnableNSProvider32 185
#define DTCODE_WSCWriteNameSpaceOrder32 186
#endif // WIN64

#define DTCODE_GetAddrInfoW 187
#define DTCODE_NSPCleanup   188
#define DTCODE_GetNameInfoW 189
#define MAX_DTCODE DTCODE_GetNameInfoW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\inc\osdef.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    osdef.h

Abstract:

    This file contains miscellaneous operating system specific definitions.

Author:

    Keith Moore keithmo@microsoft.com   03-OCT-1995

Revision History:


--*/

#ifndef _OSDEF_
#define _OSDEF_


#include <ntverp.h>



//
// Winsock configuration registry root key name (lives under HKLM).
//

#define WINSOCK_REGISTRY_ROOT \
    "System\\CurrentControlSet\\Services\\WinSock2\\Parameters"


//
// Registry version info.
//

#define WINSOCK_REGISTRY_VERSION_NAME "WinSock_Registry_Version"
#define WINSOCK_REGISTRY_VERSION_VALUE "2.0"

#define WINSOCK_CURRENT_PROTOCOL_CATALOG_NAME "Current_Protocol_Catalog"
#define WINSOCK_CURRENT_NAMESPACE_CATALOG_NAME "Current_NameSpace_Catalog"


//
// Enable tracing on debug builds.
//

#if DBG
#define DEBUG_TRACING
#define TRACING
#define BUILD_TAG_STRING    "Windows NT " VER_PRODUCTVERSION_STR
#endif


#endif  // _OSDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\util\sporder\exe\catentry.c ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    catentry

Abstract:

    Read & write the relevant registry entries.

Author:

    Steve Firebaugh (stevefir)         14-Jan-1995

Revision History:

--*/


#include <windows.h>
#include <commdlg.h>
#include <winsock2.h>
#include <nspapi.h>
#include <stdio.h>

#include "ws2spi.h"
#include "sporder.h"
#include "globals.h"




#define MAX_ENTRIES 1000 // hack, make dynamic
WSAPROTOCOL_INFOW ProtoInfo[MAX_ENTRIES];

//
//  keep track of the total number of entries in the list box;
//

int gNumRows = 0;





int CatReadRegistry (HWND hwnd)
/*++

  Called once when the dialog first comes up.  Read the registry and fill
   the listbox with all of the entries.

--*/
{
    TCHAR szOutput[MAX_STR];
    TCHAR szInput[MAX_STR];
    TCHAR szBuffer[MAX_STR];
    LONG r;
    INT iIndex;
    DWORD dwSize;

    //
    // set a tab stop far off of the screen, so that we can store the original
    //  index there, and it will stay glued to the string even as the user
    //  reorders them (unless we are building a debug).
    //


#ifndef DEBUG
    {
    int iTab;

    iTab = 300;
    SendMessage (HWNDLISTCTL, LB_SETTABSTOPS, 1, (LPARAM) &iTab);
    }
#endif

    dwSize = sizeof (ProtoInfo);
    gNumRows = WSCEnumProtocols (NULL, ProtoInfo, &dwSize, &r);
    if (gNumRows==SOCKET_ERROR) {
        CatCheckRegErrCode (hwnd, r, TEXT("WSCEnumProtocols"));
        return FALSE;
    }

    for (iIndex = 0; iIndex<gNumRows ;iIndex++) {
        //
        // Now format a string for display in the list box.  Notice that
        //  we sneak an index in to the far right (not visible) to track
        //  the string's initial position (for purposes of mapping it to
        //  the gdwCatEntries later) regardless of re-ordering.
        //

        wsprintf (szBuffer,
                  TEXT("%ws \t%d \t%d"),
                  &ProtoInfo[iIndex].szProtocol,
                  iIndex,
                  ProtoInfo[iIndex].dwCatalogEntryId);
        ADDSTRING(szBuffer);




    } // end for

    return TRUE;
}



int CatDoMoreInfo (HWND hwnd, int iSelection)
/*++

  Given a dialog handle, and an index into our global array of catalog entries,
   fill a listbox with all of the information that we know about it.

--*/
{
    TCHAR szBuffer[MAX_STR];
    WCHAR szDllName[MAX_PATH];
    int iTab;
    int r;
    DWORD dwSize;
    BYTE pb[16];

    //
    // pick an arbitraty tab number that is far enough to the right to clear
    //  most of the long strings.
    //

    iTab = 90;
    SendMessage (HWNDLISTCTL, LB_SETTABSTOPS, 1, (LPARAM) &iTab);

    dwSize = sizeof (szDllName);
    if (WSCGetProviderPath (&ProtoInfo[iSelection].ProviderId, 
                                szDllName, 
                                &dwSize, 
                                &r)==SOCKET_ERROR) {
        CatCheckRegErrCode (hwnd, r, TEXT("WSCGetProviderPath"));
        return FALSE;
    }

    wsprintf (szBuffer, TEXT("LibraryPath \t%ls"), szDllName);       ADDSTRING (szBuffer);

    wsprintf (szBuffer, TEXT("dwServiceFlags1 \t0x%x"), ProtoInfo[iSelection].dwServiceFlags1);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwServiceFlags2 \t0x%x"), ProtoInfo[iSelection].dwServiceFlags2);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwServiceFlags3 \t0x%x"), ProtoInfo[iSelection].dwServiceFlags3);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwServiceFlags4 \t0x%x"), ProtoInfo[iSelection].dwServiceFlags4);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwProviderFlags \t0x%x"), ProtoInfo[iSelection].dwProviderFlags);       ADDSTRING (szBuffer);

    //
    // format GUID for display.  do byte swapping to match expected format
    //

    memcpy (pb, (PBYTE) &(ProtoInfo[iSelection].ProviderId), sizeof (GUID));

    wsprintf (szBuffer,
              TEXT("ProviderId \t%02x%02x%02x%02x - %02x%02x - %02x%02x - %02x%02x - %02x%02x%02x%02x%02x%02x"),
              (BYTE)pb[3],
              (BYTE)pb[2],
              (BYTE)pb[1],
              (BYTE)pb[0],
              (BYTE)pb[5],
              (BYTE)pb[4],
              (BYTE)pb[7],
              (BYTE)pb[6],
              (BYTE)pb[8],
              (BYTE)pb[9],
              (BYTE)pb[10],
              (BYTE)pb[11],
              (BYTE)pb[12],
              (BYTE)pb[13],
              (BYTE)pb[14],
              (BYTE)pb[15] );
              ADDSTRING (szBuffer);

    wsprintf (szBuffer, TEXT("dwCatalogEntryId \t0x%x"), ProtoInfo[iSelection].dwCatalogEntryId);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("ProtocolChain.ChainLen \t%d"), ProtoInfo[iSelection].ProtocolChain.ChainLen); ADDSTRING (szBuffer);

    wsprintf (szBuffer, TEXT("iVersion       \t0x%x"), ProtoInfo[iSelection].iVersion);       ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iAddressFamily \t0x%x"), ProtoInfo[iSelection].iAddressFamily); ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iMaxSockAddr   \t0x%x"), ProtoInfo[iSelection].iMaxSockAddr);   ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iMinSockAddr   \t0x%x"), ProtoInfo[iSelection].iMinSockAddr);   ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iSocketType    \t0x%x"), ProtoInfo[iSelection].iSocketType);    ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iProtocol      \t0x%x"), ProtoInfo[iSelection].iProtocol);      ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iProtocolMaxOffset \t0x%x"), ProtoInfo[iSelection].iProtocolMaxOffset);      ADDSTRING (szBuffer);

    wsprintf (szBuffer, TEXT("iNetworkByteOrder      \t0x%x"), ProtoInfo[iSelection].iNetworkByteOrder);      ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("iSecurityScheme      \t0x%x"), ProtoInfo[iSelection].iSecurityScheme);      ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwMessageSize      \t0x%x"), ProtoInfo[iSelection].dwMessageSize);      ADDSTRING (szBuffer);
    wsprintf (szBuffer, TEXT("dwProviderReserved      \t0x%x"), ProtoInfo[iSelection].dwProviderReserved);      ADDSTRING (szBuffer);

    wsprintf (szBuffer, TEXT("szProtocol \t%ws"), &ProtoInfo[iSelection].szProtocol);       ADDSTRING (szBuffer);

    return TRUE;
}



int  CatDoWriteEntries (HWND hwnd)
/*++

  Here we step through all of the entries in the list box, check to see if
   it is out of order, and if it is, write data to the registry key in that
   position.

--*/
{
    TCHAR szBuffer[MAX_STR];
    int iRegKey;
    int iIndex;
    int iCatID;

    LONG r;

    DWORD lpdwCatID[MAX_ENTRIES];

    //
    // Step through all of the registry keys (catalog entries).
    //  and build array of catalog IDs to be passed to function in sporder.dll
    //

    for (iRegKey = 0; iRegKey < gNumRows; iRegKey++ ) {

        SendMessage (HWNDLISTCTL, LB_GETTEXT, iRegKey, (LPARAM) szBuffer);

        ASSERT (CatGetIndex (szBuffer, &iIndex, &iCatID),
                TEXT("CatDoWriteEntries, CatGetIndex failed."));

        //
        // build array of CatalogIDs
        //

        lpdwCatID[iRegKey] = iCatID;

    } // for


    r = WSCWriteProviderOrder (lpdwCatID, gNumRows);
    CatCheckRegErrCode (hwnd, r, TEXT("WSCWriteProviderOrder"));
    return r;
}






int CatCheckRegErrCode (HWND hwnd, LONG r, LPTSTR lpstr)
/*++

  Centralize checking the return code for Registry functions.
   Here we report the error if any with as helpful a message as we can.

--*/
{
    static TCHAR szTitle[] = TEXT("Registry error in service provider tool.");
    TCHAR szBuffer[MAX_STR];

    switch (r) {
        case ERROR_SUCCESS: return TRUE;
        break;

        case ERROR_ACCESS_DENIED : {
            lstrcpy (szBuffer, TEXT("ERROR_ACCESS_DENIED\n"));
            lstrcat (szBuffer, TEXT("You do not have the necessary privilege to call:\n"));
            lstrcat (szBuffer, lpstr);
            lstrcat (szBuffer, TEXT("\nLogon as Administrator."));

            MessageBox (hwnd, szBuffer, szTitle, MB_ICONSTOP | MB_OK);
            return FALSE;
        } break;

        //
        // As Keith & Intel change the registry format, they rename keys
        //  to avoid backward compatibility problems.  If we can't find
        //  the registry key, it is likely this EXE old and running against
        //  a new (incompatible) version of ws2.
        //

        case ERROR_FILE_NOT_FOUND : {
            lstrcpy (szBuffer, TEXT("ERROR_FILE_NOT_FOUND\n"));
            lstrcat (szBuffer, TEXT("You probably need an updated version of this tool.\n"));
            lstrcat (szBuffer, lpstr);

            MessageBox (hwnd, szBuffer, szTitle, MB_ICONSTOP | MB_OK);
            return FALSE;
        } break;


        case WSAEINVAL: {
            lstrcpy (szBuffer, TEXT("WinSock2 Registry format doesn't match \n"));
            lstrcat (szBuffer, TEXT("sporder [exe/dll]. You need updated tools. \n"));
            lstrcat (szBuffer, lpstr);

            MessageBox (hwnd, szBuffer, szTitle, MB_ICONSTOP | MB_OK);
            return FALSE;
        } break;


        default: {
            FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           r,
                           GetUserDefaultLangID(),
                           szBuffer,
                           sizeof (szBuffer),
                           0);

            lstrcat (szBuffer, TEXT("\n"));
            lstrcat (szBuffer, lpstr);
            MessageBox (hwnd, szBuffer, szTitle, MB_ICONSTOP | MB_OK);
            return FALSE;
        } break;

    }
    return TRUE;
}



int CatDoUpDown (HWND hwnd, WPARAM wParam)
/*++

  Given a dialog handle, and an up/down identifier, remove the entry, and
   reinsert it either one position up or down.

--*/
{
    TCHAR szBuffer[MAX_STR];
    DWORD iSelection;

    iSelection = (DWORD)SendMessage (HWNDLISTCTL, LB_GETCURSEL, 0, 0);

    if (iSelection != LB_ERR) {

        //
        // Read the current selecte string, delete the current selection, ...
        //

        SendMessage (HWNDLISTCTL, LB_GETTEXT, iSelection, (LPARAM)szBuffer);
        SendMessage (HWNDLISTCTL, LB_DELETESTRING, iSelection, 0);

        //
        // Adjust the position up or down by one, and make sure we are
        //  still clipped to within the valid range.
        //

        if (wParam == DID_UP) iSelection--;
        else iSelection++;

        if ((int) iSelection < 0) iSelection = 0 ;
        if ((int) iSelection >= gNumRows) iSelection = gNumRows-1 ;

        //
        // Re-insert the string and restore the selection
        //

        SendMessage (HWNDLISTCTL, LB_INSERTSTRING, iSelection, (LPARAM)szBuffer);
        SendMessage (HWNDLISTCTL, LB_SETCURSEL, iSelection, 0);
    }
    return TRUE;
}




BOOL CatGetIndex (LPTSTR szBuffer, LPINT lpIndex, LPINT lpCatID)
/*++

  The original index is stored after a tab stop, hidden from view far off
   screen to the right.  Parse the string for the tab stop, and read the
   next value.  The catalog ID is stored to the right of the index.


--*/
{
    int r;
    TCHAR *p;

    //
    // To get the index, start at the begining of the string, parse
    //  it for tokens based on tab as a separator, and take the
    //  second one.
    //

#ifdef UNICODE
    p = wcstok (szBuffer, TEXT("\t"));
    p = wcstok (NULL, TEXT("\t"));
    r = swscanf (p, TEXT("%d"), lpIndex);
    ASSERT((r == 1), TEXT("#1 ASSERT r == 1"))
    p = wcstok (NULL, TEXT("\t"));
    r = swscanf (p, TEXT("%d"), lpCatID);
    ASSERT((r == 1), TEXT("#2 ASSERT r == 1"))
#else
    p = strtok (szBuffer, TEXT("\t"));
    p = strtok (NULL, TEXT("\t"));
    r = sscanf (p, TEXT("%d"), lpIndex);
    ASSERT((r == 1), TEXT("#1 ASSERT r == 1"))
    p = strtok (NULL, TEXT("\t"));
    r = sscanf (p, TEXT("%d"), lpCatID);
    ASSERT((r == 1), TEXT("#2 ASSERT r == 1"))
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\util\sporder\dll\dllmain.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    Main module for sporder.dll...  the 32-Bit Windows functions that are
    used to change the order or WinSock2 transport service providers and
    name space providers.

Revision History:

--*/

#include <windows.h>
#include <ws2spi.h>
#include <string.h>

#include "sporder.h"

#define MAX_ENTRIES 1000 // hack, make dynamic
void
_cdecl
MyDbgPrint(
    PSTR Format,
    ...
    )
{
    va_list arglist;
    char    OutputBuffer[1024];

    va_start (arglist, Format);
    wvsprintf (OutputBuffer, Format, arglist);
    va_end (arglist);
    OutputDebugString (OutputBuffer);
}

#if DBG
#define DBGOUT(args)    MyDbgPrint args
#else
#define DBGOUT(args)
#endif


typedef struct {
    GUID    ProviderId;
    char    DisplayString[MAX_PATH];
    DWORD   Enabled;
    char    LibraryPath[MAX_PATH];
    DWORD   StoresServiceClassInfo;
    DWORD   SupportedNameSpace;
    DWORD   Version;
} NSP_ITEM;

NSP_ITEM garNspCat[MAX_ENTRIES];
//
// hack, structure copied from winsock2\dll\winsock2\dcatitem.cpp.
//  code should eventually be common.
//

typedef struct {
    char            LibraryPath[MAX_PATH];
    // The unexpanded path where the provider DLL is found.

    WSAPROTOCOL_INFOW   ProtoInfo;
    // The  protocol information.  Note that if the WSAPROTOCOL_INFOW structure
    // is  ever changed to a non-flat structure (i.e., containing pointers)
    // then  this  type  definition  will  have  to  be changed, since this
    // structure must be strictly flat.

} PACKED_CAT_ITEM;

PACKED_CAT_ITEM garPackCat[MAX_ENTRIES];
DWORD garcbData[MAX_ENTRIES];


//
// When we first enumerate and read the child registry keys, store all of
//  those names for later use.
//

TCHAR pszKeyNames[MAX_ENTRIES][MAX_PATH];


//
// The name of the registry keys that we are interested in.
//

TCHAR pszBaseKey[]=                TEXT("SYSTEM\\CurrentControlSet\\Services\\WinSock2\\Parameters");
TCHAR pszProtocolCatalog[]=        TEXT("Protocol_Catalog9");
TCHAR pszNameSpaceCatalog[]=       TEXT("NameSpace_Catalog5");
TCHAR pszCurrentProtocolCatalog[]= TEXT("Current_Protocol_Catalog");
TCHAR pszCurrentNameSpaceCatalog[]=TEXT("Current_NameSpace_Catalog");
TCHAR pszCatalogEntries[]=         TEXT("Catalog_Entries");

TCHAR pszDisplayString[]=          TEXT("DisplayString");
TCHAR pszEnabled[]=                TEXT("Enabled");
TCHAR pszLibraryPath[]=            TEXT("LibraryPath");
TCHAR pszProviderId[]=             TEXT("ProviderId");
TCHAR pszStoresServiceClassInfo[]= TEXT("StoresServiceClassInfo");
TCHAR pszSupportedNameSpace[]=     TEXT("SupportedNameSpace");
TCHAR pszVersion[]=                TEXT("Version");

#define WS2_SZ_KEYNAME TEXT("PackedCatalogItem")


BOOL
WINAPI
DllMain (
    HANDLE hDLL,
    DWORD dwReason,
    LPVOID lpReserved)
/*++

    Obligatory main() routine for DLL.

--*/

{
    return TRUE;
}

int
WSPAPI
WSCWriteProviderOrder (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries)
/*++

Routine Description:

    Reorder existing WinSock2 service providers.  The order of the service
    providers determines their priority in being selected for use.  The
    sporder.exe tool will show you the installed provider and their ordering,
    Alternately, WSAEnumProtocols(), in conjunction with this function,
    will allow you to write your own tool.

Arguments:

    lpwdCatalogEntryId  [in]
      An array of CatalogEntryId elements as found in the WSAPROTOCOL_INFO
      structure.  The order of the CatalogEntryId elements is the new
      priority ordering for the service providers.

    dwNumberOfEntries  [in]
      The number of elements in the lpwdCatalogEntryId array.


Return Value:

    ERROR_SUCCESS   - the service providers have been reordered.
    WSAEINVAL       - input parameters were bad, no action was taken.
    WSATRY_AGAIN    - the routine is being called by another thread or process.
    any registry error code


Comments:

    Here are scenarios in which the WSCWriteProviderOrder function may fail:

      The dwNumberOfEntries is not equal to the number of registered service
      providers.

      The lpwdCatalogEntryId contains an invalid catalog ID.

      The lpwdCatalogEntryId does not contain all valid catalog IDs exactly
      1 time.

      The routine is not able to access the registry for some reason
      (e.g. inadequate user persmissions)

      Another process (or thread) is currently calling the routine.


--*/
{
    int  iIndex;
    int  iNumRegCatEntries;
    int  iWPOReturn;
    DWORD i,j;
    LONG r;
    HKEY hKey;
    HKEY hSubKey;
    DWORD dwBytes;
    DWORD dwType;
    TCHAR pszBuffer[MAX_PATH];
    TCHAR pszFinalKey[MAX_PATH];
    DWORD dwMapping[MAX_ENTRIES];
    DWORD dwDummy[MAX_ENTRIES];
    DWORD dwWait;
    HANDLE hMutex;
    static char pszMutextName[] = TEXT("sporder.dll");
    HMODULE hWS2_32;


    //
    // If WS2_32 is loaded (it is if it was used to load catalog 
    // in the first place), then try to use it to reoder entries.
    // Otherwise, use old hackish way of writing to the registry directly.
    //
    hWS2_32 = GetModuleHandle (TEXT ("WS2_32.DLL"));
    if (hWS2_32!=NULL) {
        LPWSCWRITEPROVIDERORDER  lpWSCWriteProviderOrder;
        lpWSCWriteProviderOrder = 
                (LPWSCWRITEPROVIDERORDER)GetProcAddress (
                                            hWS2_32,
                                            "WSCWriteProviderOrder");
        if (lpWSCWriteProviderOrder!=NULL) {
            //MyDbgPrint ("SPORDER: calling ws2_32!WSCWriteProviderOrder...\n");
            iWPOReturn = lpWSCWriteProviderOrder (
                                    lpwdCatalogEntryId,
                                    dwNumberOfEntries
                                    );

            return iWPOReturn;
        }
    }


    //
    // Set function return code equal to success
    //  (assume the best and wait to be proven otherwise)
    //

    iWPOReturn = ERROR_SUCCESS;

    //
    // Make sure that we can handle a request of this size.
    //  Hack, this code needs to be replaced by dynamic memory allocation.
    //

    if (dwNumberOfEntries > MAX_ENTRIES) {
        return WSA_NOT_ENOUGH_MEMORY;
    }

    //
    // Protect the code that modifies the registry with a mutex.
    //

    hMutex = CreateMutexA (NULL, FALSE, pszMutextName);
    if (hMutex==NULL) {
        return WSASYSCALLFAILURE;
    }

    dwWait = WaitForSingleObject (hMutex, 0);
    if (dwWait == WAIT_TIMEOUT)
    {
        DBGOUT((TEXT("WaitForSingleObject, WAIT_TIMEOUT\n")));
        iWPOReturn = WSATRY_AGAIN;
        goto closeMutex;
    }


    //
    // read catentry format & return error if mismatch
    //

    r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      pszBaseKey,
                      0,
                      KEY_QUERY_VALUE,
                      &hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegOpenKeyEx, pszBaseKey, failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }

    //
    // Read the current registry storage format being used by WinSock2.
    //  Compare with expected value, and return failure if wrong format.
    //

    dwBytes = sizeof (pszBuffer);
    r = RegQueryValueEx (hKey,
                       pszCurrentProtocolCatalog,
                       NULL,
                       &dwType,
                       (LPVOID) pszBuffer,
                       &dwBytes);

    RegCloseKey (hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegQueryValueEx, pszCurrentProtocolCatalog, failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }

    if (lstrcmp (pszProtocolCatalog, pszBuffer) != 0)
    {
        DBGOUT((TEXT("Wrong reg. format \n")));
        iWPOReturn = WSAEINVAL;
        goto releaseMutex;
    }


    //
    // Build the final registry key that has the actual catalogs in it
    //  pszBaseKey + \ + pszCurrentProtocolCatalog + \ + pszCatalogEntries
    //  and open it for enumeration
    //

    lstrcpy (pszFinalKey, pszBaseKey);
    lstrcat (pszFinalKey, TEXT("\\"));
    lstrcat (pszFinalKey, pszProtocolCatalog);
    lstrcat (pszFinalKey, TEXT("\\"));
    lstrcat (pszFinalKey, pszCatalogEntries);

    DBGOUT((pszFinalKey));
    DBGOUT((TEXT("\n")));

    r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      pszFinalKey,
                      0,
                      KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                      &hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegOpenKeyEx failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }


    //
    // The initial open succeeded, now enumerate registry keys
    //  until we don't get any more back
    //

    for (iIndex = 0; ;iIndex++)
    {
        TCHAR    pszSubKey[MAX_PATH];
        TCHAR    szFinalPlusSubKey[MAX_PATH];
        FILETIME ftDummy;
        DWORD    dwSize;

        if (iIndex>=MAX_ENTRIES) {
            DBGOUT((TEXT("iIndex>=MAX_ENTRIES\n")));
            iWPOReturn = WSAEINVAL;
            goto releaseMutex;
        }


        dwSize = MAX_PATH;
        pszSubKey[0]=0;
        r=RegEnumKeyEx (hKey,
                         iIndex,
                         pszSubKey,
                         &dwSize,
                         NULL,
                         NULL,
                         NULL,
                         &ftDummy);

        //
        // Once we have all of the keys, we'll get return code: no_more_items.
        //  close the handle, and exit for loop.
        //

        if (r == ERROR_NO_MORE_ITEMS)
        {
            iNumRegCatEntries = iIndex;
            RegCloseKey(hKey);
            break; // exit for loop
        }


        //
        // Check for other, unexpected error conditions
        //

        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("Unexpected Error \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }


        //
        // Build up the complete name of the subkey, store it away in
        //  pszKeyNames for future use, and then open the key.
        //

        lstrcpy (szFinalPlusSubKey, pszFinalKey);
        lstrcat (szFinalPlusSubKey, TEXT("\\"));
        lstrcat (szFinalPlusSubKey, pszSubKey);

        lstrcpy (&pszKeyNames[iIndex][0],szFinalPlusSubKey);
        r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                           szFinalPlusSubKey,
                           0,
                           KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                           &hSubKey);

        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("RegOpenKeyEx, Badly formated subkey \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }


        //
        // Finally, read the binary catalog entry data into our global array.
        //

        dwBytes = sizeof (PACKED_CAT_ITEM);
        dwType = REG_BINARY;
        r = RegQueryValueEx (hSubKey,
                           WS2_SZ_KEYNAME,
                           NULL,
                           &dwType,
                           (LPVOID) &garPackCat[iIndex],
                           &dwBytes);
        garcbData[iIndex]=dwBytes;


        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("RegQueryValueEx failed \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }

        RegCloseKey(hSubKey);

    } // end for


    //
    // compare dwNumberOfEntries w/ actual number & fail if wrong
    //

    if (iNumRegCatEntries != (int) dwNumberOfEntries)
    {
        DBGOUT((TEXT("iNumRegCatEntries != dwNumberOfEntries \n")));
        iWPOReturn = WSAEINVAL;
        goto releaseMutex;
    }


    //
    // verify that array passed in has same entries as actual list,
    //  and construct index mapping at the same time.  index mapping says
    //  that entry dwMapping[i] should be written to key number i.
    //
    // for array validation:
    //   step through actual list of catalog entries,
    //    set dummy to -1 if match
    //   check that dummy array is all -1 and fail if not true.
    //

    ZeroMemory (dwDummy, dwNumberOfEntries * sizeof (DWORD));
    ZeroMemory (dwMapping, dwNumberOfEntries * sizeof (DWORD));

    for (i = 0; i < dwNumberOfEntries ;i++)
    {
        for (j = 0; j< dwNumberOfEntries ;j++)
        {
            if (garPackCat[i].ProtoInfo.dwCatalogEntryId ==
                    lpwdCatalogEntryId[j])
            {
                  dwDummy[j] = (DWORD)-1;
                  dwMapping[j] = i;
            }
        }
    }

    for (j = 0; j< dwNumberOfEntries ;j++)
    {
        if (dwDummy[j] != (DWORD)-1)
        {
            iWPOReturn = WSAEINVAL;
            goto releaseMutex;
        }
    }

    //
    // Finally, all parameter validation is complete,
    //  and we've read all of the catalog entries.
    //
    // step through array passed in
    //  and if not equal, lookup pre-read entry, and write as registry key
    //

    for (i = 0; i < dwNumberOfEntries ;i++)
    {
        if (dwMapping[i] != i)
        {
            r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      &pszKeyNames[i][0],
                      0,
                      KEY_SET_VALUE,
                      &hKey);

            if (r != ERROR_SUCCESS)
            {
                DBGOUT((TEXT("RegOpenKeyEx, KEY_SET_VALUE failed \n")));
                iWPOReturn = r;
                goto releaseMutex;
            }

            r = RegSetValueEx (hKey,
                               WS2_SZ_KEYNAME,
                               0,
                               REG_BINARY,
                               (LPVOID) &garPackCat[dwMapping[i]],
                               garcbData[i]);

            if (r != ERROR_SUCCESS)
            {
                DBGOUT((TEXT("RegSetValueEx failed \n")));
                iWPOReturn = r;
                goto releaseMutex;
            }

            RegCloseKey(hKey);

            DBGOUT((TEXT("wrote entry %d in location %d \n"), dwMapping[i], i));
        }
    }


    //
    // Release Mutex, close handle, and return.
    //  Notice that this function MUST return only from here at the
    //  end so that we are certain to release the mutex.
    //

releaseMutex:
    ReleaseMutex (hMutex);
closeMutex:
    CloseHandle (hMutex);

    return iWPOReturn;
}


LONG
ReadNamspaceRegistry(
    HKEY hKey,
    NSP_ITEM *pItem
)
{
    LONG r;
    HKEY hSubKey;
    DWORD dwBytes;
    DWORD dwType;

    dwBytes = sizeof(pItem->DisplayString);
    r = RegQueryValueEx(hKey,
                        pszDisplayString,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->DisplayString,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszDisplayString, failed \n")));
        return r;
    }

    dwBytes = sizeof(pItem->Enabled);
    r = RegQueryValueEx(hKey,
                        pszEnabled,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->Enabled,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszEnabled, failed \n")));
        return r;
    }

    dwBytes = sizeof(pItem->LibraryPath);
    r = RegQueryValueEx(hKey,
                        pszLibraryPath,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->LibraryPath,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszLibraryPath, failed \n")));
        return r;
    }


    dwBytes = sizeof(pItem->ProviderId);
    r = RegQueryValueEx(hKey,
                        pszProviderId,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->ProviderId,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszProviderId, failed \n")));
        return r;
    }

    dwBytes = sizeof(pItem->StoresServiceClassInfo);
    r = RegQueryValueEx(hKey,
                        pszStoresServiceClassInfo,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->StoresServiceClassInfo,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszStoresServiceClassInfo, failed \n")));
        return r;
    }

    dwBytes = sizeof(pItem->SupportedNameSpace);
    r = RegQueryValueEx(hKey,
                        pszSupportedNameSpace,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->SupportedNameSpace,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszSupportedNameSpace, failed \n")));
        return r;
    }

    dwBytes = sizeof(pItem->Version);
    r = RegQueryValueEx(hKey,
                        pszVersion,
                        NULL,
                        &dwType,
                        (LPVOID) &pItem->Version,
                        &dwBytes);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegQueryValueEx, pszVersion, failed \n")));
        return r;
    }

    return ERROR_SUCCESS;
}

#define GUIDEQUAL(Guid1, Guid2)                     \
       ( (Guid1)->Data1 == (Guid2)->Data1 &&        \
         (Guid1)->Data2 == (Guid2)->Data2 &&        \
         (Guid1)->Data3 == (Guid2)->Data3 &&        \
         (Guid1)->Data4[0] == (Guid2)->Data4[0] &&  \
         (Guid1)->Data4[1] == (Guid2)->Data4[1] &&  \
         (Guid1)->Data4[2] == (Guid2)->Data4[2] &&  \
         (Guid1)->Data4[3] == (Guid2)->Data4[3] &&  \
         (Guid1)->Data4[4] == (Guid2)->Data4[4] &&  \
         (Guid1)->Data4[5] == (Guid2)->Data4[5] &&  \
         (Guid1)->Data4[6] == (Guid2)->Data4[6] &&  \
         (Guid1)->Data4[7] == (Guid2)->Data4[7] )


LONG
WriteNameSpaceRegistry(
    HKEY hKey,
    NSP_ITEM *pItem
)
{
    LONG r;
    HKEY hSubKey;

    r = RegSetValueEx (hKey,
                       pszDisplayString,
                       0,
                       REG_SZ,
                       (LPVOID) &pItem->DisplayString,
                       lstrlen(pItem->DisplayString) + 1);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszEnabled,
                       0,
                       REG_DWORD,
                       (LPVOID) &pItem->Enabled,
                       sizeof(DWORD));

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszLibraryPath,
                       0,
                       REG_SZ,
                       (LPVOID) &pItem->LibraryPath,
                       lstrlen(pItem->LibraryPath) + 1);

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszProviderId,
                       0,
                       REG_BINARY,
                       (LPVOID) &pItem->ProviderId,
                       sizeof(pItem->ProviderId));

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszStoresServiceClassInfo,
                       0,
                       REG_DWORD,
                       (LPVOID) &pItem->StoresServiceClassInfo,
                       sizeof(DWORD));

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszSupportedNameSpace,
                       0,
                       REG_DWORD,
                       (LPVOID) &pItem->SupportedNameSpace,
                       sizeof(DWORD));

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    r = RegSetValueEx (hKey,
                       pszVersion,
                       0,
                       REG_DWORD,
                       (LPVOID) &pItem->Version,
                       sizeof(DWORD));

    if (r != ERROR_SUCCESS) {
        DBGOUT((TEXT("RegSetValueEx failed \n")));
        return r;
    }

    return r;
}


int
WSPAPI
WSCWriteNameSpaceOrder (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries)
/*++


--*/
{
    int  iIndex;
    int  iNumRegCatEntries;
    int  iWPOReturn;
    DWORD i,j;
    LONG r;
    HKEY hKey;
    HKEY hSubKey;
    DWORD dwBytes;
    DWORD dwType;
    TCHAR pszBuffer[MAX_PATH];
    TCHAR pszFinalKey[MAX_PATH];
    DWORD dwMapping[MAX_ENTRIES];
    DWORD dwDummy[MAX_ENTRIES];
    DWORD dwWait;
    HANDLE hMutex;
    static char pszMutextName[] = TEXT("sporder.dll");
    HMODULE hWS2_32;


    //
    // If WS2_32 is loaded (it is if it was used to load catalog 
    // in the first place), then try to use it to reoder entries.
    // Otherwise, use old hackish way of writing to the registry directly.
    //
    hWS2_32 = GetModuleHandle (TEXT ("WS2_32.DLL"));
    if (hWS2_32!=NULL) {
        LPWSCWRITENAMESPACEORDER lpWSCWriteNameSpaceOrder;
        lpWSCWriteNameSpaceOrder =
                (LPWSCWRITENAMESPACEORDER)GetProcAddress (
                                            hWS2_32,
                                            "WSCWriteNameSpaceOrder");
        if (lpWSCWriteNameSpaceOrder!=NULL) {
            //MyDbgPrint ("SPORDER: calling ws2_32!WSCWriteNameSpaceOrder...\n");
            iWPOReturn = lpWSCWriteNameSpaceOrder (
                                    lpProviderId,
                                    dwNumberOfEntries
                                    );

            return iWPOReturn;
        }
    }
    //
    // Set function return code equal to success
    //  (assume the best and wait to be proven otherwise)
    //

    iWPOReturn = ERROR_SUCCESS;

    //
    // Make sure that we can handle a request of this size.
    //  Hack, this code needs to be replaced by dynamic memory allocation.
    //

    if ( dwNumberOfEntries > MAX_ENTRIES)
        return WSA_NOT_ENOUGH_MEMORY;

    //
    // Protect the code that modifies the registry with a mutex.
    //

    hMutex = CreateMutexA (NULL, FALSE, pszMutextName);
    if (hMutex==NULL) {
        return WSASYSCALLFAILURE;
    }

    dwWait = WaitForSingleObject (hMutex, 0);
    if (dwWait == WAIT_TIMEOUT)
    {
        DBGOUT((TEXT("WaitForSingleObject, WAIT_TIMEOUT\n")));
        iWPOReturn = ERROR_BUSY;
        goto closeMutex;
    }


    //
    // read catentry format & return error if mismatch
    //

    r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      pszBaseKey,
                      0,
                      KEY_QUERY_VALUE,
                      &hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegOpenKeyEx, pszBaseKey, failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }

    //
    // Read the current registry storage format being used by WinSock2.
    //  Compare with expected value, and return failure if wrong format.
    //

    dwBytes = sizeof (pszBuffer);
    r = RegQueryValueEx (hKey,
                       pszCurrentNameSpaceCatalog,
                       NULL,
                       &dwType,
                       (LPVOID) pszBuffer,
                       &dwBytes);

    RegCloseKey (hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegQueryValueEx, pszCurrentNameSpaceCatalog, failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }

    if (lstrcmp (pszNameSpaceCatalog, pszBuffer) != 0)
    {
        DBGOUT((TEXT("Wrong reg. format \n")));
        iWPOReturn = WSAEINVAL;
        goto releaseMutex;
    }


    //
    // Build the final registry key that has the actual catalogs in it
    //  pszBaseKey + \ + pszCurrentNameSpaceCatalog + \ + pszCatalogEntries
    //  and open it for enumeration
    //

    lstrcpy (pszFinalKey, pszBaseKey);
    lstrcat (pszFinalKey, TEXT("\\"));
    lstrcat (pszFinalKey, pszNameSpaceCatalog);
    lstrcat (pszFinalKey, TEXT("\\"));
    lstrcat (pszFinalKey, pszCatalogEntries);

    DBGOUT((pszFinalKey));
    DBGOUT((TEXT("\n")));

    r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      pszFinalKey,
                      0,
                      KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                      &hKey);

    if (r != ERROR_SUCCESS)
    {
        DBGOUT((TEXT("RegOpenKeyEx failed \n")));
        iWPOReturn = r;
        goto releaseMutex;
    }


    //
    // The initial open succeeded, now enumerate registry keys
    //  until we don't get any more back
    //

    for (iIndex = 0; ;iIndex++)
    {
        TCHAR    pszSubKey[MAX_PATH];
        TCHAR    szFinalPlusSubKey[MAX_PATH];
        FILETIME ftDummy;
        DWORD    dwSize;

        if (iIndex>=MAX_ENTRIES) {
            DBGOUT((TEXT("iIndex>=MAX_ENTRIES\n")));
            iWPOReturn = WSAEINVAL;
            goto releaseMutex;
        }

        dwSize = MAX_PATH;
        pszSubKey[0]=0;
        r=RegEnumKeyEx (hKey,
                         iIndex,
                         pszSubKey,
                         &dwSize,
                         NULL,
                         NULL,
                         NULL,
                         &ftDummy);

        //
        // Once we have all of the keys, we'll get return code: no_more_items.
        //  close the handle, and exit for loop.
        //

        if (r == ERROR_NO_MORE_ITEMS)
        {
            iNumRegCatEntries = iIndex;
            RegCloseKey(hKey);
            break; // exit for loop
        }


        //
        // Check for other, unexpected error conditions
        //

        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("Unexpected Error \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }


        //
        // Build up the complete name of the subkey, store it away in
        //  pszKeyNames for future use, and then open the key.
        //

        lstrcpy (szFinalPlusSubKey, pszFinalKey);
        lstrcat (szFinalPlusSubKey, TEXT("\\"));
        lstrcat (szFinalPlusSubKey, pszSubKey);

        lstrcpy (&pszKeyNames[iIndex][0],szFinalPlusSubKey);
        r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                           szFinalPlusSubKey,
                           0,
                           KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                           &hSubKey);

        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("RegOpenKeyEx, Badly formated subkey \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }


        //
        // Finally, read the binary catalog entry data into our global array.
        //

        dwBytes = sizeof (PACKED_CAT_ITEM);
        dwType = REG_BINARY;
        r = ReadNamspaceRegistry (hSubKey,
                                  &garNspCat[iIndex]);

        if (r != ERROR_SUCCESS)
        {
            DBGOUT((TEXT("ReadNamspaceRegistry failed \n")));
            iWPOReturn = r;
            goto releaseMutex;
        }

        RegCloseKey(hSubKey);

    } // end for


    //
    // compare dwNumberOfEntries w/ actual number & fail if wrong
    //

    if (iNumRegCatEntries != (int) dwNumberOfEntries)
    {
        DBGOUT((TEXT("iNumRegCatEntries != dwNumberOfEntries \n")));
        iWPOReturn = WSAEINVAL;
        goto releaseMutex;
    }


    //
    // verify that array passed in has same entries as actual list,
    //  and construct index mapping at the same time.  index mapping says
    //  that entry dwMapping[i] should be written to key number i.
    //
    // for array validation:
    //   step through actual list of catalog entries,
    //    set dummy to -1 if match
    //   check that dummy array is all -1 and fail if not true.
    //

    ZeroMemory (dwDummy, dwNumberOfEntries * sizeof (DWORD));
    ZeroMemory (dwMapping, dwNumberOfEntries * sizeof (DWORD));

    for (i = 0; i < dwNumberOfEntries ;i++)
    {
        for (j = 0; j< dwNumberOfEntries ;j++)
        {
            if (GUIDEQUAL(&garNspCat[i].ProviderId, &lpProviderId[j]))
            {
                  dwDummy[j] = (DWORD)-1;
                  dwMapping[j] = i;
            }
        }
    }

    for (j = 0; j< dwNumberOfEntries ;j++)
    {
        if (dwDummy[j] != (DWORD)-1)
        {
            iWPOReturn = WSAEINVAL;
            goto releaseMutex;
        }
    }

    //
    // Finally, all parameter validation is complete,
    //  and we've read all of the catalog entries.
    //
    // step through array passed in
    //  and if not equal, lookup pre-read entry, and write as registry key
    //

    for (i = 0; i < dwNumberOfEntries ;i++)
    {
        if (dwMapping[i] != i)
        {
            r = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      &pszKeyNames[i][0],
                      0,
                      KEY_SET_VALUE,
                      &hKey);

            if (r != ERROR_SUCCESS)
            {
                DBGOUT((TEXT("RegOpenKeyEx, KEY_SET_VALUE failed \n")));
                iWPOReturn = r;
                goto releaseMutex;
            }

            r = WriteNameSpaceRegistry(hKey, &garNspCat[dwMapping[i]]);


            if (r != ERROR_SUCCESS)
            {
                DBGOUT((TEXT("RegSetValueEx failed \n")));
                iWPOReturn = r;
                goto releaseMutex;
            }

            RegCloseKey(hKey);

            DBGOUT((TEXT("wrote entry %d in location %d \n"), dwMapping[i], i));
        }
    }


    //
    // Release Mutex, close handle, and return.
    //  Notice that this function MUST return only from here at the
    //  end so that we are certain to release the mutex.
    //

releaseMutex:
    ReleaseMutex (hMutex);
closeMutex:
    CloseHandle (hMutex);

    return iWPOReturn;
}



#if DBG
void
_cdecl
DbgPrint(
    PTCH Format,
    ...
    )
/*++

  Write debug output messages if compiled with DEBUG

--*/
{
    TCHAR buffer[MAX_PATH];

    va_list marker;
    va_start (marker,Format);
    wvsprintf (buffer,Format, marker);
    OutputDebugString (TEXT("SPORDER: "));
    OutputDebugString (buffer);

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\util\sporder\exe\globals.h ===
#include <commctrl.h>


//
// Global variables
//

extern HINSTANCE ghInst;
extern int listTabs[];
extern int gNumRows;


//
// Function prototypes
//

INT_PTR CALLBACK EnumDlgProc     (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK SortDlgProc     (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK MoreInfoDlgProc (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK RNRDlgProc      (HWND, UINT, WPARAM, LPARAM);

int CatReadRegistry    (HWND);
int CatDoMoreInfo      (HWND, int);
int CatDoWriteEntries  (HWND);
int CatCheckRegErrCode (HWND, LONG, LPTSTR);
int CatDoUpDown        (HWND, WPARAM);
BOOL CatGetIndex (LPTSTR, LPINT, LPINT);


//
// Constant defines
//

#define DID_HEADERCTL  501
#define DID_LISTCTL    502
#define DID_UP         503
#define DID_DOWN       504
#define DID_MORE       505

#define DID_ENUM       700
#define DID_WSAENUM    701

#define TOTAL_TABS 10

#define MAX_STR 256


//
// Helpful macros
//

//
// In the context of a dialog box with a child listbox id==DID_LISTCTL...
//
#define ADDSTRING(x)   SendMessage (GetDlgItem (hwnd, DID_LISTCTL), LB_ADDSTRING, 0 ,(LPARAM) x)
#define HWNDLISTCTL    GetDlgItem (hwnd, DID_LISTCTL)

#define ASSERT(X,Y) if (!X) MessageBox (NULL, Y, TEXT("ASSERT"), MB_OK);

#define XBORDER   GetSystemMetrics (SM_CXSIZEFRAME) *3/2
#define YBORDER   GetSystemMetrics (SM_CYSIZEFRAME) *3/2
#define HDRHEIGHT GetSystemMetrics (SM_CYMENU)


//
// Simple debug output routine that becomes no-op when ndef DEBUG
//

#ifdef DEBUG
#else
#endif

#if DBG

#define DBGOUT(arg) DbgPrint arg

void
_cdecl
DbgPrint(
    PTCH Format,
    ...
    );

#else

#define DBGOUT(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\util\sporder\exe\dlgproc.c ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    dlgproc

Abstract:

    The dialog procedures for the different tabs in the main dialog.

Author:

    Steve Firebaugh (stevefir)         31-Dec-1995

Revision History:

--*/


#include <windows.h>
#include <commdlg.h>
#include <winsock2.h>
#include <nspapi.h>
#include "globals.h"


//
// Keep a dirty bit for the ordering of the service providers.  Set it if
//  the order changes, clear it if we push apply.
//

int gDirty = FALSE;



INT_PTR CALLBACK SortDlgProc(HWND hwnd,
                             UINT message,
                             WPARAM wParam,
                             LPARAM ppsp)
/*++

  This is the main dialog proc for the window that lists all of the service
   providers and lets the user push them up and down.

  Uses GLOBAL:  gNumRows

--*/
{
    int iSelection;

    switch (message) {

      case WM_INITDIALOG:
          CatReadRegistry (hwnd);
          SendMessage (GetDlgItem (hwnd, DID_LISTCTL), LB_SETCURSEL, 0, 0);
          return FALSE;
      break;


      case WM_NOTIFY: {
          NMHDR * pnmhdr;
          pnmhdr = (NMHDR *) ppsp;

          if (pnmhdr->code == PSN_APPLY) {
              if (gDirty)
                  if ( IDYES == MessageBox (hwnd,
                                        TEXT("This operation may change the behavior of the networking components on your system.\nDo you wish to continue?"),
                                        TEXT("Warning:"),
                                        MB_ICONWARNING | MB_YESNO)) {
                      CatDoWriteEntries (hwnd);
                      gDirty = FALSE;
                  }

          }



      } break;


      case WM_COMMAND:
        switch (LOWORD (wParam)) {

          //
          // On the up & down buttons, screen out the no-ops (up on top row,
          //  or down on bottom), reorder the catalog entries, and set the
          //  dirty bit.
          //

          case DID_UP: {
              iSelection = (int)SendMessage (HWNDLISTCTL, LB_GETCURSEL, 0, 0);
              if (iSelection ==  0) return FALSE;

              CatDoUpDown (hwnd, LOWORD (wParam));
              SendMessage (GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
              gDirty = TRUE;
          } break;


          case DID_DOWN: {
              iSelection = (int)SendMessage (HWNDLISTCTL, LB_GETCURSEL, 0, 0);
              if (iSelection ==  (gNumRows-1)) return FALSE;

              CatDoUpDown (hwnd, LOWORD (wParam));
              SendMessage (GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
              gDirty = TRUE;
          } break;

          //
          // If the listbox is double clicked, re-send the message as if it
          //  was a more-info button press.  If it is a selection change, then
          //  set the state of the buttons appropriately.
          //

          case DID_LISTCTL:
              if (HIWORD (wParam) == LBN_DBLCLK)
                  SendMessage (hwnd, WM_COMMAND, DID_MORE, 0);
              else if (HIWORD (wParam) == LBN_SELCHANGE) {

              // here we can enable/disable buttons...
              //  not implemented yet

              }

          break;

          //
          // If they request more information, figure out which item is selected,
          //  then map that to an index value from the initial ordering.  Finally
          //  popup a dialog that will show the information from the catalog at
          //  that index.
          //

          case DID_MORE: {
              int iIndex;
              int notUsed;
              TCHAR szBuffer[MAX_STR];

              iSelection = (int)SendMessage (HWNDLISTCTL, LB_GETCURSEL, 0, 0);

              if (iSelection != LB_ERR) {

                  //
                  // Dig the chosen string out of the listbox, find the original
                  //  index hidden in it, and popup the more information dialog
                  //  for the appropriate entry.
                  //

                  SendMessage (HWNDLISTCTL, LB_GETTEXT, iSelection, (LPARAM) szBuffer);

                  ASSERT (CatGetIndex (szBuffer, &iIndex, &notUsed),
                          TEXT("SortDlgProc, CatGetIndex failed."));

                  DialogBoxParam (ghInst,
                                  TEXT("MoreInfoDlg"),
                                  hwnd,
                                  MoreInfoDlgProc,
                                  iIndex);

              }
          } break;
        }
      break; // WM_COMMAND
    } // end switch
    return FALSE;
}


INT_PTR CALLBACK MoreInfoDlgProc(HWND hwnd,
                              UINT message,
                              WPARAM wParam,
                              LPARAM lParam)
/*++

  This is the window proc for the simple "more info" dialog.  All that we
   do here is fill our listbox with interesting info on wm_initdialog, and
   then wait to be dismissed.

--*/
{

  switch (message) {

    case WM_INITDIALOG:
       CatDoMoreInfo (hwnd, (int) lParam);
    break;


    case WM_COMMAND:
      if (wParam == IDCANCEL)
        EndDialog (hwnd, FALSE);

      if (wParam == IDOK)
        EndDialog (hwnd, TRUE);
    break;

    case WM_SYSCOMMAND:
      if (wParam == SC_CLOSE)
        EndDialog (hwnd, TRUE);
    break;


  } // end switch
  return FALSE;
}



INT_PTR CALLBACK RNRDlgProc(HWND hwnd,
                            UINT message,
                            WPARAM wParam,
                            LPARAM lParam)
/*++

  For this version, simply list the installed providers.

--*/
{

  switch (message) {

    case WM_INITDIALOG: {

    //
    // at init time, query all of the installed name space providers
    //  and put their identifier in the listbox.  Notice. that this
    //  function assumes WSAStartup has already been called.
    //

#define MAX_NAMESPACE 100  // hack, arbitrary value, should be dynamic
      WSANAMESPACE_INFO  arnspBuf[MAX_NAMESPACE];
      DWORD dwBufLen;
      int   i, r;
      int   iTab = 50;

      SendMessage (HWNDLISTCTL, LB_SETTABSTOPS, 1, (LPARAM) &iTab);

      //
      // Call the WinSock2 name space enumeration function with enough
      //  free space such that we expect to get all of the information.
      //

      dwBufLen = sizeof (arnspBuf);
      r = WSAEnumNameSpaceProviders(&dwBufLen, arnspBuf);
      if ( r == SOCKET_ERROR) {
        DBGOUT((TEXT("WSAEnumNameSpaceProviders failed w/ %d\n"), WSAGetLastError()));
        return (INT_PTR)-1;
      }


      //
      // WSAEnumNameSpaceProviders succeeded so write results to listbox
      //

      for (i = 0; i< r; i++) {
        ADDSTRING(arnspBuf[i].lpszIdentifier);
      }

    } break;

  } // end switch
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2help\precomp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file for the WinSock 2.0 helper DLL.

Author:

    Keith Moore (keithmo)       08-Nov-1995

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#if defined(_WS2HELP_W4_)

    //
    // Safe /W4 warnings to disable:
    //

    #pragma warning(disable:4055)   // type cast from data pointer to function pointer
    #pragma warning(disable:4127)   // condition expression is constant
    #pragma warning(disable:4152)   // function/data pointer conversion
    #pragma warning(disable:4201)   // nameless struct/union
    #pragma warning(disable:4214)   // bit field types other than int

    //
    // Extra initialization to allow compiler check for use of uninitialized
    // variables at w4 level.  Currently this mostly affects status set
    // inside of the exception filter as follows:
    //      __try {} __except (status=1,EXCEPTION_EXECUTE_HANDLER) { NT_ERROR (status)}
    // NT_ERROR(status) - generates uninitialized variable warning and it shouldn't
    //

    #define WS2HELP_W4_INIT

#else

    #define WS2HELP_W4_INIT if (FALSE)

#endif // defined(_WS2HELP_W4_)


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <malloc.h>


#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <windows.h>
#include <tchar.h>
#include <ws2spi.h>
#include <ws2help.h>


#include <tdi.h>
#include <afd.h>

#if DBG
#define DBG_FAILURES        0x80000000
#define DBG_PROCESS         0x40000000
#define DBG_SOCKET          0x20000000
#define DBG_COMPLETE        0x10000000
#define DBG_APC_THREAD      0x08000000
#define DBG_WINSOCK_APC     0x04000000
#define DBG_REQUEST			0x02000000
#define DBG_CANCEL          0x01000000
#define DBG_DRIVER_READ		0x00800000
#define DBG_DRIVER_WRITE	0x00400000
#define DBG_DRIVER_SEND		0x00200000
#define DBG_DRIVER_RECV		0x00100000
#define DBG_SERVICE         0x00080000
#define DBG_NOTIFY          0x00040000

#define WS2IFSL_DEBUG_KEY   "System\\CurrentControlSet\\Services\\Ws2IFSL\\Parameters\\ProcessDebug"
extern DWORD       PID;
extern ULONG       DbgLevel;
extern VOID        ReadDbgInfo (VOID);

#define WshPrint(COMPONENT,ARGS)	\
	do {						    \
		if (DbgLevel&COMPONENT){    \
			DbgPrint ARGS;		    \
		}						    \
	} while (0)
//
// Define an assert that actually works even on a free build.
//

#define WS_ASSERT(exp)                                              \
        ((exp)                                                      \
            ? 0                                                     \
            : (DbgPrint( "\n*** Assertion failed: %s\n"             \
                        "***   Source File: %s, line %ld\n\n",      \
                    #exp,__FILE__, __LINE__), (DbgBreakPoint(), 1)))



#else
#define WshPrint(COMPONENT,ARGS) do {NOTHING;} while (0)
#define WS_ASSERT(exp)
#endif

extern HINSTANCE            LibraryHdl;
extern PSECURITY_DESCRIPTOR pSDPipe;
extern CRITICAL_SECTION     StartupSyncronization;
extern BOOL                 Ws2helpInitialized;
extern HANDLE               ghWriterEvent;
DWORD
Ws2helpInitialize (
    VOID
    );

#define ENTER_WS2HELP_API()                                         \
    (Ws2helpInitialized ? 0 : Ws2helpInitialize())

VOID
NewCtxInit (
    VOID
    );

#include <ws2ifsl.h>

#define ALLOC_MEM(cb)       (LPVOID)GlobalAlloc(                    \
                                GPTR,                               \
                                (cb)                                \
                                )

#define REALLOC_MEM(p,cb)   (LPVOID)GlobalReAlloc(                  \
                                (HGLOBAL)(p),                       \
                                (cb),                               \
                                (GMEM_MOVEABLE | GMEM_ZEROINIT)     \
                                )

#define FREE_MEM(p)         (VOID)GlobalFree(                       \
                                (HGLOBAL)(p)                        \
                                )

#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\inc\ws2ifsl.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    WS2IFSL.H

Abstract:

    This module defines interface for Winsock2 IFS transport layer driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

#ifndef _WS2IFSL_
#define _WS2IFSL_

// Macro to align address data in the output buffer
#define ADDR_ALIGN(sz)  (((sz)+1)&(~3))

// Parameters for IOCTL_WS2IFSL_RETRIEVE_DRV_REQ
typedef struct _WS2IFSL_RTRV_PARAMS {
    IN ULONG                    UniqueId;       // Unique ID
    OUT PVOID                   DllContext;     // Context associated by dll
                                                // with the socket file.
	OUT ULONG				    RequestType;    // Request type
#define WS2IFSL_REQUEST_READ            0
#define WS2IFSL_REQUEST_WRITE           1
#define WS2IFSL_REQUEST_SENDTO          2
#define WS2IFSL_REQUEST_RECV            3
#define WS2IFSL_REQUEST_RECVFROM        4
#define WS2IFSL_REQUEST_QUERYHANDLE     5
    OUT ULONG                   DataLen;        // Length of data/buffer
    OUT ULONG                   AddrLen;        // Length of addr/buffer
    OUT ULONG                   Flags;          // Flags
} WS2IFSL_RTRV_PARAMS, *PWS2IFSL_RTRV_PARAMS;

// Parameters for IOCTL_WS2IFSL_COMPLETE_DRV_REQ
typedef struct _WS2IFSL_CMPL_PARAMS {
    IN HANDLE                   SocketHdl;      // Handle of socket object
    IN ULONG                    UniqueId;       // Unique ID
    IN ULONG                    DataLen;        // Length of data to copy/report
    IN ULONG                    AddrLen;        // Length of addr to copy and report
    IN NTSTATUS                 Status;         // Completion status
} WS2IFSL_CMPL_PARAMS, *PWS2IFSL_CMPL_PARAMS;

// Parameters for IOCTL_WS2IFSL_COMPLETE_DRV_CAN
typedef struct _WS2IFSL_CNCL_PARAMS {
    IN ULONG                    UniqueId;       // Unique ID
} WS2IFSL_CNCL_PARAMS, *PWS2IFSL_CNCL_PARAMS;

// Socket context parameters
typedef struct _WS2IFSL_SOCKET_CTX {
	PVOID					DllContext;     // Context value to be associated
                                            // with the socket
	HANDLE					ProcessFile;    // Process file handle for the
                                            // current process
} WS2IFSL_SOCKET_CTX, *PWS2IFSL_SOCKET_CTX;

// Process context parameters
typedef struct _WS2IFSL_PROCESS_CTX {
    HANDLE                  ApcThread;      // Thread to queue APC's to
    PPS_APC_ROUTINE         RequestRoutine; // APC routine to pass requests
    PPS_APC_ROUTINE         CancelRoutine;  // APC routine to pass cancel
    PVOID                   ApcContext;     // Apc routine context
    ULONG                   DbgLevel;       // Used only in debug builds,
                                            // (0 on free DLL builds and ignored
                                            // by the free driver)
} WS2IFSL_PROCESS_CTX, *PWS2IFSL_PROCESS_CTX;



// WS2IFSL device name
#define WS2IFSL_DEVICE_NAME    L"\\Device\\WS2IFSL"
#define WS2IFSL_SOCKET_FILE_NAME    WS2IFSL_DEVICE_NAME L"\\NifsSct"
#define WS2IFSL_PROCESS_FILE_NAME   WS2IFSL_DEVICE_NAME L"\\NifsPvd"

// Extended attribute names for the WS2IFSL files (note that size of the
// string (including terminating NULL) is carefully chosen to ensure 
// quad word alignment of the attribute value):
//  Socket file
#define WS2IFSL_SOCKET_EA_NAME          "NifsSct"
#define WS2IFSL_SOCKET_EA_NAME_LENGTH   (sizeof(WS2IFSL_SOCKET_EA_NAME)-1)
#define WS2IFSL_SOCKET_EA_VALUE_LENGTH  (sizeof(WS2IFSL_SOCKET_CTX))
#define WS2IFSL_SOCKET_EA_VALUE_OFFSET                                      \
               (FIELD_OFFSET(FILE_FULL_EA_INFORMATION,                      \
                        EaName[WS2IFSL_SOCKET_EA_NAME_LENGTH+1]))           
#define GET_WS2IFSL_SOCKET_EA_VALUE(eaInfo)                                 \
                ((PWS2IFSL_SOCKET_CTX)(                                     \
                    (PUCHAR)eaInfo +WS2IFSL_SOCKET_EA_VALUE_OFFSET))
#define WS2IFSL_SOCKET_EA_INFO_LENGTH                                       \
                (WS2IFSL_SOCKET_EA_VALUE_OFFSET+WS2IFSL_SOCKET_EA_VALUE_LENGTH)

//  Process file
#define WS2IFSL_PROCESS_EA_NAME         "NifsPvd"
#define WS2IFSL_PROCESS_EA_NAME_LENGTH  (sizeof(WS2IFSL_PROCESS_EA_NAME)-1)
#define WS2IFSL_PROCESS_EA_VALUE_LENGTH (sizeof(WS2IFSL_PROCESS_CTX))
#define WS2IFSL_PROCESS_EA_VALUE_OFFSET                                     \
               (FIELD_OFFSET(FILE_FULL_EA_INFORMATION,                      \
                        EaName[WS2IFSL_PROCESS_EA_NAME_LENGTH+1]))           
#define GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)                                \
                ((PWS2IFSL_PROCESS_CTX)(                                    \
                    (PUCHAR)eaInfo +WS2IFSL_PROCESS_EA_VALUE_OFFSET))
#define WS2IFSL_PROCESS_EA_INFO_LENGTH                                      \
                (WS2IFSL_PROCESS_EA_VALUE_OFFSET+WS2IFSL_PROCESS_EA_VALUE_LENGTH)

// All WS2IFSL IOCTL are private and should be out of range
// reserved by Microsoft for public codes
#define WS2IFSL_IOCTL_PROCESS_BASE       0x00000800
#define WS2IFSL_IOCTL_SOCKET_BASE        0x00000810

// Choice of device type implies access priviliges
#define FILE_DEVICE_WS2IFSL     FILE_DEVICE_NAMED_PIPE

// Macro that simplifies definition of WS2IFSL control codes
#define IOCTL_WS2IFSL(File,Function,Method)             \
            CTL_CODE (                                  \
	            FILE_DEVICE_WS2IFSL,                    \
                WS2IFSL_IOCTL_##File##_BASE+Function,   \
                Method,                                 \
                FILE_ANY_ACCESS)



/*
 *  IOCTL:      RETRIEVE_DRV_REQ
 *  File:       Process
 *  Purpose:    Retreive request to be executed by the DLL
 *  Paremeters: InputBuffer         - WS2IFSL_RTRV_PARAMS
 *              InputBufferLength   - sizeof (WS2IFSL_RTRV_PARAMS)
 *              OutputBuffer        - buffer for request
 *              OutputBufferLength  - size of the buffer
 *  Returns:    
 *              STATUS_SUCCESS      - driver request copied ok, no more
 *                                      requests pending
 *              STATUS_MORE_ENTRIES - driver request copied ok, another
 *                                      one is pending.
 *              STATUS_CANCELLED    - request was cancelled
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL process file
 *              STATUS_INVALID_PARAMETER - one of the parameters is invalid
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL process file
 */
#define IOCTL_WS2IFSL_RETRIEVE_DRV_REQ  IOCTL_WS2IFSL (PROCESS,0,METHOD_NEITHER)

/*
 *  IOCTL:      COMPLETE_DRV_CAN
 *  File:       Process
 *  Purpose:    Completes cancel request executed by the DLL
 *  Paremeters: InputBuffer         - WS2IFSL_CNCL_PARAMS
 *              InputBufferLength   - sizeof (WS2IFSL_CNCL_PARAMS)
 *              OutputBuffer        - NULL
 *              OutputBufferLength  - 0
 *  Returns:    
 *              STATUS_SUCCESS      - driver completed copied ok, no more
 *                                      requests pending.
 *              STATUS_MORE_ENTRIES - driver request completed ok, another
 *                                      one is pending.
 *              STATUS_INVALID_PARAMETER - one of the parameters is invalid
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL process file
 */
#define IOCTL_WS2IFSL_COMPLETE_DRV_CAN  IOCTL_WS2IFSL (PROCESS,1,METHOD_NEITHER)

/*
 *  IOCTL:      COMPLETE_DRV_REQ
 *  File:       Socket
 *  Purpose:    Completes request retrived from driver.
 *  Paremeters: InputBuffer         - WS2IFSL_CMPL_PARAMS
 *              InputBufferLength   - sizeof (WS2IFSL_CMPL_PARAMS)
 *              OutputBuffer        - buffer for request
 *              OutputBufferLength  - size of the buffer
 *
 *  Returns:    STATUS_SUCCESS - operation completed OK.
 *              STATUS_CANCELLED - operation was cancelled already.
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL process file
 *              STATUS_INVALID_PARAMETER - size of input buffer is invalid
 */
#define IOCTL_WS2IFSL_COMPLETE_DRV_REQ  IOCTL_WS2IFSL (PROCESS,2,METHOD_NEITHER)

/*
 *  IOCTL:      SET_SOCKET_CONTEXT
 *  File:       Socket
 *  Purpose:    Sets socket process context and associates context value
 *              with the socket (passed as a parameter to the APC routine).
 *  Paremeters: InputBuffer         - PWS2IFSL_SOCKET_CTX, socket context
 *                                      parameters
 *              InputBufferLength   - sizeof(WS2IFSL_SOCKET_CTX)
 *              OutputBuffer        - not used (NULL)
 *              OutputBufferLength  - not used (0)
 *  Returns:    STATUS_SUCCESS      - socket context established OK
 *              STATUS_INSUFFICIENT_RESOURCES - not enough resouces to
 *                                      perform the operation
 *              STATUS_INVALID_PARAMETER - size if input buffer ProcessFile
 *                                      parameter are invalid
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL socket file
 */
#define IOCTL_WS2IFSL_SET_SOCKET_CONTEXT    IOCTL_WS2IFSL (SOCKET,0,METHOD_NEITHER)


/*
 *  IOCTL:      COMPLETE_PVD_REQ
 *  File:       Socket
 *  Purpose:    Completes asynchronous requests for providers.
 *  Paremeters: InputBuffer         - PIO_STATUS_INFORMATION, status information
 *                                      for the request being completed
 *              InputBufferLength   - sizeof(IO_STATUS_INFORMATION)
 *              OutputBuffer        - NULL
 *              OutputBufferLength  - 0
 *  Returns:    Status field of IO_STATUS_INFORMATION structure.
 *              STATUS_NOT_IMPLEMENTED - opretion was performed on file
 *                                      that is not WS2IFSL socket file
 *              STATUS_INVALID_PARAMETER - size of input buffer is invalid
 */
#define IOCTL_WS2IFSL_COMPLETE_PVD_REQ  IOCTL_WS2IFSL (SOCKET,1,METHOD_NEITHER)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\util\sporder\exe\sporder.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sporder.h

Abstract:

    This header prototypes the 32-Bit Windows functions that are used
    to change the order or WinSock2 transport service providers and
    name space providers.

Revision History:

--*/



int
WSPAPI
WSCWriteProviderOrder (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );
/*++

Routine Description:

    Reorder existing WinSock2 service providers.  The order of the service
    providers determines their priority in being selected for use.  The
    sporder.exe tool will show you the installed provider and their ordering,
    Alternately, WSAEnumProtocols(), in conjunction with this function,
    will allow you to write your own tool.

Arguments:

    lpwdCatalogEntryId  [in]
      An array of CatalogEntryId elements as found in the WSAPROTOCOL_INFO
      structure.  The order of the CatalogEntryId elements is the new
      priority ordering for the service providers.

    dwNumberOfEntries  [in]
      The number of elements in the lpwdCatalogEntryId array.


Return Value:

    ERROR_SUCCESS   - the service providers have been reordered.
    WSAEINVAL       - input parameters were bad, no action was taken.
    ERROR_BUSY      - the routine is being called by another thread or process.
    any registry error code


Comments:

    Here are scenarios in which the WSCWriteProviderOrder function may fail:

      The dwNumberOfEntries is not equal to the number of registered service
      providers.

      The lpwdCatalogEntryId contains an invalid catalog ID.

      The lpwdCatalogEntryId does not contain all valid catalog IDs exactly
      1 time.

      The routine is not able to access the registry for some reason
      (e.g. inadequate user persmissions)

      Another process (or thread) is currently calling the routine.

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2help\resource.h ===
#define WS2IFSL_SERVICE_DISPLAY_NAME_STR    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2help\sources.inc ===
TARGETNAME=ws2help
TARGETTYPE=DYNLINK

TARGETLIBS=\
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\kernel32.lib

INCLUDES=..\;..\..\inc;..\..\..\inc

C_DEFINES=$(C_DEFINES) -D_WS2HELP_ -D_WS2HELP_W4_
MSC_WARNING_LEVEL=/W4 /WX

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\util\sporder\exe\main.c ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    main

Abstract:

    Trivial WinMain() function, creates tabbed dialog "property pages"
    and then creates the dialog... interesting code is in dialog procedures.

Author:

    Steve Firebaugh (stevefir)         31-Dec-1995

Revision History:

    SPORDER.EXE, DLL, & LIB were shipped in Win32 SDK along with NT4.

Comments:

    Code is generally ready to be compiled with UNICODE defined, however,
     we do not make use of this because EXE and DLL must also work on
     Windows 95.

--*/


#include <windows.h>
#include <winsock2.h>
#include <commctrl.h>
#include "globals.h"


HINSTANCE ghInst;


int
APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{

    PROPSHEETPAGE psp[3];
    PROPSHEETHEADER psh;
    WSADATA WSAData;
    int iTab = 0;
    int r;
    DWORD dwWait;
    HANDLE hMutex;
    TCHAR pszMutextName[] = TEXT("sporder.exe");


    DBGOUT((TEXT("checked build.\n")));

    //
    // It is possible that we will have multiple instances running at the
    //  same time... what we really want is the first to finish before the
    //  second really gets going... for that reason, wait here on mutex
    //

    hMutex = CreateMutex (NULL, FALSE, pszMutextName);
    hMutex = OpenMutex (SYNCHRONIZE, FALSE, pszMutextName);
    dwWait = WaitForSingleObject (hMutex, 0);
    if (dwWait == WAIT_TIMEOUT)
    {
        OutputDebugString (TEXT("WaitForSingleObject, WAIT_TIMEOUT\n"));
        return TRUE;
    }

    //
    // Do global initializations.
    //

    ghInst = hInstance;
    InitCommonControls();
    memset (psp, 0, sizeof (psp));
    memset (&psh, 0, sizeof (psh));


    if (WSAStartup(MAKEWORD (2,2),&WSAData) == SOCKET_ERROR) {
      OutputDebugString (TEXT("WSAStartup failed\n"));
      return -1;
    }


    psp[iTab].dwSize = sizeof(PROPSHEETPAGE);
    psp[iTab].dwFlags = PSP_USETITLE;
    psp[iTab].hInstance = ghInst;
    psp[iTab].pszTemplate = TEXT("WS2SPDlg");
    psp[iTab].pszIcon = TEXT("");
    psp[iTab].pfnDlgProc = SortDlgProc;
    psp[iTab].pszTitle = TEXT("Service Providers");
    psp[iTab].lParam = 0;
    iTab++;


    psp[iTab].dwSize = sizeof(PROPSHEETPAGE);
    psp[iTab].dwFlags = PSP_USETITLE;
    psp[iTab].hInstance = ghInst;
    psp[iTab].pszTemplate = TEXT("RNRSPDlg");
    psp[iTab].pszIcon = TEXT("");
    psp[iTab].pfnDlgProc = RNRDlgProc;
    psp[iTab].pszTitle = TEXT("Name Resolution ");
    psp[iTab].lParam = 0;
    iTab++;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE ; // | PSH_NOAPPLYNOW  ; // | PSH_HASHELP ;
    psh.hwndParent = NULL;
    psh.hInstance = ghInst;
    psh.pszIcon = TEXT("");
    psh.pszCaption = TEXT("Windows Sockets Configuration");
    psh.nPages = iTab;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    //
    // Finally display the dialog with the property sheets.
    //

//
// Sundown: Possible truncation here from INT_PTR to int in the return value.
//          However, WinMain returns an exit value which is still a 32bit value.
//

    r = (int)PropertySheet(&psh);

    //
    // Cleanup sockets, release mutex, and close handle
    //

    WSACleanup ();
    ReleaseMutex (hMutex);
    CloseHandle (hMutex);

    return r;
}


#if DBG
void
_cdecl
DbgPrint(
    PTCH Format,
    ...
    )
/*++

  Write debug output messages if compiled with DEBUG

--*/
{
    TCHAR buffer[MAX_PATH];

    va_list marker;
    va_start (marker,Format);
    wvsprintf (buffer,Format, marker);
    OutputDebugString (TEXT("SPORDER.EXE: "));
    OutputDebugString (buffer);

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2help\nt\handle.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module implements the socket handle helper functions for the WinSock 2.0
    helper library.

Author:
    Vadim Eydelman (VadimE)


Revision History:

--*/


#include "precomp.h"
#include "resource.h"
#include "osdef.h"
#include "mswsock.h"

//
//  Private constants.
//

#define FAKE_HELPER_HANDLE      ((HANDLE)'MKC ')
#define WS2IFSL_SERVICE_NAME    TEXT ("WS2IFSL")
#define WS2IFSL_SERVICE_PATH    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\WS2IFSL"

// Extended overlapped structure
typedef struct _OVERLAPPED_CTX {
    OVERLAPPED      ovlp;
#define SocketFile ovlp.hEvent
    HANDLE          ProcessFile;
	ULONG			UniqueId;
    ULONG           BufferLen;
	INT				FromLen;
    union {
	    CHAR			Buffer[1];
        SOCKET          Handle;
    };
} OVERLAPPED_CTX, *POVERLAPPED_CTX;

typedef struct _HANDLE_HELPER_CTX {
	HANDLE				ProcessFile;
	HANDLE				ThreadHdl;
	HANDLE				LibraryHdl;
} HANDLE_HELPER_CTX, *PHANDLE_HELPER_CTX;


/* Private Prototypes */ 
VOID
DoSocketRequest (
    PVOID   Context1,
    PVOID   Context2,
    PVOID   Context3
    );

NTSTATUS
DoSocketCancel (
    PVOID   Context1,
    PVOID   Context2,
    PVOID   Context3
    );

DWORD WINAPI
ApcThread (
    PVOID   param
    );

VOID CALLBACK
ExitThreadApc (
    ULONG_PTR   param
    );

void CALLBACK
WinsockApc (
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    );

NTSTATUS
WsErrorToNtStatus (
    IN DWORD Error
    );

DWORD
DemandStartWS2IFSL (
    VOID
    );

DWORD
AllowServiceDemandStart (
    SC_HANDLE hService
    );


/* Private Globals */
BOOL                    Ws2helpInitialized = FALSE;
CRITICAL_SECTION        StartupSyncronization;

/* Our module handle: we keep a reference to it to make sure that
    in is not unloaded while our thread is executing */
HINSTANCE   LibraryHdl;

/* Winsock2 entry points that we call
*/
LPFN_WSASEND                pWSASend=NULL;
LPFN_WSARECV                pWSARecv=NULL;
LPFN_WSASENDTO              pWSASendTo=NULL;
LPFN_WSARECVFROM            pWSARecvFrom=NULL;
LPFN_WSAGETLASTERROR        pWSAGetLastError=NULL;
LPFN_WSACANCELBLOCKINGCALL  pWSACancelBlockingCall = NULL;
LPFN_WSASETBLOCKINGHOOK     pWSASetBlockingHook = NULL;
LPFN_SELECT                 pSelect = NULL;
LPFN_WSASTARTUP             pWSAStartup = NULL;
LPFN_WSACLEANUP             pWSACleanup = NULL;
LPFN_GETSOCKOPT             pGetSockOpt = NULL;
LPFN_WSAIOCTL               pWSAIoctl = NULL;

#if DBG
DWORD       PID=0;
ULONG       DbgLevel = DBG_FAILURES;
#endif


/* Public Functions */


BOOL WINAPI DllMain(
    IN HINSTANCE hinstDll,
    IN DWORD fdwReason,
    LPVOID lpvReserved
    )
{


    switch (fdwReason) {

    case DLL_PROCESS_ATTACH:
        LibraryHdl = hinstDll;
        DisableThreadLibraryCalls (hinstDll);
        __try {
            InitializeCriticalSection (&StartupSyncronization);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            WshPrint(DBG_FAILURES, ("ws2help-DllMain: Failed to initialize"
                                    " startup critical section, excpt: %lx\n",
                                    GetExceptionCode ()));
            LibraryHdl = NULL;
            return FALSE;
        }
        break;


    case DLL_PROCESS_DETACH:

        if (LibraryHdl==NULL)
            break;

        // The calling process is detaching
        // the DLL from its address space.
        //
        // Note that lpvReserved will be NULL if the detach is due to
        // a FreeLibrary() call, and non-NULL if the detach is due to
        // process cleanup.
        //

        if (lpvReserved==NULL) {
            //
            // Free security descriptor if it was allocated
            //
            if (pSDPipe!=NULL)
                FREE_MEM (pSDPipe);
            if (ghWriterEvent!=NULL) {
                CloseHandle (ghWriterEvent);
            }
            DeleteCriticalSection (&StartupSyncronization);
            Ws2helpInitialized = FALSE;
        }
        break;
    }

    return(TRUE);
}


DWORD
WINAPI
WahOpenHandleHelper(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    This routine opens WinSock 2.0 handle helper

Arguments:

    HelperHandle - Points to buffer ion which to return handle.


Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
	PFILE_FULL_EA_INFORMATION	fileEa = alloca(WS2IFSL_PROCESS_EA_INFO_LENGTH);
    OBJECT_ATTRIBUTES   fileAttr;
    UNICODE_STRING      fileName;
    NTSTATUS            status;
    IO_STATUS_BLOCK     ioStatus;
    DWORD               apcThreadId;
    DWORD               rc;
    HINSTANCE           hWS2_32;
	PHANDLE_HELPER_CTX	hCtx;
    WSADATA             wsaData;

    rc = ENTER_WS2HELP_API();
    if (rc != 0)
        return rc;

    if (HelperHandle == NULL)
        return ERROR_INVALID_PARAMETER;
    *HelperHandle = (HANDLE)NULL;

    hWS2_32 = GetModuleHandle (TEXT ("WS2_32.DLL"));
    if (hWS2_32 == NULL)
        return WSASYSCALLFAILURE;

    if (((pGetSockOpt=(LPFN_GETSOCKOPT)GetProcAddress (hWS2_32, "getsockopt"))==NULL)
            || ((pSelect=(LPFN_SELECT)GetProcAddress (hWS2_32, "select"))==NULL)
            || ((pWSACancelBlockingCall=(LPFN_WSACANCELBLOCKINGCALL)GetProcAddress (hWS2_32, "WSACancelBlockingCall"))==NULL)
            || ((pWSACleanup=(LPFN_WSACLEANUP)GetProcAddress (hWS2_32, "WSACleanup"))==NULL)
            || ((pWSAGetLastError=(LPFN_WSAGETLASTERROR)GetProcAddress (hWS2_32, "WSAGetLastError"))==NULL)
            || ((pWSASetBlockingHook=(LPFN_WSASETBLOCKINGHOOK)GetProcAddress (hWS2_32, "WSASetBlockingHook"))==NULL)
            || ((pWSARecv=(LPFN_WSARECV)GetProcAddress (hWS2_32, "WSARecv"))==NULL)
            || ((pWSASend=(LPFN_WSASEND)GetProcAddress (hWS2_32, "WSASend"))==NULL)
            || ((pWSASendTo=(LPFN_WSASENDTO)GetProcAddress (hWS2_32, "WSASendTo"))==NULL)
            || ((pWSAStartup=(LPFN_WSASTARTUP)GetProcAddress (hWS2_32, "WSAStartup"))==NULL)
            || ((pWSARecvFrom=(LPFN_WSARECVFROM)GetProcAddress (hWS2_32, "WSARecvFrom"))==NULL)
            || ((pWSAIoctl=(LPFN_WSAIOCTL)GetProcAddress(hWS2_32, "WSAIoctl"))==NULL) )
        return WSASYSCALLFAILURE;

    //
    // Keep a ref-count to Winsock to prevent it from going away on us.
    // If we fail anywhere else below, the ref-count will be cleaned up
    // in the thread APC if we successfully created the thread, else we
    // must be sure to dereference it ourself.
    //

    if ((rc = pWSAStartup(MAKEWORD(2, 0), &wsaData)) != NO_ERROR)
        return (rc);

    //
    // Create file used to communicate with the driver.
    //

    hCtx = (PHANDLE_HELPER_CTX)ALLOC_MEM(sizeof(*hCtx));

    if (hCtx != NULL) {

        /* Create thread in which to execute file system requests */
	    hCtx->ThreadHdl = CreateThread (NULL,
                            0,
                            ApcThread,
                            hCtx,
                            CREATE_SUSPENDED,
                            &apcThreadId);

        if (hCtx->ThreadHdl != NULL) {

		    RtlInitUnicodeString (&fileName, WS2IFSL_PROCESS_FILE_NAME);
		    InitializeObjectAttributes (&fileAttr,
							    &fileName,
							    0,                  // Attributes
							    NULL,               // Root directory
							    NULL);              // Security descriptor
		    fileEa->NextEntryOffset = 0;
		    fileEa->Flags = 0;
		    fileEa->EaNameLength = WS2IFSL_PROCESS_EA_NAME_LENGTH;
		    fileEa->EaValueLength = WS2IFSL_PROCESS_EA_VALUE_LENGTH;
		    strcpy (fileEa->EaName, WS2IFSL_PROCESS_EA_NAME);
		    GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->ApcThread = hCtx->ThreadHdl;
		    GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->RequestRoutine = DoSocketRequest;
		    GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->CancelRoutine = DoSocketCancel;
		    GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->ApcContext = hCtx;
#if DBG
		    GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->DbgLevel = DbgLevel;
#else
		    GET_WS2IFSL_PROCESS_EA_VALUE (fileEa)->DbgLevel = 0;
#endif


		    status = NtCreateFile (&hCtx->ProcessFile,
							     FILE_ALL_ACCESS,
							     &fileAttr,
							     &ioStatus,
							     NULL,              // Allocation size
							     FILE_ATTRIBUTE_NORMAL,
							     0,                 // ShareAccess
							     FILE_OPEN_IF,      // Create disposition
							     0,                 // Create options
							     fileEa,
							     WS2IFSL_PROCESS_EA_INFO_LENGTH);

            if (status == STATUS_OBJECT_NAME_NOT_FOUND || status == STATUS_OBJECT_PATH_NOT_FOUND) {

                //
                // Driver is probably not loaded, attempt to start it.
                //
                rc = DemandStartWS2IFSL();
                if (rc == 0) {
			        status = NtCreateFile (&hCtx->ProcessFile,
								         FILE_ALL_ACCESS,
								         &fileAttr,
								         &ioStatus,
								         NULL,              // Allocation size
								         FILE_ATTRIBUTE_NORMAL,
								         0,                 // ShareAccess
								         FILE_OPEN_IF,      // Create disposition
								         0,                 // Create options
								         fileEa,
								         WS2IFSL_PROCESS_EA_INFO_LENGTH);
                } else
                    goto StartFailed;

            }

		    if (NT_SUCCESS (status)) {
                ResumeThread (hCtx->ThreadHdl);
			    *HelperHandle = (HANDLE)hCtx;
			    WshPrint (DBG_PROCESS,
				    ("WS2HELP-%lx WahOpenHandleHelper: Opened handle %p\n",
						    PID, hCtx));
			    return NO_ERROR;

            } else { 
			    WshPrint (DBG_PROCESS|DBG_FAILURES,
				    ("WS2HELP-%lx WahOpenHandleHelper: Could not create process file, status %lx\n",
				    PID, status));
			    rc = RtlNtStatusToDosError (status);
		    
            }

            StartFailed :

            hCtx->ProcessFile = NULL;
            ResumeThread(hCtx->ThreadHdl);

        } else {

		    rc = GetLastError();
		    WshPrint(DBG_PROCESS | DBG_FAILURES,
			         ("WS2HELP-%lx WahOpenHandleHelper: Could not create APC thread, rc=%ld\n", PID, rc));

        } // if (ApcThreadHdl != NULL)

	    FREE_MEM (hCtx);
    
    } else {

        WshPrint (DBG_PROCESS|DBG_FAILURES,
            ("WS2HELP-%lx WahOpenHandleHelper: Could allocate helper context\n", PID));
        rc = GetLastError();

    }

    //
    // This is the failure path.  Success would have returned NO_ERROR above.
    //

    pWSACleanup();
    return (rc);

}


DWORD
WINAPI
WahCloseHandleHelper(
    IN HANDLE HelperHandle
    )
/*++

Routine Description:

    This function closes the WinSock 2.0 handle helper.

Arguments:

    HelperHandle - The handle to close.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
	PHANDLE_HELPER_CTX	hCtx;
    DWORD               rc;

    rc = ENTER_WS2HELP_API();
    if (rc != 0)
        return rc;

    if (HelperHandle == NULL)
        return ERROR_INVALID_PARAMETER;

	hCtx = (PHANDLE_HELPER_CTX)HelperHandle;

    /* Queue APC that exits the thread */
    if (QueueUserAPC (ExitThreadApc, hCtx->ThreadHdl, (ULONG_PTR)hCtx)) {
		WshPrint (DBG_PROCESS, 
			("WS2HELP-%lx WahCloseHandleHelper: Queued close APC.\n", PID));
		return NO_ERROR;
	}
	else {
		WshPrint (DBG_PROCESS|DBG_FAILURES,
			("WS2HELP-%lx WahCloseHandleHelper: Failed to queue close APC.\n", PID));
		return ERROR_GEN_FAILURE;
	}
}


DWORD
WINAPI
WahCreateSocketHandle(
    IN HANDLE           HelperHandle,
    OUT SOCKET          *s
    )
/*++

Routine Description:

    This function creates IFS socket handle for service provider that
    cannot do it by itself.

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.
    S            - buffer to return created socket handle

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
	PFILE_FULL_EA_INFORMATION	fileEa = alloca(WS2IFSL_SOCKET_EA_INFO_LENGTH);
    OBJECT_ATTRIBUTES           fileAttr;
    UNICODE_STRING              fileName;
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatus;
    DWORD                       error;
    INT                         count;
    DWORD                       dwCount;
    INT                         openType;
    DWORD                       crOptions;
	PHANDLE_HELPER_CTX			hCtx = (PHANDLE_HELPER_CTX)HelperHandle;
    
    error = ENTER_WS2HELP_API();
    if (error!=0)
        return error;

    if ((HelperHandle==NULL) || (s==NULL))
        return ERROR_INVALID_PARAMETER;

    count = sizeof (openType);
    if ((pGetSockOpt (INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE, (PCHAR)&openType, &count)==0)
        && (openType!=0)) {
        crOptions = FILE_SYNCHRONOUS_IO_NONALERT;
    }
    else
        crOptions = 0;

    // Create file handle on the driver device
    RtlInitUnicodeString (&fileName, WS2IFSL_SOCKET_FILE_NAME);
    InitializeObjectAttributes (&fileAttr,
                        &fileName,
                        0,                  // Attributes
                        NULL,               // Root directory
                        NULL);              // Security descriptor
    fileEa->NextEntryOffset = 0;
    fileEa->Flags = 0;
    fileEa->EaNameLength = WS2IFSL_SOCKET_EA_NAME_LENGTH;
    fileEa->EaValueLength = WS2IFSL_SOCKET_EA_VALUE_LENGTH;
    strcpy (fileEa->EaName, WS2IFSL_SOCKET_EA_NAME);
        // Supply the context (can't actually supply the handle
        // until it is opened
    GET_WS2IFSL_SOCKET_EA_VALUE (fileEa)->ProcessFile = hCtx->ProcessFile;
    GET_WS2IFSL_SOCKET_EA_VALUE (fileEa)->DllContext = NULL;

    status = NtCreateFile ((HANDLE *)s,
                         FILE_ALL_ACCESS,
                         &fileAttr,
                         &ioStatus,
                         NULL,              // Allocation size
                         FILE_ATTRIBUTE_NORMAL,
                         0,                 // ShareAccess
                         FILE_OPEN_IF,      // Create disposition
                         crOptions,         // Create options
                         fileEa,
                         WS2IFSL_SOCKET_EA_INFO_LENGTH);
    if (NT_SUCCESS (status)) {
            // Now set the actual context
        GET_WS2IFSL_SOCKET_EA_VALUE (fileEa)->DllContext = (HANDLE)*s;
        if (DeviceIoControl (
                        (HANDLE)*s,                         // File Handle
                        IOCTL_WS2IFSL_SET_SOCKET_CONTEXT,   // Control Code
                        GET_WS2IFSL_SOCKET_EA_VALUE (fileEa),// InBuffer
                        sizeof (WS2IFSL_SOCKET_CTX),         // InBufferLength
                        NULL,                               // OutBuffer
                        0,                                  // OutBufferLength
                        &dwCount,                             // BytesReturned
                        NULL)) {                              // Overlapped
            WshPrint (DBG_SOCKET,
                ("WS2HELP-%lx WahCreateSocketHandle: Handle %p\n", PID,  *s));
            error = NO_ERROR;
        }
        else {
            error = GetLastError ();
            NtClose ((HANDLE)*s);
            WshPrint (DBG_SOCKET|DBG_FAILURES,
                ("WS2HELP-%lx WahCreateSocketHandle: Could not set context, rc=%ld\n",
                            PID, error));
            *s = 0;
        }
    }
    else { // if (NtCreateFile succeded)
        error = RtlNtStatusToDosError (status);
        WshPrint (DBG_SOCKET|DBG_FAILURES,
                ("WS2HELP-%lx WahCreateSocketHandle: Could create file, rc=%ld\n",
                        PID, error));
    }

    return error;
}



DWORD
WINAPI
WahCloseSocketHandle(
    IN HANDLE           HelperHandle,
    IN SOCKET           s
    )
/*++

Routine Description:

    This function destroyes IFS socket handle created by WahCreateSocketHandle

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.
    s            - socket handle to close

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
	PHANDLE_HELPER_CTX		hCtx = (PHANDLE_HELPER_CTX)HelperHandle;
	NTSTATUS				status;
    DWORD                   rc;

    rc = ENTER_WS2HELP_API();
    if (rc!=0)
        return rc;

    if ((hCtx==NULL)
            || (s==0)
            || (s==INVALID_SOCKET))
        return ERROR_INVALID_PARAMETER;

    WshPrint (DBG_SOCKET,
            ("WS2HELP-%lx WahCloseSocketHandle: Handle %p\n", PID, s));
    status = NtClose ((HANDLE)s);
	if (NT_SUCCESS (status))
		return NO_ERROR;
	else
		return RtlNtStatusToDosError (status);
}

DWORD
WINAPI
WahCompleteRequest(
    IN HANDLE              HelperHandle,
    IN SOCKET              s,
    IN LPWSAOVERLAPPED     lpOverlapped,
    IN DWORD               dwError,
    IN DWORD               cbTransferred
    )
/*++

Routine Description:

    This function simmulates completion of overlapped IO request
    on socket handle created by WasCreateSocketHandle

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.
    s            - socket handle to complete request on
    lpOverlapped - pointer to overlapped structure
    dwError      - WinSock 2.0 error code for opreation being completed
    cbTransferred- number of bytes transferred to/from user buffers as the
                    result of the operation being completed

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    IO_STATUS_BLOCK			IoStatus;
    NTSTATUS				status;
	PHANDLE_HELPER_CTX		hCtx = (PHANDLE_HELPER_CTX)HelperHandle;
    DWORD                   rc;
    
    rc = ENTER_WS2HELP_API();
    if (rc!=0)
        return rc;

    if ((hCtx==NULL)
		    || (lpOverlapped==NULL)
            || (s==INVALID_SOCKET)
            || (s==0))
        return ERROR_INVALID_PARAMETER;

        // Setup IO_STATUS block to be used by the driver to complete the
        // operation
    IoStatus.Status = WsErrorToNtStatus (dwError);
    IoStatus.Information = cbTransferred;
        // Call the driver to complete
    status = NtDeviceIoControlFile ((HANDLE)s,
                    lpOverlapped->hEvent,
                    NULL,
                    ((ULONG_PTR)lpOverlapped->hEvent&1) ? NULL : lpOverlapped,
                    (PIO_STATUS_BLOCK)lpOverlapped,
                    IOCTL_WS2IFSL_COMPLETE_PVD_REQ,
                    &IoStatus,
                    sizeof (IO_STATUS_BLOCK),
                    NULL,
                    0);
		// Be carefull not to touch overlapped after NtDeviceIoControlFile
    if (NT_SUCCESS(status) || (status==IoStatus.Status)) {
        WshPrint (DBG_COMPLETE,
            ("WS2HELP-%lx WahCompleteRequest: Handle %p, status %lx, info %ld\n",
                PID, s, IoStatus.Status, IoStatus.Information));
        return NO_ERROR;
    }
    else {
        WshPrint (DBG_COMPLETE|DBG_FAILURES,
            ("WS2HELP-%lx WahCompleteRequest: Failed on handle %p, status %lx\n",
                PID, s, status));
        return ERROR_INVALID_HANDLE;
    }
}


DWORD
WINAPI
WahEnableNonIFSHandleSupport (
    VOID
    )
/*++

Routine Description:

    This function installs and starts Winsock2 Installable File System Layer
    driver to provide socket handles for Non-IFS handle transport service 
    providers.
Arguments:

    None

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    SC_HANDLE   hSCManager, hWS2IFSL;
    DWORD       rc=0;
    TCHAR       WS2IFSL_DISPLAY_NAME[256];

    rc = ENTER_WS2HELP_API();
    if (rc!=0)
        return rc;

    //
    // Get display string for Winsock2 non-IFS handle helper service name
    // (localizable)
    //
    // Use exception handler because of delayload option we
    // use for user32.dll (for hydra compat).
    //
    rc = LoadString (LibraryHdl, WS2IFSL_SERVICE_DISPLAY_NAME_STR,
                    WS2IFSL_DISPLAY_NAME, sizeof (WS2IFSL_DISPLAY_NAME));
    if (rc==0) {
        rc = GetLastError ();
        if (rc==0)
            rc = ERROR_NOT_ENOUGH_MEMORY;
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx WahEnableNonIFSHandleSupport:"
             " Could not load service display string, err: %ld\n",
            PID, rc));
        return rc;
    }

    rc = 0;

    //
    // Open service database on the local computer
    //

    hSCManager = OpenSCManager (
                        NULL,
                        SERVICES_ACTIVE_DATABASE,
                        SC_MANAGER_CREATE_SERVICE
                        );
    if (hSCManager==NULL) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx WahEnableNonIFSHandleSupport: Could not open SC, err: %ld\n",
            PID, rc));
        return rc;
    }




    //
    // Create Winsock2 non-IFS handle helper service
    //

    hWS2IFSL = CreateService (
                    hSCManager,
                    WS2IFSL_SERVICE_NAME,
                    WS2IFSL_DISPLAY_NAME,
                    SERVICE_ALL_ACCESS,
                    SERVICE_KERNEL_DRIVER,
                    SERVICE_AUTO_START,
                    SERVICE_ERROR_NORMAL,
                    TEXT ("\\SystemRoot\\System32\\drivers\\ws2ifsl.sys"),
                    TEXT ("PNP_TDI"),   // load group
                    NULL,               // Tag ID
                    NULL,               // Dependencies
                    NULL,               // Start name
                    NULL                // Password
                    );
    if (hWS2IFSL==NULL) {
        //
        // Failure, check if service already exists
        //
        rc = GetLastError ();
        if (rc!=ERROR_SERVICE_EXISTS) {
            //
            // Some other failure, bail out
            //
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx WahEnableNonIFSHandleSupport: Could not create service, err: %ld\n",
                PID, rc));
            CloseServiceHandle (hSCManager);
            return rc;
        }

        rc = 0;

        //
        // Open existing service
        //
        hWS2IFSL = OpenService (
                    hSCManager,
                    WS2IFSL_SERVICE_NAME,
                    SERVICE_ALL_ACCESS);
        if (hWS2IFSL==NULL) {
            //
            // Could not open, bail out
            //
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx WahEnableNonIFSHandleSupport: Could not open service, err: %ld\n",
                PID, rc));
            CloseServiceHandle (hSCManager);
            return rc;
        }
    }

    rc = AllowServiceDemandStart (hWS2IFSL);
    if (rc==0) {
        if (ChangeServiceConfig (hWS2IFSL,
                    SERVICE_KERNEL_DRIVER,
                    SERVICE_DEMAND_START,
                    SERVICE_ERROR_NORMAL,
                    TEXT ("\\SystemRoot\\System32\\drivers\\ws2ifsl.sys"),
                                            // lpBinaryPathName 
                    NULL,                   // load group
                    NULL,                   // Tag ID
                    NULL,                   // Dependencies
                    NULL,                   // Start name
                    NULL,                   // Password
                    WS2IFSL_DISPLAY_NAME    // Display name
                    )) {
            WshPrint (DBG_SERVICE,
                ("WS2HELP-%lx WahEnableNonIFSHandleSupport: Configured service.\n",
                PID));
        }
        else {
            //
            // Could set config, bail out
            //
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx WahEnableNonIFSHandleSupport: Could not enable service, err: %ld\n",
                PID, rc));
        }
    }
    //
    // Success, cleanup open handles
    //
    CloseServiceHandle (hWS2IFSL);
    CloseServiceHandle (hSCManager);
    return rc;
}

DWORD
WINAPI
WahDisableNonIFSHandleSupport (
    VOID
    )
/*++

Routine Description:

    This function deinstalls Winsock2 Installable File System Layer
    driver to provide socket handles for Non-IFS handle transport service 
    providers.
Arguments:

    None

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    SC_HANDLE   hSCManager, hWS2IFSL;
    DWORD       rc=0;

    rc = ENTER_WS2HELP_API();
    if (rc!=0)
        return rc;

    //
    // Open service database on the local computer
    //

    hSCManager = OpenSCManager (
                        NULL,
                        SERVICES_ACTIVE_DATABASE,
                        SC_MANAGER_CREATE_SERVICE
                        );
    if (hSCManager==NULL) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx WahDisableNonIFSHandleSupport: Could not open SC, err: %ld\n",
            PID, rc));
        return rc;
    }

    //
    // Open service itself
    //

    hWS2IFSL = OpenService (
                hSCManager,
                WS2IFSL_SERVICE_NAME,
                SERVICE_ALL_ACCESS);
    if (hWS2IFSL==NULL) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx WahDisableNonIFSHandleSupport: Could open service, err: %ld\n",
            PID, rc));
        CloseServiceHandle (hSCManager);
        return rc;
    }

    //
    // Just disable the service, so it won't start on reboot.
    //
    // Deleting service is dangerous because this will require
    // a reboot before it can be installed again and we are
    // working towards no-reboot system
    //
    // Stopping is even worse, because it will go into uncontrollable
    // (STOP_PENDING) state until all handles to it are closed so
    // we won't be able to start it until reboot if some service is
    // holding its handles.
    // 

    if (ChangeServiceConfig (hWS2IFSL,
                SERVICE_NO_CHANGE,  // dwServiceType 
                SERVICE_DISABLED,   // dwStartType
                SERVICE_NO_CHANGE,  // dwErrorControl 
                NULL,               // lpBinaryPathName 
                NULL,               // load group
                NULL,               // Tag ID
                NULL,               // Dependencies
                NULL,               // Start name
                NULL,               // Password
                NULL                // Display name
                )) {
        rc = 0;
        WshPrint (DBG_SERVICE,
            ("WS2HELP-%lx WahDisableNonIFSHandleSupport: Disabled service.\n",
            PID));
    }
    else {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx WahDisableNonIFSHandleSupport: Could not disable service, err: %ld\n",
            PID, GetLastError ()));
    }

    CloseServiceHandle (hWS2IFSL);
    CloseServiceHandle (hSCManager);
    return rc;
}




DWORD WINAPI
ApcThread (
    PVOID   param
    )
/*++

Routine Description:

    This is a thread which is used by the driver to execute 
    IO system requests
Arguments:

    param   - handle helper context
Return Value:

    0

--*/
{
    NTSTATUS                    status;
	DWORD						rc;
	PHANDLE_HELPER_CTX			hCtx = (PHANDLE_HELPER_CTX)param;
	TCHAR						ModuleName[MAX_PATH];
    LARGE_INTEGER               Timeout;

    //
    // Could not open the file, just clean-up.
    //
    if (hCtx->ProcessFile==NULL)
        return 1;

    Timeout.QuadPart = 0x8000000000000000i64;

    // Increment our module reference count
    // so it does not go away while this thread is
    // running

	rc = GetModuleFileName (LibraryHdl,
							ModuleName,
							sizeof(ModuleName)/sizeof(ModuleName[0]));

    if (rc == 0 ||
        rc >= sizeof(ModuleName)/sizeof(ModuleName[0])) {
        //
        // some error or ModuleName too small. Bail
        //
        return 1;
    }

    hCtx->LibraryHdl = LoadLibrary (ModuleName);
    WS_ASSERT(hCtx->LibraryHdl != NULL);

    WshPrint (DBG_APC_THREAD,
        ("WS2HELP-%lx ApcThread: Initialization completed\n", PID));
            // Wait alertably to let APC's execute
    while (TRUE) {
        status = NtDelayExecution (TRUE, &Timeout);
        if (!NT_SUCCESS (status)) {
            //
            // Sleep for 3 seconds
            //
            LARGE_INTEGER   Timeout2;
            Timeout2.QuadPart = - (3i64*1000i64*1000i64*10i64);
            NtDelayExecution (FALSE, &Timeout2);
        }
    }
    // We should never get here, the thread terminates
    // from the ExitApc
    WS_ASSERT(FALSE);
	return 0;
}

VOID CALLBACK
ExitThreadApc (
    ULONG_PTR   param
    )
/*++

Routine Description:

    This APC routine is used to terminate APC thread
Arguments:

    param   - exit code for thread
Return Value:

    Exit code for thread

--*/
{
	PHANDLE_HELPER_CTX	hCtx = (PHANDLE_HELPER_CTX)param;
    HINSTANCE libraryHdl = hCtx->LibraryHdl;
    
        // Close the file
    NtClose (hCtx->ProcessFile);
	CloseHandle (hCtx->ThreadHdl);
    WshPrint (DBG_APC_THREAD, ("WS2HELP-%lx ExitThreadApc: Exiting, ctx: %p\n", PID));
    pWSACleanup();
	FREE_MEM (hCtx);
    FreeLibraryAndExitThread (libraryHdl, 0);
}


void CALLBACK
WinsockApc(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    )
/*++

Routine Description:

    This APC routine is executed upon completion of WinSock 2.0 call
Arguments:

    dwError         - WinSock2.0 return code
    cbTransferred   - number of buffers transferred to/from user buffers
    lpOverlapped    - overlapped structure associated with the request
                      (it is actually our extended structure: OVERLAPPED_CTX_
    dwFlags         - flags associated with the request (ignored)
Return Value:

    None
--*/
{
	POVERLAPPED_CTX		ctx = CONTAINING_RECORD (lpOverlapped,
													OVERLAPPED_CTX,
													ovlp);
    IO_STATUS_BLOCK		ioStatus;
	WS2IFSL_CMPL_PARAMS	params;
	NTSTATUS			status;

    UNREFERENCED_PARAMETER(dwFlags);
    
    // Setup status block for the driver
    params.SocketHdl = ctx->SocketFile;
	params.UniqueId = ctx->UniqueId;
    params.DataLen = cbTransferred;
	params.AddrLen = (ULONG)ctx->FromLen;
    params.Status = WsErrorToNtStatus (dwError);

	status = NtDeviceIoControlFile (
					ctx->ProcessFile,	// Handle
					NULL,				// Event
					NULL,				// Apc
					NULL,				// ApcContext
					&ioStatus,			// IoStatus
					IOCTL_WS2IFSL_COMPLETE_DRV_REQ, // IoctlCode
					&params,			// InputBuffer
					sizeof(params),		// InputBufferLength,
					ctx->Buffer,		// OutputBuffer
					ctx->BufferLen      // OutputBufferLength,
					);

    WshPrint (DBG_WINSOCK_APC,
        ("WS2HELP-%lx WinsockApc: Socket %p, id %ld, err %ld, cb %ld, addrlen %ld\n",
            PID, ctx->SocketFile, ctx->UniqueId,
			dwError, cbTransferred, ctx->FromLen));
    FREE_MEM (ctx);
}

VOID
DoSocketRequest (
    PVOID   PvCtx,
    PVOID   PvRequestId,
    PVOID   PvBufferLength
    )
/*++

Routine Description:

	Executes socket request for the ws2ifsl driver

Arguments:

Return Value:

    None
--*/
{
	IO_STATUS_BLOCK		ioStatus;
	NTSTATUS			status;
	WS2IFSL_RTRV_PARAMS	params;
	POVERLAPPED_CTX		ctx;
    PHANDLE_HELPER_CTX	hCtx = PvCtx;

    WshPrint (DBG_REQUEST,
		("WS2HELP-%lx DoSocketRequest: id %ld, buflen %ld\n",
        PID, PtrToUlong(PvRequestId), PtrToUlong(PvBufferLength)));

	params.UniqueId = PtrToUlong (PvRequestId);
	ctx = (POVERLAPPED_CTX)ALLOC_MEM (FIELD_OFFSET(
										OVERLAPPED_CTX,
										Buffer[PtrToUlong(PvBufferLength)]));

	if (ctx!=NULL) {
        ctx->ProcessFile = hCtx->ProcessFile;
			// Use extension field to save driver context
		ctx->UniqueId = PtrToUlong (PvRequestId);
        ctx->BufferLen = PtrToUlong (PvBufferLength);

		status = NtDeviceIoControlFile (
						ctx->ProcessFile,   // Handle
						NULL,				// Event
						NULL,				// Apc
						NULL,				// ApcContext
						&ioStatus,			// IoStatus
						IOCTL_WS2IFSL_RETRIEVE_DRV_REQ, // IoctlCode
						&params,			// InputBuffer
						sizeof(params),		// InputBufferLength,
						ctx->Buffer,		// OutputBuffer
						ctx->BufferLen	// OutputBufferLength,
						);
	}
	else {
		status = NtDeviceIoControlFile (
						hCtx->ProcessFile,	// Handle
						NULL,				// Event
						NULL,				// Apc
						NULL,				// ApcContext
						&ioStatus,			// IoStatus
						IOCTL_WS2IFSL_RETRIEVE_DRV_REQ, // IoctlCode
						&params,			// InputBuffer
						sizeof(params),		// InputBufferLength,
						NULL,				// OutputBuffer
						0					// OutputBufferLength,
						);
		WS_ASSERT(!NT_SUCCESS(status));
	}

	if (NT_SUCCESS(status)) {
		DWORD           error, count, flags;
		WSABUF          buf;

		WS_ASSERT(ctx != NULL);

		// Use hEvent to save socket context (handle)
		ctx->SocketFile = params.DllContext;
		ctx->FromLen = 0;
            
            // Setup request parameters and execute asynchronously
        switch (params.RequestType) {
        case WS2IFSL_REQUEST_READ:
            flags = 0;
            buf.buf = ctx->Buffer;
            buf.len = params.DataLen;
            if ((pWSARecv ((SOCKET)ctx->SocketFile,
                        &buf,
                        1,
                        &count,
                        &flags,
                        &ctx->ovlp,
                        WinsockApc)!=SOCKET_ERROR)
			           || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
		        WshPrint (DBG_DRIVER_READ,
                    ("WS2HELP-%lx DoSocketRequest: Read - socket %p, ctx %p,"
					" id %ld, len %ld\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId,
					params.DataLen));
                return;
            }
            break;
        case WS2IFSL_REQUEST_WRITE:
			buf.buf = ctx->Buffer;
			buf.len = params.DataLen;
            if ((pWSASend ((SOCKET)ctx->SocketFile,
                        &buf,
                        1,
                        &count,
                        0,
                        &ctx->ovlp,
                        WinsockApc)!=SOCKET_ERROR)
                   || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
	            WshPrint (DBG_DRIVER_WRITE,
					("WS2HELP-%lx DoSocketRequest: Write - socket %p, ctx %p,"
					" id %ld, len %ld\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId,
					params.DataLen));
                return;
            }
            break;
        case WS2IFSL_REQUEST_SENDTO:
			buf.buf = ctx->Buffer;
			buf.len = params.DataLen;
            if ((pWSASendTo ((SOCKET)ctx->SocketFile,
                        &buf,
                        1,
                        &count,
                        0,
						(const struct sockaddr FAR *)
							&ctx->Buffer[ADDR_ALIGN(params.DataLen)],
                        params.AddrLen,
                        &ctx->ovlp,
                        WinsockApc)!=SOCKET_ERROR)
                   || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
                WshPrint (DBG_DRIVER_SEND,
					("WS2HELP-%lx DoSocketRequest: SendTo - socket %p, ctx %p,"
					" id %ld, len %ld, addrlen %ld\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId,
					params.DataLen, params.AddrLen));
                return;
            }
            break;
        case WS2IFSL_REQUEST_RECVFROM:
			buf.buf = ctx->Buffer;
			buf.len = params.DataLen;
			flags = params.Flags;
			ctx->FromLen = (INT)params.AddrLen;
            if ((pWSARecvFrom ((SOCKET)ctx->SocketFile,
                        &buf,
                        1,
                        &count,
                        &flags,
						(struct sockaddr FAR *)
							&ctx->Buffer[ADDR_ALIGN(params.DataLen)],
                        &ctx->FromLen,
                        &ctx->ovlp,
                        WinsockApc)!=SOCKET_ERROR)
                   || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
                WshPrint (DBG_DRIVER_RECV,
					("WS2HELP-%lx DoSocketRequest: RecvFrom - socket %p, ctx %p,"
					" id %ld, len %ld, addrlen %ld, flags %lx\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId,
					params.DataLen, params.AddrLen, params.Flags));
                return;
            }
            break;
        case WS2IFSL_REQUEST_RECV:
			buf.buf = ctx->Buffer;
			buf.len = params.DataLen;
			flags = params.Flags;
            if ((pWSARecv ((SOCKET)ctx->SocketFile,
                        &buf,
                        1,
                        &count,
                        &flags,
                        &ctx->ovlp,
                        WinsockApc)!=SOCKET_ERROR)
                   || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
                WshPrint (DBG_DRIVER_RECV,
					("WS2HELP-%lx DoSocketRequest: Recv - socket %p, ctx %p,"
					" id %ld, len %ld, flags %lx\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId,
					params.DataLen, params.Flags));
                return;
            }
            break;
        case WS2IFSL_REQUEST_QUERYHANDLE:
            WS_ASSERT(params.DataLen == sizeof(SOCKET));
            if ((pWSAIoctl ((SOCKET)ctx->SocketFile,
                            SIO_QUERY_TARGET_PNP_HANDLE,
                            NULL,
                            0,
                            &ctx->Handle,
                            sizeof (ctx->Handle),
                            &count,
                            &ctx->ovlp,
                            WinsockApc)!=SOCKET_ERROR)
                   || ((error=pWSAGetLastError ())==WSA_IO_PENDING)) {
                WshPrint (DBG_CANCEL,
					("WS2HELP-%lx DoSocketRequest: PnP - socket %p, ctx %p,"
					" id %ld\n",
                    PID, ctx->SocketFile, ctx, 
					ctx->UniqueId));
                return;
            }
            break;
        default:
            WS_ASSERT(FALSE);
            __assume(0);
        }
		// The Winsock request failed (no APC is going to executed, call it here)
        WinsockApc (error, 0, &ctx->ovlp, 0);
	}

}



INT_PTR
CancelHook (
    void
    )
/*++

Routine Description:

    This is blocking hook that cancels the current request
Arguments:

Return Value:
    FALSE   - to stop polling

--*/
{
    BOOL    res;
    res = pWSACancelBlockingCall ();
    WshPrint (DBG_CANCEL,
        ("WS2HELP-%lx CancelHook: %s\n", PID, res ? "succeded" : "failed"));
    return FALSE;
}


NTSTATUS
DoSocketCancel (
    PVOID   PvCtx,
    PVOID   PvRequestId,
    PVOID   PvDllContext
    )
/*++

Routine Description:
    Hack to attempt to cancel request in progress.
    This works with MSAFD, but may (actully will) not work with
    any other provider which is likely to implement select differently.
    Our hope here that by cancelling select we will also cancel any
    other outstanding requests on a socket handle.

Arguments:

Return Value:

    None
--*/
{
    FARPROC				oldHook;
    int					res;
    fd_set				set;
    struct timeval		timeout;
	IO_STATUS_BLOCK		ioStatus;
	NTSTATUS			status;
	WS2IFSL_CNCL_PARAMS	params;
	SOCKET				s = (SOCKET)PvDllContext;
    WORD                wVersionRequested;
    WSADATA             wsaData;
    DWORD               rc;
    PHANDLE_HELPER_CTX	hCtx = PvCtx;

    WshPrint (DBG_CANCEL, ("WS2HELP-%lx DoSocketCancel: Socket %p, id %d\n",
        PID, PvDllContext, PtrToUlong (PvRequestId)));
    //
    // Request 1.1 so that blocking hooks are supported
    //
    wVersionRequested = MAKEWORD(1, 1);
    if ((rc = pWSAStartup(wVersionRequested, &wsaData)) == NO_ERROR) {

        oldHook = pWSASetBlockingHook (CancelHook);
        if (oldHook!=NULL) {

            FD_ZERO (&set);
            FD_SET (s, &set);
            timeout.tv_sec = 10;
            timeout.tv_usec = 0;
            res = pSelect (1, NULL, NULL, &set, &timeout);
            WshPrint (DBG_CANCEL, 
                ("WS2HELP-%lx CancelApc: Done on socket id %ld (res %ld)\n",
                PID, PtrToUlong(PvRequestId), res));
            pWSASetBlockingHook (oldHook);
        }
        else {
            rc = pWSAGetLastError ();
            WshPrint (DBG_CANCEL|DBG_FAILURES,
                ("WS2HELP-%lx DoSocketCancel: Could not install blocking hook, err - %ld\n",
                PID, rc));
        }

        pWSACleanup();

    } else {

        WshPrint (DBG_CANCEL|DBG_FAILURES,
            ("WS2HELP-%lx DoSocketCancel: Could not get version 1.1, rc - %ld\n",
            PID, rc));

    }

	params.UniqueId = PtrToUlong (PvRequestId);

	status = NtDeviceIoControlFile (
					hCtx->ProcessFile,  // Handle
					NULL,				// Event
					NULL,				// Apc
					NULL,				// ApcContext
					&ioStatus,			// IoStatus
					IOCTL_WS2IFSL_COMPLETE_DRV_CAN, // IoctlCode
					&params,			// InputBuffer
					sizeof(params),		// InputBufferLength,
					NULL,				// OutputBuffer
					0					// OutputBufferLength,
					);
	WS_ASSERT(NT_SUCCESS(status));


    WshPrint (DBG_CANCEL, 
        ("WS2HELP-%lx CancelApc: Completed on socket %p, id %ld (status %lx)\n",
        PID, s, params.UniqueId, status));

	return status;
}






NTSTATUS
WsErrorToNtStatus (
    DWORD   dwError
    )
/*++

Routine Description:

    This function maps WinSock 2.0 error code to NTSTATUS value
Arguments:

    dwError         - WinSock2.0 return code
    
Return Value:

    NTSTATUS corresponding to dwError
--*/
{
    // Macro that validates that our winsock error array indeces are
    // in sync with winsock2.h defines
#define MAPWSERROR(line,Error,Status)   Status
    // WinSock2.0 error to NTSTATUS MAP
static const NTSTATUS WSAEMap[]= {
    MAPWSERROR (0,      0,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (1,      1,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (2,      2,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (3,      3,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (4,      WSAEINTR,           STATUS_USER_APC),
    MAPWSERROR (5,      5,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (6,      6,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (7,      7,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (8,      8,                  STATUS_UNSUCCESSFUL),
    MAPWSERROR (9,      WSAEBADF,           STATUS_INVALID_PARAMETER),
    MAPWSERROR (10,     10,                 STATUS_UNSUCCESSFUL),     
    MAPWSERROR (11,     11,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (12,     12,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (13,     WSAEACCES,          STATUS_ACCESS_DENIED),
    MAPWSERROR (14,     WSAEFAULT,          STATUS_ACCESS_VIOLATION),
    MAPWSERROR (15,     15,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (16,     16,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (17,     17,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (18,     18,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (19,     19,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (20,     20,                 STATUS_UNSUCCESSFUL),      
    MAPWSERROR (21,     21,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (22,     WSAEINVAL,          STATUS_INVALID_PARAMETER),
    MAPWSERROR (23,     23,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (24,     WSAEMFILE,          STATUS_TOO_MANY_ADDRESSES),
    MAPWSERROR (25,     25,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (26,     26,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (27,     27,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (28,     28,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (29,     29,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (30,     30,                 STATUS_UNSUCCESSFUL),      
    MAPWSERROR (31,     31,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (32,     32,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (33,     33,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (34,     34,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (35,     WSAEWOULDBLOCK,     STATUS_MORE_PROCESSING_REQUIRED),          
    MAPWSERROR (36,     WSAEINPROGRESS,     STATUS_DEVICE_BUSY),
    MAPWSERROR (37,     WSAEALREADY,        STATUS_UNSUCCESSFUL),
    MAPWSERROR (38,     WSAENOTSOCK,        STATUS_INVALID_HANDLE),
    MAPWSERROR (39,     WSAEDESTADDRREQ,    STATUS_INVALID_PARAMETER),
    MAPWSERROR (40,     WSAEMSGSIZE,        STATUS_BUFFER_OVERFLOW),
    MAPWSERROR (41,     WSAEPROTOTYPE,      STATUS_INVALID_PARAMETER),
    MAPWSERROR (42,     WSAENOPROTOOPT,     STATUS_NOT_SUPPORTED),
    MAPWSERROR (43,     WSAEPROTONOSUPPORT, STATUS_NOT_SUPPORTED),
    MAPWSERROR (44,     WSAESOCKTNOSUPPORT, STATUS_NOT_SUPPORTED),
    MAPWSERROR (45,     WSAEOPNOTSUPP,      STATUS_NOT_SUPPORTED),
    MAPWSERROR (46,     WSAEPFNOSUPPORT,    STATUS_NOT_SUPPORTED),
    MAPWSERROR (47,     WSAEAFNOSUPPORT,    STATUS_NOT_SUPPORTED),
    MAPWSERROR (48,     WSAEADDRINUSE,      STATUS_ADDRESS_ALREADY_EXISTS),
    MAPWSERROR (49,     WSAEADDRNOTAVAIL,   STATUS_INVALID_ADDRESS_COMPONENT),
    MAPWSERROR (50,     WSAENETDOWN,        STATUS_UNEXPECTED_NETWORK_ERROR),
    MAPWSERROR (51,     WSAENETUNREACH,     STATUS_NETWORK_UNREACHABLE),
    MAPWSERROR (52,     WSAENETRESET,       STATUS_CONNECTION_RESET),
    MAPWSERROR (53,     WSAECONNABORTED,    STATUS_CONNECTION_ABORTED),
    MAPWSERROR (54,     WSAECONNRESET,      STATUS_CONNECTION_RESET),      
    MAPWSERROR (55,     WSAENOBUFS,         STATUS_INSUFFICIENT_RESOURCES),
    MAPWSERROR (56,     WSAEISCONN,         STATUS_CONNECTION_ACTIVE),
    MAPWSERROR (57,     WSAENOTCONN,        STATUS_INVALID_CONNECTION),
    MAPWSERROR (58,     WSAESHUTDOWN,       STATUS_INVALID_CONNECTION),
    MAPWSERROR (59,     WSAETOOMANYREFS,    STATUS_UNSUCCESSFUL),
    MAPWSERROR (60,     WSAETIMEDOUT,       STATUS_IO_TIMEOUT),
    MAPWSERROR (61,     WSAECONNREFUSED,    STATUS_CONNECTION_REFUSED),
    MAPWSERROR (62,     WSAELOOP,           STATUS_UNSUCCESSFUL),
    MAPWSERROR (63,     WSAENAMETOOLONG,    STATUS_NAME_TOO_LONG),
    MAPWSERROR (64,     WSAEHOSTDOWN,       STATUS_HOST_UNREACHABLE),
    MAPWSERROR (65,     WSAEHOSTUNREACH,    STATUS_HOST_UNREACHABLE),
    MAPWSERROR (66,     WSAENOTEMPTY,       STATUS_UNSUCCESSFUL),
    MAPWSERROR (67,     WSAEPROCLIM,        STATUS_INSUFFICIENT_RESOURCES),
    MAPWSERROR (68,     WSAEUSERS,          STATUS_UNSUCCESSFUL),
    MAPWSERROR (69,     WSAEDQUOT,          STATUS_INSUFFICIENT_RESOURCES),
    MAPWSERROR (70,     WSAESTALE,          STATUS_UNSUCCESSFUL),
    MAPWSERROR (71,     WSAEREMOTE,         STATUS_UNSUCCESSFUL),
    MAPWSERROR (72,     72,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (73,     73,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (74,     74,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (75,     75,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (76,     76,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (77,     77,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (78,     78,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (79,     79,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (80,     80,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (81,     81,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (82,     82,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (83,     83,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (84,     84,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (85,     85,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (86,     86,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (87,     87,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (88,     88,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (89,     89,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (90,     90,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (91,     WSASYSNOTREADY,     STATUS_MISSING_SYSTEMFILE),
    MAPWSERROR (92,     WSAVERNOTSUPPORTED, STATUS_UNSUCCESSFUL),
    MAPWSERROR (93,     WSANOTINITIALISED,  STATUS_APP_INIT_FAILURE),
    MAPWSERROR (94,     94,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (95,     95,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (96,     96,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (97,     97,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (98,     98,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (99,     99,                 STATUS_UNSUCCESSFUL),
    MAPWSERROR (100,    100,                STATUS_UNSUCCESSFUL),
    MAPWSERROR (101,    WSAEDISCON,         STATUS_GRACEFUL_DISCONNECT),
    MAPWSERROR (102,    WSAENOMORE,         STATUS_NO_MORE_ENTRIES),
    MAPWSERROR (103,    WSAECANCELLED,      STATUS_CANCELLED),
    MAPWSERROR (104,    WSAEINVALIDPROCTABLE,STATUS_UNSUCCESSFUL),
    MAPWSERROR (105,    WSAEINVALIDPROVIDER,STATUS_UNSUCCESSFUL),
    MAPWSERROR (106,    WSAEPROVIDERFAILEDINIT,STATUS_UNSUCCESSFUL),
    MAPWSERROR (107,    WSASYSCALLFAILURE,  STATUS_UNSUCCESSFUL),
    MAPWSERROR (108,    WSASERVICE_NOT_FOUND,STATUS_INVALID_SYSTEM_SERVICE),
    MAPWSERROR (109,    WSATYPE_NOT_FOUND,  STATUS_UNSUCCESSFUL),
    MAPWSERROR (110,    WSA_E_NO_MORE,      STATUS_NO_MORE_ENTRIES),
    MAPWSERROR (111,    WSA_E_CANCELLED,    STATUS_CANCELLED),
    MAPWSERROR (112,    WSAEREFUSED,        STATUS_CONNECTION_REFUSED)
    };
        // This is most likely code
    if (dwError==NO_ERROR)
        return NO_ERROR;
        // Process winsock codes
    else if ((dwError>=WSABASEERR) 
            && (dwError<WSABASEERR+sizeof(WSAEMap)/sizeof(WSAEMap[0])))
        return WSAEMap[dwError-WSABASEERR];
        // Process system specific codes
    else {
        switch (dwError) {
        case WSA_IO_PENDING:
        case WSA_IO_INCOMPLETE:
            return STATUS_UNSUCCESSFUL;
        case WSA_INVALID_HANDLE:
            return STATUS_INVALID_HANDLE;
        case WSA_INVALID_PARAMETER:
            return STATUS_INVALID_PARAMETER;
        case WSA_NOT_ENOUGH_MEMORY:
            return STATUS_INSUFFICIENT_RESOURCES;
        case WSA_OPERATION_ABORTED:  
            return STATUS_CANCELLED;
        default:
            return STATUS_UNSUCCESSFUL;
        }
    }

}


DWORD
AllowServiceDemandStart (
    SC_HANDLE hService
    )
/*++

Routine Description:

    Add the SERVICE_START right to Authenticated users with respect to this service. 

Arguments:

    hService - The service in question.

Notes:

    This code assumes that the Authenticated users SID is present in the DACL of the
    service (documented in MSDN)

Return Value:

    NO_ERROR, if successful.

    Win32 error code, on failure.

--*/
{
    int i;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
    DWORD rc;
    DWORD sdSz;
    PSECURITY_DESCRIPTOR pSD;
    PACL pDacl, pNewDacl;
    BOOL bDaclPresent, bDaclDefaulted, bAceFound;
    PACCESS_ALLOWED_ACE pAce;


    //
    // Initialize locals for error cleanup below.
    //
    pSid = NULL;
    pSD = NULL;
    pNewDacl = NULL;
    bDaclDefaulted = FALSE;

    if (!AllocateAndInitializeSid (&sia,
            1,
            SECURITY_WORLD_RID,
            0,0,0,0,0,0,0,
            &pSid
            )) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx AllowServiceDemandStart:"
            " Failed to allocate SID, err: %ld\n",
            PID, rc));
        goto cleanup;
    }

    //
    // Figure out how much buffer is needed for holding the service's
    // Security Descriptor (SD).
    //
    // NOTE: We pass &pSD instead of pSD because this parameter should
    //       not be NULL. For this call to QueryServiceObjectSecurity()
    //       we just need to pass some non-zero and valid buffer.
    //
    sdSz = 0;
    if (!QueryServiceObjectSecurity(
                  hService,                     // Handle of the service
                  DACL_SECURITY_INFORMATION,    // Type of info requested
                  &pSD,                         // Address of Security descriptor
                  0,                            // Size of SD buffer
                  &sdSz                           // Size of buffer needed
                  )) {
        rc = GetLastError ();
        if (rc!=ERROR_INSUFFICIENT_BUFFER && sdSz!=0) {
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Failed to get service DACL size info, err: %ld\n",
                PID, rc));
            goto cleanup;
        }
    }

    //
    // Allocate the SD
    //
    pSD = (PSECURITY_DESCRIPTOR) ALLOC_MEM (sdSz);
    if (pSD==NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx AllowServiceDemandStart:"
            " Failed to allocate memory (%d bytes) for service sd, err: %ld\n",
            PID, sdSz, rc));
        goto cleanup;
    }


    //
    // Now, we are ready to get the service's SD.
    //
    if (!QueryServiceObjectSecurity(
                  hService,                     // Handle of the service
                  DACL_SECURITY_INFORMATION,    // Type of info requested
                  pSD,                          // Address of Security descriptor
                  sdSz,                           // Size of SD buffer
                  &sdSz                           // Size of buffer needed
                  )) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx AllowServiceDemandStart:"
            " Failed to get service DACL info, err: %ld\n",
            PID, rc));
        goto cleanup;
    }

    //
    // Get the DACL from SD, if present.
    //
    if (!GetSecurityDescriptorDacl(
                  pSD,                  // Address of SD
                  &bDaclPresent,        // Address of flag for presence of DACL
                  &pDacl,               // Address of pointer to DACL
                  &bDaclDefaulted       // Address of flag that indicates if
                  )) {                   // DACL was defaulted.
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx AllowServiceDemandStart:"
            " Failed to get DACL from service sd, err: %ld\n",
            PID, rc));
        goto cleanup;
    }

    //
    // Find the ACE in the ACL and update it's Mask.
    // If we can't find one, we'll have to add our own
    //
    bAceFound = FALSE;
    if (bDaclPresent && pDacl!=NULL) {
        for (i = 0; i < pDacl->AceCount; i++) {
            if (!GetAce(pDacl,              // pointer to ACL
                          i,                // index of ACE to retrieve
                          (LPVOID*) &pAce   // pointer to pointer to ACE
                          )) {
                rc = GetLastError ();
                WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx AllowServiceDemandStart:"
                    " Failed to get ACE # %d from DACL, err: %ld\n",
                    PID, i, rc));
                goto cleanup;
            }

            if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE && 
                    EqualSid(pSid, &(pAce->SidStart))) {
                pAce->Mask |= SERVICE_START|SERVICE_QUERY_STATUS;
                bAceFound = TRUE;
                break;
            }
        } // for ()
    }

    if (!bAceFound) {
        //
        // Could not find the ACE, add our own ace to DACL
        //
        ACL_SIZE_INFORMATION szInfo;
        ACL_REVISION_INFORMATION revInfo;
        SECURITY_DESCRIPTOR_CONTROL control;
        DWORD sdRev;

        if (bDaclPresent && pDacl!=NULL) {
            //
            // Read old DACL info to move it to new DACL
            //
            if (!GetAclInformation (pDacl, &szInfo, sizeof (szInfo), AclSizeInformation) ||
                !GetAclInformation (pDacl, &revInfo, sizeof (revInfo), AclRevisionInformation) ) {
                rc = GetLastError ();
                WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx AllowServiceDemandStart:"
                    " Failed to get DACL size/revision info, err: %ld\n",
                    PID, rc));
                goto cleanup;
            }
        }
        else {
            //
            // Need to create DACL from scratch
            //
            szInfo.AclBytesInUse = sizeof (ACL);
            revInfo.AclRevision = ACL_REVISION;
        }

        //
        // Allocate and initialize DACL
        //
        szInfo.AclBytesInUse += FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                                GetLengthSid (pSid);
        pNewDacl = ALLOC_MEM (szInfo.AclBytesInUse);
        if (pNewDacl==NULL) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Failed to get allocate new DACL (%d bytes), err: %ld\n",
                PID, szInfo.AclBytesInUse, rc));
            goto cleanup;
        }

        if (!InitializeAcl (pNewDacl, szInfo.AclBytesInUse, revInfo.AclRevision)) {
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Failed to initialize new DACL (rev %d), err: %ld\n",
                PID, revInfo.AclRevision, rc));
            goto cleanup;
        }

        //
        // Add ace allowing starting the service
        //
        if (!AddAccessAllowedAce (pNewDacl, revInfo.AclRevision, SERVICE_START|SERVICE_QUERY_STATUS, pSid)) {
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Could not add ace to new DACL , err: %ld\n",
                PID, rc));
            goto cleanup;
        }

        //
        // If old dacl existed, move ACE's from it to new DACL
        //
        if (bDaclPresent && pDacl!=NULL) {
            //
            // Get ACE list from old DACL
            // Must succeed since we did it above.
            //
            GetAce (pDacl, 0, (LPVOID *)&pAce);

            //
            // Add them right after ours
            //
            if (!AddAce (pNewDacl, 
                            revInfo.AclRevision,
                            1,
                            pAce, 
                            pDacl->AclSize-sizeof(ACL))) {
                rc = GetLastError ();
                WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx AllowServiceDemandStart:"
                    " Could move ACE's to new DACL , err: %ld\n",
                    PID, rc));
                goto cleanup;
            }
        }

    
        if (!GetSecurityDescriptorControl (pSD, &control, &sdRev)) {
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Failed to get SD control/revision info, err: %ld\n",
                PID, rc));
            goto cleanup;
        }

        //
        // Convert service security descriptor to absolute format.
        //
        if (control & SE_SELF_RELATIVE) {
            DWORD absSz = sdSz;
            if (!MakeAbsoluteSD2 (pSD, &absSz)) {
                PSECURITY_DESCRIPTOR pAbsSd;
                rc = GetLastError ();
                if (rc!=ERROR_INSUFFICIENT_BUFFER) {
                    WshPrint (DBG_SERVICE|DBG_FAILURES,
                        ("WS2HELP-%lx AllowServiceDemandStart:"
                        " Failed convert service sd to absolute format (for size), err: %ld\n",
                        PID, rc));
                    goto cleanup;
                }

                pAbsSd = (PSECURITY_DESCRIPTOR) ALLOC_MEM (absSz);
                if (pAbsSd==NULL) {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                    WshPrint (DBG_SERVICE|DBG_FAILURES,
                        ("WS2HELP-%lx AllowServiceDemandStart:"
                        " Failed to allocate memory (%d bytes) for absolute service sd, err: %ld\n",
                        PID, absSz, rc));
                    goto cleanup;
                }

                CopyMemory (pAbsSd, pSD, sdSz);
                FREE_MEM (pSD);
                sdSz = absSz;
                pSD = pAbsSd;

                if (!MakeAbsoluteSD2 (pSD, &sdSz)) {
                    rc = GetLastError ();
                    WshPrint (DBG_SERVICE|DBG_FAILURES,
                        ("WS2HELP-%lx AllowServiceDemandStart:"
                        " Failed convert service sd to absolute format (reallocated), err: %ld\n",
                        PID, rc));
                    goto cleanup;
                }
            }
        } // if SE_SELF_RELATIVE


        //
        // Set new DACL into security decriptor.
        //
        if (!SetSecurityDescriptorDacl(pSD,     // SD
                                        TRUE,   // DACL presence
                                        pNewDacl,  // DACL
                                        bDaclDefaulted // default DACL
                                        )) {
            rc = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx AllowServiceDemandStart:"
                " Could not set new DACL in sd, err: %ld\n",
                PID, rc));
            goto cleanup;
        }
    }

    //
    // Set the new SD on the service handle
    //
    if (!SetServiceObjectSecurity(
                hService,                   // Handle to the service.
                DACL_SECURITY_INFORMATION,  // Type of info being set
                pSD                         // Address of the new SD
                )) {
        rc = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
            ("WS2HELP-%lx AllowServiceDemandStart:"
            " Failed to set service DACL info, err: %ld\n",
            PID, rc));
        goto cleanup;
    }

    rc = 0;


cleanup:
    //
    // Cleanup
    //
    if (pSid) {
        FreeSid(pSid);
    }

    if (pSD) {
        FREE_MEM (pSD);
    }

    if (pNewDacl) {
        FREE_MEM (pNewDacl);
    }

    return rc;
}

DWORD
DemandStartWS2IFSL (
    VOID
    )
{
    SC_HANDLE   hSCManager, hService;
    INT         err;
    NTSTATUS    status;

    WshPrint (DBG_SERVICE,
        ("WS2HELP-%lx DemandStartWS2IFSL: Attempting to start ...\n", PID));

    //
    // First attempt to load driver directly in the current process.
    // This is much faster that communicate to SC over RPC, especially
    // during boot when SC is not fully initialized or busy.
    //
    status = RtlImpersonateSelf (SecurityImpersonation);
    if (NT_SUCCESS (status)) {
        BOOLEAN wasEnabled;
        status =
            RtlAdjustPrivilege(
                SE_LOAD_DRIVER_PRIVILEGE,
                TRUE,
                TRUE,
                &wasEnabled
                );
        if (NT_SUCCESS (status)) {
            UNICODE_STRING  servicePath;

            RtlInitUnicodeString (&servicePath, WS2IFSL_SERVICE_PATH);
            status = NtLoadDriver (&servicePath);
            if (!wasEnabled) {
#if DBG
                NTSTATUS status2 =
#endif
                RtlAdjustPrivilege(
                    SE_LOAD_DRIVER_PRIVILEGE,
                    FALSE,
                    TRUE,
                    &wasEnabled
                    );
                WS_ASSERT(NT_SUCCESS(status2));
            }
        }
        else {
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx DemandStartWS2IFSL: Failed to get load driver privilige, status: 0x%lx.\n",
                    PID, status));
        }

        RevertToSelf ();

        if (NT_SUCCESS (status)) {
            WshPrint (DBG_SERVICE,
                    ("WS2HELP-%lx DemandStartWS2IFSL: Loaded driver OK.\n",
                    PID));
            return NO_ERROR;
        }
        else {
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx DemandStartWS2IFSL: Failed to load driver, status: 0x%lx.\n",
                    PID, status));
        }
    }
    else {
        WshPrint (DBG_SERVICE|DBG_FAILURES,
                ("WS2HELP-%lx DemandStartWS2IFSL: Failed to impersonate self, status: 0x%lx.\n",
                PID, status));
    }

    //
    // Open service database on the local computer
    //
    hSCManager = OpenSCManager (
                        NULL,
                        SERVICES_ACTIVE_DATABASE,
                        SC_MANAGER_CONNECT|SC_MANAGER_ENUMERATE_SERVICE
                        );
    if (hSCManager!=NULL) {

        //
        // Open service itself
        //

        hService = OpenService (
                    hSCManager,
                    WS2IFSL_SERVICE_NAME,
                    SERVICE_START | SERVICE_QUERY_STATUS);
        if (hService!=NULL) {

            //
            // Go ahead, try start the service
            //
            if (!StartService (hService, 0, NULL)) {
                //
                // Check if it is already running
                //
                err = GetLastError ();
                if (err!=ERROR_SERVICE_ALREADY_RUNNING) {
                    //
                    // Could not start it, bail out
                    //
                    WshPrint (DBG_SERVICE|DBG_FAILURES,
                            ("WS2HELP-%lx DemandStartWS2IFSL: Could not start service, err: %ld\n",
                            PID, err));
                    goto cleanup;
                }
                else {
                    WshPrint (DBG_SERVICE,
                            ("WS2HELP-%lx DemandStartWS2IFSL: Service is already running, err: %ld\n",
                        PID, err));
                }
            }
            else {
                do {
                    SERVICE_STATUS status;
                    if (!QueryServiceStatus(hService, &status)) {
                        err = GetLastError ();
                        WshPrint (DBG_SERVICE|DBG_FAILURES,
                            ("WS2HELP-%lx DemandStartWS2IFSL: Could not query service status, err: %ld\n",
                            PID, err));
                        //
                        // Ignore the error here.
                        //
                        break;
                    }

                    if (status.dwCurrentState != SERVICE_START_PENDING) {
                        if (status.dwCurrentState==SERVICE_RUNNING) {
                            WshPrint (DBG_SERVICE,
                                        ("WS2HELP-%lx DemandStartWS2IFSL: Service has been started.\n",
                                        PID));
                            break;
                        }
                        else {
                            WshPrint (DBG_SERVICE|DBG_FAILURES,
                                        ("WS2HELP-%lx DemandStartWS2IFSL: Failed to start service, status: %ld\n",
                                        PID, status.dwCurrentState));
                            err = WSAENETDOWN;
                            goto cleanup;
                        }
                    }
                    //
                    // Yield to another thread on current processor.
                    // If no threads are ready to run on current processor,
                    // we'll have to sleep to avoid consuming too much CPU
                    // in what would look almost like busy wait.
                    //
                    if (!SwitchToThread()) {
                        Sleep (10);
                    }
                }
                while (TRUE);
            }
            err = NO_ERROR;
        cleanup:
            CloseServiceHandle (hService);
        }
        else {
            err = GetLastError ();
            WshPrint (DBG_SERVICE|DBG_FAILURES,
                        ("WS2HELP-%lx DemandStartWS2IFSL: Could open service, err: %ld\n",
                        PID, err));
        }

        CloseServiceHandle (hSCManager);
    }
    else {

        err = GetLastError ();
        WshPrint (DBG_SERVICE|DBG_FAILURES,
                    ("WS2HELP-%lx DemandStartWS2IFSL: Could not open SC, err: %ld\n",
                    PID, err));
    }

    switch (err) {
    case NO_ERROR:
    case WSAENETDOWN:
    case ERROR_NOT_ENOUGH_MEMORY:
        {
            C_ASSERT (ERROR_NOT_ENOUGH_MEMORY==WSA_NOT_ENOUGH_MEMORY);
        }
        break;
    case ERROR_ACCESS_DENIED:
        err = WSAEACCES;
        break;
    default:
        err = WSASYSNOTREADY;
    }
    return err;
}




DWORD
Ws2helpInitialize (
    VOID
    ) {
    EnterCriticalSection (&StartupSyncronization);
    if (!Ws2helpInitialized) {
        NewCtxInit ();
#if DBG
        //ReadDbgInfo ();
#endif
        Ws2helpInitialized = TRUE;
    }
    LeaveCriticalSection (&StartupSyncronization);

    return 0;
}

#if DBG

VOID
ReadDbgInfo (
    VOID
    ) {
    TCHAR                       ProcessFilePath[MAX_PATH+1];
    LPTSTR                      pProcessFileName = NULL;
    HKEY                        hDebugKey;
    DWORD                       sz, rc, level;

    PID = GetCurrentProcessId ();
    if (GetModuleFileName(NULL, ProcessFilePath, sizeof(ProcessFilePath)) > 0) {
        pProcessFileName = _tcsrchr(ProcessFilePath, '\\');
        if (pProcessFileName!=NULL)
            pProcessFileName += 1;
        else
            pProcessFileName = ProcessFilePath;
    }
    else
        DbgPrint("WS2HELP-%lx ReadDbgInfo: Could not get process name, err=%ld.\n",
                 PID, GetLastError ());

    if (pProcessFileName != NULL) {

        if ((rc=RegOpenKeyExA (HKEY_LOCAL_MACHINE,
                WS2IFSL_DEBUG_KEY,
                0,
                KEY_QUERY_VALUE,
                &hDebugKey))==NO_ERROR) {

            sz = sizeof (DbgLevel);
            if (RegQueryValueEx (hDebugKey,
                    pProcessFileName,
                    NULL,
                    NULL, 
                    (LPBYTE)&level,
                    &sz)==0) {
			    DbgLevel = level;
                DbgPrint ("WS2HELP-%lx ReadDbgInfo: DbgLevel set to %lx.\n",
                           PID, DbgLevel);
            }

            RegCloseKey (hDebugKey);
        
        }
        else if (rc!=ERROR_FILE_NOT_FOUND)
            DbgPrint ("WS2HELP-%lx ReadDbgInfo: Could not open dbg key (%s), err=%ld.\n",
                       PID, WS2IFSL_DEBUG_KEY, rc);

    }

}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2help\nt\newctx.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    newctx.h

Abstract:

    This module implements functions for creating and manipulating context
    tables. Context tables are used in WinSock 2.0 for associating 32-bit
    context values with socket handles.

Author:

    Vadim Eyldeman (VadimE)       11-Nov-1997

Revision History:

--*/

#define _RW_LOCK_       1
//
// Private data types
//

// Handle -> context hash table
typedef struct _CTX_HASH_TABLE {
    ULONG                   NumBuckets; // Size of the table
                                        // Have to keep size we the table
                                        // to be able to atomically replace
                                        // the whole thing when expansion
                                        // is required
    LPWSHANDLE_CONTEXT      Buckets[1]; // Hash buckets with context ptr
} CTX_HASH_TABLE, FAR * LPCTX_HASH_TABLE;

typedef volatile LONG VOLCTR;
typedef VOLCTR *PVOLCTR;

   

// Handle -> context lookup table
typedef struct _CTX_LOOKUP_TABLE {
    volatile LPCTX_HASH_TABLE HashTable;// Pointer to current hash table
                                        // Replaced atomically on table
                                        // expansion
#ifdef _RW_LOCK_                        // Lock that protects the table
    VOLCTR                  EnterCounter;// Counter of number of readers
                                        // that entered the table combined
                                        // with the index if exit counter to use.
    VOLCTR                  ExitCounter[2];// Corresponding exit counters
    LONG					SpinCount;	// Number of times spin before resorting
										// to context switch while waiting for
										// readers to go away
    BOOL                    ExpansionInProgress;// Flag that indicates that
                                        // table expansion is in progress
                                        // and writer lock must be acquired
                                        // before any modifications (event
                                        // atomic can be made)
#ifdef _PERF_DEBUG_
	LONG					WriterWaits;
	LONG					FailedSpins;
    LONG                    FailedSwitches;
    LONG                    CompletedWaits;
#define RecordWriterWait(tbl)	    (tbl)->WriterWaits += 1
#define RecordFailedSpin(tbl)	    (tbl)->FailedSpins += 1
#define RecordFailedSwitch(tbl)	    (tbl)->FailedSwitches += 1
#define RecordCompletedWait(tbl)    (tbl)->CompletedWaits += 1
#else
#define RecordWriterWait(tbl)
#define RecordFailedSpin(tbl)
#define RecordFailedSwitch(tbl)
#define RecordCompletedWait(tbl)
#endif
#endif //_RW_LOCK_
    CRITICAL_SECTION        WriterLock;
} CTX_LOOKUP_TABLE, FAR * LPCTX_LOOKUP_TABLE;

// Handle -> context table
struct _CONTEXT_TABLE {
    ULONG               HandleToIndexMask;// Mask used to dispatch between
                                        // several hash tables
    CTX_LOOKUP_TABLE    Tables[1];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2help\nt\apc.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    apc.c

Abstract:

    This module implements the APC helper functions for the WinSock 2.0
    helper library.

Author:

    Keith Moore (keithmo)       20-Jun-1995

Revision History:

--*/


#include "precomp.h"


//
//  Private constants.
//

#define FAKE_HELPER_HANDLE  ((HANDLE)'MKC ')


//
//  Public functions.
//


DWORD
WINAPI
WahOpenApcHelper(
    OUT LPHANDLE HelperHandle
    )

/*++

Routine Description:

    This routine opens the WinSock 2.0 APC helper device.

Arguments:

    HelperHandle - Points to a HANDLE that will receive an open handle
        to the APC helper device.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
    DWORD   rc;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( HelperHandle == NULL ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Just return a fake handle.
    //

    *HelperHandle = FAKE_HELPER_HANDLE;

    return NO_ERROR;

}   // WahOpenApcHelper


DWORD
WINAPI
WahCloseApcHelper(
    IN HANDLE HelperHandle
    )

/*++

Routine Description:

    This function closes the WinSock 2.0 APC helper device.

Arguments:

    HelperHandle - The handle to close.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
    DWORD   rc;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( HelperHandle != FAKE_HELPER_HANDLE ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Nothing to do.
    //

    return NO_ERROR;

}   // WahCloseApcHelper


DWORD
WINAPI
WahOpenCurrentThread(
    IN  HANDLE HelperHandle,
    OUT LPWSATHREADID ThreadId
    )

/*++

Routine Description:

    This function opens a handle to the current thread.

Arguments:

    HelperHandle - An open handle to the APC helper device.

    ThreadId - Points to a WSATHREADID structure that will receive
        an open handle to the current thread and an (optional) OS-
        dependent thread identifier.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{

    HANDLE currentProcess;
    HANDLE currentThread;
    DWORD  rc;


    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( ( HelperHandle != FAKE_HELPER_HANDLE ) ||
        ( ThreadId == NULL ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Grab the current process & thread handles.
    //

    currentProcess = GetCurrentProcess();
    currentThread = GetCurrentThread();

    //
    //  Duplicate the current thread pseudo handle.
    //

    if( DuplicateHandle(
            currentProcess,                         // hSourceProcessHandle
            currentThread,                          // hSourceHandle
            currentProcess,                         // hTargetProcessHandle
            &ThreadId->ThreadHandle,                // lpTargetHandle
            0,                                      // dwDesiredAttributes
            FALSE,                                  // bInheritHandle
            DUPLICATE_SAME_ACCESS                   // dwOptions
            ) ) {

        //
        //  The NT implementation of the APC helper does not really
        //  need the OS-dependent thread identifier, but we'll store
        //  the current thread ID in the structure just for completeness.
        //

        ThreadId->Reserved = GetCurrentThreadId ();

        return NO_ERROR;

    }

    return GetLastError();

}   // WahOpenCurrentThread


DWORD
WINAPI
WahCloseThread(
    IN HANDLE HelperHandle,
    IN LPWSATHREADID ThreadId
    )

/*++

Routine Description:

    This routine closes an open thread handle.

Arguments:

    HelperHandle - An open handle to the APC helper device.

    ThreadId - Points to a WSATHREADID structure initialized by a
        previous call to WahOpenCurrentThread().

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{

    DWORD  rc;


    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( ( HelperHandle != FAKE_HELPER_HANDLE ) ||
        ( ThreadId == NULL ) ||
        ( ThreadId->ThreadHandle == NULL ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Close the handle.
    //

    if( CloseHandle( ThreadId->ThreadHandle ) ) {

        //
        //  Clear the fields in case the client tries something.
        //

        ThreadId->ThreadHandle = NULL;
        ThreadId->Reserved = 0;

        return NO_ERROR;

    }

    return GetLastError();

}   // WahCloseThread


DWORD
WINAPI
WahQueueUserApc(
    IN HANDLE HelperHandle,
    IN LPWSATHREADID ThreadId,
    IN LPWSAUSERAPC ApcRoutine,
    IN ULONG_PTR ApcContext OPTIONAL
    )

/*++

Routine Description:

    This routine queues a user-mode APC for the specified thread.

Arguments:

    HelperHandle - An open handle to the APC helper device.

    ThreadId - Points to a WSATHREADID structure initialized by a
        previous call to WahOpenCurrentThread().

    ApcRoutine - Points to the APC code to execute when the specified
        thread enters an alertable wait.

    ApcContext - An uninterpreted context value to pass to the APC routine.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
    DWORD  rc;


    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;


    //
    //  Validate parameters.
    //

    if( ( HelperHandle != FAKE_HELPER_HANDLE ) ||
        ( ThreadId == NULL ) ||
        ( ThreadId->ThreadHandle == NULL ) ||
        ( ApcRoutine == NULL ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Queue the APC.
    //

    if( QueueUserAPC(
            (PAPCFUNC)ApcRoutine,                   // pfnAPC
            ThreadId->ThreadHandle,                 // hThread
            ApcContext                              // dwData
            ) ) {

        //
        //  Success.
        //

        return NO_ERROR;

    }

    return GetLastError();

}   // WahQueueUserApc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2help\nt\newctx.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    newctx.c

Abstract:

    This module implements functions for creating and manipulating context
    tables. Context tables are used in WinSock 2.0 for associating 32-bit
    context values with socket handles.

Author:

    Vadim Eyldeman (VadimE)       11-Nov-1997

Revision History:

--*/


#include "precomp.h"
#include "newctx.h"


//
// Private contstants
//

//
// Min & max allowable values for number of handle lookup tables
// (must be some number == 2**N for optimal performance)
//
#define MIN_HANDLE_BUCKETS_WKS 0x8
#define MAX_HANDLE_BUCKETS_WKS 0x20
#define MIN_HANDLE_BUCKETS_SRV 0x20
#define MAX_HANDLE_BUCKETS_SRV 0x100

//
// Default & maximum spin count values (for critical section creation)
//

#define DEF_SPIN_COUNT 2000
#define MAX_SPIN_COUNT 8000


//
// Private globals
//

// Prime numbers used for closed hashing
ULONG const SockPrimes[] =
{
    31, 61, 127, 257, 521, 1031, 2053, 4099, 8191,
    16381, 32749, 65537, 131071, 261983, 
    0xFFFFFFFF  // Indicates end of the table, next number must be computed
                // on the fly.
};

DWORD   gdwSpinCount=0;     // Spin count used in critical sections
ULONG   gHandleToIndexMask; // Actual mask is currently the same for
                            // all tables in this DLL.
HANDLE  ghWriterEvent;      // Event for writer to wait on for readers
                            // if spinning and simple sleep fail.

//
// Table access macros.
//
// This uses property of Win NT handles which have two low order bits 0-ed
#define TABLE_FROM_HANDLE(_h,_tbls) \
            (&(_tbls)->Tables[((((ULONG_PTR)_h) >> 2) & (_tbls)->HandleToIndexMask)])

// Hash function (no need to shift as we use prime numbers)
#define HASH_BUCKET_FROM_HANDLE(_h,_hash) \
            ((_hash)->Buckets[(((ULONG_PTR)_h) % (_hash)->NumBuckets)])


//
// RW_LOCK macros
//

//VOID
//AcquireTableReaderLock (
//  IN  LPCTX_LOOKUP_TABLE     tbl,
//  OUT LONG                   idx
//  );
/*++
*******************************************************************
Routine Description:
    Acquires reader access to table
Arguments:
    tbl - table to lock
    idx - idx of the exit counter to release.
Return Value:
    NONE
*******************************************************************
--*/
#ifdef _RW_LOCK_

#define AcquireTableReaderLock(tbl,idx)                                 \
            idx = (InterlockedExchangeAdd ((LPLONG)&(tbl)->EnterCounter,2) & 1)

#else  //_RW_LOCK_

#define AcquireTableReaderLock(tbl,idx)                             \
            idx = (EnterCriticalSection(&tbl->WriterLock),0)

#endif //_RW_LOCK_

//VOID
//ReleaseTableReaderLock (
//  IN  LPCTX_LOOKUP_TABLE     tbl
//  IN  LONG                   idx
//  );
/*++
*******************************************************************
Routine Description:
    Releases reader access to table
Arguments:
    lock - pointer to lock
    idx - index of the counter to release 
Return Value:
    None
*******************************************************************
--*/
#ifdef _RW_LOCK_

#define ReleaseTableReaderLock(tbl,idx)                                     \
    /* Increment the exit counter to let the writer determine when all */   \
    /* the readers that incremented enter counter are gone */               \
    if (InterlockedExchangeAdd((LPLONG)&(tbl)->ExitCounter[idx],2)==idx){   \
        /* When writer needs a signal, it changes the counter, so that */   \
        /* last reader decrements the counting part to 0 and index part */  \
        /* corresponds to another counter */                                \
        BOOL    res;                                                        \
        ASSERT (ghWriterEvent!=NULL);                                       \
        res = PulseEvent (ghWriterEvent);                                   \
        ASSERT (res);                                                       \
    }


#else  //_RW_LOCK_

#define ReleaseTableReaderLock(tbl,idx)                             \
            LeaveCriticalSection (&(tbl)->WriterLock)

#endif //_RW_LOCK_


//VOID
//AcquireTableWriterLock (
//  IN  LPCTX_LOOKUP_TABLE  tbl
//  );
/*++
*******************************************************************
Routine Description:
    Acquires writer access to table
Arguments:
    tbl - table to lock
Return Value:
    None
*******************************************************************
--*/
#define AcquireTableWriterLock(tbl) EnterCriticalSection(&(tbl)->WriterLock)

//VOID
//ReleaseTableWriterLock (
//  IN  LPCTX_LOOKUP_TABLE  tbl
//  );
/*++
*******************************************************************
Routine Description:
    Releases writer access to table
Arguments:
    tbl - table to lock
Return Value:
    None
*******************************************************************
--*/
#define ReleaseTableWriterLock(tbl) LeaveCriticalSection(&(tbl)->WriterLock)


//VOID
//WaitForAllReaders (
//  IN  LPSOCK_LOOKUP_TABLE    tbl
//  );
/*++
*******************************************************************
Routine Description:
    Waits for all readers that are in process of accessing the table
Arguments:
    tbl - table
Return Value:
    None
*******************************************************************
--*/
#ifdef _RW_LOCK_

//
// Execute long wait (context switch requred) for readers
// Extra function call won't make much difference here.
//

VOID
DoWaitForReaders (
    LPCTX_LOOKUP_TABLE  Tbl,
    LONG                Ctr,
    LONG                Idx
    )
{

    /* Force context switch to let the reader(s) go */
    SwitchToThread ();
    if (Tbl->ExitCounter[Idx]!=Ctr) {
        RecordFailedSwitch (Tbl);
        /* If we failed we must be dealing with lower priority thread */ 
        /* waiting to execute on another  processor, wait on event to */
        /* let it proceed */
        if (ghWriterEvent==NULL) {
            /* Need to allocate a manual reset event */
            HANDLE  hEvent;
#if DBG || EVENT_CREATION_FAILURE_COUNT
            static long count = 0;
#ifndef EVENT_CREATION_FAILURE_COUNT
#define EVENT_CREATION_FAILURE_COUNT 0
#endif
            static long failure_rate = EVENT_CREATION_FAILURE_COUNT;
            if (count<failure_rate) {
                hEvent = NULL;
                count += 1;
            }
            else
#endif
                hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

            if (hEvent!=NULL) {
                /* Make sure someone else did not do it too*/
                if (InterlockedCompareExchangePointer (
                                    (PVOID *)&ghWriterEvent,
                                    hEvent,
                                    NULL)!=NULL) {
                    /* Event is already there, free ours */
                    CloseHandle (hEvent);
                }
            }
            else {
                /* Could not allocate event, will have to */
                /* use sleep to preempt ourselves */
                if (Ctr!=Tbl->ExitCounter[Idx]) {
                    Sleep (10);
                }
                return;
            }
        }
        /* Substract the enter count from the counter to make it 0 when all */
        /* the readers are gone and add the value of the index, so */
        /* that the last reader notices and signals us. */
        Ctr = 0-Ctr+Idx;
        if (InterlockedExchangeAdd((LPLONG)&Tbl->ExitCounter[Idx], Ctr)!=Idx) {
            do {
                DWORD rc;
                /* We can't just wait forever because readers */
                /* pulse the event, we may miss it (can't set */
                /* because event is shared) */
                rc = WaitForSingleObject (ghWriterEvent, 10);   
                ASSERT (rc==WAIT_OBJECT_0 || rc==WAIT_TIMEOUT);
                RecordCompletedWait (Tbl);
            }
            while (Tbl->ExitCounter[Idx]!=Idx);
        }
    }                                                           
}


#define WaitForAllReaders(tbl)         {                            \
    LONG    idx = (tbl)->EnterCounter&1;                            \
    LONG    ctr;                                                    \
    /* Initialize the other exit counter with opposite index.*/     \
    (tbl)->ExitCounter[idx^1] = idx;                                \
    /* Read the enter counter and exit counter index and */         \
    /* reinitialize it with other exit counter index. */            \
    ctr = InterlockedExchange ((LPLONG)&(tbl)->EnterCounter,idx^1)^1;\
    /* Check if old exit counter has reached the same value */      \
    if (ctr!=(tbl)->ExitCounter[idx]) {                             \
        /* Some readers remain, we'll have to wait for them*/       \
        RecordWriterWait(tbl);                                      \
        /* Spin in case reader is executing on another processor */ \
        /* (SpinCount can only be non-zero on MP machines) */       \
        if ((tbl)->SpinCount) {                                     \
            LONG spinCtr = (tbl)->SpinCount;                        \
            while (ctr!=(tbl)->ExitCounter[idx]) {                  \
                if (--spinCtr<=0) {                                 \
                    RecordFailedSpin(tbl);                          \
                    break;                                          \
                }                                                   \
            }                                                       \
        }                                                           \
        if (ctr!=(tbl)->ExitCounter[idx]) {                         \
            /* Still someone there, we'll have to context switch */ \
            DoWaitForReaders (tbl,ctr,idx);                         \
        }                                                           \
    }                                                               \
}

#else //_RW_LOCK_

#define WaitForAllReaders(tbl)         {                            \
}

#endif //_RW_LOCK_

//
// Function called during DLL initialization to peek up
// system parameters and initialize globals
//
VOID
NewCtxInit (
    VOID
    ) {
    ULONG           numLookupTables;
    NT_PRODUCT_TYPE productType;
    HKEY            hKey;
    ULONG           dwDataSize, dwDataType, dwBitMask;
    SYSTEM_INFO     sysInfo;


    productType = NtProductWinNt;

    if (!RtlGetNtProductType (&productType)) {
        productType = NtProductWinNt;
    }

    GetSystemInfo (&sysInfo);

    //
    // Spin only on MP machines.
    //
    if (sysInfo.dwNumberOfProcessors>1) {
        gdwSpinCount = DEF_SPIN_COUNT;
    }
    else {
        gdwSpinCount = 0;
    }
    //
    // Determine the # of lookup table entries or "handle buckets".
    // This number will vary depending on whether the platform is NT
    // Server or not. Allow configuration of this value via registry,
    // and make sure that the # of buckets is reasonable given the
    // platform, and that it is some value == 2**N so our handle->lock
    // mapping scheme is optimal.
    //
    // Also retrieve the spin count for use in calling
    // InitializeCriticalSectionAndSpinCount()
    //


    numLookupTables = ( productType==NtProductWinNt ?
        MIN_HANDLE_BUCKETS_WKS : MIN_HANDLE_BUCKETS_SRV );

    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Services\\Winsock2\\Parameters"),
            0,
            KEY_QUERY_VALUE,
            &hKey

            ) == ERROR_SUCCESS) {

        dwDataSize = sizeof (numLookupTables);
        RegQueryValueEx(
            hKey,
            TEXT("Ws2_32NumHandleBuckets"),
            0,
            &dwDataType,
            (LPBYTE) &numLookupTables,
            &dwDataSize
            );

        if (sysInfo.dwNumberOfProcessors>1) {
            // Spinning only makes sense on multiprocessor machines
            dwDataSize = sizeof (gdwSpinCount);
            RegQueryValueEx(
                hKey,
                TEXT("Ws2_32SpinCount"),
                0,
                &dwDataType,
                (LPBYTE) &gdwSpinCount,
                &dwDataSize
                );
        }

        RegCloseKey (hKey);
    }

    // Make sure the number is power of 2 and whithin the limits
    for(
        dwBitMask = MAX_HANDLE_BUCKETS_SRV;
        (dwBitMask & numLookupTables) == 0;
        dwBitMask >>= 1
        );
    numLookupTables = dwBitMask;

    if ( productType==NtProductWinNt ) {

        if ( numLookupTables > MAX_HANDLE_BUCKETS_WKS ) {

            numLookupTables = MAX_HANDLE_BUCKETS_WKS;

        }
        else if ( numLookupTables < MIN_HANDLE_BUCKETS_WKS ){

            numLookupTables = MIN_HANDLE_BUCKETS_WKS;
        }
    }
    else {

        if ( numLookupTables > MAX_HANDLE_BUCKETS_SRV ) {

            numLookupTables = MAX_HANDLE_BUCKETS_SRV;

        }
        else if ( numLookupTables < MIN_HANDLE_BUCKETS_SRV ){

            numLookupTables = MIN_HANDLE_BUCKETS_SRV;
        }
    }
    if (gdwSpinCount>MAX_SPIN_COUNT) {
        gdwSpinCount = MAX_SPIN_COUNT;
    }

    gHandleToIndexMask = numLookupTables - 1;
}


WS2HELPAPI
DWORD
WINAPI
WahCreateHandleContextTable(
    OUT LPCONTEXT_TABLE FAR * Table
    ) 
/*++

Routine Description:

    Creates handle -> context lookup table

Arguments:

    Table   -   Returns pointer to the created table


Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
    INT     return_code = ERROR_SUCCESS;
    ULONG   i;
    LPCONTEXT_TABLE table;

    return_code = ENTER_WS2HELP_API ();
    if (return_code!=0)
        return return_code;


    //
    // Allocate & initialize the handle lookup table
    //

    table = ALLOC_MEM (FIELD_OFFSET (struct _CONTEXT_TABLE,
                            Tables[gHandleToIndexMask+1]));

    if ( table == NULL ) {

        return WSA_NOT_ENOUGH_MEMORY;
    }

    table->HandleToIndexMask = gHandleToIndexMask;

    for ( i = 0; i <= gHandleToIndexMask; i++ ) {

        table->Tables[i].HashTable = NULL;
#ifdef _RW_LOCK_
        table->Tables[i].EnterCounter = 0;
        table->Tables[i].ExitCounter[0] = 1;
        table->Tables[i].ExitCounter[1] = 0;
        table->Tables[i].ExpansionInProgress = FALSE;
        table->Tables[i].SpinCount = gdwSpinCount;
#ifdef _PERF_DEBUG_
        table->Tables[i].WriterWaits = 0;
        table->Tables[i].FailedSpins = 0;
        table->Tables[i].FailedSwitches = 0;
        table->Tables[i].CompletedWaits = 0;
#endif
#endif //_RW_LOCK_
        __try {
            if (!InitializeCriticalSectionAndSpinCount (
                    &table->Tables[i].WriterLock,
                    gdwSpinCount
                    ))
                goto Cleanup;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            goto Cleanup;
        }
    }

    *Table = table;
    return ERROR_SUCCESS;

Cleanup:
    while (i-- > 0) {
        DeleteCriticalSection (&table->Tables[i].WriterLock);
    }
    FREE_MEM (table);
    return WSA_NOT_ENOUGH_MEMORY;
}

WS2HELPAPI
DWORD
WINAPI
WahDestroyHandleContextTable(
    LPCONTEXT_TABLE Table
    )
/*++

Routine Description:

    Destroys handle -> context lookup table

Arguments:

    Table   -   Supplies pointer to the table to destory


Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    ULONG i;

//  Valid table pointer required anyway.
//    return_code = ENTER_WS2HELP_API ();
//    if (return_code!=0)
//        return return_code;

    if (Table!=NULL) {

        for ( i = 0; i <= Table->HandleToIndexMask; i++ ) {
            
            if ( Table->Tables[i].HashTable != NULL) {

                FREE_MEM (Table->Tables[i].HashTable);
            }

            DeleteCriticalSection (&Table->Tables[i].WriterLock);
        }

        FREE_MEM (Table);
        return ERROR_SUCCESS;
    }
    else {
        return ERROR_INVALID_PARAMETER;
    }

}

WS2HELPAPI
LPWSHANDLE_CONTEXT
WINAPI
WahReferenceContextByHandle(
    LPCONTEXT_TABLE Table,
    HANDLE          Handle
    )
/*++

Routine Description:

    Looks up context for the handle in the table

Arguments:

    Table   -   Supplies pointer to the table in which to lookup

    Handle  -   Supplies WinNT object handle to find context for


Return Value:

    REFERENCED context for the handle if found, 
    NULL if it does not exist

--*/
{
    LPWSHANDLE_CONTEXT  ctx;
    LPCTX_LOOKUP_TABLE  table = TABLE_FROM_HANDLE(Handle,Table);
    LPCTX_HASH_TABLE    hash;
    LONG                idx;

//  Valid table pointer required anyway.
//    return_code = ENTER_WS2HELP_API ();
//    if (return_code!=0)
//        return return_code;

    // Take the lock
    AcquireTableReaderLock (table, idx);
    hash = table->HashTable;

    // Make sure that context exists and for the right handle
    if ((hash!=NULL)
            && ((ctx=HASH_BUCKET_FROM_HANDLE(
                                        Handle,
                                        hash))!=NULL)
            && (ctx->Handle==Handle)) {
        WahReferenceHandleContext(ctx);
    }
    else {
        ctx = NULL;
    }
    ReleaseTableReaderLock (table, idx);

    return ctx;
}

WS2HELPAPI
LPWSHANDLE_CONTEXT
WINAPI
WahInsertHandleContext(
    LPCONTEXT_TABLE     Table,
    LPWSHANDLE_CONTEXT  HContext
    )
/*++

Routine Description:

    Inserts context for the handle in the table.

Arguments:

    Table   -   Supplies pointer to the table into which to insert

    HContext -  Supplies handle context to insert which contains
                handle value and internally\externally used
                reference count


Return Value:
    NULL    -   context could not be inserted because of allocation failure
    HContext -  context was successfully inserted into empty cell
    other context - HContext replaced another context which is returned to
                    the caller

--*/
{
    LPWSHANDLE_CONTEXT  *pBucket, oldContext;
    LONG                idx;
    LPCTX_HASH_TABLE    hash, newHashTable;
    ULONG               newNumHashBuckets, i;
    LPCTX_LOOKUP_TABLE  table = TABLE_FROM_HANDLE(HContext->Handle,Table);

//  Valid table pointer required anyway.
//    return_code = ENTER_WS2HELP_API ();
//    if (return_code!=0)
//        return return_code;

    do {
#ifdef _RW_LOCK_
        AcquireTableReaderLock(table, idx);
        hash = table->HashTable;
        //
        // First make sure we have already initialized hash table
        // and it is not being expanded at the moment
        //
        if (!table->ExpansionInProgress && (hash!=NULL)) {
            pBucket = &HASH_BUCKET_FROM_HANDLE(HContext->Handle,hash);
            //
            // Try to insert handle context into the table
            //
            if (InterlockedCompareExchangePointer (
                            (PVOID *)pBucket,
                            HContext,
                            NULL)==NULL) {
                //
                // If bucket was empty and thus we succeded, get out.
                //
                ReleaseTableReaderLock(table,idx);
                oldContext = HContext;
                break;
            }
            else {
                //
                // Another context for the same handle exists or collision 
                // in hash value, need to go the long way with the exclusive lock
                // held (we will either need to replace the context or expand
                // the table, in both cases we need to make sure that no-one
                // can be still looking at the table or the context after
                // we return.
                //
            }
        }
        else {
            //
            // Table is empty, need to create one
            //
        }

        ReleaseTableReaderLock(table,idx);
#endif //_RW_LOCK_

        //
        // Acquire writer lock for table expansion operation.
        //
        AcquireTableWriterLock (table);

        //
        // Make sure no-one is trying to modify the table
        //
#ifdef _RW_LOCK_
        table->ExpansionInProgress = TRUE;
#endif //_RW_LOCK_
        WaitForAllReaders (table);

        do {
            hash = table->HashTable;
            if (hash!=NULL) {

                //
                // First check if we can succeed with the current table
                // We use the same logic as above, except we now have full
                // control of the table, so no need for interlocked operations
                //

                pBucket = &HASH_BUCKET_FROM_HANDLE (HContext->Handle, hash);
                if (*pBucket==NULL) {
                    oldContext = HContext;
                    *pBucket = HContext;
                    break;
                }
                else if ((*pBucket)->Handle==HContext->Handle) {
                    oldContext = *pBucket;
                    *pBucket = HContext;
                    break;
                }


                //
                // We in fact have to resort to table expansion
                // Remember the table size to know where to start
                //
                newNumHashBuckets = hash->NumBuckets;
            }
            else {
                //
                // Table was in fact empty, we 'll have to build one
                //
                newNumHashBuckets = 0;
            }

            //
            // Actual table expansion loop
            //
        TryAgain:

            //
            // Find the next prime number.
            //
            for (i = 0; newNumHashBuckets>=SockPrimes[i]; i++)
                ;

            if (SockPrimes[i]!=0xFFFFFFFF) {
                newNumHashBuckets = SockPrimes[i];
            }
            else {
                //
                // Reached the end of precomputed primes, simply
                // double the size of the table (we are getting
                // real big now, any mapping should do).
                //
                newNumHashBuckets *= 2;
            }


            newHashTable = (LPCTX_HASH_TABLE) ALLOC_MEM(
                        FIELD_OFFSET (
                                CTX_HASH_TABLE,
                                Buckets[newNumHashBuckets])
                        );
            if (newHashTable!=NULL) {
                newHashTable->NumBuckets = newNumHashBuckets;

                ZeroMemory(
                    newHashTable->Buckets,
                    newNumHashBuckets * sizeof (newHashTable->Buckets[0])
                );

                //
                // Well, first insert the new object, that's why we are
                // there in the first place.
                //

                HASH_BUCKET_FROM_HANDLE(HContext->Handle, newHashTable) = HContext;

                if (hash!=NULL) {
                    //
                    // The previous table wasn't empty, we need to
                    // move all the entries.  Note that we have
                    // already freezed all the table modifications
                    // above.
                    //

                    for (i=0 ; i<hash->NumBuckets; i++) {

                        if (hash->Buckets[i] != NULL) {

                            pBucket = &HASH_BUCKET_FROM_HANDLE(
                                hash->Buckets[i]->Handle,
                                newHashTable
                                );

                            if (*pBucket == NULL) {

                                *pBucket = hash->Buckets[i];

                            } else {
                                ASSERT ((*pBucket)->Handle!=hash->Buckets[i]->Handle);
                                FREE_MEM (newHashTable);

                                //
                                // Collision *after* we expanded, goto next size table
                                //
                                goto TryAgain;
                            }
                        }
                    }
                    //
                    // Table was successfully moved, safe to destroy
                    // the old one except we need to wait while no-one
                    // is accessing it.
                    //
                    table->HashTable = newHashTable;
                    WaitForAllReaders (table);
                    FREE_MEM( hash );
                }
                else {
                    //
                    // That's our hash table now.
                    //
                    table->HashTable = newHashTable;
                }
                oldContext = HContext;
            }
            else {

                oldContext = NULL;
            }
        }
        while (0);

        //
        // Set or restore the hash table before releasing the lock
        //
#ifdef _RW_LOCK_
        table->ExpansionInProgress = FALSE;
#endif //_RW_LOCK_
        ReleaseTableWriterLock(table);
    }
    while (0);

    return oldContext;
}

WS2HELPAPI
DWORD
WINAPI
WahRemoveHandleContext(
    LPCONTEXT_TABLE     Table,
    LPWSHANDLE_CONTEXT  HContext
    )
/*++

Routine Description:

    Removes context for the handle from the table

Arguments:

    Table   -   Supplies pointer to the table from which to remove

    HContext -  Supplies handle context to insert which contains
                handle value and internally\externally used
                reference count


Return Value:

    NO_ERROR - success, ERROR_INVALID_PARAMETER context did not exist
    in the table
--*/
{
    LPWSHANDLE_CONTEXT  *pBucket;
    LPCTX_LOOKUP_TABLE  table = TABLE_FROM_HANDLE(HContext->Handle,Table);
    LPCTX_HASH_TABLE    hash;
    DWORD               rc = NO_ERROR;

//  Valid table pointer required anyway.
//    return_code = ENTER_WS2HELP_API ();
//    if (return_code!=0)
//        return return_code;

    AcquireTableWriterLock(table);
    hash = table->HashTable;
    pBucket = &HASH_BUCKET_FROM_HANDLE(HContext->Handle,hash);
    if ((hash!=NULL)
            // Use interlocked operation to make sure we won't remove
            // another context.
            && (InterlockedCompareExchangePointer (
                        (PVOID *)pBucket,
                        NULL,
                        HContext)==HContext)) {
            // Wait for all who might be trying to access this block,
            // so that the caller can free it.
        WaitForAllReaders (table);
    }
    else {
        rc = ERROR_INVALID_PARAMETER;
    }
    ReleaseTableWriterLock(table);
    return rc;
}


WS2HELPAPI
BOOL
WINAPI
WahEnumerateHandleContexts(
    LPCONTEXT_TABLE         Table,
    LPFN_CONTEXT_ENUMERATOR Enumerator,
    LPVOID                  EnumCtx
    ) 
/*++

Routine Description:

    Calls specified enumeration procedure for all contexts in the table
    untill enumeration function returns FALSE.
    While enumeration is performed the table is completely locked
    for any modifications (read access is still allowed).  It is OK to
    call table modification procedures from inside the enumeration
    function (modification lock allows for recursion).

Arguments:

    Table   -   Supplies pointer to the table to enumerate

    Enumerator  - pointer to enumeration function defined as follows:
        typedef 
            BOOL  
            (WINAPI * LPFN_CONTEXT_ENUMERATOR)(
                LPVOID              EnumCtx,    // Enumeration context
                LPWSHANDLE_CONTEXT  HContext    // Handle context
                );

    EnumCtx - context to pass to enumeration function

Return Value:

    Returns result returned by the enumeration function

--*/
{
    ULONG               i,j;
    LPWSHANDLE_CONTEXT  hContext;
    BOOL                res = TRUE;


//  Valid table pointer required anyway.
//    return_code = ENTER_WS2HELP_API ();
//    if (return_code!=0)
//        return return_code;

    for (i = 0; i <= Table->HandleToIndexMask; i++)
    {
        LPCTX_LOOKUP_TABLE  table = &Table->Tables[i];
        LPCTX_HASH_TABLE    hash;


        AcquireTableWriterLock(table);
#ifdef _RW_LOCK_
        table->ExpansionInProgress = TRUE;
#endif //_RW_LOCK_
        WaitForAllReaders (table);
        hash = table->HashTable;

        if (hash!=NULL) {
            for (j=0; j<hash->NumBuckets; j++) {
                hContext = hash->Buckets[j];
                if (hContext==NULL)
                    continue;

                res = Enumerator (EnumCtx, hContext);
                if (!res)
                    break;
            }
        }
#ifdef _RW_LOCK_
        table->ExpansionInProgress = FALSE;
#endif //_RW_LOCK_
        ReleaseTableWriterLock(table);
        if (!res)
            break;
    }
    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2help\nt\whcperf.c ===
#include "precomp.h"
#include "newctx.h"
#include <stdlib.h>

LPCONTEXT_TABLE     gContextTable = NULL;
LPWSHANDLE_CONTEXT  gHandleContexts = NULL;
UINT                gNumHandles = 0;
UINT                gWRratio = 0;
LONG                gInserts = 0;
LONG                gInsertTime = 0;
LONG                gRemoves = 0;
LONG                gRemoveTime = 0;
LONG                gLookups = 0;
LONG                gLookupTime = 0;
DWORD				gNumProcessors;
LONG                gInteropSpins;

HANDLE              gSemaphore, gEvent;
volatile BOOL       gRun;
LONG                gNumThreads;

DWORD
StressThread (
    PVOID   param
    );


#define USAGE(x)    \
    "Usage:\n"\
    "   %s <num_threads> <num_handles> <write_access_%%> <time_to_run> <spins\n"\
    "   where\n"\
    "       <num_threads>   - number of threads (1-64);\n"\
    "       <num_handles>   - number of handles;\n"\
    "       <write_access_%%>  - percentage of write accesses (0-100);\n"\
    "       <time_to_run>   - time to run in sec;\n"\
    "       <spins>          - number of spins between operations.\n"\
    ,x


int _cdecl
main (
    int argc,
    CHAR **argv
    )
{
    LONG    TimeToRun, RunTime;
    HANDLE  Threads[MAXIMUM_WAIT_OBJECTS];
    DWORD   id, rc;
    UINT    err, i;
    UINT    numThreads;
    ULONG   rnd = NtGetTickCount ();
    ULONG   resolution;
    NTSTATUS status;
    LPWSHANDLE_CONTEXT  ctx;
	SYSTEM_INFO	info;

    if (argc<6) {
        printf (USAGE(argv[0]));
        return 1;
    }

	GetSystemInfo (&info);
	gNumProcessors = info.dwNumberOfProcessors;

    gNumThreads = atoi(argv[1]);
    if ((gNumThreads==0)||(gNumThreads>MAXIMUM_WAIT_OBJECTS)) {
        printf (USAGE(argv[0]));
        return 1;
    }

    gNumHandles = atoi(argv[2]);
    if (gNumHandles==0) {
        printf (USAGE(argv[0]));
        return 1;
    }


    gWRratio = atoi(argv[3]);
    if (gWRratio>100) {
        printf (USAGE(argv[0]));
        return 1;
    }

    TimeToRun = atoi(argv[4]);
    if (TimeToRun==0) {
        printf (USAGE(argv[0]));
        return 1;
    }

    gInteropSpins = atoi(argv[5]);

    gSemaphore = CreateSemaphore (NULL, 0, gNumThreads, NULL);
    if (gSemaphore==NULL) {
        printf ("Failed to create semaphore, err: %ld.\n", GetLastError ());
        return 1;
    }

    gEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
    if (gEvent==NULL) {
        printf ("Failed to create event, err: %ld.\n", GetLastError ());
        return 1;
    }

    //
    // Set timer resolution to 0.5 msec.
    //
    status = NtSetTimerResolution (5000, TRUE, &resolution);
    if (!NT_SUCCESS (status)) {
        printf ("Failed to set timer resolution, status: %lx\n", status);
        return 1;
    }
    printf ("Timer resolution is set @ %ld usec\n", resolution/10);


    err = WahCreateHandleContextTable (&gContextTable);
    if (err!=NO_ERROR) {
        printf ("Failed to create context table, err: %ld.\n", err);
        return 1;
    }

    gHandleContexts = (LPWSHANDLE_CONTEXT)
                            GlobalAlloc (
                                    GPTR,
                                    sizeof (WSHANDLE_CONTEXT)*gNumHandles
                                    );
    if (gHandleContexts==NULL) {
        printf ("Failed to allocate table of handle contexts, gle: %ld.\n",
                            GetLastError ());
        return 1;
    }

    for (i=0, ctx=gHandleContexts; i<gNumHandles; ) {

        ctx->RefCount = 1;
        do {
            ctx->Handle = (HANDLE)((((ULONGLONG)RtlRandom (&rnd)*(ULONGLONG)gNumHandles*(ULONGLONG)20)
                                        /((ULONGLONG)MAXLONG))
                                    &(~((ULONGLONG)3)));
        }
        while (WahReferenceContextByHandle (gContextTable, ctx->Handle)!=NULL);

        if (WahInsertHandleContext (gContextTable, ctx)!=ctx) {
            printf ("Failed to insert handle %p into the table.\n", ctx->Handle);
            return 1;
        }
        if ((i%128)==0) printf ("Handles created: %8.8ld\r", i);
        i++; ctx++;
    }
    printf ("Handles created: %8.8ld\n", i);

	if (!SetPriorityClass (GetCurrentProcess (), HIGH_PRIORITY_CLASS)) {
		printf ("Failed to set high priority class for the process, err: %ld.\n",
						GetLastError ());
		return 1;
	}

    numThreads = gNumThreads;
    for (i=0; i<numThreads; i++) {
        Threads[i] = CreateThread (NULL,
                                0,
                                StressThread,
                                (PVOID)i,
                                0,
                                &id
                                );
        if (Threads[i]==NULL) {
            printf ("Failed to create thread %ld, gle: %ld.\n",
                        i, GetLastError ());
            return 1;
        }
    }

    while (numThreads>0) {
        rc = WaitForSingleObject (gSemaphore, INFINITE);
        if (rc!=WAIT_OBJECT_0) {
            printf ("Failed wait for semaphore, res: %ld, err: %ld.\n", rc, GetLastError ());
            return 1;
        }
        numThreads -= 1;
        printf ("Threads to start: %8.8ld\r", numThreads);
    }
    printf ("\n");
    printf ("Starting...\n");
    RunTime = NtGetTickCount ();
    gRun = TRUE;
    rc = SignalObjectAndWait (gEvent, gSemaphore, TimeToRun*1000, FALSE);
    if (rc!=WAIT_TIMEOUT) {
        printf ("Wait for non-signaled semaphore returned: %ld, err: %ld.\n", rc, GetLastError ());
        return 1;
    }
    RunTime = NtGetTickCount()-RunTime;
    gRun = FALSE;
    
    printf ("Done, waiting for %ld threads to terminate...\n", gNumThreads);

    rc = WaitForMultipleObjects (gNumThreads, Threads, TRUE, INFINITE);


    printf ("Number of inserts    : %8.8lu.\n", gInserts);
    printf ("Inserts per ms       : %8.8lu.\n", gInserts/gInsertTime);
    printf ("Number of removes    : %8.8lu.\n", gRemoves);
    printf ("Removes per ms       : %8.8lu.\n", gRemoves/gRemoveTime);
    printf ("Number of lookups    : %8.8lu.\n", gLookups);
    printf ("Lookups per ms       : %8.8lu.\n", gLookups/gLookupTime);
    printf ("Running time         : %8.8lu.\n", RunTime);
    printf ("Total thread time    : %8.8lu.\n", gInsertTime+gRemoveTime+gLookupTime);
#ifdef _PERF_DEBUG_
    {
        LONG    ContentionCount = 0;
#ifdef _RW_LOCK_
        LONG    WriterWaits = 0;
        LONG    FailedSpins = 0;
        LONG    FailedSwitches = 0;
        LONG    CompletedWaits = 0;
#endif

        for ( i = 0; i <= gContextTable->HandleToIndexMask; i++ ) {

#ifdef _RW_LOCK_
            WriterWaits += gContextTable->Tables[i].WriterWaits;
            FailedSpins += gContextTable->Tables[i].FailedSpins;
            FailedSwitches += gContextTable->Tables[i].FailedSwitches;
            CompletedWaits += gContextTable->Tables[i].CompletedWaits;
#endif
            if (gContextTable->Tables[i].WriterLock.DebugInfo!=NULL)
                ContentionCount += gContextTable->Tables[i].WriterLock.DebugInfo->ContentionCount;
        }

#ifdef _RW_LOCK_
        printf ("Writer waits: %ld\n", WriterWaits);
        printf ("Failed spins: %ld\n", FailedSpins);
        printf ("Failed switches: %ld\n", FailedSwitches);
        printf ("Completed waits: %ld\n", CompletedWaits);
#endif
        printf ("Contention count: %ld\n", ContentionCount);
    }
#endif
	WahDestroyHandleContextTable (gContextTable);
    return 0;
}


DWORD
StressThread (
    PVOID   param
    )
{
    ULONG               idx;
    ULONG               rnd = NtGetTickCount ();
    LPWSHANDLE_CONTEXT  ctx;
    ULONG               RunTime;
	ULONGLONG			cTime, eTime, kTime1, kTime2, uTime1, uTime2;
	LONG                lInserts = 0, lInsertTime = 0;
	LONG                lRemoves = 0, lRemoveTime = 0;
	LONG                lLookups = 0, lLookupTime = 0;
    LONG                Spin;
    DWORD               rc;

	if (!SetThreadAffinityMask (GetCurrentThread (),
						1<<(PtrToUlong(param)%gNumProcessors))) {
		printf ("Failed to set thread's %ld affinity mask, err: %ld.\n",
					PtrToUlong(param), GetLastError ());
		ExitProcess (1);
	}

    rc = SignalObjectAndWait (gSemaphore, gEvent, INFINITE, FALSE);
    if (rc!=WAIT_OBJECT_0) {
        printf ("Wait for start event in thread %ld returned: %ld, err: %ld\n",
                         PtrToUlong(param), rc, GetLastError ());
        ExitProcess (1);
    }
	GetThreadTimes (GetCurrentThread (), (LPFILETIME)&cTime,
											(LPFILETIME)&eTime,
											(LPFILETIME)&kTime1,
											(LPFILETIME)&uTime1);
    RunTime = NtGetTickCount ();

    while (gRun) {
        idx = (ULONG)(((ULONGLONG)RtlRandom (&rnd)*(ULONGLONG)gNumHandles)/(ULONGLONG)MAXLONG);
        ctx = &gHandleContexts[idx];
        if ( (ULONG)(((ULONGLONG)rnd*(ULONGLONG)100)/(ULONGLONG)MAXLONG) < gWRratio) {
            lRemoveTime -= NtGetTickCount ();
            if (WahRemoveHandleContext (gContextTable, ctx)==NO_ERROR) {
                lRemoveTime += NtGetTickCount ();

                Spin = gInteropSpins;
                while (Spin--);

                ctx->RefCount = 1;
                lInsertTime -= NtGetTickCount ();
                WahInsertHandleContext (gContextTable, ctx);
                lInsertTime += NtGetTickCount ();
                lInserts += 1;
            }
            else {
                lRemoveTime += NtGetTickCount ();
            }
            lRemoves += 1;

        }
        else {
            lLookupTime -= NtGetTickCount ();
            WahReferenceContextByHandle (gContextTable, ctx->Handle);
            lLookupTime += NtGetTickCount ();
            lLookups += 1;
        }

        Spin = gInteropSpins;
        while (Spin--);
    }
	GetThreadTimes (GetCurrentThread (), (LPFILETIME)&cTime,
											(LPFILETIME)&eTime,
											(LPFILETIME)&kTime2,
											(LPFILETIME)&uTime2);
    //printf ("Thread %d ran for %lu ms, kernel mode: %lu, user mode: %lu.\n",
    //				param,
	//			NtGetTickCount ()-RunTime,
	//			(ULONG)((kTime2-kTime1)/(ULONGLONG)10000),
	//			(ULONG)((uTime2-uTime1)/(ULONGLONG)10000)
	//			);

	InterlockedExchangeAdd (&gInserts, lInserts);
	InterlockedExchangeAdd (&gInsertTime, lInsertTime);
	InterlockedExchangeAdd (&gRemoves, lRemoves);
	InterlockedExchangeAdd (&gRemoveTime, lRemoveTime);
	InterlockedExchangeAdd (&gLookups, lLookups);
	InterlockedExchangeAdd (&gLookupTime, lLookupTime);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2help\nt\wsht.c ===
#include "precomp.h"


#define USAGE(x)                        \
    "Usage:\n"\
    "   %s {s|c} name\n"\
    "   where\n"\
    "       s       -   run as the server (listen);\n"\
    "       c [machine pid number] -   run as the client (connect).\n"\
    ,x

HANDLE      hHelper;
OVERLAPPED  ovlp;

VOID WINAPI WsCompletion (
    DWORD           dwErrorCode,
    DWORD           dwNumberOfBytesTransfered,
    LPOVERLAPPED    lpOverlapped,
    DWORD           Flags
    );

int _cdecl
main (int argc, CHAR **argv) {
    DWORD   rc;
    BOOL    Server;

    if (argc<2) {
        printf (USAGE(argv[0]));
        return 0;
    }

    if (_stricmp (argv[1], "s")==0)
        Server = TRUE;
    else if (_stricmp (argv[1], "c")==0)
        Server = FALSE;
    else {
        printf ("Must specify s(erver) or c(lient).\n");
        printf (USAGE(argv[0]));
        return -1;
    }

    if ((rc=WahOpenNotificationHandleHelper (&hHelper))!=NO_ERROR) {
        printf ("WahOpenNotificationHandleHelper failed, err: %ld.\n", rc);
        return -1;
    }

    if (Server) {
        HANDLE  hSync, hApc, hAEvent, hAPort, hANoPort;
        OVERLAPPED  oApc, oEvent, oPort, oNoPort;
        LPOVERLAPPED lpo;
        HANDLE  hPort;
        HANDLE  hEvent;
        DWORD   count;
        ULONG_PTR key;

        hPort = CreateIoCompletionPort (
                    INVALID_HANDLE_VALUE,
                    NULL,
                    0,
                    0
                    );

        if (hPort==NULL) {
            printf ("CreateIoCompletionPort (create) failed, err: %ld.\n", GetLastError ());
            return -1;
        }

        hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (hEvent==NULL) {
            printf ("CreateEvent failed, err: %ld.\n", GetLastError ());
            return -1;
        }

        rc = WahCreateNotificationHandle (hHelper, &hSync);
        if (rc!=0) {
            printf ("WahCreateNotificationHandle failed, err: %ld.\n", rc);
            return -1;
        }

        rc = WahCreateNotificationHandle (hHelper, &hApc);
        if (rc!=0) {
            printf ("WahCreateNotificationHandle failed, err: %ld.\n", rc);
            return -1;
        }
        oApc.hEvent = NULL;

        rc = WahCreateNotificationHandle (hHelper, &hAEvent);
        if (rc!=0) {
            printf ("WahCreateNotificationHandle failed, err: %ld.\n", rc);
            return -1;
        }
        oEvent.hEvent = hEvent;

        rc = WahCreateNotificationHandle (hHelper, &hAPort);
        if (rc!=0) {
            printf ("WahCreateNotificationHandle failed, err: %ld.\n", rc);
            return -1;
        }
        if (CreateIoCompletionPort (hAPort, hPort, (ULONG_PTR)hAPort, 0)
               == INVALID_HANDLE_VALUE) {
            printf ("CreateIoCompletionPort (associate) failed, err: %ld.\n", GetLastError ());
            return -1;
        }
        oPort.hEvent = NULL;

        rc = WahCreateNotificationHandle (hHelper, &hANoPort);
        if (rc!=0) {
            printf ("WahCreateNotificationHandle failed, err: %ld.\n", rc);
            return -1;
        }
        if (CreateIoCompletionPort (hANoPort, hPort, (ULONG_PTR)hANoPort, 0)
               == INVALID_HANDLE_VALUE) {
            printf ("CreateIoCompletionPort (associate) failed, err: %ld.\n", GetLastError ());
            return -1;
        }
        oNoPort.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 1);

        while (1) {
            printf ("Posting apc wait.\n");
            rc = WahWaitForNotification (hHelper, hApc, &oApc, WsCompletion);
            if ((rc!=0) && (rc!=WSA_IO_PENDING)) {
                printf ("WahWaitForNotification(apc) failed, err: %ld.\n", rc);
                return -1;
            }

            printf ("Posting event wait.\n");
            rc = WahWaitForNotification (hHelper, hAEvent, &oEvent, NULL);
            if ((rc!=0) && (rc!=WSA_IO_PENDING)) {
                printf ("WahWaitForNotification(event) failed, err: %ld.\n", rc);
                return -1;
            }

            printf ("Posting port wait.\n");
            rc = WahWaitForNotification (hHelper, hAPort, &oPort, NULL);
            if ((rc!=0) && (rc!=WSA_IO_PENDING)) {
                printf ("WahWaitForNotification(port) failed, err: %ld.\n", rc);
                return -1;
            }

            printf ("Posting noport wait.\n");
            rc = WahWaitForNotification (hHelper, hANoPort, &oNoPort, NULL);
            if ((rc!=0) && (rc!=WSA_IO_PENDING)) {
                printf ("WahWaitForNotification(port) failed, err: %ld.\n", rc);
                return -1;
            }

            printf ("Posting sync wait.\n");
            memset (&ovlp, 0, sizeof (ovlp));
            rc = WahWaitForNotification (hHelper, hSync, NULL, NULL);
            if (rc!=0) {
                printf ("WahWaitForNotification failed, err: %ld.\n", rc);
                return -1;
            }

            printf ("Waiting for apc\n");
            rc = SleepEx (INFINITE, TRUE);
            if (rc!=WAIT_IO_COMPLETION) {
                printf ("Unexpected result on wait for apc: %ld.\n", rc);
                return rc;
            }

            printf ("Waiting for port\n");
            if (GetQueuedCompletionStatus (hPort, &count, &key, &lpo, INFINITE)) {
                rc = 0;
            }
            else if (lpo) {
                rc = GetLastError ();
                if (rc==0)
                    printf ("No error code for failed GetQueuedCompletionStatus.\n");
            }
            else {
                printf ("GetQueuedCompletionStatus failed, err: %ld.\n", GetLastError ());
                return -1;
            }
            if (key!=(ULONG_PTR)hAPort)
                printf ("Wrong completion key: %p (expected : %p)", key, hAPort);
            WsCompletion (rc, count, lpo, 0);

            printf ("Waiting for noport\n");
            oNoPort.hEvent = NULL;
            if (GetOverlappedResult (hANoPort, &oNoPort, &count, TRUE)) {
                rc = 0;
            }
            else {
                rc = GetLastError ();
                if (rc==0)
                    printf ("No error code for failed GetOverlappedResult.\n");
            }
            WsCompletion (rc, count, &oNoPort, 0);

            printf ("Waiting for event\n");
            if (GetOverlappedResult (hAEvent, &oEvent, &count, TRUE)) {
                rc = 0;
            }
            else {
                rc = GetLastError ();
                if (rc==0)
                    printf ("No error code for failed GetOverlappedResult.\n");
            }
            WsCompletion (rc, count, &oEvent, 0);
        }
        CloseHandle (hSync);
        CloseHandle (hANoPort);
        CloseHandle (hAPort);
        CloseHandle (hAEvent);
        CloseHandle (hApc);

        CloseHandle (hPort);
        CloseHandle (hEvent);
    }
    else if (argc<3) {
        rc = WahNotifyAllProcesses (hHelper);
        if (rc==0) {
            printf ("Notified all ok.\n");
        }
        else {
            printf ("WahNotifyAllProcesses failed, err: %ld.\n", rc);
        }
    }
    else if (argc>=5) {
        HANDLE          hPipe;
        DWORD           id = GetCurrentProcessId (), count;
        WCHAR           name[MAX_PATH];


        //
        // Create client and of the pipe that matched the
        // pattern
        //
        wsprintfW (name, L"\\\\%hs\\pipe\\Winsock2\\CatalogChangeListener-%hs-%hs", 
                    argv[2], argv[3], argv[4]);

        hPipe =  CreateFileW (name, 
                                GENERIC_WRITE, 
                                FILE_SHARE_READ, 
                                (LPSECURITY_ATTRIBUTES) NULL, 
                                OPEN_EXISTING, 
                                FILE_ATTRIBUTE_NORMAL, 
                                (HANDLE) NULL);
        if (hPipe!=INVALID_HANDLE_VALUE) {
            printf ("Opened pipe %ls.\n", name);
            CloseHandle (hPipe);
        }
        else {
            printf ("Could not open pipe %ls, err: %ld\n",
                name, GetLastError ());
        }
    }
    else
        printf (USAGE(argv[0]));

    WahCloseNotificationHandleHelper (hHelper);
    return 0;
}

VOID WINAPI WsCompletion (
    DWORD           dwErrorCode,
    DWORD           dwNumberOfBytesTransfered,
    LPOVERLAPPED    lpOverlapped,
    DWORD           dwFlags
    ) {
    if (dwErrorCode!=0) {
        printf ("Falure in WsCompletion, err: %ld.\n", dwErrorCode);
        ExitProcess (-1);
    }
    else {
        printf ("WsComletion: %d bytes transferred.\n", dwNumberOfBytesTransfered);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2help\nt\notify.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    notify.c

Abstract:

    This module implements the notification handle helper functions for the WinSock 2.0
    helper library.

Author:
    Vadim Eydelman (VadimE)


Revision History:

--*/
#include "precomp.h"
#include "osdef.h"
#include <accctrl.h>
#include <aclapi.h>

//
//  Private constants.
//
#define FAKE_NOTIFICATION_HELPER_HANDLE     ((HANDLE)'VD  ')
#define WS2_PIPE_BASE           L"\\Device\\NamedPipe\\"
#define WS2_PIPE_FORMAT         L"Winsock2\\CatalogChangeListener-%x-%x"
#define WS2_PIPE_WILDCARD       L"WINSOCK2\\CATALOGCHANGELISTENER-*-*"

/* Private Prototypes */
VOID
PipeListenApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

DWORD
GetWinsockRootSecurityDescriptor (
    OUT PSECURITY_DESCRIPTOR    *pDescr
    );

DWORD
BuildPipeSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR    pBaseDescr,
    OUT PSECURITY_DESCRIPTOR    *pDescr
    );


// Current pipe number (to avoid unnecessary collisions during
// pipe creation)
LONG PipeSerialNumber = 0;

// Security descriptor that we use to grant write permissions to pipe
// to only those who have write permisions to registry key with
// winsock catalog
PSECURITY_DESCRIPTOR        pSDPipe = NULL;

#if DBG
VOID        DumpSid (PSID pSid, LPSTR AccessType);
#endif


DWORD
WINAPI
WahOpenNotificationHandleHelper(
    OUT LPHANDLE HelperHandle
    )
/*++

Routine Description:

    This routine opens WinSock 2.0 notification handle helper device

Arguments:

    HelperHandle - Points to buffer ion which to return handle.


Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    DWORD   rc;
    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( HelperHandle == NULL ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Just return a fake handle.
    //

    *HelperHandle = FAKE_NOTIFICATION_HELPER_HANDLE;

    return NO_ERROR;

}   // WahOpenNotificationHandleHelper

DWORD
WINAPI
WahCloseNotificationHandleHelper(
    IN HANDLE HelperHandle
    )

/*++

Routine Description:

    This function closes the WinSock 2.0 notification helper device.

Arguments:

    HelperHandle - The handle to close.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/

{
    DWORD   rc;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    //
    //  Validate parameters.
    //

    if( HelperHandle != FAKE_NOTIFICATION_HELPER_HANDLE ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Nothing to do.
    //

    return NO_ERROR;

}   // WahCloseNotificationHandleHelper

DWORD
WINAPI
WahCreateNotificationHandle(
    IN HANDLE           HelperHandle,
    OUT HANDLE          *h
    )
/*++

Routine Description:

    This function creates notificaion handle to receive asyncronous
    interprocess notifications.

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.
    h            - buffer to return created notification handle

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    WCHAR               name[MAX_PATH];
    UNICODE_STRING      uName;
    OBJECT_ATTRIBUTES   attr;
    DWORD               rc = 0;
    LARGE_INTEGER       readTimeout;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;

    PSECURITY_DESCRIPTOR    pSDKey, pSDTemp;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;


    if (HelperHandle==NULL)
        return ERROR_INVALID_PARAMETER;
    else if ((HelperHandle!=FAKE_NOTIFICATION_HELPER_HANDLE)
            || (h==NULL))
        return ERROR_INVALID_PARAMETER;

    //
    // Build security descriptor for the pipe if we have not
    // already done this
    //

    if (pSDPipe==NULL) {
        //
        // First get security descriptor of the registry key that
        // contains the Winsock2 catalogs
        //
        rc = GetWinsockRootSecurityDescriptor (&pSDKey);
        if (rc==0) {
            //
            // Build the pipe security descriptor with grants
            // write permissions to same set of SIDs that have
            // write permissions to the registry key.
            //
            rc = BuildPipeSecurityDescriptor (pSDKey, &pSDTemp);
            if (rc==0) {
                //
                // Set the global if someone hasn't done this
                // while we were building it
                //
                if (InterlockedCompareExchangePointer (&pSDPipe,
                                            pSDTemp,
                                            NULL
                                            )!=NULL)
                    //
                    // Someone else did this, free ours
                    //
                    FREE_MEM (pSDTemp);
            }
            //
            // Free registry key descriptor
            //
            FREE_MEM (pSDKey);
        }
    }

    if (rc==0) {

        //
        // We use default timeout on our pipe (we do not actually
        // care what it is)
        //
        readTimeout.QuadPart =  -10 * 1000 * 50;

        do {
            //
            // Try to build unique pipe name using serial number
            //
            swprintf (name, WS2_PIPE_BASE WS2_PIPE_FORMAT,
                            GetCurrentProcessId(), PipeSerialNumber);
            InterlockedIncrement (&PipeSerialNumber);
            RtlInitUnicodeString( &uName, name );
            InitializeObjectAttributes (
                        &attr,
                        &uName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        pSDPipe);

            //
            // Try to create it
            //

            status = NtCreateNamedPipeFile (
                        h,                              // Handle
                        GENERIC_READ                    // DesiredAccess
                            | SYNCHRONIZE
                            | WRITE_DAC,
                        &attr,                          // Obja
                        &ioStatusBlock,                 // IoStatusBlock
                        FILE_SHARE_WRITE,               // Share access
                        FILE_CREATE,                    // CreateDisposition
                        0,                              // CreateFlags
                        FILE_PIPE_MESSAGE_TYPE,         // NamedPipeType
                        FILE_PIPE_MESSAGE_MODE,         // ReadMode
                        FILE_PIPE_QUEUE_OPERATION,      // CompletionMode
                        1,                              // MaxInstances
                        4,                              // InboundQuota
                        0,                              // OutboundQuota
                        &readTimeout                    // Timeout
                        );
            //
            // Continue on doing this if we have name collision
            // (serial number wrapped!!! or someone attempts to
            // interfere with out operation by using the same
            // naming scheme!!!)
            //
        }
        while (status==STATUS_OBJECT_NAME_COLLISION);

        if (NT_SUCCESS (status)) {
            WshPrint (DBG_NOTIFY,
                ("WS2HELP-%lx WahCreateNotificationHandle: Created pipe %ls.\n",
                PID, name));
            rc = 0;
        }
        else {
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx WahCreateNotificationHandle: Could not create pipe %ls, status: %lx\n",
                PID, name, status));
            rc = RtlNtStatusToDosError (status);
        }
    }

    return rc;
}


DWORD
WINAPI
WahWaitForNotification(
    IN HANDLE           HelperHandle,
    IN HANDLE           h,
    IN LPWSAOVERLAPPED  lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++

Routine Description:

    This function waits for asyncronous interprocess notifications
    received on the pipe.

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.
    h            - notification handle
    lpOverlapped - overlapped structure for async IO
    lpCompletionRoutine - completion routine for async IO

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    DWORD           rc;
    NTSTATUS        status;
    IO_STATUS_BLOCK localIoStatus;

    HANDLE          event;
    PIO_APC_ROUTINE apcRoutine;
    PVOID           apcContext;
    PIO_STATUS_BLOCK ioStatus;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    if (HelperHandle==NULL)
        return ERROR_INVALID_PARAMETER;
    else if (HelperHandle!=FAKE_NOTIFICATION_HELPER_HANDLE)
        return ERROR_INVALID_PARAMETER;


    //
    // Disconnect previous client if any.
    // (If none were connected, the call fails, but
    // we ignore the error anyway).
    //
    status = NtFsControlFile(
                        h,
                        NULL,
                        NULL,   // ApcRoutine
                        NULL,   // ApcContext
                        &localIoStatus,
                        FSCTL_PIPE_DISCONNECT,
                        NULL,   // InputBuffer
                        0,      // InputBufferLength,
                        NULL,   // OutputBuffer
                        0       // OutputBufferLength
                        );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject( h, FALSE, NULL );
    }

    if (lpOverlapped) {
        //
        // Initialize for GetOverlappedResult to work
        //
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        if (lpCompletionRoutine) {
            //
            // Async IO with completion routine
            //
            event = NULL;
            apcRoutine = PipeListenApc;
            apcContext = lpCompletionRoutine;
        }
        else {
            //
            // Event based or completion port async IO
            // 1 in low-order bit means they want to bypass completion
            // port
            //
            event = lpOverlapped->hEvent;
            apcRoutine = NULL;
            apcContext = ((ULONG_PTR)lpOverlapped->hEvent & 1) ? NULL : lpOverlapped;
        }
        //
        // Async IO, use overlapped for IoStatus and read buffer
        //
        ioStatus = (PIO_STATUS_BLOCK)lpOverlapped;
    }
    else {
        //
        // Synchronous IO, use locals for IoStatus and read buffer
        //
        ioStatus = &localIoStatus;
        ioStatus->Status = STATUS_PENDING;
        apcRoutine = NULL;
        apcContext = NULL;
        event = NULL;
    }

    //
    // Listen for new client
    //
    status = NtFsControlFile (
                    h,                  // Filehandle
                    event,              // Event
                    apcRoutine,         // ApcRoutine
                    apcContext,         // ApcContext
                    ioStatus,           // IoStatusBlock
                    FSCTL_PIPE_LISTEN,  // IoControlCode
                    NULL,               // InputBuffer
                    0,                  // InputBufferLength
                    NULL,               // OutputBuffer
                    0                   // OutputBufferLength
                    );

    if ((lpOverlapped==NULL) && (status==STATUS_PENDING)) {
        //
        // Wait for completion if IO was synchronous and
        // NtFsControlFile returned pending
        //
        status = NtWaitForSingleObject( h, FALSE, NULL );
        if (NT_SUCCESS (status)) {
            status = ioStatus->Status;
        }
        else {
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx WahWaitForNotification:"
                " Wait failed, status: %lx\n",
                PID, status));
        }
    }

    // Convert status code
    if (status==STATUS_SUCCESS)
        rc = 0;
    else if (status==STATUS_PENDING) {
        rc = WSA_IO_PENDING;
    }
    else {
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx WahWaitForNotification:"
            " Wait failed, status: %lx\n",
            PID, status));
        rc = RtlNtStatusToDosError (status);
    }
    return rc;
}

DWORD
WahNotifyAllProcesses (
    IN HANDLE           HelperHandle
    ) {
/*++

Routine Description:

    This function notifies all the processes that listen for
    notifications

Arguments:

    HelperHandle - The handle of WinSock 2.0 handle helper.

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
    HANDLE          hDir, hPipe;
    struct {
        FILE_NAMES_INFORMATION  Info;
        WCHAR                   FileName[MAX_PATH];
    }               NameInfo;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING  NameFormat;
    PUNICODE_STRING pNameFormat;
    NTSTATUS        status;
    UNICODE_STRING  PipeRootName;
    OBJECT_ATTRIBUTES PipeRootAttr;
    WCHAR           name[MAX_PATH + sizeof(WS2_PIPE_BASE)/sizeof(WCHAR)];
    UNICODE_STRING  uName;
    OBJECT_ATTRIBUTES attr;
    DWORD           rc;

    //
    // Don't let clients that listen for notifications impresonate this
    // user which surely runs at high privilige level (has a write access
    // to the HKLM key).
    //
    SECURITY_QUALITY_OF_SERVICE qos;
    qos.Length = sizeof (qos);
    qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    qos.EffectiveOnly = TRUE;
    qos.ImpersonationLevel = SecurityAnonymous;

    rc = ENTER_WS2HELP_API ();
    if (rc!=0)
        return rc;

    if (HelperHandle==NULL)
        return ERROR_INVALID_PARAMETER;
    else if (HelperHandle!=FAKE_NOTIFICATION_HELPER_HANDLE)
        return ERROR_INVALID_PARAMETER;

    //
    // Open handle to pipe root directory
    //
    RtlInitUnicodeString( &PipeRootName, WS2_PIPE_BASE );
    InitializeObjectAttributes(
        &PipeRootAttr,
        &PipeRootName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenFile (
              &hDir,                                // FileHandle
              FILE_LIST_DIRECTORY | SYNCHRONIZE,    // DesiredAccess
              &PipeRootAttr,                        // ObjectAttributes
              &ioStatusBlock,                       // IoStatusBlock
              FILE_SHARE_READ|FILE_SHARE_WRITE,     // ShareAccess
              FILE_DIRECTORY_FILE                   // OpenOptions
                | FILE_SYNCHRONOUS_IO_NONALERT
                | FILE_OPEN_FOR_BACKUP_INTENT);

    if (NT_SUCCESS(status)) {
        //
        // Enumerate all pipes that match our pattern
        //
        RtlInitUnicodeString( &NameFormat, WS2_PIPE_WILDCARD );
        pNameFormat = &NameFormat;
        while ((status=NtQueryDirectoryFile (
                            hDir,                       // File Handle
                            NULL,                       // Event
                            NULL,                       // Apc routine
                            NULL,                       // Apc context
                            &ioStatusBlock,             // IoStatusBlock
                            &NameInfo,                  // FileInformation
                            sizeof(NameInfo)-
                               sizeof(UNICODE_NULL),    // Length
                            FileNamesInformation,       // FileInformationClass
                            TRUE,                       // ReturnSingleEntry
                            pNameFormat,                // FileName
                            (BOOLEAN)(pNameFormat!=NULL)// RestartScan
                            ))==STATUS_SUCCESS) {

            pNameFormat = NULL; // No need for pattern on second
                                // and all successive enum calls

            //
            // Create client and of the pipe that matched the
            // pattern
            //
            NameInfo.Info.FileName[
                NameInfo.Info.FileNameLength
                    /sizeof(NameInfo.Info.FileName[0])] = 0;

            _snwprintf(name,
                       (sizeof(name)/sizeof(name[0])),
                       WS2_PIPE_BASE L"%ls",
                       NameInfo.Info.FileName);

            RtlInitUnicodeString( &uName, name );
            InitializeObjectAttributes(
                &attr,
                &uName,
                OBJ_CASE_INSENSITIVE,   // Attributes
                NULL,                   // Root directory
                NULL                    // Security descriptor
                );
            //
            // The InitializeObjectAttributes macro presently stores NULL for
            // the SecurityQualityOfService field, so we must manually set that
            // field for now.
            //
            attr.SecurityQualityOfService = &qos;

            status = NtCreateFile (
                            &hPipe,
                            GENERIC_WRITE | SYNCHRONIZE,
                            &attr,
                            &ioStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ,
                            OPEN_EXISTING,
                            0,
                            NULL,
                            0);
            if (NT_SUCCESS (status)) {
                WshPrint (DBG_NOTIFY,
                    ("WS2HELP-%lx WahNotifyAllProcesses:"
                    " Opened pipe %ls.\n",
                    PID, name));
                NtClose (hPipe);
            }
#if DBG
            else if (status==STATUS_PIPE_NOT_AVAILABLE) {
                WshPrint (DBG_NOTIFY,
                    ("WS2HELP-%lx WahNotifyAllProcesses:"
                    " Pipe %ls is not currently listening.\n",
                    PID, name));
            }
            else {
                WshPrint (DBG_NOTIFY|DBG_FAILURES,
                    ("WS2HELP-%lx WahNotifyAllProcesses:"
                    " Could not open pipe %ls, status: %lx\n",
                    PID, name, status));
            }
#endif
        }
        if (status!=STATUS_NO_MORE_FILES) {
            //
            // Some other failure, means we could not even
            // enumerate
            //
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx WahNotifyAllProcesses:"
                " Could enumerate pipes, status: %lx\n",
                PID, status));
        }
        NtClose (hDir);
    }
    else {
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx WahNotifyAllProcesses:"
            " Could open pipe root, status: %lx\n",
            PID, status));
    }

    return 0;
}

// Private functions

VOID
PipeListenApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
/*++

Routine Description:

    This NT IO APC that converts parameters and calls client APC.

Arguments:

    ApcContext  -   apc context - pointer to client APC

    IoStatusBlock - io status block - part of client's overlapped structure

    Reserved    -   reserved


Return Value:

    None


--*/
{
    
    DWORD   rc;

    UNREFERENCED_PARAMETER(Reserved);

    switch (IoStatusBlock->Status) {
    case STATUS_SUCCESS:
        rc = 0;
        break;
    case STATUS_CANCELLED:
        rc = WSA_OPERATION_ABORTED;
        break;
    default:
        rc = WSASYSCALLFAILURE;
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx PipeListenApc:"
            " Failed, status: %lx\n",
            PID, IoStatusBlock->Status));
        break;

    }
    (*(LPWSAOVERLAPPED_COMPLETION_ROUTINE)ApcContext)
            (rc, 0, (LPWSAOVERLAPPED)IoStatusBlock, 0);

}


DWORD
GetWinsockRootSecurityDescriptor (
    PSECURITY_DESCRIPTOR    *pDescr
    )
/*++

Routine Description:

    Reads security descriptor of the registry key that contains
    Winsock2 catalogs

Arguments:

    pDescr  - buffer to receive locally allocated pointer to descriptor
Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    HKEY                hKey;
    DWORD               sz;
    DWORD               rc;

    //
    // Open the key
    //
    rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    WINSOCK_REGISTRY_ROOT,
                    0,
                    KEY_READ|READ_CONTROL,
                    &hKey
                    );
    if (rc==0) {
        //
        // Get the required buffer size
        //
        sz = 0;
        rc = RegGetKeySecurity (hKey,
                         DACL_SECURITY_INFORMATION, // we only need
                                                    // DACL to see
                                                    // who has write
                                                    // permissions to
                                                    // the key
                         NULL,
                         &sz);
        if (rc==ERROR_INSUFFICIENT_BUFFER) {
            PSECURITY_DESCRIPTOR descr;
            //
            // Allocate buffer
            //
            descr = (PSECURITY_DESCRIPTOR)ALLOC_MEM (sz);
            if (descr!=NULL) {
                //
                // Fetch the data
                //
                rc = RegGetKeySecurity (hKey,
                                 DACL_SECURITY_INFORMATION,
                                 descr,
                                 &sz);
                if (rc==0) {
                    *pDescr = descr;
                }
                else {
                    WshPrint (DBG_NOTIFY|DBG_FAILURES,
                        ("WS2HELP-%lx GetWinsockRootExplicitAccess:"
                        " Failed to get key security (data), err: %ld\n",
                        PID, rc));
                    FREE_MEM (descr);
                }
            }
            else {
                rc = GetLastError ();
                WshPrint (DBG_NOTIFY|DBG_FAILURES,
                    ("WS2HELP-%lx GetWinsockRootExplicitAccess:"
                    " Failed to allocate security descriptor, err: %ld\n",
                    PID, rc));
                if (rc==0)
                    rc = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else {
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx GetWinsockRootExplicitAccess:"
                " Failed to get key security (size), err: %ld\n",
                PID, rc));
        }
        //
        // Do not need key anymore
        //
        RegCloseKey (hKey);
    }
    else {
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx GetWinsockRootExplicitAccess:"
            " Failed to open winsock root key, err: %ld\n",
            PID, rc));
    }
    return rc;
}


DWORD
BuildPipeSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR    pBaseDescr,
    OUT PSECURITY_DESCRIPTOR    *pDescr
    )
/*++

Routine Description:

    Builds security descriptor with the same write permissions
    as in base descriptor (which is the descriptor of the
    registry key) minus network users

Arguments:

    pBaseDescr  - descriptor of the registry key from which to
                    read write permisions

    pDescr      - buffer to receive locally allocated pointer to descriptor

Return Value:

    DWORD - NO_ERROR if successful, a Win32 error code if not.

--*/
{
    PACL                    pBaseDacl, pDacl;
    BOOL                    DaclPresent, DaclDefaulted;
    DWORD                   cbDacl;
    DWORD                   rc = 0;
    ACL_SIZE_INFORMATION    sizeInfo;
    ULONG                   i;
    ACE_HEADER              *pAce;
    SID_IDENTIFIER_AUTHORITY    siaNt = SECURITY_NT_AUTHORITY;
    PSID                    pSidNetUser;
    SID_IDENTIFIER_AUTHORITY    siaCreator = SECURITY_CREATOR_SID_AUTHORITY;
    PSID                    pSidCrOwner;
    PSID                    pSidCrGroup;

    *pDescr = NULL;

#if defined(_WS2HELP_W4_)
    RtlZeroMemory(&sizeInfo, sizeof(sizeInfo));
#endif // defined(_WS2HELP_W4_)

    //
    // Get DACL from the base descriptor
    //
    if (!GetSecurityDescriptorDacl (
                        pBaseDescr,
                        &DaclPresent,
                        &pBaseDacl,
                        &DaclDefaulted
                        )) {
        rc = GetLastError ();
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
            " Failed to get DACL from base descriptor, err: %ld\n",
            PID, rc));
        if (rc==0)
            rc = ERROR_GEN_FAILURE;

        return rc;
    }

    //
    // Allocate SID for network users
    //

    if (!AllocateAndInitializeSid (&siaNt,
            1,
            SECURITY_NETWORK_RID,
            0,0,0,0,0,0,0,
            &pSidNetUser
            )) {
        rc = GetLastError ();
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
            " Failed to allocate net user SID, err: %ld\n",
            PID, rc));
        if (rc==0)
            rc = ERROR_GEN_FAILURE;

        return rc;
    }

    //
    // Allocate SID for creator/owner
    //

    if (!AllocateAndInitializeSid (&siaCreator,
            1,
            SECURITY_CREATOR_OWNER_RID,
            0,0,0,0,0,0,0,
            &pSidCrOwner
            )) {
        rc = GetLastError ();
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
            " Failed to allocate creator owner SID, err: %ld\n",
            PID, rc));
        if (rc==0)
            rc = ERROR_GEN_FAILURE;
        FreeSid (pSidNetUser);

        return rc;
    }

    //
    // Allocate SID for creator group
    //

    if (!AllocateAndInitializeSid (&siaCreator,
            1,
            SECURITY_CREATOR_GROUP_RID,
            0,0,0,0,0,0,0,
            &pSidCrGroup
            )) {
        rc = GetLastError ();
        WshPrint (DBG_NOTIFY|DBG_FAILURES,
            ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
            " Failed to allocate creator group SID, err: %ld\n",
            PID, rc));
        if (rc==0)
            rc = ERROR_GEN_FAILURE;
        FreeSid (pSidCrOwner);
        FreeSid (pSidNetUser);

        return rc;
    }

    //
    // Our DACL will at least contain an ACE that denies
    // access to all network users
    //
    cbDacl = sizeof (ACL)
                + FIELD_OFFSET (ACCESS_DENIED_ACE, SidStart)
                + GetLengthSid (pSidNetUser);


    //
    // If base DACL is present and non-NULL, we will need to
    // parse it, count all the accounts that have write permissions,
    // so we can allocate space in security descriptor to
    // hold them
    //
    if (DaclPresent && pBaseDacl!=NULL) {
        //
        // Get number of ACEs in the DACL
        //
        if (GetAclInformation (pBaseDacl,
                                &sizeInfo,
                                sizeof (sizeInfo),
                                AclSizeInformation
                                )) {
            //
            // Enumerate all ACEs to get the required size
            // of the DACL that we are about to build
            //
            for (i=0; i<sizeInfo.AceCount; i++) {
                if (GetAce (pBaseDacl, i, &pAce)) {
                    //
                    // Only count access-allowed or access-denied ACEs
                    // with write access to the key
                    //
                    switch (pAce->AceType) {
                    case ACCESS_ALLOWED_ACE_TYPE:
                        #define paAce ((ACCESS_ALLOWED_ACE  *)pAce)
                        if (((paAce->Mask & KEY_WRITE)==KEY_WRITE)
                                && !EqualSid (&paAce->SidStart, pSidCrOwner)
                                && !EqualSid (&paAce->SidStart, pSidCrGroup)
                                    ) {
                            cbDacl += FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart)
                                        +  GetLengthSid (&paAce->SidStart);
                        }
                        #undef paAce
                        break;
                    case ACCESS_DENIED_ACE_TYPE:
                        #define pdAce ((ACCESS_DENIED_ACE  *)pAce)
                        if ((pdAce->Mask & KEY_WRITE)==KEY_WRITE) {
                            cbDacl += FIELD_OFFSET (ACCESS_DENIED_ACE, SidStart)
                                        +  GetLengthSid (&pdAce->SidStart);
                        }
                        #undef pdAce
                        break;
                    }

                }
                else {
                    rc = GetLastError ();
                    WshPrint (DBG_NOTIFY|DBG_FAILURES,
                        ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                        " Failed to get ACE # %ld, err: %ld\n",
                        PID, i, rc));
                    if (rc==0)
                        rc = ERROR_GEN_FAILURE;
                    break;
                }
            } // for
        }
        else {
            rc = GetLastError ();
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                " Failed to get DACL size info, err: %ld\n",
                PID, rc));
            if (rc==0)
                rc = ERROR_GEN_FAILURE;
        }
    } // if DaclPresent and pDacl!=NULL
    else {
        //
        // Base DACL does not exist or empty
        //
        rc = 0;
    }


    if (rc==0) {
        //
        // Allocate memory for the descriptor and DACL
        //
        *pDescr = (PSECURITY_DESCRIPTOR)ALLOC_MEM
                        (sizeof (SECURITY_DESCRIPTOR)+cbDacl);
        if (*pDescr!=NULL) {
            pDacl = (PACL)((PUCHAR)(*pDescr)+sizeof(SECURITY_DESCRIPTOR));

            //
            // Initialize descriptor and DACL
            //

            if (InitializeSecurityDescriptor (*pDescr,
                            SECURITY_DESCRIPTOR_REVISION)
                   && InitializeAcl (pDacl, cbDacl, ACL_REVISION)) {

                //
                // First add access-denied ace for all
                // network users
                //

                if (AddAccessDeniedAce (pDacl,
                                        ACL_REVISION,
                                        GENERIC_WRITE
                                            |STANDARD_RIGHTS_WRITE
                                            |SYNCHRONIZE,
                                        pSidNetUser
                                        )) {
#if DBG
                    DumpSid (pSidNetUser, "Denying");
#endif

                    //
                    // If base DACL is present and non-NULL, we will need to
                    // parse it add all ACEs that have write permisions
                    // to the DACL we build
                    //
                    if (DaclPresent && (pBaseDacl!=NULL)) {

                        //
                        // Enumerate all ACEs and copy them
                        // to the new DACL
                        //
                        for (i=0; i<sizeInfo.AceCount; i++) {
                            if (GetAce (pBaseDacl, i, &pAce)) {
                                //
                                // Only count access-allowed or access-denied ACEs
                                // with write access to the key
                                //
                                switch (pAce->AceType) {
                                case ACCESS_ALLOWED_ACE_TYPE:
                                    #define paAce ((ACCESS_ALLOWED_ACE  *)pAce)
                                    if (((paAce->Mask & KEY_WRITE)==KEY_WRITE)
                                            && !EqualSid (&paAce->SidStart, pSidCrOwner)
                                            && !EqualSid (&paAce->SidStart, pSidCrGroup)
                                        ) {
                                        if (AddAccessAllowedAce (pDacl,
                                                ACL_REVISION,
                                                GENERIC_WRITE
                                                    | STANDARD_RIGHTS_WRITE
                                                    | SYNCHRONIZE
                                                    | FILE_READ_ATTRIBUTES,
                                                &paAce->SidStart
                                                )) {
#if DBG
                                            DumpSid (&paAce->SidStart, "Allowing");
#endif
                                        }
                                        else {
                                            rc = GetLastError ();
                                            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                                                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                                                " Failed to add access allowed ACE # %ld, err: %ld\n",
                                                PID, i, rc));
                                            if (rc==0)
                                                rc = ERROR_GEN_FAILURE;
                                        }
                                    }
                                    #undef paAce
                                    break;
                                case ACCESS_DENIED_ACE_TYPE:
                                    #define pdAce ((ACCESS_DENIED_ACE  *)pAce)
                                    if ((pdAce->Mask & KEY_WRITE)==KEY_WRITE) {
                                        if (AddAccessDeniedAce (pDacl,
                                                ACL_REVISION,
                                                GENERIC_WRITE
                                                    | STANDARD_RIGHTS_WRITE
                                                    | SYNCHRONIZE,
                                                &pdAce->SidStart
                                                )) {
#if DBG
                                            DumpSid (&pdAce->SidStart, "Denying");
#endif
                                        }
                                        else {
                                            rc = GetLastError ();
                                            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                                                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                                                " Failed to add access denied ACE # %ld, err: %ld\n",
                                                PID, i, rc));
                                            if (rc==0)
                                                rc = ERROR_GEN_FAILURE;
                                        }
                                    }
                                    #undef pdAce
                                    break;
                                }
                                if (rc!=0) {
                                    // Stop enumeration in case
                                    // of failure
                                    break;
                                }
                            }
                            else {
                                rc = GetLastError ();
                                WshPrint (DBG_NOTIFY|DBG_FAILURES,
                                    ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                                    " Failed to re-get ACE # %ld, err: %ld\n",
                                    PID, i, rc));
                                if (rc==0)
                                    rc = ERROR_GEN_FAILURE;
                                break;
                            }
                        } // for
                    } // if (DaclPresent and pBaseDacl!=NULL)
                }
                else {
                    rc = GetLastError ();
                    WshPrint (DBG_NOTIFY|DBG_FAILURES,
                        ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                        " Failed to add accees denied ace for net users %ld, err: %ld\n",
                        PID, rc));
                    if (rc==0)
                        rc = ERROR_GEN_FAILURE;
                }
            }
            else {
                rc = GetLastError ();
                WshPrint (DBG_NOTIFY|DBG_FAILURES,
                    ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                    " Failed to initialize DACL, err: %ld\n",
                    PID, rc));
                if (rc==0)
                    rc = ERROR_GEN_FAILURE;
            }

            //
            // If we succeded in building of the
            // DACL, add it to the security descriptor
            //
            if (rc==0) {
                if (SetSecurityDescriptorDacl (
                                *pDescr,
                                TRUE,
                                pDacl,
                                FALSE
                                )) {
                    rc = 0;
                }
                else {
                    rc = GetLastError ();
                    WshPrint (DBG_NOTIFY|DBG_FAILURES,
                        ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                        " Failed to set DACL, err: %ld\n",
                        PID, rc));
                    if (rc==0)
                        rc = ERROR_GEN_FAILURE;
                }
            } // if rc==0 (DACL is built)
            else {
                // Failed to build DACL, free memory for security descriptor
                FREE_MEM (*pDescr);
                *pDescr = NULL;
            }
        }
        else {
            rc = GetLastError ();
            WshPrint (DBG_NOTIFY|DBG_FAILURES,
                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                " Failed to allocate security descriptor, err: %ld\n",
                PID, rc));
                if (rc==0)
                    rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    } // if rc==0 (Parsed base DACL ok)

    //
    // Free net user sid which we already copied to DACL in security
    // descriptor
    //
    FreeSid (pSidNetUser);
    FreeSid (pSidCrOwner);
    FreeSid (pSidCrGroup);

    return rc;
}

#if DBG
VOID
DumpSid (
    PSID    pSid,
    LPSTR   AccessType
    ) {
    TCHAR   Name[256];
    DWORD   szName = sizeof (Name);
    TCHAR   Domain[256];
    DWORD   szDomain = sizeof (Domain);
    SID_NAME_USE    nameUse;
    static HANDLE SAM_SERVICE_STARTED_EVENT = NULL;

    if (DbgLevel & DBG_NOTIFY) {
        if (SAM_SERVICE_STARTED_EVENT==NULL) {
            SAM_SERVICE_STARTED_EVENT = CreateEvent (NULL,
                                        FALSE,
                                        FALSE,
                                        TEXT("SAM_SERVICE_STARTED"));
            if (SAM_SERVICE_STARTED_EVENT!=NULL) {
                DWORD   rc;
                rc = WaitForSingleObject (SAM_SERVICE_STARTED_EVENT, 0);
                CloseHandle (SAM_SERVICE_STARTED_EVENT);
                if (rc!=WAIT_OBJECT_0) {
                    // Reset global so we try this again
                    SAM_SERVICE_STARTED_EVENT = NULL;
                    return;
                }
                // proceed without resetting global so we do not try again
                
            }
            else
                // Event must not have been created
                return;
        }

        if (LookupAccountSid (NULL,
                            pSid,
                            Name,
                            &szName,
                            Domain,
                            &szDomain,
                            &nameUse
                            )) {
            WshPrint (DBG_NOTIFY,
                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                " %s write permissions to %s\\%s (use:%d).\n",
                PID, AccessType, Domain, Name, nameUse));

        }
        else {
            DWORD   i, n;
            WshPrint (DBG_NOTIFY,
                ("WS2HELP-%lx BuildPipeSecurityDescriptor:"
                " Could not lookup name for sid, err: %ld.\n",
                PID, GetLastError()));
            WshPrint (DBG_NOTIFY,
                ("WS2HELP-%lx, SID dump: S-%d-%d",
                PID, SID_REVISION, GetSidIdentifierAuthority(pSid)->Value[6]));
            n = *GetSidSubAuthorityCount(pSid);
            for (i=0; i<n; i++)
                WshPrint (DBG_NOTIFY, ("-%d", *GetSidSubAuthority (pSid, i)));
            WshPrint (DBG_NOTIFY, ("\n"));
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\debug.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module implements debug support for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

#include "precomp.h"
#if DBG
ULONG DbgLevel=DBG_FAILURES;

VOID
ReadDbgInfo (
    IN PUNICODE_STRING RegistryPath
    ) {
    PWSTR RegistryPathBuffer;
    PWSTR Parameters = L"Parameters";
    RTL_QUERY_REGISTRY_TABLE    paramTable[3]; // table size = nr of params + 2

    RegistryPathBuffer = (PWSTR)ExAllocatePool(NonPagedPool,
                                RegistryPath->Length + sizeof(WCHAR));

    if (RegistryPathBuffer == NULL) {
        return;
    }

    RtlCopyMemory (RegistryPathBuffer, RegistryPath->Buffer, RegistryPath->Length);
    *(PWCHAR)(((PUCHAR)RegistryPathBuffer)+RegistryPath->Length) = (WCHAR)'\0';

    RtlZeroMemory(&paramTable[0], sizeof(paramTable));

    paramTable[0].QueryRoutine = NULL;
    paramTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    paramTable[0].Name = Parameters;

    paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name = L"DbgLevel";
    paramTable[1].EntryContext = &DbgLevel;
    paramTable[1].DefaultType = REG_DWORD;
    paramTable[1].DefaultData = &DbgLevel;
    paramTable[1].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(
          RTL_REGISTRY_ABSOLUTE,
          RegistryPathBuffer,
          paramTable,
          NULL,
          NULL);

    ExFreePool(RegistryPathBuffer);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\dispatch.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dispatch.h

Abstract:

    This header contains the dispatch routine declarations
    for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

NTSTATUS
DispatchCreate (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);

NTSTATUS
DispatchCleanup (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);

NTSTATUS
DispatchClose (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);

NTSTATUS
DispatchReadWrite (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);

NTSTATUS
DispatchDeviceControl (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);

BOOLEAN
FastIoDeviceControl (
	IN PFILE_OBJECT 		FileObject,
	IN BOOLEAN 			    Wait,
	IN PVOID 				InputBuffer	OPTIONAL,
	IN ULONG 				InputBufferLength,
	OUT PVOID 				OutputBuffer	OPTIONAL,
	IN ULONG 				OutputBufferLength,
	IN ULONG 				IoControlCode,
	OUT PIO_STATUS_BLOCK	IoStatus,
	IN PDEVICE_OBJECT 		DeviceObject
    );


NTSTATUS
DispatchPnP (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\driver.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    driver.h

Abstract:

    This module contains global variable and external routine
    declarations for driver object of ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

extern PDEVICE_OBJECT  DeviceObject;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\debug.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module contains debug support definitions for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

#if DBG

// Components
#define DBG_DISPATCH            0x00000001
#define DBG_SOCKET              0x00000002
#define DBG_PROCESS             0x00000004
#define DBG_QUEUE               0x00000008
#define DBG_LOAD                0x00000010

// Operations
#define DBG_READWRITE           0x00000100
#define DBG_AFDIOCTL            0x00000200
#define DBG_DRV_COMPLETE        0x00000400
#define DBG_PVD_COMPLETE        0x00000800
#define DBG_RETRIEVE            0x00001000
#define DBG_CANCEL              0x00002000

// Failures
#define DBG_FAILURES            0x80000000

extern ULONG DbgLevel;

#define WsPrint(FLAGS,ARGS)	    \
	do {						\
		if (DbgLevel&FLAGS){    \
			DbgPrint ARGS;		\
		}						\
	} while (0)

#define WsProcessPrint(Process,FLAGS,ARGS)	\
	do {						            \
		if (((Process)->DbgLevel)&FLAGS){   \
			DbgPrint ARGS;		            \
		}						            \
	} while (0)

VOID
ReadDbgInfo (
    IN PUNICODE_STRING RegistryPath
    );
#else
#define WsPrint(FLAGS,ARGS) do {NOTHING;} while (0)
#define WsProcessPrint(Process,FLAGS,ARGS) do {NOTHING;} while (0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\misc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module implemets helper routines not readily available
    in kernel or TDI libraries for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Oct-1997 (Inspired by AFD)

Revision History:

--*/

#include "precomp.h"


#pragma alloc_text(PAGE, AllocateMdlChain)
#pragma alloc_text(PAGE, CopyBufferToMdlChain)
#pragma alloc_text(PAGE, CopyMdlChainToBuffer)


VOID
AllocateMdlChain(
    IN PIRP Irp,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount,
    OUT PULONG TotalByteCount
    )

/*++

Routine Description:

    Allocates a MDL chain describing the WSABUF array and attaches
    the chain to the specified IRP.

Arguments:

    Irp - The IRP that will receive the MDL chain.

    BufferArray - Points to an array of WSABUF structures describing
        the user's buffers.

    BufferCount - Contains the number of WSABUF structures in the
        array.

    TotalByteCount - Will receive the total number of BYTEs described
        by the WSABUF array.

Return Value:

    None

Note:
    Raises appropriate exception if probing/allocation fails
--*/

{
    PMDL currentMdl;
    PMDL * chainTarget;
    KPROCESSOR_MODE previousMode;
    ULONG totalLength;
    PVOID bufferPointer;
    ULONG bufferLength;

    PAGED_CODE ();
    //
    //  Sanity check.
    //

    ASSERT( Irp != NULL );
    ASSERT( Irp->MdlAddress == NULL );
    ASSERT( BufferArray != NULL );
    ASSERT( BufferCount > 0 );
    ASSERT( TotalByteCount != NULL );

    //
    //  Get the previous processor mode.
    //

    previousMode = Irp->RequestorMode;

    if ((BufferArray == NULL) 
            || (BufferCount == 0)
                // Check for integer overflow (disabled by compiler)
            || (BufferCount>(MAXULONG/sizeof (WSABUF)))) {
        ExRaiseStatus (STATUS_INVALID_PARAMETER);
    }

   if( previousMode != KernelMode ) {

        //
        //  Probe the WSABUF array.
        //

        ProbeForRead(
            BufferArray,                            // Address
            BufferCount * sizeof(WSABUF),           // Length
            sizeof(ULONG)                           // Alignment
            );

    }

    //
    //  Get into a known state.
    //

    currentMdl = NULL;
    chainTarget = &Irp->MdlAddress;
    totalLength = 0;


    //
    //  Scan the array.
    //

    do {

        bufferPointer = BufferArray->buf;
        bufferLength = BufferArray->len;

        if( bufferPointer != NULL &&
            bufferLength > 0 ) {

            //
            //  Update the total byte counter.
            //

            totalLength += bufferLength;

            //
            //  Create a new MDL.
            //

            currentMdl = IoAllocateMdl(
                            bufferPointer,      // VirtualAddress
                            bufferLength,       // Length
                            FALSE,              // SecondaryBuffer
                            TRUE,               // ChargeQuota
                            NULL                // Irp
                            );

            if( currentMdl != NULL ) {

                //
                //  Chain the MDL onto the IRP.  In theory, we could
                //  do this by passing the IRP into IoAllocateMdl(),
                //  but IoAllocateMdl() does a linear scan on the MDL
                //  chain to find the last one in the chain.
                //
                //  We can do much better.
                //

                *chainTarget = currentMdl;
                chainTarget = &currentMdl->Next;

                //
                //  Advance to the next WSABUF structure.
                //

                BufferArray++;

            } else {

                //
                //  Cannot allocate new MDL, raise exception.
                //

                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }

        }

    } while( --BufferCount );

    //
    //  Ensure the MDL chain is NULL terminated.
    //

    ASSERT( *chainTarget == NULL );


    //
    //  Return the total buffer count.
    //

    *TotalByteCount = totalLength;

} // AllocateMdlChain

ULONG
CopyMdlChainToBuffer(
    IN PMDL  SourceMdlChain,
    IN PVOID Destination,
    IN ULONG DestinationLength
    )

/*++

Routine Description:

    Copies data from a MDL chain to a linear buffer.
    Assumes that MDL in the right process context
    (virtual address is valid but it may not be mapped into system space)

Arguments:

    SourceMdlChain  - chain of MDL to copy buffer from.

    Destination - Points to the linear destination of the data.

    DestinationLength - The length of Destination.


Return Value:

    ULONG - The number of bytes copied.

--*/

{
    ULONG   SrcBytesLeft = 0;
    PUCHAR  Dst = Destination, Src;

    PAGED_CODE ();

    //ASSERT (SourceMdlChain->Process==PsGetCurrentProcess ());

    while (DestinationLength != 0) {
        do {
            if (SourceMdlChain == NULL) {
                goto Done;
            }
            Src = MmGetMdlVirtualAddress (SourceMdlChain);
            SrcBytesLeft = MmGetMdlByteCount (SourceMdlChain);
            SourceMdlChain = SourceMdlChain->Next;
        }
        while (SrcBytesLeft == 0);

        if (SrcBytesLeft >= DestinationLength) {
            RtlCopyMemory (Dst, Src, DestinationLength);
            Dst += DestinationLength;
            break;
        } else {
            RtlCopyMemory (Dst, Src, SrcBytesLeft);
            DestinationLength -= SrcBytesLeft;
            Dst += SrcBytesLeft;
        }
    }

Done:
    return (ULONG)(Dst - (PUCHAR)Destination);

} // CopyMdlChainToBuffer



ULONG
CopyBufferToMdlChain(
    IN PVOID Source,
    IN ULONG SourceLength,
    IN PMDL  DestinationMdlChain
    )

/*++

Routine Description:

    Copies data from a linear buffer to a MDL chain.
    Assumes that MDL in the right process context
    (virtual address is valid but it may not be mapped into system space)

Arguments:

    Source - Points to the linear source of the data.

    SourceLength - The length of Source.

    DestinationMdlChain  - chain of MDL to copy buffer to.

Return Value:

    ULONG - The number of bytes copied.

--*/

{
    ULONG   DstBytesLeft = 0;
    PUCHAR  Dst, Src = Source;

//    ASSERT (DestinationMdlChain->Process==PsGetCurrentProcess ());

    while (SourceLength != 0) {
        do {
            if (DestinationMdlChain == NULL) {
                goto Done;
            }
            Dst = MmGetMdlVirtualAddress (DestinationMdlChain);
            DstBytesLeft = MmGetMdlByteCount (DestinationMdlChain);
            DestinationMdlChain = DestinationMdlChain->Next;
        }
        while (DstBytesLeft == 0);

        if (DstBytesLeft >= SourceLength) {
            RtlCopyMemory (Dst, Src, SourceLength);
            Src += SourceLength;            
            break;
        } else {
            RtlCopyMemory (Dst, Src, DstBytesLeft);
            SourceLength -= DstBytesLeft;
            Src += DstBytesLeft;
        }
    }

Done:
    return (ULONG)(Src - (PUCHAR)Source);

} // CopyBufferToMdlChain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\dispatch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the dispatch routines for
    ws2ifsl.sys driver

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:
    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, DispatchCreate)
#pragma alloc_text (PAGE, DispatchCleanup)
#pragma alloc_text (PAGE, DispatchClose)
#pragma alloc_text (PAGE, DispatchReadWrite)
#pragma alloc_text (PAGE, DispatchDeviceControl)
#pragma alloc_text (PAGE, FastIoDeviceControl)
#endif

NTSTATUS
DispatchCreate (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called as the result of a request to create
    a file associated with WS2IFSL driver device object.

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - create Irp

Return Value:

    STATUS_SUCCESS - requested file object can be created
    STATUS_INVALID_PARAMETER - required extened attribute is missing
                        or invalid
    STATUS_INSUFFICIENT_RESOURCES - not enough resources to complete
                        this request

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    PFILE_FULL_EA_INFORMATION   eaBuffer;

    PAGED_CODE ();

    // Get extended attribute buffer which identifies the
    // type of file that should be created.

    eaBuffer = Irp->AssociatedIrp.SystemBuffer;
    if (eaBuffer!=NULL) {
        irpSp = IoGetCurrentIrpStackLocation (Irp);
        if ((eaBuffer->EaNameLength==WS2IFSL_SOCKET_EA_NAME_LENGTH)
                && (strcmp (eaBuffer->EaName, WS2IFSL_SOCKET_EA_NAME)==0)) {
            // This is the request to create socket file

            status = CreateSocketFile (irpSp->FileObject,
                                        Irp->RequestorMode,
                                        eaBuffer);
        }
        else if ((eaBuffer->EaNameLength==WS2IFSL_PROCESS_EA_NAME_LENGTH)
                && (strcmp (eaBuffer->EaName, WS2IFSL_PROCESS_EA_NAME)==0)) {
            // This is the request to create process file

            status = CreateProcessFile (irpSp->FileObject,
                                        Irp->RequestorMode,
                                        eaBuffer);
        }
        else
            status = STATUS_INVALID_PARAMETER;
    }
    else
        status = STATUS_INVALID_PARAMETER;
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
} // DispatchCreate

NTSTATUS
DispatchCleanup (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called when all handles to a file associated with WS2IFSL
    driver device object are closed, so the driver should cleanup all the
    outstanding IRPs.

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - cleanup Irp

Return Value:

    STATUS_SUCCESS - cleanup operation completed
    STATUS_PENDING - cleanup operation started and IoCompleteRequest will be
                    called when it is done

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    ULONG                       eaNameTag;

    PAGED_CODE ();

    // Get the file type from file object context
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    eaNameTag = *((PULONG)irpSp->FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        status = CleanupSocketFile (irpSp->FileObject, Irp);
        break;
    case PROCESS_FILE_EANAME_TAG:
        status = CleanupProcessFile (irpSp->FileObject, Irp);
        break;
    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);
        status = STATUS_INVALID_HANDLE;
        break;
    }

    // Complete the request if it was not marked pending
    if (status!=STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return status;
} // DispatchCleanup

NTSTATUS
DispatchClose (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called when all references to a file associated with WS2IFSL
    driver device object are released and IO system is about to delete the
    file object itself

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - close Irp

Return Value:

    STATUS_SUCCESS - close operation completed

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    ULONG                       eaNameTag;

    PAGED_CODE ();

    // Get the file type from file object context
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    eaNameTag = *((PULONG)irpSp->FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        CloseSocketFile (irpSp->FileObject);
        status = STATUS_SUCCESS;
        break;
    case PROCESS_FILE_EANAME_TAG:
        CloseProcessFile (irpSp->FileObject);
        status = STATUS_SUCCESS;
        break;
    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);
        status = STATUS_INVALID_HANDLE;
        break;
    }

    // Complete the request
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
} // DispatchClose

NTSTATUS
DispatchReadWrite (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called to perform read or write operation on file object.
    It is only supported for socket files.

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - read/write  Irp

Return Value:

    STATUS_PENDING - operation is passed onto WS2IFSL DLL to execute
    STATUS_CANCELED - operation canceled because WS2IFSL DLL has been unloaded
    STATUS_INVALID_DEVICE_REQUEST - the operation cannot be performed on
                        this file object.
    STATUS_INVALID_HANDLE - file object is not valid in the context of
                        current process


--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    ULONG                       eaNameTag;

    PAGED_CODE ();

    // Get the file type from file object context
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    eaNameTag = *((PULONG)irpSp->FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        status = DoSocketReadWrite (irpSp->FileObject, Irp);
        break;
    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);
    case PROCESS_FILE_EANAME_TAG:
        // This operation is not valid for process files
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    // Complete the request if it was not marked pending
    if (status!=STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return status;
} // DispatchReadWrite


NTSTATUS
DispatchDeviceControl (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called to perform device control operation on file object.

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - device control Irp

Return Value:

    STATUS_SUCCESS - device control operation completed
    STATUS_PENDING - operation is in progress
    STATUS_INVALID_DEVICE_REQUEST - the operation cannot be performed on
                        this file object.
    STATUS_INVALID_HANDLE - file object is not valid in the context of
                        current process

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    ULONG                       eaNameTag;
    ULONG                       function;

    PAGED_CODE ();

    // Get the file type from file object context
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    eaNameTag = *((PULONG)irpSp->FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        function = WS2IFSL_IOCTL_FUNCTION(SOCKET,irpSp->Parameters.DeviceIoControl.IoControlCode);
        if ((function<sizeof(SocketIoControlMap)/sizeof(SocketIoControlMap[0])) &&
                (SocketIoctlCodeMap[function]==irpSp->Parameters.DeviceIoControl.IoControlCode)) {
            // Use table dispatch to call appropriate internal IOCTL routine
            ASSERTMSG ("Socket file device control requests should have been handled"
                    " by FastIo path ", FALSE);
            SocketIoControlMap[function] (
                    irpSp->FileObject,
                    Irp->RequestorMode,
                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    irpSp->Parameters.DeviceIoControl.InputBufferLength,
                    Irp->UserBuffer,
                    irpSp->Parameters.DeviceIoControl.OutputBufferLength,
                    &Irp->IoStatus);
            status = Irp->IoStatus.Status;
        }
        else if ((irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_SEND_DATAGRAM)
                    || (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE_DATAGRAM)
                    || (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE))
            // Handle some "popular" afd IOCTLs
            status = DoSocketAfdIoctl (irpSp->FileObject, Irp);
        else {
            WsPrint (DBG_FAILURES,
                ("WS2IFSL-%04lx DispatchDeviceControl: Unsupported IOCTL - %lx!!!\n",
                    PsGetCurrentProcessId(),
                    irpSp->Parameters.DeviceIoControl.IoControlCode
                    ));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;
    case PROCESS_FILE_EANAME_TAG:
        function = WS2IFSL_IOCTL_FUNCTION(PROCESS,irpSp->Parameters.DeviceIoControl.IoControlCode);
        if ((function<sizeof(ProcessIoControlMap)/sizeof(ProcessIoControlMap[0])) &&
                (ProcessIoctlCodeMap[function]==irpSp->Parameters.DeviceIoControl.IoControlCode)) {
            // Use table dispatch to call appropriate internal IOCTL routine
            ASSERTMSG ("Process file device control requests should have been handled"
                    " by FastIo path ", FALSE);
            ProcessIoControlMap[function] (
                    irpSp->FileObject,
                    Irp->RequestorMode,
                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    irpSp->Parameters.DeviceIoControl.InputBufferLength,
                    Irp->UserBuffer,
                    irpSp->Parameters.DeviceIoControl.OutputBufferLength,
                    &Irp->IoStatus);
            status = Irp->IoStatus.Status;
        }
        else {
            WsPrint (DBG_FAILURES,
                ("WS2IFSL-%04lx DispatchDeviceControl: Unsupported IOCTL - %lx!!!\n",
                    PsGetCurrentProcessId(),
                    irpSp->Parameters.DeviceIoControl.IoControlCode
                    ));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;
    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    // Complete the request if it was not marked pending
    if (status!=STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return status;
} // DispatchDeviceControl


BOOLEAN
FastIoDeviceControl (
	IN PFILE_OBJECT 		FileObject,
	IN BOOLEAN 			    Wait,
	IN PVOID 				InputBuffer	OPTIONAL,
	IN ULONG 				InputBufferLength,
	OUT PVOID 				OutputBuffer	OPTIONAL,
	IN ULONG 				OutputBufferLength,
	IN ULONG 				IoControlCode,
	OUT PIO_STATUS_BLOCK	IoStatus,
	IN PDEVICE_OBJECT 		DeviceObject
    )
/*++

Routine Description:

    This routine is called to perform device control operation on file object.
    This is IO system fast path that assumes immediate action

Arguments:

    FileObject      - file object to which request is directed;
    Wait            - ??? (always TRUE);
    InputBuffer     - address of the input buffer;
    InputBufferLength - size of the input buffer;
    OutputBuffer    - address of the output buffer;
    OutputBufferLength - size of the output buffer;
    IoControlCode   - code of the operation to be performed;
    IoStatus        - status of the operation returned by the driver:
    DeviceObject    - WS2IFSL device object

Return Value:

    TRUE    - operation completed,
    FALSE   - operation should be preformed using Irps
--*/
{
    BOOLEAN         done = FALSE;
    ULONG           eaNameTag;
    ULONG           function;

    PAGED_CODE ();

    // Get the file type from file object context
    eaNameTag = *((PULONG)FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        function = WS2IFSL_IOCTL_FUNCTION(SOCKET,IoControlCode);
        if ((function<sizeof(SocketIoControlMap)/sizeof(SocketIoControlMap[0])) &&
                (SocketIoctlCodeMap[function]==IoControlCode)) {
            IO_STATUS_BLOCK IoStatusTemp;

            // Use table dispatch to call appropriate internal IOCTL routine
            SocketIoControlMap[function] (
                    FileObject,
                    ExGetPreviousMode(),
                    InputBuffer,
                    InputBufferLength,
                    OutputBuffer,
                    OutputBufferLength,
                    &IoStatusTemp);

            if (NT_SUCCESS(IoStatusTemp.Status))
            {
                done = TRUE;
                memcpy(IoStatus, &IoStatusTemp, sizeof(IoStatusTemp));
            }
        }
        else if ((IoControlCode==IOCTL_AFD_SEND_DATAGRAM)
                    || (IoControlCode==IOCTL_AFD_RECEIVE_DATAGRAM)
                    || (IoControlCode==IOCTL_AFD_RECEIVE))
            // AFD ioctls can only be handled on "slow" io path (need IRP)
            NOTHING;
        else {
            WsPrint (DBG_FAILURES,
                ("WS2IFSL-%04lx FastIoDeviceControl: Unsupported IOCTL - %lx!!!\n",
                    PsGetCurrentProcessId(), IoControlCode));
            //
            // Let the real dispatch deal with the error.
            NOTHING;
        }
        break;
    case PROCESS_FILE_EANAME_TAG:
        function = WS2IFSL_IOCTL_FUNCTION(PROCESS,IoControlCode);
        if ((function<sizeof(ProcessIoControlMap)/sizeof(ProcessIoControlMap[0])) &&
                (ProcessIoctlCodeMap[function]==IoControlCode)) {
            // Use table dispatch to call appropriate internal IOCTL routine
            IO_STATUS_BLOCK IoStatusTemp;

            ProcessIoControlMap[function] (
                    FileObject,
                    ExGetPreviousMode(),
                    InputBuffer,
                    InputBufferLength,
                    OutputBuffer,
                    OutputBufferLength,
                    &IoStatusTemp);

            if (NT_SUCCESS(IoStatusTemp.Status))
            {
                done = TRUE;
                memcpy(IoStatus, &IoStatusTemp, sizeof(IoStatusTemp));
            }
        }
        else {
            WsPrint (DBG_FAILURES,
                ("WS2IFSL-%04lx FastIoDeviceControl: Unsupported IOCTL - %lx!!!\n",
                    PsGetCurrentProcessId(),IoControlCode));
            //
            // Let the real dispatch deal with the error.
            NOTHING;
        }
        break;
    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);
        //
        // Let the real dispatch deal with the error.
        NOTHING;
        break;
    }

    return done;
} // FastIoDeviceControl

NTSTATUS
DispatchPnP (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
	)
/*++

Routine Description:

    This routine is called to perform PnP control operation on file object.

Arguments:

    DeviceObject - WS2IFSL device object
    Irp          - PnP Irp

Return Value:

    STATUS_SUCCESS - device control operation completed
    STATUS_PENDING - operation is in progress
    STATUS_INVALID_DEVICE_REQUEST - the operation cannot be performed on
                        this file object.

--*/
{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpSp;
    ULONG                       eaNameTag;

    PAGED_CODE ();

    // Get the file type from file object context
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    eaNameTag = *((PULONG)irpSp->FileObject->FsContext);

    // Call appropriate routine based on file type
    switch (eaNameTag) {
    case SOCKET_FILE_EANAME_TAG:
        switch (irpSp->MinorFunction) {
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            status = SocketPnPTargetQuery (irpSp->FileObject, Irp);
            break;
        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
        break;

    default:
        ASSERTMSG ("Unknown file EA name tag", FALSE);

    case PROCESS_FILE_EANAME_TAG:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
   }
    // Complete the request if it was not marked pending
    if (status!=STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\driver.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module contains the driver entry and unload routines
    for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

#include "precomp.h"

// Local routine declarations
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
DriverUnload (
	IN PDRIVER_OBJECT 	DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry )
#pragma alloc_text(PAGE, DriverUnload)
#endif

PDEVICE_OBJECT  DeviceObject;

FAST_IO_DISPATCH FastIoDispatchTable = {
    sizeof (FAST_IO_DISPATCH),  // SizeOfFastIoDispatch
    NULL,                       // FastIoCheckIfPossible
    NULL,                       // FastIoRead
    NULL,                       // FastIoWrite
    NULL,                       // FastIoQueryBasicInfo
    NULL,                       // FastIoQueryStandardInfo
    NULL,                       // FastIoLock
    NULL,                       // FastIoUnlockSingle
    NULL,                       // FastIoUnlockAll
    NULL,                       // FastIoUnlockAllByKey
    FastIoDeviceControl         // FastIoDeviceControl
};


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the ws2ifsl device driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.
    RegistryPath - path to driver's registry ley

Return Value:

    Final status from the initialization operation.

--*/

{
    NTSTATUS        status;
    UNICODE_STRING  deviceName;

    PAGED_CODE( );


#if DBG
    ReadDbgInfo (RegistryPath);
#endif
    //
    // Create the device object.  (IoCreateDevice zeroes the memory
    // occupied by the object.)
    //

    RtlInitUnicodeString( &deviceName, WS2IFSL_DEVICE_NAME );

    status = IoCreateDevice(
                 DriverObject,                   // DriverObject
                 0,                              // DeviceExtension
                 &deviceName,                    // DeviceName
                 FILE_DEVICE_WS2IFSL,           // DeviceType
                 0,                              // DeviceCharacteristics
                 FALSE,                          // Exclusive
                 &DeviceObject                   // DeviceObject
                 );


    if (NT_SUCCESS(status)) {
    
        // Initialize device object
        
        // DeviceObject->Flags |= 0;  // Neither direct nor buffering
        DeviceObject->StackSize = 1; // No underlying drivers

        //
        // Initialize the driver object.
        //

        DriverObject->MajorFunction[IRP_MJ_CREATE] = DispatchCreate;
        DriverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchClose;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP] = DispatchCleanup;
        DriverObject->MajorFunction[IRP_MJ_READ] = 
            DriverObject->MajorFunction[IRP_MJ_WRITE] = DispatchReadWrite;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;
        DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnP;
        DriverObject->DriverUnload = DriverUnload;
        DriverObject->FastIoDispatch = &FastIoDispatchTable;


        //
        // Initialize global data.
        //

        WsPrint (DBG_LOAD, ("WS2IFSL DriverEntry: driver loaded OK\n"));
        return STATUS_SUCCESS;
    }
    else {
        WsPrint (DBG_FAILURES|DBG_LOAD,
            ("WS2IFSL DriverEntry: unable to create device object: %X\n",
            status ));
    }

    return status;
} // DriverEntry


NTSTATUS
DriverUnload (
	IN PDRIVER_OBJECT 	DriverObject
    )
/*++

Routine Description:

    This routine releases all resources allocated by the driver
    when it is unloaded.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    STATUS_SUCCESS

--*/

{
    PAGED_CODE( );
    // Release global resources
    IoDeleteDevice (DeviceObject);

    WsPrint (DBG_LOAD, ("WS2IFSL DriverUnload: driver unloaded OK\n"));

    return STATUS_SUCCESS;
} // DriverUnload
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\misc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains declarations of functions and globals
    for helper routines not readily available
    in kernel or TDI libraries for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

ULONG
CopyMdlChainToBuffer(
    IN PMDL  SourceMdlChain,
    IN PVOID Destination,
    IN ULONG DestinationLength
    );

VOID
AllocateMdlChain(
    IN PIRP Irp,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount,
    OUT PULONG TotalByteCount
    );

ULONG
CopyBufferToMdlChain(
    IN PVOID Source,
    IN ULONG SourceLength,
    IN PMDL  DestinationMdlChain
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\precomp.h ===
#include <ntosp.h>

//extern POBJECT_TYPE *IoFileObjectType;
//extern POBJECT_TYPE *ExEventObjectType;
//extern POBJECT_TYPE *PsThreadType;

#ifndef SG_UNCONSTRAINED_GROUP
#define SG_UNCONSTRAINED_GROUP   0x01
#endif

#ifndef SG_CONSTRAINED_GROUP
#define SG_CONSTRAINED_GROUP     0x02
#endif

#include <tdi.h>
#include <tdikrnl.h>
#include <afd.h>       // To support "secret" AFD IOCTL's

#include <ws2ifsl.h>

#include "ws2ifslp.h"
#include "driver.h"
#include "debug.h"
#include "dispatch.h"
#include "socket.h"
#include "process.h"
#include "queue.h"
#include "misc.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\queue.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.h

Abstract:

    This module contains declarations of functions and globals
    for queue processing routines in ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/


VOID
InitializeRequestQueue (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PKTHREAD             ApcThread,
    IN KPROCESSOR_MODE      ApcMode,
    IN PKNORMAL_ROUTINE     ApcRoutine,
    IN PVOID                ApcContext
    );

VOID
InitializeCancelQueue (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PKTHREAD             ApcThread,
    IN KPROCESSOR_MODE      ApcMode,
    IN PKNORMAL_ROUTINE     ApcRoutine,
    IN PVOID                ApcContext
    );

BOOLEAN
QueueRequest (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PIRP                 Irp
    );

PIRP
DequeueRequest (
    PIFSL_PROCESS_CTX   ProcessCtx,
    ULONG               UniqueId,
    BOOLEAN             *more
    );

VOID
CleanupQueuedRequests (
    IN  PIFSL_PROCESS_CTX       ProcessCtx,
    IN  PFILE_OBJECT            SocketFile,
    OUT PLIST_ENTRY             IrpList
    );

VOID
CancelQueuedRequest (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
    );

VOID
QueueCancel (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PIFSL_CANCEL_CTX     CancelCtx
    );

PIFSL_CANCEL_CTX
DequeueCancel (
    PIFSL_PROCESS_CTX   ProcessCtx,
    ULONG               UniqueId,
    BOOLEAN             *more
    );

BOOLEAN
RemoveQueuedCancel (
    PIFSL_PROCESS_CTX   ProcessCtx,
    PIFSL_CANCEL_CTX    CancelCtx
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\process.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module implements process file object for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

#include "precomp.h"

//
// Internal routine prototypes
//

VOID
RetrieveDrvRequest (
    IN PFILE_OBJECT     ProcessFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

VOID
CompleteDrvCancel (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

VOID
CallCompleteDrvRequest (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CreateProcessFile)
#pragma alloc_text(PAGE, CleanupProcessFile)
#pragma alloc_text(PAGE, CloseProcessFile)
#pragma alloc_text(PAGE, RetrieveDrvRequest)
#pragma alloc_text(PAGE, CompleteDrvCancel)
#pragma alloc_text(PAGE, CallCompleteDrvRequest)
#endif

ULONG                   ProcessIoctlCodeMap[3] = {
#if WS2IFSL_IOCTL_FUNCTION(PROCESS,IOCTL_WS2IFSL_RETRIEVE_DRV_REQ)!=0
#error Mismatch between IOCTL function code and ProcessIoControlMap
#endif
    IOCTL_WS2IFSL_RETRIEVE_DRV_REQ,
#if WS2IFSL_IOCTL_FUNCTION(PROCESS,IOCTL_WS2IFSL_COMPLETE_DRV_CAN)!=1
#error Mismatch between IOCTL function code and ProcessIoControlMap
#endif
    IOCTL_WS2IFSL_COMPLETE_DRV_CAN,
#if WS2IFSL_IOCTL_FUNCTION(PROCESS,IOCTL_WS2IFSL_COMPLETE_DRV_REQ)!=2
#error Mismatch between IOCTL function code and ProcessIoControlMap
#endif
    IOCTL_WS2IFSL_COMPLETE_DRV_REQ
};

PPROCESS_DEVICE_CONTROL ProcessIoControlMap[3] = {
    RetrieveDrvRequest,
    CompleteDrvCancel,
    CallCompleteDrvRequest
};


NTSTATUS
CreateProcessFile (
    IN PFILE_OBJECT                 ProcessFile,
    IN KPROCESSOR_MODE              RequestorMode,
    IN PFILE_FULL_EA_INFORMATION    eaInfo
    )
/*++

Routine Description:

    Allocates and initializes process file context structure

Arguments:
    ProcessFile - socket file object
    eaInfo     - EA for process file

Return Value:

    STATUS_SUCCESS  - operation completed OK
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate context
    STATUS_INVALID_PARAMETER - invalid creation parameters
    STATUS_INVALID_HANDLE   - invalid event handle(s)
    STATUS_OBJECT_TYPE_MISMATCH - event handle(s) is not for event object
--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PIFSL_PROCESS_CTX       ProcessCtx;
    PETHREAD                apcThread;

    PAGED_CODE ();

    //
    // Verify the size of the input strucuture
    //

    if (eaInfo->EaValueLength!=WS2IFSL_PROCESS_EA_VALUE_LENGTH) {
        WsPrint (DBG_PROCESS|DBG_FAILURES,
            ("WS2IFSL-%04lx CreateProcessFile: Invalid ea info size (%ld)"
             " for process file %p.\n",
             PsGetCurrentProcessId(),
             eaInfo->EaValueLength,
             ProcessFile));
        return STATUS_INVALID_PARAMETER;
    }


    //
    // Reference event handles for signalling to user mode DLL
    //
    status = ObReferenceObjectByHandle(
                 GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->ApcThread,
                 THREAD_SET_CONTEXT,    // DesiredAccess
                 *PsThreadType,
                 RequestorMode,
                 (PVOID *)&apcThread,
                 NULL
                 );

    if (NT_SUCCESS (status)) {
        if (IoThreadToProcess (apcThread)==IoGetCurrentProcess ()) {

            // Allocate process context and charge it to the process
            try {
                ProcessCtx = (PIFSL_PROCESS_CTX) ExAllocatePoolWithQuotaTag (
                                                    NonPagedPool,
                                                    sizeof (IFSL_PROCESS_CTX),
                                                    PROCESS_FILE_CONTEXT_TAG);
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                ProcessCtx = NULL;
                status = GetExceptionCode ();
            }

            if (ProcessCtx!=NULL) {
                // Initialize process context structure
                ProcessCtx->EANameTag = PROCESS_FILE_EANAME_TAG;
                ProcessCtx->UniqueId = PsGetCurrentProcessId();
                ProcessCtx->CancelId = 0;
                InitializeRequestQueue (ProcessCtx,
                                        (PKTHREAD)apcThread,
                                        RequestorMode,
                                        (PKNORMAL_ROUTINE)GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->RequestRoutine,
                                        GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->ApcContext);
                InitializeCancelQueue (ProcessCtx,
                                        (PKTHREAD)apcThread,
                                        RequestorMode,
                                        (PKNORMAL_ROUTINE)GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->CancelRoutine,
                                        GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->ApcContext);
#if DBG
                ProcessCtx->DbgLevel
                    = GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->DbgLevel|DbgLevel;
#endif



                ProcessFile->FsContext = ProcessCtx;
                WsProcessPrint (ProcessCtx, DBG_PROCESS,
                    ("WS2IFSL-%04lx CreateProcessFile: Process file %p (ctx: %p).\n",
                     ProcessCtx->UniqueId,
                     ProcessFile, ProcessFile->FsContext));
                return STATUS_SUCCESS;
            }
            else {
                WsPrint (DBG_PROCESS|DBG_FAILURES,
                    ("WS2IFSL-%04lx CreateProcessFile: Could not allocate context for"
                     " process file %p.\n",
                     PsGetCurrentProcessId(),
                     ProcessFile));
                if (NT_SUCCESS (status)) {
                    ASSERT (FALSE);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        else {
            WsPrint (DBG_PROCESS|DBG_FAILURES,
                ("WS2IFSL-%04lx CreateProcessFile: Apc thread (%p)"
                 " is not from current process for process file %p.\n",
                 PsGetCurrentProcessId(),
                 GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->ApcThread,
                 ProcessFile));
        }
        ObDereferenceObject (apcThread);
    }
    else {
        WsPrint (DBG_PROCESS|DBG_FAILURES,
            ("WS2IFSL-%04lx CreateProcessFile: Could not reference apc thread (%p)"
             " for process file %p, status: %lx.\n",
             PsGetCurrentProcessId(),
             GET_WS2IFSL_PROCESS_EA_VALUE(eaInfo)->ApcThread,
             ProcessFile,
             status));
    }

    return status;
} // CreateProcessFile


NTSTATUS
CleanupProcessFile (
    IN PFILE_OBJECT ProcessFile,
    IN PIRP         Irp
    )
/*++

Routine Description:

    Cleanup routine for process file, NOP

Arguments:
    ProcessFile  - process file object
    Irp          - cleanup request

Return Value:

    STATUS_SUCESS  - operation completed OK
--*/
{
    PIFSL_PROCESS_CTX  ProcessCtx = ProcessFile->FsContext;
    PAGED_CODE ();

    WsProcessPrint (ProcessCtx, DBG_PROCESS,
        ("WS2IFSL-%04lx CleanupProcessFile: Process file %p (ctx:%p)\n",
        ProcessCtx->UniqueId,
        ProcessFile, ProcessFile->FsContext));

    return STATUS_SUCCESS;
} // CleanupProcessFile


VOID
CloseProcessFile (
    IN PFILE_OBJECT ProcessFile
    )
/*++

Routine Description:

    Deallocate all resources associated with process file

Arguments:
    ProcessFile  - process file object

Return Value:
    None
--*/
{
    PIFSL_PROCESS_CTX    ProcessCtx = ProcessFile->FsContext;
    PAGED_CODE ();

    WsProcessPrint (ProcessCtx, DBG_PROCESS,
        ("WS2IFSL-%04lx CloseProcessFile: Process file %p (ctx:%p)\n",
        ProcessCtx->UniqueId, ProcessFile, ProcessFile->FsContext));

    ASSERT (IsListEmpty (&ProcessCtx->RequestQueue.ListHead));
    ASSERT (IsListEmpty (&ProcessCtx->CancelQueue.ListHead));

    ObDereferenceObject (ProcessCtx->RequestQueue.Apc.Thread);

    // Now free the context itself
    ExFreePool (ProcessCtx);

} // CloseProcessFile




VOID
RetrieveDrvRequest (
    IN PFILE_OBJECT     ProcessFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Retrievs parameters and data of the request to be executed by
    user mode DLL

Arguments:
    ProcessFile         - Identifies the process
    InputBuffer         - input buffer pointer
                                - identifies the request to retreive
                                  and received request parameters
    InputBufferLength   - size of the input buffer
    OutputBuffer        - output buffer pointer
                                - buffer to receive data and address
                                  for send operation
    OutputBufferLength  - size of output buffer
    IoStatus            - IO status information block
        Status: STATUS_SUCCESS - operation retreived OK, no more pending
                                 requests in the queue.
                STATUS_MORE_ENTRIES - operation retrieved OK, more requests
                                      are available in the queue
                STATUS_CANCELLED    - operation was cancelled before it
                                      could be retrieved
                STATUS_INVALID_PARAMETER - one of the parameters was invalid
                STATUS_INSUFFICIENT_RESOURCES - insufficient resources or
                                            buffer space to perform the
                                            operation.
        Information:            - number of bytes copied to OutputBuffer
Return Value:
    None (result returned via IoStatus block)
--*/
{
    PIFSL_PROCESS_CTX       ProcessCtx = ProcessFile->FsContext;
    PIFSL_SOCKET_CTX        SocketCtx;
    PWS2IFSL_RTRV_PARAMS    params;
    PIRP                    irp = NULL;
    PIO_STACK_LOCATION      irpSp;
    BOOLEAN                 more =FALSE;
    ULONG                   bytesCopied;

    PAGED_CODE();

    IoStatus->Information = 0;
    // Check input buffer size
    if (InputBufferLength<sizeof (WS2IFSL_RTRV_PARAMS)) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        WsPrint (DBG_RETRIEVE|DBG_FAILURES,
            ("WS2IFSL-%04lx RetrieveDrvRequest: Invalid input buffer size (%ld).\n",
             PsGetCurrentProcessId(),
             InputBufferLength));
        return;
    }

    try {
        // Verify buffers
        if (RequestorMode!=KernelMode) {
            ProbeForRead (InputBuffer,
                            sizeof (*params),
                            sizeof (ULONG));
            if (OutputBufferLength>0)
                ProbeForWrite (OutputBuffer,
                            OutputBufferLength,
                            sizeof (UCHAR));
        }
        params = InputBuffer;

        // Dequeue the request indetified in the input buffer
        irp = DequeueRequest (ProcessCtx,
                                params->UniqueId,
                                &more);
        if (irp!=NULL) {
            //
            // Copy request parameters and data
            //
            irpSp = IoGetCurrentIrpStackLocation (irp);

            if (OutputBuffer==NULL) {
                //
                // Special condition, dll could not allocate support
                // structures
                //
                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }

            SocketCtx = irpSp->FileObject->FsContext;
            params->DllContext = SocketCtx->DllContext;

            switch (irpSp->MajorFunction) {
            case IRP_MJ_READ:
                params->RequestType = WS2IFSL_REQUEST_READ;
                params->DataLen = irpSp->Parameters.Read.Length;
                params->AddrLen = 0;
                params->Flags = 0;
                break;

            case IRP_MJ_WRITE:
                bytesCopied = CopyMdlChainToBuffer (irp->MdlAddress,
                                        OutputBuffer,
                                        OutputBufferLength);
                if (bytesCopied<irpSp->Parameters.Write.Length) {
					WsPrint (DBG_RETRIEVE|DBG_FAILURES,
						("WS2IFSL-%04lx RetrieveDrvRequest: Invalid output buffer size (%ld).\n",
						 PsGetCurrentProcessId(),
						 OutputBufferLength));
                    ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
                }
                params->RequestType = WS2IFSL_REQUEST_WRITE;
                params->DataLen = bytesCopied;
                params->AddrLen = 0;
                params->Flags = 0;
                IoStatus->Information = bytesCopied;
                break;

            case IRP_MJ_DEVICE_CONTROL:
                switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
                case IOCTL_AFD_RECEIVE_DATAGRAM:
                    params->RequestType = WS2IFSL_REQUEST_RECVFROM;
                    params->DataLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                    params->AddrLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
                    params->Flags = (ULONG)(ULONG_PTR)irp->Tail.Overlay.IfslRequestFlags;
                    break;

                case IOCTL_AFD_RECEIVE:
                    params->RequestType = WS2IFSL_REQUEST_RECV;
                    params->DataLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                    params->AddrLen = 0;
                    params->Flags = (ULONG)(ULONG_PTR)irp->Tail.Overlay.IfslRequestFlags;
                    break;

                case IOCTL_AFD_SEND_DATAGRAM:
                    bytesCopied = CopyMdlChainToBuffer (irp->MdlAddress,
                                        OutputBuffer,
                                        OutputBufferLength);
                    if ((bytesCopied<=irpSp->Parameters.DeviceIoControl.OutputBufferLength)
                            || (ADDR_ALIGN(bytesCopied)+irpSp->Parameters.DeviceIoControl.InputBufferLength
                            < OutputBufferLength)) {
						WsPrint (DBG_RETRIEVE|DBG_FAILURES,
							("WS2IFSL-%04lx RetrieveDrvRequest: Invalid output buffer size (%ld).\n",
							 PsGetCurrentProcessId(),
							 OutputBufferLength));
                        ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
                    }

                    RtlCopyMemory (
                        (PUCHAR)OutputBuffer + ADDR_ALIGN(bytesCopied),
                        irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                        irpSp->Parameters.DeviceIoControl.InputBufferLength);

                    params->RequestType = WS2IFSL_REQUEST_SENDTO;
                    params->DataLen = bytesCopied;
                    params->AddrLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
                    params->Flags = (ULONG)(ULONG_PTR)irp->Tail.Overlay.IfslRequestFlags;
                    IoStatus->Information = ADDR_ALIGN(bytesCopied)
                            + irpSp->Parameters.DeviceIoControl.InputBufferLength;
                    break;
                default:
                    ASSERTMSG ("Unknown IOCTL!!!", FALSE);
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }
                break;
            case IRP_MJ_PNP:
                params->RequestType = WS2IFSL_REQUEST_QUERYHANDLE;
                params->DataLen = sizeof (HANDLE);
                params->AddrLen = 0;
                params->Flags = 0;
                break;
            }

            //
            // Insert the request into the socket list
            //
            if (InsertProcessedRequest (SocketCtx, irp)) {
                if (more)
                    IoStatus->Status = STATUS_MORE_ENTRIES;
                else
                    IoStatus->Status = STATUS_SUCCESS;
                WsProcessPrint (ProcessCtx, DBG_RETRIEVE,
                    ("WS2IFSL-%04lx RetrieveDrvRequest:"
                     " Irp %p (id:%ld), socket file %p, op %ld.\n",
                     ProcessCtx->UniqueId,
                     irp, params->UniqueId, irpSp->FileObject,
                     params->RequestType));
            }

            else {
                ExRaiseStatus (STATUS_CANCELLED);
            }
        }
        else {
            WsProcessPrint (ProcessCtx, DBG_RETRIEVE|DBG_FAILURES,
                ("WS2IFSL-%04lx RetrieveDrvRequest:"
                 " Request with id %ld is not in the queue.\n",
                 ProcessCtx->UniqueId,
                 params->UniqueId));
            IoStatus->Status = STATUS_CANCELLED;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Something failed, complete the request (if any)
        //
        IoStatus->Status = GetExceptionCode ();
        WsProcessPrint (ProcessCtx, DBG_RETRIEVE|DBG_FAILURES,
            ("WS2IFSL-%04lx RetrieveDrvRequest: Failed to process"
             " id %ld, status %lx, irp %p (func: %s).\n",
             ProcessCtx->UniqueId,params->UniqueId, IoStatus->Status,
			 irp,	irp
						? (irpSp->MajorFunction==IRP_MJ_READ
							? "read"
							: (irpSp->MajorFunction==IRP_MJ_WRITE
								? "Write"
                                : (irpSp->MajorFunction==IRP_MJ_PNP
								    ? "PnP"
                                    : (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE_DATAGRAM
									    ? "RecvFrom"
									    : (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE
										    ? "Recv"
										    : (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_SEND_DATAGRAM
											    ? "SendTo"
											    : "UnknownCtl"
											    )
                                            )
										)
									)
								)
							)
						: "Unknown"));

        if (irp!=NULL) {
            irp->IoStatus.Status = IoStatus->Status;
            irp->IoStatus.Information = 0;
            CompleteSocketIrp (irp);
        }
    }
}

VOID
CompleteDrvCancel (
    IN PFILE_OBJECT     ProcessFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Indicates that user mode has completed cancel request
Arguments:
    ProcessFile         - Identifies the process
    InputBuffer         - input buffer pointer
                                - identifies the request being completed
    InputBufferLength   - size of the input buffer
    OutputBuffer        - NULL
    OutputBufferLength  - 0
    IoStatus            - IO status information block
        Status: STATUS_SUCCESS - operation completed OK, no more pending
                                 requests in the queue.
                STATUS_MORE_ENTRIES - operation completed OK, more requests
                                      are available in the queue
        Information:            - 0

Return Value:
    None (result returned via IoStatus block)
--*/
{
    PIFSL_PROCESS_CTX       ProcessCtx = ProcessFile->FsContext;
    PWS2IFSL_CNCL_PARAMS    params;
    BOOLEAN                 more = FALSE;
    PIFSL_CANCEL_CTX        cancelCtx;

    PAGED_CODE();

    IoStatus->Information = 0;

    if (InputBufferLength<sizeof (*params)) {
        WsPrint (DBG_RETRIEVE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvCancel: Invalid input buffer size (%ld)"
             " for process file %p.\n",
             PsGetCurrentProcessId(),
             InputBufferLength,
             ProcessFile));
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return;
    }

    // Verify input buffer
    try {
        if (RequestorMode!=KernelMode) {
            ProbeForRead (InputBuffer,
                            sizeof (*params),
                            sizeof (ULONG));
        }
        params = InputBuffer;
        cancelCtx = DequeueCancel (ProcessCtx,
                                    params->UniqueId,
                                    &more);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        IoStatus->Status = GetExceptionCode ();
        WsPrint (DBG_RETRIEVE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvCancel: Invalid input buffer (%p).\n",
             PsGetCurrentProcessId(),
             InputBuffer));
        return ;
    }

    if (cancelCtx!=NULL) {
        FreeSocketCancel (cancelCtx);
    }
    else {
        WsProcessPrint (ProcessCtx, DBG_RETRIEVE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvCancel: Canceled request id %ld is gone already.\n",
             ProcessCtx->UniqueId, params->UniqueId));
    }

    if (more) {
        IoStatus->Status = STATUS_MORE_ENTRIES;
    }
    else {
        IoStatus->Status = STATUS_SUCCESS;
    }

}


VOID
CallCompleteDrvRequest (
    IN PFILE_OBJECT     ProcessFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Validate parameters and call to complete request that was
    prviously passed to user mode DLL on a specified socket file
Arguments:
    SocketFile          - Socket file on which to operate
    InputBuffer         - input buffer pointer
                            identifies the request to complete and
                            supplies description of the results
    InputBufferLength   - size of the input buffer
    OutputBuffer        - result buffer (data and address)
    OutputBufferLength  - sizeof result buffer
    IoStatus            - IO status information block
        Status: STATUS_SUCCESS - request was completed OK
                STATUS_CANCELLED - request was already cancelled
                STATUS_INVALID_PARAMETER - one of the parameters was invalid

Return Value:
    None (result returned via IoStatus block)
--*/
{
    WS2IFSL_CMPL_PARAMS params;
    PFILE_OBJECT    SocketFile;

    PAGED_CODE();

    IoStatus->Information = 0;

    if (InputBufferLength<sizeof (WS2IFSL_CMPL_PARAMS)) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        WsPrint (DBG_DRV_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvRequest: Invalid input buffer size (%ld).\n",
             PsGetCurrentProcessId(),
             InputBufferLength));
        return;
    }

    // Check and copy parameters
    try {
        if (RequestorMode !=KernelMode) {
            ProbeForRead (InputBuffer,
                            sizeof (WS2IFSL_CMPL_PARAMS),
                            sizeof (ULONG));
            if (OutputBufferLength>0)
                ProbeForRead (OutputBuffer,
                            OutputBufferLength,
                            sizeof (UCHAR));
        }
        params = *((PWS2IFSL_CMPL_PARAMS)InputBuffer);

    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        IoStatus->Status = GetExceptionCode ();
        WsProcessPrint (
             (PIFSL_PROCESS_CTX)ProcessFile->FsContext,
             DBG_DRV_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CallCompleteDrvRequest: Exception accessing"
             " buffers.\n",
             ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId));
        return;
    }
    if (params.DataLen>OutputBufferLength) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        WsPrint (DBG_DRV_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvRequest: Mismatch in output buffer size"
            " (data:%ld, total:%ld) for socket handle %p.\n",
             PsGetCurrentProcessId(),
             params.DataLen,
             OutputBufferLength,
             params.SocketHdl));
        return;
    }

    if (params.AddrLen>0) {
        if ((params.AddrLen>OutputBufferLength) ||
                (ADDR_ALIGN(params.DataLen)+params.AddrLen
                    >OutputBufferLength)) {
            WsPrint (DBG_DRV_COMPLETE|DBG_FAILURES,
                ("WS2IFSL-%04lx CompleteDrvRequest: Mismatch in output buffer size"
                " (data:%ld, addr:%ld, total:%ld) for socket handle %p.\n",
                 PsGetCurrentProcessId(),
                 params.DataLen,
                 params.AddrLen,
                 OutputBufferLength,
                 params.SocketHdl));
            return;
        }
    }

    IoStatus->Status = ObReferenceObjectByHandle (
                 params.SocketHdl,
                 FILE_ALL_ACCESS,
                 *IoFileObjectType,
                 RequestorMode,
                 (PVOID *)&SocketFile,
                 NULL
                 );

    if (NT_SUCCESS (IoStatus->Status)) {

        if ((IoGetRelatedDeviceObject (SocketFile)==DeviceObject)
                && ((*((PULONG)SocketFile->FsContext))
                        ==SOCKET_FILE_EANAME_TAG)) {
            CompleteDrvRequest (SocketFile,
                                &params,
                                OutputBuffer,
                                OutputBufferLength,
                                IoStatus
                                );
        }

        ObDereferenceObject (SocketFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\socket.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    socket.c

Abstract:

    This module implements socket file object for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

#include "precomp.h"



VOID
SetSocketContext (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );


VOID
CompletePvdRequest (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

VOID
ProcessedCancelRoutine (
        IN PDEVICE_OBJECT       DeviceObject,
        IN PIRP                         Irp
    );

PIRP
GetProcessedRequest (
    PIFSL_SOCKET_CTX    SocketCtx,
    ULONG               UniqueId
    );

VOID
CleanupProcessedRequests (
    PIFSL_SOCKET_CTX    SocketCtx,
    PLIST_ENTRY         IrpList
    );


VOID
CancelSocketIo (
    PFILE_OBJECT    SocketFile
    );

PFILE_OBJECT
GetSocketProcessReference (
    IN  PIFSL_SOCKET_CTX    SocketCtx
    );

PFILE_OBJECT
SetSocketProcessReference (
    IN  PIFSL_SOCKET_CTX    SocketCtx,
    IN  PFILE_OBJECT        NewProcessFile,
    IN  PVOID               NewDllContext
    );

NTSTATUS
CompleteTargetQuery (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CreateSocketFile)
#pragma alloc_text(PAGE, CleanupSocketFile)
#pragma alloc_text(PAGE, CloseSocketFile)
#pragma alloc_text(PAGE, DoSocketReadWrite)
#pragma alloc_text(PAGE, DoSocketAfdIoctl)
#pragma alloc_text(PAGE, SetSocketContext)
#pragma alloc_text(PAGE, CompleteDrvRequest)
#pragma alloc_text(PAGE, CompletePvdRequest)
#pragma alloc_text(PAGE, SocketPnPTargetQuery)
//#pragma alloc_text (PAGE, CompleteTargetQuery) - should never be paged. 
#endif

ULONG                  SocketIoctlCodeMap[2] = {
#if WS2IFSL_IOCTL_FUNCTION(SOCKET,IOCTL_WS2IFSL_SET_SOCKET_CONTEXT)!=0
#error Mismatch between IOCTL function code and SocketIoControlMap
#endif
    IOCTL_WS2IFSL_SET_SOCKET_CONTEXT,
#if WS2IFSL_IOCTL_FUNCTION(SOCKET,IOCTL_WS2IFSL_COMPLETE_PVD_REQ)!=1
#error Mismatch between IOCTL function code and SocketIoControlMap
#endif
    IOCTL_WS2IFSL_COMPLETE_PVD_REQ
};

PSOCKET_DEVICE_CONTROL SocketIoControlMap[2] = {
    SetSocketContext,
    CompletePvdRequest
};


#define GenerateUniqueId(curId) \
    ((ULONG)InterlockedIncrement (&(curId)))


NTSTATUS
CreateSocketFile (
    IN PFILE_OBJECT                 SocketFile,
    IN KPROCESSOR_MODE              RequestorMode,
    IN PFILE_FULL_EA_INFORMATION    eaInfo
    )
/*++

Routine Description:

    Allocates and initializes socket file context structure.

Arguments:
    SocketFile - socket file object
    eaInfo     - EA for socket file

Return Value:

    STATUS_SUCCESS  - operation completed OK
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate context
--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIFSL_SOCKET_CTX    SocketCtx;
    HANDLE              hProcessFile;
    PFILE_OBJECT        ProcessFile;
    PVOID               DllContext;

    PAGED_CODE ();

    if (eaInfo->EaValueLength!=WS2IFSL_SOCKET_EA_VALUE_LENGTH) {
        WsPrint (DBG_SOCKET|DBG_FAILURES,
            ("WS2IFSL-%04lx CreateSocketFile: Invalid ea info size (%ld)"
             " for process file %p.\n",
             PsGetCurrentProcessId(),
             eaInfo->EaValueLength,
             SocketFile));
        return STATUS_INVALID_PARAMETER;
    }

    hProcessFile = GET_WS2IFSL_SOCKET_EA_VALUE(eaInfo)->ProcessFile;
    DllContext = GET_WS2IFSL_SOCKET_EA_VALUE(eaInfo)->DllContext;
    // Get reference to the process file with which this context is associated
    status = ObReferenceObjectByHandle(
                 hProcessFile,
                 FILE_ALL_ACCESS,
                 *IoFileObjectType,
                 RequestorMode,
                 (PVOID *)&ProcessFile,
                 NULL
                 );
    if (NT_SUCCESS (status)) {
        // Verify that the file pointer is really our driver's process file
        // and that it created for the current process
        if ((IoGetRelatedDeviceObject (ProcessFile)
                        ==DeviceObject)
                && ((*((PULONG)ProcessFile->FsContext))
                        ==PROCESS_FILE_EANAME_TAG)
                && (((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId
                        ==PsGetCurrentProcessId())) {
            // Allocate socket context and charge it to the process
            try {
                SocketCtx = (PIFSL_SOCKET_CTX) ExAllocatePoolWithQuotaTag (
                                                    NonPagedPool,
                                                    sizeof (IFSL_SOCKET_CTX),
                                                    SOCKET_FILE_CONTEXT_TAG);
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                SocketCtx = NULL;
                status = GetExceptionCode ();
            }

            if (SocketCtx!=NULL) {
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
                    ("WS2IFSL-%04lx CreateSocketFile: Created socket %p (ctx:%p)\n",
                        ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId, SocketFile, SocketCtx));
                // Initialize socket context structure
                SocketCtx->EANameTag = SOCKET_FILE_EANAME_TAG;
                SocketCtx->DllContext = DllContext;
                SocketCtx->ProcessRef = ProcessFile;
                InitializeListHead (&SocketCtx->ProcessedIrps);
                KeInitializeSpinLock (&SocketCtx->SpinLock);
                SocketCtx->CancelCtx = NULL;
                SocketCtx->IrpId = 0;

                // Associate socket context with socket file
                SocketFile->FsContext = SocketCtx;

                return status;
            }
            else {
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_FAILURES|DBG_SOCKET,
                    ("WS2IFSL-%04lx CreateSocketFile: Could not allocate socket context\n",
                        ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId));
                if (NT_SUCCESS (status)) {
                    ASSERT (FALSE);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        else {
            // Handle refers to random file object
            WsPrint (DBG_SOCKET|DBG_FAILURES,
                ("WS2IFSL-%04lx CreateSocketFile: Procees file handle %p (File:%p)"
                 " is not valid\n",
                 PsGetCurrentProcessId(),
                 ProcessFile, hProcessFile));
            status = STATUS_INVALID_PARAMETER;
        }
        ObDereferenceObject (ProcessFile);
    }
    else {
        WsPrint (DBG_SOCKET|DBG_FAILURES,
            ("WS2IFSL-%04lx CreateSocketFile: Could not get process file from handle %p,"
             " status:%lx.\n",
             PsGetCurrentProcessId(),
             hProcessFile,
             status));
    }

    return status;
} // CreateSocketFile


NTSTATUS
CleanupSocketFile (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    )
/*++

Routine Description:

    Initiates socket file cleanup in context of current process.

Arguments:
    SocketFile  - socket file object
    Irp         - cleanup request

Return Value:

    STATUS_PENDING  - operation initiated OK
    STATUS_INVALID_HANDLE - socket has not been initialized
                        in current process
--*/
{
    NTSTATUS                status;
    PIFSL_SOCKET_CTX        SocketCtx;
    PFILE_OBJECT            ProcessFile;
    LIST_ENTRY              irpList;
    PIFSL_CANCEL_CTX        cancelCtx;

    PAGED_CODE ();
    SocketCtx = SocketFile->FsContext;
    ProcessFile = GetSocketProcessReference (SocketCtx);
    WsProcessPrint ((PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext, DBG_SOCKET,
        ("WS2IFSL-%04lx CleanupSocketFile: Socket %p \n",
        GET_SOCKET_PROCESSID(SocketCtx), SocketFile));
    //
    // Build the list of IRPS still panding on this socket
    //
    InitializeListHead (&irpList);
    CleanupQueuedRequests (ProcessFile->FsContext,
                            SocketFile,
                            &irpList);
    CleanupProcessedRequests (SocketCtx, &irpList);

            //
            // Complete the cancelled IRPS
            //
    while (!IsListEmpty (&irpList)) {
        PLIST_ENTRY entry;
        PIRP        irp;
        entry = RemoveHeadList (&irpList);
        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Status = STATUS_CANCELLED;
        irp->IoStatus.Information = 0;
        WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
            ("WS2IFSL-%04lx CleanupSocketFile: Cancelling Irp %p on socket %p \n",
            GET_SOCKET_PROCESSID(SocketCtx), irp, SocketFile));
        CompleteSocketIrp (irp);
    }

    //
    // Indicate that cleanup routine is going to take care of the
    // pending cancel request if any.
    //
    cancelCtx = InterlockedExchangePointer (
                                    (PVOID *)&SocketCtx->CancelCtx,
                                    NULL);
    if (cancelCtx!=NULL) {
        //
        // We are going to try to free this request if it is still in the queue
        //
        WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
            ("WS2IFSL-%04lx CleanupSocketFile: Removing cancel ctx %p on socket %p \n",
            GET_SOCKET_PROCESSID(SocketCtx), cancelCtx, SocketFile));
        if (RemoveQueuedCancel (ProcessFile->FsContext, cancelCtx)) {
            //
            // Request was in the queue, it is safe to call regular free routine
            // (no-one else will find it now, so it is safe to put the pointer
            // back in place so that FreeSocketCancel can free it)
            //
            SocketCtx->CancelCtx = cancelCtx;
            FreeSocketCancel (cancelCtx);
        }
        else {
            //
            // Someone else managed to remove the request from the queue before
            // we did, let them or close routine free it. We aren't going to
            // touch it after this.
            //
            SocketCtx->CancelCtx = cancelCtx;
        }
    }

    status = STATUS_SUCCESS;

    ObDereferenceObject (ProcessFile);
    return status;
} // CleanupSocketFile


VOID
CloseSocketFile (
    IN PFILE_OBJECT SocketFile
    )
/*++

Routine Description:

    Deallocates all resources associated with socket file

Arguments:
    SocketFile  - socket file object

Return Value:
    None
--*/
{
    PIFSL_SOCKET_CTX    SocketCtx = SocketFile->FsContext;

    PAGED_CODE ();
    WsProcessPrint ((PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext, DBG_SOCKET,
        ("WS2IFSL-%04lx CloseSocketFile: Socket %p \n",
         GET_SOCKET_PROCESSID(SocketCtx), SocketFile));

    // First dereference process file
    ObDereferenceObject (SocketCtx->ProcessRef);

    if (SocketCtx->CancelCtx!=NULL) {
        ExFreePool (SocketCtx->CancelCtx);
    }

    // Free context
    ExFreePool (SocketCtx);

} // CloseSocketFile

NTSTATUS
DoSocketReadWrite (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    )
/*++

Routine Description:

    Initiates read and write request processing on socket file.

Arguments:
    SocketFile  - socket file object
    Irp         - read/write request

Return Value:

    STATUS_PENDING  - operation initiated OK
    STATUS_INVALID_HANDLE - socket has not been initialized
                        in current process
--*/
{
    NTSTATUS                status;
    PIFSL_SOCKET_CTX        SocketCtx;
    PFILE_OBJECT            ProcessFile;
    PIO_STACK_LOCATION      irpSp;

    PAGED_CODE ();

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    SocketCtx = SocketFile->FsContext;
    ProcessFile = GetSocketProcessReference (SocketCtx);

    if (((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId==PsGetCurrentProcessId()) {
        WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_READWRITE,
            ("WS2IFSL-%04lx DoSocketReadWrite: %s irp %p on socket %p, len %ld.\n",
            ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId,
            irpSp->MajorFunction==IRP_MJ_READ ? "Read" : "Write",
                        Irp, SocketFile,
                        irpSp->MajorFunction==IRP_MJ_READ
                                        ? irpSp->Parameters.Read.Length
                                        : irpSp->Parameters.Write.Length));
        //
        // Allocate MDL to describe the user buffer.
        //
        Irp->MdlAddress = IoAllocateMdl(
                        Irp->UserBuffer,      // VirtualAddress
                        irpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                            // Length
                        FALSE,              // SecondaryBuffer
                        TRUE,               // ChargeQuota
                        NULL                // Irp
                        );
        if (Irp->MdlAddress!=NULL) {

            // We are going to pend this request
            IoMarkIrpPending (Irp);

            // Prepare IRP for insertion into the queue
            Irp->Tail.Overlay.IfslRequestId = UlongToPtr(GenerateUniqueId (SocketCtx->IrpId));
            Irp->Tail.Overlay.IfslRequestFlags = (PVOID)0;
            Irp->Tail.Overlay.IfslAddressLenPtr = NULL;
            Irp->Tail.Overlay.IfslRequestQueue = NULL;
            if (!QueueRequest (ProcessFile->FsContext, Irp)) {
                Irp->IoStatus.Status = STATUS_CANCELLED;
                Irp->IoStatus.Information = 0;
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_READWRITE,
                    ("WS2IFSL-%04lx DoSocketReadWrite: Cancelling Irp %p on socket %p.\n",
                    ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId,
                    Irp, SocketFile));
                CompleteSocketIrp (Irp);
            }

            status = STATUS_PENDING;
        }
        else {
            WsPrint (DBG_SOCKET|DBG_READWRITE|DBG_FAILURES,
                ("WS2IFSL-%04lx DoSocketReadWrite: Failed to allocate Mdl for Irp %p"
                " on socket %p, status %lx.\n",
            PsGetCurrentProcessId(), Irp, SocketFile));;
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        status = STATUS_INVALID_HANDLE;
        WsPrint (DBG_SOCKET|DBG_READWRITE|DBG_FAILURES,
            ("WS2IFSL-%04lx DoSocketReadWrite: Socket %p has not"
                " been setup in the process.\n",
            PsGetCurrentProcessId(), SocketFile));
    }

    ObDereferenceObject (ProcessFile);

    return status;
} // DoSocketReadWrite

NTSTATUS
DoSocketAfdIoctl (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    )
/*++

Routine Description:

    Initiates read and write request processing on socket file.

Arguments:
    SocketFile  - socket file object
    Irp         - afd IOCTL request

Return Value:

    STATUS_PENDING  - operation initiated OK
    STATUS_INVALID_HANDLE - socket has not been initialized
                        in current process
--*/
{
    NTSTATUS                status;
    PIO_STACK_LOCATION      irpSp;
    PIFSL_SOCKET_CTX        SocketCtx;
    PFILE_OBJECT            ProcessFile;
    LPWSABUF                bufferArray = NULL;
    ULONG                   bufferCount = 0, length = 0, flags = 0;
    PVOID                   address = NULL;
    PULONG                  lengthPtr = NULL;

    PAGED_CODE ();

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Information = 0;
    SocketCtx = SocketFile->FsContext;
    ProcessFile = GetSocketProcessReference (SocketCtx);

    if (((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId==PsGetCurrentProcessId()) {

        try {
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForRead (
                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    irpSp->Parameters.DeviceIoControl.InputBufferLength,
                    sizeof (ULONG));
            }
            switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
            case IOCTL_AFD_RECEIVE_DATAGRAM: {
                PAFD_RECV_DATAGRAM_INFO info;

                if (irpSp->Parameters.DeviceIoControl.InputBufferLength
                            < sizeof (*info)) {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }
                info = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                bufferArray = info->BufferArray;
                bufferCount = info->BufferCount;
                address = info->Address;
                lengthPtr = info->AddressLength;
                if ((address == NULL) ^ (lengthPtr == NULL)) {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }

                if (Irp->RequestorMode!=KernelMode) {
                    ProbeForRead (
                        lengthPtr,
                        sizeof (*lengthPtr),
                        sizeof (ULONG));
                }

                length = *lengthPtr;

                if (address != NULL ) {
                    //
                    // Bomb off if the user is trying to do something bad, like
                    // specify a zero-length address, or one that's unreasonably
                    // huge. Here, we (arbitrarily) define "unreasonably huge" as
                    // anything 64K or greater.
                    //
                    if( length == 0 ||
                        length >= 65536 ) {

                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }

                }
                flags = info->TdiFlags;
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
                        ("WS2IFSL-%04lx DoSocketAfdIoctl: RecvFrom irp %p, socket %p,"
                        " arr %p, cnt %ld, addr %p, lenp %p, len %ld, flags %lx.\n",
                        ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId, Irp, SocketFile,
                        bufferArray, bufferCount, address, lengthPtr, length, flags));
                break;
            }
            case IOCTL_AFD_RECEIVE: {
                PAFD_RECV_INFO info;
                if (irpSp->Parameters.DeviceIoControl.InputBufferLength
                        < sizeof (*info)) {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }
                info = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                bufferArray = info->BufferArray;
                bufferCount = info->BufferCount;
                flags = info->TdiFlags;
                                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
                                        ("WS2IFSL-%04lx DoSocketAfdIoctl: Recv irp %p, socket %p,"
                                        " arr %p, cnt %ld, flags %lx.\n",
                                        ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId, Irp, SocketFile,
                                        bufferArray, bufferCount, flags));
                break;
            }

            case IOCTL_AFD_SEND_DATAGRAM: {
                PAFD_SEND_DATAGRAM_INFO info;

                if (irpSp->Parameters.DeviceIoControl.InputBufferLength
                        < sizeof (*info)) {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }
                info = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                bufferArray = info->BufferArray;
                bufferCount = info->BufferCount;
                address = &(((PTRANSPORT_ADDRESS)
                    info->TdiConnInfo.RemoteAddress)->Address[0].AddressType);
                length = info->TdiConnInfo.RemoteAddressLength
                    - FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].AddressType);

                //
                // Bomb off if the user is trying to do something bad, like
                // specify a zero-length address, or one that's unreasonably
                // huge. Here, we (arbitrarily) define "unreasonably huge" as
                // anything 64K or greater.
                //

                if( length == 0 ||
                    length >= 65536 ) {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }

                if( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead (
                        address,
                        length,
                        sizeof (UCHAR));
                }

                flags = 0;
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
                        ("WS2IFSL-%04lx DoSocketAfdIoctl: SendTo irp %p, socket %p,"
                        " arr %p, cnt %ld, addr %p, len %ld, flags %lx.\n",
                        ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId, Irp, SocketFile,
                        bufferArray, bufferCount, address, length, flags));
                break;
            }
            default:
                ASSERTMSG ("Unknown IOCTL!!!", FALSE);
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }

            AllocateMdlChain (Irp,
                    bufferArray,
                    bufferCount,
                    &irpSp->Parameters.DeviceIoControl.OutputBufferLength);

            WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
                    ("WS2IFSL-%04lx DoSocketAfdIoctl: %s irp %p, socket %p,"
                    " arr %p, cnt %ld, addr %p, lenp %p, len %ld, flags %lx.\n",
                    ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId,
                    irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE_DATAGRAM
                            ? "RecvFrom"
                            : (irpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE
                                    ? "Recv"
                                    : "SendTo"
                                    ),
                    Irp, SocketFile,
                    bufferArray, bufferCount, address, lengthPtr, length, flags));
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            status = GetExceptionCode ();
            WsPrint (DBG_SOCKET|DBG_AFDIOCTL|DBG_FAILURES,
                ("WS2IFSL-%04lx DoSocketAfdIoctl: Failed to process Irp %p"
                " on socket %p, status %lx.\n",
            PsGetCurrentProcessId(), Irp, SocketFile, status));;
            goto Exit;
        }

        // We are going to pend this request
        IoMarkIrpPending (Irp);

        // Prepare IRP for insertion into the queue
        irpSp->Parameters.DeviceIoControl.IfslAddressBuffer = address;
        irpSp->Parameters.DeviceIoControl.IfslAddressLength = length;

        Irp->Tail.Overlay.IfslRequestId = UlongToPtr(GenerateUniqueId (SocketCtx->IrpId));
        Irp->Tail.Overlay.IfslAddressLenPtr = lengthPtr;
        Irp->Tail.Overlay.IfslRequestFlags = UlongToPtr(flags);
        Irp->Tail.Overlay.IfslRequestQueue = NULL;

        if (!QueueRequest (ProcessFile->FsContext, Irp)) {
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;
            WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
                ("WS2IFSL-%04lx DoAfdIoctl: Cancelling Irp %p on socket %p.\n",
                ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId,
                Irp, SocketFile));
            CompleteSocketIrp (Irp);
        }
        status = STATUS_PENDING;
    }
    else {
        status = STATUS_INVALID_HANDLE;
        WsPrint (DBG_SOCKET|DBG_AFDIOCTL|DBG_FAILURES,
            ("WS2IFSL-%04lx DoSocketAfdIoctl: Socket %p has not"
                " been setup in the process\n",
            PsGetCurrentProcessId(), SocketFile));
    }
Exit:
    ObDereferenceObject (ProcessFile);
    return status;
} // DoSocketAfdIoctl

VOID
SetSocketContext (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Sets up socket file in context of a current process: associates it with
    process file and assigns context supplied by the caller

Arguments:
    SocketFile          - Socket file on which to operate
    InputBuffer         - input buffer pointer
    InputBufferLength   - size of the input buffer
    OutputBuffer        - output buffer pointer
    OutputBufferLength  - size of output buffer
    IoStatus            - IO status information block

Return Value:
    None (result returned via IoStatus block)
--*/
{
    PIFSL_SOCKET_CTX        SocketCtx;
    HANDLE                  hProcessFile;
    PFILE_OBJECT            ProcessFile;
    PVOID                   DllContext;

    PAGED_CODE ();

    IoStatus->Information = 0;

    SocketCtx = SocketFile->FsContext;

    // First check arguments
    if (InputBufferLength<sizeof (WS2IFSL_SOCKET_CTX)) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        WsPrint (DBG_SOCKET|DBG_FAILURES,
            ("WS2IFSL-%04lx SetSocketContext: Invalid input buffer size (%ld)"
             " for socket file %p.\n",
             PsGetCurrentProcessId(),
             InputBufferLength,
             SocketFile));
        return;
    }

    try {
        if (RequestorMode!=KernelMode) {
            ProbeForRead (InputBuffer,
                            sizeof (WS2IFSL_SOCKET_CTX),
                            sizeof (ULONG));
        }
        hProcessFile = ((PWS2IFSL_SOCKET_CTX)InputBuffer)->ProcessFile;
        DllContext = ((PWS2IFSL_SOCKET_CTX)InputBuffer)->DllContext;
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        IoStatus->Status = GetExceptionCode ();
        WsPrint (DBG_SOCKET|DBG_FAILURES,
            ("WS2IFSL-%04lx SetSocketContext: Invalid input buffer (%p)"
             " for socket file %p.\n",
             PsGetCurrentProcessId(),
             InputBuffer,
             SocketFile));
        return;
    }

    // Get reference to the process file with which this context is associated
    IoStatus->Status = ObReferenceObjectByHandle(
                 hProcessFile,
                 FILE_ALL_ACCESS,
                 *IoFileObjectType,
                 RequestorMode,
                 (PVOID *)&ProcessFile,
                 NULL
                 );
    if (NT_SUCCESS (IoStatus->Status)) {
        // Verify that the file pointer is really our driver's process file
        // and that it created for the current process
        if ((IoGetRelatedDeviceObject (ProcessFile)
                        ==DeviceObject)
                && ((*((PULONG)ProcessFile->FsContext))
                        ==PROCESS_FILE_EANAME_TAG)
                && (((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId
                        ==PsGetCurrentProcessId())) {

            PFILE_OBJECT    oldProcessFile;

            oldProcessFile = SetSocketProcessReference (
                                            SocketCtx,
                                            ProcessFile,
                                            DllContext);

            if (oldProcessFile==ProcessFile) {
                // Old socket, just reset DLL context
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
                    ("WS2IFSL-%04lx ResetSocketContext:"
                    " Socket %p (h:%p->%p)\n",
                     ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId, SocketFile,
                     SocketCtx->DllContext, DllContext));
            }
            else {
                LIST_ENTRY  irpList;
                // Socket moved to a different process
                WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
                    ("WS2IFSL-%04lx ResetSocketContext:"
                    " Socket %p (f:%p->%p(h:%p)\n",
                     ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId, SocketFile,
                     oldProcessFile, ProcessFile, DllContext));

                InitializeListHead (&irpList);

                // Make sure we do not keep IRPs that are queued to
                // the old object as it may go away as soon as we
                // dereference it below.  Note that processed IRPs
                // do not reference process file object in any way.
                CleanupQueuedRequests (oldProcessFile->FsContext, SocketFile, &irpList);
                while (!IsListEmpty (&irpList)) {
                    PLIST_ENTRY entry;
                    PIRP        irp;
                    entry = RemoveHeadList (&irpList);
                    irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
                    irp->IoStatus.Status = STATUS_CANCELLED;
                    irp->IoStatus.Information = 0;
                    WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_SOCKET,
                        ("WS2IFSL-%04lx ResetSocketContext: Cancelling Irp %p on socket %p \n",
                        ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId, irp, SocketFile));
                    CompleteSocketIrp (irp);
                }


                // Dereference the old object below
                ProcessFile = oldProcessFile;

            }
        }
        else {
            // Handle refers to random file object
            WsPrint (DBG_SOCKET|DBG_FAILURES,
                ("WS2IFSL-%04lx SetSocketContext: Procees file handle %p (File:%p)"
                 " is not valid in the process.\n",
                 PsGetCurrentProcessId(),
                 ProcessFile, hProcessFile));
            IoStatus->Status = STATUS_INVALID_PARAMETER;
        }

        ObDereferenceObject (ProcessFile);
    }
    else {
        WsPrint (DBG_SOCKET|DBG_FAILURES,
            ("WS2IFSL-%04lx SetSocketContext: Could not get process file from handle %p,"
             " status:%lx.\n",
             PsGetCurrentProcessId(),
             hProcessFile,
             IoStatus->Status));
    }

} //SetSocketContext



VOID
CompletePvdRequest (
    IN PFILE_OBJECT     SocketFile,
    IN KPROCESSOR_MODE  RequestorMode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    OUT PVOID           OutputBuffer,
    IN ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Completes this IOCTL to allow completion port usage by non-IFS providers
Arguments:
    SocketFile          - Socket file on which to operate
    InputBuffer         - input buffer pointer
                            contains IoStatus structure to be returned
                            as the result of this call
    InputBufferLength   - size of the input buffer
    OutputBuffer        - NULL
    OutputBufferLength  - 0
    IoStatus            - IO status information block

Return Value:
    None (result returned via IoStatus block)
--*/
{
    PIFSL_SOCKET_CTX    SocketCtx;
    PFILE_OBJECT        ProcessFile;
    PAGED_CODE();

    IoStatus->Information = 0;
    // First check arguments
    if (InputBufferLength<sizeof (IO_STATUS_BLOCK)) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        WsPrint (DBG_PVD_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompletePvdRequest: Invalid input buffer size (%ld)"
             " for socket file %p.\n",
             PsGetCurrentProcessId(),
             InputBufferLength,
             SocketFile));
        return;
    }

    SocketCtx = SocketFile->FsContext;
    ProcessFile = GetSocketProcessReference (SocketCtx);

    if (((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId==PsGetCurrentProcessId()) {
        WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_PVD_COMPLETE,
            ("WS2IFSL-%04lx CompletePvdRequest: Socket %p (h:%p,cport:%p)\n",
                ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId,
                SocketFile, SocketCtx->DllContext,
                SocketFile->CompletionContext));

        // Carefully write status info
        try {
            if (RequestorMode!=KernelMode)
                ProbeForRead (InputBuffer,
                                sizeof (IO_STATUS_BLOCK),
                                sizeof (ULONG));
            *IoStatus = *((PIO_STATUS_BLOCK)InputBuffer);
        }
        except(EXCEPTION_EXECUTE_HANDLER) {
            IoStatus->Status = GetExceptionCode ();
            WsPrint (DBG_SOCKET|DBG_FAILURES,
                ("WS2IFSL-%04lx CompletePvdRequest: Invalid input buffer (%p)"
                 " for socket file %p.\n",
                 PsGetCurrentProcessId(),
                 InputBuffer,
                 SocketFile));
        }
    }
    else {
        IoStatus->Status = STATUS_INVALID_HANDLE;
        WsPrint (DBG_SOCKET|DBG_PVD_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompletePvdRequest: Socket %p has not"
                " been setup in the process\n",
            PsGetCurrentProcessId(), SocketFile));
    }

    ObDereferenceObject (ProcessFile);

} //CompletePvdRequest

VOID
CompleteDrvRequest (
    IN PFILE_OBJECT         SocketFile,
    IN PWS2IFSL_CMPL_PARAMS Params,
    IN PVOID                OutputBuffer,
    IN ULONG                OutputBufferLength,
    OUT PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:

    Complete request that was prviously passed to user mode DLL
Arguments:
    SocketFile          - Socket file on which to operate
    Params              - description of the parameters
    OutputBuffer        - Request results (data and address)
    OutputBufferLength  - sizeof result buffer
    IoStatus            - IO status information block
        Status: STATUS_SUCCESS - request was completed OK
                STATUS_CANCELLED - request was already cancelled

Return Value:
    None (result returned via IoStatus block)
--*/
{
    PIFSL_SOCKET_CTX    SocketCtx;
    PIRP                irp = NULL;
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    SocketCtx = SocketFile->FsContext;


    // Check and copy parameters
    try {

        //
        // Try to find matching IRP in the processed list.
        //
        irp = GetProcessedRequest (SocketCtx, Params->UniqueId);
        if (irp!=NULL) {
            NTSTATUS    status = Params->Status , status2 = 0;
            ULONG       bytesCopied;

            irpSp = IoGetCurrentIrpStackLocation (irp);

            //
            // Copy data based on the function we performed
            //

            switch (irpSp->MajorFunction) {
            case IRP_MJ_DEVICE_CONTROL:
                switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
                case IOCTL_AFD_RECEIVE_DATAGRAM:
                    //
                    // Copy address buffer and length
                    //
                    if (irpSp->Parameters.DeviceIoControl.IfslAddressBuffer!=NULL) {
                        ULONG   addrOffset = ADDR_ALIGN(irpSp->Parameters.DeviceIoControl.OutputBufferLength);
                        if (addrOffset+Params->AddrLen > OutputBufferLength) {
                            ExRaiseStatus (STATUS_INVALID_PARAMETER);
                        }
                        if (Params->AddrLen
                                <=irpSp->Parameters.DeviceIoControl.IfslAddressLength) {
                            RtlCopyMemory (
                                    irpSp->Parameters.DeviceIoControl.IfslAddressBuffer,
                                    (PUCHAR)OutputBuffer+addrOffset,
                                    Params->AddrLen);
                        }
                        else {
                            RtlCopyMemory (
                                    irpSp->Parameters.DeviceIoControl.IfslAddressBuffer,
                                    (PUCHAR)OutputBuffer+addrOffset,
                                    irpSp->Parameters.DeviceIoControl.IfslAddressLength);
                            status2 = STATUS_BUFFER_OVERFLOW;
                        }
                    }
                    if (NT_SUCCESS (status2) && irp->UserBuffer) {
                        *((PULONG)(irp->Tail.Overlay.IfslAddressLenPtr)) = Params->AddrLen;
                    }

                    //
                    // Drop through to copy data as well
                    //

                case IOCTL_AFD_RECEIVE:
                    break;
                case IOCTL_AFD_SEND_DATAGRAM:
                    goto NoCopy;
                    break;
                default:
                    ASSERTMSG ("Unsupported IOCTL!!!", FALSE);
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                    break;
                }

                //
                // Drop through to copy data as well
                //

            case IRP_MJ_READ:
                if (irp->MdlAddress!=NULL) {
                    bytesCopied = CopyBufferToMdlChain (
                                    OutputBuffer,
                                    Params->DataLen,
                                    irp->MdlAddress);
                }
                else
                    bytesCopied = 0;

                if ((bytesCopied<Params->DataLen)
                        && NT_SUCCESS (status))
                    status = STATUS_BUFFER_OVERFLOW;
                break;
            case IRP_MJ_WRITE:
                bytesCopied = Params->DataLen;
                // goto NoCopy; // same as break;
                break;
            case IRP_MJ_PNP: 
                if (OutputBufferLength>=sizeof (HANDLE)) {
                    PDEVICE_OBJECT  targetDevice;
                    PIRP            targetIrp;
                    PIO_STACK_LOCATION targetSp;

                    status = ObReferenceObjectByHandle (
                                    *((PHANDLE)OutputBuffer),
                                    MAXIMUM_ALLOWED,
                                    *IoFileObjectType,
                                    irp->RequestorMode,
                                    (PVOID *)&irpSp->FileObject,
                                    NULL
                                    );
                    if (NT_SUCCESS (status)) {
                        targetDevice = IoGetRelatedDeviceObject (irpSp->FileObject);
                        targetIrp = IoBuildAsynchronousFsdRequest (
                                                    IRP_MJ_PNP,
                                                    targetDevice,
                                                    NULL,
                                                    0,
                                                    NULL,
                                                    NULL
                                                    );
                        if (targetIrp!=NULL) {
                            targetSp = IoGetNextIrpStackLocation (targetIrp);
                            *targetSp = *irpSp;
                            targetSp->FileObject = irpSp->FileObject;
                            IoSetCompletionRoutine( targetIrp, CompleteTargetQuery, irp, TRUE, TRUE, TRUE );
                            IoCallDriver (targetDevice, targetIrp);
                            goto NoCompletion;
                        }
                        else {
                            ObDereferenceObject (irpSp->FileObject);
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }
                }
                else {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }
                    
                                
                break;
            default:
                ASSERTMSG ("Unsupported MJ code!!!", FALSE);
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
                break;
            }

        NoCopy:
            irp->IoStatus.Information = bytesCopied;

            if (NT_SUCCESS (status)) {
                irp->IoStatus.Status = status2;
            }
            else {
                irp->IoStatus.Status = status;
            }

            WsProcessPrint (
                (PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
                DBG_DRV_COMPLETE,
                ("WS2IFSL-%04lx CompleteDrvRequest: Irp %p, status %lx, info %ld,"
                 " on socket %p (h:%p).\n",
                    GET_SOCKET_PROCESSID(SocketCtx),
                    irp, irp->IoStatus.Status,
                    irp->IoStatus.Information,
                    SocketFile, SocketCtx->DllContext));
            CompleteSocketIrp (irp);
        NoCompletion:
            IoStatus->Status = STATUS_SUCCESS;
        }
        else {
            IoStatus->Status = STATUS_CANCELLED;
            WsProcessPrint (
                (PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
                DBG_DRV_COMPLETE|DBG_FAILURES,
                ("WS2IFSL-%04lx CompleteDrvRequest:"
                 " Request id %ld is not in the list"
                 " for socket %p.\n",
                 GET_SOCKET_PROCESSID(SocketCtx),
                 Params->UniqueId,
                 SocketFile));
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        IoStatus->Status = GetExceptionCode ();
        WsProcessPrint (
             (PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
             DBG_DRV_COMPLETE|DBG_FAILURES,
            ("WS2IFSL-%04lx CompleteDrvRequest: Failed to process"
             " Irp %p (id %ld) for socket %p, status %lx.\n",
             GET_SOCKET_PROCESSID(SocketCtx),
             irp, Params->UniqueId,
             SocketFile, IoStatus->Status));
        if (irp!=NULL) {
            //
            // Cleanup and complete the irp
            //
            irp->IoStatus.Status = IoStatus->Status;
            irp->IoStatus.Information = 0;
            if (irpSp->MajorFunction==IRP_MJ_DEVICE_CONTROL) {
                irp->UserBuffer = NULL;
            }
            CompleteSocketIrp (irp);
        }
    }
} //CompleteDrvRequest

NTSTATUS
CompleteTargetQuery (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIRP    irp = Context;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (irp);

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    ObDereferenceObject (irpSp->FileObject);
    //
    // Copy the status info returned by target device
    //
    irp->IoStatus = Irp->IoStatus;

    //
    // Free the target irp;
    // 
    IoFreeIrp (Irp);

    //
    // Complete the original IRP.
    //
    CompleteSocketIrp (irp);

    //
    // Make sure IO subsystem does not touch the IRP we freed
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SocketPnPTargetQuery (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    )
/*++

Routine Description:

    Passes target device relation query to the underlying
    socket if any.

Arguments:
    SocketFile  - socket file object
    Irp         - query target device relation request

Return Value:

    STATUS_PENDING  - operation initiated OK
--*/
{
    NTSTATUS                status;
    PIO_STACK_LOCATION      irpSp;
    PIFSL_SOCKET_CTX        SocketCtx;
    PFILE_OBJECT            ProcessFile;

    PAGED_CODE ();

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    Irp->IoStatus.Information = 0;
    SocketCtx = SocketFile->FsContext;
    ProcessFile = GetSocketProcessReference (SocketCtx);


    // We are going to pend this request
    IoMarkIrpPending (Irp);

    // Prepare IRP for insertion into the queue
    irpSp->Parameters.DeviceIoControl.IfslAddressBuffer = NULL;
    irpSp->Parameters.DeviceIoControl.IfslAddressLength = 0;

    Irp->Tail.Overlay.IfslRequestId = UlongToPtr(GenerateUniqueId (SocketCtx->IrpId));
    Irp->Tail.Overlay.IfslAddressLenPtr = NULL;
    Irp->Tail.Overlay.IfslRequestFlags = (PVOID)0;
    Irp->Tail.Overlay.IfslRequestQueue = NULL;

    if (!QueueRequest (ProcessFile->FsContext, Irp)) {
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        WsProcessPrint ((PIFSL_PROCESS_CTX)ProcessFile->FsContext, DBG_AFDIOCTL,
            ("WS2IFSL-%04lx DoAfdIoctl: Cancelling Irp %p on socket %p.\n",
            ((PIFSL_PROCESS_CTX)ProcessFile->FsContext)->UniqueId,
            Irp, SocketFile));
        CompleteSocketIrp (Irp);
    }
    status = STATUS_PENDING;

    ObDereferenceObject (ProcessFile);
    return status;
}

BOOLEAN
InsertProcessedRequest (
    PIFSL_SOCKET_CTX    SocketCtx,
    PIRP                Irp
    )
/*++

Routine Description:

    Inserts request that was processed to be passed to user mode
    DLL into socket list.  Checks if request is cancelled
Arguments:
    SocketCtx   - contex of the socket into which insert the request
    Irp         - request to insert
Return Value:
    TRUE        - request was inserted
    FALSE       - request is being cancelled
--*/
{
    KIRQL       oldIRQL;
    IoSetCancelRoutine (Irp, ProcessedCancelRoutine);
    KeAcquireSpinLock (&SocketCtx->SpinLock, &oldIRQL);
    if (!Irp->Cancel) {
        InsertTailList (&SocketCtx->ProcessedIrps,
                        &Irp->Tail.Overlay.ListEntry);
        Irp->Tail.Overlay.IfslRequestQueue = &SocketCtx->ProcessedIrps;
        KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
        return TRUE;
    }
    else {
        KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
        return FALSE;
    }
}

VOID
ProcessedCancelRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    )
/*++

Routine Description:

    Driver cancel routine for socket request waiting in the list
    (being processed by the user mode DLL).
Arguments:
    DeviceObject - WS2IFSL device object
    Irp          - Irp to be cancelled

Return Value:
    None
--*/
{
    PIO_STACK_LOCATION      irpSp;
    PIFSL_SOCKET_CTX        SocketCtx;

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    SocketCtx = irpSp->FileObject->FsContext;
    WsProcessPrint ((PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
              DBG_SOCKET,
              ("WS2IFSL-%04lx ProcessedCancel: Socket %p, Irp %p\n",
              GET_SOCKET_PROCESSID(SocketCtx),
              irpSp->FileObject, Irp));
    KeAcquireSpinLockAtDpcLevel (&SocketCtx->SpinLock);
    if (Irp->Tail.Overlay.IfslRequestQueue!=NULL) {
        ASSERT (Irp->Tail.Overlay.IfslRequestQueue==&SocketCtx->ProcessedIrps);
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
        Irp->Tail.Overlay.IfslRequestQueue = NULL;
        KeReleaseSpinLockFromDpcLevel (&SocketCtx->SpinLock);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        CancelSocketIo (irpSp->FileObject);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        CompleteSocketIrp (Irp);
    }
    else {
        KeReleaseSpinLockFromDpcLevel (&SocketCtx->SpinLock);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
        //
        // Don't touch IRP after this as we do not own it anymore
        //
    }
}

VOID
CleanupProcessedRequests (
    IN  PIFSL_SOCKET_CTX    SocketCtx,
    OUT PLIST_ENTRY         IrpList
    )
/*++

Routine Description:

    Cleans up all requests on the socket which are being
    processed by the user mode DLL

Arguments:
    SocketCtx   -   context of the socket
    IrpList     -   list to insert cleaned up request (to be completed
                    by the caller)
Return Value:
    None
--*/
{
    PIRP            irp;
    PLIST_ENTRY     entry;
    KIRQL           oldIRQL;

    KeAcquireSpinLock (&SocketCtx->SpinLock, &oldIRQL);
    while (!IsListEmpty(&SocketCtx->ProcessedIrps)) {
        entry = RemoveHeadList (&SocketCtx->ProcessedIrps);
        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        ASSERT (irp->Tail.Overlay.IfslRequestQueue==&SocketCtx->ProcessedIrps);
        irp->Tail.Overlay.IfslRequestQueue = NULL;
        InsertTailList (IrpList, &irp->Tail.Overlay.ListEntry);
    }
    KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
}

VOID
CompleteSocketIrp (
    PIRP        Irp
    )
/*++

Routine Description:

    Completes IRP and properly synchronizes with cancel routine
    if necessary (it has already been called).
Arguments:
    Irp     - irp to complete
Return Value:
    None
--*/
{

    //
    // Reset cancel routine (it wont complete the IRP as it
    // won't be able to find it)
    //

    if (IoSetCancelRoutine (Irp, NULL)==NULL) {
        KIRQL   oldIRQL;
        //
        // Cancel routine has been called.
        // Synchronize with cancel routine (it won't touch the
        // IRP after it releases cancel spinlock)

        IoAcquireCancelSpinLock (&oldIRQL);
        IoReleaseCancelSpinLock (oldIRQL);
    }

    if (Irp->MdlAddress!=NULL) {
        ASSERT ((Irp->MdlAddress->MdlFlags & MDL_PAGES_LOCKED) == 0);
        IoFreeMdl (Irp->MdlAddress);
        Irp->MdlAddress = NULL;
    }

    IoCompleteRequest (Irp, IO_NO_INCREMENT);
}

PIRP
GetProcessedRequest (
    PIFSL_SOCKET_CTX    SocketCtx,
    ULONG               UniqueId
    )
/*++

Routine Description:

    Finds and returns matching IRP from the processed IRP list

Arguments:
    SocketCtx   - socket context to search for the IRP in
    UniqueId    - id assigned to the request to distinguish identify
                    it case it was cancelled and IRP was reused
Return Value:
    IRP
    NULL    - irp was not found
--*/
{
    PIRP        irp;
    PLIST_ENTRY entry;
    KIRQL       oldIRQL;

    //
    // We do not usually have many request sumulteneously pending
    // on a socket, so the linear search should suffice.
    //

    KeAcquireSpinLock (&SocketCtx->SpinLock, &oldIRQL);
    entry = SocketCtx->ProcessedIrps.Flink;
    while (entry!=&SocketCtx->ProcessedIrps) {
        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        entry = entry->Flink;
        if (irp->Tail.Overlay.IfslRequestId==UlongToPtr(UniqueId)) {
            ASSERT (irp->Tail.Overlay.IfslRequestQueue==&SocketCtx->ProcessedIrps);
            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
            irp->Tail.Overlay.IfslRequestQueue = NULL;
            KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
            return irp;
        }
    }
    KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
    return NULL;
}


VOID
CancelSocketIo (
    PFILE_OBJECT    SocketFile
    )
/*++

Routine Description:

    Queue a request to user mode DLL to cancel all io on the socket

Arguments:
    SocketCtx   - socket context on which IO is to be cancelled

Return Value:
        None
--*/
{
    PIFSL_SOCKET_CTX    SocketCtx = SocketFile->FsContext;
    PIFSL_PROCESS_CTX   ProcessCtx = SocketCtx->ProcessRef->FsContext;
    PIFSL_CANCEL_CTX    cancelCtx;

    try {
        cancelCtx = (PIFSL_CANCEL_CTX) ExAllocatePoolWithQuotaTag (
                                        NonPagedPool,
                                        sizeof (IFSL_CANCEL_CTX),
                                        CANCEL_CTX_TAG);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        cancelCtx = NULL;
    }


    if (cancelCtx!=NULL) {
        //
        // Make sure socket does not go away while this request exists
        //
        ObReferenceObject (SocketFile);
        cancelCtx->SocketFile = SocketFile;
        cancelCtx->UniqueId = GenerateUniqueId (ProcessCtx->CancelId);

        //
        // We do not want to queue another cancel request if we have
        // one pending or being executed
        //
        if (InterlockedCompareExchangePointer ((PVOID *)&SocketCtx->CancelCtx,
                                cancelCtx,
                                NULL)==NULL) {
            WsProcessPrint (
                      ProcessCtx,
                      DBG_CANCEL,
                      ("WS2IFSL-%04lx CancelSocketIo: Context %p, socket %p\n",
                      ProcessCtx->UniqueId,
                      cancelCtx, SocketFile));
            QueueCancel (ProcessCtx, cancelCtx);
            return;
        }

        WsProcessPrint (
                  ProcessCtx,
                  DBG_CANCEL,
                  ("WS2IFSL-%04lx CancelSocketIo: Another cancel active"
                  " context %p, socket %p\n",
                  ProcessCtx->UniqueId,
                  SocketCtx->CancelCtx, SocketFile));
        ObDereferenceObject (SocketFile);
        ExFreePool (cancelCtx);
    }
    else {
        WsPrint (DBG_SOCKET|DBG_CANCEL|DBG_FAILURES,
                  ("WS2IFSL-%04lx CancelSocketIo: Could not allocate cancel"
                  " context for socket %p\n",
                  PsGetCurrentProcessId(),
                  SocketFile));
    }
}

VOID
FreeSocketCancel (
    PIFSL_CANCEL_CTX CancelCtx
    )
/*++

Routine Description:

    Frees resources associated with cancel request

Arguments:
    CancelCtx   - cancel request context

Return Value:
        None
--*/
{
    PFILE_OBJECT        SocketFile = CancelCtx->SocketFile;
    PIFSL_SOCKET_CTX    SocketCtx = SocketFile->FsContext;

    ASSERT (IoGetRelatedDeviceObject (SocketFile)==DeviceObject);
    ASSERT (SocketCtx->EANameTag==SOCKET_FILE_EANAME_TAG);
    ASSERT (CancelCtx->ListEntry.Flink==NULL);

    //
    // We are going to dereference the file object whether
    // free the structure or not
    //
    CancelCtx->SocketFile = NULL;
    ObDereferenceObject (SocketFile);

    //
    // During socket closure, the cleanup routine may be in
    // process of freeing this cancel context and will set
    // the pointer to it to NULL to indicate the fact
    //
    if (InterlockedCompareExchangePointer ((PVOID *)&SocketCtx->CancelCtx,
                                            NULL,
                                            CancelCtx)) {
        WsProcessPrint (
                  (PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
                  DBG_CANCEL,
                  ("WS2IFSL-%04lx FreeSocketCancel: Freeing cancel"
                  " context %p, socket %p\n",
                  GET_SOCKET_PROCESSID(SocketCtx),
                  CancelCtx, SocketFile));
        ExFreePool (CancelCtx);
    }
    else {
        //
        // The close routine will take care of freeing the request
        //
        WsProcessPrint (
                  (PIFSL_PROCESS_CTX)SocketCtx->ProcessRef->FsContext,
                  DBG_CANCEL,
                  ("WS2IFSL-%04lx FreeSocketCancel: Cleanup owns cancel"
                  " context %p, socket %p\n",
                  GET_SOCKET_PROCESSID(SocketCtx),
                  CancelCtx, SocketFile));
    }
}


PFILE_OBJECT
GetSocketProcessReference (
    IN  PIFSL_SOCKET_CTX    SocketCtx
    )
/*++

Routine Description:

    Reads and references process file currently associated with
    the socket under the lock to protect in case socket is moved
    to a different process

Arguments:
    SocketCtx   - socket context to read process file from

Return Value:
    Referenced pointer to process file object currently associated
    with the socket.

--*/
{
    KIRQL               oldIRQL;
    PFILE_OBJECT        ProcessFile;

    KeAcquireSpinLock (&SocketCtx->SpinLock, &oldIRQL);
    ObReferenceObject (SocketCtx->ProcessRef);
    ProcessFile = SocketCtx->ProcessRef;
    KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);

    return ProcessFile;
}


PFILE_OBJECT
SetSocketProcessReference (
    IN  PIFSL_SOCKET_CTX    SocketCtx,
    IN  PFILE_OBJECT        NewProcessFile,
    IN  PVOID               NewDllContext
    )
/*++

Routine Description:

    Sets new process context for the socket object under the protection
    of a lock.

Arguments:
    SocketCtx       - socket context to set
    NewProcessFile  - process file reference
    NewDllContext   - context to be associated with the socket
                        in the process

Return Value:
    Previous process file reference
--*/
{
    KIRQL               oldIRQL;
    PFILE_OBJECT        ProcessFile;

    KeAcquireSpinLock (&SocketCtx->SpinLock, &oldIRQL);
    ProcessFile = SocketCtx->ProcessRef;
    SocketCtx->ProcessRef = NewProcessFile;
    SocketCtx->DllContext = NewDllContext;
    KeReleaseSpinLock (&SocketCtx->SpinLock, oldIRQL);
    return ProcessFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\process.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.h

Abstract:

    This module contains declarations of functions and globals
    for process file object implemetation in ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

// Process file device IO control function pointer
typedef
VOID                                        // Result is returned via IoStatus
(*PPROCESS_DEVICE_CONTROL) (
    IN PFILE_OBJECT     ProcessFile,        // Process file on which to operate
    IN KPROCESSOR_MODE  RequestorMode,      // Mode of the caller
    IN PVOID            InputBuffer,        // Input buffer pointer
    IN ULONG            InputBufferLength,  // Size of the input buffer
    OUT PVOID           OutputBuffer,       // Output buffer pointer
    IN ULONG            OutputBufferLength, // Size of output buffer
    OUT PIO_STATUS_BLOCK IoStatus           // IO status information block
    );

PPROCESS_DEVICE_CONTROL ProcessIoControlMap[3];
ULONG                   ProcessIoctlCodeMap[3];

NTSTATUS
CreateProcessFile (
    IN PFILE_OBJECT                 ProcessFile,
    IN KPROCESSOR_MODE              RequestorMode,
    IN PFILE_FULL_EA_INFORMATION    eaInfo
    );

NTSTATUS
CleanupProcessFile (
    IN PFILE_OBJECT ProcessFile,
    IN PIRP         Irp
    );

VOID
CloseProcessFile (
    IN PFILE_OBJECT ProcessFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\queue.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    This module implements IRP queue processing routines for ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

#include "precomp.h"

//
// Private prototypes
//

VOID
QueueKernelRoutine (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

VOID
SignalRequest (
	IN PIFSL_PROCESS_CTX		ProcessCtx
	);

VOID
RequestRundownRoutine (
    IN struct _KAPC *Apc
    );

VOID
FlushRequestQueue (
    PIFSL_QUEUE Queue
    );

VOID
QueuedCancelRoutine (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
    );

VOID
SignalCancel (
	IN PIFSL_PROCESS_CTX		ProcessCtx
	);

VOID
CancelRundownRoutine (
    IN struct _KAPC *Apc
    );

VOID
FlushCancelQueue (
    PIFSL_QUEUE Queue
    );



#pragma alloc_text(PAGE, InitializeRequestQueue)
#pragma alloc_text(PAGE, InitializeCancelQueue)

VOID
InitializeRequestQueue (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PKTHREAD             ApcThread,
    IN KPROCESSOR_MODE      ApcMode,
    IN PKNORMAL_ROUTINE     ApcRoutine,
    IN PVOID                ApcContext
    )
/*++

Routine Description:

    Initializes request queue object

Arguments:
    ProcessCtx   - process context to which queue belongs
    ApcThread    - thread to which to queue APC requests for processing
    ApcMode      - mode of the caller (should be user)
    ApcRoutine   - routine that processes requests
    ApcContext   - context to pass to the routine in addition to request
                    parameters

Return Value:
    None
--*/
{
	PAGED_CODE ();

    InitializeListHead (&ProcessCtx->RequestQueue.ListHead);
    ProcessCtx->RequestQueue.Busy = FALSE;
    KeInitializeSpinLock (&ProcessCtx->RequestQueue.Lock);
    KeInitializeApc (&ProcessCtx->RequestQueue.Apc,
                        ApcThread,
                        OriginalApcEnvironment,
                        QueueKernelRoutine,
                        RequestRundownRoutine,
                        ApcRoutine,
                        ApcMode,
                        ApcContext);
}


BOOLEAN
QueueRequest (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PIRP                 Irp
    )
/*++

Routine Description:

    Queues IRP to IFSL request queue and signals to user mode DLL
    to start processing if it is not busy already.

Arguments:
    ProcessCtx   - process context in which to queue
    Irp          - request to be queued

Return Value:
    TRUE    - IRP was queued
    FALSE   - IRP was already cancelled

--*/
{
	BOOLEAN		res;
    KIRQL       oldIRQL;
	PIFSL_QUEUE	queue = &ProcessCtx->RequestQueue;

    IoSetCancelRoutine (Irp, QueuedCancelRoutine);
    KeAcquireSpinLock (&queue->Lock, &oldIRQL);
    if (!Irp->Cancel) {
		//
		// Request is not cancelled, insert it into the queue
		//
        InsertTailList (&queue->ListHead, &Irp->Tail.Overlay.ListEntry);
        Irp->Tail.Overlay.IfslRequestQueue = queue;

		//
		// If queue wasn't busy, signal to user mode DLL to pick up new request
		//
        if (!queue->Busy) {
			ASSERT (queue->ListHead.Flink==&Irp->Tail.Overlay.ListEntry);
            SignalRequest (ProcessCtx);
            ASSERT (queue->Busy);
        }
        res = TRUE;
    }
    else {
        res = FALSE;
    }
    KeReleaseSpinLock (&queue->Lock, oldIRQL);

	return res;

} // QueueRequest

PIRP
DequeueRequest (
    PIFSL_PROCESS_CTX   ProcessCtx,
    ULONG               UniqueId,
    BOOLEAN             *more
    )
/*++

Routine Description:

    Removes IRP from IFSL request queue.

Arguments:
    ProcessCtx  - process context from which to remove
    UniqueId    - unique request id
    more        - set to TRUE if there are more requests in the queue

Return Value:
    IRP         - pointer to the IRP
    NULL        - the request was not in the queue

--*/
{
    KIRQL       oldIRQL;
    PIRP        irp;
    PIFSL_QUEUE queue = &ProcessCtx->RequestQueue;

    KeAcquireSpinLock (&queue->Lock, &oldIRQL);
    irp = CONTAINING_RECORD (queue->ListHead.Flink, IRP, Tail.Overlay.ListEntry);
    if (!IsListEmpty (&queue->ListHead)
            && (irp->Tail.Overlay.IfslRequestId==UlongToPtr(UniqueId))) {
		//
		// Queue is not empty and first request matches passed in parameters,
		// dequeue and return it
		//

		ASSERT (queue->Busy);
        
        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        irp->Tail.Overlay.IfslRequestQueue = NULL;
    }
    else {
        irp = NULL;
    }

    if (IsListEmpty (&queue->ListHead)) {
		//
		// Queue is now empty, change its state, so that new request knows to
		// signal to user mode DLL
		//
        queue->Busy = FALSE;
    }
    else {
		//
		// There is another request pending, signal it now
		//
        SignalRequest (ProcessCtx);
        ASSERT (queue->Busy);
    }
	//
	// Hint the caller that we just signalled, so it does not have to wait on event
	//
    *more = queue->Busy;

    KeReleaseSpinLock (&queue->Lock, oldIRQL);
    return irp;
}


VOID
SignalRequest (
	IN PIFSL_PROCESS_CTX		ProcessCtx
	)
/*++

Routine Description:

    Fills request parameters & signals user mode DLL to process the request

Arguments:
    ProcessCtx   - our context for the process which IRP belongs to

Return Value:
    None
Note:
	SHOULD ONLY BE CALLED WITH QUEUE SPINLOCK HELD
--*/
{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    ULONG                   bufferLen;

    ASSERT (!IsListEmpty (&ProcessCtx->RequestQueue.ListHead));


    irp = CONTAINING_RECORD (
                        ProcessCtx->RequestQueue.ListHead.Flink,
                        IRP,
                        Tail.Overlay.ListEntry
                        );
    irpSp = IoGetCurrentIrpStackLocation (irp);

    switch (irpSp->MajorFunction) {
    case IRP_MJ_READ:
        bufferLen = irpSp->Parameters.Read.Length;;
        break;
    case IRP_MJ_WRITE:
        bufferLen = irpSp->Parameters.Write.Length;
        break;
    case IRP_MJ_DEVICE_CONTROL:
        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_AFD_RECEIVE_DATAGRAM:
            bufferLen = ADDR_ALIGN(irpSp->Parameters.DeviceIoControl.OutputBufferLength)
                        + irpSp->Parameters.DeviceIoControl.InputBufferLength;
            break;
        case IOCTL_AFD_RECEIVE:
            bufferLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            break;
        case IOCTL_AFD_SEND_DATAGRAM:
            bufferLen = ADDR_ALIGN(irpSp->Parameters.DeviceIoControl.OutputBufferLength)
                        + irpSp->Parameters.DeviceIoControl.InputBufferLength;
            break;
        }
        break;
    case IRP_MJ_PNP:
        bufferLen = sizeof (HANDLE);
        break;
    default:
        ASSERT (FALSE);
        break;
    }

    if (KeInsertQueueApc (&ProcessCtx->RequestQueue.Apc,
                                irp->Tail.Overlay.IfslRequestId,
                                UlongToPtr(bufferLen),
                                IO_NETWORK_INCREMENT)) {
        WsProcessPrint (ProcessCtx, DBG_QUEUE,
            ("WS2IFSL-%04lx SignalRequest: Irp %p (id %ld) on socket %p.\n",
             ProcessCtx->UniqueId,
             irp, irp->Tail.Overlay.IfslRequestId,
		     irpSp->FileObject));
        ProcessCtx->RequestQueue.Busy = TRUE;
    }
    else {
        WsProcessPrint (ProcessCtx, DBG_QUEUE|DBG_FAILURES,
            ("WS2IFSL-%04lx KeInsertQueueApc failed: Irp %p (id %ld) on socket %p.\n",
             ProcessCtx->UniqueId,
             irp, irp->Tail.Overlay.IfslRequestId,
		     irpSp->FileObject));
        //
        // APC queing failed, cancel all outstanding requests.
        //
        FlushRequestQueue (&ProcessCtx->RequestQueue);
    }

} // SignalRequest

VOID
QueueKernelRoutine (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    )
{
    NOTHING;
}

VOID
RequestRundownRoutine (
    IN struct _KAPC *Apc
    )
/*++

Routine Description:

    APC rundown routine for request queue APC
    Flushes the queue and marks it as not busy so new
    request fail immediately as well.
Arguments:
    APC     - cancel queue APC structure
Return Value:
    None
--*/
{
    PIFSL_QUEUE Queue;
    KIRQL       oldIrql;

    Queue = CONTAINING_RECORD (Apc, IFSL_QUEUE, Apc);
    KeAcquireSpinLock (&Queue->Lock, &oldIrql);
    Queue->Busy = FALSE;
    FlushRequestQueue (Queue);
    KeReleaseSpinLock (&Queue->Lock, oldIrql);
}


VOID
FlushRequestQueue (
    PIFSL_QUEUE Queue
    )
/*++

Routine Description:

    Flushes and completes IRPs in the request queue
Arguments:
    Queue   - request queue to flush
Return Value:
    None
Note:
	SHOULD ONLY BE CALLED WITH QUEUE SPINLOCK HELD
--*/
{
    while (!IsListEmpty (&Queue->ListHead)) {
        PIRP irp = CONTAINING_RECORD (Queue->ListHead.Flink,
                                            IRP,
                                            Tail.Overlay.ListEntry);
        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        irp->Tail.Overlay.IfslRequestQueue = NULL;
        KeReleaseSpinLockFromDpcLevel (&Queue->Lock);
        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = STATUS_CANCELLED;
        CompleteSocketIrp (irp);
        KeAcquireSpinLockAtDpcLevel (&Queue->Lock);
    }
}

VOID
CleanupQueuedRequests (
    IN  PIFSL_PROCESS_CTX       ProcessCtx,
    IN  PFILE_OBJECT            SocketFile,
    OUT PLIST_ENTRY             IrpList
    )
/*++

Routine Description:

    Cleans up all IRPs associated with a socket file object from the request
    queue

Arguments:
    ProcessCtx  - process context to which queue belongs
    SocketFile  - socket file object for which to remove requests
    IrpList     - list head to hold the IRPs removed from the queue

Return Value:
    None
--*/
{
    KIRQL               oldIRQL;
    PLIST_ENTRY         entry;
	PIFSL_QUEUE			queue = &ProcessCtx->RequestQueue;

    KeAcquireSpinLock (&queue->Lock, &oldIRQL);
    entry = queue->ListHead.Flink;
    while (entry!=&queue->ListHead) {
        PIRP    irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (irp);

        entry = entry->Flink;
        if (irpSp->FileObject==SocketFile) {
            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
            irp->Tail.Overlay.IfslRequestQueue = NULL;
            InsertTailList (IrpList, &irp->Tail.Overlay.ListEntry);
        }
    }
    KeReleaseSpinLock (&queue->Lock, oldIRQL);
}

VOID
QueuedCancelRoutine (
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			Irp
    )
/*++

Routine Description:

    Driver cancel routine for socket request waiting in the queue
    to be reported to user mode DLL.

Arguments:
    DeviceObject - WS2IFSL device object
    Irp          - Irp to be cancelled

Return Value:
    None
--*/
{
    PIO_STACK_LOCATION      irpSp;
    PIFSL_SOCKET_CTX        SocketCtx;
    PIFSL_PROCESS_CTX       ProcessCtx;

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    SocketCtx = irpSp->FileObject->FsContext;
    ProcessCtx = SocketCtx->ProcessRef->FsContext;

    WsProcessPrint (ProcessCtx, DBG_QUEUE,
              ("WS2IFSL-%04lx CancelQueuedRequest: Socket %p , Irp %p\n",
              ProcessCtx->UniqueId,
              irpSp->FileObject, Irp));
    KeAcquireSpinLockAtDpcLevel (&ProcessCtx->RequestQueue.Lock);
    if (Irp->Tail.Overlay.IfslRequestQueue!=NULL) {
        ASSERT (Irp->Tail.Overlay.IfslRequestQueue==&ProcessCtx->RequestQueue);
		//
		// Request was in the queue, remove and cancel it here
		//
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
        Irp->Tail.Overlay.IfslRequestQueue = NULL;
        KeReleaseSpinLockFromDpcLevel (&ProcessCtx->RequestQueue.Lock);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        CompleteSocketIrp (Irp);
    }
    else {
		//
		// Request was not in the queue, whoever removed should note the
		// cancel flag and properly deal with it
		//
        KeReleaseSpinLockFromDpcLevel (&ProcessCtx->RequestQueue.Lock);
        IoReleaseCancelSpinLock (Irp->CancelIrql);
        //
        // Don't touch IRP after this as we do not own it anymore
        //
    }
}

VOID
InitializeCancelQueue (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PKTHREAD             ApcThread,
    IN KPROCESSOR_MODE      ApcMode,
    IN PKNORMAL_ROUTINE     ApcRoutine,
    IN PVOID                ApcContext
    )
/*++

Routine Description:

    Initializes cancel queue object

Arguments:
    ProcessCtx   - process context to which queue belongs
    ApcThread    - thread to which to queue APC requests for processing
    ApcMode      - mode of the caller (should be user)
    ApcRoutine   - routine that processes requests
    ApcContext   - context to pass to the routine in addition to request
                    parameters

Return Value:
    None
--*/
{
	PAGED_CODE ();

    InitializeListHead (&ProcessCtx->CancelQueue.ListHead);
    ProcessCtx->CancelQueue.Busy = FALSE;
    KeInitializeSpinLock (&ProcessCtx->CancelQueue.Lock);
    KeInitializeApc (&ProcessCtx->CancelQueue.Apc,
                        ApcThread,
                        OriginalApcEnvironment,
                        QueueKernelRoutine,
                        CancelRundownRoutine,
                        ApcRoutine,
                        ApcMode,
                        ApcContext);
}



VOID
QueueCancel (
    IN PIFSL_PROCESS_CTX    ProcessCtx,
    IN PIFSL_CANCEL_CTX     CancelCtx
    )
/*++

Routine Description:

    Queues cancel request to IFSL cancel queue and signals to user mode DLL
    to start processing if it is not busy already.

Arguments:
    ProcessCtx  - process context in which to queue
    CancelCtx   - request to be queued

Return Value:
    None

--*/
{
    KIRQL                   oldIRQL;
	PIFSL_QUEUE				queue = &ProcessCtx->CancelQueue;
    
    KeAcquireSpinLock (&queue->Lock, &oldIRQL);
    InsertTailList (&queue->ListHead, &CancelCtx->ListEntry);
    ASSERT (CancelCtx->ListEntry.Flink != NULL);
    if (!queue->Busy) {
		ASSERT (queue->ListHead.Flink==&CancelCtx->ListEntry);
        SignalCancel (ProcessCtx);
        ASSERT (ProcessCtx->CancelQueue.Busy);
    }
    KeReleaseSpinLock (&queue->Lock, oldIRQL);

} // QueueCancel


PIFSL_CANCEL_CTX
DequeueCancel (
    PIFSL_PROCESS_CTX   ProcessCtx,
    ULONG               UniqueId,
    BOOLEAN             *more
    )
/*++

Routine Description:

    Removes cancel request from IFSL cancel queue.

Arguments:
    ProcessCtx  - process context from which to remove
    UniqueId    - unique cancel request id
    more        - set to TRUE if there are more requests in the queue

Return Value:
    CTX         - pointer to cancel request context
    NULL        - the request was not in the queue

--*/
{
    KIRQL               oldIRQL;
    PIFSL_CANCEL_CTX    cancelCtx;
    PIFSL_QUEUE         queue = &ProcessCtx->CancelQueue;


    KeAcquireSpinLock (&queue->Lock, &oldIRQL);
    cancelCtx = CONTAINING_RECORD (
                        queue->ListHead.Flink,
                        IFSL_CANCEL_CTX,
                        ListEntry
                        );
    if (!IsListEmpty (&queue->ListHead)
            && (cancelCtx->UniqueId==UniqueId)) {
		//
		// Queue is not empty and first request matches passed in parameters,
		// dequeue and return it
		//

		ASSERT (queue->Busy);
        
		RemoveEntryList (&cancelCtx->ListEntry);
        cancelCtx->ListEntry.Flink = NULL;
    }
    else
        cancelCtx = NULL;

    if (IsListEmpty (&queue->ListHead)) {
		//
		// Queue is now empty, change its state, so that new request knows to
		// signal to user mode DLL
		//
        queue->Busy = FALSE;
    }
    else {
		//
		// There is another request pending, signal it now
		//
        SignalCancel (ProcessCtx);
        ASSERT (queue->Busy);
    }
	//
	// Hint the caller that we just signalled, so it does not have to wait on event
	//
    *more = queue->Busy;

    KeReleaseSpinLock (&queue->Lock, oldIRQL);
    return cancelCtx;
}


VOID
SignalCancel (
	IN PIFSL_PROCESS_CTX		ProcessCtx
	)
/*++

Routine Description:

    Fills request parameters & signals user mode DLL to process the request

Arguments:
    ProcessCtx   - our context for the process which cancel request belongs to

Return Value:
    None

Note:
	SHOULD ONLY BE CALLED WITH QUEUE SPINLOCK HELD

--*/
{
    PIFSL_CANCEL_CTX        cancelCtx;
    PIFSL_SOCKET_CTX        SocketCtx;

    ASSERT (!IsListEmpty (&ProcessCtx->CancelQueue.ListHead));

    ProcessCtx->CancelQueue.Busy = TRUE;

    cancelCtx = CONTAINING_RECORD (
                        ProcessCtx->CancelQueue.ListHead.Flink,
                        IFSL_CANCEL_CTX,
                        ListEntry
                        );
    SocketCtx = cancelCtx->SocketFile->FsContext;

    if (KeInsertQueueApc (&ProcessCtx->CancelQueue.Apc,
                                UlongToPtr(cancelCtx->UniqueId),
                                SocketCtx->DllContext,
                                IO_NETWORK_INCREMENT)) {
        WsProcessPrint (ProcessCtx, DBG_QUEUE,
            ("WS2IFSL-%04lx SignalCancel: Context %p on socket %p (h %p).\n",
             ProcessCtx->UniqueId,
             cancelCtx, cancelCtx->SocketFile, SocketCtx->DllContext));
    }
    else {
        //
        // APC queing failed, cancel all outstanding requests.
        //
        FlushCancelQueue (&ProcessCtx->CancelQueue);
    }

} // SignalCancel

VOID
FlushCancelQueue (
    PIFSL_QUEUE Queue
    )
/*++

Routine Description:

    Flushes and frees entries in the cancel queue
Arguments:
    Queue   - request queue to flush
Return Value:
    None
Note:
	SHOULD ONLY BE CALLED WITH QUEUE SPINLOCK HELD
--*/
{
    while (!IsListEmpty (&Queue->ListHead)) {
        PIFSL_CANCEL_CTX cancelCtx = CONTAINING_RECORD (
                        Queue->ListHead.Flink,
                        IFSL_CANCEL_CTX,
                        ListEntry
                        );
        RemoveEntryList (&cancelCtx->ListEntry);
        cancelCtx->ListEntry.Flink = NULL;
        FreeSocketCancel (cancelCtx);
    }
}


VOID
CancelRundownRoutine (
    IN struct _KAPC *Apc
    )
/*++

Routine Description:

    APC rundown routine for cancel queue APC
    Flushes the queue and marks it as not busy so new
    request fail immediately as well.
Arguments:
    APC     - cancel queue APC structure
Return Value:
    None
--*/
{
    PIFSL_QUEUE Queue;
    KIRQL       oldIrql;

    Queue = CONTAINING_RECORD (Apc, IFSL_QUEUE, Apc);
    KeAcquireSpinLock (&Queue->Lock, &oldIrql);
    Queue->Busy = FALSE;
    FlushCancelQueue (Queue);
    KeReleaseSpinLock (&Queue->Lock, oldIrql);
}


BOOLEAN
RemoveQueuedCancel (
    PIFSL_PROCESS_CTX   ProcessCtx,
    PIFSL_CANCEL_CTX    CancelCtx
    )
/*++

Routine Description:

    Remove cancel request from the cancel queue if it is there

Arguments:
    ProcessCtx  - process context to which queue belongs
    CancelCtx   - request to remove

Return Value:
    None
--*/
{
    KIRQL       oldIRQL;
    BOOLEAN     res;


    // Acquire queue lock
    KeAcquireSpinLock (&ProcessCtx->CancelQueue.Lock, &oldIRQL);
    res = (CancelCtx->ListEntry.Flink!=NULL);
    if (res) {
        RemoveEntryList (&CancelCtx->ListEntry);
        CancelCtx->ListEntry.Flink = NULL;
    }
    KeReleaseSpinLock (&ProcessCtx->CancelQueue.Lock, oldIRQL);
    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\testifsl.c ===
#include <nt.h>
#include <stdio.h>
#include <string.h>

#include "ws2ifsl.h"

HANDLE              ApcThreadHdl;
HANDLE              ProcessFile;

char                TestString[]="WS2IFSL";


DWORD WINAPI
ApcThread (
    PVOID   param
    );

VOID CALLBACK
ExitThreadApc (
    DWORD   param
    );

VOID 
Ws2ifslApc (
    IN PWS2IFSL_APC_REQUEST         Request,
    IN PVOID                        RequestCtx,
    IN PVOID                        SocketCtx
    );


int _cdecl
main (
    int     argc,
    char    *argv[]
    ) {
    UCHAR                       fullEaBuffer[FIELD_OFFSET(FILE_FULL_EA_INFORMATION,
                                            EaName[WS2IFSL_PROCESS_EA_NAME_LENGTH+1]);
    PFILE_FULL_EA_INFORMATION   fileEa;
    OBJECT_ATTRIBUTES           fileAttr;
    UNICODE_STRING              fileName;
    NTSTATUS                    status;
    DWORD                       apcThreadId;
    HANDLE                      hEvent;
    DWORD                       rc;
    BOOL                        res;

    hEvent = CreateEvent (NULL, TRUE, FALSE, NULL); // manual reset event
    if (hEvent==NULL) {
        printf ("Could not create event.\n");
        return 1;
    }

    RtlInitUnicodeString (fileName, WS2IFSL_DEVICE_NAME);
    InitializeObjectAttributes (&fileAttr,
                        fileName,
                        0,                  // Attributes
                        NULL,               // Root directory
                        NULL);              // Security descriptor
    fileEa = (PPFILE_FULL_EA_INFORMATION)fullEaBuffer;
    fileEa->NextOffset = 0;
    fileEa->Flags = 0;
    fileEa->EaNameLength = WS2IFSL_PROCESS_EA_NAME_LENGTH;
    fileEa->EaValueLength = 0;
    strcpy (fileEa->EaName, WS2IFSL_PROCESS_EA_NAME);

    status = NtCreateFile (&ProcessFile,
                         FILE_ALL_ACCESS,
                         fileAttr,
                         &ioStatus,
                         NULL,              // Allocation size
                         FILE_ATTRIBUTE_NORMAL,
                         0,                 // ShareAccess
                         FILE_OPEN_IF,      // Create disposition
                         0,                 // Create options
                         fullEaBuffer,
                         sizeof (fullEaBuffer));
    if (NT_SUCCESS (status)) {
        printf ("Created process file, handle: %lx.\n", ProcessFile);


        ApcThreadHdl = CreateThread (NULL,
                                    0,
                                    ApcThread,
                                    hEvent,
                                    0,
                                    &apcThreadId);
        if (ApcThreadHdl!=NULL) {
            rc = WaitForSingleObject (hEvent, INFINITE);
            if (rc==WAIT_OBJECT_0) {
                HANDLE              socketFile;
                HANDLE              hCompletion;
                char                TestBuffer[sizeof (TestString)];
                DWORD               count, key;
                OVERLAPPED          readOVLP, writeOVLP, ctrlOVLP;
                POVERLAPPED         ovlp;
                WS2IFSL_SOCKET_CTX  socketCtx;

                fileEa = (PPFILE_FULL_EA_INFORMATION)fullEaBuffer;
                fileEa->NextOffset = 0;
                fileEa->Flags = 0;
                fileEa->EaNameLength = WS2IFSL_SOCKET_EA_NAME_LENGTH;
                fileEa->EaValueLength = 0;
                strcpy (fileEa->EaName, WS2IFSL_SOCKET_EA_NAME);

                status = NtCreateFile (&socketFile,
                                     FILE_ALL_ACCESS,
                                     fileAttr,
                                     &ioStatus,
                                     NULL,              // Allocation size
                                     FILE_ATTRIBUTE_NORMAL,
                                     0,                 // ShareAccess
                                     FILE_OPEN_IF,      // Create disposition
                                     0,                 // Create options
                                     fullEaBuffer,
                                     sizeof (fullEaBuffer));
                if (NT_SUCCESS (status)) {
                    printf ("Created socket file, handle:%lx\n", socketFile);
                    socketCtx.SocketCtx = socketFile;
                    socketCtx.ProcessFile = ProcessFile;
                    res = DeviceIoControl (socketFile,
                                    IOCTL_WS2IFSL_SET_SOCKET_CONTEXT,
                                    &socketCtx,
                                    sizeof (socketCtx),
                                    NULL,
                                    0,
                                    &count,
                                    NULL);
                    if (res) {
                        hCompletion = CreateIoCompletionPort (socketFile,
                                            NULL,
                                            1,
                                            0);
                        if (hCompletion!=NULL) {
                            memset (TestBuffer, 0, sizeof (TestBuffer));
                            readOVLP.hEvent = NULL;
                            res = ReadFile (socketFile,
                                                TestBuffer,
                                                sizeof (TestBuffer),
                                                &count,
                                                &readOVLP);
                            if (res || (GetLastError ()==ERROR_IO_PENDING)) {
                                writeOVLP.hEvent = NULL;
                                res = WriteFile (socketFile,
                                                    TestString,
                                                    sizeof (TestString),
                                                    &count,
                                                    &writeOVLP);
                                if (res || (GetLastError ()==ERROR_IO_PENDING)) {
                                    ctrlOVLP.Internal = STATUS_BUFFER_OVERFLOW;
                                    ctrlOVLP.InternalHigh = 10;
                                    ctrlOVLP.hEvent = NULL;
                                    res = DeviceIoControl (socketFile,
                                                    IOCTL_WS2IFSL_COMPLETE_REQUEST,
                                                    &ctrlOVLP,
                                                    sizeof (IO_STATUS_BLOCK),
                                                    NULL,
                                                    0,
                                                    &count,
                                                    NULL);
                                    do {
                                        res = GetQueuedCompletionStatus (hCompletion,
                                                &count,
                                                &key,
                                                &ovlp,
                                                INFINITE);
                                        if (ovlp!=NULL) {
                                            if (ovlp==&readOVLP) {
                                                printf ("Read completed,"
                                                        "key: %ld, error: %ld, count: %ld, string: %ls.\n",
                                                        key,
                                                        res ? 0 : GetLastError (),
                                                        count,
                                                        TestBuffer);
                                                done |= 1;
                                            }
                                            else if (ovlp==&writeOVLP) {
                                                printf ("Write completed,"
                                                        "key:%ld, error: %ld, count: %ld.\n",
                                                        key,
                                                        res ? 0 : GetLastError (),
                                                        count);
                                                done |= 2;
                                            }
                                            else if (ovlp==&ctrlOVLP) {
                                                printf ("Control completed,"
                                                        "key:%ld, error: %ld, count: %ld.\n",
                                                        key,
                                                        res ? 0 : GetLastError (),
                                                        count);
                                                done |= 4;
                                            }
                                        }
                                        else {
                                            prinf ("GetQueuedCompletionStatus failed, error %ld.\n",
                                                    GetLastError ());
                                            break;
                                        }
                                    }
                                    while (done!=7);
                                }
                                else {
                                    printf ("Write failed, error: %ld.\n", GetLastError ());
                                }
                            }
                            else {
                                printf ("Read failed, error: %ld.\n", GetLastError ());
                            }
                            CloseHandle (hCompletion);
                        }
                        else {
                            printf ("Could not create completion port, error %ld.\n",
                                        GetLastError ());
                        }
                    }
                    else {
                        printf ("IOCTL_WS2IFSL_SET_SOCKET_CONTEXT failed, error: %ld.\n",
                                    GetLastError ());
                    }
                    
                    NtClose (socketFile);

                }
                else {
                    printf ("Could not create socket file, status:%lx\n", status);
                }

            }
            else {
                printf ("Wait for event failed, rc=%lx, error=%ld.\n",
                                rc, GetLastError ());
            }

            QueueUserAPC (ExitThreadApc, ApcThreadHdl, 0);
            WaitForSingleObject (ApcThreadHdl, INFINITE);
            CloseHandle (ApcThreadHdl);
        }
        else {
            printf ("Could not create thread.\n");
        }
        NtClose (ProcessFile);
    }
    CloseHandle (hEvent);
}


DWORD WINAPI
ApcThread (
    PVOID   param
    ) {
    WS2IFSL_APC_REQUEST     ApcRequest;
    WS2IFSL_THREAD_CTX      threadCtx;
    HANDLE                  hEvent = (HANDLE)param;
    BOOL                    res;
    OVERLAPPED              ovlp;

    threadCtx.ApcThreadHdl = ApcThreadHdl;
    threadCtx.ApcRoutine = Ws2ifslApc;
    ovlp.hEvent = NULL;
    res = DeviceIoControl (socketFile,
                    IOCTL_WS2IFSL_SET_THREAD_CONTEXT,
                    &threadCtx,
                    sizeof (threadCtx),
                    &ApcRequest,
                    sizeof (ApcRequest),
                    &count,
                    &ovlp);
    SetEvent (hEvent);
    if (!res && (GetLastError ()==ERROR_IO_PEDNING) {
        printf ("ApcThread: going into sleep mode....\n");
        while (TRUE)
            SleepEx (INIFINITE, TRUE);
    }
    else
        printf ("IOCTL_WS2IFSL_SET_THREAD_CONTEXT returned: %ld (status: %lx).\n",
                res ? 0 : GetLastError (), ovlp.Internal);
    return 0;
}

    
VOID CALLBACK
ExitThreadApc (
    DWORD   param
    ) {
    ExitThread (param);
}


typedef struct _PENDING_REQUEST {
    HANDLE      SocketCtx;
    PVOID       RequestCtx;
    PVOID       Buffer;
    ULONG       Length;
} PENDING_REQUEST, *PPENDING_REQUEST;

PPENDING_REQUEST    ReadRequest, WriteRequest;

                    
VOID 
Ws2ifslApc (
    IN PWS2IFSL_APC_REQUEST         Request,
    IN PVOID                        RequestCtx,
    IN PVOID                        SocketCtx
    ) {
    IO_STATUS_BLOCK IoStatus;
    DWORD           count;

    switch (Request->request) {
    case WS2IFSL_APC_REQUEST_READ:
        printf ("Processing read request, buffer: %lx, length: %ld, request %lx, context:%lx.",
                                Request->Read.Buffer,
                                Request->Read.Length,
                                RequestCtx,
                                SocketCtx);
        if (WriteRequest!=NULL) {
            if (WriteRequest->Length<=Request->Read.Length) {
                memcpy (Request->Read.Buffer, WriteRequest.Buffer, WriteRequest.Length);
                IoStatus.Status = STATUS_SUCCESS;
                IoStatus.Information = WriteRequest.Length;
            }
            else {
                memcpy (Request->Read.Buffer, WriteRequest.Buffer, Request.Read.Length);
                IoStatus.Status = STATUS_BUFFER_OVERFLOW;
                IoStatus.Information = Request.Read.Length;
            }
            res = DeviceIoControl ((HANDLE)WriteRequest->SocketCtx,
                            IOCTL_WS2IFSL_COMPLETE_REQUEST,
                            &IoStatus,
                            sizeof (IoStatus),
                            WriteRequest->RequestCtx,
                            0,
                            &count,
                            NULL);
            if (res)
                printf ("Completed write request, buffer %lx, count %ld, status %lx.\n",
                        WriteRequest->Buffer, IoStatus.Information, IoStatus.Status);
            else
                printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
            free (WriteRequest);
            WriteRequest = NULL;
        }
        else if (ReadRequest==NULL) {
            ReadRequest = (PPENDING_REQUEST)malloc (sizeof (PENDING_REQUEST));
            if (ReadRequest!=NULL) {
                ReadRequest->SocketCtx = SocketCtx;
                ReadRequest->RequestCtx = RequestCtx;
                ReadRequest->Buffer = Request->Read.Buffer;
                ReadRequest->Length = Request->Read.Length;
                printf ("Pended read request.\n");
                break;
            }
            else {
                IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                IoStatus.Information = 0;
            }
        }
        else {
            IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoStatus.Information = 0;
        }
        res = DeviceIoControl ((HANDLE)SocketCtx,
                        IOCTL_WS2IFSL_COMPLETE_REQUEST,
                        &IoStatus,
                        sizeof (IoStatus),
                        RequestCtx,
                        0,
                        &count,
                        NULL);
        if (res)
            printf ("Completed read request, buffer %lx, count %ld, status %lx.\n",
                    Request->Read.Buffer, IoStatus.Information, IoStatus.Status);
        else
            printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
        break;
    case WS2IFSL_APC_REQUEST_WRITE:
        printf ("Processing write request, buffer: %lx, length: %ld, request %lx, context:%lx.",
                                Request->Write.Buffer,
                                Request->Write.Length,
                                RequestCtx,
                                SocketCtx);
        if (ReadRequest!=NULL) {
            if (ReadRequest->Length>=Request->Write.Length) {
                memcpy (ReadRequest->Buffer, Request->Write.Buffer, Request->Write.Length);
                IoStatus.Status = STATUS_SUCCESS;
                IoStatus.Information = Request->Write.Length;
            }
            else {
                memcpy (ReadRequest->Buffer, Request->Write.Buffer, ReadRequest->Length);
                IoStatus.Status = STATUS_BUFFER_OVERFLOW;
                IoStatus.Information = ReadRequest->Length;
            }
            res = DeviceIoControl ((HANDLE)ReadRequest->SocketCtx,
                            IOCTL_WS2IFSL_COMPLETE_REQUEST,
                            &IoStatus,
                            sizeof (IoStatus),
                            ReadRequest->RequestCtx,
                            0,
                            &count,
                            NULL);
            if (res)
                printf ("Completed read request, buffer %lx, count %ld, status %lx.\n",
                        ReadRequest->Buffer, IoStatus.Information, IoStatus.Status);
            else
                printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
            free (ReadRequest);
            ReadRequest = NULL;
        }
        else if (WriteRequest==NULL) {
            WriteRequest = (PPENDING_REQUEST)malloc (sizeof (PENDING_REQUEST));
            if (WriteRequest!=NULL) {
                WriteRequest->SocketCtx = SocketCtx;
                WriteRequest->RequestCtx = RequestCtx;
                WriteRequest->Buffer = Request->Write.Buffer;
                WriteRequest->Length = Request->Write.Length;
                printf ("Pended write request.\n");
                break;
            }
            else {
                IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                IoStatus.Information = 0;
            }
        }
        else {
            IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoStatus.Information = 0;
        }
        res = DeviceIoControl ((HANDLE)SocketCtx,
                        IOCTL_WS2IFSL_COMPLETE_REQUEST,
                        &IoStatus,
                        sizeof (IoStatus),
                        RequestCtx,
                        0,
                        &count,
                        NULL);
        if (res)
            printf ("Completed write request, buffer %lx, count %ld, status %lx.\n",
                    Request->Read.Buffer, IoStatus.Information, IoStatus.Status);
        else
            printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
        break;
    case WS2IFSL_APC_REQUEST_CLOSE:
        printf ("Processing close request: %lx, context:%lx.",
                                RequestCtx,
                                SocketCtx);
        if ((WriteRequest!=NULL) && (WriteRequest->RequestCtx==RequestCtx)) {
            IoStatus.Status = STATUS_CANCELLED;
            IoStatus.Information = 0;
            res = DeviceIoControl ((HANDLE)WriteRequest->SocketCtx,
                            IOCTL_WS2IFSL_COMPLETE_REQUEST,
                            &IoStatus,
                            sizeof (IoStatus),
                            WriteRequest->RequestCtx,
                            0,
                            &count,
                            NULL);
            if (res)
                printf ("Completed write request, buffer %lx, count %ld, status %lx.\n",
                        WriteRequest->Buffer, IoStatus.Information, IoStatus.Status);
            else
                printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
        }

        if ((ReadRequest!=NULL) && (ReadRequest->RequestCtx==RequestCtx)) {
            IoStatus.Status = STATUS_CANCELLED;
            IoStatus.Information = 0;
            res = DeviceIoControl ((HANDLE)ReadRequest->SocketCtx,
                            IOCTL_WS2IFSL_COMPLETE_REQUEST,
                            &IoStatus,
                            sizeof (IoStatus),
                            ReadRequest->RequestCtx,
                            0,
                            &count,
                            NULL);
            if (res)
                printf ("Completed read request, buffer %lx, count %ld, status %lx.\n",
                        ReadRequest->Buffer, IoStatus.Information, IoStatus.Status);
            else
                printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
        }
        IoStatus.Status = STATUS_SUCCESS;
        IoStatus.Information = 0;
        res = DeviceIoControl ((HANDLE)SocketCtx,
                        IOCTL_WS2IFSL_COMPLETE_REQUEST,
                        &IoStatus,
                        sizeof (IoStatus),
                        RequestCtx,
                        0,
                        &count,
                        NULL);
        if (res)
            printf ("Completed close request, status %lx.\n", IoStatus.Status);
        else
            printf ("IOCTL_WS2IFSL_COMPLETE_REQUEST failed, error %ld\n", GetLastError ());
       break;
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\ws2ifslp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    WS2IFSLP.H

Abstract:

    This module defines private constants and data structures 
    for Winsock2 IFS transport layer driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

    Vadim Eydelman (VadimE)    Oct-1997, rewrite to properly handle IRP
                                        cancellation
--*/

// Pool tags
#define PROCESS_FILE_CONTEXT_TAG        'P2sW'
#define SOCKET_FILE_CONTEXT_TAG         'S2sW'
#define CANCEL_CTX_TAG                  'C2sW'

// File EAName tags
#define SOCKET_FILE_EANAME_TAG          'kcoS'
#define PROCESS_FILE_EANAME_TAG         'corP'

// Macro to get the code back from IOCTL
#define WS2IFSL_IOCTL_FUNCTION(File,Ioctl)          \
            (IoGetFunctionCodeFromCtlCode(Ioctl)    \
                - WS2IFSL_IOCTL_##File##_BASE)

typedef struct _IFSL_CANCEL_CTX {
    LIST_ENTRY              ListEntry;
    PFILE_OBJECT            SocketFile;
    ULONG                   UniqueId;
} IFSL_CANCEL_CTX, *PIFSL_CANCEL_CTX;

typedef struct _IFSL_QUEUE {
    LIST_ENTRY              ListHead;
    BOOLEAN                 Busy;
    KSPIN_LOCK              Lock;
    KAPC                    Apc;
} IFSL_QUEUE, *PIFSL_QUEUE;

// Context (FsContext field of the NT file object) associated with the
// file opened by WS2IFSL DLL on per process basis.
typedef struct _IFSL_PROCESS_CTX {
	ULONG				    EANameTag;  // 'Proc' - first four bytes of
                                        // extended attribute name for this
                                        // type of file
	HANDLE				    UniqueId;   // unique identifier of the process 
                                        // (read from UniqueProcessID field of
                                        // the EPROCESS structure)
    IFSL_QUEUE              RequestQueue;// queue of requests

    IFSL_QUEUE              CancelQueue;// queue of cancel requests
    ULONG                   CancelId;   // Used to generate IDs for
                                        // each cancel request in the process.
                                        // Combined with cancel request pointer 
                                        // itself allows to match requests completed by
                                        // user mode DLL with pending ones
#if DBG
    ULONG               DbgLevel;
#endif
} IFSL_PROCESS_CTX, *PIFSL_PROCESS_CTX;


// Context (FsContext field of the NT file object) associated with
// file opened by WS2IFSL DLL for each socket.
typedef struct _IFSL_SOCKET_CTX {
	ULONG					EANameTag;  // 'Sock' - first four bytes of
                                        // extended attribute name for this
                                        // type of file
	PVOID				    DllContext; // Context maintained for WS2IFSL DLL
	PFILE_OBJECT		    ProcessRef; // Pointer to process file object
    LONG                    IrpId;      // Used to generate IDs for
                                        // each IRP on the socket. Combined
                                        // with IRP pointer itself allows
                                        // to match requests completed by
                                        // user mode DLL with pending IRPs
    LIST_ENTRY              ProcessedIrps; // List of request being processed by
                                        // WS2IFSL DLL in APC thread
    KSPIN_LOCK              SpinLock;   // Protects requests in the list
                                        // above as well as process reference
    PIFSL_CANCEL_CTX        CancelCtx;  // Context to pass cancel request
                                        // to user mode DLL
} IFSL_SOCKET_CTX, *PIFSL_SOCKET_CTX;
#define GET_SOCKET_PROCESSID(ctx) \
            (((PIFSL_PROCESS_CTX)((ctx)->ProcessRef->FsContext))->UniqueId)

//
// Driver context field usage macros
//
#define IfslRequestId       DriverContext[0]    // Request's unique id
#define IfslRequestQueue    DriverContext[1]    // Queue if inserted, NULL othw
#define IfslRequestFlags    DriverContext[2]    // Request specific flags
#define IfslAddressLenPtr   DriverContext[3]    // Address length pointer

// Irp stack location fields usage macros
#define IfslAddressBuffer   Type3InputBuffer    // Source address
#define IfslAddressLength   InputBufferLength   // Source address length
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2help\ws2ifsl\socket.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    socket.h

Abstract:

    This module contains declarations of functions and globals
    for socket file object implemetation in ws2ifsl.sys driver.

Author:

    Vadim Eydelman (VadimE)    Dec-1996

Revision History:

--*/

// Socket file device IO control function pointer
typedef
VOID                                        // Result is returned via IoStatus
(*PSOCKET_DEVICE_CONTROL) (
    IN PFILE_OBJECT     SocketFile,         // Socket file on which to operate
    IN KPROCESSOR_MODE  RequestorMode,      // Mode of the caller
    IN PVOID            InputBuffer,        // Input buffer pointer
    IN ULONG            InputBufferLength,  // Size of the input buffer
    OUT PVOID           OutputBuffer,       // Output buffer pointer
    IN ULONG            OutputBufferLength, // Size of output buffer
    OUT PIO_STATUS_BLOCK IoStatus           // IO status information block
    );

PSOCKET_DEVICE_CONTROL SocketIoControlMap[2];
ULONG                  SocketIoctlCodeMap[2];

NTSTATUS
CreateSocketFile (
    IN PFILE_OBJECT                 SocketFile,
    IN KPROCESSOR_MODE              RequestorMode,
    IN PFILE_FULL_EA_INFORMATION    eaInfo
    );

NTSTATUS
CleanupSocketFile (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    );

VOID
CloseSocketFile (
    IN PFILE_OBJECT SocketFile
    );

NTSTATUS
DoSocketReadWrite (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    );

NTSTATUS
DoSocketAfdIoctl (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    );

VOID
FreeSocketCancel (
    PIFSL_CANCEL_CTX    CancelCtx
    );

VOID
CompleteSocketIrp (
    PIRP        Irp
    );

BOOLEAN
InsertProcessedRequest (
    PIFSL_SOCKET_CTX    SocketCtx,
    PIRP                Irp
    );

VOID
CompleteDrvRequest (
    IN PFILE_OBJECT         SocketFile,
    IN PWS2IFSL_CMPL_PARAMS Params,
    IN PVOID                OutputBuffer,
    IN ULONG                OutputBufferLength,
    OUT PIO_STATUS_BLOCK    IoStatus
    );

NTSTATUS
SocketPnPTargetQuery (
    IN PFILE_OBJECT SocketFile,
    IN PIRP         Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\autodial.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    autodial.h

Abstract:

    This module contains definitions for
    Autodial support in Winsock.

Author:

    Anthony Discolo (adiscolo)    15-May-1996

Revision History:

--*/

VOID
InitializeAutodial(VOID);

VOID
UninitializeAutodial(VOID);

BOOL
WSAttemptAutodialAddr(
    IN const struct sockaddr FAR *name,
    IN int namelen
    );

BOOL
WSAttemptAutodialName(
    IN const LPWSAQUERYSETW lpqsRestrictions
    );

VOID
WSNoteSuccessfulHostentLookup(
    IN const char FAR *name,
    IN const ULONG ipaddr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\classfwd.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    classfwd.h

Abstract:

    This  module  contains "forward" declarations for major types used commonly
    within the WinSock 2 DLL.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 08-July-1995

Notes:

    $Revision:   1.9  $

    $Modtime:   08 Mar 1996 04:52:58  $

Revision History:

    most-recent-revision-date email-name
        description

    25-July-1995 dirk@mink.intel.com
        Added forward definintions for DCATALOG

    07-09-1995  drewsxpa@ashland.intel.com
        Completed  first  complete  version with clean compile and released for
        subsequent implementation.

    07-08-1995  drewsxpa@ashland.intel.com
        Original version

--*/

#ifndef _CLASSFWD_
#define _CLASSFWD_

#include <windows.h>

class DTHREAD;
typedef DTHREAD FAR * PDTHREAD;

class DPROCESS;
typedef DPROCESS FAR * PDPROCESS;

class DSOCKET;
typedef DSOCKET FAR * PDSOCKET;

class DPROVIDER;
typedef DPROVIDER FAR * PDPROVIDER;

class PROTO_CATALOG_ITEM;
typedef PROTO_CATALOG_ITEM  FAR * PPROTO_CATALOG_ITEM;

class DCATALOG;
typedef DCATALOG FAR * PDCATALOG;

class NSPROVIDER;
typedef NSPROVIDER FAR * PNSPROVIDER;

class NSPSTATE;
typedef NSPSTATE FAR * PNSPSTATE;

class NSCATALOG;
typedef NSCATALOG FAR * PNSCATALOG;

class NSCATALOGENTRY;
typedef NSCATALOGENTRY FAR * PNSCATALOGENTRY;

class NSQUERY;
typedef NSQUERY FAR * PNSQUERY;

class NSPROVIDERSTATE;
typedef NSPROVIDERSTATE FAR * PNSPROVIDERSTATE;


#endif  // _CLASSFWD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\async.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Async.h

Abstract:

    Global definitions for the WinSock asynchronous processing thread.

Author:

    Keith Moore (keithmo)        18-Jun-1992

Revision History:

--*/


#ifndef _ASYNC_H_
#define _ASYNC_H_


//
// Context block.
//

typedef struct _WINSOCK_CONTEXT_BLOCK {

    LIST_ENTRY AsyncThreadQueueListEntry;
    HANDLE TaskHandle;
    DWORD OpCode;

    union {

        struct {
            HWND hWnd;
            unsigned int wMsg;
            PCHAR Filter;
            int Length;
            int Type;
            PCHAR Buffer;
            int BufferLength;
        } AsyncGetHost;

        struct {
            HWND hWnd;
            unsigned int wMsg;
            PCHAR Filter;
            PCHAR Buffer;
            int BufferLength;
        } AsyncGetProto;

        struct {
            HWND hWnd;
            unsigned int wMsg;
            PCHAR Filter;
            PCHAR Protocol;
            PCHAR Buffer;
            int BufferLength;
        } AsyncGetServ;

    } Overlay;

} WINSOCK_CONTEXT_BLOCK, *PWINSOCK_CONTEXT_BLOCK;

//
// Opcodes for processing by the winsock asynchronous processing
// thread.
//

#define WS_OPCODE_GET_HOST_BY_ADDR    0x01
#define WS_OPCODE_GET_HOST_BY_NAME    0x02
#define WS_OPCODE_GET_PROTO_BY_NUMBER 0x03
#define WS_OPCODE_GET_PROTO_BY_NAME   0x04
#define WS_OPCODE_GET_SERV_BY_PORT    0x05
#define WS_OPCODE_GET_SERV_BY_NAME    0x06


//
// Initialization/termination functions.
//

BOOL
SockAsyncGlobalInitialize(
    VOID
    );

VOID
SockAsyncGlobalTerminate(
    VOID
    );

BOOL
SockCheckAndInitAsyncThread(
    VOID
    );

VOID
SockTerminateAsyncThread(
    VOID
    );

BOOL
SockIsAsyncThreadInitialized (
    VOID
    );
//
// Work queue functions.
//

PWINSOCK_CONTEXT_BLOCK
SockAllocateContextBlock(
    DWORD AdditionalSpace
    );

VOID
SockFreeContextBlock(
    IN PWINSOCK_CONTEXT_BLOCK ContextBlock
    );

VOID
SockQueueRequestToAsyncThread(
    IN PWINSOCK_CONTEXT_BLOCK ContextBlock
    );

INT
SockCancelAsyncRequest(
    IN HANDLE TaskHandle
    );


#endif  // _ASYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\common\trace.c ===
/*/////////////////////////////////////////////////////////////////////////
//
// INTEL Corporation Proprietary Information
// Copyright (c) Intel Corporation
//
// This listing is supplied under the terms of a license aggreement
// with INTEL Corporation and may not be used, copied nor disclosed
// except in accordance with that agreement.
//
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
// $Workfile:   TRACE.C  $
// $Revision:   1.3  $
// $Modtime:   27 Nov 1995 08:38:08  $
//
//  DESCRIPTION:
// This file contains the output function for the tracing facility
// used in PII DLL
//////////////////////////////////////////////////////////////////
*/

/* Single Line Comments */
#pragma warning(disable: 4001)
// Disable some more benign warnings for compiling at warning level 4

// nonstandard extension used : nameless struct/union
#pragma warning(disable: 4201)

// nonstandard extension used : bit field types other than int
#pragma warning(disable: 4214)

// Note: Creating precompiled header
#pragma warning(disable: 4699)

// unreferenced inline function has been removed
#pragma warning(disable: 4514)

// unreferenced formal parameter
//#pragma warning(disable: 4100)

// 'type' differs in indirection to slightly different base
// types from 'other type'
#pragma warning(disable: 4057)

// named type definition in parentheses
#pragma warning(disable: 4115)

// nonstandard extension used : benign typedef redefinition
#pragma warning(disable: 4209)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <memory.h>
#include <stdio.h>
#include <stdarg.h>
#include <io.h>

/* because windows.h turns this one back on */
#pragma warning(disable: 4001)

#include "trace.h"
#include "osdef.h"

#ifdef TRACING

BOOL  InitMemoryBuffers(VOID);

LPSTR g_CurrentMessage=NULL;
CRITICAL_SECTION g_OutputRoutine;
int iTraceDestination=TRACE_TO_AUX;
char TraceFile[] = "trace.log";
DWORD debugLevel=DBG_ERR;
HANDLE g_OutputFile = NULL; // file descriptor for file output
BOOL g_LogOpened = FALSE; // have we opened the file for output
BOOL g_TraceInited = FALSE;



VOID
__cdecl
PrintDebugString(
                 char *Format,
                 ...
                 )
/*++
  Routine Description:

  This routine outputs a debug messages.  Debug messages are routed
  to a file or a debug window depnding on the value of a global
  variable defined in this module

  Arguments:

  Format - A "printf()" compatible format specification.

  ... - Additional arguments to "printf()" format specification.

  Returns:

  NONE

  --*/
{
    va_list ArgumentList; // argument list for varargs processing
    DWORD  BytesWritten;

    if (!g_TraceInited)
    {
        #define INIT_MUTEX_BASE_NAME  "WS2_32TraceMutex-"  
        HANDLE  InitMutex;
        CHAR    InitMutexName[sizeof(INIT_MUTEX_BASE_NAME)+8];
        // Generate a name unique for a process so we can't cross other processes.
        sprintf (InitMutexName, INIT_MUTEX_BASE_NAME "%8.8lx", GetCurrentProcessId());
        // Create the mutex to protect the rest of the init code
        InitMutex = CreateMutex(
                                NULL,  // Use default security attributes
                                FALSE, // We don't want automatic ownership
                                InitMutexName);
        if (!InitMutex)
        {
            // We failed to create the mutex there is nothign else we
            // can do so return.  This will cause the debug output to
            // be silently lost.
            return;
        } //if

        // Wait on mutex (just a little and bail if we can't get it)
        if (WaitForSingleObject( InitMutex, 10000)==WAIT_OBJECT_0) {

            // Check to see if init is still needed
            if (!g_TraceInited)
            {
                // Init the critical section to be used to protect the
                // output portion of this routine.
                __try {
                    InitializeCriticalSection( &g_OutputRoutine );
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    goto Release;
                }
                // allocate buffers to hold debug messages
                if (InitMemoryBuffers()) {
                    g_TraceInited = TRUE;
                } //if
                else {
                    DeleteCriticalSection ( &g_OutputRoutine );
                }
            Release:
                ;
            } //if

            // Signal the mutex
            ReleaseMutex(InitMutex);
        }
        // delete this threads handle to the mutex
        CloseHandle(InitMutex);

        // Bail out if we couldn't init memory buffers or critical section
        if (!g_TraceInited)
        {
            return;
        }
    }


    // Here is where all the heavy lifting starts
    EnterCriticalSection( &g_OutputRoutine );

    // print the user message to our buffer
    va_start(ArgumentList, Format);
    _vsnprintf(g_CurrentMessage, TRACE_OUTPUT_BUFFER_SIZE, Format, ArgumentList);
    va_end(ArgumentList);

    if (iTraceDestination == TRACE_TO_FILE)
    {
        if (!g_LogOpened)
        {
            g_OutputFile =
            CreateFile( TraceFile,
                        GENERIC_WRITE,     // open for writing
                        FILE_SHARE_WRITE,  // Share the file with others
                        NULL,              // default security
                        OPEN_ALWAYS,       // Use file if it exsits
                        FILE_ATTRIBUTE_NORMAL, // Use a normal file
                        NULL);             // No template

            if (g_OutputFile != INVALID_HANDLE_VALUE)
            {
                g_LogOpened = TRUE;
            } //if
        } //if

        if (g_LogOpened)
        {
            // Write the current message to the trace file
            WriteFile(g_OutputFile,
                      g_CurrentMessage,
                      lstrlen(g_CurrentMessage),
                      &BytesWritten,
                      NULL);

            // Flush debug output to file
            FlushFileBuffers( TraceFile );

        } //if
    }

    if( iTraceDestination == TRACE_TO_AUX)
    {
        // Send message to AUX device
        OutputDebugString(g_CurrentMessage);
    }
    LeaveCriticalSection( &g_OutputRoutine );
}




BOOL
InitMemoryBuffers(
                  VOID
                  )
/*++
  Routine Description:

  Initailizes the memory buffers used by this module.

  Arguments:

  NONE

  Returns:

  TRUE if all memory buffers are successfully created, Otherwise FALSE.

  --*/
{
    BOOL ReturnCode=FALSE;

    g_CurrentMessage = GlobalAlloc (GPTR, TRACE_OUTPUT_BUFFER_SIZE);
    if (g_CurrentMessage)
    {
        ZeroMemory( g_CurrentMessage, TRACE_OUTPUT_BUFFER_SIZE );
        ReturnCode=TRUE;
    } //if
    return(ReturnCode);
}

VOID
TraceCleanup (
    )
{
    if (g_LogOpened) {
        CloseHandle (g_OutputFile);
        g_OutputFile = NULL;
        g_LogOpened = FALSE;
    }

    if (g_TraceInited) {
        GlobalFree (g_CurrentMessage);
        g_CurrentMessage = NULL;
        DeleteCriticalSection (&g_OutputRoutine);
        g_TraceInited = FALSE;
    }
}

LONG
Ws2ExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionPointers,
    LPSTR SourceFile,
    LONG LineNumber
    )
{

    LPSTR fileName;
    DWORD i;

    //
    // Protect ourselves in case the process is totally messed up.
    //

    __try {

        //
        // Exceptions should never be thrown in a properly functioning
        // system, so this is bad. To ensure that someone will see this,
        // print to the debugger directly
        //


        fileName = strrchr( SourceFile, '\\' );

        if( fileName == NULL ) {
            fileName = SourceFile;
        } else {
            fileName++;
        }

        //
        // Whine about the exception.
        //

        PrintDebugString(
                "-| WS2_32 EXCEPTION: %08lx @ %p %d params, caught in %s:%d\n",
                            ExceptionPointers->ExceptionRecord->ExceptionCode,
                            ExceptionPointers->ExceptionRecord->ExceptionAddress,
                            ExceptionPointers->ExceptionRecord->NumberParameters,
                            fileName, LineNumber );
        if (ExceptionPointers->ExceptionRecord->NumberParameters) {
            PrintDebugString (
                "                     Params:"); 
            for (i=0; i<ExceptionPointers->ExceptionRecord->NumberParameters; i++) {
                PrintDebugString(" %p", ExceptionPointers->ExceptionRecord->ExceptionInformation[i]);
            }
            PrintDebugString ("\n");
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Not much we can do here...
        //

        ;
    }
    return EXCEPTION_EXECUTE_HANDLER;

}   // Ws2ExceptionFilter

LONG
Ws2ProviderExceptionFilter(
    LPEXCEPTION_POINTERS ExceptionPointers,
    LPSTR pFunc,
    LPWSTR pDll,
    LPWSTR pName,
    LPGUID pGuid
    )
/*++
  Routine Description:

    Special exception filter for exceptions in critical calls to provider DLLs,
    such as startup and cleanup.

  Arguments:

    Exception and provider information

  Returns:
    whatever lower-level exception handler returns with EXCEPTION_CONTINUE_SEARCH
    filtered out since exception handler cannot be bypassed with current logic
    in ws2_32.dll


  --*/
{
    LONG    result;

    //
    // Protect ourselves in case the process is totally messed up.
    //

    __try {
        PrintDebugString(
                "-| WS2_32 Unhandled Exception: %08lx @ %p, caught in %s of %ls"
                " (provider:%ls GUID:(%8.8x-%4.4x-%4.4x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x) |-\n",
                ExceptionPointers->ExceptionRecord->ExceptionCode,
                ExceptionPointers->ExceptionRecord->ExceptionAddress,
                pFunc, pDll, pName, pGuid->Data1, pGuid->Data2, pGuid->Data3,
                pGuid->Data4[0],pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
                pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],pGuid->Data4[7]
                );
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Not much we can do here...
        //

        ;
    }

    //
    // Try standard handler for unhanled exceptions.
    // This will bring in a popup or launch the debugger if
    // just in time debugging is enabled.
    //
    result = UnhandledExceptionFilter (ExceptionPointers);
    if (result==EXCEPTION_CONTINUE_SEARCH) {
        //
        // It did not work, force break-in if debugger is attached at all.
        //
        result = RtlUnhandledExceptionFilter (ExceptionPointers);
        if (result==EXCEPTION_CONTINUE_SEARCH) {
            //
            // No luck, handle the exception.
            //
            result = EXCEPTION_EXECUTE_HANDLER;
        }
    }
    return result;
}
#endif  // TRACING


#if DBG

VOID
WsAssert(
    LPVOID FailedAssertion,
    LPVOID FileName,
    ULONG LineNumber
    )
{

    PrintDebugString(
        "\n"
        "*** Assertion failed: %s\n"
        "*** Source file %s, line %lu\n\n",
        FailedAssertion,
        FileName,
        LineNumber
        );

    DebugBreak();

}   // WsAssert

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\dcatalog.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dcatalog.h

Abstract:

    This  module  contains  the  interface  to  the  catalog  of  protocol_info
    structures and their associated providers for the winsock2 DLL.

Author:

    Dirk Brandewie  dirk@mink.intel.com 25-JUL-1995

Notes:

    $Revision:   1.19  $

    $Modtime:   14 Feb 1996 10:40:22  $


Revision History:

    04-Oct-1995  keithmo@microsoft.com
        Added FindIFSProviderForSocket() to fully support sockets inherited
        by or duplicated into the current process.

    31-July-1995 drewsxpa@ashland.intel.com
        Moved catalog item class into a different file.

    27-July-1995 drewsxpa@ashland.intel.com
        Made  changes  to  reflect  the  decision  to make protocol_info be the
        primary identifiable and searchable item instead of provider.

    25-July-1995 dirk@mink.intel.com
        Initial revision.
--*/

#ifndef _DCATALOG_
#define _DCATALOG_

#include "winsock2.h"
#include <windows.h>
#include "classfwd.h"


typedef
BOOL
(* CATALOGITERATION) (
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    );
/*++

Routine Description:

    CATALOGITERATION  is  a place-holder for a function supplied by the client.
    The  function  is  called once for each PROTO_CATALOG_ITEM structure in the
    catalog while enumerating the catalog.  The client can stop the enumeration
    early by returning FALSE from the function.

    Note  that  the DPROVIDER associated with an enumerated DPROTO_CATALOG_ITEM
    may  be  NULL.   To retrieve DPROTO_CATALOG_ITEM structure that has had its
    DPROVIDER      loaded      and      initialized,      you      can      use
    GetCatalogItemFromCatalogEntryId.

Arguments:

    PassBack     - Supplies  to  the  client an uninterpreted, unmodified value
                   that  was  specified  by the client in the original function
                   that  requested  the  enumeration.   The client can use this
                   value  to  carry context between the requesting site and the
                   enumeration function.

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.

Return Value:

    TRUE  - The  enumeration  should continue with more iterations if there are
            more structures to enumerate.

    FALSE - The enumeration should stop with this as the last iteration even if
            there are more structures to enumerate.

--*/

class DCATALOG_ITEMS {
friend class DCATALOG;
    VOID
    UpdateProtocolList (
        PLIST_ENTRY new_list
        );

    LIST_ENTRY  m_protocol_list;
    // The head of the list of protocol catalog items

    ULONG m_num_items;
    // Number of items in this catalog.
};


class DCATALOG: private DCATALOG_ITEMS
{
public:

    DCATALOG();

    INT
    InitializeFromRegistry(
        IN  HKEY    ParentKey,
        IN  HANDLE  CatalogChangeEvent OPTIONAL
        );

#ifdef _WIN64
    INT
    InitializeFromRegistry32(
        IN  HKEY    ParentKey
    );

    INT
    InitializeFromRegistry64_32(
        IN  HKEY    ParentKey
    );

    VOID
    AppendCatalogItem32(
        IN  PPROTO_CATALOG_ITEM  CatalogItem
        );

    VOID
    RemoveCatalogItem32(
        IN  PPROTO_CATALOG_ITEM  CatalogItem
        );
#endif

    INT
    RefreshFromRegistry (
        IN  HANDLE  CatalogChangeEvent OPTIONAL
        );

    INT
    WriteToRegistry(
        );

    ~DCATALOG();

    VOID
    EnumerateCatalogItems(
        IN CATALOGITERATION  Iteration,
        IN PVOID             PassBack
        );

    INT
    GetCountedCatalogItemFromCatalogEntryId(
        IN  DWORD                     CatalogEntryId,
        OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
        );

    INT
    GetCountedCatalogItemFromAddressFamily(
        IN  INT af,
        OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
        );

    INT
    GetCountedCatalogItemFromAttributes(
        IN  INT   af,
        IN  INT   type,
        IN  INT   protocol,
        IN  DWORD StartAfterId OPTIONAL,
        OUT PPROTO_CATALOG_ITEM FAR * CatalogItem
        );

    DWORD
    AllocateCatalogEntryId(
        );

    VOID
    AppendCatalogItem(
        IN  PPROTO_CATALOG_ITEM  CatalogItem
        );

    VOID
    RemoveCatalogItem(
        IN  PPROTO_CATALOG_ITEM  CatalogItem
        );

    INT
    FindIFSProviderForSocket(
        SOCKET Socket
        );

    static
    LPSTR
    GetCurrentCatalogName(
        VOID
        );

private:

    VOID
    AcquireCatalogLock(
        VOID
        );

    VOID
    ReleaseCatalogLock(
        VOID
        );

    BOOL
    OpenCatalog(
        IN  HKEY   ParentKey
        );

    INT
    LoadProvider(
        IN PPROTO_CATALOG_ITEM CatalogEntry
        );

    PDPROVIDER
    FindAnotherProviderInstance(
        IN LPGUID ProviderId
        );

    ULONG m_serial_num;
    // The serial number of the catalog (changes every time catalog
    // is changed in the registry)

    ULONG m_next_id;
    // Next catalog id number to be assinged to newly installed provider

    HKEY m_reg_key;
    // Handle of the registry key under which catalog resides.
    // We keep it open so we can get notified whenever catalog
    // changes.

    CRITICAL_SECTION m_catalog_lock;
    // A critical section object protecting this class.

#ifdef _WIN64
    union {
        DCATALOG_ITEMS   *m_items32;
        LPCSTR           m_entries_name32;
    };
    static LPCSTR        sm_entries_name32;
#endif
};  // class dcatalog

inline
VOID
DCATALOG::AcquireCatalogLock(
    VOID
    )
{
    EnterCriticalSection( &m_catalog_lock );
}

inline
VOID
DCATALOG::ReleaseCatalogLock(
    VOID
    )
{
    LeaveCriticalSection( &m_catalog_lock );
}

#endif // _DCATALOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\dcatitem.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dcatitem.h

Abstract:

    This  file  contains the class definition for the PROTO_CATALOG_ITEM class.
    This  class  defines the interface to the entries that can be installed and
    retrieved in the protocol catalog.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 31-July-1995

Notes:

    $Revision:   1.7  $

    $Modtime:   12 Jan 1996 15:09:02  $

Revision History:

    most-recent-revision-date email-name
        description

    07-31-1995 drewsxpa@ashland.intel.com
        Created  original  version  from  definitions  separated  out  from the
        dcatalog module.

--*/

#ifndef _DCATITEM_
#define _DCATITEM_

#include "winsock2.h"
#include <windows.h>
#include "classfwd.h"


class PROTO_CATALOG_ITEM {
public:

    PROTO_CATALOG_ITEM();

    INT
    InitializeFromRegistry(
        IN  HKEY  ParentKey,
        IN  INT   SequenceNum
        );

    INT
    InitializeFromValues(
        IN  LPWSTR              LibraryPath,
        IN  LPWSAPROTOCOL_INFOW ProtoInfo
        );

    LPWSAPROTOCOL_INFOW
    GetProtocolInfo();

    LPGUID
    GetProviderId();

    LPWSTR
    GetLibraryPath();

    PDPROVIDER
    GetProvider();

    INT WriteToRegistry(
        IN  HKEY  ParentKey,
        IN  INT   SequenceNum
        );


    VOID
    Reference ();

    VOID
    Dereference ();

    bool operator== (const PROTO_CATALOG_ITEM& Item);

private:


    INT
    IoRegistry(
        IN  HKEY  EntryKey,
        IN  BOOL  IsRead
        );


    // Should never be called directly, but through dereferencing.
    ~PROTO_CATALOG_ITEM();

friend class DCATALOG;  // So it can access some of the private fields 
                        // and methods below.
friend class DCATALOG_ITEMS;  // So it can access some of the privat    e fields 
                        // and methods below.
    VOID
    SetProvider(
        IN  PDPROVIDER  Provider
        );

    LIST_ENTRY     m_CatalogLinkage;
    // Used  to  link  items  in  catalog.

    LONG        m_reference_count;
    // This object's reference count

    PDPROVIDER  m_Provider;
    // Pointer to the dprovider object attached to this catalog entry.

    WSAPROTOCOL_INFOW m_ProtoInfo;
    // The cataloged WSAPROTOCOL_INFOW structure.  This is typically used for
    // comparison  when  selecting  a  provider by address family, socket
    // type, etc.

    WCHAR m_LibraryPath[MAX_PATH];
    // Fully qualified path to the provider's DLL image.


};  // class PROTO_CATALOG_ITEM

inline
VOID
PROTO_CATALOG_ITEM::Reference () {
    //
    // Object is created with reference count of 1
    // and is destroyed whenever it gets back to 0.
    //
    assert (m_reference_count>0);
    InterlockedIncrement (&m_reference_count);
}


inline
VOID
PROTO_CATALOG_ITEM::Dereference () {
    assert (m_reference_count>0);
    if (InterlockedDecrement (&m_reference_count)==0)
        delete this;
}

inline
LPWSAPROTOCOL_INFOW
PROTO_CATALOG_ITEM::GetProtocolInfo()
/*++

Routine Description:

    This  procedure  retrieves a reference to the protocol info associated with
    the  catalog  item.   Note  that  the  reference is to storage owned by the
    catalog item.  It is the caller's responsibility to make sure the reference
    is no longer used after the catalog item is destroyed.

Arguments:

    None

Return Value:

    Returns a pointer to the associated protocol info.
--*/
{
    return(& m_ProtoInfo);
}  // GetProtocolInfo



inline
LPGUID
PROTO_CATALOG_ITEM::GetProviderId()
/*++

Routine Description:

    This procedure retrieves a the unique ID of the provider associated with
    the catalog item.

Arguments:

    None

Return Value:

    Returns the provider ID (a GUID).
--*/
{
    return &m_ProtoInfo.ProviderId;
}  // GetProviderId



inline
LPWSTR
PROTO_CATALOG_ITEM::GetLibraryPath()
/*++

Routine Description:

    This    procedure   retrieves   a   reference   to   the   zero-terminated,
    fully-qualified  path  of  the library that is the service provider for the
    protocol  associated  with the catalog item.  Note that the reference is to
    storage  owned  by  the catalog item.  It is the caller's responsibility to
    make  sure  the  reference  is  no  longer  used  after the catalog item is
    destroyed.

Arguments:

    None

Return Value:

    Returns a pointer to the library path string.
--*/
{
    assert(m_LibraryPath[0] != '\0');
    return(m_LibraryPath);
}  // GetLibraryPath

inline
PDPROVIDER
PROTO_CATALOG_ITEM::GetProvider()
/*++

Routine Description:

    This  procedure  retrieves  a  reference to the DPROVIDER associated with a
    catalog  entry.  Note that the reference may be NULL if no provider has yet
    been loaded for this protocol.

Arguments:

    None

Return Value:

    Returns  the  current provider reference, or NULL if there is no associated
    provider.
--*/
{
    return(m_Provider);
}  // GetProvider


inline
bool 
PROTO_CATALOG_ITEM::operator== (
    const PROTO_CATALOG_ITEM& Item
    )
{
    //
    // Do member by member comparison for protocol info structure and 
    // provider path.
    //
    return            
    //
    // Start with entry ID since these are unique for
    // each protocol info entry.
    //
           m_ProtoInfo.dwCatalogEntryId==Item.m_ProtoInfo.dwCatalogEntryId &&

    //
    // Rest is in the order it is layed out in the structure.
    //
           m_ProtoInfo.dwServiceFlags1==Item.m_ProtoInfo.dwServiceFlags1 &&
           m_ProtoInfo.dwServiceFlags2==Item.m_ProtoInfo.dwServiceFlags2 &&
           m_ProtoInfo.dwServiceFlags3==Item.m_ProtoInfo.dwServiceFlags3 &&
           m_ProtoInfo.dwServiceFlags4==Item.m_ProtoInfo.dwServiceFlags4 &&
           m_ProtoInfo.dwProviderFlags==Item.m_ProtoInfo.dwProviderFlags &&
           m_ProtoInfo.ProviderId==Item.m_ProtoInfo.ProviderId &&
           m_ProtoInfo.ProtocolChain.ChainLen==Item.m_ProtoInfo.ProtocolChain.ChainLen &&
           memcmp (m_ProtoInfo.ProtocolChain.ChainEntries,
                                Item.m_ProtoInfo.ProtocolChain.ChainEntries,
                                sizeof (m_ProtoInfo.ProtocolChain.ChainEntries[0])*
                                    m_ProtoInfo.ProtocolChain.ChainLen)==0 &&
           m_ProtoInfo.iVersion==Item.m_ProtoInfo.iVersion &&
           m_ProtoInfo.iAddressFamily==Item.m_ProtoInfo.iAddressFamily &&
           m_ProtoInfo.iMaxSockAddr==Item.m_ProtoInfo.iMaxSockAddr &&
           m_ProtoInfo.iMinSockAddr==Item.m_ProtoInfo.iMinSockAddr &&
           m_ProtoInfo.iSocketType==Item.m_ProtoInfo.iSocketType &&
           m_ProtoInfo.iProtocol==Item.m_ProtoInfo.iProtocol &&
           m_ProtoInfo.iProtocolMaxOffset==Item.m_ProtoInfo.iProtocolMaxOffset &&
           m_ProtoInfo.iNetworkByteOrder==Item.m_ProtoInfo.iNetworkByteOrder &&
           m_ProtoInfo.iSecurityScheme==Item.m_ProtoInfo.iSecurityScheme &&
           m_ProtoInfo.dwMessageSize==Item.m_ProtoInfo.dwMessageSize &&
           m_ProtoInfo.dwProviderReserved==Item.m_ProtoInfo.dwProviderReserved &&
           wcscmp (m_ProtoInfo.szProtocol, Item.m_ProtoInfo.szProtocol)==0 &&
           wcscmp (m_LibraryPath, Item.m_LibraryPath)==0;
}

#endif // _DCATITEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\getxbyy.h ===
/*++

    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.

Module Name:

    getxbyy.h

Abstract:

    This  module  takes  care  of  forwarding  the getxbyy functions off to the
    correct  alternate  or  fallback  getxbyy  provider.   The only interesting
    internal aspect of the interface to this module is a pair of initialization
    and  shutdown  functions  that  must  be  called  when the WinSock 2 DLL is
    initialized and shut down.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 12-20-1995

Notes:

    $Revision:   1.1  $

    $Modtime:   12 Jan 1996 15:09:00  $

Revision History:

    12-20-1995 drewsxpa@ashland.intel.com
        Created
--*/

#ifndef _GETXBYY_
#define _GETXBYY_

//
// Obsolete.
//

#endif // _GETXBYY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\nscatalo.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    nscatalo.h

Abstract:

    This module contains the interface to the catalog of name space providers
    for the winsock2 DLL.

Author:

    Dirk Brandewie  dirk@mink.intel.com 9-NOV-1995

Notes:

    $Revision:   1.7  $

    $Modtime:   14 Feb 1996 14:13:32  $


Revision History:

    09-NOV-1995 dirk@mink.intel.com
        Initial revision.
--*/

#ifndef _NSCATALO_
#define _NSCATALO_

#include "winsock2.h"
#include <windows.h>


typedef
BOOL
(* NSCATALOGITERATION) (
    IN PVOID            PassBack,
    IN PNSCATALOGENTRY  CatalogEntry
    );
/*++

Routine Description:

    CATALOGITERATION  is  a place-holder for a function supplied by the client.
    The  function  is  called once for each NSPROTO_CATALOG_ITEM structure in
    the catalog while enumerating the catalog.  The client can stop the
    enumeration early by returning FALSE from the function.

Arguments:

    PassBack     - Supplies  to  the  client an uninterpreted, unmodified value
                   that  was  specified  by the client in the original function
                   that  requested  the  enumeration.   The client can use this
                   value  to  carry context between the requesting site and the
                   enumeration function.

    CatalogEntry - Supplies  to  the client a reference to a NSCATALOGENTRY
                   structure with values for this item of the enumeration.

Return Value:

    TRUE  - The  enumeration  should continue with more iterations if there are
            more structures to enumerate.

    FALSE - The enumeration should stop with this as the last iteration even if
            there are more structures to enumerate.

--*/

PNSCATALOG
OpenInitializedNameSpaceCatalog();
/*++

Routine Description:

    Creates and returns catalog object that represents current reqistry state
Arguments:
    None
Return Value:
    Catalog object or NULL if allocation or registry IO fails

--*/



class NSCATALOG
{
public:

    NSCATALOG();

    INT
    InitializeFromRegistry(
        IN  HKEY    ParentKey,
        IN  HANDLE  CatalogChangeEvent OPTIONAL
        );

#ifdef _WIN64
    INT
    InitializeFromRegistry32(
        IN  HKEY    ParentKey
        );
#endif

    INT
    RefreshFromRegistry (
        IN  HANDLE  CatalogChangeEvent OPTIONAL
        );

    INT
    WriteToRegistry(
        );

    ~NSCATALOG();

    VOID
    EnumerateCatalogItems(
        IN NSCATALOGITERATION  Iteration,
        IN PVOID               PassBack
        );

    INT
    GetCountedCatalogItemFromProviderId(
        IN  LPGUID ProviderId,
        OUT PNSCATALOGENTRY FAR * CatalogItem
        );

    INT
    GetCountedCatalogItemFromNameSpaceId(
        IN  DWORD                 NameSpaceId,
        OUT PNSCATALOGENTRY FAR * CatalogItem
        );


    VOID
    AppendCatalogItem(
        IN  PNSCATALOGENTRY  CatalogItem
        );

    VOID
    RemoveCatalogItem(
        IN  PNSCATALOGENTRY  CatalogItem
        );

    INT WSAAPI
    GetServiceClassInfo(
        IN OUT  LPDWORD                 lpdwBufSize,
        IN OUT  LPWSASERVICECLASSINFOW  lpServiceClassInfo
        );

    INT
    LoadProvider(
        IN PNSCATALOGENTRY CatalogEntry
        );

    static
    LPSTR
    GetCurrentCatalogName(
        VOID
        );

private:

    BOOL
    OpenCatalog(
        IN  HKEY   ParentKey
        );

    VOID
    AcquireCatalogLock(
        VOID
        );

    VOID
    ReleaseCatalogLock(
        VOID
        );


    VOID
    UpdateNamespaceList (
        PLIST_ENTRY new_list
        );

    PNSPROVIDER
    GetClassInfoProvider(
        IN  DWORD BufSize,
        IN  LPWSASERVICECLASSINFOW  lpServiceClassInfo
        );


    LIST_ENTRY  m_namespace_list;
    // The head of the list of protocol catalog items

    ULONG m_num_items;
    // Number of items in this catalog.

    ULONG m_serial_num;
    // The serial number of the catalog (changes every time catalog
    // is changed in the registry)

    HKEY m_reg_key;
    // Handle of the registry key under which catalog resides.
    // We keep it open so we can get notified whenever catalog
    // changes.

    PNSPROVIDER m_classinfo_provider;
#ifdef _WIN64
    BOOLEAN     m_entries32;
#endif

    CRITICAL_SECTION m_nscatalog_lock;

};  // class dcatalog

inline
VOID
NSCATALOG::AcquireCatalogLock(
    VOID
    )
{
    EnterCriticalSection( &m_nscatalog_lock );
}



inline
VOID
NSCATALOG::ReleaseCatalogLock(
    VOID
    )
{
    LeaveCriticalSection( &m_nscatalog_lock );
}


#endif // _NSCATALO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sockets\winsock2\ws2_32\inc\dprocess.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    dprocess.h

Abstract:

    This header defines the "DPROCESS" class.  The DPROCESS class defines state
    variables  and operations for DPROCESS objects within the WinSock 2 DLL.  A
    DPROCESS  object  represents  all  of the information known about a process
    using the Windows Sockets API.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 7-July-1995

Notes:

    $Revision:   1.16  $

    $Modtime:   08 Mar 1996 04:58:14  $

Revision History:

    most-recent-revision-date email-name
        description

    25-July dirk@mink.intel.com
        Moved protocol catalog related items into DCATALOG. Added data
        member to contain a pointer to the protocol catalog. Removed
        provider list moved provider references to into the protocol
        catalog.

    14-July-1995  dirk@mink.intel.com
        Moved member function documentation to implementation file
        dprocess.cpp. Changed critical section data members to be
        pointers to CRITICAL_SECTION. Added inline implementations for
        the list lock/unlock member functions.

    07-09-1995  drewsxpa@ashland.intel.com
        Completed  first  complete  version with clean compile and released for
        subsequent implementation.

    7-July-1995 drewsxpa@ashland.intel.com
        Original version

--*/

#ifndef _DPROCESS_
#define _DPROCESS_

#include "winsock2.h"
#include <windows.h>
#include "ws2help.h"
#include "classfwd.h"



class DPROCESS
{
  public:

  // Static (global-scope) member functions

    static PDPROCESS
    GetCurrentDProcess(
                        VOID
                        );
    static INT
    DProcessClassInitialize(
                            VOID
                            );

  // Normal member functions

    DPROCESS();

    INT Initialize();

    ~DPROCESS();

    BOOL 
    DSocketDetach (
                  IN LPWSHANDLE_CONTEXT   Context
                  );
    PDCATALOG
    GetProtocolCatalog();

    PNSCATALOG
    GetNamespaceCatalog();

    INT
    GetAsyncHelperDeviceID(
                           OUT LPHANDLE HelperHandle
                           );

    INT
    GetHandleHelperDeviceID(
                           OUT LPHANDLE HelperHandle
                           );
    INT
    GetNotificationHelperDeviceID(
                           OUT LPHANDLE HelperHandle
                           );
    VOID
    IncrementRefCount();

    DWORD
    DecrementRefCount();

    BYTE
    GetMajorVersion();

    BYTE
    GetMinorVersion();

    WORD
    GetVersion();

    VOID
    SetVersion( WORD Version );

#ifndef WS2_DEBUGGER_EXTENSION
//
// Give debugger extension access to all fields
//
  private:
#endif
    VOID    LockDThreadList();
    VOID    UnLockDThreadList();
    VOID    UpdateNamespaceCatalog ();

    INT
    OpenAsyncHelperDevice(
                           OUT LPHANDLE HelperHandle
                           );

    INT
    OpenHandleHelperDevice(
                           OUT LPHANDLE HelperHandle
                           );
    INT
    OpenNotificationHelperDevice(
                           OUT LPHANDLE HelperHandle
                           );


  static PDPROCESS sm_current_dprocess;
      // A class-scope reference to the single current DPROCESS object for this
      // process.

  LONG m_reference_count;
      // The   number   of   times   this   object   has   been   refereced  by
      // WSAStarup/WSACleanup.   WSAStartup  increases the count and WSACleanup
      // decreases the count.  Declarations for lists of associated objects:

  WORD m_version;
      // The WinSock version number for this process.

  BOOLEAN m_lock_initialized;
      // For proper cleanup of critical section if initialization fails

  PDCATALOG m_protocol_catalog;
      // Reference  to  the  protocol  catalog for the process

  HANDLE  m_proto_catalog_change_event;
      // Event that keeps track of protocol catalog changes
  
  PNSCATALOG m_namespace_catalog;
      // Reference  to  the  name space  catalog for the process

  HANDLE  m_ns_catalog_change_event;
      // Event that keeps track of name space catalog changes

  // Declarations for Helper objects created on demand:

  HANDLE  m_ApcHelper;
      // Reference to the Asynchronous callback helper device.  An asynchronous
      // callback helper device is only opened on demand.

  HANDLE  m_HandleHelper;
      // Reference to the handle helper device.  A handler
      // helper device is only opened on demand.

  HANDLE  m_NotificationHelper;
      