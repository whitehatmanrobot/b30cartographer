E(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
}

static void FASTCALL ClipNEF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEIF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEIXF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNECF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNECBF(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		 __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		   __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEIFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEIXFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_INDEX(dst,a,b,t);
    __GL_CLIP_BACKINDEX(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNECFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNEBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		    __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static void FASTCALL ClipNECBFT(__GLvertex *dst, const __GLvertex *a, const __GLvertex *b,
		     __GLfloat t)
{
    LERP_START(dst, a, b);
    __GL_CLIP_POS(dst,a,b,t);
    __GL_CLIP_COLOR(dst,a,b,t);
    __GL_CLIP_BACKCOLOR(dst,a,b,t);
    __GL_CLIP_TEXTURE(dst,a,b,t);
    __GL_CLIP_NORMAL(dst,a,b,t);
    __GL_CLIP_EYE(dst,a,b,t);
    __GL_CLIP_FOG(dst,a,b,t);
}

static PFN_VERTEX_CLIP_PROC clipProcs[84] =
#else
static PFN_VERTEX_CLIP_PROC clipProcs[28] =
#endif //GL_WIN_phong_shading
{
    Clip, ClipI, ClipC, ClipX, ClipB, ClipIX, ClipCB,
    ClipF, ClipIF, ClipCF, ClipXF, ClipBF, ClipIXF, ClipCBF,
    ClipT, ClipIT, ClipCT, ClipXT, ClipBT, ClipIXT, ClipCBT,
    ClipFT, ClipIFT, ClipCFT, ClipXFT, ClipBFT, ClipIXFT, ClipCBFT,
#ifdef GL_WIN_phong_shading
    ClipN, ClipNI, ClipNC, ClipNX, ClipNB, ClipNIX, ClipNCB,
    ClipNF, ClipNIF, ClipNCF, ClipNXF, ClipNBF, ClipNIXF, ClipNCBF,
    ClipNT, ClipNIT, ClipNCT, ClipNXT, ClipNBT, ClipNIXT, ClipNCBT,
    ClipNFT, ClipNIFT, ClipNCFT, ClipNXFT, ClipNBFT, ClipNIXFT, ClipNCBFT,
      //
    ClipNE, ClipNEI, ClipNEC, ClipNEX, ClipNEB, ClipNEIX, ClipNECB,
    ClipNEF, ClipNEIF, ClipNECF, ClipNEXF, ClipNEBF, ClipNEIXF, ClipNECBF,
    ClipNET, ClipNEIT, ClipNECT, ClipNEXT, ClipNEBT, ClipNEIXT, ClipNECBT,
    ClipNEFT, ClipNEIFT, ClipNECFT, ClipNEXFT, ClipNEBFT, ClipNEIXFT, ClipNECBFT,
#endif //GL_WIN_phong_shading
};

#ifdef GL_WIN_phong_shading
void FASTCALL __glGenericPickParameterClipProcs(__GLcontext *gc)
{
    GLint line = 0, poly = 0;
    GLuint enables = gc->state.enables.general;
    GLboolean twoSided = (enables & __GL_LIGHTING_ENABLE)
                         && gc->state.light.model.twoSided;
    GLboolean colorMaterial = (enables & __GL_COLOR_MATERIAL_ENABLE);
    GLboolean doPhong = (enables & __GL_LIGHTING_ENABLE) &&
                        (gc->state.light.shadingModel == GL_PHONG_WIN);
    GLuint modeFlags = gc->polygon.shader.modeFlags;

#ifdef NT
    if (gc->renderMode == GL_SELECT)
    {
        gc->procs.lineClipParam = Clip;
        gc->procs.polyClipParam = Clip;
        return;
    }
#endif

    if (gc->modes.rgbMode) {
        if (doPhong) {
            if (!colorMaterial) {
                line = 28; //0+28
                poly = 28;
            } else {
                line = 30; //2+28
                poly = 30;
            }
        }
        else {
            if (gc->state.light.shadingModel != GL_FLAT) {
                line = 2;
                poly = 2;
            }
        }
    } else {
        if (doPhong) {
            if (!colorMaterial) {
                line = 28; //0+28
                poly = 28;
            } else {
                line = 29; //1+28
                poly = 29;
            }
        }
        else {
            if (gc->state.light.shadingModel != GL_FLAT) {
                line = 1;
                poly = 1;
            }
        }
    }


// Compute front and back color needs for polygons.
// Points and lines always use the front color.
// Unlit primitives always use the front color.
//
//  Cull enable?    Two sided?  Cull face   Color needs
//  N       N       BACK        FRONT
//  N       N       FRONT       FRONT
//  N       N       FRONT_AND_BACK  FRONT
//  N       Y       BACK        FRONT/BACK
//  N       Y       FRONT       FRONT/BACK
//  N       Y       FRONT_AND_BACK  FRONT/BACK
//  Y       N       BACK        FRONT
//  Y       N       FRONT       FRONT
//  Y       N       FRONT_AND_BACK  None
//  Y       Y       BACK        FRONT
//  Y       Y       FRONT       BACK
//  Y       Y       FRONT_AND_BACK  None
    
    if (gc->state.light.shadingModel != GL_FLAT &&
        (enables & __GL_LIGHTING_ENABLE) &&
        gc->state.light.model.twoSided)
    {
        if ((enables & __GL_CULL_FACE_ENABLE) == 0)
        {
            // Both colors are needed
            poly += 4;
        }
        else if (gc->state.polygon.cull == GL_FRONT)
        {
            // Only back colors are needed
            poly += 2;
        }
        else if (gc->state.polygon.cull == GL_FRONT_AND_BACK)
        {
            // Neither color is needed
            poly = 0;
        }
    }
    
    if ((modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG)) ||
	    ((modeFlags & (__GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH_LIGHT)) == 
         __GL_SHADE_CHEAP_FOG)) {
#ifdef NT
        // POLYARRAY - fog is not computed in feedback mode!
        if (gc->renderMode == GL_RENDER)
        {
            line += 7;
            poly += 7;
        }
#else
        line += 7;
        poly += 7;
#endif
    }
    if (gc->texture.textureEnabled) { /*XXX - don't change this (see Derrick)*/
        line += 14;
        poly += 14;
    }
    if (doPhong && 
        (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_EYE_XPOLATE))
    {
        line += 28;
        poly += 28;
    }
    
    gc->procs.lineClipParam = clipProcs[line];
    gc->procs.polyClipParam = clipProcs[poly];
}

#else //GL_WIN_phong_shading

void FASTCALL __glGenericPickParameterClipProcs(__GLcontext *gc)
{
    GLint line = 0, poly = 0;
    GLuint enables = gc->state.enables.general;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    GLboolean twoSided = (enables & __GL_LIGHTING_ENABLE)
                         && gc->state.light.model.twoSided;

#ifdef NT
    if (gc->renderMode == GL_SELECT)
    {
        gc->procs.lineClipParam = Clip;
        gc->procs.polyClipParam = Clip;
        return;
    }
#endif

    if (gc->modes.rgbMode) {
        if (gc->state.light.shadingModel != GL_FLAT) {
            line = 2;
            poly = 2;
        }
    } else {
        if (gc->state.light.shadingModel != GL_FLAT) {
            line = 1;
            poly = 1;
        }
    }

// Compute front and back color needs for polygons.
// Points and lines always use the front color.
// Unlit primitives always use the front color.
//
//  Cull enable?    Two sided?  Cull face   Color needs
//  N       N       BACK        FRONT
//  N       N       FRONT       FRONT
//  N       N       FRONT_AND_BACK  FRONT
//  N       Y       BACK        FRONT/BACK
//  N       Y       FRONT       FRONT/BACK
//  N       Y       FRONT_AND_BACK  FRONT/BACK
//  Y       N       BACK        FRONT
//  Y       N       FRONT       FRONT
//  Y       N       FRONT_AND_BACK  None
//  Y       Y       BACK        FRONT
//  Y       Y       FRONT       BACK
//  Y       Y       FRONT_AND_BACK  None
    
    if (gc->state.light.shadingModel != GL_FLAT &&
        (enables & __GL_LIGHTING_ENABLE) &&
    gc->state.light.model.twoSided)
    {
        if ((enables & __GL_CULL_FACE_ENABLE) == 0)
        {
            // Both colors are needed
            poly += 4;
        }
        else if (gc->state.polygon.cull == GL_FRONT)
        {
            // Only back colors are needed
            poly += 2;
        }
        else if (gc->state.polygon.cull == GL_FRONT_AND_BACK)
        {
            // Neither color is needed
            poly = 0;
        }
    }
    
    if ((modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG)) ||
	    ((modeFlags & (__GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH_LIGHT)) == 
         __GL_SHADE_CHEAP_FOG)) {
      
#ifdef NT
// POLYARRAY - fog is not computed in feedback mode!
    if (gc->renderMode == GL_RENDER)
    {
        line += 7;
        poly += 7;
    }
#else
    line += 7;
    poly += 7;
#endif
    }
    if (gc->texture.textureEnabled) { /*XXX - don't change this (see Derrick)*/
    line += 14;
    poly += 14;
    }
    gc->procs.lineClipParam = clipProcs[line];
    gc->procs.polyClipParam = clipProcs[poly];
}
#endif //GL_WIN_phong_shading
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_bitma.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.8 $
** $Date: 1993/08/31 16:23:06 $
*/
#include "precomp.h"
#pragma hdrstop

#include "devlock.h"

#ifdef NT
void APIPRIVATE __glim_Bitmap(GLsizei w, GLsizei h, GLfloat xOrig, GLfloat yOrig,
		   GLfloat xMove, GLfloat yMove, const GLubyte *bitmap,
		   GLboolean _IsDlist)
#else
void APIPRIVATE __glim_Bitmap(GLsizei w, GLsizei h, GLfloat xOrig, GLfloat yOrig,
		   GLfloat xMove, GLfloat yMove, const GLubyte *bitmap)
#endif
{
    __GL_SETUP();
    GLuint beginMode;
    BOOL bResetViewportAdj = FALSE;

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	    __glim_Bitmap(w,h,xOrig,yOrig,
		    xMove,yMove,bitmap,_IsDlist);
	    return;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

#ifdef NT
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // MCD does not hook glBitmap, so we go straight to the
    // simulations.  Therefore, if we are grabbing the device
    // lock lazily, we need to grab it now.

        if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc,
                                   RENDER_LOCK_FLAGS))
            return;

    // We may need to temporarily reset the viewport adjust values
    // before calling simulations.  If GenMcdResetViewportAdj returns
    // TRUE, the viewport is changed and we need restore later with
    // VP_NOBIAS.

        bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
    }

    if (_IsDlist)
    {
	const __GLbitmap *glbitmap = (const __GLbitmap *) bitmap;
	(*gc->procs.renderBitmap)(gc, glbitmap, (const GLubyte *) (glbitmap+1));
    }
    else
    {
#endif
	if ((w < 0) || (h < 0)) {
	    __glSetError(GL_INVALID_VALUE);
	    return;
	}
	(*gc->procs.bitmap)(gc, w, h, xOrig, yOrig, xMove, yMove, bitmap);
#ifdef NT
    }
#endif

// Restore viewport values if needed.

    if (bResetViewportAdj)
    {
        GenMcdResetViewportAdj(gc, VP_NOBIAS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_blend.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.14 $
** $Date: 1993/04/14 21:23:50 $
*/
#include "precomp.h"
#pragma hdrstop


void __glDoBlendSourceZERO(__GLcontext *gc, const __GLcolor *source,
		            const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat zero = __glZero;

#ifdef __GL_LINT
    gc = gc;
    source = source;
    dest = dest;
#endif
    result->r = zero;
    result->g = zero;
    result->b = zero;
    result->a = zero;
}

void __glDoBlendDestZERO(__GLcontext *gc, const __GLcolor *source,
		          const __GLcolor *dest, __GLcolor *result)
{
#ifdef __GL_LINT
    gc = gc;
    source = source;
    dest = dest;
    result = result;
#endif
    /* Pretend to add zero to each component of the result.
    **
    ** result->r += zero;
    ** result->g += zip;
    ** result->b += squat;
    ** result->a += a bagel;
    */
}

void __glDoBlendSourceONE(__GLcontext *gc, const __GLcolor *source,
		           const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

#ifdef __GL_LINT
    gc = gc;
    dest = dest;
#endif
    r = source->r;
    g = source->g;
    b = source->b;
    a = source->a;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendDestONE(__GLcontext *gc, const __GLcolor *source,
		         const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

#ifdef __GL_LINT
    gc = gc;
    source = source;
#endif

    r = dest->r;
    g = dest->g;
    b = dest->b;
    a = dest->a;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendDestSC(__GLcontext *gc, const __GLcolor *source,
		        const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

    r = dest->r * source->r * gc->frontBuffer.oneOverRedScale;
    g = dest->g * source->g * gc->frontBuffer.oneOverGreenScale;
    b = dest->b * source->b * gc->frontBuffer.oneOverBlueScale;
    a = dest->a * source->a * gc->frontBuffer.oneOverAlphaScale;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendDestMSC(__GLcontext *gc, const __GLcolor *source,
		         const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat one = __glOne;

    r = dest->r * (one - source->r * gc->frontBuffer.oneOverRedScale);
    g = dest->g * (one - source->g * gc->frontBuffer.oneOverGreenScale);
    b = dest->b * (one - source->b * gc->frontBuffer.oneOverBlueScale);
    a = dest->a * (one - source->a * gc->frontBuffer.oneOverAlphaScale);

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendSourceDC(__GLcontext *gc, const __GLcolor *source,
		          const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

    r = source->r * dest->r * gc->frontBuffer.oneOverRedScale;
    g = source->g * dest->g * gc->frontBuffer.oneOverGreenScale;
    b = source->b * dest->b * gc->frontBuffer.oneOverBlueScale;
    a = source->a * dest->a * gc->frontBuffer.oneOverAlphaScale;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendSourceMDC(__GLcontext *gc, const __GLcolor *source,
		           const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat one = __glOne;

    r = source->r * (one - dest->r * gc->frontBuffer.oneOverRedScale);
    g = source->g * (one - dest->g * gc->frontBuffer.oneOverGreenScale);
    b = source->b * (one - dest->b * gc->frontBuffer.oneOverBlueScale);
    a = source->a * (one - dest->a * gc->frontBuffer.oneOverAlphaScale);

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendSourceSA(__GLcontext *gc, const __GLcolor *source,
		          const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

#ifdef __GL_LINT
    dest = dest;
#endif
    a = source->a * gc->frontBuffer.oneOverAlphaScale;

    r = a * source->r;
    g = a * source->g;
    b = a * source->b;
    a = a * source->a;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendDestSA(__GLcontext *gc, const __GLcolor *source,
		        const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;

    a = source->a * gc->frontBuffer.oneOverAlphaScale;

    r = a * dest->r;
    g = a * dest->g;
    b = a * dest->b;
    a = a * dest->a;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendSourceMSA(__GLcontext *gc, const __GLcolor *source,
		           const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat msa = __glOne - source->a * gc->frontBuffer.oneOverAlphaScale;

#ifdef __GL_LINT
    dest = dest;
#endif
    r = msa * source->r;
    g = msa * source->g;
    b = msa * source->b;
    a = msa * source->a;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendDestMSA(__GLcontext *gc, const __GLcolor *source,
		         const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat msa = 
	    __glOne - source->a * gc->frontBuffer.oneOverAlphaScale;

    r = msa * dest->r;
    g = msa * dest->g;
    b = msa * dest->b;
    a = msa * dest->a;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendSourceDA(__GLcontext *gc, const __GLcolor *source,
		          const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b;
    __GLfloat a = dest->a * gc->frontBuffer.oneOverAlphaScale;

    r = a * source->r;
    g = a * source->g;
    b = a * source->b;
    a = a * source->a;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendDestDA(__GLcontext *gc, const __GLcolor *source,
		        const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b;
    __GLfloat a = dest->a * gc->frontBuffer.oneOverAlphaScale;

#ifdef __GL_LINT
    source = source;
#endif
    r = a * dest->r;
    g = a * dest->g;
    b = a * dest->b;
    a = a * dest->a;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendSourceMDA(__GLcontext *gc, const __GLcolor *source,
		           const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat mda;

    mda = __glOne - dest->a * gc->frontBuffer.oneOverAlphaScale;

    r = mda * source->r;
    g = mda * source->g;
    b = mda * source->b;
    a = mda * source->a;

    result->r = r;
    result->g = g;
    result->b = b;
    result->a = a;
}

void __glDoBlendDestMDA(__GLcontext *gc, const __GLcolor *source,
		         const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b, a;
    __GLfloat mda;

#ifdef __GL_LINT
    source = source;
#endif
    mda = __glOne - dest->a * gc->frontBuffer.oneOverAlphaScale;

    r = mda * dest->r;
    g = mda * dest->g;
    b = mda * dest->b;
    a = mda * dest->a;

    result->r += r;
    result->g += g;
    result->b += b;
    result->a += a;
}

void __glDoBlendSourceSAT(__GLcontext *gc, const __GLcolor *source,
		           const __GLcolor *dest, __GLcolor *result)
{
    /* Compiler hints */
    __GLfloat r, g, b;
    __GLfloat sa, mda;

    mda = __glOne - dest->a * gc->frontBuffer.oneOverAlphaScale;
    sa = source->a * gc->frontBuffer.oneOverAlphaScale;
    if (sa < mda) {
	r = sa * source->r;
	g = sa * source->g;
	b = sa * source->b;
    } else {
	r = mda * source->r;
	g = mda * source->g;
	b = mda * source->b;
    }
    result->a = source->a;
    result->r = r;
    result->g = g;
    result->b = b;
}

/************************************************************************/

static void Nop(__GLcontext *gc, const __GLcolor *source,
                const __GLcolor *dest, __GLcolor *result)
{
#ifdef __GL_LINT
    gc = gc;
    source = source;
    dest = dest;
    result = result;
#endif
}

/*
** Generic blend not handled by cases below
*/
static void NoFetchBlend(__GLcontext *gc, __GLcolorBuffer *cfb,
			 const __GLfragment *frag, __GLcolor *result)
{
#ifdef __GL_LINT
    cfb = cfb;
#endif
    (*gc->procs.blendColor)(gc, &(frag->color), NULL, result);
}

/*
** Generic blend not handled by cases below
*/
static void FetchBlend(__GLcontext *gc, __GLcolorBuffer *cfb,
		       const __GLfragment *frag, __GLcolor *result) 
{
    __GLcolor dest;

    (*cfb->fetch)(cfb, frag->x, frag->y, &dest);

    (*gc->procs.blendColor)(gc, &(frag->color), &dest, result);
}

void __glDoBlend(__GLcontext *gc, const __GLcolor *source,
	          const __GLcolor *dest, __GLcolor *result)
{
    (*gc->procs.blendSrc)(gc, source, dest, result);
    (*gc->procs.blendDst)(gc, source, dest, result);

    if (result->r > gc->frontBuffer.redScale) {
	result->r = gc->frontBuffer.redScale;
    }
    if (result->g > gc->frontBuffer.greenScale) {
	result->g = gc->frontBuffer.greenScale;
    }
    if (result->b > gc->frontBuffer.blueScale) {
	result->b = gc->frontBuffer.blueScale;
    }
    if (result->a > gc->frontBuffer.alphaScale) {
	result->a = gc->frontBuffer.alphaScale;
    }
}

void __glDoBlendNoClamp(__GLcontext *gc, const __GLcolor *source,
	                 const __GLcolor *dest, __GLcolor *result)
{
    (*gc->procs.blendSrc)(gc, source, dest, result);
    (*gc->procs.blendDst)(gc, source, dest, result);
}

/*
** Source function == SRC_ALPHA and dest function == ZERO
*/
void __glDoBlend_SA_ZERO(__GLcontext *gc, const __GLcolor *source,
		          const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a;

#ifdef __GL_LINT
    dest = dest;
#endif
    a = source->a * gc->frontBuffer.oneOverAlphaScale;
    result->r = source->r * a;
    result->g = source->g * a;
    result->b = source->b * a;
    result->a = source->a * a;
}

/*
** Source function == SRC_ALPHA and dest function == ONE
*/
void __glDoBlend_SA_ONE(__GLcontext *gc, const __GLcolor *source, 
		         const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a, ra, rr, rg, rb;

    a = source->a * gc->frontBuffer.oneOverAlphaScale;
    rr = dest->r + source->r * a;
    if (rr > gc->frontBuffer.redScale) {
	rr = gc->frontBuffer.redScale;
    }
    rg = dest->g + source->g * a;
    if (rg > gc->frontBuffer.greenScale) {
	rg = gc->frontBuffer.greenScale;
    }
    rb = dest->b + source->b * a;
    if (rb > gc->frontBuffer.blueScale) {
	rb = gc->frontBuffer.blueScale;
    }
    ra = dest->a + source->a * a;
    if (ra > gc->frontBuffer.alphaScale) {
	ra = gc->frontBuffer.alphaScale;
    }

    result->r = rr;
    result->g = rg;
    result->b = rb;
    result->a = ra;
}

/*
** Source function == SRC_ALPHA and dest function == ONE_MINUS_SRC_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void __glDoBlend_SA_MSA(__GLcontext *gc, const __GLcolor *source, 
		         const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a, msa, rr, rg, rb, ra;

    a = source->a * gc->frontBuffer.oneOverAlphaScale;
    msa = __glOne - a;
    rr = source->r * a + dest->r * msa;
    rg = source->g * a + dest->g * msa;
    rb = source->b * a + dest->b * msa;
    ra = source->a * a + dest->a * msa;

    result->r = rr;
    result->g = rg;
    result->b = rb;
    result->a = ra;
}

/*
** Source function == ONE_MINUS_SRC_ALPHA and dest function == SRC_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void __glDoBlend_MSA_SA(__GLcontext *gc, const __GLcolor *source, 
		         const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a, msa, rr, rg, rb, ra;

    a = source->a * gc->frontBuffer.oneOverAlphaScale;
    msa = __glOne - a;
    rr = source->r * msa + dest->r * a;
    rg = source->g * msa + dest->g * a;
    rb = source->b * msa + dest->b * a;
    ra = source->a * msa + dest->a * a;

    result->r = rr;
    result->g = rg;
    result->b = rb;
    result->a = ra;
}

/*
** Source function == DST_ALPHA and dest function == ONE_MINUS_DST_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void __glDoBlend_DA_MDA(__GLcontext *gc, const __GLcolor *source, 
		         const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a, mda;

    a = dest->a * gc->frontBuffer.oneOverAlphaScale;
    mda = __glOne - a;

    result->r = a * source->r + mda * dest->r;
    result->g = a * source->g + mda * dest->g;
    result->b = a * source->b + mda * dest->b;
    result->a = a * source->a + mda * dest->a;
}

/*
** Source function == ONE_MINUS_DST_ALPHA and dest function == DST_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void __glDoBlend_MDA_DA(__GLcontext *gc, const __GLcolor *source, 
		         const __GLcolor *dest, __GLcolor *result)
{
    __GLfloat a, mda;

    a = dest->a * gc->frontBuffer.oneOverAlphaScale;
    mda = __glOne - a;

    result->r = mda * source->r + a * dest->r;
    result->g = mda * source->g + a * dest->g;
    result->b = mda * source->b + a * dest->b;
    result->a = mda * source->a + a * dest->a;
}


/* Generic blend span func.
*/
void FASTCALL __glBlendSpan(__GLcontext *gc)
{
    __GLcolor *cp, *fcp, temp;
    GLint w;

    // Fetch span if required
    if( gc->procs.blend == FetchBlend )
        __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;

    while (--w >= 0) {
	(*gc->procs.blendColor)(gc, cp, fcp, &temp);
	*cp = temp;
	cp++;
	fcp++;
    }
}

/*
** Source function == SRC_ALPHA and dest function == ONE_MINUS_SRC_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void FASTCALL __glBlendSpan_SA_MSA(__GLcontext *gc)
{
    __GLfloat a, msa, rr, rg, rb, ra, oneOverAlpha;
    __GLfloat one = __glOne;
    __GLcolor *cp, *fcp;
    GLint w;

    __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    while (--w >= 0) {
	a = cp->a * oneOverAlpha;
	msa = one - a;

	rr = cp->r * a + fcp->r * msa;
	rg = cp->g * a + fcp->g * msa;
	rb = cp->b * a + fcp->b * msa;
	ra = cp->a * a + fcp->a * msa;

	cp->r = rr;
	cp->g = rg;
	cp->b = rb;
	cp->a = ra;
	cp++;
	fcp++;
    }
}

/*
** Source function == ONE_MINUS_SRC_ALPHA and dest function == SRC_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void FASTCALL __glBlendSpan_MSA_SA(__GLcontext *gc)
{
    __GLfloat a, msa, rr, rg, rb, ra, oneOverAlpha;
    __GLfloat one = __glOne;
    __GLcolor *cp, *fcp;
    GLint w;

    __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    while (--w >= 0) {
	a = cp->a * oneOverAlpha;
	msa = __glOne - a;
	rr = cp->r * msa + fcp->r * a;
	rg = cp->g * msa + fcp->g * a;
	rb = cp->b * msa + fcp->b * a;
	ra = cp->a * msa + fcp->a * a;

	cp->r = rr;
	cp->g = rg;
	cp->b = rb;
	cp->a = ra;
	cp++;
	fcp++;
    }
}

void FASTCALL __glBlendSpan_SA_ZERO(__GLcontext *gc)
{
    __GLfloat a, rr, rg, rb, ra, oneOverAlpha;
    __GLfloat one = __glOne;
    __GLcolor *cp;
    GLint w;

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    while (--w >= 0) {
	a = cp->a * oneOverAlpha;
	rr = cp->r * a;
	rg = cp->g * a;
	rb = cp->b * a;
	ra = cp->a * a;

	cp->r = rr;
	cp->g = rg;
	cp->b = rb;
	cp->a = ra;
	cp++;
    }
}

/*
** Source function == SRC_ALPHA and dest function == ONE
** Clamping is required
*/
void FASTCALL __glBlendSpan_SA_ONE(__GLcontext *gc)
{
    __GLfloat a, rr, rg, rb, ra, oneOverAlpha;
    __GLfloat rs, gs, bs, as;
    __GLcolor *cp, *fcp;
    GLint w;

    __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    rs = gc->frontBuffer.redScale;
    gs = gc->frontBuffer.greenScale;
    bs = gc->frontBuffer.blueScale;
    as = gc->frontBuffer.alphaScale;
    while (--w >= 0) {
	a = cp->a * gc->frontBuffer.oneOverAlphaScale;
	rr = fcp->r + cp->r * a;
	rg = fcp->g + cp->g * a;
	if (rr > rs) {
	    rr = rs;
	}
	rb = fcp->b + cp->b * a;
	if (rg > gs) {
	    rg = gs;
	}
	ra = fcp->a + cp->a * a;
	if (rb > bs) {
	    rb = bs;
	}

	cp->r = rr;
	if (ra > as) {
	    ra = as;
	}
	cp->g = rg;
	cp->b = rb;
	cp->a = ra;
	cp++;
	fcp++;
    }
}

/*
** Source function == DST_ALPHA and dest function == ONE_MINUS_DST_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void FASTCALL __glBlendSpan_DA_MDA(__GLcontext *gc)
{
    __GLfloat a, mda, oneOverAlpha;
    __GLfloat one = __glOne;
    __GLcolor *cp, *fcp;
    GLint w;

    __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    while (--w >= 0) {
	a = fcp->a * oneOverAlpha;
	mda = one - a;

	cp->r = cp->r * a + fcp->r * mda;
	cp->g = cp->g * a + fcp->g * mda;
	cp->b = cp->b * a + fcp->b * mda;
	cp->a = cp->a * a + fcp->a * mda;

	cp++;
	fcp++;
    }
}

/*
** Source function == ONE_MINUS_DST_ALPHA and dest function == DST_ALPHA
** No clamping is done, because the incoming colors should already be
** in range, and the math of x a + y (1 - a) should give a result from
** 0 to 1 if x and y are both from 0 to 1.
*/
void FASTCALL __glBlendSpan_MDA_DA(__GLcontext *gc)
{
    __GLfloat a, mda, oneOverAlpha;
    __GLfloat one = __glOne;
    __GLcolor *cp, *fcp;
    GLint w;

    __glFetchSpan( gc );

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
    fcp = gc->polygon.shader.fbcolors;
    oneOverAlpha = gc->frontBuffer.oneOverAlphaScale;
    while (--w >= 0) {
	a = fcp->a * oneOverAlpha;
	mda = one - a;

	cp->r = cp->r * mda + fcp->r * a;
	cp->g = cp->g * mda + fcp->g * a;
	cp->b = cp->b * mda + fcp->b * a;
	cp->a = cp->a * mda + fcp->a * a;

	cp++;
	fcp++;
    }
}

/************************************************************************/

void FASTCALL __glGenericPickBlendProcs(__GLcontext *gc)
{
    GLenum s = gc->state.raster.blendSrc;
    GLenum d = gc->state.raster.blendDst;

    if (gc->modes.colorIndexMode) {
	return;
    }
    /* Does the blending function need to fetch the dst color? */
    gc->procs.blendSpan = __glBlendSpan;
    if (d == GL_ZERO && s != GL_DST_COLOR && s != GL_ONE_MINUS_DST_COLOR &&
	    s != GL_DST_ALPHA && s != GL_ONE_MINUS_DST_ALPHA &&
	    s != GL_SRC_ALPHA_SATURATE) {
	gc->procs.blend = NoFetchBlend;
    } else {
	gc->procs.blend = FetchBlend;
    }
    if (!(gc->state.enables.general & __GL_BLEND_ENABLE)) {
	gc->procs.blendColor = Nop;
    } else {
	/* Look for any fast paths */
	if (s == GL_SRC_ALPHA) {
	    if (d == GL_ZERO) {
		gc->procs.blendColor = __glDoBlend_SA_ZERO;
		gc->procs.blendSpan = __glBlendSpan_SA_ZERO;
		return;
	    }
	    if (d == GL_ONE) {
		gc->procs.blendColor = __glDoBlend_SA_ONE;
		gc->procs.blendSpan = __glBlendSpan_SA_ONE;
		return;
	    }
	    if (d == GL_ONE_MINUS_SRC_ALPHA) {
		gc->procs.blendColor = __glDoBlend_SA_MSA;
		gc->procs.blendSpan = __glBlendSpan_SA_MSA;
		return;
	    }
	}
	else if (s == GL_ONE_MINUS_SRC_ALPHA) {
	    if (d == GL_SRC_ALPHA) {
		gc->procs.blendColor = __glDoBlend_MSA_SA;
		gc->procs.blendSpan = __glBlendSpan_MSA_SA;
		return;
	    }
	}
	else if (s == GL_DST_ALPHA) {
	    if (d == GL_ONE_MINUS_DST_ALPHA) {
		gc->procs.blendColor = __glDoBlend_DA_MDA;
		gc->procs.blendSpan = __glBlendSpan_DA_MDA;
		return;
	    }
        }
        else if (s == GL_ONE_MINUS_DST_ALPHA) {
	    if (d == GL_DST_ALPHA) {
		gc->procs.blendColor = __glDoBlend_MDA_DA;
		gc->procs.blendSpan = __glBlendSpan_MDA_DA;
		return;
	    }
        }

	/* Use generic blend function */
	if (    (d == GL_ONE_MINUS_SRC_COLOR) ||
	        (s == GL_ONE_MINUS_DST_COLOR) ||
	        (d == GL_ZERO) ||
	        (s == GL_ZERO)) {
	    gc->procs.blendColor = __glDoBlendNoClamp;
	} else {
	    gc->procs.blendColor = __glDoBlend;
	}
	switch (s) {
	  case GL_ZERO:
	    gc->procs.blendSrc = __glDoBlendSourceZERO;
	    break;
	  case GL_ONE:
	    gc->procs.blendSrc = __glDoBlendSourceONE;
	    break;
	  case GL_DST_COLOR:
	    gc->procs.blendSrc = __glDoBlendSourceDC;
	    break;
	  case GL_ONE_MINUS_DST_COLOR:
	    gc->procs.blendSrc = __glDoBlendSourceMDC;
	    break;
	  case GL_SRC_ALPHA:
	    gc->procs.blendSrc = __glDoBlendSourceSA;
	    break;
	  case GL_ONE_MINUS_SRC_ALPHA:
	    gc->procs.blendSrc = __glDoBlendSourceMSA;
	    break;
	  case GL_DST_ALPHA:
	    gc->procs.blendSrc = __glDoBlendSourceDA;
	    break;
	  case GL_ONE_MINUS_DST_ALPHA:
	    gc->procs.blendSrc = __glDoBlendSourceMDA;
	    break;
	  case GL_SRC_ALPHA_SATURATE:
	    gc->procs.blendSrc = __glDoBlendSourceSAT;
	    break;
	}
	switch (d) {
	  case GL_ZERO:
	    gc->procs.blendDst = __glDoBlendDestZERO;
	    break;
	  case GL_ONE:
	    gc->procs.blendDst = __glDoBlendDestONE;
	    break;
	  case GL_SRC_COLOR:
	    gc->procs.blendDst = __glDoBlendDestSC;
	    break;
	  case GL_ONE_MINUS_SRC_COLOR:
	    gc->procs.blendDst = __glDoBlendDestMSC;
	    break;
	  case GL_SRC_ALPHA:
	    gc->procs.blendDst = __glDoBlendDestSA;
	    break;
	  case GL_ONE_MINUS_SRC_ALPHA:
	    gc->procs.blendDst = __glDoBlendDestMSA;
	    break;
	  case GL_DST_ALPHA:
	    gc->procs.blendDst = __glDoBlendDestDA;
	    break;
	  case GL_ONE_MINUS_DST_ALPHA:
	    gc->procs.blendDst = __glDoBlendDestMDA;
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_eval.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.26 $
** $Date: 1993/11/29 01:18:49 $
*/
#include "precomp.h"
#pragma hdrstop

#include "attrib.h"

static const
struct defaultMap {
    GLint	index;
    GLint	k;
    __GLfloat	values[4];
} defaultMaps[__GL_MAP_RANGE_COUNT] = {
    {__GL_C4, 4, 1.0, 1.0, 1.0, 1.0},
    {__GL_I , 1, 1.0, 0.0, 0.0, 0.0},
    {__GL_N3, 3, 0.0, 0.0, 1.0, 0.0},
    {__GL_T1, 1, 0.0, 0.0, 0.0, 0.0},
    {__GL_T2, 2, 0.0, 0.0, 0.0, 0.0},
    {__GL_T3, 3, 0.0, 0.0, 0.0, 0.0},
    {__GL_T4, 4, 0.0, 0.0, 0.0, 1.0},
    {__GL_V3, 3, 0.0, 0.0, 0.0, 0.0},
    {__GL_V4, 4, 0.0, 0.0, 0.0, 1.0},
};

void FASTCALL __glInitEvaluatorState(__GLcontext *gc)
{
    int i,j;
    const struct defaultMap *defMap;
    __GLevaluator1 *eval1;
    __GLevaluator2 *eval2;
    __GLfloat **eval1Data;
    __GLfloat **eval2Data;

    for (i = 0; i < __GL_MAP_RANGE_COUNT; i++) {
	defMap = &(defaultMaps[i]);
	eval1 = &(gc->eval.eval1[i]);
	eval2 = &(gc->eval.eval2[i]);
	eval1Data = &(gc->eval.eval1Data[i]);
	eval2Data = &(gc->eval.eval2Data[i]);

	eval1->order = 1;
	eval1->u1 = __glZero;
	eval1->u2 = __glOne;
	eval1->k = defMap->k;
	eval2->majorOrder = 1;
	eval2->minorOrder = 1;
	eval2->u1 = __glZero;
	eval2->u2 = __glOne;
	eval2->v1 = __glZero;
	eval2->v2 = __glOne;
	eval2->k = defMap->k;
	*eval1Data = (__GLfloat *)
	    GCALLOC(gc, (size_t) (sizeof(__GLfloat) * defMap->k));
#ifdef NT
        if (NULL == *eval1Data) {
            return;
        }
#endif /* NT */
	*eval2Data = (__GLfloat *)
	    GCALLOC(gc, (size_t) (sizeof(__GLfloat) * defMap->k));
#ifdef NT
        if (NULL == *eval2Data) {
            return;
        }
#endif /* NT */
	for (j = 0; j < defMap->k; j++) {
	    (*eval1Data)[j] = defMap->values[j];
	    (*eval2Data)[j] = defMap->values[j];
	}
    }

    gc->eval.uorder = __glZero;
    gc->eval.vorder = __glZero;
    gc->eval.evalStackState = __glZero;

    gc->state.evaluator.u1.start = __glZero;
    gc->state.evaluator.u2.start = __glZero;
    gc->state.evaluator.v2.start = __glZero;
    gc->state.evaluator.u1.finish = __glOne;
    gc->state.evaluator.u2.finish = __glOne;
    gc->state.evaluator.v2.finish = __glOne;
    gc->state.evaluator.u1.n = 1;
    gc->state.evaluator.u2.n = 1;
    gc->state.evaluator.v2.n = 1;
}

void FASTCALL __glFreeEvaluatorState(__GLcontext *gc)
{
    int i;
    __GLevaluatorMachine *evals = &gc->eval;

    for (i = 0; i < __GL_MAP_RANGE_COUNT; i++) {
        if (evals->eval1Data[i]) {
            GCFREE(gc, evals->eval1Data[i]);
            evals->eval1Data[i] = 0;
        }
        if (evals->eval2Data[i]) {
            GCFREE(gc, evals->eval2Data[i]);
            evals->eval2Data[i] = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_depth.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

static __GLzValue FASTCALL Fetch(__GLdepthBuffer *fb, GLint x, GLint y)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return fp[0];
}

static GLboolean StoreNEVER(__GLdepthBuffer *fb,
			    GLint x, GLint y, __GLzValue z)
{
#ifdef __GL_LINT
    fb = fb;
    x = y;
    z = z;
#endif
    return GL_FALSE;
}

static GLboolean StoreLESS(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreLESS: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z < fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z == fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreLEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreLEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z <= fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreGREATER(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreGREATER: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z > fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreNOTEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreNOTEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z != fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreGEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreGEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    if (z >= fp[0]) {
	fp[0] = z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean StoreALWAYS(__GLdepthBuffer *fb,
			     GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "StoreALWAYS: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    fp[0] = z;
    return GL_TRUE;
}

/************************************************************************/

static GLboolean StoreLESS_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z < fp[0];
}

static GLboolean StoreEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z == fp[0];
}

static GLboolean StoreLEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z <= fp[0];
}

static GLboolean StoreGREATER_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z > fp[0];
}

static GLboolean StoreNOTEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z != fp[0];
}

static GLboolean StoreGEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLzValue *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLzValue*), x, y);
    return z >= fp[0];
}

static GLboolean StoreALWAYS_W(__GLdepthBuffer *fb,
			     GLint x, GLint y, __GLzValue z)
{
#ifdef __GL_LINT
    fb = fb;
    x = y;
    z = z;
#endif
    return GL_TRUE;
}


#ifdef NT
static __GLzValue FASTCALL Fetch16(__GLdepthBuffer *fb, GLint x, GLint y)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return (__GLzValue) fp[0];
}

static GLboolean Store16NEVER(__GLdepthBuffer *fb,
			    GLint x, GLint y, __GLzValue z)
{
#ifdef __GL_LINT
    fb = fb;
    x = y;
    z = z;
#endif
    return GL_FALSE;
}

static GLboolean Store16LESS(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16LESS: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z < fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16EQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16EQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z == fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16LEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16LEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z <= fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16GREATER(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16GREATER: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z > fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16NOTEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16NOTEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z != fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16GEQUAL(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16GEQUAL: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    if (z >= fp[0]) {
	fp[0] = (__GLz16Value)z;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLboolean Store16ALWAYS(__GLdepthBuffer *fb,
			     GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

#ifdef ASSERT_BUFFER
    ASSERTOPENGL(fb->buf.base != NULL, "Store16ALWAYS: No depth buffer\n");
#endif
    
    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    fp[0] = (__GLz16Value)z;
    return GL_TRUE;
}

/************************************************************************/

static GLboolean Store16LESS_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z < fp[0];
}

static GLboolean Store16EQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z == fp[0];
}

static GLboolean Store16LEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z <= fp[0];
}

static GLboolean Store16GREATER_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z > fp[0];
}

static GLboolean Store16NOTEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z != fp[0];
}

static GLboolean Store16GEQUAL_W(__GLdepthBuffer *fb,
			   GLint x, GLint y, __GLzValue z)
{
    __GLz16Value *fp;

    fp = __GL_DEPTH_ADDR(fb, (__GLz16Value*), x, y);
    return z >= fp[0];
}

static GLboolean Store16ALWAYS_W(__GLdepthBuffer *fb,
			     GLint x, GLint y, __GLzValue z)
{
#ifdef __GL_LINT
    fb = fb;
    x = y;
    z = z;
#endif
    return GL_TRUE;
}

#endif //NT

/************************************************************************/

static void FASTCALL Clear(__GLdepthBuffer *dfb)
{
    __GLcontext *gc = dfb->buf.gc;
    __GLzValue *fb;
    GLint x, y, x1, y1;
    GLint skip, w, w32, w4, w1;
    __GLzValue z = (__GLzValue)(gc->state.depth.clear * dfb->scale);

#ifdef NT
    if( !gc->state.depth.writeEnable )
	return;
#endif

    x = gc->transform.clipX0;
    y = gc->transform.clipY0;
    x1 = gc->transform.clipX1;
    y1 = gc->transform.clipY1;
    if (((w = x1 - x) == 0) || (y1 - y == 0)) {
	return;
    }

    fb = __GL_DEPTH_ADDR(dfb, (__GLzValue*), x, y);

#ifdef NT
    ASSERTOPENGL(sizeof(ULONG) == sizeof(__GLzValue),
                 "Incorrect __GLzValue size\n");
    skip = dfb->buf.outerWidth;
    if (skip == w)
    {
        w = w * (y1 - y) * sizeof(ULONG);
        RtlFillMemoryUlong((PVOID) fb, (ULONG) w, (ULONG) z);
    }
    else
    {
        w = w * sizeof(ULONG);      // convert to byte count
        for (; y < y1; y++)
        {
            RtlFillMemoryUlong((PVOID) fb, (ULONG) w, (ULONG) z);
            fb += skip;
        }
    }
#else
    skip = dfb->buf.outerWidth - w;
    w32 = w >> 5;
    w4 = (w & 31) >> 2;
    w1 = w & 3;
    for (; y < y1; y++) {
	w = w32;
	while (--w >= 0) {
	    fb[0] = z; fb[1] = z; fb[2] = z; fb[3] = z;
	    fb[4] = z; fb[5] = z; fb[6] = z; fb[7] = z;
	    fb[8] = z; fb[9] = z; fb[10] = z; fb[11] = z;
	    fb[12] = z; fb[13] = z; fb[14] = z; fb[15] = z;
	    fb[16] = z; fb[17] = z; fb[18] = z; fb[19] = z;
	    fb[20] = z; fb[21] = z; fb[22] = z; fb[23] = z;
	    fb[24] = z; fb[25] = z; fb[26] = z; fb[27] = z;
	    fb[28] = z; fb[29] = z; fb[30] = z; fb[31] = z;
	    fb += 32;
	}
	w = w4;
	while (--w >= 0) {
	    fb[0] = z; fb[1] = z; fb[2] = z; fb[3] = z;
	    fb += 4;
	}
	w = w1;
	while (--w >= 0) {
	    *fb++ = z;
	}
	fb += skip;
    }
#endif // NT

}

#ifdef NT
/************************************************************************/

static void FASTCALL Clear16(__GLdepthBuffer *dfb)
{
    __GLcontext *gc = dfb->buf.gc;
    __GLz16Value *fb;
    GLint x, y, x1, y1;
    GLint skip, w; 
    __GLz16Value z = (__GLz16Value)(gc->state.depth.clear * dfb->scale);
    __GLzValue zz = (z << 16) | z;

#ifdef NT
    if( !gc->state.depth.writeEnable )
	return;
#endif

    x = gc->transform.clipX0;
    y = gc->transform.clipY0;
    x1 = gc->transform.clipX1;
    y1 = gc->transform.clipY1;
    if (((w = x1 - x) == 0) || (y1 - y == 0)) {
	return;
    }

    fb = __GL_DEPTH_ADDR(dfb, (__GLz16Value*), x, y);

    skip = dfb->buf.outerWidth;

    // handle word overhangs onto long boundaries

    if( (ULONG_PTR)fb & 0x2 ) { // Left word overhang
	int ysav = y;
    	__GLz16Value *fbsav = fb;

	for( ; y < y1; y ++, fb+=skip ) {
	    *fb = z;
	}
	y = ysav;
	fb = fbsav+1;
	w--;
    }
    if( (ULONG)((ULONG_PTR)fb + w*sizeof(__GLz16Value)) & 0x2 ) {  // Right overhang
	int ysav = y;
    	__GLz16Value *fbsav = fb;

	w--;
	fb += w;
	for( ; y < y1; y ++, fb+=skip ) {
	    *fb = z;
	}
	y = ysav;
	fb = fbsav;
    }

    // Do 4byte-aligned stuff

    if (skip == w)
    {
        w = w * (y1 - y) * sizeof(__GLz16Value);
        RtlFillMemoryUlong((PVOID) fb, (ULONG) w, (ULONG) zz);
    }
    else
    {
	if( skip & 0x1 ) { // skip is odd - successive lines will NOT be
			   //  quad-word aligned
	    int i;
            for (; y < y1; y++)
            {
		for( i = 0; i < w; i ++ )
		    *fb++ = z;
                fb += (skip-w);
            }
	}
	else {
            w = w * sizeof(__GLz16Value);   // convert to byte count
            for (; y < y1; y++)
            {
                RtlFillMemoryUlong((PVOID) fb, (ULONG) w, (ULONG) zz);
                fb += skip;
            }
        }
    }

}
#endif // NT

/************************************************************************/

static GLboolean (*StoreProcs[32])(__GLdepthBuffer*, GLint, GLint, __GLzValue)
 = {
    StoreNEVER,
    StoreLESS,
    StoreEQUAL,
    StoreLEQUAL,
    StoreGREATER,
    StoreNOTEQUAL,
    StoreGEQUAL,
    StoreALWAYS,
    StoreNEVER,
    StoreLESS_W,
    StoreEQUAL_W,
    StoreLEQUAL_W,
    StoreGREATER_W,
    StoreNOTEQUAL_W,
    StoreGEQUAL_W,
    StoreALWAYS_W,
    Store16NEVER,
    Store16LESS,
    Store16EQUAL,
    Store16LEQUAL,
    Store16GREATER,
    Store16NOTEQUAL,
    Store16GEQUAL,
    Store16ALWAYS,
    Store16NEVER,
    Store16LESS_W,
    Store16EQUAL_W,
    Store16LEQUAL_W,
    Store16GREATER_W,
    Store16NOTEQUAL_W,
    Store16GEQUAL_W,
    Store16ALWAYS_W
};

static void FASTCALL Pick(__GLcontext *gc, __GLdepthBuffer *fb, GLint depthIndex)
{
    fb->store = StoreProcs[depthIndex];
    fb->storeRaw = StoreProcs[depthIndex];
}

void FASTCALL __glInitDepth32(__GLcontext *gc, __GLdepthBuffer *fb)
{
    fb->buf.elementSize = sizeof(__GLzValue);
    fb->buf.gc = gc;
    fb->scale = (__GLzValue) ~0;
    fb->writeMask = (__GLzValue) ~0;
    fb->pick = Pick;
    fb->clear = Clear;
    fb->store2 = StoreALWAYS;
    fb->fetch = Fetch;
}

#ifdef NT
void FASTCALL __glInitDepth16(__GLcontext *gc, __GLdepthBuffer *fb)
{
    fb->buf.elementSize = sizeof(__GLz16Value);
    fb->buf.gc = gc;
    fb->scale = (__GLz16Value) ~0;
    fb->writeMask = (__GLz16Value) ~0;
    fb->pick = Pick;
    fb->clear = Clear16;
    fb->store2 = Store16ALWAYS;
    fb->fetch = Fetch16;
}
#endif

void FASTCALL __glFreeDepth32(__GLcontext *gc, __GLdepthBuffer *fb)
{
#ifdef __GL_LINT
    gc = gc;
    fb = fb;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_conte.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include <stdio.h>
#include <fixed.h>

static GLfloat DefaultAmbient[4] = { 0.2f, 0.2f, 0.2f, 1.0 };
static GLfloat DefaultDiffuse[4] = { 0.8f, 0.8f, 0.8f, 1.0 };
static GLfloat DefaultBlack[4] = { 0.0, 0.0, 0.0, 1.0 };
static GLfloat DefaultWhite[4] = { 1.0, 1.0, 1.0, 1.0 };

#ifdef NT
#define UB2F(ub)  ((GLfloat) ((ub) / 255.0))
#define B2F(b)    ((GLfloat) ((2 * (b) + 1) / 255.0))

GLfloat __glUByteToFloat[256] = {
    UB2F(  0), UB2F(  1), UB2F(  2), UB2F(  3),
    UB2F(  4), UB2F(  5), UB2F(  6), UB2F(  7),
    UB2F(  8), UB2F(  9), UB2F( 10), UB2F( 11),
    UB2F( 12), UB2F( 13), UB2F( 14), UB2F( 15),
    UB2F( 16), UB2F( 17), UB2F( 18), UB2F( 19),
    UB2F( 20), UB2F( 21), UB2F( 22), UB2F( 23),
    UB2F( 24), UB2F( 25), UB2F( 26), UB2F( 27),
    UB2F( 28), UB2F( 29), UB2F( 30), UB2F( 31),
    UB2F( 32), UB2F( 33), UB2F( 34), UB2F( 35),
    UB2F( 36), UB2F( 37), UB2F( 38), UB2F( 39),
    UB2F( 40), UB2F( 41), UB2F( 42), UB2F( 43),
    UB2F( 44), UB2F( 45), UB2F( 46), UB2F( 47),
    UB2F( 48), UB2F( 49), UB2F( 50), UB2F( 51),
    UB2F( 52), UB2F( 53), UB2F( 54), UB2F( 55),
    UB2F( 56), UB2F( 57), UB2F( 58), UB2F( 59),
    UB2F( 60), UB2F( 61), UB2F( 62), UB2F( 63),
    UB2F( 64), UB2F( 65), UB2F( 66), UB2F( 67),
    UB2F( 68), UB2F( 69), UB2F( 70), UB2F( 71),
    UB2F( 72), UB2F( 73), UB2F( 74), UB2F( 75),
    UB2F( 76), UB2F( 77), UB2F( 78), UB2F( 79),
    UB2F( 80), UB2F( 81), UB2F( 82), UB2F( 83),
    UB2F( 84), UB2F( 85), UB2F( 86), UB2F( 87),
    UB2F( 88), UB2F( 89), UB2F( 90), UB2F( 91),
    UB2F( 92), UB2F( 93), UB2F( 94), UB2F( 95),
    UB2F( 96), UB2F( 97), UB2F( 98), UB2F( 99),
    UB2F(100), UB2F(101), UB2F(102), UB2F(103),
    UB2F(104), UB2F(105), UB2F(106), UB2F(107),
    UB2F(108), UB2F(109), UB2F(110), UB2F(111),
    UB2F(112), UB2F(113), UB2F(114), UB2F(115),
    UB2F(116), UB2F(117), UB2F(118), UB2F(119),
    UB2F(120), UB2F(121), UB2F(122), UB2F(123),
    UB2F(124), UB2F(125), UB2F(126), UB2F(127),
    UB2F(128), UB2F(129), UB2F(130), UB2F(131),
    UB2F(132), UB2F(133), UB2F(134), UB2F(135),
    UB2F(136), UB2F(137), UB2F(138), UB2F(139),
    UB2F(140), UB2F(141), UB2F(142), UB2F(143),
    UB2F(144), UB2F(145), UB2F(146), UB2F(147),
    UB2F(148), UB2F(149), UB2F(150), UB2F(151),
    UB2F(152), UB2F(153), UB2F(154), UB2F(155),
    UB2F(156), UB2F(157), UB2F(158), UB2F(159),
    UB2F(160), UB2F(161), UB2F(162), UB2F(163),
    UB2F(164), UB2F(165), UB2F(166), UB2F(167),
    UB2F(168), UB2F(169), UB2F(170), UB2F(171),
    UB2F(172), UB2F(173), UB2F(174), UB2F(175),
    UB2F(176), UB2F(177), UB2F(178), UB2F(179),
    UB2F(180), UB2F(181), UB2F(182), UB2F(183),
    UB2F(184), UB2F(185), UB2F(186), UB2F(187),
    UB2F(188), UB2F(189), UB2F(190), UB2F(191),
    UB2F(192), UB2F(193), UB2F(194), UB2F(195),
    UB2F(196), UB2F(197), UB2F(198), UB2F(199),
    UB2F(200), UB2F(201), UB2F(202), UB2F(203),
    UB2F(204), UB2F(205), UB2F(206), UB2F(207),
    UB2F(208), UB2F(209), UB2F(210), UB2F(211),
    UB2F(212), UB2F(213), UB2F(214), UB2F(215),
    UB2F(216), UB2F(217), UB2F(218), UB2F(219),
    UB2F(220), UB2F(221), UB2F(222), UB2F(223),
    UB2F(224), UB2F(225), UB2F(226), UB2F(227),
    UB2F(228), UB2F(229), UB2F(230), UB2F(231),
    UB2F(232), UB2F(233), UB2F(234), UB2F(235),
    UB2F(236), UB2F(237), UB2F(238), UB2F(239),
    UB2F(240), UB2F(241), UB2F(242), UB2F(243),
    UB2F(244), UB2F(245), UB2F(246), UB2F(247),
    UB2F(248), UB2F(249), UB2F(250), UB2F(251),
    UB2F(252), UB2F(253), UB2F(254), UB2F(255),
};

GLfloat __glByteToFloat[256] = {
    B2F(   0), B2F(   1), B2F(   2), B2F(   3),
    B2F(   4), B2F(   5), B2F(   6), B2F(   7),
    B2F(   8), B2F(   9), B2F(  10), B2F(  11),
    B2F(  12), B2F(  13), B2F(  14), B2F(  15),
    B2F(  16), B2F(  17), B2F(  18), B2F(  19),
    B2F(  20), B2F(  21), B2F(  22), B2F(  23),
    B2F(  24), B2F(  25), B2F(  26), B2F(  27),
    B2F(  28), B2F(  29), B2F(  30), B2F(  31),
    B2F(  32), B2F(  33), B2F(  34), B2F(  35),
    B2F(  36), B2F(  37), B2F(  38), B2F(  39),
    B2F(  40), B2F(  41), B2F(  42), B2F(  43),
    B2F(  44), B2F(  45), B2F(  46), B2F(  47),
    B2F(  48), B2F(  49), B2F(  50), B2F(  51),
    B2F(  52), B2F(  53), B2F(  54), B2F(  55),
    B2F(  56), B2F(  57), B2F(  58), B2F(  59),
    B2F(  60), B2F(  61), B2F(  62), B2F(  63),
    B2F(  64), B2F(  65), B2F(  66), B2F(  67),
    B2F(  68), B2F(  69), B2F(  70), B2F(  71),
    B2F(  72), B2F(  73), B2F(  74), B2F(  75),
    B2F(  76), B2F(  77), B2F(  78), B2F(  79),
    B2F(  80), B2F(  81), B2F(  82), B2F(  83),
    B2F(  84), B2F(  85), B2F(  86), B2F(  87),
    B2F(  88), B2F(  89), B2F(  90), B2F(  91),
    B2F(  92), B2F(  93), B2F(  94), B2F(  95),
    B2F(  96), B2F(  97), B2F(  98), B2F(  99),
    B2F( 100), B2F( 101), B2F( 102), B2F( 103),
    B2F( 104), B2F( 105), B2F( 106), B2F( 107),
    B2F( 108), B2F( 109), B2F( 110), B2F( 111),
    B2F( 112), B2F( 113), B2F( 114), B2F( 115),
    B2F( 116), B2F( 117), B2F( 118), B2F( 119),
    B2F( 120), B2F( 121), B2F( 122), B2F( 123),
    B2F( 124), B2F( 125), B2F( 126), B2F( 127),
    B2F(-128), B2F(-127), B2F(-126), B2F(-125),
    B2F(-124), B2F(-123), B2F(-122), B2F(-121),
    B2F(-120), B2F(-119), B2F(-118), B2F(-117),
    B2F(-116), B2F(-115), B2F(-114), B2F(-113),
    B2F(-112), B2F(-111), B2F(-110), B2F(-109),
    B2F(-108), B2F(-107), B2F(-106), B2F(-105),
    B2F(-104), B2F(-103), B2F(-102), B2F(-101),
    B2F(-100), B2F( -99), B2F( -98), B2F( -97),
    B2F( -96), B2F( -95), B2F( -94), B2F( -93),
    B2F( -92), B2F( -91), B2F( -90), B2F( -89),
    B2F( -88), B2F( -87), B2F( -86), B2F( -85),
    B2F( -84), B2F( -83), B2F( -82), B2F( -81),
    B2F( -80), B2F( -79), B2F( -78), B2F( -77),
    B2F( -76), B2F( -75), B2F( -74), B2F( -73),
    B2F( -72), B2F( -71), B2F( -70), B2F( -69),
    B2F( -68), B2F( -67), B2F( -66), B2F( -65),
    B2F( -64), B2F( -63), B2F( -62), B2F( -61),
    B2F( -60), B2F( -59), B2F( -58), B2F( -57),
    B2F( -56), B2F( -55), B2F( -54), B2F( -53),
    B2F( -52), B2F( -51), B2F( -50), B2F( -49),
    B2F( -48), B2F( -47), B2F( -46), B2F( -45),
    B2F( -44), B2F( -43), B2F( -42), B2F( -41),
    B2F( -40), B2F( -39), B2F( -38), B2F( -37),
    B2F( -36), B2F( -35), B2F( -34), B2F( -33),
    B2F( -32), B2F( -31), B2F( -30), B2F( -29),
    B2F( -28), B2F( -27), B2F( -26), B2F( -25),
    B2F( -24), B2F( -23), B2F( -22), B2F( -21),
    B2F( -20), B2F( -19), B2F( -18), B2F( -17),
    B2F( -16), B2F( -15), B2F( -14), B2F( -13),
    B2F( -12), B2F( -11), B2F( -10), B2F(  -9),
    B2F(  -8), B2F(  -7), B2F(  -6), B2F(  -5),
    B2F(  -4), B2F(  -3), B2F(  -2), B2F(  -1),
};
#endif // NT

/*
** Early initialization of context.  Very little is done here, just enough
** to make a context viable.
*/

void FASTCALL __glEarlyInitContext(__GLcontext *gc)
{
    GLint numLights, attribDepth;
    GLint i;

    ASSERTOPENGL(__GL_MAX_MAX_VIEWPORT == __GL_MAX_WINDOW_WIDTH &&
		 __GL_MAX_MAX_VIEWPORT == __GL_MAX_WINDOW_HEIGHT,
		 "__GL_MAX_MAX_VIEWPORT mismatch\n");

    gc->constants.fviewportXAdjust = (__GLfloat) gc->constants.viewportXAdjust;
    gc->constants.fviewportYAdjust = (__GLfloat) gc->constants.viewportYAdjust;
    gc->procs.pickColorMaterialProcs = __glNopGC;
    gc->procs.applyColor = __glNopGC;

    /* Allocate memory to hold variable sized things */
    numLights = gc->constants.numberOfLights;
    gc->state.light.source = (__GLlightSourceState*)
	GCALLOCZ(gc, numLights*sizeof(__GLlightSourceState));
    gc->light.lutCache = NULL;
    gc->light.source = (__GLlightSourceMachine*)
	GCALLOCZ(gc, numLights*sizeof(__GLlightSourceMachine));
    attribDepth = gc->constants.maxAttribStackDepth;
    gc->attributes.stack = (__GLattribute**)
	GCALLOCZ(gc, attribDepth*sizeof(__GLattribute*));
    attribDepth = gc->constants.maxClientAttribStackDepth;
    gc->clientAttributes.stack = (__GLclientAttribute**)
	GCALLOCZ(gc, attribDepth*sizeof(__GLclientAttribute*));
    // now lazy allocate in RenderMode
    gc->select.stack = (GLuint*) NULL;

#ifdef NT
    // Allocate (n-1) vertices.  The last one is reserved by polyarray code.
    (void) PolyArrayAllocBuffer(gc, POLYDATA_BUFFER_SIZE + 1);
#ifndef NEW_PARTIAL_PRIM
    for (i = 0; i < sizeof(gc->vertex.pdSaved)/sizeof(gc->vertex.pdSaved[0]); i++)
	gc->vertex.pdSaved[i].color = &gc->vertex.pdSaved[i].colors[__GL_FRONTFACE];
#endif // NEW_PARTIAL_PRIM
#endif

#ifdef _X86_

    initClipCodesTable();
    initInvSqrtTable();

#endif // _X86_

    __glEarlyInitTextureState(gc);

#if __GL_NUMBER_OF_AUX_BUFFERS > 0
    /*
    ** Allocate any aux color buffer records
    ** Note: Does not allocate the actual buffer memory, this is done elsewhere.
    */
    if (gc->modes.maxAuxBuffers > 0) {
	gc->auxBuffer = (__GLcolorBuffer *)
	    GCALLOCZ(gc, gc->modes.maxAuxBuffers*sizeof(__GLcolorBuffer));
    }
#endif

    __glInitDlistState(gc);
}

void FASTCALL __glContextSetColorScales(__GLcontext *gc)
{
    __GLfloat one = __glOne;
    __GLattribute **spp;
    __GLattribute *sp;
    GLuint mask;
    GLint i;

    gc->frontBuffer.oneOverRedScale = one / gc->frontBuffer.redScale;
    gc->frontBuffer.oneOverGreenScale = one / gc->frontBuffer.greenScale;
    gc->frontBuffer.oneOverBlueScale = one / gc->frontBuffer.blueScale;
    gc->frontBuffer.oneOverAlphaScale = one / gc->frontBuffer.alphaScale;

    gc->vertexToBufferIdentity = GL_TRUE;
    
    if (__GL_FLOAT_NEZ(gc->redVertexScale))
    {
        gc->oneOverRedVertexScale = one / gc->redVertexScale;
    }
    else
    {
        gc->oneOverRedVertexScale = __glZero;
    }
    
    if (__GL_FLOAT_NE(gc->redVertexScale, gc->frontBuffer.redScale))
    {
        gc->redVertexToBufferScale =
            gc->frontBuffer.redScale * gc->oneOverRedVertexScale;
        gc->vertexToBufferIdentity = GL_FALSE;
    }
    else
    {
        gc->redVertexToBufferScale = __glOne;
    }

    if (__GL_FLOAT_NEZ(gc->greenVertexScale))
    {
        gc->oneOverGreenVertexScale = one / gc->greenVertexScale;
    }
    else
    {
        gc->oneOverGreenVertexScale = __glZero;
    }

    if (__GL_FLOAT_NE(gc->greenVertexScale, gc->frontBuffer.greenScale))
    {
        gc->greenVertexToBufferScale =
            gc->frontBuffer.greenScale * gc->oneOverGreenVertexScale;
        gc->vertexToBufferIdentity = GL_FALSE;
    }
    else
    {
        gc->greenVertexToBufferScale = __glOne;
    }

    if (__GL_FLOAT_NEZ(gc->blueVertexScale))
    {
        gc->oneOverBlueVertexScale = one / gc->blueVertexScale;
    }
    else
    {
        gc->oneOverBlueVertexScale = __glZero;
    }
    
    if (__GL_FLOAT_NE(gc->blueVertexScale, gc->frontBuffer.blueScale))
    {
        gc->blueVertexToBufferScale =
            gc->frontBuffer.blueScale * gc->oneOverBlueVertexScale;
        gc->vertexToBufferIdentity = GL_FALSE;
    }
    else
    {
        gc->blueVertexToBufferScale = __glOne;
    }

    if (__GL_FLOAT_NEZ(gc->alphaVertexScale))
    {
        gc->oneOverAlphaVertexScale = one / gc->alphaVertexScale;
    }
    else
    {
        gc->oneOverAlphaVertexScale = __glZero;
    }
    
    if (__GL_FLOAT_NE(gc->alphaVertexScale, gc->frontBuffer.alphaScale))
    {
        gc->alphaVertexToBufferScale =
            gc->frontBuffer.alphaScale * gc->oneOverAlphaVertexScale;
        gc->vertexToBufferIdentity = GL_FALSE;
    }
    else
    {
        gc->alphaVertexToBufferScale = __glOne;
    }

    for (spp = &gc->attributes.stack[0]; spp < gc->attributes.stackPointer; 
	    spp++) {
	sp = *spp;
	mask = sp->mask;

	if (mask & GL_CURRENT_BIT) {
	    if (gc->modes.rgbMode) {
		__glScaleColorf(gc,
		    &sp->current.rasterPos.colors[__GL_FRONTFACE],
		    &sp->current.rasterPos.colors[__GL_FRONTFACE].r);
	    }
	}
	if (mask & GL_LIGHTING_BIT) {
	    __glScaleColorf(gc,
		&sp->light.model.ambient,
		&sp->light.model.ambient.r);
	    for (i=0; i<gc->constants.numberOfLights; i++) {
		__glScaleColorf(gc,
		    &sp->light.source[i].ambient,
		    &sp->light.source[i].ambient.r);
		__glScaleColorf(gc,
		    &sp->light.source[i].diffuse,
		    &sp->light.source[i].diffuse.r);
		__glScaleColorf(gc,
		    &sp->light.source[i].specular,
		    &sp->light.source[i].specular.r);
	    }
	    __glScaleColorf(gc,
		&sp->light.front.emissive,
		&sp->light.front.emissive.r);
	    __glScaleColorf(gc,
		&sp->light.back.emissive,
		&sp->light.back.emissive.r);
	}
#ifdef NT
        if (mask & GL_FOG_BIT)
        {
            __glScaleColorf(gc, &sp->fog.color, &sp->fog.color.r);
	    if (sp->fog.color.r == sp->fog.color.g
	     && sp->fog.color.r == sp->fog.color.b)
		sp->fog.flags |= __GL_FOG_GRAY_RGB;
	    else
		sp->fog.flags &= ~__GL_FOG_GRAY_RGB;
        }

#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FOG);
#endif
#endif
    }

    if (gc->modes.rgbMode) {
	__glScaleColorf(gc, 
	        &gc->state.current.rasterPos.colors[__GL_FRONTFACE], 
		&gc->state.current.rasterPos.colors[__GL_FRONTFACE].r);
    } 

    __glScaleColorf(gc, 
	    &gc->state.light.model.ambient,
	    &gc->state.light.model.ambient.r);
    for (i=0; i<gc->constants.numberOfLights; i++) {
	__glScaleColorf(gc,
		&gc->state.light.source[i].ambient,
		&gc->state.light.source[i].ambient.r);
	__glScaleColorf(gc,
		&gc->state.light.source[i].diffuse,
		&gc->state.light.source[i].diffuse.r);
	__glScaleColorf(gc,
		&gc->state.light.source[i].specular,
		&gc->state.light.source[i].specular.r);
    }
    __glScaleColorf(gc,
   	    &gc->state.light.front.emissive, 
   	    &gc->state.light.front.emissive.r);
    __glScaleColorf(gc,
   	    &gc->state.light.back.emissive, 
   	    &gc->state.light.back.emissive.r);
#ifdef NT
    __glScaleColorf(gc, &gc->state.fog.color, &gc->state.fog.color.r);
    if (gc->state.fog.color.r == gc->state.fog.color.g
     && gc->state.fog.color.r == gc->state.fog.color.b)
	gc->state.fog.flags |= __GL_FOG_GRAY_RGB;
    else
        gc->state.fog.flags &= ~__GL_FOG_GRAY_RGB;

#ifdef _MCD_
        MCD_STATE_DIRTY(gc, FOG);
#endif
#endif

    __glPixelSetColorScales(gc);
}

void FASTCALL __glContextUnsetColorScales(__GLcontext *gc)
{
    GLint i;
    __GLattribute **spp;
    __GLattribute *sp;
    GLuint mask;

    for (spp = &gc->attributes.stack[0]; spp < gc->attributes.stackPointer; 
	    spp++) {
	sp = *spp;
	mask = sp->mask;

	if (mask & GL_CURRENT_BIT) {
	    if (gc->modes.rgbMode) {
		__glUnScaleColorf(gc,
		    &sp->current.rasterPos.colors[__GL_FRONTFACE].r,
		    &sp->current.rasterPos.colors[__GL_FRONTFACE]);
	    }
	}
	if (mask & GL_LIGHTING_BIT) {
	    __glUnScaleColorf(gc,
		&sp->light.model.ambient.r,
		&sp->light.model.ambient);
	    for (i=0; i<gc->constants.numberOfLights; i++) {
		__glUnScaleColorf(gc,
		    &sp->light.source[i].ambient.r,
		    &sp->light.source[i].ambient);
		__glUnScaleColorf(gc,
		    &sp->light.source[i].diffuse.r,
		    &sp->light.source[i].diffuse);
		__glUnScaleColorf(gc,
		    &sp->light.source[i].specular.r,
		    &sp->light.source[i].specular);
	    }
	    __glUnScaleColorf(gc,
		&sp->light.front.emissive.r,
		&sp->light.front.emissive);
	    __glUnScaleColorf(gc,
		&sp->light.back.emissive.r,
		&sp->light.back.emissive);
	}
#ifdef NT
        if (mask & GL_FOG_BIT)
        {
            __glUnScaleColorf(gc, &sp->fog.color.r, &sp->fog.color);
#ifdef _MCD_
            MCD_STATE_DIRTY(gc, FOG);
#endif
        }
#endif
    }

    if (gc->modes.rgbMode) {
	__glUnScaleColorf(gc,
	        &gc->state.current.rasterPos.colors[__GL_FRONTFACE].r,
		&gc->state.current.rasterPos.colors[__GL_FRONTFACE]);
    }
    __glUnScaleColorf(gc, 
	    &gc->state.light.model.ambient.r,
	    &gc->state.light.model.ambient);
    for (i=0; i<gc->constants.numberOfLights; i++) {
	__glUnScaleColorf(gc,
		&gc->state.light.source[i].ambient.r,
		&gc->state.light.source[i].ambient);
	__glUnScaleColorf(gc,
		&gc->state.light.source[i].diffuse.r,
		&gc->state.light.source[i].diffuse);
	__glUnScaleColorf(gc,
		&gc->state.light.source[i].specular.r,
		&gc->state.light.source[i].specular);
    }
    __glUnScaleColorf(gc,
   	    &gc->state.light.front.emissive.r,
   	    &gc->state.light.front.emissive);
    __glUnScaleColorf(gc,
   	    &gc->state.light.back.emissive.r,
   	    &gc->state.light.back.emissive);
#ifdef NT
    __glUnScaleColorf(gc, &gc->state.fog.color.r, &gc->state.fog.color);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, FOG);
#endif
#endif
}

/*
** Initialize all user controllable state, plus any computed state that
** is only set by user commands.  For example, light source position
** is converted immediately into eye coordinates.
**
** Any state that would be initialized to zero is not done here because
** the memory assigned to the context has already been block zeroed.
**
** NOTE: Since this function may need memory allocation, caller must
** check that gengc->errorcode is not set indicating memory allocation
** error.  If error is set, context is in an unknown state and data
** structure integrity is not guaranteed.
*/
void FASTCALL __glSoftResetContext(__GLcontext *gc)
{
    __GLlightSourceState *lss;
    __GLlightSourceMachine *lsm;
    __GLvertex *vx;
    GLint i, numLights;
    __GLfloat one = __glOne;

    /*
    ** Initialize constant values first so that they will
    ** be valid if needed by subsequent initialization steps.
    */

    if (gc->constants.alphaTestSize == 0) {
	gc->constants.alphaTestSize = 256;	/* A default */
    }
    gc->constants.alphaTableConv = (gc->constants.alphaTestSize - 1) / 
	    gc->frontBuffer.alphaScale;

    // viewportEpsilon is the smallest representable value in window
    // coordinates.  The number of fractional bits in a window
    // coordinate is known and fixed, so compute epsilon directly
    gc->constants.viewportEpsilon = 1.0f/(1 << __GL_VERTEX_FRAC_BITS);
    gc->constants.viewportAlmostHalf =
        __glHalf - gc->constants.viewportEpsilon;

    /* Allocate memory to hold variable sized things */
    numLights = gc->constants.numberOfLights;

    /* Misc machine state */
    gc->beginMode = __GL_NEED_VALIDATE;
    gc->dirtyMask = __GL_DIRTY_ALL;
    gc->validateMask = (GLuint) ~0;
    gc->attributes.stackPointer = &gc->attributes.stack[0];
    gc->clientAttributes.stackPointer = &gc->clientAttributes.stack[0];
#ifndef NT
// NT vertex allocation is done in __glEarlyInitContext.
    gc->vertex.v0 = &gc->vertex.vbuf[0];

    vx = &gc->vertex.vbuf[0];
    for (i = 0; i < __GL_NVBUF; i++, vx++) {
	vx->color = &vx->colors[__GL_FRONTFACE];
    }
#endif

    /* We need to initialize the matrix stuff early (before we handle */
    /* lighting) since we cache the modelview matrix with the light   */

    __glInitTransformState(gc);
#ifdef NT
    /* __glInitTransformState does memory allocation (incl. modelView */
    /* matrix which is needed later in this function.  If error code  */
    /* is set, we must exit.                                          */
    if (((__GLGENcontext *) gc)->errorcode)
        return;
#endif

    /* GL_LIGHTING_BIT state */
    gc->state.light.model.ambient.r = DefaultAmbient[0];
    gc->state.light.model.ambient.g = DefaultAmbient[1];
    gc->state.light.model.ambient.b = DefaultAmbient[2];
    gc->state.light.model.ambient.a = DefaultAmbient[3];
    gc->state.light.front.ambient.r = DefaultAmbient[0];
    gc->state.light.front.ambient.g = DefaultAmbient[1];
    gc->state.light.front.ambient.b = DefaultAmbient[2];
    gc->state.light.front.ambient.a = DefaultAmbient[3];
    gc->state.light.front.diffuse.r = DefaultDiffuse[0];
    gc->state.light.front.diffuse.g = DefaultDiffuse[1];
    gc->state.light.front.diffuse.b = DefaultDiffuse[2];
    gc->state.light.front.diffuse.a = DefaultDiffuse[3];
    gc->state.light.front.specular.r = DefaultBlack[0];
    gc->state.light.front.specular.g = DefaultBlack[1];
    gc->state.light.front.specular.b = DefaultBlack[2];
    gc->state.light.front.specular.a = DefaultBlack[3];
    gc->state.light.front.emissive.r = DefaultBlack[0];
    gc->state.light.front.emissive.g = DefaultBlack[1];
    gc->state.light.front.emissive.b = DefaultBlack[2];
    gc->state.light.front.emissive.a = DefaultBlack[3];
    gc->state.light.front.cmapa = 0;
    gc->state.light.front.cmapd = 1;
    gc->state.light.front.cmaps = 1;
    gc->state.light.back = gc->state.light.front;

    gc->light.front.specularExponent = -1;
    gc->light.front.specTable = NULL;
    gc->light.front.cache = NULL;
    gc->light.back.specularExponent = -1;
    gc->light.back.specTable = NULL;
    gc->light.back.cache = NULL;

    /* Initialize the individual lights */
    gc->state.light.dirtyLights = (1 << gc->constants.numberOfLights)-1;
    lss = &gc->state.light.source[0];
    lsm = &gc->light.source[0];
    for (i = 0; i < numLights; i++, lss++, lsm++) {
	lss->ambient.r = DefaultBlack[0];
	lss->ambient.g = DefaultBlack[1];
	lss->ambient.b = DefaultBlack[2];
	lss->ambient.a = DefaultBlack[3];
	if (i == 0) {
	    lss->diffuse.r = DefaultWhite[0];
	    lss->diffuse.g = DefaultWhite[1];
	    lss->diffuse.b = DefaultWhite[2];
	    lss->diffuse.a = DefaultWhite[3];
	} else {
	    lss->diffuse.r = DefaultBlack[0];
	    lss->diffuse.g = DefaultBlack[1];
	    lss->diffuse.b = DefaultBlack[2];
	    lss->diffuse.a = DefaultBlack[3];
	}
        lss->lightMatrix = gc->transform.modelView->matrix;
	lss->specular = lss->diffuse;
	lss->position.z = __glOne;
	lss->positionEye.z = __glOne;
	lsm->position.z = __glOne;
        lss->direction.z = __glMinusOne;
	lss->directionEye.z = __glMinusOne;
        lss->directionEyeNorm.z = __glMinusOne;
	lsm->direction.z = __glMinusOne;
	lss->spotLightCutOffAngle = 180;
	lss->constantAttenuation = __glOne;
	lsm->spotTable = NULL;
	lsm->spotLightExponent = -1;
	lsm->cache = NULL;
    }
    gc->state.light.colorMaterialFace = GL_FRONT_AND_BACK;
    gc->state.light.colorMaterialParam = GL_AMBIENT_AND_DIFFUSE;
    gc->state.light.shadingModel = GL_SMOOTH;

    /* GL_HINT_BIT state */
    gc->state.hints.perspectiveCorrection = GL_DONT_CARE;
    gc->state.hints.pointSmooth = GL_DONT_CARE;
    gc->state.hints.lineSmooth = GL_DONT_CARE;
    gc->state.hints.polygonSmooth = GL_DONT_CARE;
    gc->state.hints.fog = GL_DONT_CARE;
#ifdef GL_WIN_phong_shading
    gc->state.hints.phong = GL_DONT_CARE;
#endif //GL_WIN_phong_shading

    /* GL_CURRENT_BIT state */
    gc->state.current.rasterPos.window.x = gc->constants.fviewportXAdjust;
    gc->state.current.rasterPos.window.y = gc->constants.fviewportYAdjust;
    gc->state.current.rasterPos.clip.w = __glOne;
    gc->state.current.rasterPos.texture.w = __glOne;
    gc->state.current.rasterPos.color
	= &gc->state.current.rasterPos.colors[__GL_FRONTFACE];
    if (gc->modes.rgbMode) {
	gc->state.current.rasterPos.colors[__GL_FRONTFACE].r = DefaultWhite[0];
	gc->state.current.rasterPos.colors[__GL_FRONTFACE].g = DefaultWhite[1];
	gc->state.current.rasterPos.colors[__GL_FRONTFACE].b = DefaultWhite[2];
	gc->state.current.rasterPos.colors[__GL_FRONTFACE].a = DefaultWhite[3];
    } else {
	gc->state.current.rasterPos.colors[__GL_FRONTFACE].r = __glOne;
    }
    gc->state.current.validRasterPos = GL_TRUE;
    gc->state.current.edgeTag = GL_TRUE;

    /* GL_FOG_BIT state */
    gc->state.fog.mode = GL_EXP;
    gc->state.fog.density = __glOne;
#ifdef NT
    gc->state.fog.density2neg = -(__glOne);
#endif
    gc->state.fog.end = (__GLfloat) 1.0;
    gc->state.fog.flags = __GL_FOG_GRAY_RGB; // default fog color is 0,0,0,0

    /* GL_POINT_BIT state */
    gc->state.point.requestedSize = (__GLfloat) 1.0;
    gc->state.point.smoothSize = (__GLfloat) 1.0;
    gc->state.point.aliasedSize = 1;

    /* GL_LINE_BIT state */
    gc->state.line.requestedWidth = (__GLfloat) 1.0;
    gc->state.line.smoothWidth = (__GLfloat) 1.0;
    gc->state.line.aliasedWidth = 1;
    gc->state.line.stipple = 0xFFFF;
    gc->state.line.stippleRepeat = 1;

    /* GL_POLYGON_BIT state */
    gc->state.polygon.frontMode = GL_FILL;
    gc->state.polygon.backMode = GL_FILL;
    gc->state.polygon.cull = GL_BACK;
    gc->state.polygon.frontFaceDirection = GL_CCW;

    /* GL_POLYGON_STIPPLE_BIT state */
    for (i = 0; i < 4*32; i++) {
	gc->state.polygonStipple.stipple[i] = 0xFF;
    }
    for (i = 0; i < 32; i++) {
	gc->polygon.stipple[i] = 0xFFFFFFFF;
    }

    /* GL_ACCUM_BUFFER_BIT state */

    /* GL_STENCIL_BUFFER_BIT state */
    gc->state.stencil.testFunc = GL_ALWAYS;
    gc->state.stencil.mask = __GL_MAX_STENCIL_VALUE;
    gc->state.stencil.fail = GL_KEEP;
    gc->state.stencil.depthFail = GL_KEEP;
    gc->state.stencil.depthPass = GL_KEEP;
    gc->state.stencil.writeMask = __GL_MAX_STENCIL_VALUE;

    /* GL_DEPTH_BUFFER_BIT state */
    gc->state.depth.writeEnable = GL_TRUE;
    gc->state.depth.testFunc = GL_LESS;
    gc->state.depth.clear = __glOne;

    /* GL_COLOR_BUFFER_BIT state */
    gc->renderMode = GL_RENDER;
    gc->state.raster.alphaFunction = GL_ALWAYS;
    gc->state.raster.blendSrc = GL_ONE;
    gc->state.raster.blendDst = GL_ZERO;
    gc->state.raster.logicOp = GL_COPY;
    gc->state.raster.rMask = GL_TRUE;
    gc->state.raster.gMask = GL_TRUE;
    gc->state.raster.bMask = GL_TRUE;
    gc->state.raster.aMask = GL_TRUE;
    if (gc->modes.doubleBufferMode) {
	gc->state.raster.drawBuffer = GL_BACK;
    } else {
	gc->state.raster.drawBuffer = GL_FRONT;
    }
    gc->state.raster.drawBufferReturn = gc->state.raster.drawBuffer;
    gc->state.current.userColor.r = (__GLfloat) 1.0;
    gc->state.current.userColor.g = (__GLfloat) 1.0;
    gc->state.current.userColor.b = (__GLfloat) 1.0;
    gc->state.current.userColor.a = (__GLfloat) 1.0;
    gc->state.current.userColorIndex = (__GLfloat) 1.0;
    if (gc->modes.colorIndexMode) {
	gc->state.raster.writeMask = (gc)->frontBuffer.redMax;
    }
    gc->state.enables.general |= __GL_DITHER_ENABLE;

    gc->select.hit = GL_FALSE;
    gc->select.sp = gc->select.stack;

    /*
    ** Initialize larger subsystems by calling their init codes.
    */
    __glInitEvaluatorState(gc);
    __glInitTextureState(gc);
    __glInitPixelState(gc);
    __glInitLUTCache(gc);
#ifdef NT
    __glInitVertexArray(gc);
#endif
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, ALL);
#endif
}

/************************************************************************/

/*
** Free any attribute state left on the stack.  Stop at the first
** zero in the array.
*/
void FASTCALL __glFreeAttributeState(__GLcontext *gc)
{
    __GLattribute *sp, **spp;

    for (spp = &gc->attributes.stack[0];
	 spp < &gc->attributes.stack[gc->constants.maxAttribStackDepth];
	 spp++) {
	if (sp = *spp) {
	    GCFREE(gc, sp);
	} else
	    break;
    }
    GCFREE(gc, gc->attributes.stack);
}

void FASTCALL __glFreeClientAttributeState(__GLcontext *gc)
{
    __GLclientAttribute *sp, **spp;

    for (spp = &gc->clientAttributes.stack[0];
	 spp < &gc->clientAttributes.stack[gc->constants.maxClientAttribStackDepth];
	 spp++) {
	if (sp = *spp) {
	    GCFREE(gc, sp);
	} else
	    break;
    }
    GCFREE(gc, gc->clientAttributes.stack);
}

/*
** Destroy a context.  If it's the current context then the
** current context is set to GL_NULL.
*/
void FASTCALL __glDestroyContext(__GLcontext *gc)
{
    __GLcontext *oldgc;

    oldgc = (__GLcontext *)GLTEB_SRVCONTEXT();

#ifndef NT
    /* Set the global context to the one we are destroying. */
    __gl_context = gc;
#else
    // Set paTeb to NULL for now.  If we ever need to reference pa in this
    // function, then set it up appropriately.
    gc->paTeb = NULL;
    GLTEB_SET_SRVCONTEXT(gc);

    /*
    ** Need to pop all pushed attributes to free storage.
    ** Then it will be safe to delete stack entries.
    */
    if (gc->attributes.stack) {
        while (gc->attributes.stackPointer > &gc->attributes.stack[0]) {
            (void) __glInternalPopAttrib(gc, GL_TRUE);
        }
    }
    if (gc->clientAttributes.stack) {
        while (gc->clientAttributes.stackPointer > &gc->clientAttributes.stack[0]) {
            (void) __glInternalPopClientAttrib(gc, GL_FALSE, GL_TRUE);
        }
    }
#endif

    GCFREE(gc, gc->state.light.source);
    GCFREE(gc, gc->light.source);
#ifdef NT
    // now lazy allocated
    if (gc->select.stack)
#endif
	GCFREE(gc, gc->select.stack);

    GCFREE(gc, gc->state.transform.eyeClipPlanes);
    GCFREE(gc, gc->transform.modelViewStack);
    GCFREE(gc, gc->transform.projectionStack);
    GCFREE(gc, gc->transform.textureStack);
    GCFREE(gc, gc->transform.clipTemp);

    GCFREE(gc, gc->alphaTestFuncTable);
#ifdef NT
    // they are one memory allocation.
    GCFREE(gc, gc->stencilBuffer.testFuncTable);
#else
    GCFREE(gc, gc->stencilBuffer.testFuncTable);
    GCFREE(gc, gc->stencilBuffer.failOpTable);
    GCFREE(gc, gc->stencilBuffer.depthFailOpTable);
    GCFREE(gc, gc->stencilBuffer.depthPassOpTable);
#endif

    /*
    ** Free other malloc'd data associated with the context
    */
    __glFreeEvaluatorState(gc);
    __glFreePixelState(gc);
    __glFreeDlistState(gc);
    if (gc->attributes.stack)   __glFreeAttributeState(gc);
    if (gc->clientAttributes.stack)   __glFreeClientAttributeState(gc);
    if (gc->texture.texture)  __glFreeTextureState(gc);
    if (gc->light.lutCache)   __glFreeLUTCache(gc);

#ifdef NT
    // Free the vertex buffer.
    PolyArrayFreeBuffer(gc);
#endif

#if __GL_NUMBER_OF_AUX_BUFFERS > 0
    /*
    ** Free any aux color buffer records
    ** Note: Does not free the actual buffer memory, this is done elsewhere.
    */
    if (gc->auxBuffer) GCFREE(gc, gc->auxBuffer);
#endif

    /*
    ** Note: We do not free the software buffers here.  They are attached
    ** to the drawable, and is the glx extension's responsibility to free
    ** them when the drawable is destroyed.
    */

    FREE(gc);

    if (gc == oldgc) oldgc = NULL;
#ifndef NT
    __gl_context = oldgc;
#else
    GLTEB_SET_SRVCONTEXT(oldgc);
#endif
}

#ifdef NT
// See also __glSetError
void FASTCALL __glSetErrorEarly(__GLcontext *gc, GLenum code)
{
    if (gc == (__GLcontext *) NULL)
        return;

    if (!gc->error)
	gc->error = code;

    ASSERTOPENGL(gc->error == 0
        || (gc->error >= GL_INVALID_ENUM && gc->error <= GL_OUT_OF_MEMORY),
        "Bad error code in gc\n");

    DBGLEVEL2(LEVEL_INFO, "__glSetError error: %ld (0x%lX)\n", code, code);

#if 0
    try
    {
	DebugBreak();
    }
    finally
    {
    }
#endif
}
#endif // NT

void FASTCALL __glSetError(GLenum code)
{
    __GL_SETUP();

    __glSetErrorEarly(gc, code);
}

GLint APIPRIVATE __glim_RenderMode(GLenum mode)
{
    GLint rv;
    __GL_SETUP_NOT_IN_BEGIN2();

    switch (mode) {
      case GL_RENDER:
      case GL_FEEDBACK:
      case GL_SELECT:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return 0;
    }

    /* Switch out of old render mode.  Get return value. */
    switch (gc->renderMode) {
      case GL_RENDER:
	rv = 0;
	break;
      case GL_FEEDBACK:
	rv = gc->feedback.overFlowed ? -1 :
	    (GLint)((ULONG_PTR)(gc->feedback.result - gc->feedback.resultBase));
	break;
      case GL_SELECT:
	rv = gc->select.overFlowed ? -1 : gc->select.hits;
	break;
    }

    switch (mode) {
      case GL_FEEDBACK:
	if (!gc->feedback.resultBase) {
	    __glSetError(GL_INVALID_OPERATION);
	    return rv;
	}
	gc->feedback.result = gc->feedback.resultBase;
	gc->feedback.overFlowed = GL_FALSE;
	break;
      case GL_SELECT:
	if (!gc->select.stack)
	{
	    gc->select.stack = (GLuint*) GCALLOCZ
		(gc, gc->constants.maxNameStackDepth*sizeof(GLuint));
	    if (!gc->select.stack)
	    {
		__glSetError(GL_OUT_OF_MEMORY);
		return rv;
	    }
	}
	if (!gc->select.resultBase) {
	    __glSetError(GL_INVALID_OPERATION);
	    return rv;
	}
	gc->select.result = gc->select.resultBase;
	gc->select.overFlowed = GL_FALSE;
	gc->select.sp = gc->select.stack;
	gc->select.hit = GL_FALSE;
	gc->select.hits = 0;
	gc->select.z = 0;
	break;
    }
    /* Switch to new render mode - do this last! */
    if (gc->renderMode == mode) return rv;
    gc->renderMode = mode;
    __GL_DELAY_VALIDATE(gc);
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_fog.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.15 $
** $Date: 1993/10/07 18:46:43 $
*/
#include "precomp.h"
#pragma hdrstop

GLboolean FASTCALL __glFogSpan(__GLcontext *gc)
{
    __GLcolor *cp, *fogColor;
    __GLfloat f, oneMinusFog, fog;
    GLint w;
    GLboolean bGrayFog;

    w = gc->polygon.shader.length;

    f = gc->polygon.shader.frag.f;
    cp = gc->polygon.shader.colors;
    fogColor = &gc->state.fog.color;
#ifdef NT
    bGrayFog = !gc->modes.colorIndexMode
		&& (gc->state.fog.flags & __GL_FOG_GRAY_RGB);
    if (bGrayFog)
    {
	while (--w >= 0)
	{
	    __GLfloat delta;
	    /* clamp fog value */
	    fog = f;
	    if (fog < __glZero) fog = __glZero;
	    else if (fog > __glOne) fog = __glOne;
	    oneMinusFog = __glOne - fog;
	    delta = oneMinusFog * fogColor->r;

	    /* Blend incoming color against the fog color */
	    cp->r = fog * cp->r + delta;
	    cp->g = fog * cp->g + delta;
	    cp->b = fog * cp->b + delta;

	    f += gc->polygon.shader.dfdx;
	    cp++;
	}
    }
    else
#endif
	while (--w >= 0) {
	    /* clamp fog value */
	    fog = f;
	    if (fog < __glZero) fog = __glZero;
	    else if (fog > __glOne) fog = __glOne;
	    oneMinusFog = __glOne - fog;

	    /* Blend incoming color against the fog color */
	    if (gc->modes.colorIndexMode) {
		cp->r = cp->r + oneMinusFog * gc->state.fog.index;
	    } else {
		cp->r = fog * cp->r + oneMinusFog * fogColor->r;
		cp->g = fog * cp->g + oneMinusFog * fogColor->g;
		cp->b = fog * cp->b + oneMinusFog * fogColor->b;
	    }

	    f += gc->polygon.shader.dfdx;
	    cp++;
	}

    return GL_FALSE;
}

GLboolean FASTCALL __glFogStippledSpan(__GLcontext *gc)
{
    __GLstippleWord bit, inMask, *sp;
    __GLcolor *cp, *fogColor;
    __GLfloat f, oneMinusFog, fog;
    GLint count;
    GLint w;
    GLboolean bGrayFog;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    f = gc->polygon.shader.frag.f;
    cp = gc->polygon.shader.colors;
    fogColor = &gc->state.fog.color;
#ifdef NT
    bGrayFog = (gc->state.fog.flags & __GL_FOG_GRAY_RGB) ? GL_TRUE : GL_FALSE;
#endif
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp++;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		/* clamp fog value */
		fog = f;
		if (fog < __glZero) fog = __glZero;
		else if (fog > __glOne) fog = __glOne;
		oneMinusFog = __glOne - fog;

		/* Blend incoming color against the fog color */
		if (gc->modes.colorIndexMode) {
		    cp->r = cp->r + oneMinusFog * gc->state.fog.index;
		} else {
#ifdef NT
		    if (bGrayFog)
		    {
			__GLfloat delta = oneMinusFog * fogColor->r;

			cp->r = fog * cp->r + delta;
			cp->g = fog * cp->g + delta;
			cp->b = fog * cp->b + delta;
		    }
		    else
#endif
		    {
			cp->r = fog * cp->r + oneMinusFog * fogColor->r;
			cp->g = fog * cp->g + oneMinusFog * fogColor->g;
			cp->b = fog * cp->b + oneMinusFog * fogColor->b;
		    }
		}
	    }
	    f += gc->polygon.shader.dfdx;
	    cp++;
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
    }

    return GL_FALSE;
}

/************************************************************************/

GLboolean FASTCALL __glFogSpanSlow(__GLcontext *gc)
{
    __GLcolor *cp, *fogColor;
    __GLfloat f, oneMinusFog, fog, eyeZ;
    __GLfloat density, density2neg, end;
    GLint w;
    GLboolean bGrayFog;

    w = gc->polygon.shader.length;

    f = gc->polygon.shader.frag.f;
    cp = gc->polygon.shader.colors;
    fogColor = &gc->state.fog.color;
    density = gc->state.fog.density;
#ifdef NT
    bGrayFog = (gc->state.fog.flags & __GL_FOG_GRAY_RGB) ? GL_TRUE : GL_FALSE;
    density2neg = gc->state.fog.density2neg;
#else
    density2 = density * density;
    start = gc->state.fog.start;
#endif
    end = gc->state.fog.end;
    while (--w >= 0) {
#ifdef NT
	/* Compute fog value */
	eyeZ = f;
	switch (gc->state.fog.mode) {
	  case GL_EXP:
	    if (eyeZ < __glZero)
		fog = __GL_POWF(__glE,  density * eyeZ);
	    else
		fog = __GL_POWF(__glE, -density * eyeZ);
	    /* clamp fog value */
	    if (fog > __glOne) fog = __glOne;
	    break;
	  case GL_EXP2:
	    fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);
	    /* clamp fog value */
	    if (fog > __glOne) fog = __glOne;
	    break;
	  case GL_LINEAR:
	    if (eyeZ < __glZero)
		fog = (end + eyeZ) * gc->state.fog.oneOverEMinusS;
	    else
		fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	    /* clamp fog value */
	    if (fog < __glZero) fog = __glZero;
	    else if (fog > __glOne) fog = __glOne;
	    break;
	}
#else
	/* Compute fog value */
	eyeZ = f;
	if (eyeZ < __glZero) eyeZ = -eyeZ;
	switch (gc->state.fog.mode) {
	  case GL_EXP:
	    fog = __GL_POWF(__glE, -density * eyeZ);
	    break;
	  case GL_EXP2:
	    fog = __GL_POWF(__glE, -(density2 * eyeZ * eyeZ));
	    break;
	  case GL_LINEAR:
	    fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	    break;
	}

	/* clamp fog value */
	if (fog < __glZero) fog = __glZero;
	else if (fog > __glOne) fog = __glOne;
#endif
	oneMinusFog = __glOne - fog;

	/* Blend incoming color against the fog color */
	if (gc->modes.colorIndexMode) {
	    cp->r = cp->r + oneMinusFog * gc->state.fog.index;
	} else {
#ifdef NT
    	    if (bGrayFog)
	    {
		__GLfloat delta = oneMinusFog * fogColor->r;

		cp->r = fog * cp->r + delta;
		cp->g = fog * cp->g + delta;
		cp->b = fog * cp->b + delta;
	    }
	    else
#endif
	    {
		cp->r = fog * cp->r + oneMinusFog * fogColor->r;
		cp->g = fog * cp->g + oneMinusFog * fogColor->g;
		cp->b = fog * cp->b + oneMinusFog * fogColor->b;
	    }
	}

	f += gc->polygon.shader.dfdx;
	cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glFogStippledSpanSlow(__GLcontext *gc)
{
    __GLstippleWord bit, inMask, *sp;
    __GLcolor *cp, *fogColor;
    __GLfloat f, oneMinusFog, fog, eyeZ;
    __GLfloat density, density2neg, end;
    GLint count;
    GLint w;
    GLboolean bGrayFog;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    f = gc->polygon.shader.frag.f;
    cp = gc->polygon.shader.colors;
    fogColor = &gc->state.fog.color;
#ifdef NT
    bGrayFog = (gc->state.fog.flags & __GL_FOG_GRAY_RGB) ? GL_TRUE : GL_FALSE;
#endif
    density = gc->state.fog.density;
#ifdef NT
    density2neg = gc->state.fog.density2neg;
#else
    density2 = density * density;
    start = gc->state.fog.start;
#endif
    end = gc->state.fog.end;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp++;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
#ifdef NT
		/* Compute fog value */
		eyeZ = f;
		switch (gc->state.fog.mode) {
		  case GL_EXP:
		    if (eyeZ < __glZero)
			fog = __GL_POWF(__glE,  density * eyeZ);
		    else
			fog = __GL_POWF(__glE, -density * eyeZ);
		    /* Clamp resulting fog value */
		    if (fog > __glOne) fog = __glOne;
		    break;
		  case GL_EXP2:
		    fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);
		    /* Clamp resulting fog value */
		    if (fog > __glOne) fog = __glOne;
		    break;
		  case GL_LINEAR:
		    if (eyeZ < __glZero)
			fog = (end + eyeZ) * gc->state.fog.oneOverEMinusS;
		    else
			fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
		    /* Clamp resulting fog value */
		    if (fog < __glZero) fog = __glZero;
		    else if (fog > __glOne) fog = __glOne;
		    break;
		}
#else
		/* Compute fog value */
		eyeZ = f;
		if (eyeZ < __glZero) eyeZ = -eyeZ;
		switch (gc->state.fog.mode) {
		  case GL_EXP:
		    fog = __GL_POWF(__glE, -density * eyeZ);
		    break;
		  case GL_EXP2:
		    fog = __GL_POWF(__glE, -(density2 * eyeZ * eyeZ));
		    break;
		  case GL_LINEAR:
		    fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
		    break;
		}

		/* Clamp resulting fog value */
		if (fog < __glZero) fog = __glZero;
		else if (fog > __glOne) fog = __glOne;
#endif
		oneMinusFog = __glOne - fog;

		/* Blend incoming color against the fog color */
		if (gc->modes.colorIndexMode) {
		    cp->r = cp->r + oneMinusFog * gc->state.fog.index;
		} else {
#ifdef NT
		    if (bGrayFog)
		    {
			__GLfloat delta = oneMinusFog * fogColor->r;

			cp->r = fog * cp->r + delta;
			cp->g = fog * cp->g + delta;
			cp->b = fog * cp->b + delta;
		    }
		    else
#endif
		    {
			cp->r = fog * cp->r + oneMinusFog * fogColor->r;
			cp->g = fog * cp->g + oneMinusFog * fogColor->g;
			cp->b = fog * cp->b + oneMinusFog * fogColor->b;
		    }
		}
	    }
	    f += gc->polygon.shader.dfdx;
	    cp++;
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
    }

    return GL_FALSE;
}

/************************************************************************/

/*
** Compute the fog value given an eyeZ.  Then blend into fragment.
** This is used when fragment fogging is done (GL_FOG_HINT == GL_NICEST)
** or by the point rendering routines.
** NOTE: the code below has the -eyeZ factored out.
*/
void __glFogFragmentSlow(__GLcontext *gc, __GLfragment *frag, __GLfloat eyeZ)
{
    __GLfloat fog, oneMinusFog, density, density2neg, end;
    __GLcolor *fogColor;

#ifdef NT
    switch (gc->state.fog.mode) {
      case GL_EXP:
	density = gc->state.fog.density;
	if (eyeZ < __glZero)
	    fog = __GL_POWF(__glE,  density * eyeZ);
	else
	    fog = __GL_POWF(__glE, -density * eyeZ);
	/* clamp fog value */
	if (fog > __glOne) fog = __glOne;
	break;
      case GL_EXP2:
	density2neg = gc->state.fog.density2neg;
	fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);
	/* clamp fog value */
	if (fog > __glOne) fog = __glOne;
	break;
      case GL_LINEAR:
	end = gc->state.fog.end;
	if (eyeZ < __glZero)
	    fog = (end + eyeZ) * gc->state.fog.oneOverEMinusS;
	else
	    fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	/* clamp fog value */
	if (fog < __glZero) fog = __glZero;
	else if (fog > __glOne) fog = __glOne;
	break;
    }
#else
    if (eyeZ < __glZero) eyeZ = -eyeZ;

    switch (gc->state.fog.mode) {
      case GL_EXP:
	density = gc->state.fog.density;
	fog = __GL_POWF(__glE, -density * eyeZ);
	break;
      case GL_EXP2:
	density = gc->state.fog.density;
	fog = __GL_POWF(__glE, -(density * eyeZ * density * eyeZ));
	break;
      case GL_LINEAR:
	end = gc->state.fog.end;
	fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	break;
    }

    /*
    ** clamp fog value
    */
    if (fog < __glZero)
	fog = __glZero;
    else if (fog > __glOne)
	fog = __glOne;
#endif
    oneMinusFog = __glOne - fog;

    /*
    ** Blend incoming color against the fog color
    */
    fogColor = &gc->state.fog.color;
    if (gc->modes.colorIndexMode) {
	frag->color.r = frag->color.r + oneMinusFog * gc->state.fog.index;
    } else {
#ifdef NT
	if (gc->state.fog.flags & __GL_FOG_GRAY_RGB)
	{
	    __GLfloat delta = oneMinusFog * fogColor->r;

	    frag->color.r = fog * frag->color.r + delta;
	    frag->color.g = fog * frag->color.g + delta;
	    frag->color.b = fog * frag->color.b + delta;
	}
	else
#endif
	{
	    frag->color.r = fog * frag->color.r + oneMinusFog * fogColor->r;
	    frag->color.g = fog * frag->color.g + oneMinusFog * fogColor->g;
	    frag->color.b = fog * frag->color.b + oneMinusFog * fogColor->b;
	}
    }
}


/*
** Compute generic fog value for vertex.
*/
__GLfloat FASTCALL __glFogVertex(__GLcontext *gc, __GLvertex *vx)
{
    __GLfloat eyeZ, fog, density, density2neg, end;

    eyeZ = vx->eyeZ;
#ifdef NT
    switch (gc->state.fog.mode) {
      case GL_EXP:
	density = gc->state.fog.density;
	if (eyeZ < __glZero)
	    fog = __GL_POWF(__glE,  density * eyeZ);
	else
	    fog = __GL_POWF(__glE, -density * eyeZ);
	/* clamp fog value */
	if (fog > __glOne) fog = __glOne;
	break;
      case GL_EXP2:
	density2neg = gc->state.fog.density2neg;
	fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);
	/* clamp fog value */
	if (fog > __glOne) fog = __glOne;
	break;
      case GL_LINEAR:
	end = gc->state.fog.end;
	if (eyeZ < __glZero)
	    fog = (end + eyeZ) * gc->state.fog.oneOverEMinusS;
	else
	    fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	/* clamp fog value */
	if (fog < __glZero) fog = __glZero;
	else if (fog > __glOne) fog = __glOne;
	break;
    }
#else
    if (eyeZ < __glZero) eyeZ = -eyeZ;

    switch (gc->state.fog.mode) {
      case GL_EXP:
	density = gc->state.fog.density;
	fog = __GL_POWF(__glE, -density * eyeZ);
	break;
      case GL_EXP2:
	density = gc->state.fog.density;
	fog = __GL_POWF(__glE, -(density * eyeZ * density * eyeZ));
	break;
      case GL_LINEAR:
	end = gc->state.fog.end;
	fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
	break;
    }

    /*
    ** Since this routine is called when we are doing slow fog, we can
    ** safely clamp the fog value here. 
    */
    if (fog < __glZero)
	fog = __glZero;
    else if (fog > __glOne)
	fog = __glOne;
#endif
    
    return fog;
}

/*
** Compute linear fog value for vertex
*/
__GLfloat FASTCALL __glFogVertexLinear(__GLcontext *gc, __GLvertex *vx)
{
    __GLfloat eyeZ, fog, end;

    eyeZ = vx->eyeZ;
#ifdef NT
    end = gc->state.fog.end;
    if (eyeZ < __glZero)
	fog = (end + eyeZ) * gc->state.fog.oneOverEMinusS;
    else
	fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
#else
    if (eyeZ < __glZero) eyeZ = -eyeZ;

    end = gc->state.fog.end;
    fog = (end - eyeZ) * gc->state.fog.oneOverEMinusS;
#endif

    if (fog < __glZero)
	fog = __glZero;
    else if (fog > __glOne)
	fog = __glOne;
    
    return fog;
}


/*
** Compute the fogged color given an incoming color and a fog value.
*/
void __glFogColorSlow(__GLcontext *gc, __GLcolor *out, __GLcolor *in, 
		      __GLfloat fog)
{
    __GLcolor *fogColor;
    __GLfloat oneMinusFog;
    __GLfloat r, g, b;

    oneMinusFog = __glOne - fog;

    /*
    ** Blend incoming color against the fog color
    */
    fogColor = &gc->state.fog.color;
    if (gc->modes.colorIndexMode) {
	out->r = in->r + oneMinusFog * gc->state.fog.index;
    } else {
#ifdef NT
	if (gc->state.fog.flags & __GL_FOG_GRAY_RGB)
	{
	    __GLfloat delta = oneMinusFog * fogColor->r;

	    out->r = fog * in->r + delta;
	    out->g = fog * in->g + delta;
	    out->b = fog * in->b + delta;
	}
	else
#endif
	{
	    /*
	    ** The following is coded like this to give the instruction scheduler
	    ** a hand.
	    */
	    r = fog * in->r;
	    g = fog * in->g;
	    b = fog * in->b;
	    r += oneMinusFog * fogColor->r;
	    g += oneMinusFog * fogColor->g;
	    b += oneMinusFog * fogColor->b;
	    out->r = r;
	    out->g = g;
	    out->b = b;
	}
	out->a = in->a;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_feedb.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.21 $
** $Date: 1993/09/23 16:37:59 $
*/
#include "precomp.h"
#pragma hdrstop

void APIPRIVATE __glim_FeedbackBuffer(GLsizei bufferLength, GLenum type, GLfloat buffer[])
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((type < GL_2D) || (type > GL_4D_COLOR_TEXTURE)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if (bufferLength < 0) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
    if (gc->renderMode == GL_FEEDBACK) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }
    gc->feedback.resultBase = buffer;
    gc->feedback.result = buffer;
    gc->feedback.resultLength = bufferLength;
    gc->feedback.overFlowed = GL_FALSE;
    gc->feedback.type = type;
}

void APIPRIVATE __glim_PassThrough(GLfloat element)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->renderMode == GL_FEEDBACK) {
	__glFeedbackTag(gc, GL_PASS_THROUGH_TOKEN);
	__glFeedbackTag(gc, element);
    }
}

/************************************************************************/

void __glFeedbackTag(__GLcontext *gc, GLfloat f)
{
    if (!gc->feedback.overFlowed) {
	if (gc->feedback.result >=
		    gc->feedback.resultBase + gc->feedback.resultLength) {
	    gc->feedback.overFlowed = GL_TRUE;
	} else {
	    gc->feedback.result[0] = f;
	    gc->feedback.result = gc->feedback.result + 1;
	}
    }
}

static void FASTCALL feedback(__GLcontext *gc, __GLvertex *v)
{
    GLenum type = gc->feedback.type;

#ifdef NT
// Do coordinates
    __glFeedbackTag(gc, v->window.x - gc->constants.fviewportXAdjust);
    if (gc->constants.yInverted)
	__glFeedbackTag(gc, (gc->constants.height - 
                             (v->window.y - gc->constants.fviewportYAdjust)));
    else
	__glFeedbackTag(gc, v->window.y - gc->constants.fviewportYAdjust);
    if (type != GL_2D)
	__glFeedbackTag(gc, v->window.z / gc->depthBuffer.scale);
    /*
    ** NOTE: return clip.w, as window.w has no spec defined meaning.
    ** It is true that this implementation uses window.w, but thats
    ** something different.
    */
    if (type == GL_4D_COLOR_TEXTURE)
	__glFeedbackTag(gc, v->clip.w);
#else
    switch (type) {
      case GL_2D:
	__glFeedbackTag(gc, v->window.x - gc->constants.fviewportXAdjust);
	if (gc->constants.yInverted) {
	    __glFeedbackTag(gc, (gc->constants.height - 
		    (v->window.y - gc->constants.fviewportYAdjust)) - 
		    gc->constants.viewportEpsilon);
	} else {
	    __glFeedbackTag(gc, v->window.y - gc->constants.fviewportYAdjust);
	}
	break;
      case GL_3D:
      case GL_3D_COLOR:
      case GL_3D_COLOR_TEXTURE:
	__glFeedbackTag(gc, v->window.x - gc->constants.fviewportXAdjust);
	if (gc->constants.yInverted) {
	    __glFeedbackTag(gc, (gc->constants.height - 
		    (v->window.y - gc->constants.fviewportYAdjust)) - 
		    gc->constants.viewportEpsilon);
	} else {
	    __glFeedbackTag(gc, v->window.y - gc->constants.fviewportYAdjust);
	}
	__glFeedbackTag(gc, v->window.z / gc->depthBuffer.scale);
	break;
      case GL_4D_COLOR_TEXTURE:
	__glFeedbackTag(gc, v->window.x - gc->constants.fviewportXAdjust);
	if (gc->constants.yInverted) {
	    __glFeedbackTag(gc, (gc->constants.height - 
		    (v->window.y - gc->constants.fviewportYAdjust)) - 
		    gc->constants.viewportEpsilon);
	} else {
	    __glFeedbackTag(gc, v->window.y - gc->constants.fviewportYAdjust);
	}
	__glFeedbackTag(gc, v->window.z / gc->depthBuffer.scale);
	/*
	** NOTE: return clip.w, as window.w has no spec defined meaning.
	** It is true that this implementation uses window.w, but thats
	** something different.
	*/
	__glFeedbackTag(gc, v->clip.w);
	break;
    }
#endif
    switch (type) {
      case GL_3D_COLOR:
      case GL_3D_COLOR_TEXTURE:
      case GL_4D_COLOR_TEXTURE:
	{
	    __GLcolor *c = v->color;
	    if (gc->modes.rgbMode) {
		__glFeedbackTag(gc, c->r * gc->oneOverRedVertexScale);
		__glFeedbackTag(gc, c->g * gc->oneOverGreenVertexScale);
		__glFeedbackTag(gc, c->b * gc->oneOverBlueVertexScale);
		__glFeedbackTag(gc, c->a * gc->oneOverAlphaVertexScale);
	    } else {
		__glFeedbackTag(gc, c->r);
	    }
	}
	break;
      case GL_2D:
      case GL_3D:
        break;
    }
    switch (type) {
      case GL_3D_COLOR_TEXTURE:
      case GL_4D_COLOR_TEXTURE:
	__glFeedbackTag(gc, v->texture.x);
	__glFeedbackTag(gc, v->texture.y);
	__glFeedbackTag(gc, v->texture.z);
	__glFeedbackTag(gc, v->texture.w);
	break;
      case GL_2D:
      case GL_3D:
      case GL_3D_COLOR:
	break;
    }
}

void FASTCALL __glFeedbackCopyPixels(__GLcontext *gc, __GLvertex *vx)
{
    __glFeedbackTag(gc, GL_COPY_PIXEL_TOKEN);
    feedback(gc, vx);
}

void FASTCALL __glFeedbackDrawPixels(__GLcontext *gc, __GLvertex *vx)
{
    __glFeedbackTag(gc, GL_DRAW_PIXEL_TOKEN);
    feedback(gc, vx);
}

void FASTCALL __glFeedbackBitmap(__GLcontext *gc, __GLvertex *vx)
{
    __glFeedbackTag(gc, GL_BITMAP_TOKEN);
    feedback(gc, vx);
}

/* feedback version of renderPoint proc */
void FASTCALL __glFeedbackPoint(__GLcontext *gc, __GLvertex *vx)
{
    __glFeedbackTag(gc, GL_POINT_TOKEN);
    feedback(gc, vx);
}

/* feedback version of renderLine proc */
void FASTCALL __glFeedbackLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
                   GLuint flags)
{
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLcolor *oacp;

    oacp = a->color;
    if (!(modeFlags & __GL_SHADE_SMOOTH_LIGHT)
#ifdef GL_WIN_phong_shading
        && !(modeFlags & __GL_SHADE_PHONG)
#endif //GL_WIN_phong_shading
        ) {
        a->color = b->color;
    }

    if (gc->line.notResetStipple) {
        __glFeedbackTag(gc, GL_LINE_TOKEN);
    } else {
        gc->line.notResetStipple = GL_TRUE;
        __glFeedbackTag(gc, GL_LINE_RESET_TOKEN);
    }
    feedback(gc, a);
    feedback(gc, b);

    a->color = oacp;
}

/* feedback version of renderTriangle proc */
void FASTCALL __glFeedbackTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			  __GLvertex *c)
{
    __GLfloat dxAC, dxBC, dyAC, dyBC, area;
    GLboolean ccw;
    GLint face;
    GLuint modeFlags;
#ifdef SGI
// not used
    GLboolean first;
    __GLfloat x, y, z, wInv;
    __GLfloat vpXScale, vpYScale, vpZScale;
    __GLfloat vpXCenter, vpYCenter, vpZCenter;
    __GLviewport *vp;

    /* Compute window coordinates first, if not already done */
    vp = &gc->state.viewport;
    vpXCenter = vp->xCenter;
    vpYCenter = vp->yCenter;
    vpZCenter = vp->zCenter;
    vpXScale = vp->xScale;
    vpYScale = vp->yScale;
    vpZScale = vp->zScale;
#endif

    /* Compute signed area of the triangle */
    dxAC = a->window.x - c->window.x;
    dxBC = b->window.x - c->window.x;
    dyAC = a->window.y - c->window.y;
    dyBC = b->window.y - c->window.y;
    area = dxAC * dyBC - dxBC * dyAC;
    ccw = area >= __glZero;

    /*
    ** Figure out if face is culled or not.  The face check needs to be
    ** based on the vertex winding before sorting.  This code uses the
    ** reversed flag to invert the sense of ccw - an xor accomplishes
    ** this conversion without an if test.
    **
    ** 		ccw	reversed		xor
    ** 		---	--------		---
    ** 		0	0			0 (remain !ccw)
    ** 		1	0			1 (remain ccw)
    ** 		0	1			1 (become ccw)
    ** 		1	1			0 (become cw)
    */
    face = gc->polygon.face[ccw];
    if (face == gc->polygon.cullFace) {
	/* Culled */
	return;
    }

#ifdef NT
    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
    if (modeFlags & __GL_SHADE_SMOOTH_LIGHT)
    {	/* Smooth shading */
	if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
	{
	    a->color++;
	    b->color++;
	    c->color++;
	}
    }
    else
    {	/* Flat shading */
	__GLvertex *pv = gc->vertex.provoking;
	if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
	    pv->color++;
	a->color = pv->color;
	b->color = pv->color;
	c->color = pv->color;
    }
#else
    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
    needs = gc->vertex.needs;
    if (gc->state.light.shadingModel == GL_FLAT) {
	__GLvertex *pv = gc->vertex.provoking;
	GLuint pvneeds;
	GLuint faceNeeds;
	GLint colorFace;

	if (modeFlags & __GL_SHADE_TWOSIDED) {
	    colorFace = face;
	    faceNeeds = gc->vertex.faceNeeds[face];
	} else {
	    colorFace = __GL_FRONTFACE;
	    faceNeeds = gc->vertex.faceNeeds[__GL_FRONTFACE];
	}

	pv->color = &pv->colors[colorFace];
	a->color = pv->color;
	b->color = pv->color;
	c->color = pv->color;
	pvneeds = faceNeeds & (__GL_HAS_LIGHTING |
		__GL_HAS_FRONT_COLOR | __GL_HAS_BACK_COLOR);
	if (~pv->has & pvneeds) {
	    (*pv->validate)(gc, pv, pvneeds);
	}
    } else {
	GLuint faceNeeds;
	GLint colorFace;

	if (modeFlags & __GL_SHADE_TWOSIDED) {
	    colorFace = face;
	    needs |= gc->vertex.faceNeeds[face];
	} else {
	    colorFace = __GL_FRONTFACE;
	    needs |= gc->vertex.faceNeeds[__GL_FRONTFACE];
	}

	a->color = &a->colors[colorFace];
	b->color = &b->colors[colorFace];
	c->color = &c->colors[colorFace];
    }
    if (~a->has & needs) (*a->validate)(gc, a, needs);
    if (~b->has & needs) (*b->validate)(gc, b, needs);
    if (~c->has & needs) (*c->validate)(gc, c, needs);
#endif

    /* Deal with polygon face modes */
    switch (gc->polygon.mode[face]) {
      case __GL_POLYGON_MODE_POINT:
#ifdef NT
	if (a->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackPoint(gc, a);
	if (b->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackPoint(gc, b);
	if (c->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackPoint(gc, c);
	break;
#else
	if (a->boundaryEdge) {
	    __glFeedbackTag(gc, GL_POINT_TOKEN);
	    feedback(gc, a);
	}
	if (b->boundaryEdge) {
	    __glFeedbackTag(gc, GL_POINT_TOKEN);
	    feedback(gc, b);
	}
	if (c->boundaryEdge) {
	    __glFeedbackTag(gc, GL_POINT_TOKEN);
	    feedback(gc, c);
	}
	break;
#endif
      case __GL_POLYGON_MODE_LINE:
#ifdef NT
	if (a->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackLine(gc, a, b, 0);
	if (b->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackLine(gc, b, c, 0);
	if (c->has & __GL_HAS_EDGEFLAG_BOUNDARY) __glFeedbackLine(gc, c, a, 0);
	break;
#else
	if (a->boundaryEdge) {
	    if (!gc->line.notResetStipple) {
		gc->line.notResetStipple = GL_TRUE;
		__glFeedbackTag(gc, GL_LINE_RESET_TOKEN);
	    } else {
		__glFeedbackTag(gc, GL_LINE_TOKEN);
	    }
	    feedback(gc, a);
	    feedback(gc, b);
	}
	if (b->boundaryEdge) {
	    if (!gc->line.notResetStipple) {
		gc->line.notResetStipple = GL_TRUE;
		__glFeedbackTag(gc, GL_LINE_RESET_TOKEN);
	    } else {
		__glFeedbackTag(gc, GL_LINE_TOKEN);
	    }
	    feedback(gc, b);
	    feedback(gc, c);
	}
	if (c->boundaryEdge) {
	    if (!gc->line.notResetStipple) {
		gc->line.notResetStipple = GL_TRUE;
		__glFeedbackTag(gc, GL_LINE_RESET_TOKEN);
	    } else {
		__glFeedbackTag(gc, GL_LINE_TOKEN);
	    }
	    feedback(gc, c);
	    feedback(gc, a);
	}
	break;
#endif
      case __GL_POLYGON_MODE_FILL:
	__glFeedbackTag(gc, GL_POLYGON_TOKEN);
	__glFeedbackTag(gc, 3);
	feedback(gc, a);
	feedback(gc, b);
	feedback(gc, c);
	break;
    }

    /* Restore color pointers */
    a->color = &a->colors[__GL_FRONTFACE];
    b->color = &b->colors[__GL_FRONTFACE];
    c->color = &c->colors[__GL_FRONTFACE];
    if (gc->state.light.shadingModel == GL_FLAT) {
	__GLvertex *pv = gc->vertex.provoking;

	pv->color = &pv->colors[__GL_FRONTFACE];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_globa.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#ifdef NT
// Disable long to float conversion warning.
#pragma warning (disable:4244)
#endif // NT

__GLcoord __gl_frustumClipPlanes[6] = {
    {  1.0,  0.0,  0.0,  1.0 },		/* left */
    { -1.0,  0.0,  0.0,  1.0 },		/* right */
    {  0.0,  1.0,  0.0,  1.0 },		/* bottom */
    {  0.0, -1.0,  0.0,  1.0 },		/* top */
    {  0.0,  0.0,  1.0,  1.0 },		/* zNear */
    {  0.0,  0.0, -1.0,  1.0 },		/* zFar */
};

GLbyte __glDitherTable[16] = {
    0, 8, 2, 10,
    12, 4, 14, 6,
    3, 11, 1, 9,
    15, 7, 13, 5,
};

// Clip coordinate offsets for frustum clipping
GLuint __glFrustumOffsets[6] =
{
    FIELD_OFFSET(__GLvertex, clip.x),
    FIELD_OFFSET(__GLvertex, clip.x),
    FIELD_OFFSET(__GLvertex, clip.y),
    FIELD_OFFSET(__GLvertex, clip.y),
    FIELD_OFFSET(__GLvertex, clip.z),
    FIELD_OFFSET(__GLvertex, clip.z)
};

#ifdef NT
#if defined(_X86_) || defined(_ALPHA_) || defined(_MIPS_) || defined(_PPC_)

const double __glDoubleTwo            = ((double) 2.0);
const double __glDoubleMinusTwo       = ((double) -2.0);

// On Alpha, register f31 is always read as zero.
#ifndef _ALPHA_
const __GLfloat __glZero              = ((__GLfloat) 0.0);
#endif

const __GLfloat __glOne               = ((__GLfloat) 1.0);
const __GLfloat __glMinusOne          = ((__GLfloat) -1.0);
const __GLfloat __glHalf              = ((__GLfloat) 0.5);
const __GLfloat __glDegreesToRadians  = ((__GLfloat) 3.14159265358979323846 /
                                         (__GLfloat) 180.0);
const __GLfloat __glPi                = ((__GLfloat) 3.14159265358979323846);
const __GLfloat __glSqrt2             = ((__GLfloat) 1.41421356237309504880);
const __GLfloat __glE                 = ((__GLfloat) 2.7182818284590452354);
const __GLfloat __glVal128            = ((__GLfloat) 128.0);
const __GLfloat __glVal255            = ((__GLfloat) 255.0);
const __GLfloat __glOneOver255        = ((__GLfloat) (1.0 / 255.0));
const __GLfloat __glVal256            = ((__GLfloat) 256.0);
const __GLfloat __glOneOver512        = ((__GLfloat) (1.0 / 512.0));
const __GLfloat __glVal768            = ((__GLfloat) 768.0);
const __GLfloat __glVal65535          = ((__GLfloat) 65535.0);
const __GLfloat __glVal65536          = ((__GLfloat) 65536.0);
const __GLfloat __glTexSubDiv         = ((__GLfloat) TEX_SUBDIV);
const __GLfloat __glOneOver65535      = ((__GLfloat) (1.0 / 65535.0));
const __GLfloat __glVal2147483648     = ((__GLfloat) 2147483648.0);
/*
** Not quite 2^31-1 because of possible floating point errors.  4294965000
** is a much safer number to use.
*/
const __GLfloat __glVal4294965000     =  ((__GLfloat) (4294965000.0));
const __GLfloat __glOneOver4294965000 =  ((__GLfloat) (1.0 / 4294965000.0));

#endif // Real values
#endif // NT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_get.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include <devlock.h>

#define __GL_FLOAT	0	/* __GLfloat */
#define __GL_FLOAT32	1	/* api 32 bit float */
#define __GL_FLOAT64	2	/* api 64 bit float */
#define __GL_INT32	3	/* api 32 bit int */
#define __GL_BOOLEAN	4	/* api 8 bit boolean */
#define __GL_COLOR	5	/* unscaled color in __GLfloat */
#define __GL_SCOLOR	6	/* scaled color in __GLfloat */

void __glConvertResult(__GLcontext *gc, GLint fromType, const void *rawdata,
		       GLint toType, void *result, GLint size);

void APIPRIVATE __glim_GetTexEnvfv(GLenum target,
			GLenum pname, GLfloat v[])
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (target != GL_TEXTURE_ENV) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_ENV_MODE:
	v[0] = gc->state.texture.env[0].mode;
	break;
      case GL_TEXTURE_ENV_COLOR:
	__glUnScaleColorf(gc, v, &gc->state.texture.env[0].color);
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetTexEnviv(GLenum target,
			 GLenum pname, GLint v[])	
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (target != GL_TEXTURE_ENV) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_ENV_MODE:
	v[0] = gc->state.texture.env[0].mode;
	break;
      case GL_TEXTURE_ENV_COLOR:
	__glUnScaleColori(gc, v, &gc->state.texture.env[0].color);
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetTexGenfv(GLenum coord, GLenum pname,
			GLfloat v[])
{
    __GLtextureCoordState* tcs;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (coord) {
      case GL_S:
	tcs = &gc->state.texture.s;
	break;
      case GL_T:
	tcs = &gc->state.texture.t;
	break;
      case GL_R:
	tcs = &gc->state.texture.r;
	break;
      case GL_Q:
	tcs = &gc->state.texture.q;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_GEN_MODE:
	v[0] = tcs->mode;
	break;
      case GL_OBJECT_PLANE:
	v[0] = tcs->objectPlaneEquation.x;
	v[1] = tcs->objectPlaneEquation.y;
	v[2] = tcs->objectPlaneEquation.z;
	v[3] = tcs->objectPlaneEquation.w;
	break;
      case GL_EYE_PLANE:
	v[0] = tcs->eyePlaneEquation.x;
	v[1] = tcs->eyePlaneEquation.y;
	v[2] = tcs->eyePlaneEquation.z;
	v[3] = tcs->eyePlaneEquation.w;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetTexGendv(GLenum coord, GLenum pname,
			GLdouble v[])
{
    __GLtextureCoordState* tcs;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (coord) {
      case GL_S:
	tcs = &gc->state.texture.s;
	break;
      case GL_T:
	tcs = &gc->state.texture.t;
	break;
      case GL_R:
	tcs = &gc->state.texture.r;
	break;
      case GL_Q:
	tcs = &gc->state.texture.q;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_GEN_MODE:
	v[0] = tcs->mode;
	break;
      case GL_OBJECT_PLANE:
	v[0] = tcs->objectPlaneEquation.x;
	v[1] = tcs->objectPlaneEquation.y;
	v[2] = tcs->objectPlaneEquation.z;
	v[3] = tcs->objectPlaneEquation.w;
	break;
      case GL_EYE_PLANE:
	v[0] = tcs->eyePlaneEquation.x;
	v[1] = tcs->eyePlaneEquation.y;
	v[2] = tcs->eyePlaneEquation.z;
	v[3] = tcs->eyePlaneEquation.w;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetTexGeniv(GLenum coord, GLenum pname,
			GLint v[])
{
    __GLtextureCoordState* tcs;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (coord) {
      case GL_S:
	tcs = &gc->state.texture.s;
	break;
      case GL_T:
	tcs = &gc->state.texture.t;
	break;
      case GL_R:
	tcs = &gc->state.texture.r;
	break;
      case GL_Q:
	tcs = &gc->state.texture.q;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_GEN_MODE:
	v[0] = tcs->mode;
	break;
      case GL_OBJECT_PLANE:
	__glConvertResult(gc, __GL_FLOAT, &tcs->objectPlaneEquation.x,
			  __GL_INT32, v, 4);
	break;
      case GL_EYE_PLANE:
	__glConvertResult(gc, __GL_FLOAT, &tcs->eyePlaneEquation.x,
			  __GL_INT32, v, 4);
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetTexParameterfv(GLenum target,
			      GLenum pname, GLfloat v[])
{
    __GLtextureParamState *pts;
    __GL_SETUP_NOT_IN_BEGIN();

    pts = __glLookUpTextureParams(gc, target);

    if (!pts) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    switch (pname) {
      case GL_TEXTURE_WRAP_S:
	v[0] = pts->sWrapMode;
	break;
      case GL_TEXTURE_WRAP_T:
	v[0] = pts->tWrapMode;
	break;
      case GL_TEXTURE_MIN_FILTER:
	v[0] = pts->minFilter;
	break;
      case GL_TEXTURE_MAG_FILTER:
	v[0] = pts->magFilter;
	break;
      case GL_TEXTURE_BORDER_COLOR:
	v[0] = pts->borderColor.r;
	v[1] = pts->borderColor.g;
	v[2] = pts->borderColor.b;
	v[3] = pts->borderColor.a;
	break;
      case GL_TEXTURE_PRIORITY:
	{
	    __GLtextureObjectState *ptos;
	    ptos = __glLookUpTextureTexobjs(gc, target);
	    v[0] = ptos->priority;
	}
	break;
      case GL_TEXTURE_RESIDENT:
	{
	    __GLtextureObject *pto;
	    pto = __glLookUpTextureObject(gc, target);
	    v[0] = (GLfloat)(pto->resident);
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetTexParameteriv(GLenum target,
			      GLenum pname, GLint v[])
{
    __GLtextureParamState *pts;
    __GL_SETUP_NOT_IN_BEGIN();

    pts = __glLookUpTextureParams(gc, target);

    if (!pts) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
	v[0] = pts->sWrapMode;
	break;
      case GL_TEXTURE_WRAP_T:
	v[0] = pts->tWrapMode;
	break;
      case GL_TEXTURE_MIN_FILTER:
	v[0] = pts->minFilter;
	break;
      case GL_TEXTURE_MAG_FILTER:
	v[0] = pts->magFilter;
	break;
      case GL_TEXTURE_BORDER_COLOR:
	v[0] = __GL_FLOAT_TO_I(pts->borderColor.r);
	v[1] = __GL_FLOAT_TO_I(pts->borderColor.g);
	v[2] = __GL_FLOAT_TO_I(pts->borderColor.b);
	v[3] = __GL_FLOAT_TO_I(pts->borderColor.a);
	break;
      case GL_TEXTURE_PRIORITY:
	{
	    __GLtextureObjectState *ptos;
	    ptos = __glLookUpTextureTexobjs(gc, target);
	    v[0] = __GL_FLOAT_TO_I(ptos->priority);
	}
	break;
      case GL_TEXTURE_RESIDENT:
	{
	    __GLtextureObject *pto;
	    pto = __glLookUpTextureObject(gc, target);
	    v[0] = (GLint)(pto->resident);
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetTexLevelParameterfv(GLenum target, GLint level,
				   GLenum pname, GLfloat v[])
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);

    if (!tex) {
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if ((level < 0) || (level >= gc->constants.maxMipMapLevel)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
    lp = &tex->level[level];

    switch (pname) {
      case GL_TEXTURE_WIDTH:
	v[0] = lp->width;
        break;
      case GL_TEXTURE_HEIGHT:
	if (tex->dim == 1) {
	    v[0] = lp->height - lp->border*2;
	} else {
		v[0] = lp->height;
        }
        break;
      case GL_TEXTURE_COMPONENTS:
	v[0] = lp->requestedFormat;
        break;
      case GL_TEXTURE_BORDER:
	v[0] = lp->border;
	break;
      case GL_TEXTURE_RED_SIZE:
	v[0] = lp->redSize;
	break;
      case GL_TEXTURE_GREEN_SIZE:
	v[0] = lp->greenSize;
	break;
      case GL_TEXTURE_BLUE_SIZE:
	v[0] = lp->blueSize;
	break;
      case GL_TEXTURE_ALPHA_SIZE:
	v[0] = lp->alphaSize;
	break;
      case GL_TEXTURE_LUMINANCE_SIZE:
	v[0] = lp->luminanceSize;
	break;
      case GL_TEXTURE_INTENSITY_SIZE:
	v[0] = lp->intensitySize;
	break;
      default:
	goto bad_enum;
    }
}

void APIPRIVATE __glim_GetTexLevelParameteriv(GLenum target, GLint level,
				   GLenum pname, GLint v[])
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);

    if (!tex) {
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    if ((level < 0) || (level >= gc->constants.maxMipMapLevel)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
    lp = &tex->level[level];

    switch (pname) {
      case GL_TEXTURE_WIDTH:
	v[0] = lp->width;
        break;
      case GL_TEXTURE_HEIGHT:
	if (tex->dim == 1) {
	    v[0] = lp->height - lp->border*2;
	} else {
		v[0] = lp->height;
        }
        break;
      case GL_TEXTURE_COMPONENTS:
	v[0] = lp->requestedFormat;
        break;
      case GL_TEXTURE_BORDER:
	v[0] = lp->border;
	break;
      case GL_TEXTURE_RED_SIZE:
	v[0] = lp->redSize;
	break;
      case GL_TEXTURE_GREEN_SIZE:
	v[0] = lp->greenSize;
	break;
      case GL_TEXTURE_BLUE_SIZE:
	v[0] = lp->blueSize;
	break;
      case GL_TEXTURE_ALPHA_SIZE:
	v[0] = lp->alphaSize;
	break;
      case GL_TEXTURE_LUMINANCE_SIZE:
	v[0] = lp->luminanceSize;
	break;
      case GL_TEXTURE_INTENSITY_SIZE:
	v[0] = lp->intensitySize;
	break;
      default:
	goto bad_enum;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetClipPlane(GLenum plane, GLdouble eqn[4])
{
    GLint index;
    __GL_SETUP_NOT_IN_BEGIN();

    index = plane - GL_CLIP_PLANE0;
    if ((index < 0) || (index >= gc->constants.numberOfClipPlanes)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    eqn[0] = gc->state.transform.eyeClipPlanes[index].x;
    eqn[1] = gc->state.transform.eyeClipPlanes[index].y;
    eqn[2] = gc->state.transform.eyeClipPlanes[index].z;
    eqn[3] = gc->state.transform.eyeClipPlanes[index].w;
}

/************************************************************************/

void FASTCALL __glInitImagePack(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
		       GLint width, GLint height, GLenum format, GLenum type, 
		       const GLvoid *buf)
{
    spanInfo->x = __glZero;
    spanInfo->zoomx = __glOne;
    spanInfo->realWidth = spanInfo->width = width;
    spanInfo->height = height;

    spanInfo->srcSkipPixels = 0;
    spanInfo->srcSkipLines = 0;
    spanInfo->srcSwapBytes = GL_FALSE;
#ifdef __GL_STIPPLE_MSB
    spanInfo->srcLsbFirst = GL_FALSE;
#else
    spanInfo->srcLsbFirst = GL_TRUE;
#endif
    spanInfo->srcLineLength = width;

    spanInfo->dstFormat = format;
    spanInfo->dstType = type;
    spanInfo->dstImage = buf;
    __glLoadPackModes(gc, spanInfo);
}

void APIPRIVATE __glim_GetTexImage(GLenum target, GLint level, GLenum format, GLenum type,
			GLvoid *texels)
{
    GLint width, height;
    GLint internalFormat;
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GLpixelSpanInfo spanInfo;
    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);

    if (!tex || (target == GL_PROXY_TEXTURE_1D) ||
	        (target == GL_PROXY_TEXTURE_2D))
    {
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    if ((level < 0) || (level >= gc->constants.maxMipMapLevel)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
    switch (format) {
      case GL_RGBA:
      case GL_RGB:
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX:
#endif
	break;
      default:
	goto bad_enum;
    }
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	goto bad_enum;
    }

    lp = &tex->level[level];

    internalFormat = lp->internalFormat;

#ifdef NT
    if (internalFormat == GL_NONE)
    {
        // No texture defined so don't return any data
        // Note: This cannot be an error case because
        // covgl calls GetTexImage without an image
        // and expects success
        return;
    }
#endif

#ifdef GL_EXT_paletted_texture
    // If the request is for color index data then the source
    // must be color indices
    if (format == GL_COLOR_INDEX &&
        internalFormat != GL_COLOR_INDEX8_EXT &&
        internalFormat != GL_COLOR_INDEX16_EXT)
    {
        __glSetError(GL_INVALID_OPERATION);
        return;
    }
#endif
    
    width = lp->width;
    if (tex->dim == 1) {
	height = lp->height - lp->border*2;
    } else {
	height = lp->height;
    }
    spanInfo.srcImage = lp->buffer;
    switch (internalFormat) {
      case GL_LUMINANCE:
	spanInfo.srcFormat = GL_RED;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
      case GL_LUMINANCE_ALPHA:
	spanInfo.srcFormat = __GL_RED_ALPHA;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
      case GL_RGB:
	spanInfo.srcFormat = GL_RGB;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
      case GL_RGBA:
	spanInfo.srcFormat = GL_RGBA;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
      case GL_ALPHA:
	spanInfo.srcFormat = GL_ALPHA;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
      case GL_INTENSITY:
	spanInfo.srcFormat = GL_RED;
	spanInfo.srcType = GL_FLOAT;
        spanInfo.srcAlignment = 4;
	break;
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
        // Be a little tricky here because the internal format
        // is padded to 32 bits
	spanInfo.srcFormat = GL_BGRA_EXT;
	spanInfo.srcType = GL_UNSIGNED_BYTE;
        spanInfo.srcAlignment = 4;
	break;
      case GL_BGRA_EXT:
	spanInfo.srcFormat = GL_BGRA_EXT;
	spanInfo.srcType = GL_UNSIGNED_BYTE;
        spanInfo.srcAlignment = 4;
	break;
#endif
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX16_EXT:
        // We're copying out an indexed texture
        // If the destination format is color index then we want the
        // indices to go through the normal color index processing
        // If the desination isn't color index then we do not want
        // the normal color index processing to occur because the
        // I_TO_? maps will be used.  Instead we want the texture's
        // palette to be used, so use a different format to force
        // the new code path
        if (format == GL_COLOR_INDEX)
        {
            spanInfo.srcFormat = GL_COLOR_INDEX;
        }
        else
        {
            spanInfo.srcFormat = __GL_PALETTE_INDEX;
        }
        
        if (internalFormat == GL_COLOR_INDEX8_EXT)
        {
            // We can't just use tex->paletteSize because
            // this value is used to scale float items of srcType
            // to srcType's range, not to the palette range
            spanInfo.srcPaletteSize = 255;
            spanInfo.srcType = GL_UNSIGNED_BYTE;
        }
        else
        {
            ASSERTOPENGL(internalFormat == GL_COLOR_INDEX16_EXT,
                         "Unexpected internalFormat\n");

            spanInfo.srcPaletteSize = 65535;
            spanInfo.srcType = GL_UNSIGNED_SHORT;
        }
        spanInfo.srcAlignment = 1;
        spanInfo.srcPalette = tex->paletteData;
        break;
#endif
#ifdef NT
    default:
        ASSERTOPENGL(FALSE, "Unhandled internalFormat in GetTexImage\n");
        break;
#endif
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    __glInitImagePack(gc, &spanInfo, width, height, format, type, texels);
    if (tex->dim == 1) {
	spanInfo.srcSkipLines += lp->border;
    }
    __glInitPacker(gc, &spanInfo);
    __glInitUnpacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
}

/************************************************************************/

void APIPRIVATE __glim_GetPolygonStipple(GLubyte *outImage)
{
    __GLpixelSpanInfo spanInfo;
    __GL_SETUP_NOT_IN_BEGIN();

    spanInfo.srcImage = &(gc->state.polygonStipple.stipple[0]);
    spanInfo.srcType = GL_BITMAP;
    spanInfo.srcFormat = GL_COLOR_INDEX;
    spanInfo.srcAlignment = 4;
    __glInitImagePack(gc, &spanInfo, 32, 32, GL_COLOR_INDEX, GL_BITMAP, 
	    outImage);
    __glInitPacker(gc, &spanInfo);
    __glInitUnpacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
}

/************************************************************************/

void APIPRIVATE __glim_GetLightfv(GLenum light, GLenum pname,
		       GLfloat result[])
{
    GLint index;
    __GLlightSourceState *src;
    __GL_SETUP_NOT_IN_BEGIN();

    index = light - GL_LIGHT0;
    if ((index < 0) || (index >= gc->constants.numberOfLights)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    src = &gc->state.light.source[index];
    switch (pname) {
      case GL_AMBIENT:
	__glUnScaleColorf(gc, result, &src->ambient);
	break;
      case GL_DIFFUSE:
	__glUnScaleColorf(gc, result, &src->diffuse);
	break;
      case GL_SPECULAR:
	__glUnScaleColorf(gc, result, &src->specular);
	break;
      case GL_POSITION:
	result[0] = src->positionEye.x;
	result[1] = src->positionEye.y;
	result[2] = src->positionEye.z;
	result[3] = src->positionEye.w;
	break;
      case GL_SPOT_DIRECTION:
	result[0] = src->directionEye.x;
	result[1] = src->directionEye.y;
	result[2] = src->directionEye.z;
	break;
      case GL_SPOT_EXPONENT:
	result[0] = src->spotLightExponent;
	break;
      case GL_SPOT_CUTOFF:
	result[0] = src->spotLightCutOffAngle;
	break;
      case GL_CONSTANT_ATTENUATION:
        result[0] = src->constantAttenuation;
        break;
      case GL_LINEAR_ATTENUATION:
        result[0] = src->linearAttenuation;
        break;
      case GL_QUADRATIC_ATTENUATION:
        result[0] = src->quadraticAttenuation;
        break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetLightiv(GLenum light, GLenum pname,
		       GLint result[])
{
    GLint index;
    __GLlightSourceState *src;
    __GL_SETUP_NOT_IN_BEGIN();

    index = light - GL_LIGHT0;
    if ((index < 0) || (index >= gc->constants.numberOfLights)) {
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    src = &gc->state.light.source[index];
    switch (pname) {
      case GL_AMBIENT:
	__glUnScaleColori(gc, result, &src->ambient);
	break;
      case GL_DIFFUSE:
	__glUnScaleColori(gc, result, &src->diffuse);
	break;
      case GL_SPECULAR:
	__glUnScaleColori(gc, result, &src->specular);
	break;
      case GL_POSITION:	    
	__glConvertResult(gc, __GL_FLOAT, &src->positionEye.x,
			  __GL_INT32, result, 4);
	break;
      case GL_SPOT_DIRECTION:
	__glConvertResult(gc, __GL_FLOAT, &src->directionEye.x,
			  __GL_INT32, result, 3);
	break;
      case GL_SPOT_EXPONENT:
	__glConvertResult(gc, __GL_FLOAT, &src->spotLightExponent,
			  __GL_INT32, result, 1);
	break;
      case GL_SPOT_CUTOFF:
	__glConvertResult(gc, __GL_FLOAT, &src->spotLightCutOffAngle,
			  __GL_INT32, result, 1);
	break;
      case GL_CONSTANT_ATTENUATION:
	__glConvertResult(gc, __GL_FLOAT, &src->constantAttenuation,
			  __GL_INT32, result, 1);
        break;
      case GL_LINEAR_ATTENUATION:
	__glConvertResult(gc, __GL_FLOAT, &src->linearAttenuation,
			  __GL_INT32, result, 1);
        break;
      case GL_QUADRATIC_ATTENUATION:
	__glConvertResult(gc, __GL_FLOAT, &src->quadraticAttenuation,
			  __GL_INT32, result, 1);
        break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetMaterialfv(GLenum face, GLenum pname,
			  GLfloat result[])
{
    __GLmaterialState *mat;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (face) {
      case GL_FRONT:
	mat = &gc->state.light.front;
	break;
      case GL_BACK:
	mat = &gc->state.light.back;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    switch (pname) {
      case GL_COLOR_INDEXES:
	result[0] = mat->cmapa;
	result[1] = mat->cmapd;
	result[2] = mat->cmaps;
	break;
      case GL_SHININESS:
	result[0] = mat->specularExponent;
	break;
      case GL_EMISSION:
	__glUnScaleColorf(gc, result, &mat->emissive);
	break;
      case GL_AMBIENT:
	result[0] = mat->ambient.r;
	result[1] = mat->ambient.g;
	result[2] = mat->ambient.b;
	result[3] = mat->ambient.a;
	break;
      case GL_DIFFUSE:
	result[0] = mat->diffuse.r;
	result[1] = mat->diffuse.g;
	result[2] = mat->diffuse.b;
	result[3] = mat->diffuse.a;
	break;
      case GL_SPECULAR:
	result[0] = mat->specular.r;
	result[1] = mat->specular.g;
	result[2] = mat->specular.b;
	result[3] = mat->specular.a;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetMaterialiv(GLenum face, GLenum pname,
			  GLint result[])
{
    __GLmaterialState *mat;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (face) {
      case GL_FRONT:
	mat = &gc->state.light.front;
	break;
      case GL_BACK:
	mat = &gc->state.light.back;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    switch (pname) {
      case GL_COLOR_INDEXES:
	__glConvertResult(gc, __GL_FLOAT, &mat->cmapa,
			  __GL_INT32, result, 3);
	break;
      case GL_SHININESS:
	__glConvertResult(gc, __GL_FLOAT, &mat->specularExponent,
			  __GL_INT32, result, 1);
	break;
      case GL_EMISSION:
	__glUnScaleColori(gc, result, &mat->emissive);
	break;
      case GL_AMBIENT:
	result[0] = __GL_FLOAT_TO_I(mat->ambient.r);
	result[1] = __GL_FLOAT_TO_I(mat->ambient.g);
	result[2] = __GL_FLOAT_TO_I(mat->ambient.b);
	result[3] = __GL_FLOAT_TO_I(mat->ambient.a);
	break;
      case GL_DIFFUSE:
	result[0] = __GL_FLOAT_TO_I(mat->diffuse.r);
	result[1] = __GL_FLOAT_TO_I(mat->diffuse.g);
	result[2] = __GL_FLOAT_TO_I(mat->diffuse.b);
	result[3] = __GL_FLOAT_TO_I(mat->diffuse.a);
	break;
      case GL_SPECULAR:
	result[0] = __GL_FLOAT_TO_I(mat->specular.r);
	result[1] = __GL_FLOAT_TO_I(mat->specular.g);
	result[2] = __GL_FLOAT_TO_I(mat->specular.b);
	result[3] = __GL_FLOAT_TO_I(mat->specular.a);
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

void APIPRIVATE __glim_GetMapfv(GLenum target, GLenum query, GLfloat buf[])
{
    __GLevaluator1 *eval1;
    __GLevaluator2 *eval2;
    __GLfloat *eval1Data, *eval2Data;
    GLfloat *rp;
    GLint index, i, t;
    __GL_SETUP_NOT_IN_BEGIN();

    /*
    ** Check if target is valid.
    */
    rp = buf;
    switch (target) {
      case GL_MAP1_COLOR_4:
      case GL_MAP1_INDEX:
      case GL_MAP1_NORMAL:
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3:
      case GL_MAP1_VERTEX_4:
	index = __GL_EVAL1D_INDEX(target);
	eval1 = &gc->eval.eval1[index];
	switch (query) {
	  case GL_COEFF:
	    t = eval1->order * eval1->k;
	    eval1Data = gc->eval.eval1Data[index];
	    for (i = 0; i < t; i++) {
		*rp++ = eval1Data[i];
	    }
	    break;
	  case GL_DOMAIN:
	    *rp++ = eval1->u1;
	    *rp++ = eval1->u2;
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval1[index].order;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_INDEX:
      case GL_MAP2_NORMAL:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3:
      case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3:
      case GL_MAP2_VERTEX_4:
	index = __GL_EVAL2D_INDEX(target);
	eval2 = &gc->eval.eval2[index];
	switch (query) {
	  case GL_COEFF:
	    eval2Data = gc->eval.eval2Data[index];
	    t = eval2->majorOrder * eval2->minorOrder * eval2->k;
	    for (i = 0; i < t; i++) {
		*rp++ = eval2Data[i];
	    }
	    break;
	  case GL_DOMAIN:
	    *rp++ = eval2->u1;
	    *rp++ = eval2->u2;
	    *rp++ = eval2->v1;
	    *rp++ = eval2->v2;
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval2[index].majorOrder;
	    *rp++ = gc->eval.eval2[index].minorOrder;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetMapdv(GLenum target, GLenum query, GLdouble buf[])
{
    __GLevaluator1 *eval1;
    __GLevaluator2 *eval2;
    __GLfloat *eval1Data, *eval2Data;
    GLdouble *rp;
    GLint index, i, t;
    __GL_SETUP_NOT_IN_BEGIN();

    /*
    ** Check if target is valid.
    */
    rp = buf;
    switch (target) {
      case GL_MAP1_COLOR_4:
      case GL_MAP1_INDEX:
      case GL_MAP1_NORMAL:
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3:
      case GL_MAP1_VERTEX_4:
	index = __GL_EVAL1D_INDEX(target);
	eval1 = &gc->eval.eval1[index];
	switch (query) {
	  case GL_COEFF:
	    eval1Data = gc->eval.eval1Data[index];
	    t = eval1->order * eval1->k;
	    for (i = 0; i < t; i++) {
		*rp++ = eval1Data[i];
	    }
	    break;
	  case GL_DOMAIN:
	    *rp++ = eval1->u1;
	    *rp++ = eval1->u2;
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval1[index].order;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_INDEX:
      case GL_MAP2_NORMAL:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3:
      case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3:
      case GL_MAP2_VERTEX_4:
	index = __GL_EVAL2D_INDEX(target);
	eval2 = &gc->eval.eval2[index];
	switch (query) {
	  case GL_COEFF:
	    eval2Data = gc->eval.eval2Data[index];
	    t = eval2->majorOrder * eval2->minorOrder * eval2->k;
	    for (i = 0; i < t; i++) {
		*rp++ = eval2Data[i];
	    }
	    break;
	  case GL_DOMAIN:
	    *rp++ = eval2->u1;
	    *rp++ = eval2->u2;
	    *rp++ = eval2->v1;
	    *rp++ = eval2->v2;
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval2[index].majorOrder;
	    *rp++ = gc->eval.eval2[index].minorOrder;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetMapiv(GLenum target, GLenum query, GLint buf[])
{
    __GLevaluator1 *eval1;
    __GLevaluator2 *eval2;
    __GLfloat *eval1Data, *eval2Data;
    GLint *rp;
    GLint index, t;
    __GL_SETUP_NOT_IN_BEGIN();

    /*
    ** Check if target is valid.
    */
    rp = buf;
    switch (target) {
      case GL_MAP1_COLOR_4:
      case GL_MAP1_INDEX:
      case GL_MAP1_NORMAL:
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3:
      case GL_MAP1_VERTEX_4:
	index = __GL_EVAL1D_INDEX(target);
	eval1 = &gc->eval.eval1[index];
	switch (query) {
	  case GL_COEFF:
	    eval1Data = gc->eval.eval1Data[index];
	    t = eval1->order * eval1->k;
	    __glConvertResult(gc, __GL_FLOAT, eval1Data,
			      __GL_INT32, rp, t);
	    break;
	  case GL_DOMAIN:
	    __glConvertResult(gc, __GL_FLOAT, &eval1->u1,
			      __GL_INT32, rp, 2);
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval1[index].order;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_INDEX:
      case GL_MAP2_NORMAL:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3:
      case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3:
      case GL_MAP2_VERTEX_4:
	index = __GL_EVAL2D_INDEX(target);
	eval2 = &gc->eval.eval2[index];
	switch (query) {
	  case GL_COEFF:
	    eval2Data = gc->eval.eval2Data[index];
	    t = eval2->majorOrder * eval2->minorOrder * eval2->k;
	    __glConvertResult(gc, __GL_FLOAT, eval2Data,
			      __GL_INT32, rp, t);
	    break;
	  case GL_DOMAIN:
	    __glConvertResult(gc, __GL_FLOAT, &eval2->u1,
			      __GL_INT32, rp, 4);
	    break;
	  case GL_ORDER:
	    *rp++ = gc->eval.eval2[index].majorOrder;
	    *rp++ = gc->eval.eval2[index].minorOrder;
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/*****************************************************************************/

void APIPRIVATE __glim_GetPixelMapfv(GLenum map, GLfloat buf[])
{
    GLint index;
    GLint limit;
    GLfloat *rp;
    __GLpixelMapHead *pMap;
    __GL_SETUP_NOT_IN_BEGIN();

    pMap = gc->state.pixel.pixelMap;
    index = map - GL_PIXEL_MAP_I_TO_I;
    rp = buf;
    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
	{
	    GLint *fromp = pMap[index].base.mapI;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = *fromp++;
	    }
	}
	break;
      case GL_PIXEL_MAP_I_TO_R:      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:      case GL_PIXEL_MAP_I_TO_A:
      case GL_PIXEL_MAP_R_TO_R:      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:      case GL_PIXEL_MAP_A_TO_A:
	{
	    __GLfloat *fromp = pMap[index].base.mapF;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = *fromp++;
	    }
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetPixelMapuiv(GLenum map, GLuint buf[])
{
    GLint index;
    GLint limit;
    GLuint *rp;
    __GLpixelMapHead *pMap;
    __GL_SETUP_NOT_IN_BEGIN();

    pMap = gc->state.pixel.pixelMap;
    index = map - GL_PIXEL_MAP_I_TO_I;
    rp = buf;
    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
	{
	    GLint *fromp = pMap[index].base.mapI;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = *fromp++;
	    }
	}
	break;
      case GL_PIXEL_MAP_I_TO_R:      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:      case GL_PIXEL_MAP_I_TO_A:
      case GL_PIXEL_MAP_R_TO_R:      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:      case GL_PIXEL_MAP_A_TO_A:
	{
	    __GLfloat *fromp = pMap[index].base.mapF;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = (GLuint) *fromp++;
	    }
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

void APIPRIVATE __glim_GetPixelMapusv(GLenum map, GLushort buf[])
{
    GLint index;
    GLint limit;
    GLushort *rp;
    __GLpixelMapHead *pMap;
    __GL_SETUP_NOT_IN_BEGIN();

    pMap = gc->state.pixel.pixelMap;
    index = map - GL_PIXEL_MAP_I_TO_I;
    rp = buf;
    switch (map) {
      case GL_PIXEL_MAP_I_TO_I:
      case GL_PIXEL_MAP_S_TO_S:
	{
	    GLint *fromp = pMap[index].base.mapI;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = (GLushort) *fromp++;
	    }
	}
	break;
      case GL_PIXEL_MAP_I_TO_R:      case GL_PIXEL_MAP_I_TO_G:
      case GL_PIXEL_MAP_I_TO_B:      case GL_PIXEL_MAP_I_TO_A:
      case GL_PIXEL_MAP_R_TO_R:      case GL_PIXEL_MAP_G_TO_G:
      case GL_PIXEL_MAP_B_TO_B:      case GL_PIXEL_MAP_A_TO_A:
	{
	    __GLfloat *fromp = pMap[index].base.mapF;
	    limit = pMap[index].size;
	    while (--limit >= 0) {
		*rp++ = (GLushort) *fromp++;
	    }
	}
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
}

/************************************************************************/

/*
** Convert the results of a query from one type to another.
*/
void __glConvertResult(__GLcontext *gc, GLint fromType, const void *rawdata,
		       GLint toType, void *result, GLint size)
{
    GLint i;
    
    switch (fromType) {
      case __GL_FLOAT:
	switch (toType) {
	  case __GL_FLOAT32:
	    for (i=0; i < size; i++) {
		((GLfloat *)result)[i] = ((const __GLfloat *)rawdata)[i];
	    }
	    break;
	  case __GL_FLOAT64:
	    for (i=0; i < size; i++) {
		((GLdouble *)result)[i] = ((const __GLfloat *)rawdata)[i];
	    }
	    break;
	  case __GL_INT32:
	    for (i=0; i < size; i++) {
		((GLint *)result)[i] = 
			(GLint)(((const __GLfloat *)rawdata)[i] >= (__GLfloat) 0.0 ?
			((const __GLfloat *)rawdata)[i] + __glHalf:
			((const __GLfloat *)rawdata)[i] - __glHalf);
	    }
	    break;
	  case __GL_BOOLEAN:
	    for (i=0; i < size; i++) {
		((GLboolean *)result)[i] =
		    ((const __GLfloat *)rawdata)[i] ? 1 : 0;
	    }
	    break;
	}
	break;
      case __GL_COLOR:
	switch (toType) {
	  case __GL_FLOAT32:
	    for (i=0; i < size; i++) {
		((GLfloat *)result)[i] = ((const __GLfloat *)rawdata)[i];
	    }
	    break;
	  case __GL_FLOAT64:
	    for (i=0; i < size; i++) {
		((GLdouble *)result)[i] = ((const __GLfloat *)rawdata)[i];
	    }
	    break;
	  case __GL_INT32:
	    for (i=0; i < size; i++) {
		((GLint *)result)[i] =
		    __GL_FLOAT_TO_I(((const __GLfloat *)rawdata)[i]);
	    }
	    break;
	  case __GL_BOOLEAN:
	    for (i=0; i < size; i++) {
		((GLboolean *)result)[i] =
		    ((const __GLfloat *)rawdata)[i] ? 1 : 0;
	    }
	    break;
	}
	break;
      case __GL_SCOLOR:
	switch (toType) {
	  case __GL_FLOAT32:
	    ((GLfloat *)result)[0] =
		((const __GLfloat *)rawdata)[0] * gc->oneOverRedVertexScale;
	    ((GLfloat *)result)[1] =
		((const __GLfloat *)rawdata)[1] * gc->oneOverGreenVertexScale;
	    ((GLfloat *)result)[2] =
		((const __GLfloat *)rawdata)[2] * gc->oneOverBlueVertexScale;
	    ((GLfloat *)result)[3] =
		((const __GLfloat *)rawdata)[3] * gc->oneOverAlphaVertexScale;
	    break;
	  case __GL_FLOAT64:
	    ((GLdouble *)result)[0] =
		((const __GLfloat *)rawdata)[0] * gc->oneOverRedVertexScale;
	    ((GLdouble *)result)[1] =
		((const __GLfloat *)rawdata)[1] * gc->oneOverGreenVertexScale;
	    ((GLdouble *)result)[2] =
		((const __GLfloat *)rawdata)[2] * gc->oneOverBlueVertexScale;
	    ((GLdouble *)result)[3] =
		((const __GLfloat *)rawdata)[3] * gc->oneOverAlphaVertexScale;
	    break;
	  case __GL_INT32:
	    ((GLint *)result)[0] =
		__GL_FLOAT_TO_I(((const __GLfloat *)rawdata)[0] *
				gc->oneOverRedVertexScale);
	    ((GLint *)result)[1] =
		__GL_FLOAT_TO_I(((const __GLfloat *)rawdata)[1] *
				gc->oneOverGreenVertexScale);
	    ((GLint *)result)[2] =
		__GL_FLOAT_TO_I(((const __GLfloat *)rawdata)[2] *
				gc->oneOverBlueVertexScale);
	    ((GLint *)result)[3] =
		__GL_FLOAT_TO_I(((const __GLfloat *)rawdata)[3] *
				gc->oneOverAlphaVertexScale);
	    break;
	  case __GL_BOOLEAN:
	    for (i=0; i < size; i++) {
		((GLboolean *)result)[i] =
		    ((const __GLfloat *)rawdata)[i] ? 1 : 0;
	    }
	    break;
	}
	break;
      case __GL_INT32:
	switch (toType) {
	  case __GL_FLOAT32:
	    for (i=0; i < size; i++) {
		((GLfloat *)result)[i] = ((const GLint *)rawdata)[i];
	    }
	    break;
	  case __GL_FLOAT64:
	    for (i=0; i < size; i++) {
		((GLdouble *)result)[i] = ((const GLint *)rawdata)[i];
	    }
	    break;
	  case __GL_INT32:
	    for (i=0; i < size; i++) {
		((GLint *)result)[i] = ((const GLint *)rawdata)[i];
	    }
	    break;
	  case __GL_BOOLEAN:
	    for (i=0; i < size; i++) {
		((GLboolean *)result)[i] = ((const GLint *)rawdata)[i] ? 1 : 0;
	    }
	    break;
	}
	break;
      case __GL_BOOLEAN:
	switch (toType) {
	  case __GL_FLOAT32:
	    for (i=0; i < size; i++) {
		((GLfloat *)result)[i] = ((const GLboolean *)rawdata)[i];
	    }
	    break;
	  case __GL_FLOAT64:
	    for (i=0; i < size; i++) {
		((GLdouble *)result)[i] = ((const GLboolean *)rawdata)[i];
	    }
	    break;
	  case __GL_INT32:
	    for (i=0; i < size; i++) {
		((GLint *)result)[i] = ((const GLboolean *)rawdata)[i];
	    }
	    break;
	  case __GL_BOOLEAN:
	    for (i=0; i < size; i++) {
		((GLboolean *)result)[i] =
		    ((const GLboolean *)rawdata)[i] ? 1 : 0;
	    }
	    break;
	}
	break;
    }
}

/*
** Fetch the data for a query in its internal type, then convert it to the
** type that the user asked for.
*/
void __glDoGet(GLenum sq, void *result, GLint type, const char *procName)
{
    GLint index;
    __GLfloat ftemp[100], *fp = ftemp;		/* NOTE: for floats */
    __GLfloat ctemp[100], *cp = ctemp;		/* NOTE: for colors */
    __GLfloat sctemp[100], *scp = sctemp;	/* NOTE: for scaled colors */
    GLint itemp[100], *ip = itemp;		/* NOTE: for ints */
    GLboolean ltemp[100], *lp = ltemp;		/* NOTE: for logicals */
    __GLfloat *mp;
    __GL_SETUP_NOT_IN_BEGIN();

#ifdef __GL_LINT
    procName = procName;
#endif
    switch (sq) {
      case GL_ALPHA_TEST:
      case GL_BLEND:
      case GL_COLOR_MATERIAL:
      case GL_CULL_FACE:
      case GL_DEPTH_TEST:
      case GL_DITHER:
#ifdef GL_WIN_specular_fog
      case GL_FOG_SPECULAR_TEXTURE_WIN:
#endif //GL_WIN_specular_fog
      case GL_FOG:
      case GL_LIGHTING:
      case GL_LINE_SMOOTH:
      case GL_LINE_STIPPLE:
      case GL_INDEX_LOGIC_OP:
      case GL_COLOR_LOGIC_OP:
      case GL_NORMALIZE:
      case GL_POINT_SMOOTH:
      case GL_POLYGON_SMOOTH:
      case GL_POLYGON_STIPPLE:
      case GL_SCISSOR_TEST:
      case GL_STENCIL_TEST:
      case GL_TEXTURE_1D:
      case GL_TEXTURE_2D:
      case GL_AUTO_NORMAL:
      case GL_TEXTURE_GEN_S:
      case GL_TEXTURE_GEN_T:
      case GL_TEXTURE_GEN_R:
      case GL_TEXTURE_GEN_Q:
#ifdef GL_WIN_multiple_textures
      case GL_TEXCOMBINE_CLAMP_WIN:
#endif // GL_WIN_multiple_textures
#ifdef GL_EXT_flat_paletted_lighting
      case GL_PALETTED_LIGHTING_EXT:
#endif // GL_EXT_flat_paletted_lighting
      case GL_CLIP_PLANE0: case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2: case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4: case GL_CLIP_PLANE5:
      case GL_LIGHT0: case GL_LIGHT1:
      case GL_LIGHT2: case GL_LIGHT3:
      case GL_LIGHT4: case GL_LIGHT5:
      case GL_LIGHT6: case GL_LIGHT7:
      case GL_MAP1_COLOR_4:
      case GL_MAP1_NORMAL:
      case GL_MAP1_INDEX:
      case GL_MAP1_TEXTURE_COORD_1: case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3: case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3: case GL_MAP1_VERTEX_4:
      case GL_MAP2_COLOR_4:
      case GL_MAP2_NORMAL:
      case GL_MAP2_INDEX:
      case GL_MAP2_TEXTURE_COORD_1: case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3: case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3: case GL_MAP2_VERTEX_4:
      case GL_VERTEX_ARRAY:
      case GL_NORMAL_ARRAY:
      case GL_COLOR_ARRAY:
      case GL_INDEX_ARRAY:
      case GL_TEXTURE_COORD_ARRAY:
      case GL_EDGE_FLAG_ARRAY:
      case GL_POLYGON_OFFSET_POINT:
      case GL_POLYGON_OFFSET_LINE:
      case GL_POLYGON_OFFSET_FILL:
	*lp++ = __glim_IsEnabled(sq);
	break;
      case GL_MAX_TEXTURE_SIZE:
	*ip++ = gc->constants.maxTextureSize;
	break;
#ifdef GL_WIN_multiple_textures
      case GL_MAX_CURRENT_TEXTURES_WIN:
        *ip++ = (int)gc->constants.numberOfCurrentTextures;
        break;
      case GL_TEXCOMBINE_NATURAL_CLAMP_WIN:
        *ip++ = (int)gc->constants.texCombineNaturalClamp;
        break;
    case GL_CURRENT_TEXTURE_INDEX_WIN:
        *ip++ = (int)gc->texture.texIndex;
        break;
#endif // GL_WIN_multiple_textures
      case GL_SUBPIXEL_BITS:
	*ip++ = gc->constants.subpixelBits;
	break;
      case GL_MAX_LIST_NESTING:
	*ip++ = __GL_MAX_LIST_NESTING;
	break;
      case GL_CURRENT_COLOR:
        *cp++ = gc->state.current.userColor.r;
        *cp++ = gc->state.current.userColor.g;
        *cp++ = gc->state.current.userColor.b;
        *cp++ = gc->state.current.userColor.a;
        break;
      case GL_CURRENT_INDEX:
        *fp++ = gc->state.current.userColorIndex;
        break;
      case GL_CURRENT_NORMAL:
        *cp++ = gc->state.current.normal.x;
        *cp++ = gc->state.current.normal.y;
        *cp++ = gc->state.current.normal.z;
        break;
      case GL_CURRENT_TEXTURE_COORDS:
        *fp++ = gc->state.current.texture.x;
        *fp++ = gc->state.current.texture.y;
        *fp++ = gc->state.current.texture.z;
        *fp++ = gc->state.current.texture.w;
        break;
      case GL_CURRENT_RASTER_INDEX:
	if (gc->modes.rgbMode) {
	    /* Always return 1 */
	    *fp++ = (__GLfloat) 1.0;
	} else {
	    *fp++ = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
	}
	break;
      case GL_CURRENT_RASTER_COLOR:
	if (gc->modes.colorIndexMode) {
	    /* Always return 1,1,1,1 */
	    *fp++ = (__GLfloat) 1.0;
	    *fp++ = (__GLfloat) 1.0;
	    *fp++ = (__GLfloat) 1.0;
	    *fp++ = (__GLfloat) 1.0;
	} else {
	    *scp++ = gc->state.current.rasterPos.colors[__GL_FRONTFACE].r;
	    *scp++ = gc->state.current.rasterPos.colors[__GL_FRONTFACE].g;
	    *scp++ = gc->state.current.rasterPos.colors[__GL_FRONTFACE].b;
	    *scp++ = gc->state.current.rasterPos.colors[__GL_FRONTFACE].a;
	}
        break;
      case GL_CURRENT_RASTER_TEXTURE_COORDS:
        *fp++ = gc->state.current.rasterPos.texture.x;
        *fp++ = gc->state.current.rasterPos.texture.y;
        *fp++ = gc->state.current.rasterPos.texture.z;
        *fp++ = gc->state.current.rasterPos.texture.w;
	break;
      case GL_CURRENT_RASTER_POSITION:
        *fp++ = gc->state.current.rasterPos.window.x
	    - gc->constants.fviewportXAdjust;
	if (gc->constants.yInverted) {
	    *fp++ = gc->constants.height - 
		    (gc->state.current.rasterPos.window.y - 
		     gc->constants.fviewportYAdjust) -
		     gc->constants.viewportEpsilon;
	} else {
	    *fp++ = gc->state.current.rasterPos.window.y
		- gc->constants.fviewportYAdjust;
	}
        *fp++ = gc->state.current.rasterPos.window.z / gc->depthBuffer.scale;
	*fp++ = gc->state.current.rasterPos.clip.w;
        break;
      case GL_CURRENT_RASTER_POSITION_VALID:
        *lp++ = gc->state.current.validRasterPos;
	break;
      case GL_CURRENT_RASTER_DISTANCE:
	*fp++ = gc->state.current.rasterPos.eyeZ;
	break;
      case GL_POINT_SIZE:
        *fp++ = gc->state.point.requestedSize;
        break;
      case GL_POINT_SIZE_RANGE:
        *fp++ = gc->constants.pointSizeMinimum;
        *fp++ = gc->constants.pointSizeMaximum;
        break;
      case GL_POINT_SIZE_GRANULARITY:
        *fp++ = gc->constants.pointSizeGranularity;
        break;
      case GL_LINE_WIDTH:
        *fp++ = gc->state.line.requestedWidth;
        break;
      case GL_LINE_WIDTH_RANGE:
        *fp++ = gc->constants.lineWidthMinimum;
        *fp++ = gc->constants.lineWidthMaximum;
        break;
      case GL_LINE_WIDTH_GRANULARITY:
        *fp++ = gc->constants.lineWidthGranularity;
        break;
      case GL_LINE_STIPPLE_PATTERN:
        *ip++ = gc->state.line.stipple;
        break;
      case GL_LINE_STIPPLE_REPEAT:
        *ip++ = gc->state.line.stippleRepeat;
        break;
      case GL_POLYGON_MODE:
        *ip++ = gc->state.polygon.frontMode;
        *ip++ = gc->state.polygon.backMode;
        break;
      case GL_EDGE_FLAG:
        *lp++ = gc->state.current.edgeTag;
	break;
      case GL_CULL_FACE_MODE:
        *ip++ = gc->state.polygon.cull;
        break;
      case GL_FRONT_FACE:
        *ip++ = gc->state.polygon.frontFaceDirection;
        break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
        *lp++ = gc->state.light.model.localViewer;
        break;
      case GL_LIGHT_MODEL_TWO_SIDE:
        *lp++ = gc->state.light.model.twoSided;
        break;
      case GL_LIGHT_MODEL_AMBIENT:
	__glUnScaleColorf(gc, cp, &gc->state.light.model.ambient);
	cp += 4;
        break;
      case GL_COLOR_MATERIAL_FACE:
        *ip++ = gc->state.light.colorMaterialFace;
        break;
      case GL_COLOR_MATERIAL_PARAMETER:
        *ip++ = gc->state.light.colorMaterialParam;
        break;
      case GL_SHADE_MODEL:
        *ip++ = gc->state.light.shadingModel;
        break;
      case GL_FOG_INDEX:
        *fp++ = gc->state.fog.index;
        break;
      case GL_FOG_DENSITY:
        *fp++ = gc->state.fog.density;
        break;
      case GL_FOG_START:
        *fp++ = gc->state.fog.start;
        break;
      case GL_FOG_END:
        *fp++ = gc->state.fog.end;
        break;
      case GL_FOG_MODE:
        *ip++ = gc->state.fog.mode;
        break;
      case GL_FOG_COLOR:
        *scp++ = gc->state.fog.color.r;
        *scp++ = gc->state.fog.color.g;
        *scp++ = gc->state.fog.color.b;
        *scp++ = gc->state.fog.color.a;
        break;
      case GL_DEPTH_RANGE:
	/* These get scaled like colors, to [0, 2^31-1] */
        *cp++ = gc->state.viewport.zNear;
        *cp++ = gc->state.viewport.zFar;
        break;
      case GL_DEPTH_WRITEMASK:
	*lp++ = gc->state.depth.writeEnable;
	break;
      case GL_DEPTH_CLEAR_VALUE:
	/* This gets scaled like colors, to [0, 2^31-1] */
	*cp++ = gc->state.depth.clear;
	break;
      case GL_DEPTH_FUNC:
	*ip++ = gc->state.depth.testFunc;
	break;
      case GL_ACCUM_CLEAR_VALUE:
	*cp++ = gc->state.accum.clear.r;
	*cp++ = gc->state.accum.clear.g;
	*cp++ = gc->state.accum.clear.b;
	*cp++ = gc->state.accum.clear.a;
	break;
      case GL_STENCIL_CLEAR_VALUE:
        *ip++ = gc->state.stencil.clear;
        break;
      case GL_STENCIL_FUNC:
        *ip++ = gc->state.stencil.testFunc;
        break;
      case GL_STENCIL_VALUE_MASK:
	*ip++ = gc->state.stencil.mask;
	break;
      case GL_STENCIL_FAIL:
        *ip++ = gc->state.stencil.fail;
        break;
      case GL_STENCIL_PASS_DEPTH_FAIL:
        *ip++ = gc->state.stencil.depthFail;
        break;
      case GL_STENCIL_PASS_DEPTH_PASS:
        *ip++ = gc->state.stencil.depthPass;
        break;
      case GL_STENCIL_REF:
        *ip++ = gc->state.stencil.reference;
        break;
      case GL_STENCIL_WRITEMASK:
        *ip++ = gc->state.stencil.writeMask;
        break;
      case GL_MATRIX_MODE:
        *ip++ = gc->state.transform.matrixMode;
        break;
      case GL_VIEWPORT:
        *ip++ = gc->state.viewport.x;
        *ip++ = gc->state.viewport.y;
        *ip++ = gc->state.viewport.width;
        *ip++ = gc->state.viewport.height;
        break;
      case GL_ATTRIB_STACK_DEPTH:
        *ip++ = (GLint)((ULONG_PTR)(gc->attributes.stackPointer - gc->attributes.stack));
        break;
      case GL_CLIENT_ATTRIB_STACK_DEPTH:
        *ip++ = (GLint)((ULONG_PTR)(gc->clientAttributes.stackPointer - gc->clientAttributes.stack));
        break;
      case GL_MODELVIEW_STACK_DEPTH:
        *ip++ = 1 + (GLint)((ULONG_PTR)(gc->transform.modelView - gc->transform.modelViewStack));
        break;
      case GL_PROJECTION_STACK_DEPTH:
        *ip++ = 1 + (GLint)((ULONG_PTR)(gc->transform.projection - gc->transform.projectionStack));
        break;
      case GL_TEXTURE_STACK_DEPTH:
        *ip++ = 1 + (GLint)((ULONG_PTR)(gc->transform.texture - gc->transform.textureStack));
        break;
      case GL_MODELVIEW_MATRIX:
	mp = &gc->transform.modelView->matrix.matrix[0][0];
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
        break;
      case GL_PROJECTION_MATRIX:
	mp = &gc->transform.projection->matrix.matrix[0][0];
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
        break;
      case GL_TEXTURE_MATRIX:
	mp = &gc->transform.texture->matrix.matrix[0][0];
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
	*fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++; *fp++ = *mp++;
        break;
      case GL_ALPHA_TEST_FUNC:
        *ip++ = gc->state.raster.alphaFunction;
        break;
      case GL_ALPHA_TEST_REF:
        *fp++ = gc->state.raster.alphaReference;
        break;
      case GL_BLEND_DST:
        *ip++ = gc->state.raster.blendDst;
        break;
      case GL_BLEND_SRC:
        *ip++ = gc->state.raster.blendSrc;
        break;
      case GL_LOGIC_OP_MODE:
        *ip++ = gc->state.raster.logicOp;
        break;
      case GL_DRAW_BUFFER:
        *ip++ = gc->state.raster.drawBufferReturn;
        break;
      case GL_READ_BUFFER:
        *ip++ = gc->state.pixel.readBufferReturn;
        break;
      case GL_SCISSOR_BOX:
        *ip++ = gc->state.scissor.scissorX;
        *ip++ = gc->state.scissor.scissorY;
        *ip++ = gc->state.scissor.scissorWidth;
        *ip++ = gc->state.scissor.scissorHeight;
        break;
      case GL_INDEX_CLEAR_VALUE:
        *fp++ = gc->state.raster.clearIndex;
        break;
      case GL_INDEX_MODE:
        *lp++ = gc->modes.colorIndexMode ? GL_TRUE : GL_FALSE;
        break;
      case GL_INDEX_WRITEMASK:
        *ip++ = gc->state.raster.writeMask;
        break;
      case GL_COLOR_CLEAR_VALUE:
        *cp++ = gc->state.raster.clear.r;
        *cp++ = gc->state.raster.clear.g;
        *cp++ = gc->state.raster.clear.b;
        *cp++ = gc->state.raster.clear.a;
        break;
      case GL_RGBA_MODE:
        *lp++ = gc->modes.rgbMode ? GL_TRUE : GL_FALSE;
        break;
      case GL_COLOR_WRITEMASK:
        *lp++ = gc->state.raster.rMask;
        *lp++ = gc->state.raster.gMask;
        *lp++ = gc->state.raster.bMask;
        *lp++ = gc->state.raster.aMask;
        break;
      case GL_RENDER_MODE:
	*ip++ = gc->renderMode;
	break;
      case GL_PERSPECTIVE_CORRECTION_HINT:
        *ip++ = gc->state.hints.perspectiveCorrection;
        break;
      case GL_POINT_SMOOTH_HINT:
        *ip++ = gc->state.hints.pointSmooth;
        break;
      case GL_LINE_SMOOTH_HINT:
        *ip++ = gc->state.hints.lineSmooth;
        break;
      case GL_POLYGON_SMOOTH_HINT:
        *ip++ = gc->state.hints.polygonSmooth;
        break;
      case GL_FOG_HINT:
        *ip++ = gc->state.hints.fog;
        break;
#ifdef GL_WIN_phong_shading
      case GL_PHONG_HINT_WIN:
        *ip++ = gc->state.hints.phong;
        break;
#endif //GL_WIN_phong_shading
      case GL_LIST_BASE:
        *ip++ = gc->state.list.listBase;
        break;
      case GL_LIST_INDEX:
	*ip++ = gc->dlist.currentList;
	break;
      case GL_LIST_MODE:
	*ip++ = gc->dlist.mode;
	break;
      case GL_PACK_SWAP_BYTES:
        *lp++ = gc->state.pixel.packModes.swapEndian;
        break;
      case GL_PACK_LSB_FIRST:
        *lp++ = gc->state.pixel.packModes.lsbFirst;
        break;
      case GL_PACK_ROW_LENGTH:
        *ip++ = gc->state.pixel.packModes.lineLength;
        break;
      case GL_PACK_SKIP_ROWS:
        *ip++ = gc->state.pixel.packModes.skipLines;
        break;
      case GL_PACK_SKIP_PIXELS:
        *ip++ = gc->state.pixel.packModes.skipPixels;
        break;
      case GL_PACK_ALIGNMENT:
        *ip++ = gc->state.pixel.packModes.alignment;
        break;
      case GL_UNPACK_SWAP_BYTES:
        *lp++ = gc->state.pixel.unpackModes.swapEndian;
        break;
      case GL_UNPACK_LSB_FIRST:
        *lp++ = gc->state.pixel.unpackModes.lsbFirst;
        break;
      case GL_UNPACK_ROW_LENGTH:
        *ip++ = gc->state.pixel.unpackModes.lineLength;
        break;
      case GL_UNPACK_SKIP_ROWS:
        *ip++ = gc->state.pixel.unpackModes.skipLines;
        break;
      case GL_UNPACK_SKIP_PIXELS:
        *ip++ = gc->state.pixel.unpackModes.skipPixels;
        break;
      case GL_UNPACK_ALIGNMENT:
        *ip++ = gc->state.pixel.unpackModes.alignment;
        break;
      case GL_MAP_COLOR:
        *lp++ = gc->state.pixel.transferMode.mapColor;
        break;
      case GL_MAP_STENCIL:
        *lp++ = gc->state.pixel.transferMode.mapStencil;
        break;
      case GL_INDEX_SHIFT:
        *ip++ = gc->state.pixel.transferMode.indexShift;
        break;
      case GL_INDEX_OFFSET:
        *ip++ = gc->state.pixel.transferMode.indexOffset;
        break;
      case GL_RED_SCALE:
        *fp++ = gc->state.pixel.transferMode.r_scale;
        break;
      case GL_GREEN_SCALE:
        *fp++ = gc->state.pixel.transferMode.g_scale;
        break;
      case GL_BLUE_SCALE:
        *fp++ = gc->state.pixel.transferMode.b_scale;
        break;
      case GL_ALPHA_SCALE:
        *fp++ = gc->state.pixel.transferMode.a_scale;
        break;
      case GL_DEPTH_SCALE:
        *fp++ = gc->state.pixel.transferMode.d_scale;
        break;
      case GL_RED_BIAS:
        *fp++ = gc->state.pixel.transferMode.r_bias;
	break;
      case GL_GREEN_BIAS:
        *fp++ = gc->state.pixel.transferMode.g_bias;
	break;
      case GL_BLUE_BIAS:
        *fp++ = gc->state.pixel.transferMode.b_bias;
	break;
      case GL_ALPHA_BIAS:
        *fp++ = gc->state.pixel.transferMode.a_bias;
	break;
      case GL_DEPTH_BIAS:
        *fp++ = gc->state.pixel.transferMode.d_bias;
	break;
      case GL_ZOOM_X:
        *fp++ = gc->state.pixel.transferMode.zoomX;
        break;
      case GL_ZOOM_Y:
        *fp++ = gc->state.pixel.transferMode.zoomY;
        break;
      case GL_PIXEL_MAP_I_TO_I_SIZE:      case GL_PIXEL_MAP_S_TO_S_SIZE:
      case GL_PIXEL_MAP_I_TO_R_SIZE:      case GL_PIXEL_MAP_I_TO_G_SIZE:
      case GL_PIXEL_MAP_I_TO_B_SIZE:      case GL_PIXEL_MAP_I_TO_A_SIZE:
      case GL_PIXEL_MAP_R_TO_R_SIZE:      case GL_PIXEL_MAP_G_TO_G_SIZE:
      case GL_PIXEL_MAP_B_TO_B_SIZE:      case GL_PIXEL_MAP_A_TO_A_SIZE:
	index = sq - GL_PIXEL_MAP_I_TO_I_SIZE;
	*ip++ = gc->state.pixel.pixelMap[index].size;
	break;
      case GL_MAX_EVAL_ORDER:
        *ip++ = gc->constants.maxEvalOrder;
        break;
      case GL_MAX_LIGHTS:
        *ip++ = gc->constants.numberOfLights;
        break;
      case GL_MAX_CLIP_PLANES:
	*ip++ = gc->constants.numberOfClipPlanes;
	break;
      case GL_MAX_PIXEL_MAP_TABLE:
	*ip++ = gc->constants.maxPixelMapTable;
	break;
      case GL_MAX_ATTRIB_STACK_DEPTH:
        *ip++ = gc->constants.maxAttribStackDepth;
        break;
      case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
        *ip++ = gc->constants.maxClientAttribStackDepth;
        break;
      case GL_MAX_MODELVIEW_STACK_DEPTH:
#ifdef NT
        *ip++ = __GL_WGL_MAX_MODELVIEW_STACK_DEPTH;
#else
        *ip++ = gc->constants.maxModelViewStackDepth;
#endif
        break;
      case GL_MAX_NAME_STACK_DEPTH:
        *ip++ = gc->constants.maxNameStackDepth;
        break;
      case GL_MAX_PROJECTION_STACK_DEPTH:
#ifdef NT
        *ip++ = __GL_WGL_MAX_PROJECTION_STACK_DEPTH;
#else
        *ip++ = gc->constants.maxProjectionStackDepth;
#endif
        break;
      case GL_MAX_TEXTURE_STACK_DEPTH:
#ifdef NT
        *ip++ = __GL_WGL_MAX_TEXTURE_STACK_DEPTH;
#else
        *ip++ = gc->constants.maxTextureStackDepth;
#endif
        break;
      case GL_INDEX_BITS:
	*ip++ = gc->modes.indexBits;
	break;
      case GL_RED_BITS:
	*ip++ = gc->modes.redBits;
	break;
      case GL_GREEN_BITS:
	*ip++ = gc->modes.greenBits;
	break;
      case GL_BLUE_BITS:
	*ip++ = gc->modes.blueBits;
	break;
      case GL_ALPHA_BITS:
	*ip++ = gc->modes.alphaBits;
	break;
      case GL_DEPTH_BITS:
        // gc->modes.depthBits is the number of bits in the total
        // depth pixel, not just the number of active bits.
        // Usually these quantities are the same, but not always
        // for MCD.
        *ip++ = ((__GLGENcontext *)gc)->gsurf.pfd.cDepthBits;
	break;
      case GL_STENCIL_BITS:
	*ip++ = gc->modes.stencilBits;
	break;
      case GL_ACCUM_RED_BITS:
      case GL_ACCUM_GREEN_BITS:
      case GL_ACCUM_BLUE_BITS:
      case GL_ACCUM_ALPHA_BITS:
	*ip++ = gc->modes.accumBits;
	break;
      case GL_MAP1_GRID_DOMAIN:
        *fp++ = gc->state.evaluator.u1.start;
        *fp++ = gc->state.evaluator.u1.finish;
        break;
      case GL_MAP1_GRID_SEGMENTS:
        *ip++ = gc->state.evaluator.u1.n;
        break;
      case GL_MAP2_GRID_DOMAIN:
        *fp++ = gc->state.evaluator.u2.start;
        *fp++ = gc->state.evaluator.u2.finish;
        *fp++ = gc->state.evaluator.v2.start;
        *fp++ = gc->state.evaluator.v2.finish;
        break;
      case GL_MAP2_GRID_SEGMENTS:
        *ip++ = gc->state.evaluator.u2.n;
        *ip++ = gc->state.evaluator.v2.n;
        break;
      case GL_NAME_STACK_DEPTH:
	*ip++ = (GLint)((ULONG_PTR)(gc->select.sp - gc->select.stack));
	break;
      case GL_MAX_VIEWPORT_DIMS:
	*ip++ = gc->constants.maxViewportWidth;
	*ip++ = gc->constants.maxViewportHeight;
	break;
      case GL_DOUBLEBUFFER:
	*lp++ = gc->modes.doubleBufferMode ? GL_TRUE : GL_FALSE;
	break;
      case GL_AUX_BUFFERS:
	*ip++ = gc->modes.maxAuxBuffers;
	break;
      case GL_STEREO:
	*lp++ = GL_FALSE;
	break;
      case GL_TEXTURE_BINDING_1D:
	{
	    __GLtextureObjectState *ptos;
	    ptos = __glLookUpTextureTexobjs(gc, GL_TEXTURE_1D);
	    *ip++ = ptos->name;
	}
	break;
      case GL_TEXTURE_BINDING_2D:
	{
	    __GLtextureObjectState *ptos;
	    ptos = __glLookUpTextureTexobjs(gc, GL_TEXTURE_2D);
	    *ip++ = ptos->name;
	}
	break;
      case GL_POLYGON_OFFSET_FACTOR:
	*fp++ = gc->state.polygon.factor;
	break;
      case GL_POLYGON_OFFSET_UNITS:
	*fp++ = gc->state.polygon.units;
	break;
      case GL_VERTEX_ARRAY_SIZE:
	*ip++ = gc->vertexArray.vertex.size;
	break;
      case GL_VERTEX_ARRAY_TYPE:
	*ip++ = gc->vertexArray.vertex.type;
	break;
      case GL_VERTEX_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.vertex.stride;
	break;
      case GL_NORMAL_ARRAY_TYPE:
	*ip++ = gc->vertexArray.normal.type;
	break;
      case GL_NORMAL_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.normal.stride;
	break;
      case GL_COLOR_ARRAY_SIZE:
	*ip++ = gc->vertexArray.color.size;
	break;
      case GL_COLOR_ARRAY_TYPE:
	*ip++ = gc->vertexArray.color.type;
	break;
      case GL_COLOR_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.color.stride;
	break;
      case GL_INDEX_ARRAY_TYPE:
	*ip++ = gc->vertexArray.index.type;
	break;
      case GL_INDEX_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.index.stride;
	break;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
	*ip++ = gc->vertexArray.texCoord.size;
	break;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
	*ip++ = gc->vertexArray.texCoord.type;
	break;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.texCoord.stride;
	break;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
	*ip++ = gc->vertexArray.edgeFlag.stride;
	break;
      case GL_FEEDBACK_BUFFER_SIZE:
        *ip++ = gc->feedback.resultLength;
        break;
      case GL_FEEDBACK_BUFFER_TYPE:
        *ip++ = gc->feedback.type;
        break;
      case GL_SELECTION_BUFFER_SIZE:
        *ip++ = gc->select.resultLength;
        break;
      case GL_MAX_ELEMENTS_INDICES_WIN:
	*ip++ = VA_DRAWRANGEELEM_MAX_INDICES;
	break;
      case GL_MAX_ELEMENTS_VERTICES_WIN:
	*ip++ = VA_DRAWRANGEELEM_MAX_VERTICES;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    /* Use the motion of the pointers to type convert the result */
    if (ip != itemp) {
	__glConvertResult(gc, __GL_INT32, itemp, type, result, (GLint)((ULONG_PTR)(ip - itemp)));
    } else
    if (fp != ftemp) {
	__glConvertResult(gc, __GL_FLOAT, ftemp, type, result, (GLint)((ULONG_PTR)(fp - ftemp)));
    } else
    if (lp != ltemp) {
	__glConvertResult(gc, __GL_BOOLEAN, ltemp, type, result, (GLint)((ULONG_PTR)(lp - ltemp)));
    } else
    if (cp != ctemp) {
	__glConvertResult(gc, __GL_COLOR, ctemp, type, result, (GLint)((ULONG_PTR)(cp - ctemp)));
    } else
    if (scp != sctemp) {
	__glConvertResult(gc, __GL_SCOLOR, sctemp, type, result, (GLint)((ULONG_PTR)(scp - sctemp)));
    }
}

#ifdef NT
// __glGenDoGet implemented in ..\generic\gencx.c
extern void FASTCALL __glGenDoGet(GLenum, void *, GLint, const char *);
#endif

void APIPRIVATE __glim_GetDoublev(GLenum sq, GLdouble result[])
{
#ifdef NT
    __glGenDoGet(sq, result, __GL_FLOAT64, "glGetDoublev");
#else
    __glDoGet(sq, result, __GL_FLOAT64, "glGetDoublev");
#endif
}

void APIPRIVATE __glim_GetFloatv(GLenum sq, GLfloat result[])
{
#ifdef NT
    __glGenDoGet(sq, result, __GL_FLOAT32, "glGetFloatv");
#else
    __glDoGet(sq, result, __GL_FLOAT32, "glGetFloatv");
#endif
}

void APIPRIVATE __glim_GetIntegerv(GLenum sq, GLint result[])
{
#ifdef NT
    __glGenDoGet(sq, result, __GL_INT32, "glGetIntegerv");
#else
    __glDoGet(sq, result, __GL_INT32, "glGetIntegerv");
#endif
}

void APIPRIVATE __glim_GetBooleanv(GLenum sq, GLboolean result[])
{
#ifdef NT
    __glGenDoGet(sq, result, __GL_BOOLEAN, "glGetBooleanv");
#else
    __glDoGet(sq, result, __GL_BOOLEAN, "glGetBooleanv");
#endif
}

/*
** Return the current error code.
*/
GLenum APIPRIVATE __glim_GetError(void)
{
    __GL_SETUP();
    GLint error;

#ifdef NT
    // glGetError is supposed to return GL_INVALID_OPERATION within
    // a glBegin/glEnd pair but this can cause problems with apps
    // which don't expect it.  The suggested behavior is to return
    // GL_NO_ERROR inside glBegin/glEnd but set the error code to
    // GL_INVALID_OPERATION so a later glGetError outside of the
    // glBegin/glEnd will return it
    if (__GL_IN_BEGIN())
    {
        error = GL_NO_ERROR;
        gc->error = GL_INVALID_OPERATION;
    }
    else
    {
#endif
        error = gc->error;
        gc->error = 0;
#ifdef NT
    }
#endif

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_image.c ===
/*
** Copyright 1991,1992 Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.7 $
** $Date: 1993/06/18 00:29:39 $
*/
#include "precomp.h"
#pragma hdrstop

GLubyte __glMsbToLsbTable[256] = {
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

static GLubyte LowBitsMask[9] = {
    0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff,
};

static GLubyte HighBitsMask[9] = {
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff,
};

/************************************************************************/

void FASTCALL __glConvertStipple(__GLcontext *gc)
{
    GLubyte b0, b1, b2, b3, *stipple;
    GLuint *dst;
    GLint i;

    stipple = &gc->state.polygonStipple.stipple[0];
    dst = &gc->polygon.stipple[0];
#ifdef __GL_STIPPLE_MSB
    /*
    ** Convert input stipple bytes which are in little endian MSB format
    ** into a single long word, whose high bit represents the left most
    ** X coordinate of a 32 bit span.
    */
    for (i = 0; i < 32; i++) {
	b0 = *stipple++;
	b1 = *stipple++;
	b2 = *stipple++;
	b3 = *stipple++;
	*dst++ = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
    }
#else
    /*
    ** Make 32bit form of the stipple for easier rendering.
    */
    for (i = 0; i < 32; i++) {
	b0 = __glMsbToLsbTable[*stipple++];
	b1 = __glMsbToLsbTable[*stipple++];
	b2 = __glMsbToLsbTable[*stipple++];
	b3 = __glMsbToLsbTable[*stipple++];
	*dst++ = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
    }
#endif
}

/************************************************************************/

/*
** Compute memory required for internal packed array of data of given type
** and format.
*/
GLint APIPRIVATE __glImageSize(GLsizei width, GLsizei height, GLenum format, GLenum type) 
{
    GLint bytes_per_row;
    GLint components;

    components = __glElementsPerGroup(format);
    if (type == GL_BITMAP) {
	bytes_per_row = (width + 7) >> 3;
    } else {
	bytes_per_row =(GLint)__glBytesPerElement(type) * width;
    }
    return bytes_per_row * height * components;
}

/*
** Extract array from user's data applying all pixel store modes.
** The internal packed array format used has LSB_FIRST = FALSE and 
** ALIGNMENT = 1.
*/
void APIPRIVATE __glFillImage(__GLcontext *gc, GLsizei width, GLsizei height,
		   GLenum format, GLenum type,
		   const GLvoid *userdata, GLubyte *newimage)
{
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint line_length = gc->state.pixel.unpackModes.lineLength;
    GLint alignment = gc->state.pixel.unpackModes.alignment;
    GLint skip_pixels = gc->state.pixel.unpackModes.skipPixels;
    GLint skip_lines = gc->state.pixel.unpackModes.skipLines;
    GLint groups_per_line;
    GLint group_size;
    GLint lsb_first = gc->state.pixel.unpackModes.lsbFirst;
    GLint swap_bytes = gc->state.pixel.unpackModes.swapEndian;
    GLint elements_per_line;
    const GLubyte *start;
    const GLubyte *iter;
    GLubyte *iter2;
    GLint i, j, k;

    components = __glElementsPerGroup(format);
    if (line_length > 0) {
	groups_per_line = line_length;
    } else {
	groups_per_line = width;
    }

    /* All formats except GL_BITMAP fall out trivially */
    if (type == GL_BITMAP) {
	GLint elements_left;
	GLint bit_offset;
	GLint current_byte;
	GLint next_byte;
	GLint high_bit_mask;
	GLint low_bit_mask;

	rowsize = (groups_per_line * components + 7) / 8;
	padding = (rowsize % alignment);
	if (padding) {
	    rowsize += alignment - padding;
	}
	start = ((const GLubyte*) userdata) + skip_lines * rowsize + 
		(skip_pixels * components / 8);
	bit_offset = (skip_pixels * components) % 8;
	high_bit_mask = LowBitsMask[8-bit_offset];
	low_bit_mask = HighBitsMask[bit_offset];
	elements_per_line = width * components;
	iter2 = newimage;
	for (i = 0; i < height; i++) {
	    elements_left = elements_per_line;
	    iter = start;
	    while (elements_left) {
		/* First retrieve low bits from current byte */
		if (lsb_first) {
		    current_byte = __glMsbToLsbTable[iter[0]];
		} else {
		    current_byte = iter[0];
		}
		if (bit_offset) {
		    /* Need to read next byte to finish current byte */
		    if (elements_left > (8 - bit_offset)) {
			if (lsb_first) {
			    next_byte = __glMsbToLsbTable[iter[1]];
			} else {
			    next_byte = iter[1];
			}
			current_byte = 
			    ((current_byte & high_bit_mask) << bit_offset) |
			    ((next_byte & low_bit_mask) >> (8 - bit_offset));
		    } else {
			current_byte = 
			    ((current_byte & high_bit_mask) << bit_offset);
		    }
		} 
		if (elements_left >= 8) {
		    *iter2 = (GLubyte) current_byte;
		    elements_left -= 8;
		} else {
		    *iter2 = (GLubyte)
			(current_byte & HighBitsMask[elements_left]);
		    elements_left = 0;
		}
		iter2++;
		iter++;
	    }
	    start += rowsize;
	}
    } else {
	element_size = (GLint)__glBytesPerElement(type);
	group_size = element_size * components;
	if (element_size == 1) swap_bytes = 0;

	rowsize = groups_per_line * group_size;
	padding = (rowsize % alignment);
	if (padding) {
	    rowsize += alignment - padding;
	}
	start = ((const GLubyte*) userdata) + skip_lines * rowsize
	    + skip_pixels * group_size;
	iter2 = newimage;
	elements_per_line = width * components;

	if (swap_bytes) {
	    for (i = 0; i < height; i++) {
		iter = start;
		for (j = 0; j < elements_per_line; j++) {
		    for (k = 1; k <= element_size; k++) {
			iter2[k-1] = iter[element_size - k];
		    }
		    iter2 += element_size;
		    iter += element_size;
		}
		start += rowsize;
	    }
	} else {
	    if (rowsize == elements_per_line * element_size) {
		/* Ha!  This is mondo easy! */
		__GL_MEMCOPY(iter2, start,
			     elements_per_line * element_size * height);
	    } else {
		iter = start;
		for (i = 0; i < height; i++) {
		    __GL_MEMCOPY(iter2, iter, elements_per_line * element_size);
		    iter2 += elements_per_line * element_size;
		    iter += rowsize;
		}
	    }
	}
    }
}

/*
** Insert array into user's data applying all pixel store modes.
** The internal packed array format used has LSB_FIRST = FALSE and 
** ALIGNMENT = 1.  __glEmptyImage() because it is the opposite of 
** __glFillImage().
*/
void __glEmptyImage(__GLcontext *gc, GLsizei width, GLsizei height,
		    GLenum format, GLenum type,
		    const GLubyte *oldimage, GLvoid *userdata)
{
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint line_length = gc->state.pixel.packModes.lineLength;
    GLint alignment = gc->state.pixel.packModes.alignment;
    GLint skip_pixels = gc->state.pixel.packModes.skipPixels;
    GLint skip_lines = gc->state.pixel.packModes.skipLines;
    GLint groups_per_line;
    GLint group_size;
    GLint lsb_first = gc->state.pixel.packModes.lsbFirst;
    GLint swap_bytes = gc->state.pixel.packModes.swapEndian;
    GLint elements_per_line;
    GLubyte *start;
    GLubyte *iter;
    const GLubyte *iter2;
    GLint i, j, k;

    components = __glElementsPerGroup(format);
    if (line_length > 0) {
	groups_per_line = line_length;
    } else {
	groups_per_line = width;
    }

    /* All formats except GL_BITMAP fall out trivially */
    if (type == GL_BITMAP) {
	GLint elements_left;
	GLint bit_offset;
	GLint current_byte;
	GLint high_bit_mask;
	GLint low_bit_mask;
	GLint write_mask;
	GLubyte write_byte;

	rowsize = (groups_per_line * components + 7) / 8;
	padding = (rowsize % alignment);
	if (padding) {
	    rowsize += alignment - padding;
	}
	start = ((GLubyte*) userdata) + skip_lines * rowsize + 
		(skip_pixels * components / 8);
	bit_offset = (skip_pixels * components) % 8;
	high_bit_mask = LowBitsMask[8-bit_offset];
	low_bit_mask = HighBitsMask[bit_offset];
	elements_per_line = width * components;
	iter2 = oldimage;
	for (i = 0; i < height; i++) {
	    elements_left = elements_per_line;
	    iter = start;
	    write_mask = high_bit_mask;
	    write_byte = 0;
	    while (elements_left) {
		/* Set up write_mask (to write to current byte) */
		if (elements_left + bit_offset < 8) {
		    /* Need to trim write_mask */
		    write_mask &= HighBitsMask[bit_offset+elements_left];
		}

		if (lsb_first) {
		    current_byte = __glMsbToLsbTable[iter[0]];
		} else {
		    current_byte = iter[0];
		}

		if (bit_offset) {
		    write_byte |= (GLubyte) (iter2[0] >> bit_offset);
		    current_byte = (current_byte & ~write_mask) | 
			    (write_byte & write_mask);
		    write_byte = (GLubyte) (iter2[0] << (8 - bit_offset));
		} else {
		    current_byte = (current_byte & ~write_mask) |
			    (iter2[0] & write_mask);
		}

		if (lsb_first) {
		    iter[0] = __glMsbToLsbTable[current_byte];
		} else {
		    iter[0] = (GLubyte) current_byte;
		}

		if (elements_left >= 8) {
		    elements_left -= 8;
		} else {
		    elements_left = 0;
		}
		iter2++;
		iter++;
		write_mask = 0xff;
	    }
	    if (write_byte) {
		/* Some data left over that still needs writing */
		write_mask &= low_bit_mask;
		if (lsb_first) {
		    current_byte = __glMsbToLsbTable[iter[0]];
		} else {
		    current_byte = iter[0];
		}

		current_byte = (current_byte & ~write_mask) |
			(write_byte & write_mask);
		
		if (lsb_first) {
		    iter[0] = __glMsbToLsbTable[current_byte];
		} else {
		    iter[0] = (GLubyte) current_byte;
		}
	    }
	    start += rowsize;
	}
    } else {
	element_size = (GLint)__glBytesPerElement(type);
	group_size = element_size * components;
	if (element_size == 1) swap_bytes = 0;

	rowsize = groups_per_line * group_size;
	padding = (rowsize % alignment);
	if (padding) {
	    rowsize += alignment - padding;
	}
	start = ((GLubyte*) userdata) + skip_lines * rowsize
	    + skip_pixels * group_size;
	iter2 = oldimage;
	elements_per_line = width * components;

	if (swap_bytes) {
	    for (i = 0; i < height; i++) {
		iter = start;
		for (j = 0; j < elements_per_line; j++) {
		    for (k = 1; k <= element_size; k++) {
			iter[k-1] = iter2[element_size - k];
		    }
		    iter2 += element_size;
		    iter += element_size;
		}
		start += rowsize;
	    }
	} else {
	    if (rowsize == elements_per_line * element_size) {
		/* Ha!  This is mondo easy! */
		__GL_MEMCOPY(start, iter2,
			     elements_per_line * element_size * height);
	    } else {
		iter = start;
		for (i = 0; i < height; i++) {
		    __GL_MEMCOPY(iter, iter2, elements_per_line * element_size);
		    iter2 += elements_per_line * element_size;
		    iter += rowsize;
		}
	    }
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_light.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Lighting and coloring code.
**
** $Revision: 1.42 $
** $Date: 1993/12/08 02:20:39 $
*/

#include "precomp.h"
#pragma hdrstop

/*
** Scale an incoming color from the user.
*/
void FASTCALL __glScaleColorf(__GLcontext *gc, __GLcolor *dst, const GLfloat src[4])
{
    dst->r = src[0] * gc->redVertexScale;
    dst->g = src[1] * gc->greenVertexScale;
    dst->b = src[2] * gc->blueVertexScale;
    dst->a = src[3] * gc->alphaVertexScale;
}

/*
** Clamp and scale an incoming color from the user.
*/
void FASTCALL __glClampAndScaleColorf(__GLcontext *gc, __GLcolor *d, const GLfloat s[4])
{
    __GLfloat zero = __glZero;

    d->r = s[0] * gc->redVertexScale;
    if (d->r < zero) d->r = zero;
    if (d->r > gc->redVertexScale) d->r = gc->redVertexScale;

    d->g = s[1] * gc->greenVertexScale;
    if (d->g < zero) d->g = zero;
    if (d->g > gc->greenVertexScale) d->g = gc->greenVertexScale;

    d->b = s[2] * gc->blueVertexScale;
    if (d->b < zero) d->b = zero;
    if (d->b > gc->blueVertexScale) d->b = gc->blueVertexScale;

    d->a = s[3] * gc->alphaVertexScale;
    if (d->a < zero) d->a = zero;
    if (d->a > gc->alphaVertexScale) d->a = gc->alphaVertexScale;
}

/*
** Clamp an incoming color from the user.
*/
void FASTCALL __glClampColorf(__GLcontext *gc, __GLcolor *d, const GLfloat s[4])
{
    __GLfloat zero = __glZero;
    __GLfloat one = __glOne;
    __GLfloat r,g,b,a;

    r = s[0];
    g = s[1];
    b = s[2];
    a = s[3];

    if (r < zero) d->r = zero;
    else if (r > one) d->r = one;
    else d->r = r;

    if (g < zero) d->g = zero;
    else if (g > one) d->g = one;
    else d->g = g;

    if (b < zero) d->b = zero;
    else if (b > one) d->b = one;
    else d->b = b;

    if (a < zero) d->a = zero;
    else if (a > one) d->a = one;
    else d->a = a;
}

/*
** Clamp and scale an incoming color from the user.
*/
void FASTCALL __glClampAndScaleColori(__GLcontext *gc, __GLcolor *d, const GLint s[4])
{
    __GLfloat zero = __glZero;

    d->r = __GL_I_TO_FLOAT(s[0]) * gc->redVertexScale;
    if (d->r < zero) d->r = zero;
    if (d->r > gc->redVertexScale) d->r = gc->redVertexScale;

    d->g = __GL_I_TO_FLOAT(s[1]) * gc->greenVertexScale;
    if (d->g < zero) d->g = zero;
    if (d->g > gc->greenVertexScale) d->g = gc->greenVertexScale;

    d->b = __GL_I_TO_FLOAT(s[2]) * gc->blueVertexScale;
    if (d->b < zero) d->b = zero;
    if (d->b > gc->blueVertexScale) d->b = gc->blueVertexScale;

    d->a = __GL_I_TO_FLOAT(s[3]) * gc->alphaVertexScale;
    if (d->a < zero) d->a = zero;
    if (d->a > gc->alphaVertexScale) d->a = gc->alphaVertexScale;
}

/*
** Clamp an incoming color from the user.
*/
void FASTCALL __glClampColori(__GLcontext *gc, __GLcolor *d, const GLint s[4])
{
    __GLfloat zero = __glZero;
    __GLfloat one = __glOne;
    __GLfloat r,g,b,a;

    r = __GL_I_TO_FLOAT(s[0]);
    g = __GL_I_TO_FLOAT(s[1]);
    b = __GL_I_TO_FLOAT(s[2]);
    a = __GL_I_TO_FLOAT(s[3]);

    if (r < zero) d->r = zero;
    else if (r > one) d->r = one;
    else d->r = r;

    if (g < zero) d->g = zero;
    else if (g > one) d->g = one;
    else d->g = g;

    if (b < zero) d->b = zero;
    else if (b > one) d->b = one;
    else d->b = b;

    if (a < zero) d->a = zero;
    else if (a > one) d->a = one;
    else d->a = a;
}

/*
** Reverse the scaling back to the users original
*/
void FASTCALL __glUnScaleColorf(__GLcontext *gc, GLfloat dst[4], const __GLcolor* src)
{
    dst[0] = src->r * gc->oneOverRedVertexScale;
    dst[1] = src->g * gc->oneOverGreenVertexScale;
    dst[2] = src->b * gc->oneOverBlueVertexScale;
    dst[3] = src->a * gc->oneOverAlphaVertexScale;
}

/*
** Reverse the scaling back to the users original
*/
void FASTCALL __glUnScaleColori(__GLcontext *gc, GLint dst[4], const __GLcolor* src)
{
    dst[0] = __GL_FLOAT_TO_I(src->r * gc->oneOverRedVertexScale);
    dst[1] = __GL_FLOAT_TO_I(src->g * gc->oneOverGreenVertexScale);
    dst[2] = __GL_FLOAT_TO_I(src->b * gc->oneOverBlueVertexScale);
    dst[3] = __GL_FLOAT_TO_I(src->a * gc->oneOverAlphaVertexScale);
}

/*
** Clamp an already scaled RGB color.
*/
void FASTCALL __glClampRGBColor(__GLcontext *gc, __GLcolor *dst, const __GLcolor *src)
{
    __GLfloat zero = __glZero;
    __GLfloat r, g, b, a;
    __GLfloat rl, gl, bl, al;

    r = src->r; rl = gc->redVertexScale;
    if (r <= zero) {
	dst->r = zero;
    } else {
	if (r >= rl) {
	    dst->r = rl;
	} else {
	    dst->r = r;
	}
    }
    g = src->g; gl = gc->greenVertexScale;
    if (g <= zero) {
	dst->g = zero;
    } else {
	if (g >= gl) {
	    dst->g = gl;
	} else {
	    dst->g = g;
	}
    }
    b = src->b; bl = gc->blueVertexScale;
    if (b <= zero) {
	dst->b = zero;
    } else {
	if (b >= bl) {
	    dst->b = bl;
	} else {
	    dst->b = b;
	}
    }
    a = src->a; al = gc->alphaVertexScale;
    if (a <= zero) {
	dst->a = zero;
    } else {
	if (a >= al) {
	    dst->a = al;
	} else {
	    dst->a = a;
	}
    }
}

/************************************************************************/

/*
** gc->procs.applyColor procs.  These are used to apply the current color
** change to either a material color, or to current.color (when not
** lighting), preparing the color for copying into the vertex.
*/

void FASTCALL ChangeMaterialEmission(__GLcontext *gc, __GLmaterialState *ms,
				   __GLmaterialMachine *msm)
{
    __GLfloat r, g, b;

    r = gc->state.current.userColor.r * gc->redVertexScale;
    g = gc->state.current.userColor.g * gc->greenVertexScale;
    b = gc->state.current.userColor.b * gc->blueVertexScale;

    ms->emissive.r = r;
    ms->emissive.g = g;
    ms->emissive.b = b;
    ms->emissive.a = gc->state.current.userColor.a * gc->alphaVertexScale;

#ifdef NT
    // compute the invariant scene color
    msm->paSceneColor.r = ms->ambient.r * gc->state.light.model.ambient.r;
    msm->paSceneColor.g = ms->ambient.g * gc->state.light.model.ambient.g;
    msm->paSceneColor.b = ms->ambient.b * gc->state.light.model.ambient.b;
#else
    msm->sceneColor.r = r + ms->ambient.r * gc->state.light.model.ambient.r;
    msm->sceneColor.g = g + ms->ambient.g * gc->state.light.model.ambient.g;
    msm->sceneColor.b = b + ms->ambient.b * gc->state.light.model.ambient.b;
#endif
}

void FASTCALL ChangeMaterialSpecular(__GLcontext *gc, __GLmaterialState *ms,
				   __GLmaterialMachine *msm)
{
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    GLboolean isBack;
    __GLfloat r, g, b;

    r = gc->state.current.userColor.r;
    g = gc->state.current.userColor.g;
    b = gc->state.current.userColor.b;

    ms->specular.r = r;
    ms->specular.g = g;
    ms->specular.b = b;
    ms->specular.a = gc->state.current.userColor.a;

    /*
    ** Update per-light-source state that depends on material specular
    ** state
    */
    isBack = msm == &gc->light.back;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	lspmm = &lsm->front + isBack;
	lss = lsm->state;

	/* Recompute per-light per-material cached specular */
	lspmm->specular.r = r * lss->specular.r;
	lspmm->specular.g = g * lss->specular.g;
	lspmm->specular.b = b * lss->specular.b;
    }
}

void FASTCALL ChangeMaterialAmbient(__GLcontext *gc, __GLmaterialState *ms,
				  __GLmaterialMachine *msm)
{
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    GLboolean isBack;
    __GLfloat r, g, b;

    r = gc->state.current.userColor.r;
    g = gc->state.current.userColor.g;
    b = gc->state.current.userColor.b;

    ms->ambient.r = r;
    ms->ambient.g = g;
    ms->ambient.b = b;
    ms->ambient.a = gc->state.current.userColor.a;

#ifdef NT
    // compute the invariant scene color
    msm->paSceneColor.r = ms->emissive.r;
    msm->paSceneColor.g = ms->emissive.g;
    msm->paSceneColor.b = ms->emissive.b;
#else
    msm->sceneColor.r = ms->emissive.r + r * gc->state.light.model.ambient.r;
    msm->sceneColor.g = ms->emissive.g + g * gc->state.light.model.ambient.g;
    msm->sceneColor.b = ms->emissive.b + b * gc->state.light.model.ambient.b;
#endif

    /*
    ** Update per-light-source state that depends on material ambient
    ** state.
    */
    isBack = msm == &gc->light.back;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	lspmm = &lsm->front + isBack;
	lss = lsm->state;

	/* Recompute per-light per-material cached ambient */
	lspmm->ambient.r = r * lss->ambient.r;
	lspmm->ambient.g = g * lss->ambient.g;
	lspmm->ambient.b = b * lss->ambient.b;
    }
}

void FASTCALL ChangeMaterialDiffuse(__GLcontext *gc, __GLmaterialState *ms,
				  __GLmaterialMachine *msm)
{
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    GLboolean isBack;
    __GLfloat r, g, b, a;

    r = gc->state.current.userColor.r;
    g = gc->state.current.userColor.g;
    b = gc->state.current.userColor.b;
    a = gc->state.current.userColor.a;

    ms->diffuse.r = r;
    ms->diffuse.g = g;
    ms->diffuse.b = b;
    ms->diffuse.a = a;

    if (a < __glZero) {
	a = __glZero;
    } else if (a > __glOne) {
	a = __glOne;
    }
    msm->alpha = a * gc->alphaVertexScale;

    /*
    ** Update per-light-source state that depends on material diffuse
    ** state.
    */
    isBack = msm == &gc->light.back;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	lspmm = &lsm->front + isBack;
	lss = lsm->state;

	/* Recompute per-light per-material cached diffuse */
	lspmm->diffuse.r = r * lss->diffuse.r;
	lspmm->diffuse.g = g * lss->diffuse.g;
	lspmm->diffuse.b = b * lss->diffuse.b;
    }
}

void FASTCALL ChangeMaterialAmbientAndDiffuse(__GLcontext *gc,
					    __GLmaterialState *ms,
					    __GLmaterialMachine *msm)
{
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    GLboolean isBack;
    __GLfloat r, g, b, a;

    r = gc->state.current.userColor.r;
    g = gc->state.current.userColor.g;
    b = gc->state.current.userColor.b;
    a = gc->state.current.userColor.a;

    ms->ambient.r = r;
    ms->ambient.g = g;
    ms->ambient.b = b;
    ms->ambient.a = a;

    ms->diffuse.r = r;
    ms->diffuse.g = g;
    ms->diffuse.b = b;
    ms->diffuse.a = a;

#ifdef NT
    // compute the invariant scene color
    msm->paSceneColor.r = ms->emissive.r;
    msm->paSceneColor.g = ms->emissive.g;
    msm->paSceneColor.b = ms->emissive.b;
#else
    msm->sceneColor.r = ms->emissive.r + r * gc->state.light.model.ambient.r;
    msm->sceneColor.g = ms->emissive.g + g * gc->state.light.model.ambient.g;
    msm->sceneColor.b = ms->emissive.b + b * gc->state.light.model.ambient.b;
#endif

    if (a < __glZero) {
	a = __glZero;
    } else if (a > __glOne) {
	a = __glOne;
    }
    msm->alpha = a * gc->alphaVertexScale;

    /*
    ** Update per-light-source state that depends on per-material state.
    */
    isBack = msm == &gc->light.back;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	lspmm = &lsm->front + isBack;
	lss = lsm->state;

	/* Recompute per-light per-material cached ambient */
	lspmm->ambient.r = r * lss->ambient.r;
	lspmm->ambient.g = g * lss->ambient.g;
	lspmm->ambient.b = b * lss->ambient.b;

	/* Recompute per-light per-material cached diffuse */
	lspmm->diffuse.r = r * lss->diffuse.r;
	lspmm->diffuse.g = g * lss->diffuse.g;
	lspmm->diffuse.b = b * lss->diffuse.b;
    }
}

void FASTCALL __glChangeOneMaterialColor(__GLcontext *gc)
{
    (*gc->procs.changeMaterial)(gc, gc->light.cm, gc->light.cmm);
}

void FASTCALL __glChangeBothMaterialColors(__GLcontext *gc)
{
    (*gc->procs.changeMaterial)(gc, &gc->state.light.front, &gc->light.front);
    (*gc->procs.changeMaterial)(gc, &gc->state.light.back, &gc->light.back);
}

/************************************************************************/

/*
** DEPENDENCIES:
**
** Material 	EMISSIVE, AMBIENT, DIFFUSE, SHININESS
** Light Model 	AMBIENT
*/

/*
** Compute derived state for a material
*/
void ComputeMaterialState(__GLcontext *gc, __GLmaterialState *ms,
				 __GLmaterialMachine *msm, GLint changeBits)
{
    GLdouble  exponent;
    __GLspecLUTEntry *lut;

    if ((changeBits & (__GL_MATERIAL_EMISSIVE | __GL_MATERIAL_AMBIENT | 
	    __GL_MATERIAL_DIFFUSE | __GL_MATERIAL_SHININESS)) == 0) {
	return;
    }
    /* Only compute specular lookup table when it changes */
    if (!msm->cache || (ms->specularExponent != msm->specularExponent)) {
	/*
	** Specular lookup table generation.  Instead of performing a
	** "pow" computation each time a vertex is lit, we generate a
	** lookup table which approximates the pow function:
	**
	** 	n2 = n circle-dot hHat[i]
	** 	if (n2 >= threshold) {
	** 		n2spec = specTable[n2 * scale];
	** 		...
	** 	}
	**
	** Remember that n2 is a value constrained to be between 0.0 and
	** 1.0, inclusive (n is the normalized normal; hHat[i] is the
	** unit h vector).  "threshold" is the threshold where incoming
	** n2 values become meaningful for a given exponent.  The larger
	** the specular exponent, the closer "threshold" will approach
	** 1.0.
	**
	** A simple linear mapping of the n2 value to a table index will
	** not suffice because in most cases the majority of the table
	** entries would be zero, while the useful non-zero values would
	** be compressed into a few table entries.  By setting up a
	** threshold, we can use the entire table to represent the useful
	** values beyond the threshold.  "scale" is computed based on
	** this threshold.
	*/
	exponent = msm->specularExponent = ms->specularExponent;

	__glFreeSpecLUT(gc, msm->cache);
	lut = msm->cache = __glCreateSpecLUT(gc, exponent);
#ifdef NT
        if (lut)
        {
            msm->threshold = lut->threshold;
            msm->scale = lut->scale;
            msm->specTable = lut->table;
        }
        else
        {
            msm->threshold = (GLfloat) 0.0;
            msm->scale = (GLfloat) __GL_SPEC_LOOKUP_TABLE_SIZE;
            msm->specTable = NULL;
        }
#else
	msm->threshold = lut->threshold;
	msm->scale = lut->scale;
	msm->specTable = lut->table;
#endif // NT
    }

#ifdef NT
    /* Compute invariant scene color */
    if (changeBits & (__GL_MATERIAL_EMISSIVE | __GL_MATERIAL_AMBIENT))
    {
	if (msm->colorMaterialChange & __GL_MATERIAL_EMISSIVE)
	{
	    msm->paSceneColor.r = ms->ambient.r * gc->state.light.model.ambient.r;
	    msm->paSceneColor.g = ms->ambient.g * gc->state.light.model.ambient.g;
	    msm->paSceneColor.b = ms->ambient.b * gc->state.light.model.ambient.b;
	}
	else if (msm->colorMaterialChange & __GL_MATERIAL_AMBIENT)
	{
	    msm->paSceneColor.r = ms->emissive.r;
	    msm->paSceneColor.g = ms->emissive.g;
	    msm->paSceneColor.b = ms->emissive.b;
	}
	else
	{
	    // there is no color material but need to compute this anyway!
	    msm->paSceneColor.r = ms->emissive.r 
		+ ms->ambient.r * gc->state.light.model.ambient.r;
	    msm->paSceneColor.g = ms->emissive.g 
		+ ms->ambient.g * gc->state.light.model.ambient.g;
	    msm->paSceneColor.b = ms->emissive.b 
		+ ms->ambient.b * gc->state.light.model.ambient.b;
	}
    }
#else
    /* Compute scene color */
    if (changeBits & (__GL_MATERIAL_EMISSIVE | __GL_MATERIAL_AMBIENT)) {
	msm->sceneColor.r = ms->emissive.r
	    + ms->ambient.r * gc->state.light.model.ambient.r;
	msm->sceneColor.g = ms->emissive.g
	    + ms->ambient.g * gc->state.light.model.ambient.g;
	msm->sceneColor.b = ms->emissive.b
	    + ms->ambient.b * gc->state.light.model.ambient.b;
    }
#endif

    /* Clamp material alpha */
    if (changeBits & __GL_MATERIAL_DIFFUSE) {
	msm->alpha = ms->diffuse.a * gc->alphaVertexScale;
	if (msm->alpha < __glZero) {
	    msm->alpha = __glZero;
	} else if (msm->alpha > gc->alphaVertexScale) {
	    msm->alpha = gc->alphaVertexScale;
	}
    }
}

/*
** DEPENDENCIES:
**
** Derived state:
**
** Enables	LIGHTx
** Lightx	DIFFUSE, AMBIENT, SPECULAR, POSITION, SPOT_EXPONENT, 
**		SPOT_CUTOFF, CONSTANT_ATTENUATION, LINEAR_ATTENUATION,
**		QUADRATIC_ATTENUATION
** Light Model  LOCAL_VIEWER
*/

/*
** Compute any derived state for the enabled lights.
*/
void FASTCALL ComputeLightState(__GLcontext *gc)
{
    __GLlightSourceState *lss;
    __GLlightSourceMachine *lsm, **lsmp;
    __GLfloat zero;
    GLuint enables;
    GLint i;
    __GLspecLUTEntry *lut;

    zero = __glZero;

    lss = &gc->state.light.source[0];
    lsm = &gc->light.source[0];
    lsmp = &gc->light.sources;
    enables = gc->state.enables.lights;
    for (i = 0; i < gc->constants.numberOfLights;
	    i++, lss++, lsm++, enables >>= 1) {
	if (!(enables & 1)) continue;

	/* Link this enabled light on to the list */
	*lsmp = lsm;
	lsm->state = lss;	/* Could be done once, elsewhere... */
	lsmp = &lsm->next;

	/*
	** Compute per-light derived state that wasn't already done
	** in the api handlers.
	*/
	lsm->position = lss->positionEye;
	lsm->isSpot = lss->spotLightCutOffAngle != 180;
	if (lsm->isSpot) {
	    lsm->cosCutOffAngle =
		__GL_COSF(lss->spotLightCutOffAngle * __glDegreesToRadians);
	}

	if (lsm->isSpot && (!lsm->cache ||
	        (lsm->spotLightExponent != lss->spotLightExponent))) {
	    GLdouble exponent;

	    /*
	    ** Compute spot light exponent lookup table, but only when
	    ** the exponent changes value and the light is a spot light.
	    */
	    exponent = lsm->spotLightExponent = lss->spotLightExponent;

	    if (lsm->cache) {
		__glFreeSpecLUT(gc, lsm->cache);
	    }
	    lut = lsm->cache = __glCreateSpecLUT(gc, exponent);
#ifdef NT
            if (lut)
            {
                lsm->threshold = lut->threshold;
                lsm->scale = lut->scale;
                lsm->spotTable = lut->table;
            }
            else
            {
                lsm->threshold = (GLfloat) 0.0;
                lsm->scale = (GLfloat) __GL_SPEC_LOOKUP_TABLE_SIZE;
                lsm->spotTable = NULL;
            }
#else
	    lsm->threshold = lut->threshold;
	    lsm->scale = lut->scale;
	    lsm->spotTable = lut->table;
#endif // NT
	}

	lsm->constantAttenuation = lss->constantAttenuation;
    if (__GL_FLOAT_NEZ(lsm->constantAttenuation))
	    lsm->attenuation = __glOne / lss->constantAttenuation;
    else
        lsm->attenuation = __glOne;
	lsm->linearAttenuation = lss->linearAttenuation;
	lsm->quadraticAttenuation = lss->quadraticAttenuation;

	/*
	** Pick per-light calculation proc based on the state
	** of the light source
	*/
	if (gc->modes.colorIndexMode) {
	    lsm->sli = ((__GLfloat) 0.30) * lss->specular.r
		+ ((__GLfloat) 0.59) * lss->specular.g
		+ ((__GLfloat) 0.11) * lss->specular.b;
	    lsm->dli = ((__GLfloat) 0.30) * lss->diffuse.r
		+ ((__GLfloat) 0.59) * lss->diffuse.g
		+ ((__GLfloat) 0.11) * lss->diffuse.b;
	}
	if (!gc->state.light.model.localViewer && !lsm->isSpot
		&& (lsm->position.w == zero)) {
	    __GLfloat hv[3];

	    /* Compute unit h[i] (normalized) */
	    __glNormalize(hv, &lsm->position.x);
	    lsm->unitVPpli.x = hv[0];
	    lsm->unitVPpli.y = hv[1];
	    lsm->unitVPpli.z = hv[2];
	    hv[2] += __glOne;
	    __glNormalize(&lsm->hHat.x, hv);
	    lsm->slowPath = GL_FALSE;
	} else {
	    lsm->slowPath = GL_TRUE;
	}
    }
    *lsmp = 0;
}

/*
** DEPENDENCIES:
**
** Procs:
**
** Light Model	LOCAL_VIEWER
** Lightx	SPOT_CUTOFF, POSITION
** Enables	LIGHTING
** modeFlags	CHEAP_FOG
*/
void FASTCALL ComputeLightProcs(__GLcontext *gc)
{
    GLboolean anySlow = GL_FALSE;
    __GLlightSourceMachine *lsm;

    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	if (lsm->slowPath) {
	    anySlow = GL_TRUE;
	    break;
	}
    }

#ifdef NT
    if ((gc->polygon.shader.modeFlags & __GL_SHADE_CHEAP_FOG) &&
	    (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH_LIGHT) &&
	    gc->renderMode == GL_RENDER)
    {
	if (gc->modes.colorIndexMode)
	    gc->procs.paApplyCheapFog = PolyArrayCheapFogCIColor;
	else
	    gc->procs.paApplyCheapFog = PolyArrayCheapFogRGBColor;
    }
    else
	gc->procs.paApplyCheapFog = 0;	// for debugging

    if (gc->state.enables.general & __GL_LIGHTING_ENABLE)
    {
#ifdef GL_WIN_phong_shading
        if (gc->state.light.shadingModel == GL_PHONG_WIN)
        {
            __glGenericPickPhongProcs (gc);
        }
        //else
#endif //GL_WIN_phong_shading
	if (gc->modes.colorIndexMode)
	{
	    if (!anySlow)
		gc->procs.paCalcColor = PolyArrayFastCalcCIColor;
	    else
		gc->procs.paCalcColor = PolyArrayCalcCIColor;
	}
	else
	{
	    if (!anySlow)
	    {
		// If there are no color material changes in front and back
		// faces, use the zippy function!
		if (!gc->light.front.colorMaterialChange
		 && !gc->light.back.colorMaterialChange)
		    gc->procs.paCalcColor = PolyArrayZippyCalcRGBColor;
		else
		    gc->procs.paCalcColor = PolyArrayFastCalcRGBColor;
	    }
	    else
	    {
		gc->procs.paCalcColor = PolyArrayCalcRGBColor;
	    }
	}
    }
    else
    {
	// set it to NULL for debugging
	gc->procs.paCalcColor = (PFN_POLYARRAYCALCCOLOR) NULL;
    }

    if (gc->modes.colorIndexMode)
	gc->procs.paCalcColorSkip = PolyArrayFillIndex0;
    else
	gc->procs.paCalcColorSkip = PolyArrayFillColor0;
#else
    if (gc->state.enables.general & __GL_LIGHTING_ENABLE) {
	if (gc->modes.colorIndexMode) {
	    if (!anySlow) {
		gc->procs.calcColor = __glFastCalcCIColor;
	    } else {
		gc->procs.calcColor = __glCalcCIColor;
	    }
	} else {
	    if (!anySlow) {
		gc->procs.calcColor = __glFastCalcRGBColor;
	    } else {
		gc->procs.calcColor = __glCalcRGBColor;
	    }
	}
	gc->procs.calcRasterColor = gc->procs.calcColor;
	if ((gc->polygon.shader.modeFlags & __GL_SHADE_CHEAP_FOG) &&
		(gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH_LIGHT) &&
		gc->renderMode == GL_RENDER) {
	    gc->procs.calcColor2 = gc->procs.calcColor;
	    if (gc->modes.colorIndexMode) {
		gc->procs.calcColor = __glFogLitCIColor;
	    } else {
		gc->procs.calcColor = __glFogLitRGBColor;
	    }
	}
    } else {
	gc->procs.calcRasterColor = __glNopLight;
	if ((gc->polygon.shader.modeFlags & __GL_SHADE_CHEAP_FOG) &&
		(gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH_LIGHT) &&
		gc->renderMode == GL_RENDER) {
	    if (gc->modes.colorIndexMode) {
		gc->procs.calcColor = __glFogCIColor;
	    } else {
		gc->procs.calcColor = __glFogRGBColor;
	    }
	} else {
	    gc->procs.calcColor = __glNopLight;
	}
    }
#endif
}

/*
** DEPENDENCIES:
**
** Material	AMBIENT, DIFFUSE, SPECULAR
** Lightx	AMBIENT, DIFFUSE, SPECULAR
*/
void FASTCALL ComputeLightMaterialState(__GLcontext *gc, GLint frontChange,
				      GLint backChange)
{
    __GLmaterialState *front, *back;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat r, g, b;
    GLint allChange;

    allChange = frontChange | backChange;
    if ((allChange & (__GL_MATERIAL_AMBIENT | __GL_MATERIAL_DIFFUSE | 
	    __GL_MATERIAL_SPECULAR)) == 0) {
	return;
    }

    front = &gc->state.light.front;
    back = &gc->state.light.back;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	lss = lsm->state;
	/*
	** Pre-multiply and the front & back ambient, diffuse and
	** specular colors
	*/
	if (allChange & __GL_MATERIAL_AMBIENT) {
	    r = lss->ambient.r;
	    g = lss->ambient.g;
	    b = lss->ambient.b;
	    if (frontChange & __GL_MATERIAL_AMBIENT) {
		lsm->front.ambient.r = front->ambient.r * r;
		lsm->front.ambient.g = front->ambient.g * g;
		lsm->front.ambient.b = front->ambient.b * b;
	    }
	    if (backChange & __GL_MATERIAL_AMBIENT) {
		lsm->back.ambient.r = back->ambient.r * r;
		lsm->back.ambient.g = back->ambient.g * g;
		lsm->back.ambient.b = back->ambient.b * b;
	    }
	}

	if (allChange & __GL_MATERIAL_DIFFUSE) {
	    r = lss->diffuse.r;
	    g = lss->diffuse.g;
	    b = lss->diffuse.b;
	    if (frontChange & __GL_MATERIAL_DIFFUSE) {
		lsm->front.diffuse.r = front->diffuse.r * r;
		lsm->front.diffuse.g = front->diffuse.g * g;
		lsm->front.diffuse.b = front->diffuse.b * b;
	    }
	    if (backChange & __GL_MATERIAL_DIFFUSE) {
		lsm->back.diffuse.r = back->diffuse.r * r;
		lsm->back.diffuse.g = back->diffuse.g * g;
		lsm->back.diffuse.b = back->diffuse.b * b;
	    }
	}

	if (allChange & __GL_MATERIAL_SPECULAR) {
	    r = lss->specular.r;
	    g = lss->specular.g;
	    b = lss->specular.b;
	    if (frontChange & __GL_MATERIAL_SPECULAR) {
		lsm->front.specular.r = front->specular.r * r;
		lsm->front.specular.g = front->specular.g * g;
		lsm->front.specular.b = front->specular.b * b;
	    }
	    if (backChange & __GL_MATERIAL_SPECULAR) {
		lsm->back.specular.r = back->specular.r * r;
		lsm->back.specular.g = back->specular.g * g;
		lsm->back.specular.b = back->specular.b * b;
	    }
	}
    }
}

/*
** DEPENDENCIES:
**
** Material 	EMISSIVE, AMBIENT, DIFFUSE, SHININESS, SPECULAR
** Light Model 	AMBIENT
** Lightx	AMBIENT, DIFFUSE, SPECULAR
*/

/*
** Recompute light state based upon the material change indicated by 
** frontChange and backChange.
*/
void FASTCALL __glValidateMaterial(__GLcontext *gc, GLint frontChange, GLint backChange)
{
    ComputeMaterialState(gc, &gc->state.light.front, &gc->light.front, 
	    frontChange);
    ComputeMaterialState(gc, &gc->state.light.back, &gc->light.back, 
	    backChange);
    ComputeLightMaterialState(gc, frontChange, backChange);
}

/*
** DEPENDENCIES:
**
** Enables	LIGHTx, LIGHTING
** ( Material 	EMISSIVE, AMBIENT, DIFFUSE, SHININESS, SPECULAR )
** Light Model 	AMBIENT, LOCAL_VIEWER
** Lightx	DIFFUSE, AMBIENT, SPECULAR, POSITION, SPOT_EXPONENT, 
**		SPOT_CUTOFF, CONSTANT_ATTENUATION, LINEAR_ATTENUATION,
**		QUADRATIC_ATTENUATION
** modeFlags	CHEAP_FOG
*/

/*
** Pre-compute lighting state.
*/
void FASTCALL __glValidateLighting(__GLcontext *gc)
{
    if (gc->dirtyMask & __GL_DIRTY_LIGHTING) {
	ComputeLightState(gc);
	ComputeLightProcs(gc);
	__glValidateMaterial(gc, __GL_MATERIAL_ALL, __GL_MATERIAL_ALL);
    } else {
	ComputeLightProcs(gc);
    }
}

void FASTCALL __glGenericPickColorMaterialProcs(__GLcontext *gc)
{
    if (gc->modes.rgbMode) {
	if (gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) {
	    switch (gc->state.light.colorMaterialFace) {
	      case GL_FRONT_AND_BACK:
		gc->procs.applyColor = __glChangeBothMaterialColors;
		gc->light.cm = 0;
		gc->light.cmm = 0;
		break;
	      case GL_FRONT:
		gc->procs.applyColor = __glChangeOneMaterialColor;
		gc->light.cm = &gc->state.light.front;
		gc->light.cmm = &gc->light.front;
		break;
	      case GL_BACK:
		gc->procs.applyColor = __glChangeOneMaterialColor;
		gc->light.cm = &gc->state.light.back;
		gc->light.cmm = &gc->light.back;
		break;
	    }
	    switch (gc->state.light.colorMaterialParam) {
	      case GL_EMISSION:
		gc->procs.changeMaterial = ChangeMaterialEmission;
		break;
	      case GL_SPECULAR:
		gc->procs.changeMaterial = ChangeMaterialSpecular;
		break;
	      case GL_AMBIENT:
		gc->procs.changeMaterial = ChangeMaterialAmbient;
		break;
	      case GL_DIFFUSE:
		gc->procs.changeMaterial = ChangeMaterialDiffuse;
		break;
	      case GL_AMBIENT_AND_DIFFUSE:
		gc->procs.changeMaterial = ChangeMaterialAmbientAndDiffuse;
		break;
	    }
	} else {
	    gc->procs.applyColor = __glNopGC;
	}
    } else {
	/*
	** When in color index mode the value is copied from the
	** current.userColorIndex into the vertex
	*/
	gc->procs.applyColor = __glNopGC;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_lined.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop
#include "phong.h"

#define __TWO_31 ((__GLfloat) 2147483648.0)

/*
** Most line functions will start off by computing the information 
** computed by this routine.
**
** The excessive number of labels in this routine is partly due
** to the fact that it is used as a model for writing an assembly 
** equivalent.
*/
#ifndef NT
void FASTCALL __glInitLineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint start, end;
    __GLfloat x0,y0,x1,y1;
    __GLfloat minorStart;
    GLint intMinorStart;
    __GLfloat dx, dy;
    __GLfloat offset;
    __GLfloat slope;
    __GLlineState *ls = &gc->state.line;
    __GLfloat halfWidth;
    __GLfloat x0frac, x1frac, y0frac, y1frac, half, totDist;

    gc->line.options.v0 = v0;
    gc->line.options.v1 = v1;
    gc->line.options.width = gc->state.line.aliasedWidth;

    x0=v0->window.x;
    y0=v0->window.y;
    x1=v1->window.x;
    y1=v1->window.y;
    dx=x1-x0;
    dy=y1-y0;

    halfWidth = (ls->aliasedWidth - 1) * __glHalf;

    /* Ugh.  This is slow.  Bummer. */
    x0frac = x0 - ((GLint) x0);
    x1frac = x1 - ((GLint) x1);
    y0frac = y0 - ((GLint) y0);
    y1frac = y1 - ((GLint) y1);
    half = __glHalf;

    if (dx > __glZero) {
	if (dy > __glZero) {
	    if (dx > dy) {	/* dx > dy > 0 */
		gc->line.options.yBig = 1;
posxmajor:			/* dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = 1;
		gc->line.options.xLittle = 1;
		slope = dy/dx;

		start = (GLint) (x0);
		end = (GLint) (x1);

		y0frac -= half;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac + x0frac - half;
		if (totDist > half) start++;

		y1frac -= half;
		if (y1frac < 0) y1frac = -y1frac;

		totDist = y1frac + x1frac - half;
		if (totDist > half) end++;

		offset = start + half - x0;

		gc->line.options.length = dx;
		gc->line.options.numPixels = end - start;

xmajorfinish:
		gc->line.options.axis = __GL_X_MAJOR;
		gc->line.options.xStart = start;
		gc->line.options.offset = offset;
		minorStart = y0 + offset*slope - halfWidth;
		intMinorStart = (GLint) minorStart;
		minorStart -= intMinorStart;
		gc->line.options.yStart = intMinorStart;
		gc->line.options.dfraction = (GLint)(slope * __TWO_31);
		gc->line.options.fraction = (GLint)(minorStart * __TWO_31);
	    } else {		/* dy >= dx > 0 */
		gc->line.options.xBig = 1;
posymajor:			/* dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = 1;
		gc->line.options.yLittle = 1;
		slope = dx/dy;

		start = (GLint) (y0);
		end = (GLint) (y1);

		x0frac -= half;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = y0frac + x0frac - half;
		if (totDist > half) start++;

		x1frac -= half;
		if (x1frac < 0) x1frac = -x1frac;

		totDist = y1frac + x1frac - half;
		if (totDist > half) end++;

		offset = start + half - y0;

		gc->line.options.length = dy;
		gc->line.options.numPixels = end - start;

ymajorfinish:
		gc->line.options.axis = __GL_Y_MAJOR;
		gc->line.options.yStart = start;
		gc->line.options.offset = offset;
		minorStart = x0 + offset*slope - halfWidth;
		intMinorStart = (GLint) minorStart;
		minorStart -= intMinorStart;
		gc->line.options.xStart = intMinorStart;
		gc->line.options.dfraction = (GLint)(slope * __TWO_31);
		gc->line.options.fraction = (GLint)(minorStart * __TWO_31);
	    }
	} else {
	    if (dx > -dy) {	/* dx > -dy >= 0 */
		gc->line.options.yBig = -1;
		goto posxmajor;
	    } else {		/* -dy >= dx >= 0, dy != 0 */
		gc->line.options.xBig = 1;
negymajor:			/* -dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = -1;
		gc->line.options.yLittle = -1;
		slope = dx/-dy;

		start = (GLint) (y0);
		end = (GLint) (y1);

		x0frac -= half;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = x0frac + half - y0frac;
		if (totDist > half) start--;

		x1frac -= half;
		if (x1frac < 0) x1frac = -x1frac;

		totDist = x1frac + half - y1frac;
		if (totDist > half) end--;

		offset = y0 - (start + half);

		gc->line.options.length = -dy;
		gc->line.options.numPixels = start - end;
		goto ymajorfinish;
	    }
	}
    } else {
	if (dy > __glZero) {
	    if (-dx > dy) {	/* -dx > dy > 0 */
		gc->line.options.yBig = 1;
negxmajor:			/* -dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = -1;
		gc->line.options.xLittle = -1;
		slope = dy/-dx;

		start = (GLint) (x0);
		end = (GLint) (x1);

		y0frac -= half;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac + half - x0frac;
		if (totDist > half) start--;

		y1frac -= half;
		if (y1frac < 0) y1frac = -y1frac;

		totDist = y1frac + half - x1frac;
		if (totDist > half) end--;

		offset = x0 - (start + half);

		gc->line.options.length = -dx;
		gc->line.options.numPixels = start - end;

		goto xmajorfinish;
	    } else {		/* dy >= -dx >= 0, dy != 0 */
		gc->line.options.xBig = -1;
		goto posymajor;
	    }
	} else {
	    if (dx < dy) {	/* -dx > -dy >= 0 */
		gc->line.options.yBig = -1;
		goto negxmajor;
	    } else {		/* -dy >= -dx >= 0 */
#ifdef NT 
		if (dx == dy && dy == 0) {
		    gc->line.options.numPixels = 0;
		    return;
		}
#else
		if (dx == dy && dy == 0) return;
#endif
		gc->line.options.xBig = -1;
		goto negymajor;
	    }
	}
    }
}
#endif

#ifdef NT
void FASTCALL __glRenderAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, GLuint flags)
#else
void FASTCALL __glRenderAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
#endif
{
    __GLlineState *ls = &gc->state.line;
    __GLfloat invDelta;
    __GLfloat winv, r;
    __GLcolor *cp;
    __GLfloat offset;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

#ifndef NT
    __glInitLineData(gc, v0, v1);
    if (gc->line.options.numPixels == 0) return;
#else
    GLboolean init;
    CHOP_ROUND_ON();

    init = (GLboolean)__glInitLineData(gc, v0, v1);

    CHOP_ROUND_OFF();

    if (!init)
    {
        return;
    }

    invDelta = gc->line.options.oneOverLength;
#endif

    offset = gc->line.options.offset;

    /*
    ** Set up increments for any enabled line options.
    */
#ifndef NT
    invDelta = __glOne / gc->line.options.length;
#endif
    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
        __GLfloat dzdx;

        /*
        ** Calculate window z coordinate increment and starting position.
        */
        dzdx = (v1->window.z - v0->window.z) * invDelta;
#ifdef NT
        if(( gc->modes.depthBits == 16 ) &&
           ( gc->depthBuffer.scale <= (GLuint)0xffff )) {
            gc->polygon.shader.frag.z = 
              (__GLzValue)(Z16_SCALE *(v0->window.z + dzdx * offset));
            gc->polygon.shader.dzdx = (GLint)(Z16_SCALE * dzdx);
        }
        else {
            gc->polygon.shader.frag.z = 
              (__GLzValue)(v0->window.z + dzdx * offset);
            gc->polygon.shader.dzdx = (GLint)dzdx;
        }
#else
        gc->polygon.shader.frag.z = (__GLzValue)(v0->window.z + dzdx * offset);
        gc->polygon.shader.dzdx = (GLint)dzdx;
#endif
    }

    if (modeFlags & __GL_SHADE_LINE_STIPPLE) {
        if (!gc->line.notResetStipple) {
            gc->line.stipplePosition = 0;
            gc->line.repeat = 0;
            gc->line.notResetStipple = GL_TRUE;
        }
    }

    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        __GLfloat f1, f0;
        __GLfloat dfdx;

        gc->line.options.f0 = f0 = v0->eyeZ;
        gc->polygon.shader.dfdx = dfdx = 
            (v1->eyeZ - v0->eyeZ) * invDelta;
        gc->polygon.shader.frag.f = f0 + dfdx * offset;
    }
    else if (modeFlags & __GL_SHADE_INTERP_FOG)
    {
        __GLfloat f1, f0;
        __GLfloat dfdx;

        f0 = v0->fog;
        f1 = v1->fog;
        gc->line.options.f0 = f0;
        gc->polygon.shader.dfdx = dfdx = (f1 - f0) * invDelta;
        gc->polygon.shader.frag.f = f0 + dfdx * offset;
    }
    
    if (modeFlags & __GL_SHADE_TEXTURE) {
        __GLfloat v0QW, v1QW;
        __GLfloat dS, dT, dQWdX;
        winv = v0->window.w;

        /*
        ** Calculate texture s and t value increments.
        */
        v0QW = v0->texture.w * winv;
        v1QW = v1->texture.w * v1->window.w;
        dS = (v1->texture.x * v1QW - v0->texture.x * v0QW) * invDelta;
        dT = (v1->texture.y * v1QW - v0->texture.y * v0QW) * invDelta;
        gc->polygon.shader.dsdx = dS;
        gc->polygon.shader.dtdx = dT;
        gc->polygon.shader.dqwdx = dQWdX = (v1QW - v0QW) * invDelta;
        gc->polygon.shader.frag.s = v0->texture.x * winv + dS * offset;
        gc->polygon.shader.frag.t = v0->texture.y * winv + dT * offset;
        gc->polygon.shader.frag.qw = v0->texture.w * winv + dQWdX * offset;
    } 
    
#ifdef GL_WIN_phong_shading
    if (modeFlags & __GL_SHADE_PHONG) 
        (*gc->procs.phong.InitLineParams) (gc, v0, v1, invDelta);
#endif //GL_WIN_phong_shading

    if ((modeFlags & __GL_SHADE_SMOOTH) 
#ifdef GL_WIN_phong_shading
        || ((modeFlags & __GL_SHADE_PHONG) &&
            (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_COLOR_XPOLATE))
#endif //GL_WIN_phong_shading
        ) {
        __GLcolor *c0 = v0->color;
        __GLcolor *c1 = v1->color;
        __GLfloat drdx, dgdx, dbdx, dadx;

        /*
        ** Calculate red, green, blue and alpha value increments.
        */
        drdx = (c1->r - c0->r) * invDelta;
        if (gc->modes.rgbMode) {
            dgdx = (c1->g - c0->g) * invDelta;
            dbdx = (c1->b - c0->b) * invDelta;
            dadx = (c1->a - c0->a) * invDelta;
            gc->polygon.shader.dgdx = dgdx;
            gc->polygon.shader.dbdx = dbdx;
            gc->polygon.shader.dadx = dadx;
        }
        gc->polygon.shader.drdx = drdx;
        cp = v0->color;
    } else {
        cp = v1->color;

        // Initialize these values to zero even for the flat case
        // because there is an optimization in so_prim which will
        // turn off smooth shading without repicking, so these need
        // to be valid
        gc->polygon.shader.drdx = __glZero;
        gc->polygon.shader.dgdx = __glZero;
        gc->polygon.shader.dbdx = __glZero;
        gc->polygon.shader.dadx = __glZero;
    }

    r = cp->r;
    if (modeFlags & __GL_SHADE_RGB) {
        __GLfloat g,b,a;

        g = cp->g;
        b = cp->b;
        a = cp->a;
        gc->polygon.shader.frag.color.g = g;
        gc->polygon.shader.frag.color.b = b;
        gc->polygon.shader.frag.color.a = a;
    }
    gc->polygon.shader.frag.color.r = r;
    
    gc->polygon.shader.length = gc->line.options.numPixels;
    (*gc->procs.line.processLine)(gc);
}

#ifdef NT
void FASTCALL __glRenderFlatFogLine(__GLcontext *gc, __GLvertex *v0,
                                    __GLvertex *v1, GLuint flags)
#else
void FASTCALL __glRenderFlatFogLine(__GLcontext *gc, __GLvertex *v0,
                                    __GLvertex *v1)
#endif
{
    __GLcolor v0col, v1col;
    __GLcolor *v0ocp, *v1ocp;

    (*gc->procs.fogColor)(gc, &v0col, v1->color, v0->fog);
    (*gc->procs.fogColor)(gc, &v1col, v1->color, v1->fog);
    v0ocp = v0->color;
    v1ocp = v1->color;
    v0->color = &v0col;
    v1->color = &v1col;

#ifdef NT
    (*gc->procs.renderLine2)(gc, v0, v1, flags);
#else
    (*gc->procs.renderLine2)(gc, v0, v1);
#endif
    
    v0->color = v0ocp;
    v1->color = v1ocp;
}


/************************************************************************/

/*
** Most line functions will start off by computing the information 
** computed by this routine.
**
** The excessive number of labels in this routine is partly due
** to the fact that it is used as a model for writing an assembly 
** equivalent.
*/
void FASTCALL __glInitAALineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint start;
    __GLfloat width;
    __GLfloat x0,y0,x1,y1;
    __GLfloat minorStart;
    GLint intMinorStart;
    __GLfloat dx, dy;
    __GLfloat offset;
    __GLfloat slope;
    __GLlineState *ls = &gc->state.line;
    __GLfloat halfWidth;
    __GLfloat realLength, oneOverRealLength;
    __GLfloat dldx, dldy;
    __GLfloat dddx, dddy;

    gc->line.options.v0 = v0;
    gc->line.options.v1 = v1;

    x0=v0->window.x;
    y0=v0->window.y;
    x1=v1->window.x;
    y1=v1->window.y;
    dx=x1-x0;
    dy=y1-y0;
    realLength = __GL_SQRTF(dx*dx+dy*dy);
    oneOverRealLength = realLength == __glZero ? __glZero : __glOne/realLength;
    gc->line.options.realLength = realLength;
    gc->line.options.dldx = dldx = dx * oneOverRealLength;
    gc->line.options.dldy = dldy = dy * oneOverRealLength;
    gc->line.options.dddx = dddx = -dldy;
    gc->line.options.dddy = dddy = dldx;

    if (dx > __glZero) {
	if (dy > __glZero) {	/* dx > 0, dy > 0 */
	    gc->line.options.dlBig = dldx + dldy;
	    gc->line.options.ddBig = dddx + dddy;
	    if (dx > dy) {	/* dx > dy > 0 */
		gc->line.options.yBig = 1;
posxmajor:			/* dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = 1;
		gc->line.options.xLittle = 1;
		gc->line.options.dlLittle = dldx;
		gc->line.options.ddLittle = dddx;
		slope = dy/dx;
		start = (GLint) x0;
		offset = start + __glHalf - x0;

		gc->line.options.length = dx;
		gc->line.options.numPixels = (GLint)__GL_FAST_CEILF(x1 - x0) + 1;

		width = __GL_FAST_CEILF(gc->state.line.smoothWidth * 
			realLength / dx);
xmajorfinish:
		gc->line.options.width = (GLint)width + 1;
		halfWidth = width * __glHalf;

		gc->line.options.axis = __GL_X_MAJOR;
		gc->line.options.xStart = start;
		gc->line.options.offset = offset;
		minorStart = y0 + offset*slope - halfWidth;
		intMinorStart = (GLint) minorStart;
		minorStart -= intMinorStart;
		gc->line.options.yStart = intMinorStart;
		gc->line.options.dfraction = (GLint)(slope * __TWO_31);
		gc->line.options.fraction = (GLint)(minorStart * __TWO_31);
	    } else {		/* dy >= dx > 0 */
		gc->line.options.xBig = 1;
posymajor:			/* dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = 1;
		gc->line.options.yLittle = 1;
		gc->line.options.dlLittle = dldy;
		gc->line.options.ddLittle = dddy;
		slope = dx/dy;
		start = (GLint) y0;
		offset = start + __glHalf - y0;

		gc->line.options.length = dy;
		gc->line.options.numPixels = (GLint)__GL_FAST_CEILF(y1 - y0) + 1;

		width = __GL_FAST_CEILF(gc->state.line.smoothWidth * 
			realLength / dy);
ymajorfinish:
		gc->line.options.width = (GLint)width + 1;
		halfWidth = width * __glHalf;

		gc->line.options.axis = __GL_Y_MAJOR;
		gc->line.options.yStart = start;
		gc->line.options.offset = offset;
		minorStart = x0 + offset*slope - halfWidth;
		intMinorStart = (GLint) minorStart;
		minorStart -= intMinorStart;
		gc->line.options.xStart = intMinorStart;
		gc->line.options.dfraction = (GLint)(slope * __TWO_31);
		gc->line.options.fraction = (GLint)(minorStart * __TWO_31);
	    }
	} else {		/* dx > 0, dy <= 0 */
	    gc->line.options.dlBig = dldx - dldy;
	    gc->line.options.ddBig = dddx - dddy;
	    if (dx > -dy) {	/* dx > -dy >= 0 */
		gc->line.options.yBig = -1;
		goto posxmajor;
	    } else {		/* -dy >= dx >= 0, dy != 0 */
		gc->line.options.xBig = 1;
negymajor:			/* -dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = -1;
		gc->line.options.yLittle = -1;
		gc->line.options.dlLittle = -dldy;
		gc->line.options.ddLittle = -dddy;
		slope = dx/-dy;
		start = (GLint) y0;
		offset = y0 - (start + __glHalf);

		gc->line.options.length = -dy;
		gc->line.options.numPixels = (GLint)__GL_FAST_CEILF(y0 - y1) + 1;

		width = __GL_FAST_CEILF(-gc->state.line.smoothWidth * 
			realLength / dy);

		goto ymajorfinish;
	    }
	}
    } else {
	if (dy > __glZero) {	/* dx <= 0, dy > 0 */
	    gc->line.options.dlBig = dldy - dldx;
	    gc->line.options.ddBig = dddy - dddx;
	    if (-dx > dy) {	/* -dx > dy > 0 */
		gc->line.options.yBig = 1;
negxmajor:			/* -dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = -1;
		gc->line.options.xLittle = -1;
		gc->line.options.dlLittle = -dldx;
		gc->line.options.ddLittle = -dddx;
		slope = dy/-dx;
		start = (GLint) x0;
		offset = x0 - (start + __glHalf);

		gc->line.options.length = -dx;
		gc->line.options.numPixels = (GLint)__GL_FAST_CEILF(x0 - x1) + 1;

		width = __GL_FAST_CEILF(-gc->state.line.smoothWidth * 
			realLength / dx);

		goto xmajorfinish;
	    } else {		/* dy >= -dx >= 0, dy != 0 */
		gc->line.options.xBig = -1;
		goto posymajor;
	    }
	} else {		/* dx <= 0, dy <= 0 */
	    gc->line.options.dlBig = -dldx - dldy;
	    gc->line.options.ddBig = -dddx - dddy;
	    if (dx < dy) {	/* -dx > -dy >= 0 */
		gc->line.options.yBig = -1;
		goto negxmajor;
	    } else {		/* -dy >= -dx >= 0 */
		if (dx == dy && dy == 0) {
		    gc->line.options.length = 0;
		    return;
		}
		gc->line.options.xBig = -1;
		goto negymajor;
	    }
	}
    }
}

#ifdef NT
void FASTCALL __glRenderAntiAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, GLuint flags)
#else
void FASTCALL __glRenderAntiAliasLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
#endif
{
    __GLlineState *ls = &gc->state.line;
    __GLfloat invDelta;
    __GLfloat winv;
    __GLcolor *cp;
    __GLfloat offset;
    GLint lineRep;
    GLint x, y, xBig, xLittle, yBig, yLittle;
    GLint fraction, dfraction;
    __GLfloat dlLittle, dlBig;
    __GLfloat ddLittle, ddBig;
    __GLfloat length, width;
    __GLfloat lineLength;
    __GLfloat dx, dy;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    __glInitAALineData(gc, v0, v1);
    if (gc->line.options.length == 0) return;

    offset = gc->line.options.offset;

    /*
    ** Set up increments for any enabled line options.
    */
    invDelta = __glOne / gc->line.options.length;
    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
        /*
        ** Calculate window z coordinate increment and starting position.
        */
#ifdef NT
        if(( gc->modes.depthBits == 16 ) &&
           ( gc->depthBuffer.scale <= (GLuint)0xffff )) {
            gc->polygon.shader.dzdx = (GLint)((v1->window.z - v0->window.z) * 
                                              invDelta * Z16_SCALE);
            gc->polygon.shader.frag.z = (GLint)(Z16_SCALE*v0->window.z + 
                                                gc->polygon.shader.dzdx * offset);
        }
        else {
            gc->polygon.shader.dzdx = (GLint)((v1->window.z - v0->window.z) * 
                                              invDelta);
            gc->polygon.shader.frag.z = (GLint)(v0->window.z + 
                                                gc->polygon.shader.dzdx * offset);
        }
#else
        gc->polygon.shader.dzdx = (GLint)((v1->window.z - v0->window.z) * 
                                          invDelta);
        gc->polygon.shader.frag.z = (GLint)(v0->window.z + 
                                            gc->polygon.shader.dzdx * offset);
#endif
    } 

    if (modeFlags & __GL_SHADE_LINE_STIPPLE) {
        if (!gc->line.notResetStipple) {
            gc->line.stipplePosition = 0;
            gc->line.repeat = 0;
            gc->line.notResetStipple = GL_TRUE;
        }
    }

    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        __GLfloat f1, f0;
        __GLfloat dfdx;

        f0 = v0->eyeZ;
        f1 = v1->eyeZ;
        gc->line.options.f0 = f0;
        gc->polygon.shader.dfdx = dfdx = (f1 - f0) * invDelta;
        gc->polygon.shader.frag.f = f0 + dfdx * offset;
    }
    else if (modeFlags & __GL_SHADE_INTERP_FOG)
    {
        __GLfloat f1, f0;
        __GLfloat dfdx;

        f0 = v0->fog;
        f1 = v1->fog;
        gc->line.options.f0 = f0;
        gc->polygon.shader.dfdx = dfdx = (f1 - f0) * invDelta;
        gc->polygon.shader.frag.f = f0 + dfdx * offset;
    }

    if ((modeFlags & __GL_SHADE_SMOOTH) 
#ifdef GL_WIN_phong_shading
        || ((modeFlags & __GL_SHADE_PHONG) &&
            (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_COLOR_XPOLATE))
#endif //GL_WIN_phong_shading
        ) 
    {
        __GLcolor *c0 = v0->color;
        __GLcolor *c1 = v1->color;

        /*
        ** Calculate red, green, blue and alpha value increments.
        */
        gc->polygon.shader.drdx = (c1->r - c0->r) * invDelta;
        if (gc->modes.rgbMode) {
            gc->polygon.shader.dgdx = (c1->g - c0->g) * invDelta;
            gc->polygon.shader.dbdx = (c1->b - c0->b) * invDelta;
            gc->polygon.shader.dadx = (c1->a - c0->a) * invDelta;
        }
        cp = v0->color;
    } else {
        cp = v1->color;

        // Initialize these values to zero even for the flat case
        // because there is an optimization in so_prim which will
        // turn off smooth shading without repicking, so these need
        // to be valid
        gc->polygon.shader.drdx = __glZero;
        gc->polygon.shader.dgdx = __glZero;
        gc->polygon.shader.dbdx = __glZero;
        gc->polygon.shader.dadx = __glZero;
    }

    gc->polygon.shader.frag.color.r = cp->r;
    if (gc->modes.rgbMode) {
        gc->polygon.shader.frag.color.g = cp->g;
        gc->polygon.shader.frag.color.b = cp->b;
        gc->polygon.shader.frag.color.a = cp->a;
    }

    if (gc->texture.textureEnabled) {
        __GLfloat v0QW, v1QW;
        __GLfloat dS, dT;

        /*
        ** Calculate texture s and t value increments.
        */
        v0QW = v0->texture.w * v0->window.w;
        v1QW = v1->texture.w * v1->window.w;
        dS = (v1->texture.x * v1QW - v0->texture.x * v0QW) * invDelta;
        dT = (v1->texture.y * v1QW - v0->texture.y * v0QW) * invDelta;
        gc->polygon.shader.dsdx = dS;
        gc->polygon.shader.dtdx = dT;
        gc->polygon.shader.dqwdx = (v1QW - v0QW) * invDelta;
        
        winv = v0->window.w;
        gc->polygon.shader.frag.s = v0->texture.x * winv + 
          gc->polygon.shader.dsdx * offset;
        gc->polygon.shader.frag.t = v0->texture.y * winv + 
          gc->polygon.shader.dtdx * offset;
        gc->polygon.shader.frag.qw = v0->texture.w * winv + 
          gc->polygon.shader.dqwdx * offset;
    } 

    lineRep = gc->line.options.width;
    
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    
    x = gc->line.options.xStart;
    y = gc->line.options.yStart;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    
    dlLittle = gc->line.options.dlLittle;
    dlBig = gc->line.options.dlBig;
    ddLittle = gc->line.options.ddLittle;
    ddBig = gc->line.options.ddBig;
    
    dx = x + __glHalf - v0->window.x;
    dy = y + __glHalf - v0->window.y;
    length = dx * gc->line.options.dldx +
      dy * gc->line.options.dldy;
    width = dx * gc->line.options.dddx +
      dy * gc->line.options.dddy;
    lineLength = gc->line.options.realLength + __glHalf;
    
    if (modeFlags & __GL_SHADE_LINE_STIPPLE) {
        gc->line.options.stippleOffset = 
          gc->line.stipplePosition * gc->state.line.stippleRepeat +
          gc->line.repeat - __glHalf;
        
        /* XXX Move to a validation routine? */
        gc->line.options.oneOverStippleRepeat = 
          __glOne / gc->state.line.stippleRepeat;
    }
    
    while (--lineRep >= 0) {
        /* Trace the line backwards as needed */
        while (length > -__glHalf) {
            fraction -= dfraction;
            if (fraction < 0) {
                fraction &= ~0x80000000;
                length -= dlBig;
                width -= ddBig;
                x -= xBig;
                y -= yBig;
            } else {
                length -= dlLittle;
                width -= ddLittle;
                x -= xLittle;
                y -= yLittle;
            }
        }

        /* Trace line forwards to correct */
        while (length <= -__glHalf) {
            fraction += dfraction;
            if (fraction < 0) {
                fraction &= ~0x80000000;
                length += dlBig;
                width += ddBig;
                x += xBig;
                y += yBig;
            } else {
                length += dlLittle;
                width += ddLittle;
                x += xLittle;
                y += yLittle;
            }
        }
        
#ifdef GL_WIN_phong_shading
    if (modeFlags & __GL_SHADE_PHONG) 
        (*gc->procs.phong.InitLineParams) (gc, v0, v1, invDelta);
#endif //GL_WIN_phong_shading
    
        /* Save new fraction/dfraction */
        gc->line.options.plength = length;
        gc->line.options.pwidth = width;
        gc->line.options.fraction = fraction;
        gc->line.options.dfraction = dfraction;
        gc->line.options.xStart = x;
        gc->line.options.yStart = y;
        
        gc->polygon.shader.length = gc->line.options.numPixels;
        (*gc->procs.line.processLine)(gc);
        
        if (gc->line.options.axis == __GL_X_MAJOR) {
            y++;
            length += gc->line.options.dldy;
            width += gc->line.options.dddy;
        } else {
            x++;
            length += gc->line.options.dldx;
            width += gc->line.options.dddx;
        }
    }
    
    if (modeFlags & __GL_SHADE_LINE_STIPPLE) {
        /* Update stipple.  Ugh. */
        int increase;
        int posInc;

        /* Shift stipple by 'increase' bits */
        increase = (GLint)__GL_FAST_CEILF(gc->line.options.realLength);
        
        posInc = increase / gc->state.line.stippleRepeat;
        
        gc->line.stipplePosition = (gc->line.stipplePosition + posInc) & 0xf;
        gc->line.repeat = (gc->line.repeat + increase) % gc->state.line.stippleRepeat;
    }
}

#ifdef NT
void FASTCALL __glNopLineBegin(__GLcontext *gc)
{
}

void FASTCALL __glNopLineEnd(__GLcontext *gc)
{
}
#endif // NT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_linec.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

/*
** The following is a discussion of the math used to do edge clipping against
** a clipping plane.
** 
**     P1 is an end point of the edge
**     P2 is the other end point of the edge
** 
**     Q = t*P1 + (1 - t)*P2
**     That is, Q lies somewhere on the line formed by P1 and P2.
** 
**     0 <= t <= 1
**     This constrains Q to lie between P1 and P2.
** 
**     C is the plane equation for the clipping plane
** 
**     D1 = P1 dot C
**     D1 is the distance between P1 and C.  If P1 lies on the plane
**     then D1 will be zero.  The sign of D1 will determine which side
**     of the plane that P1 is on, with negative being outside.
** 
**     D2 = P2 dot C
**     D2 is the distance between P2 and C.  If P2 lies on the plane
**     then D2 will be zero.  The sign of D2 will determine which side
**     of the plane that P2 is on, with negative being outside.
** 
** Because we are trying to find the intersection of the P1 P2 line
** segment with the clipping plane we require that:
** 
**     Q dot C = 0
** 
** Therefore
** 
**     (t*P1 + (1 - t)*P2) dot C = 0
** 
**     (t*P1 + P2 - t*P2) dot C = 0
** 
**     t*P1 dot C + P2 dot C - t*P2 dot C = 0
** 
** Substituting D1 and D2 in
** 
**     t*D1 + D2 - t*D2 = 0
** 
** Solving for t
** 
**     t = -D2 / (D1 - D2)
** 
**     t = D2 / (D2 - D1)
*/

/*
** Clip a line against the frustum clip planes and any user clipping planes.
** If an edge remains after clipping then compute the window coordinates
** and invoke the renderer.
**
** Notice:  This algorithim is an example of an implementation that is
** different than what the spec says.  This is equivalent in functionality
** and meets the spec, but doesn't clip in eye space.  This clipper clips
** in NTVP (clip) space.
**
** Trivial accept/reject has already been dealt with.
*/
#ifdef NT
void FASTCALL __glClipLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
                           GLuint flags)
#else
void __glClipLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b)
#endif
{
#ifdef NT
    __GLvertex *provokingA = a;
    __GLvertex *provokingB = b;
#else
    __GLvertex *provoking = b;
#endif
    __GLvertex np1, np2;
    __GLcoord *plane;
    GLuint needs, allClipCodes, clipCodes;
    PFN_VERTEX_CLIP_PROC clip;
    __GLfloat zero;
    __GLfloat winx, winy;
    __GLfloat vpXCenter, vpYCenter, vpZCenter;
    __GLfloat vpXScale, vpYScale, vpZScale;
    __GLviewport *vp;
    __GLfloat x, y, z, wInv;
    GLint i;

    // We have to turn rounding on.  Otherwise, the fast FP-comparison
    // routines below can fail:
    FPU_SAVE_MODE();
    FPU_ROUND_ON_PREC_HI();

    /* Check for trivial pass of the line */
    allClipCodes = a->clipCode | b->clipCode;

    /*
    ** For each clippling plane that something is out on, clip
    ** check the verticies.  Note that no bits will be set in
    ** allClipCodes for clip planes that are not enabled.
    */
    zero = __glZero;
    clip = gc->procs.lineClipParam;

    /* 
    ** Do user clip planes first, because we will maintain eye coordinates
    ** only while doing user clip planes.  They are ignored for the
    ** frustum clipping planes.
    */
    clipCodes = allClipCodes >> 6;
    if (clipCodes) {
	plane = &gc->state.transform.eyeClipPlanes[0];
	do {
	    /*
	    ** See if this clip plane has anything out of it.  If not,
	    ** press onward to check the next plane.  Note that we
	    ** shift this mask to the right at the bottom of the loop.
	    */
	    if (clipCodes & 1) {
		__GLfloat t, d1, d2;

		d1 = (plane->x * ((POLYDATA *)a)->eye.x) +
		     (plane->y * ((POLYDATA *)a)->eye.y) +
		     (plane->z * ((POLYDATA *)a)->eye.z) +
		     (plane->w * ((POLYDATA *)a)->eye.w);
		d2 = (plane->x * ((POLYDATA *)b)->eye.x) +
		     (plane->y * ((POLYDATA *)b)->eye.y) +
		     (plane->z * ((POLYDATA *)b)->eye.z) +
		     (plane->w * ((POLYDATA *)b)->eye.w);
		if (__GL_FLOAT_LTZ(d1)) {
		    /* a is out */
		    if (__GL_FLOAT_LTZ(d2)) {
			/* a & b are out */
                        FPU_RESTORE_MODE();
			return;
		    }

		    /*
		    ** A is out and B is in.  Compute new A coordinate
		    ** clipped to the plane.
		    */
		    t = d2 / (d2 - d1);
		    (*clip)(&np1, a, b, t);
		    ((POLYDATA *)&np1)->eye.x =
			t*(((POLYDATA *)a)->eye.x - ((POLYDATA *)b)->eye.x) +
			((POLYDATA *)b)->eye.x;
		    ((POLYDATA *)&np1)->eye.y =
			t*(((POLYDATA *)a)->eye.y - ((POLYDATA *)b)->eye.y) +
			((POLYDATA *)b)->eye.y;
		    ((POLYDATA *)&np1)->eye.z =
			t*(((POLYDATA *)a)->eye.z - ((POLYDATA *)b)->eye.z) +
			((POLYDATA *)b)->eye.z;
		    ((POLYDATA *)&np1)->eye.w =
			t*(((POLYDATA *)a)->eye.w - ((POLYDATA *)b)->eye.w) +
			((POLYDATA *)b)->eye.w;
		    a = &np1;
		    a->has = b->has;
		    ASSERTOPENGL(!(a->has & __GL_HAS_FIXEDPT), "clear __GL_HAS_FIXEDPT flag!\n");
		} else {
		    /* a is in */
		    if (__GL_FLOAT_LTZ(d2)) {
			/*
			** A is in and B is out.  Compute new B
			** coordinate clipped to the plane.
			**
			** NOTE: To avoid cracking in polygons with
			** shared clipped edges we always compute "t"
			** from the out vertex to the in vertex.  The
			** above clipping code gets this for free (b is
			** in and a is out).  In this code b is out and a
			** is in, so we reverse the t computation and the
			** argument order to (*clip).
			*/
			t = d1 / (d1 - d2);
			(*clip)(&np2, b, a, t);
			((POLYDATA *)&np2)->eye.x =
			    t*(((POLYDATA *)b)->eye.x - ((POLYDATA *)a)->eye.x)+
			    ((POLYDATA *)a)->eye.x;
			((POLYDATA *)&np2)->eye.y =
			    t*(((POLYDATA *)b)->eye.y - ((POLYDATA *)a)->eye.y)+
			    ((POLYDATA *)a)->eye.y;
			((POLYDATA *)&np2)->eye.z =
			    t*(((POLYDATA *)b)->eye.z - ((POLYDATA *)a)->eye.z)+
			    ((POLYDATA *)a)->eye.z;
			((POLYDATA *)&np2)->eye.w =
			    t*(((POLYDATA *)b)->eye.w - ((POLYDATA *)a)->eye.w)+
			    ((POLYDATA *)a)->eye.w;
			b = &np2;
			b->has = a->has;
			ASSERTOPENGL(!(b->has & __GL_HAS_FIXEDPT), "clear __GL_HAS_FIXEDPT flag!\n");
		    } else {
			/* A and B are in */
		    }
		}
	    }
	    plane++;
	    clipCodes >>= 1;
	} while (clipCodes);
    }

    allClipCodes &= __GL_FRUSTUM_CLIP_MASK;
    if (allClipCodes) {
	i = 0;
	do {
	    /*
	    ** See if this clip plane has anything out of it.  If not,
	    ** press onward to check the next plane.  Note that we
	    ** shift this mask to the right at the bottom of the loop.
	    */
	    if (allClipCodes & 1) {
		__GLfloat t, d1, d2;

                if (i & 1)
                {
                    d1 = a->clip.w -
                        *(__GLfloat *)((GLubyte *)a + __glFrustumOffsets[i]);
                    d2 = b->clip.w -
                        *(__GLfloat *)((GLubyte *)b + __glFrustumOffsets[i]);
                }
                else
                {
                    d1 = *(__GLfloat *)((GLubyte *)a + __glFrustumOffsets[i]) +
                        a->clip.w;
                    d2 = *(__GLfloat *)((GLubyte *)b + __glFrustumOffsets[i]) +
                        b->clip.w;
                }

		if (__GL_FLOAT_LTZ(d1)) {
		    /* a is out */
		    if (__GL_FLOAT_LTZ(d2)) {
			/* a & b are out */
                        FPU_RESTORE_MODE();
			return;
		    }

		    /*
		    ** A is out and B is in.  Compute new A coordinate
		    ** clipped to the plane.
		    */
		    t = d2 / (d2 - d1);
		    (*clip)(&np1, a, b, t);
		    a = &np1;
		    a->has = b->has;
		    ASSERTOPENGL(!(a->has & __GL_HAS_FIXEDPT), "clear __GL_HAS_FIXEDPT flag!\n");
		} else {
		    /* a is in */
		    if (__GL_FLOAT_LTZ(d2)) {
			/*
			** A is in and B is out.  Compute new B
			** coordinate clipped to the plane.
			**
			** NOTE: To avoid cracking in polygons with
			** shared clipped edges we always compute "t"
			** from the out vertex to the in vertex.  The
			** above clipping code gets this for free (b is
			** in and a is out).  In this code b is out and a
			** is in, so we reverse the t computation and the
			** argument order to (*clip).
			*/
			t = d1 / (d1 - d2);
			(*clip)(&np2, b, a, t);
			b = &np2;
			b->has = a->has;
			ASSERTOPENGL(!(b->has & __GL_HAS_FIXEDPT), "clear __GL_HAS_FIXEDPT flag!\n");
		    } else {
			/* A and B are in */
		    }
		}
	    }
            i++;
	    allClipCodes >>= 1;
	} while (allClipCodes);
    }

    vp = &gc->state.viewport;
    vpXCenter = vp->xCenter;
    vpYCenter = vp->yCenter;
    vpZCenter = vp->zCenter;
    vpXScale = vp->xScale;
    vpYScale = vp->yScale;
    vpZScale = vp->zScale;

    /* Compute window coordinates for vertices generated by clipping */
    if (provokingA->clipCode != 0)
    {
        wInv = __glOne / a->clip.w;
        x = a->clip.x; 
        y = a->clip.y; 
        z = a->clip.z;
        winx = x * vpXScale * wInv + vpXCenter;
        winy = y * vpYScale * wInv + vpYCenter;

        if (winx < gc->transform.fminx)
            winx = gc->transform.fminx;
        else if (winx >= gc->transform.fmaxx)
            winx = gc->transform.fmaxx - gc->constants.viewportEpsilon;

        if (winy < gc->transform.fminy)
            winy = gc->transform.fminy;
        else if (winy >= gc->transform.fmaxy)
            winy = gc->transform.fmaxy - gc->constants.viewportEpsilon;

        a->window.z = z * vpZScale * wInv + vpZCenter;
        a->window.w = wInv;
        a->window.x = winx;
        a->window.y = winy;

        // Update color pointer since this vertex is a new one
        // generated by clipping
        if (gc->state.light.shadingModel == GL_FLAT)
        {
            a->color = &provokingA->colors[__GL_FRONTFACE];
        }
        else
        {
            a->color = &a->colors[__GL_FRONTFACE];
        }
    }

    if (provokingB->clipCode != 0)
    {
        wInv = __glOne / b->clip.w;
        x = b->clip.x; 
        y = b->clip.y; 
        z = b->clip.z;
        winx = x * vpXScale * wInv + vpXCenter;
        winy = y * vpYScale * wInv + vpYCenter;

        if (winx < gc->transform.fminx)
            winx = gc->transform.fminx;
        else if (winx >= gc->transform.fmaxx)
            winx = gc->transform.fmaxx - gc->constants.viewportEpsilon;

        if (winy < gc->transform.fminy)
            winy = gc->transform.fminy;
        else if (winy >= gc->transform.fmaxy)
            winy = gc->transform.fmaxy - gc->constants.viewportEpsilon;

        b->window.z = z * vpZScale * wInv + vpZCenter;
        b->window.w = wInv;
        b->window.x = winx;
        b->window.y = winy;
        
        if (gc->state.light.shadingModel == GL_FLAT)
        {
            b->color = &provokingB->colors[__GL_FRONTFACE];
        }
        else
        {
            b->color = &b->colors[__GL_FRONTFACE];
        }
    }

    // Restore the floating-point mode for rendering:
    FPU_RESTORE_MODE();

    /* Validate line state */
    if (gc->state.light.shadingModel == GL_FLAT) {
	// Add the vertices then restore the b color pointer
        //
        // Note that although b is the only new vertex, up
        // to two vertices can be added because each new vertex
        // generated by clipping must be added.  For a line where
        // both endpoints are out of the clipping region, both
        // an entry and an exit vertex must be added
        if (provokingA->clipCode != 0)
        {
            // a was out so a new vertex was added at the point of
            // entry
            flags |= __GL_LVERT_FIRST;
        }
        // b is always added since either:
        // b was in and is new so it needs to be added
        // b was out so a new vertex was added at the exit point
        (*gc->procs.renderLine)(gc, a, b, flags);
        
#ifndef NT
	b->color = &b->colors[__GL_FRONTFACE];
#endif
    } else {
        if (provokingA->clipCode != 0)
        {
            flags |= __GL_LVERT_FIRST;
        }
        (*gc->procs.renderLine)(gc, a, b, flags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_listc.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.15 $
** $Date: 1993/10/23 00:34:54 $
*/
#include "precomp.h"
#pragma hdrstop

#include "listcomp.h"
#include "g_listop.h"
#include "lcfuncs.h"
#include "dlist.h"
#include "dlistopt.h"

#ifndef NT
// Move to dlist.
/*
** The code in here makes a lot of assumptions about the size of the 
** various user types (GLfloat, GLint, etcetra).  
*/

#define __GL_IMAGE_BITMAP	0
#define __GL_IMAGE_INDICES	1
#define __GL_IMAGE_RGBA		2

void __gllc_Bitmap(GLsizei width, GLsizei height,
		   GLfloat xorig, GLfloat yorig, 
		   GLfloat xmove, GLfloat ymove, 
		   const GLubyte *oldbits)
{
    __GLbitmap *bitmap;
    GLubyte *newbits;
    GLint imageSize;
    __GL_SETUP();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue(gc);
	return;
    }

    imageSize = height * ((width + 7) >> 3);
    imageSize = __GL_PAD(imageSize);

    bitmap = (__GLbitmap *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(imageSize + sizeof(__GLbitmap)),
                                DLIST_GENERIC_OP(Bitmap));
    if (bitmap == NULL) return;

    bitmap->width = width;
    bitmap->height = height;
    bitmap->xorig = xorig;
    bitmap->yorig = yorig;
    bitmap->xmove = xmove;
    bitmap->ymove = ymove;
    bitmap->imageSize = imageSize;

    newbits = (GLubyte *)bitmap + sizeof(__GLbitmap); 
    __glFillImage(gc, width, height, GL_COLOR_INDEX, GL_BITMAP, 
                  oldbits, newbits);

    __glDlistAppendOp(gc, bitmap, __glle_Bitmap);
}

const GLubyte *__glle_Bitmap(const GLubyte *PC)
{
    const __GLbitmap *bitmap;
    __GL_SETUP();
    GLuint beginMode;

    bitmap = (const __GLbitmap *) PC;

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return PC + sizeof(__GLbitmap) + bitmap->imageSize;
	}
    }

    (*gc->procs.renderBitmap)(gc, bitmap, (const GLubyte *) (bitmap+1));

    return PC + sizeof(__GLbitmap) + bitmap->imageSize;
}

void FASTCALL __gllei_PolygonStipple(__GLcontext *gc, const GLubyte *bits)
{
    if (__GL_IN_BEGIN()) {
        __glSetError(GL_INVALID_OPERATION);
        return;
    }

    /* 
    ** Just copy bits into stipple, convertPolygonStipple() will do the rest.
    */
    __GL_MEMCOPY(&gc->state.polygonStipple.stipple[0], bits,
		 sizeof(gc->state.polygonStipple.stipple));
    (*gc->procs.convertPolygonStipple)(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, POLYDRAW);
#endif
}

void __gllc_PolygonStipple(const GLubyte *mask)
{
    void *data;
    __GL_SETUP();
    GLubyte *newbits;

    newbits = (GLubyte *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(__glImageSize(32, 32, GL_COLOR_INDEX, GL_BITMAP)),
                                DLIST_GENERIC_OP(PolygonStipple));
    if (newbits == NULL) return;

    __glFillImage(gc, 32, 32, GL_COLOR_INDEX, GL_BITMAP, mask, newbits);

    __glDlistAppendOp(gc, newbits, __glle_PolygonStipple);
}

const GLubyte *__glle_PolygonStipple(const GLubyte *PC)
{
    __GL_SETUP();

    __gllei_PolygonStipple(gc, (const GLubyte *) (PC));
    return PC + __glImageSize(32, 32, GL_COLOR_INDEX, GL_BITMAP);
}

typedef struct __GLmap1_Rec {
        GLenum    target;
        __GLfloat u1;
        __GLfloat u2;
        GLint     order;
        /*        points  */
} __GLmap1;

void __gllc_Map1f(GLenum target, 
		  GLfloat u1, GLfloat u2,
		  GLint stride, GLint order,
		  const GLfloat *points)
{
    __GLmap1 *map1data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();
    
    k=__glEvalComputeK(target);
    if (k < 0) {
	__gllc_InvalidEnum(gc);
	return;
    }

    if (order > gc->constants.maxEvalOrder || stride < k ||
	    order < 1 || u1 == u2) {
	__gllc_InvalidValue(gc);
	return;
    }

    cmdsize = sizeof(__GLmap1) + 
	    __glMap1_size(k, order) * sizeof(__GLfloat);

    map1data = (__GLmap1 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map1));
    if (map1data == NULL) return;

    map1data->target = target;
    map1data->u1 = u1;
    map1data->u2 = u2;
    map1data->order = order;
    data = (__GLfloat *) ((GLubyte *)map1data + sizeof(__GLmap1));
    __glFillMap1f(k, order, stride, points, data);

    __glDlistAppendOp(gc, map1data, __glle_Map1);
}

const GLubyte *__glle_Map1(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLmap1 *map1data;
    GLint k;

    map1data = (const __GLmap1 *) PC;
    k = __glEvalComputeK(map1data->target);

    /* Stride of "k" matches internal stride */
#ifdef __GL_DOUBLE
    (*gc->dispatchState->dispatch->Map1d)
#else /* __GL_DOUBLE */
    (*gc->dispatchState->dispatch->Map1f)
#endif /* __GL_DOUBLE */
	    (map1data->target, map1data->u1, map1data->u2,
	    k, map1data->order, (const __GLfloat *)(PC + sizeof(__GLmap1)));

    return PC + sizeof(__GLmap1) + 
	    __glMap1_size(k, map1data->order) * sizeof(__GLfloat);
}

void __gllc_Map1d(GLenum target, 
		  GLdouble u1, GLdouble u2,
		  GLint stride, GLint order, 
		  const GLdouble *points)
{
    __GLmap1 *map1data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();
    
    k=__glEvalComputeK(target);
    if (k < 0) {
	__gllc_InvalidEnum(gc);
	return;
    }

    if (order > gc->constants.maxEvalOrder || stride < k ||
	    order < 1 || u1 == u2) {
	__gllc_InvalidValue(gc);
	return;
    }

    cmdsize = sizeof(__GLmap1) + 
	    __glMap1_size(k, order) * sizeof(__GLfloat);

    map1data = (__GLmap1 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map1));
    if (map1data == NULL) return;

    map1data->target = target;
    map1data->u1 = u1;
    map1data->u2 = u2;
    map1data->order = order;
    data = (__GLfloat *) ((GLubyte *)map1data + sizeof(__GLmap1));
    __glFillMap1d(k, order, stride, points, data);

    __glDlistAppendOp(gc, map1data, __glle_Map1);
}

typedef struct __GLmap2_Rec {
        GLenum    target;
        __GLfloat u1;
        __GLfloat u2;
        GLint     uorder;
        __GLfloat v1;
        __GLfloat v2;
        GLint     vorder;
        /*        points  */
} __GLmap2;

void __gllc_Map2f(GLenum target, 
		  GLfloat u1, GLfloat u2,
		  GLint ustride, GLint uorder, 
		  GLfloat v1, GLfloat v2,
		  GLint vstride, GLint vorder, 
		  const GLfloat *points)
{
    __GLmap2 *map2data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();

    k=__glEvalComputeK(target);
    if (k < 0) {
	__gllc_InvalidEnum(gc);
	return;
    }

    if (vorder > gc->constants.maxEvalOrder || vstride < k ||
	    vorder < 1 || u1 == u2 || ustride < k ||
	    uorder > gc->constants.maxEvalOrder || uorder < 1 ||
	    v1 == v2) {
	__gllc_InvalidValue(gc);
	return;
    }

    cmdsize = sizeof(__GLmap2) + 
	    __glMap2_size(k, uorder, vorder) * sizeof(__GLfloat);

    map2data = (__GLmap2 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map2));
    if (map2data == NULL) return;

    map2data->target = target;
    map2data->u1 = u1;
    map2data->u2 = u2;
    map2data->uorder = uorder;
    map2data->v1 = v1;
    map2data->v2 = v2;
    map2data->vorder = vorder;

    data = (__GLfloat *) ((GLubyte *)map2data + sizeof(__GLmap2));
    __glFillMap2f(k, uorder, vorder, ustride, vstride, points, data);

    __glDlistAppendOp(gc, map2data, __glle_Map2);
}

const GLubyte *__glle_Map2(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLmap2 *map2data;
    GLint k;

    map2data = (const __GLmap2 *) PC;
    k = __glEvalComputeK(map2data->target);

    /* Stride of "k" and "k * vorder" matches internal strides */
#ifdef __GL_DOUBLE
    (*gc->dispatchState->dispatch->Map2d)
#else /* __GL_DOUBLE */
    (*gc->dispatchState->dispatch->Map2f)
#endif /* __GL_DOUBLE */
	    (map2data->target, 
	    map2data->u1, map2data->u2, k * map2data->vorder, map2data->uorder,
	    map2data->v1, map2data->v2, k, map2data->vorder,
	    (const __GLfloat *)(PC + sizeof(__GLmap2)));
    
    return PC + sizeof(__GLmap2) + 
	    __glMap2_size(k, map2data->uorder, map2data->vorder) * 
	    sizeof(__GLfloat);
}

void __gllc_Map2d(GLenum target, 
		  GLdouble u1, GLdouble u2,
                  GLint ustride, GLint uorder, 
		  GLdouble v1, GLdouble v2,
		  GLint vstride, GLint vorder, 
		  const GLdouble *points)
{
    __GLmap2 *map2data;
    GLint k;
    GLint cmdsize;
    __GLfloat *data;
    __GL_SETUP();

    k=__glEvalComputeK(target);
    if (k < 0) {
	__gllc_InvalidEnum(gc);
	return;
    }

    if (vorder > gc->constants.maxEvalOrder || vstride < k ||
	    vorder < 1 || u1 == u2 || ustride < k ||
	    uorder > gc->constants.maxEvalOrder || uorder < 1 ||
	    v1 == v2) {
	__gllc_InvalidValue(gc);
	return;
    }

    cmdsize = sizeof(__GLmap2) + 
	    __glMap2_size(k, uorder, vorder) * sizeof(__GLfloat);

    map2data = (__GLmap2 *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(cmdsize), DLIST_GENERIC_OP(Map2));
    if (map2data == NULL) return;

    map2data->target = target;
    map2data->u1 = u1;
    map2data->u2 = u2;
    map2data->uorder = uorder;
    map2data->v1 = v1;
    map2data->v2 = v2;
    map2data->vorder = vorder;

    data = (__GLfloat *) ((GLubyte *)map2data + sizeof(__GLmap2));
    __glFillMap2d(k, uorder, vorder, ustride, vstride, points, data);

    __glDlistAppendOp(gc, map2data, __glle_Map2);
}

typedef struct __GLdrawPixels_Rec {
        GLsizei width;
        GLsizei height;
        GLenum  format;
        GLenum  type;
        /*      pixels  */
} __GLdrawPixels;

const GLubyte *__glle_DrawPixels(const GLubyte *PC)
{
    const __GLdrawPixels *pixdata;
    GLint imageSize;
    __GL_SETUP();
    GLuint beginMode;

    pixdata = (const __GLdrawPixels *) PC;
    imageSize = __glImageSize(pixdata->width, pixdata->height, 
			      pixdata->format, pixdata->type);

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return PC + sizeof(__GLdrawPixels) + __GL_PAD(imageSize);
	}
    }

    (*gc->procs.drawPixels)(gc, pixdata->width, pixdata->height, 
			    pixdata->format, pixdata->type, 
			    (const GLubyte *)(PC + sizeof(__GLdrawPixels)), 
			    GL_TRUE);
    return PC + sizeof(__GLdrawPixels) + __GL_PAD(imageSize);
}

void __gllc_DrawPixels(GLint width, GLint height, GLenum format, 
		       GLenum type, const GLvoid *pixels)
{
    __GLdrawPixels *pixdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue(gc);
	return;
    }
    switch (format) {
      case GL_STENCIL_INDEX:
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
      case GL_DEPTH_COMPONENT:
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum(gc);
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }

    imageSize = __glImageSize(width, height, format, type);
    imageSize = __GL_PAD(imageSize);

    pixdata = (__GLdrawPixels *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLdrawPixels) + imageSize),
                                DLIST_GENERIC_OP(DrawPixels));
    if (pixdata == NULL) return;

    pixdata->width = width;
    pixdata->height = height;
    pixdata->format = format;
    pixdata->type = type;

    __glFillImage(gc, width, height, format, type, pixels, 
                  (GLubyte *)pixdata + sizeof(__GLdrawPixels));

    __glDlistAppendOp(gc, pixdata, __glle_DrawPixels);
}

typedef struct __GLtexImage1D_Rec {
        GLenum  target;
        GLint   level;
        GLint   components;
        GLsizei width;
        GLint   border;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexImage1D;

const GLubyte *__glle_TexImage1D(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLtexImage1D *data;

    data = (const __GLtexImage1D *) PC;
    __gllei_TexImage1D(gc, data->target, data->level, data->components, 
		       data->width, data->border, data->format, data->type, 
		       (const GLubyte *)(PC + sizeof(__GLtexImage1D)));

    return PC + sizeof(__GLtexImage1D) + __GL_PAD(data->imageSize);
}

typedef struct __GLtexImage2D_Rec {
        GLenum  target;
        GLint   level;
        GLint   components;
        GLsizei width;
        GLsizei height;
        GLint   border;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexImage2D;

const GLubyte *__glle_TexImage2D(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLtexImage2D *data;

    data = (const __GLtexImage2D *) PC;
    __gllei_TexImage2D(gc, data->target, data->level, data->components, 
		       data->width, data->height, data->border, data->format, 
		       data->type,
		       (const GLubyte *)(PC + sizeof(__GLtexImage2D)));

    return PC + sizeof(__GLtexImage2D) + __GL_PAD(data->imageSize);
}

void __gllc_TexImage1D(GLenum target, GLint level, 
		       GLint components,
		       GLint width, GLint border, GLenum format, 
		       GLenum type, const GLvoid *pixels)
{
    __GLtexImage1D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

    if (border < 0 || border > 1) {
	__gllc_InvalidValue(gc);
	return;
    }
    if (width < 0) {
	__gllc_InvalidValue(gc);
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum(gc);
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }

    if (target == GL_PROXY_TEXTURE_1D_EXT) {
	imageSize = 0;
    } else {
	imageSize = __glImageSize(width, 1, format, type);
    }
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexImage1D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexImage1D)+imageSize),
                                DLIST_GENERIC_OP(TexImage1D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->components = components;
    texdata->width = width;
    texdata->border = border;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0 && pixels != NULL) {
        __glFillImage(gc, width, 1, format, type, pixels, 
                      (GLubyte *)texdata + sizeof(__GLtexImage1D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexImage1D);
}

void __gllc_TexImage2D(GLenum target, GLint level, 
		       GLint components,
		       GLint width, GLint height, GLint border, 
		       GLenum format, GLenum type, 
		       const GLvoid *pixels)
{
    __GLtexImage2D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

    if (border < 0 || border > 1) {
	__gllc_InvalidValue(gc);
	return;
    }
    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue(gc);
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum(gc);
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }

    if (target == GL_PROXY_TEXTURE_2D_EXT) {
	imageSize = 0;
    } else {
        imageSize = __glImageSize(width, height, format, type);
    }
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexImage2D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexImage2D) + imageSize),
                                DLIST_GENERIC_OP(TexImage2D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->components = components;
    texdata->width = width;
    texdata->height = height;
    texdata->border = border;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0 && pixels != NULL) {
        __glFillImage(gc, width, height, format, type, pixels, 
                      (GLubyte *) (GLubyte *)texdata + sizeof(__GLtexImage2D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexImage2D);
}


typedef struct __GLtexSubImage1D_Rec {
        GLenum  target;
        GLint   level;
        GLint   xoffset;
        GLsizei width;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexSubImage1D;

const GLubyte *__glle_TexSubImage1D(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLtexSubImage1D *data;

    data = (const __GLtexSubImage1D *) PC;
    __gllei_TexSubImage1D(gc, data->target, data->level, 
			     data->xoffset, data->width,
			     data->format, data->type, 
			  (const GLubyte *)(PC + sizeof(__GLtexSubImage1D)));
    return PC + sizeof(__GLtexSubImage1D) + __GL_PAD(data->imageSize);
}

void __gllc_TexSubImage1D(GLenum target, GLint level,
			     GLint xoffset, GLsizei width,
			     GLenum format, GLenum type, const GLvoid *pixels)
{
    __GLtexSubImage1D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

    if (width < 0) {
	__gllc_InvalidValue(gc);
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum(gc);
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }

    imageSize = __glImageSize(width, 1, format, type);
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexSubImage1D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexSubImage1D) + imageSize),
                                DLIST_GENERIC_OP(TexSubImage1D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->xoffset = xoffset;
    texdata->width = width;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0) {
	__glFillImage(gc, width, 1, format, type, pixels, 
		(GLubyte *)texdata + sizeof(__GLtexSubImage1D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexSubImage1D);
}

typedef struct __GLtexSubImage2D_Rec {
        GLenum  target;
        GLint   level;
        GLint   xoffset;
        GLint   yoffset;
        GLsizei width;
        GLsizei height;
        GLenum  format;
        GLenum  type;
        GLint   imageSize;
        /*      pixels  */
} __GLtexSubImage2D;

const GLubyte *__glle_TexSubImage2D(const GLubyte *PC)
{
    __GL_SETUP();
    const __GLtexSubImage2D *data;

    data = (const __GLtexSubImage2D *) PC;
    __gllei_TexSubImage2D(gc, data->target, data->level,
			     data->xoffset, data->yoffset,
			     data->width, data->height,
			     data->format, data->type,
		       (const GLubyte *)(PC + sizeof(__GLtexSubImage2D)));
    return PC + sizeof(__GLtexSubImage2D) + __GL_PAD(data->imageSize);
}

void __gllc_TexSubImage2D(GLenum target, GLint level,
			     GLint xoffset, GLint yoffset,
			     GLsizei width, GLsizei height,
			     GLenum format, GLenum type, const GLvoid *pixels)
{
    __GLtexSubImage2D *texdata;
    GLint imageSize;
    GLboolean index;
    __GL_SETUP();

    if ((width < 0) || (height < 0)) {
	__gllc_InvalidValue(gc);
	return;
    }
    switch (format) {
      case GL_COLOR_INDEX:
	index = GL_TRUE;
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
	index = GL_FALSE;
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }
    switch (type) {
      case GL_BITMAP:
	if (!index) {
	    __gllc_InvalidEnum(gc);
	    return;
	}
	break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	__gllc_InvalidEnum(gc);
	return;
    }

    imageSize = __glImageSize(width, height, format, type);
    imageSize = __GL_PAD(imageSize);

    texdata = (__GLtexSubImage2D *)
        __glDlistAddOpUnaligned(gc, DLIST_SIZE(sizeof(__GLtexSubImage2D) + imageSize),
                                DLIST_GENERIC_OP(TexSubImage2D));
    if (texdata == NULL) return;

    texdata->target = target;
    texdata->level = level;
    texdata->xoffset = xoffset;
    texdata->yoffset = yoffset;
    texdata->width = width;
    texdata->height = height;
    texdata->format = format;
    texdata->type = type;
    texdata->imageSize = imageSize;

    if (imageSize > 0) {
	__glFillImage(gc, width, height, format, type, pixels, 
		(GLubyte *) texdata + sizeof(__GLtexSubImage2D));
    }

    __glDlistAppendOp(gc, texdata, __glle_TexSubImage2D);
}
#endif // !NT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_lines.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

/*
** Process the incoming line by calling all of the appropriate line procs.
** Return value is ignored.
**
** It sets gc->polygon.shader.cfb to gc->drawBuffer.
*/
GLboolean FASTCALL __glProcessLine(__GLcontext *gc)
{
    GLboolean stippling, retval;
    GLint i,n;
#ifdef NT
    GLint length;
    __GLcolor colors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor fbcolors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor *vColors, *vFbcolors;
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;

    length = gc->polygon.shader.length;
    
    if (length > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (length+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return GL_TRUE;
        }
    }
    else
    {
        words = stackWords;
    }

    if (length > (__GL_MAX_STACKED_COLORS>>1))
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, length * sizeof(__GLcolor));
        if (NULL == vColors)
        {
            if (length > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            return GL_TRUE;
        }

        vFbcolors = (__GLcolor *) gcTempAlloc(gc, length * sizeof(__GLcolor));
        if (NULL == vFbcolors)
        {
            if (length > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            gcTempFree(gc, vColors);
            return GL_TRUE;
        }
    }
    else
    {
        vColors = colors;
        vFbcolors = fbcolors;
    }
#else
    __GLcolor vColors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
    __GLcolor vFbcolors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
#endif

    gc->polygon.shader.colors = vColors;
    gc->polygon.shader.fbcolors = vFbcolors;
    gc->polygon.shader.stipplePat = words;
    gc->polygon.shader.cfb = gc->drawBuffer;

    stippling = GL_FALSE;
    n = gc->procs.line.n;

    gc->polygon.shader.done = GL_FALSE;

    /* Step 1:  Perform early line stipple, coloring procs */
    for (i = 0; i < n; i++) {
	if (stippling) {
	    if ((*gc->procs.line.stippledLineFuncs[i])(gc)) {
		/* Line stippled away! */
		retval = GL_TRUE;
		goto __glProcessLineExit;
	    }
	} else {
	    if ((*gc->procs.line.lineFuncs[i])(gc)) {
		if (gc->polygon.shader.done)
                {
                    retval = GL_TRUE;
        	    goto __glProcessLineExit;
        	}
		stippling = GL_TRUE;
	    }
	}
    }

    if (stippling) {
	retval = (*gc->procs.line.wideStippledLineRep)(gc);
    } else {
	retval = (*gc->procs.line.wideLineRep)(gc);
    }
__glProcessLineExit:
#ifdef NT
    if (length > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
    if (length > (__GL_MAX_STACKED_COLORS>>1))
    {
        gcTempFree(gc, vColors);
        gcTempFree(gc, vFbcolors);
    }
#endif
    return (retval);
}

/*
** Process the incoming line by calling the 3 appropriate line procs.  It does
** not chain to gc->procs.line.wideLineRep, but returns instead.  This is a 
** specific fast path.
**
** Return value is ignored.
**
** It sets gc->polygon.shader.cfb to gc->drawBuffer.
*/
GLboolean FASTCALL __glProcessLine3NW(__GLcontext *gc)
{
    GLboolean retval;
#ifdef NT
    GLint length;
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    __GLcolor colors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor fbcolors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor *vColors, *vFbcolors;

    length = gc->polygon.shader.length;
    
    if (length > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (length+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return GL_TRUE;
        }
    }
    else
    {
        words = stackWords;
    }

    if (length > (__GL_MAX_STACKED_COLORS>>1))
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, length * sizeof(__GLcolor));
        if (NULL == vColors)
        {
            if (length > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            return GL_TRUE;
        }

        vFbcolors = (__GLcolor *) gcTempAlloc(gc, length * sizeof(__GLcolor));
        if (NULL == vFbcolors)
        {
            if (length > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            gcTempFree(gc, vColors);
            return GL_TRUE;
        }
    }
    else
    {
        vColors = colors;
        vFbcolors = fbcolors;
    }
#else
    __GLcolor vColors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
    __GLcolor vFbcolors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
#endif

    gc->polygon.shader.colors = vColors;
    gc->polygon.shader.fbcolors = vFbcolors;
    gc->polygon.shader.stipplePat = words;
    gc->polygon.shader.cfb = gc->drawBuffer;

    gc->polygon.shader.done = GL_FALSE;

    /* Call non-stippled procs... */
    if ((*gc->procs.line.lineFuncs[0])(gc)) {
	if (gc->polygon.shader.done)
        {
            retval = GL_TRUE;
            goto __glProcessLine3NWExit;
        }
	goto stippled1;
    }
    if ((*gc->procs.line.lineFuncs[1])(gc)) {
	if (gc->polygon.shader.done)
        {
            retval = GL_TRUE;
            goto __glProcessLine3NWExit;
        }
	goto stippled2;
    }
    retval = (*gc->procs.line.lineFuncs[2])(gc);
    goto __glProcessLine3NWExit;

stippled1:
    if ((*gc->procs.line.stippledLineFuncs[1])(gc)) {
	retval = GL_TRUE;
	goto __glProcessLine3NWExit;
    }
stippled2:
    retval = (*gc->procs.line.stippledLineFuncs[2])(gc);
__glProcessLine3NWExit:
#ifdef NT
    if (length > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
    if (length > (__GL_MAX_STACKED_COLORS>>1))
    {
        gcTempFree(gc, vColors);
        gcTempFree(gc, vFbcolors);
    }
#endif
    return (retval);
}

/*
** Take incoming line, duplicate it, and continue processing.
**
** Return value is ignored.
*/
GLboolean FASTCALL __glWideLineRep(__GLcontext *gc)
{
    GLint i, m, n, width;
    GLboolean stippling;

    n = gc->procs.line.n;
    m = gc->procs.line.m;
    
    width = gc->line.options.width;

    /* Step 2:  Replicate wide line */
    while (--width >= 0) {
	stippling = GL_FALSE;
	for (i = n; i < m; i++) {
	    if (stippling) {
		if ((*gc->procs.line.stippledLineFuncs[i])(gc)) {
		    /* Line stippled away! */
		    goto nextLine;
		}
	    } else {
		if ((*gc->procs.line.lineFuncs[i])(gc)) {
		    if (gc->polygon.shader.done) {
			gc->polygon.shader.done = GL_FALSE;
			goto nextLine;
		    }
		    stippling = GL_TRUE;
		}
	    }
	}
	if (stippling) {
	    (*gc->procs.line.drawStippledLine)(gc);
	} else {
	    (*gc->procs.line.drawLine)(gc);
	}
nextLine:
	if (gc->line.options.axis == __GL_X_MAJOR) {
	    gc->line.options.yStart++;
	} else {
	    gc->line.options.xStart++;
	}
    }

    return GL_FALSE;
}

/*
** Take incoming stippled line, duplicate it, and continue processing.
**
** Return value is ignored.
*/
GLboolean FASTCALL __glWideStippleLineRep(__GLcontext *gc)
{
    GLint i, m, n, width;
    GLint stipLen;
    GLint w;
    __GLlineState *ls = &gc->state.line;
    __GLstippleWord *fsp, *tsp;

#ifndef NT
    __GLstippleWord stipplePat[__GL_MAX_STIPPLE_WORDS];
    
    w = gc->polygon.shader.length;
#else
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *stipplePat;
    
    w = gc->polygon.shader.length;
    if (w > __GL_MAX_STACK_STIPPLE_BITS)
    {
        stipplePat = gcTempAlloc(gc, (w+__GL_STIPPLE_BITS-1)/8);
        if (stipplePat == NULL)
        {
            return GL_TRUE;
        }
    }
    else
    {
        stipplePat = stackWords;
    }
#endif
    
    n = gc->procs.line.n;
    m = gc->procs.line.m;
    
    width = ls->aliasedWidth;

    /*
    ** XXX - Saving the stipple like this is only really necessary if 
    ** depth or stencil testing.
    */
    stipLen = (w + __GL_STIPPLE_BITS - 1) >> __GL_STIPPLE_COUNT_BITS;

    fsp = gc->polygon.shader.stipplePat;
    tsp = stipplePat;
    for (i = 0; i < stipLen; i++) {
	*tsp++ = *fsp++;
    }

    /* Step 2:  Replicate wide line */
    while (--width >= 0) {
	for (i = n; i < m; i++) {
	    if ((*gc->procs.line.stippledLineFuncs[i])(gc)) {
		/* Line stippled away! */
		goto nextLine;
	    }
	}
	(*gc->procs.line.drawStippledLine)(gc);
nextLine:
	if (width) {
	    tsp = gc->polygon.shader.stipplePat;
	    fsp = stipplePat;
	    for (i = 0; i < stipLen; i++) {
		*tsp++ = *fsp++;
	    }

	    if (gc->line.options.axis == __GL_X_MAJOR) {
		gc->line.options.yStart++;
	    } else {
		gc->line.options.xStart++;
	    }
	}
    }

#ifdef NT
    if (w > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, stipplePat);
    }
#endif
    
    return GL_FALSE;
}

/*
** Take incoming line and draw it to both FRONT and BACK buffers.
**
** This routines sets gc->polygon.shader.cfb to &gc->frontBuffer
** and then to &gc->backBuffer
**
** Return value is ignored.
*/
GLboolean FASTCALL __glDrawBothLine(__GLcontext *gc)
{
    GLint i, j, m, l;
    GLboolean stippling;
    GLint w;
    __GLcolor *fcp, *tcp;
#ifdef NT
    __GLcolor colors[__GL_MAX_STACKED_COLORS];
    __GLcolor *vColors;
    
    w = gc->polygon.shader.length;
    if (w > __GL_MAX_STACKED_COLORS)
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
        if (NULL == vColors)
            return GL_TRUE;
    }
    else
    {
        vColors = colors;
    }
#else
    __GLcolor vColors[__GL_MAX_MAX_VIEWPORT];

    w = gc->polygon.shader.length;
#endif

    m = gc->procs.line.m;
    l = gc->procs.line.l;
    
    /*
    ** XXX - Saving colors like this is only really necessary if blending,
    ** logicOping, or masking.  
    */
    fcp = gc->polygon.shader.colors;
    tcp = vColors;
    if (gc->modes.rgbMode) {
	for (i = 0; i < w; i++) {
	    *tcp++ = *fcp++;
	}
    } else {
	for (i = 0; i < w; i++) {
	    tcp->r = fcp->r;
	    fcp++;
	    tcp++;
	}
    }

    /* Step 3:  Draw to FRONT_AND_BACK */
    for (j = 0; j < 2; j++) {
	if (j == 0) {
	    gc->polygon.shader.cfb = &gc->frontBuffer;
	} else {
	    gc->polygon.shader.cfb = &gc->backBuffer;
	}
	stippling = GL_FALSE;
	for (i = m; i < l; i++) {
	    if (stippling) {
		if ((*gc->procs.line.stippledLineFuncs[i])(gc)) {
		    /* Line stippled away! */
		    break;
		}
	    } else {
		if ((*gc->procs.line.lineFuncs[i])(gc)) {
		    if (gc->polygon.shader.done) {
			gc->polygon.shader.done = GL_FALSE;
			break;
		    }
		    stippling = GL_TRUE;
		}
	    }
	}

	if (j == 0) {
	    tcp = gc->polygon.shader.colors;
	    fcp = vColors;
	    if (gc->modes.rgbMode) {
		for (i = 0; i < w; i++) {
		    *tcp++ = *fcp++;
		}
	    } else {
		for (i = 0; i < w; i++) {
		    tcp->r = fcp->r;
		    fcp++;
		    tcp++;
		}
	    }
	}
    }
#ifdef NT
    if (w > __GL_MAX_STACKED_COLORS)
    {
        gcTempFree(gc, vColors);
    }
#endif
    return GL_FALSE;
}

/*
** Take incoming stippled line and draw it to both FRONT and BACK buffers.
**
** Return value is ignored.
*/
GLboolean FASTCALL __glDrawBothStippledLine(__GLcontext *gc)
{
    GLint i, m, l, j;
    GLint stipLen;
    GLint w;
    __GLstippleWord *fsp, *tsp;
    __GLcolor *fcp, *tcp;
#ifdef NT
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *stipplePat;
    __GLcolor colors[__GL_MAX_STACKED_COLORS];
    __GLcolor *vColors;

    w = gc->polygon.shader.length;
    
    if (w > __GL_MAX_STACK_STIPPLE_BITS)
    {
        stipplePat = gcTempAlloc(gc, (w+__GL_STIPPLE_BITS-1)/8);
        if (stipplePat == NULL)
        {
            return GL_TRUE;
        }
    }
    else
    {
        stipplePat = stackWords;
    }

    if (w > __GL_MAX_STACKED_COLORS)
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
        if (NULL == vColors)
        {
            if (w > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, stipplePat);
            }
            return GL_TRUE;
        }
    }
    else
    {
        vColors = colors;
    }
#else
    __GLstippleWord stipplePat[__GL_MAX_STIPPLE_WORDS];
    __GLcolor vColors[__GL_MAX_MAX_VIEWPORT];

    w = gc->polygon.shader.length;
#endif

    l = gc->procs.line.l;
    m = gc->procs.line.m;
    

    /*
    ** XXX - Saving colors like this is only really necessary if blending,
    ** logicOping, or masking, and not drawing to FRONT_AND_BACK (because
    ** if we are, then that proc will save colors too)
    */
    fcp = gc->polygon.shader.colors;
    tcp = vColors;
    if (gc->modes.rgbMode) {
	for (i = 0; i < w; i++) {
	    *tcp++ = *fcp++;
	}
    } else {
	for (i = 0; i < w; i++) {
	    tcp->r = fcp->r;
	    fcp++;
	    tcp++;
	}
    }

    /*
    ** XXX - Saving the stipple like this is only really necessary if 
    ** depth or stencil testing.
    */
    stipLen = (w + __GL_STIPPLE_BITS - 1) >> __GL_STIPPLE_COUNT_BITS;

    fsp = gc->polygon.shader.stipplePat;
    tsp = stipplePat;
    for (i = 0; i < stipLen; i++) {
	*tsp++ = *fsp++;
    }

    /* Step 2:  Replicate wide line */
    for (j = 0; j < 2; j++) {
	if (j == 0) {
	    gc->polygon.shader.cfb = &gc->frontBuffer;
	} else {
	    gc->polygon.shader.cfb = &gc->backBuffer;
	}
	for (i = m; i < l; i++) {
	    if ((*gc->procs.line.stippledLineFuncs[i])(gc)) {
		/* Line stippled away! */
		break;
	    }
	}
	if (j == 0) {
	    tcp = gc->polygon.shader.colors;
	    fcp = vColors;
	    if (gc->modes.rgbMode) {
		for (i = 0; i < w; i++) {
		    *tcp++ = *fcp++;
		}
	    } else {
		for (i = 0; i < w; i++) {
		    tcp->r = fcp->r;
		    fcp++;
		    tcp++;
		}
	    }

	    tsp = gc->polygon.shader.stipplePat;
	    fsp = stipplePat;
	    for (i = 0; i < stipLen; i++) {
		*tsp++ = *fsp++;
	    }
	}
    }
#ifdef NT
    if (w > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, stipplePat);
    }
    if (w > __GL_MAX_STACKED_COLORS)
    {
        gcTempFree(gc, vColors);
    }
#endif
    return GL_FALSE;
}

GLboolean FASTCALL __glScissorLine(__GLcontext *gc)
{
    GLint clipX0, clipX1;
    GLint clipY0, clipY1;
    GLint xStart, yStart, xEnd, yEnd;
    GLint xLittle, yLittle;
    GLint xBig, yBig;
    GLint fraction, dfraction;
    GLint highWord, lowWord;
    GLint bigs, littles;
    GLint failed, count;
    GLint w;
    __GLstippleWord bit, outMask, *osp;

    w = gc->polygon.shader.length;
    
    clipX0 = gc->transform.clipX0;
    clipX1 = gc->transform.clipX1;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;

    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;

    /* If the start point is in the scissor region, we attempt to trivially
    ** accept the line.
    */
    if (xStart >= clipX0 && xStart < clipX1 &&
	    yStart >= clipY0 && yStart < clipY1) {

	w--;	/* Makes our math simpler */
	/* Trivial accept attempt */
	xEnd = xStart + xBig * w;
	yEnd = yStart + yBig * w;
	if (xEnd >= clipX0 && xEnd < clipX1 && 
		yEnd >= clipY0 && yEnd < clipY1) {
	    return GL_FALSE;
	}

	xLittle = gc->line.options.xLittle;
	yLittle = gc->line.options.yLittle;
	fraction = gc->line.options.fraction;
	dfraction = gc->line.options.dfraction;

	/* Invert negative minor slopes so we can assume dfraction > 0 */
	if (dfraction < 0) {
	    dfraction = -dfraction;
	    fraction = 0x7fffffff - fraction;
	}

	/* Now we compute number of littles and bigs in this line */

	/* We perform a 16 by 32 bit multiply.  Ugh. */
	highWord = (((GLuint) dfraction) >> 16) * w + 
		(((GLuint) fraction) >> 16);
	lowWord = (dfraction & 0xffff) * w + (fraction & 0xffff);
	highWord += (((GLuint) lowWord) >> 16);
	bigs = ((GLuint) highWord) >> 15;
	littles = w - bigs;

	/* Second trivial accept attempt */
	xEnd = xStart + xBig*bigs + xLittle*littles;
	yEnd = yStart + yBig*bigs + yLittle*littles;
	if (xEnd >= clipX0 && xEnd < clipX1 && 
		yEnd >= clipY0 && yEnd < clipY1) {
	    return GL_FALSE;
	}
	w++;	/* Restore w */
    } else {
	xLittle = gc->line.options.xLittle;
	yLittle = gc->line.options.yLittle;
	fraction = gc->line.options.fraction;
	dfraction = gc->line.options.dfraction;
    }

    /*
    ** Note that we don't bother to try trivially rejecting this line.  After
    ** all, it has already been clipped, and the only way that it might
    ** possibly be trivially rejected is if it is a piece of a wide line that
    ** runs right along the edge of the window.
    */

    /*
    ** This sucks.  The line needs to be scissored.
    ** Well, it should only happen rarely, so we can afford
    ** to make it slow.  We achieve this by tediously stippling the line.
    ** (rather than clipping it, of course, which would be faster but harder).
    */
    failed = 0;
    osp = gc->polygon.shader.stipplePat;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (xStart < clipX0 || xStart >= clipX1 ||
		    yStart < clipY0 || yStart >= clipY1) {
		outMask &= ~bit;
		failed++;
	    }

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		xStart += xBig;
		yStart += yBig;
	    } else {
		xStart += xLittle;
		yStart += yLittle;
	    }

#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}

	*osp++ = outMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_TRUE;
    }

    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glScissorStippledLine(__GLcontext *gc)
{
    GLint clipX0, clipX1;
    GLint clipY0, clipY1;
    GLint xStart, yStart, xEnd, yEnd;
    GLint xLittle, yLittle;
    GLint xBig, yBig;
    GLint fraction, dfraction;
    GLint highWord, lowWord;
    GLint bigs, littles;
    GLint failed, count;
    GLint w;
    __GLstippleWord *sp;
    __GLstippleWord bit, outMask, inMask;

    w = gc->polygon.shader.length;

    clipX0 = gc->transform.clipX0;
    clipX1 = gc->transform.clipX1;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;

    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;

    /* If the start point is in the scissor region, we attempt to trivially
    ** accept the line.
    */
    if (xStart >= clipX0 && xStart < clipX1 &&
	    yStart >= clipY0 && yStart < clipY1) {

	w--;	/* Makes our math simpler */
	/* Trivial accept attempt */
	xEnd = xStart + xBig * w;
	yEnd = yStart + yBig * w;
	if (xEnd >= clipX0 && xEnd < clipX1 && 
		yEnd >= clipY0 && yEnd < clipY1) {
	    return GL_FALSE;
	}

	xLittle = gc->line.options.xLittle;
	yLittle = gc->line.options.yLittle;
	fraction = gc->line.options.fraction;
	dfraction = gc->line.options.dfraction;

	/* Invert negative minor slopes so we can assume dfraction > 0 */
	if (dfraction < 0) {
	    dfraction = -dfraction;
	    fraction = 0x7fffffff - fraction;
	}

	/* Now we compute number of littles and bigs in this line */

	/* We perform a 16 by 32 bit multiply.  Ugh. */
	highWord = (((GLuint) dfraction) >> 16) * w + 
		(((GLuint) fraction) >> 16);
	lowWord = (dfraction & 0xffff) * w + (fraction & 0xffff);
	highWord += (((GLuint) lowWord) >> 16);
	bigs = ((GLuint) highWord) >> 15;
	littles = w - bigs;

	/* Second trivial accept attempt */
	xEnd = xStart + xBig*bigs + xLittle*littles;
	yEnd = yStart + yBig*bigs + yLittle*littles;
	if (xEnd >= clipX0 && xEnd < clipX1 && 
		yEnd >= clipY0 && yEnd < clipY1) {
	    return GL_FALSE;
	}
	w++;	/* Restore w */
    } else {
	xLittle = gc->line.options.xLittle;
	yLittle = gc->line.options.yLittle;
	fraction = gc->line.options.fraction;
	dfraction = gc->line.options.dfraction;
    }

    /*
    ** Note that we don't bother to try trivially rejecting this line.  After
    ** all, it has already been clipped, and the only way that it might
    ** possibly be trivially rejected is if it is a piece of a wide line that
    ** runs right along the edge of the window.
    */

    /*
    ** This sucks.  The line needs to be scissored.
    ** Well, it should only happen rarely, so we can afford
    ** to make it slow.  We achieve this by tediously stippling the line.
    ** (rather than clipping it, of course, which would be faster but harder).
    */
    sp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		if (xStart < clipX0 || xStart >= clipX1 ||
			yStart < clipY0 || yStart >= clipY1) {
		    outMask &= ~bit;
		    failed++;
		}
	    } else failed++;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		xStart += xBig;
		yStart += yBig;
	    } else {
		xStart += xLittle;
		yStart += yLittle;
	    }

#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}

	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }

    return GL_TRUE;
}

/*
** Create a stipple based upon the current line stipple for this line.
*/
GLboolean FASTCALL __glStippleLine(__GLcontext *gc)
{
    GLint failed, count, stippleRepeat;
    GLint stipple, currentBit, stipplePos, repeat;
    __GLstippleWord bit, outMask, *osp;
    __GLlineState *ls = &gc->state.line;
    GLint w;

    w = gc->polygon.shader.length;
    osp = gc->polygon.shader.stipplePat;
    repeat = gc->line.repeat;
    stippleRepeat = ls->stippleRepeat;
    stipplePos = gc->line.stipplePosition;
    currentBit = 1 << stipplePos;
    stipple = ls->stipple;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if ((stipple & currentBit) == 0) {
		/* Stippled fragment away */
		outMask &= ~bit;
		failed++;
	    }

	    if (++repeat >= stippleRepeat) {
		stipplePos = (stipplePos + 1) & 0xf;
		currentBit = 1 << stipplePos;
		repeat = 0;
	    }

#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    gc->line.repeat = repeat;
    gc->line.stipplePosition = stipplePos;

    if (failed == 0) {
	return GL_FALSE;
    } else if (failed != gc->polygon.shader.length) {
	return GL_TRUE;
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Apply the stencil test to this line.
*/
GLboolean FASTCALL __glStencilTestLine(__GLcontext *gc)
{
    __GLstencilCell *tft, *sfb, *fail, cell;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dspLittle, dspBig;
    GLint count, failed;
    __GLstippleWord bit, outMask, *osp;
    GLuint smask;
    GLint w;

    w = gc->polygon.shader.length;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    tft = gc->stencilBuffer.testFuncTable;
#ifdef NT
    if (!tft)
        return GL_FALSE;
#endif // NT
    fail = gc->stencilBuffer.failOpTable;
    smask = gc->state.stencil.mask;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    cell = sfb[0];
	    if (!tft[cell & smask]) {
		/* Test failed */
		outMask &= ~bit;
		sfb[0] = fail[cell];
		failed++;
	    }

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		sfb += dspBig;
	    } else {
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Apply the stencil test to this stippled line.
*/
GLboolean FASTCALL __glStencilTestStippledLine(__GLcontext *gc)
{
    __GLstencilCell *tft, *sfb, *fail, cell;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint count, failed;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLint dspLittle, dspBig;
    GLuint smask;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    tft = gc->stencilBuffer.testFuncTable;
#ifdef NT
    if (!tft)
        return GL_FALSE;
#endif // NT
    fail = gc->stencilBuffer.failOpTable;
    smask = gc->state.stencil.mask;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		cell = sfb[0];
		if (!tft[cell & smask]) {
		    /* Test failed */
		    outMask &= ~bit;
		    sfb[0] = fail[cell];
		    failed++;
		}
	    } else failed++;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		sfb += dspBig;
	    } else {
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }
    return GL_TRUE;
}

#ifndef __GL_USEASMCODE

GLboolean FASTCALL __glDepthTestLine(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    switch (testFunc) {
	      case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
	      case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
	      case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
	      case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
	      case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
	      case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
	      case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
	      case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
	    }
	    if (passed) {
		if (writeEnabled) {
		    zfb[0] = z;
		}
	    } else {
		outMask &= ~bit;
		failed++;
	    }
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
	    } else {
		zfb += dzpLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	/* Call next span proc */
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next stippled span proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

#endif

GLboolean FASTCALL __glDepthTestStippledLine(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		switch (testFunc) {
		  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
		  case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
		  case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
		  case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
		  case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
		  case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
		  case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
		  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
		}
		if (passed) {
		    if (writeEnabled) {
			zfb[0] = z;
		    }
		} else {
		    outMask &= ~bit;
		    failed++;
		}
	    } else failed++;
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
	    } else {
		zfb += dzpLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean FASTCALL __glDepthTestStencilLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    switch (testFunc) {
	      case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
	      case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
	      case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
	      case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
	      case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
	      case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
	      case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
	      case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
	    }
	    if (passed) {
		sfb[0] = zPassOp[sfb[0]];
		if (writeEnabled) {
		    zfb[0] = z;
		}
	    } else {
		sfb[0] = zFailOp[sfb[0]];
		outMask &= ~bit;
		failed++;
	    }
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
		sfb += dspBig;
	    } else {
		zfb += dzpLittle;
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	/* Call next span proc */
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next stippled span proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glDepthTestStencilStippledLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		switch (testFunc) {
		  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
		  case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
		  case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
		  case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
		  case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
		  case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
		  case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
		  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
		}
		if (passed) {
		    sfb[0] = zPassOp[sfb[0]];
		    if (writeEnabled) {
			zfb[0] = z;
		    }
		} else {
		    sfb[0] = zFailOp[sfb[0]];
		    outMask &= ~bit;
		    failed++;
		}
	    } else failed++;
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
		sfb += dspBig;
	    } else {
		zfb += dzpLittle;
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }

    return GL_TRUE;
}

#ifdef NT
GLboolean FASTCALL __glDepth16TestLine(__GLcontext *gc)
{
    __GLzValue z, dzdx;
    __GLz16Value z16, *zfb;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    z16 = z >> Z16_SHIFT;
	    switch (testFunc) {
	      case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
	      case (GL_LESS & 0x7):     passed = z16 < zfb[0]; break;
	      case (GL_EQUAL & 0x7):    passed = z16 == zfb[0]; break;
	      case (GL_LEQUAL & 0x7):   passed = z16 <= zfb[0]; break;
	      case (GL_GREATER & 0x7):  passed = z16 > zfb[0]; break;
	      case (GL_NOTEQUAL & 0x7): passed = z16 != zfb[0]; break;
	      case (GL_GEQUAL & 0x7):   passed = z16 >= zfb[0]; break;
	      case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
	    }
	    if (passed) {
		if (writeEnabled) {
		    zfb[0] = z16;
		}
	    } else {
		outMask &= ~bit;
		failed++;
	    }
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
	    } else {
		zfb += dzpLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	/* Call next span proc */
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next stippled span proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glDepth16TestStippledLine(__GLcontext *gc)
{
    __GLzValue z, dzdx;
    __GLz16Value z16, *zfb;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		z16 = z >> Z16_SHIFT;
		switch (testFunc) {
		  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
		  case (GL_LESS & 0x7):     passed = z16 < zfb[0]; break;
		  case (GL_EQUAL & 0x7):    passed = z16 == zfb[0]; break;
		  case (GL_LEQUAL & 0x7):   passed = z16 <= zfb[0]; break;
		  case (GL_GREATER & 0x7):  passed = z16 > zfb[0]; break;
		  case (GL_NOTEQUAL & 0x7): passed = z16 != zfb[0]; break;
		  case (GL_GEQUAL & 0x7):   passed = z16 >= zfb[0]; break;
		  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
		}
		if (passed) {
		    if (writeEnabled) {
			zfb[0] = z16;
		    }
		} else {
		    outMask &= ~bit;
		    failed++;
		}
	    } else failed++;
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
	    } else {
		zfb += dzpLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean FASTCALL __glDepth16TestStencilLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx;
    __GLz16Value z16, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    testFunc = gc->state.depth.testFunc & 0x7;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    z16 = z >> Z16_SHIFT;
	    switch (testFunc) {
	      case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
	      case (GL_LESS & 0x7):     passed = z16 < zfb[0]; break;
	      case (GL_EQUAL & 0x7):    passed = z16 == zfb[0]; break;
	      case (GL_LEQUAL & 0x7):   passed = z16 <= zfb[0]; break;
	      case (GL_GREATER & 0x7):  passed = z16 > zfb[0]; break;
	      case (GL_NOTEQUAL & 0x7): passed = z16 != zfb[0]; break;
	      case (GL_GEQUAL & 0x7):   passed = z16 >= zfb[0]; break;
	      case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
	    }
	    if (passed) {
		sfb[0] = zPassOp[sfb[0]];
		if (writeEnabled) {
		    zfb[0] = z16;
		}
	    } else {
		sfb[0] = zFailOp[sfb[0]];
		outMask &= ~bit;
		failed++;
	    }
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
		sfb += dspBig;
	    } else {
		zfb += dzpLittle;
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	/* Call next span proc */
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next stippled span proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glDepth16TestStencilStippledLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dzpLittle, dzpBig;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx;
    __GLz16Value z16, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    zfb = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dzpLittle = xLittle + yLittle * gc->depthBuffer.buf.outerWidth;
    dzpBig = xBig + yBig * gc->depthBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    testFunc = gc->state.depth.testFunc & 0x7;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		z16 = z >> Z16_SHIFT;
		switch (testFunc) {
		  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
		  case (GL_LESS & 0x7):     passed = z16 < zfb[0]; break;
		  case (GL_EQUAL & 0x7):    passed = z16 == zfb[0]; break;
		  case (GL_LEQUAL & 0x7):   passed = z16 <= zfb[0]; break;
		  case (GL_GREATER & 0x7):  passed = z16 > zfb[0]; break;
		  case (GL_NOTEQUAL & 0x7): passed = z16 != zfb[0]; break;
		  case (GL_GEQUAL & 0x7):   passed = z16 >= zfb[0]; break;
		  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
		}
		if (passed) {
		    sfb[0] = zPassOp[sfb[0]];
		    if (writeEnabled) {
			zfb[0] = z16;
		    }
		} else {
		    sfb[0] = zFailOp[sfb[0]];
		    outMask &= ~bit;
		    failed++;
		}
	    } else failed++;
	    z += dzdx;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		zfb += dzpBig;
		sfb += dspBig;
	    } else {
		zfb += dzpLittle;
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
	/* Call next proc */
	return GL_FALSE;
    }

    return GL_TRUE;
}
#endif // NT

GLboolean FASTCALL __glDepthPassLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dspLittle, dspBig;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    zPassOp = gc->stencilBuffer.depthPassOpTable;
#ifdef NT
    if (!zPassOp)
        return GL_FALSE;
#endif // NT
    while (--w >= 0) {
	sfb[0] = zPassOp[sfb[0]];
	fraction += dfraction;
	if (fraction < 0) {
	    fraction &= ~0x80000000;
	    sfb += dspBig;
	} else {
	    sfb += dspLittle;
	}
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glDepthPassStippledLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    GLint dspLittle, dspBig;
    __GLstippleWord bit, inMask, *sp;
    GLint count;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
	    gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
#ifdef NT
    if (!zPassOp)
        return GL_FALSE;
#endif // NT
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp++;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		sfb[0] = zPassOp[sfb[0]];
	    }
	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		sfb += dspBig;
	    } else {
		sfb += dspLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glDitherCILine(__GLcontext *gc)
{
    /* XXX - Dither the CI line */
    return GL_FALSE;
}

GLboolean FASTCALL __glDitherCIStippledLine(__GLcontext *gc)
{
    /* XXX - Dither the CI stippled line */
    return GL_FALSE;
}

GLboolean FASTCALL __glDitherRGBALine(__GLcontext *gc)
{
    /* XXX - Dither the RGBA line */
    return GL_FALSE;
}

GLboolean FASTCALL __glDitherRGBAStippledLine(__GLcontext *gc)
{
    /* XXX - Dither the RGBA stippled line */
    return GL_FALSE;
}

/*
** This store line proc lives just above cfb->store, so it does
** fetching, blending, dithering, logicOping, masking, and storing.
**
** It uses the colorBuffer pointed to by gc->polygon.shader.cfb.
*/
GLboolean FASTCALL __glStoreLine(__GLcontext *gc)
{
    GLint xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint len;

    len = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;
    store = cfb->store;
    frag.x = gc->line.options.xStart;
    frag.y = gc->line.options.yStart;

    while (--len >= 0) {
	frag.color = *cp++;
	(*store)(cfb, &frag);

	fraction += dfraction;
	if (fraction < 0) {
	    fraction &= ~0x80000000;
	    frag.x += xBig;
	    frag.y += yBig;
	} else {
	    frag.x += xLittle;
	    frag.y += yLittle;
	}
    }

    return GL_FALSE;
}

/*
** This store line proc lives just above cfb->store, so it does
** fetching, blending, dithering, logicOping, masking, and storing.
**
** It uses the colorBuffer pointed to by gc->polygon.shader.cfb.
*/
GLboolean FASTCALL __glStoreStippledLine(__GLcontext *gc)
{
    GLint x, y, xLittle, xBig, yLittle, yBig;
    GLint fraction, dfraction;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    __GLstippleWord inMask, bit, *sp;
    GLint count;
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);
    GLint len;

    len = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;
    store = cfb->store;
    x = gc->line.options.xStart;
    y = gc->line.options.yStart;

    while (len) {
	count = len;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	len -= count;

	inMask = *sp++;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		frag.x = x;
		frag.y = y;
		frag.color = *cp;
		(*store)(cfb, &frag);
	    }

	    cp++;
	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		x += xBig;
		y += yBig;
	    } else {
		x += xLittle;
		y += yLittle;
	    }
#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glAntiAliasLine(__GLcontext *gc)
{
    __GLfloat length;	/* Dist along length */
    __GLfloat width;	/* Dist along width */
    GLint fraction, dfraction;
    __GLfloat dlLittle, dlBig;
    __GLfloat ddLittle, ddBig;
    __GLcolor *cp;
    __GLfloat coverage;
    __GLfloat lineWidth;
    __GLfloat lineLength;
    GLint failed, count;
    __GLstippleWord bit, outMask, *osp;
    GLint w;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    w = gc->polygon.shader.length;

    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    cp = gc->polygon.shader.colors;

    dlLittle = gc->line.options.dlLittle;
    dlBig = gc->line.options.dlBig;
    ddLittle = gc->line.options.ddLittle;
    ddBig = gc->line.options.ddBig;

    length = gc->line.options.plength;
    width = gc->line.options.pwidth;
    lineLength = gc->line.options.realLength - __glHalf;
    lineWidth = __glHalf * gc->state.line.smoothWidth - __glHalf;


    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);

	while (--count >= 0) {
	    /* Coverage for sides */
	    if (width > lineWidth) {
		coverage = lineWidth - width + __glOne;
		if (coverage < __glZero) {
		    coverage = __glZero;
		    goto coverageZero;
		}
	    } else if (width < -lineWidth) {
		coverage = width + lineWidth + __glOne;
		if (coverage < __glZero) {
		    coverage = __glZero;
		    goto coverageZero;
		}
	    } else {
		coverage = __glOne;
	    }

	    /* Coverage for start, end */
	    if (length < __glHalf) {
		coverage *= length + __glHalf;
		if (coverage < __glZero) {
		    coverage = __glZero;
		    goto coverageZero;
		}
	    } else if (length > lineLength) {
		coverage *= lineLength - length + __glOne;
		if (coverage < __glZero) {
		    coverage = __glZero;
		    goto coverageZero;
		}
	    } 

	    /* Coverage for internal stipples */
	    if ( modeFlags & __GL_SHADE_LINE_STIPPLE ) {
		__GLfloat stippleOffset;
		GLint lowStip, highStip;
		GLint lowBit, highBit;
		GLint lowVal, highVal;
		__GLfloat percent;

		/* Minor correction */
		if (length > __glHalf) {
		    stippleOffset = gc->line.options.stippleOffset + length;
		} else {
		    stippleOffset = gc->line.options.stippleOffset + __glHalf;
		}
		lowStip = __GL_FAST_FLOORF_I(stippleOffset);
		highStip = lowStip + 1;

		/* percent is the percent of highStip that will be used */
		percent = stippleOffset - lowStip;

		lowBit = (GLint) (lowStip * 
			gc->line.options.oneOverStippleRepeat) & 0xf;
		highBit = (GLint) (highStip * 
			gc->line.options.oneOverStippleRepeat) & 0xf;

		if (gc->state.line.stipple & (1<<lowBit)) {
		    lowVal = 1;
		} else {
		    lowVal = 0;
		}

		if (gc->state.line.stipple & (1<<highBit)) {
		    highVal = 1;
		} else {
		    highVal = 0;
		}

		coverage *= lowVal * (__glOne - percent) +
			highVal * percent;
	    }

	    if (coverage == __glZero) {
coverageZero:;
		outMask &= ~bit;
		failed++;
	    } else {
		if (gc->modes.colorIndexMode) {
		    cp->r = __glBuildAntiAliasIndex(cp->r, coverage);
		} else {
		    cp->a *= coverage;
		}
	    }
	    cp++;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		length += dlBig;
		width += ddBig;
	    } else {
		length += dlLittle;
		width += ddLittle;
	    }

#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*osp++ = outMask;
    }

    if (failed == 0) {
	/* Call next span proc */
	return GL_FALSE;
    } else {
	if (failed != gc->polygon.shader.length) {
	    /* Call next stippled span proc */
	    return GL_TRUE;
	}
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glAntiAliasStippledLine(__GLcontext *gc)
{
    __GLfloat length;	/* Dist along length */
    __GLfloat width;	/* Dist along width */
    GLint fraction, dfraction;
    __GLfloat dlLittle, dlBig;
    __GLfloat ddLittle, ddBig;
    __GLcolor *cp;
    __GLfloat coverage;
    __GLfloat lineWidth;
    __GLfloat lineLength;
    GLint failed, count;
    __GLstippleWord bit, outMask, inMask, *sp;
    GLint w;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    cp = gc->polygon.shader.colors;

    dlLittle = gc->line.options.dlLittle;
    dlBig = gc->line.options.dlBig;
    ddLittle = gc->line.options.ddLittle;
    ddBig = gc->line.options.ddBig;

    length = gc->line.options.plength;
    width = gc->line.options.pwidth;
    lineLength = gc->line.options.realLength - __glHalf;
    lineWidth = __glHalf * gc->state.line.smoothWidth - __glHalf;

    failed = 0;
    while (w) {
	count = w;
	if (count > __GL_STIPPLE_BITS) {
	    count = __GL_STIPPLE_BITS;
	}
	w -= count;

	inMask = *sp;
	outMask = (__GLstippleWord) ~0;
	bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
	while (--count >= 0) {
	    if (inMask & bit) {
		/* Coverage for sides */
		if (width > lineWidth) {
		    coverage = lineWidth - width + __glOne;
		    if (coverage < __glZero) {
			coverage = __glZero;
			goto coverageZero;
		    }
		} else if (width < -lineWidth) {
		    coverage = width + lineWidth + __glOne;
		    if (coverage < __glZero) {
			coverage = __glZero;
			goto coverageZero;
		    }
		} else {
		    coverage = __glOne;
		}

		/* Coverage for start, end */
		if (length < __glHalf) {
		    coverage *= length + __glHalf;
		    if (coverage < __glZero) {
			coverage = __glZero;
			goto coverageZero;
		    }
		} else if (length > lineLength) {
		    coverage *= lineLength - length + __glOne;
		    if (coverage < __glZero) {
			coverage = __glZero;
			goto coverageZero;
		    }
		} 

		/* Coverage for internal stipples */
		if (modeFlags & __GL_SHADE_LINE_STIPPLE) {
		    __GLfloat stippleOffset;
		    GLint lowStip, highStip;
		    GLint lowBit, highBit;
		    GLint lowVal, highVal;
		    __GLfloat percent;

		    /* Minor correction */
		    if (length > __glHalf) {
			stippleOffset = gc->line.options.stippleOffset + length;
		    } else {
			stippleOffset = gc->line.options.stippleOffset + __glHalf;
		    }
		    lowStip = __GL_FAST_FLOORF_I(stippleOffset);
		    highStip = lowStip + 1;

		    /* percent is the percent of highStip that will be used */
		    percent = stippleOffset - lowStip;

		    lowBit = (GLint) (lowStip * 
			    gc->line.options.oneOverStippleRepeat) & 0xf;
		    highBit = (GLint) (highStip * 
			    gc->line.options.oneOverStippleRepeat) & 0xf;

		    if (gc->state.line.stipple & (1<<lowBit)) {
			lowVal = 1;
		    } else {
			lowVal = 0;
		    }

		    if (gc->state.line.stipple & (1<<highBit)) {
			highVal = 1;
		    } else {
			highVal = 0;
		    }

		    coverage *= lowVal * (__glOne - percent) +
			    highVal * percent;
		}

		if (coverage == __glZero) {
coverageZero:;
		    outMask &= ~bit;
		    failed++;
		} else {
		    if (gc->modes.colorIndexMode) {
			cp->r = __glBuildAntiAliasIndex(cp->r, coverage);
		    } else {
			cp->a *= coverage;
		    }
		}
	    } else failed++;
	    cp++;

	    fraction += dfraction;
	    if (fraction < 0) {
		fraction &= ~0x80000000;
		length += dlBig;
		width += ddBig;
	    } else {
		length += dlLittle;
		width += ddLittle;
	    }

#ifdef __GL_STIPPLE_MSB
	    bit >>= 1;
#else
	    bit <<= 1;
#endif
	}
	*sp++ = outMask & inMask;
    }

    if (failed == gc->polygon.shader.length) {
	return GL_TRUE;
    }
    return GL_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_math.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Mathematical subroutines needed by the GL.
**
** $Revision: 1.12 $
** $Date: 1993/12/11 01:03:25 $
*/
#include "precomp.h"
#pragma hdrstop

#include "xform.h"

#ifdef SGI
// SGIBUG None of the assembly routines copies matrixType!
#ifndef __GL_ASM_COPYMATRIX
/*
** Copy src to dst
*/
void FASTCALL __glCopyMatrix(__GLmatrix *dst, const __GLmatrix *src)
{
    dst->matrixType = src->matrixType;
    dst->matrix[0][0] = src->matrix[0][0];
    dst->matrix[0][1] = src->matrix[0][1];
    dst->matrix[0][2] = src->matrix[0][2];
    dst->matrix[0][3] = src->matrix[0][3];

    dst->matrix[1][0] = src->matrix[1][0];
    dst->matrix[1][1] = src->matrix[1][1];
    dst->matrix[1][2] = src->matrix[1][2];
    dst->matrix[1][3] = src->matrix[1][3];

    dst->matrix[2][0] = src->matrix[2][0];
    dst->matrix[2][1] = src->matrix[2][1];
    dst->matrix[2][2] = src->matrix[2][2];
    dst->matrix[2][3] = src->matrix[2][3];

    dst->matrix[3][0] = src->matrix[3][0];
    dst->matrix[3][1] = src->matrix[3][1];
    dst->matrix[3][2] = src->matrix[3][2];
    dst->matrix[3][3] = src->matrix[3][3];
}
#endif /*  __GL_ASM_COPYMATRIX */
#endif // SGI

/*
** Make m an identity matrix
*/
void FASTCALL __glMakeIdentity(__GLmatrix *m)
{
    __GLfloat zer = __glZero;
    __GLfloat one = ((__GLfloat) 1.0);;
    m->matrix[0][0] = one; m->matrix[0][1] = zer;
        m->matrix[0][2] = zer; m->matrix[0][3] = zer;
    m->matrix[1][0] = zer; m->matrix[1][1] = one;
        m->matrix[1][2] = zer; m->matrix[1][3] = zer;
    m->matrix[2][0] = zer; m->matrix[2][1] = zer;
        m->matrix[2][2] = one; m->matrix[2][3] = zer;
    m->matrix[3][0] = zer; m->matrix[3][1] = zer;
        m->matrix[3][2] = zer; m->matrix[3][3] = one;
    m->matrixType = __GL_MT_IDENTITY;
}


#ifndef __GL_ASM_MULTMATRIX
/*
** Compute r = a * b, where r can equal b.
*/
void FASTCALL __glMultMatrix(__GLmatrix *r, const __GLmatrix *a, const __GLmatrix *b)
{
    __GLfloat b00, b01, b02, b03;
    __GLfloat b10, b11, b12, b13;
    __GLfloat b20, b21, b22, b23;
    __GLfloat b30, b31, b32, b33;
    GLint i;

    b00 = b->matrix[0][0]; b01 = b->matrix[0][1];
        b02 = b->matrix[0][2]; b03 = b->matrix[0][3];
    b10 = b->matrix[1][0]; b11 = b->matrix[1][1];
        b12 = b->matrix[1][2]; b13 = b->matrix[1][3];
    b20 = b->matrix[2][0]; b21 = b->matrix[2][1];
        b22 = b->matrix[2][2]; b23 = b->matrix[2][3];
    b30 = b->matrix[3][0]; b31 = b->matrix[3][1];
        b32 = b->matrix[3][2]; b33 = b->matrix[3][3];

    for (i = 0; i < 4; i++) {
	r->matrix[i][0] = a->matrix[i][0]*b00 + a->matrix[i][1]*b10
	    + a->matrix[i][2]*b20 + a->matrix[i][3]*b30;
	r->matrix[i][1] = a->matrix[i][0]*b01 + a->matrix[i][1]*b11
	    + a->matrix[i][2]*b21 + a->matrix[i][3]*b31;
	r->matrix[i][2] = a->matrix[i][0]*b02 + a->matrix[i][1]*b12
	    + a->matrix[i][2]*b22 + a->matrix[i][3]*b32;
	r->matrix[i][3] = a->matrix[i][0]*b03 + a->matrix[i][1]*b13
	    + a->matrix[i][2]*b23 + a->matrix[i][3]*b33;
    }
}
#endif /*  __GL_ASM_MULTMATRIX */

#ifndef __GL_ASM_NORMALIZE
/*
** Normalize v into vout.
*/
void FASTCALL __glNormalize(__GLfloat vout[3], const __GLfloat v[3])
{
    __GLfloat len;

    len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
    if (__GL_FLOAT_LEZ(len)) 
    {
        vout[0] = __glZero;
        vout[1] = __glZero;
        vout[2] = __glZero;
        return;
    } else {
        if (len == ((__GLfloat) 1.0)) 
        {
	        vout[0] = v[0];
	        vout[1] = v[1];
	        vout[2] = v[2];
        } else {
	        len = ((__GLfloat) 1.0) / __GL_SQRTF(len);
	        vout[0] = v[0] * len;
	        vout[1] = v[1] * len;
	        vout[2] = v[2] * len;
        }
    }
}

#endif /* __GL_ASM_NORMALIZE */

#ifndef __GL_ASM_NORMAL_BATCH
/*
** Normalize normals in a polyarray.
*/
void FASTCALL __glNormalizeBatch(POLYARRAY *pa)
{
    POLYDATA *  const pdLast = pa->pdNextVertex;
    POLYDATA  *pd = pa->pd0;

    for (; pd < pdLast; pd++)
    {
        if (pd->flags & POLYDATA_NORMAL_VALID)
        {
            __GLcoord * const v   = &pd->normal;
            const __GLfloat len = v->x*v->x + v->y*v->y + v->z*v->z;
            if (__GL_FLOAT_LEZ(len)) 
            {
	            v->x = __glZero;
	            v->y = __glZero;
	            v->z = __glZero;
            } else 
            {
	            if (fabs(len - (GLfloat)1.0) > (__GLfloat) 0.0001) 
                {
                    const __GLfloat   tmp = ((__GLfloat)1.0) / __GL_SQRTF(len);
	                v->x = v->x * tmp;
	                v->y = v->y * tmp;
	                v->z = v->z * tmp;
	            }
            }
        }
    }
}
#endif /* __GL_ASM_NORMAL_BATCH */

/*
** inverse = invert(transpose(src))

This code uses Cramer's Rule to calculate the matrix inverse.
In general, the inverse transpose has this form:

[          ] -t    [                                   ]
[          ]       [             -t             -t t   ]
[  Q    P  ]       [   S(SQ - PT)     -(SQ - PT)  T    ]
[          ]       [                                   ]
[          ]       [                                   ]
[          ]    =  [                                   ]
[          ]       [        -1  t                      ]
[          ]       [     -(Q  P)             1         ]
[  T    S  ]       [   -------------   -------------   ]
[          ]       [         -1  t t         -1  t t   ]
[          ]       [   S - (Q  P) T    S - (Q  P) T    ]

But in the usual case that P,S == [0, 0, 0, 1], this is enough:

[          ] -t    [                                   ]
[          ]       [         -t              -t t      ]
[  Q    0  ]       [        Q              -Q  T       ]
[          ]       [                                   ]
[          ]       [                                   ]
[          ]    =  [                                   ]
[          ]       [                                   ]
[          ]       [                                   ]
[  T    1  ]       [        0                1         ]
[          ]       [                                   ]
[          ]       [                                   ]

*/
void FASTCALL __glInvertTransposeMatrix(__GLmatrix *inverse, const __GLmatrix *src)
{
    __GLfloat x00, x01, x02;
    __GLfloat x10, x11, x12;
    __GLfloat x20, x21, x22;
    __GLfloat rcp;

#ifdef NT
  // The matrix type of the inverse transpose is not necessarily the
  // same as that of the input.  Always set it to general here to
  // be safe.  The type can be refined later if necessary.
  inverse->matrixType = __GL_MT_GENERAL;
  if (src->matrixType)
#else
  /* propagate matrix type & branch if general */
  if (inverse->matrixType = src->matrixType)
#endif
  {
    __GLfloat z00, z01, z02;
    __GLfloat z10, z11, z12;
    __GLfloat z20, z21, z22;

    /* read 3x3 matrix into registers */
    x00 = src->matrix[0][0];
    x01 = src->matrix[0][1];
    x02 = src->matrix[0][2];
    x10 = src->matrix[1][0];
    x11 = src->matrix[1][1];
    x12 = src->matrix[1][2];
    x20 = src->matrix[2][0];
    x21 = src->matrix[2][1];
    x22 = src->matrix[2][2];

    /* compute first three 2x2 cofactors */
    z20 = x01*x12 - x11*x02;
    z10 = x21*x02 - x01*x22;
    z00 = x11*x22 - x12*x21;

    /* compute 3x3 determinant & its reciprocal */
    rcp = x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
        return;
    rcp = (float)1/rcp;

    /* compute other six 2x2 cofactors */
    z01 = x20*x12 - x10*x22;
    z02 = x10*x21 - x20*x11;
    z11 = x00*x22 - x20*x02;
    z12 = x20*x01 - x00*x21;
    z21 = x10*x02 - x00*x12;
    z22 = x00*x11 - x10*x01;

    /* multiply all cofactors by reciprocal */
    inverse->matrix[0][0] = z00*rcp;
    inverse->matrix[0][1] = z01*rcp;
    inverse->matrix[0][2] = z02*rcp;
    inverse->matrix[1][0] = z10*rcp;
    inverse->matrix[1][1] = z11*rcp;
    inverse->matrix[1][2] = z12*rcp;
    inverse->matrix[2][0] = z20*rcp;
    inverse->matrix[2][1] = z21*rcp;
    inverse->matrix[2][2] = z22*rcp;

    /* read translation vector & negate */
    x00 = -src->matrix[3][0];
    x01 = -src->matrix[3][1];
    x02 = -src->matrix[3][2];

    /* store bottom row of inverse transpose */
    inverse->matrix[3][0] = 0;
    inverse->matrix[3][1] = 0;
    inverse->matrix[3][2] = 0;
    inverse->matrix[3][3] = 1;

    /* finish by tranforming translation vector */
    inverse->matrix[0][3] = inverse->matrix[0][0]*x00 +
			    inverse->matrix[0][1]*x01 +
			    inverse->matrix[0][2]*x02;
    inverse->matrix[1][3] = inverse->matrix[1][0]*x00 +
			    inverse->matrix[1][1]*x01 +
			    inverse->matrix[1][2]*x02;
    inverse->matrix[2][3] = inverse->matrix[2][0]*x00 +
			    inverse->matrix[2][1]*x01 +
			    inverse->matrix[2][2]*x02;

    if ((rcp <= ((float)1.0 + __GL_MATRIX_UNITY_SCALE_EPSILON)) &&
        (rcp >= ((float)1.0 - __GL_MATRIX_UNITY_SCALE_EPSILON))) {
        inverse->nonScaling = GL_TRUE;
    } else {
        inverse->nonScaling = GL_FALSE;
    }

  }
  else
  {
    __GLfloat x30, x31, x32;
    __GLfloat y01, y02, y03, y12, y13, y23;
    __GLfloat z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->matrix[0][0];
    x01 = src->matrix[0][1];
    x10 = src->matrix[1][0];
    x11 = src->matrix[1][1];
    x20 = src->matrix[2][0];
    x21 = src->matrix[2][1];
    x30 = src->matrix[3][0];
    x31 = src->matrix[3][1];

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->matrix[0][2];
    x03 = src->matrix[0][3];
    x12 = src->matrix[1][2];
    x13 = src->matrix[1][3];
    x22 = src->matrix[2][2];
    x23 = src->matrix[2][3];
    x32 = src->matrix[3][2];
    x33 = src->matrix[3][3];

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->matrix[0][0];
    x01 = src->matrix[0][1];
    x10 = src->matrix[1][0];
    x11 = src->matrix[1][1];
    x20 = src->matrix[2][0];
    x21 = src->matrix[2][1];
    x30 = src->matrix[3][0];
    x31 = src->matrix[3][1];

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
	return;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->matrix[0][0] = z00*rcp;
    inverse->matrix[0][1] = z01*rcp;
    inverse->matrix[1][0] = z10*rcp;
    inverse->matrix[0][2] = z02*rcp;
    inverse->matrix[2][0] = z20*rcp;
    inverse->matrix[0][3] = z03*rcp;
    inverse->matrix[3][0] = z30*rcp;
    inverse->matrix[1][1] = z11*rcp;
    inverse->matrix[1][2] = z12*rcp;
    inverse->matrix[2][1] = z21*rcp;
    inverse->matrix[1][3] = z13*rcp;
    inverse->matrix[3][1] = z31*rcp;
    inverse->matrix[2][2] = z22*rcp;
    inverse->matrix[2][3] = z23*rcp;
    inverse->matrix[3][2] = z32*rcp;
    inverse->matrix[3][3] = z33*rcp;

    if ((inverse->matrix[3][0] == __glZero) && 
        (inverse->matrix[3][1] == __glZero) &&
        (inverse->matrix[3][2] == __glZero)) {

        if (((rcp <= ((float)1.0 + __GL_MATRIX_UNITY_SCALE_EPSILON)) &&
            (rcp >= ((float)1.0 - __GL_MATRIX_UNITY_SCALE_EPSILON)))) {
            inverse->nonScaling = GL_TRUE;
        } else {
            inverse->nonScaling = GL_FALSE;
        }
        
    } else {
        inverse->nonScaling = GL_FALSE;        
    }
  }
}

/*
 * Find the 3x3 transpose of a matrix.  This is used to calculate the light
 * vector in object space for fast infinite lighting.
 */

void __glTranspose3x3(__GLmatrix *dst, __GLmatrix *src)
{

    __GLfloat x00, x01, x02;
    __GLfloat x10, x11, x12;
    __GLfloat x20, x21, x22;

    x00 = src->matrix[0][0];
    x01 = src->matrix[0][1];
    x02 = src->matrix[0][2];

    x10 = src->matrix[1][0];
    x11 = src->matrix[1][1];
    x12 = src->matrix[1][2];

    x20 = src->matrix[2][0];
    x21 = src->matrix[2][1];
    x22 = src->matrix[2][2];

    dst->matrix[0][0] = x00;
    dst->matrix[1][0] = x01;
    dst->matrix[2][0] = x02;
    dst->matrix[3][0] = __glZero;

    dst->matrix[0][1] = x10;
    dst->matrix[1][1] = x11;
    dst->matrix[2][1] = x12;
    dst->matrix[3][1] = __glZero;

    dst->matrix[0][2] = x20;
    dst->matrix[1][2] = x21;
    dst->matrix[2][2] = x22;
    dst->matrix[3][2] = __glZero;

    dst->matrix[0][3] = __glZero;
    dst->matrix[1][3] = __glZero;
    dst->matrix[2][3] = __glZero;
    dst->matrix[3][3] = __glOne;
}

#ifdef NT

/*
** Return the closest integer log based 2 of a number
*/

static GLubyte logTab[256] = { 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
                               4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
                               5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                               5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                               6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                               6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                               6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                               6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                               7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
};

GLint FASTCALL __glIntLog2(__GLfloat f)
{
    GLuint i = (GLuint) FTOL(f);

    if (i & 0xffff0000) {
        if (i & 0xff000000) {
            return ((GLint)logTab[i >> 24] + 24);
        } else {
            return ((GLint)logTab[i >> 16] + 16);
	}
    } else {
        if (i & 0xff00) {
            return ((GLint)logTab[i >> 8] + 8);
        } else {
            return ((GLint)logTab[i]);
        }
    }
}

#else

GLint __glIntLog2(__GLfloat f)
{
    return (GLint)(__GL_LOGF(f) * __GL_M_LN2_INV);
}

#endif

GLfloat FASTCALL __glClampf(GLfloat fval, __GLfloat zero, __GLfloat one)
{
    if (fval < zero) return zero;
    else if (fval > one) return one;
    else return fval;
}

/*
** r = vector from p1 to p2
*/
#ifndef __GL_ASM_VECSUB4
void FASTCALL __glVecSub4(__GLcoord *r,
                          const __GLcoord *p1, const __GLcoord *p2)
{
    __GLfloat oneOverW;

    if (p2->w == __glZero) {
	if (p1->w == __glZero) {
	    r->x = p2->x - p1->x;
	    r->y = p2->y - p1->y;
	    r->z = p2->z - p1->z;
	} else {
	    r->x = p2->x;
	    r->y = p2->y;
	    r->z = p2->z;
	}
    } else
    if (p1->w == __glZero) {
	r->x = -p1->x;
	r->y = -p1->y;
	r->z = -p1->z;
    } else{
	oneOverW = ((__GLfloat) 1.0) / p2->w;
	r->x = p2->x * oneOverW;
	r->y = p2->y * oneOverW;
	r->z = p2->z * oneOverW;
	oneOverW = ((__GLfloat) 1.0) / p1->w;
	r->x -= p1->x * oneOverW;
	r->y -= p1->y * oneOverW;
	r->z -= p1->z * oneOverW;
    }
}
#endif // !__GL_ASM_VECSUB4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_names.c ===
/*
** Copyright 1991, 1922, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list table management routines.
**
** $Revision: 1.3 $
** $Date: 1995/02/11 00:53:45 $
*/

#include "precomp.h"
#pragma hdrstop

#include <namesint.h>
#include "..\..\dlist\dlistint.h"

/************************************************************************/
/*
** The Name Space Management code is used to store and retreive named
** data structures.  The data being stored is referred to with void
** pointers to allow for the storage of any type of structure.
**
** Note that this code was developed for dlist name management.
** The bulk of it remains the same, but the semaphores for locking
** dlist access have been moved up one level.  The code that uses
** this module for name space management must enclose the calls
** to Names entry points with LOCK and UNLOCK statements.
*/
/************************************************************************/

/*----------------------------------------------------------------------*/
/*
** Internal data structures.  Not intended for consumption outside of
** this module.
*/
/*----------------------------------------------------------------------*/

/*
** The name space is implemented as a 2-3 tree.
** The depth of the tree is the same for
** the entire tree (so we always know once we reach that depth that the
** node found is a leaf).
**
** A 2-3 tree in a nutshell goes like this:
**
** Every node at the maximum depth is a leaf, all other nodes are branch
**   nodes and have 2 or 3 children.
**
** A new node can be inserted in O(depth) time and an old node can be deleted
**   in O(depth) time.  During this insertion or deletion, the tree is
**   automatically rebalanced.
**
**
** Hmmm.  Derrick Burns mentions splay trees.  They would probably work
** as well if not better, and might be easier to code.  Maybe later -- little
** point in re-writing working code.
**
** Leaf nodes are arrays of sequential display lists.  The typical tree will
** actually only be one node (since users will define a few sequential
** lists, all of which fit into one leaf node).
**
** The range of display lists stored in a leaf is indicated by "start" and
** "end" (inclusive).
**
** There are two varieties of leaves.  There are leaves which contain unused
** (but reserved) display lists.  They are unique in that "lists" will be
** NULL.  The other type of leaf contains display lists currently in use.
** "lists" will not be NULL for these leaves, and will point to an array
** containing the actual display lists.
**
** Leaves containing unused (but reserved) display lists are generated when
** the user calls glGenLists().
**
** As the user starts using these reserved lists, the leaf containing unused
** (reserved) lists is split into two (or sometimes three) leaves.  One of
** the leaves will contain the display list the user is currently using, and
** the other will contain the rest of the still unused display lists.
**
** When this split takes place, the new leaf (containing the "now used" display
** lists) will be sized to __GL_DLIST_MIN_ARRAY_BLOCK entries if possible
** (with one of the array entries being the new display list, and the other
** entries pointing to a NOP dummy display list).  As the user continues
** to define more and more display lists, the leaf containing a range
** of used display lists will continue to grow until it reaches a
** size of __GL_DLIST_MAX_ARRAY_BLOCK entries, at which point a new
** leaf will be created to hold additional lists.
*/

/*
** A leaf node.
** The data pointers are void so diffent types of data structures can
** be managed.  The dataInfo pointer points back to information needed
** to manage the specific data structure pointed to by a void pointer.
*/
struct __GLnamesLeafRec {
    __GLnamesBranch *parent;    /* parent node - must be first */
    GLuint start;               /* start of range */
    GLuint end;                 /* end of range */
    void **dataList;            /* array of ptrs to named data */
    __GLnamesArrayTypeInfo *dataInfo;   /* ptr to data type info */
};

/*
** A branch node.
** The section of the tree in children[0] has name values all <= low.
** The section in children[1] has values: low < value <= medium.
** The section in children[2] (if not NULL) has values > medium.
*/
struct __GLnamesBranchRec {
    __GLnamesBranch *parent;            /* parent node - must be first */
    GLuint low;                         /* children[0] all <= low */
    GLuint medium;                      /* children[1] all <= medium & > low */
    __GLnamesBranch *children[3];       /* children[2] all > medium */
};

/*----------------------------------------------------------------------*/
/*
** Name Space Manager internal routines.
*/
/*----------------------------------------------------------------------*/

/*
** Sets up a new names tree and returns a pointer to it.
*/
__GLnamesArray * FASTCALL __glNamesNewArray(__GLcontext *gc, __GLnamesArrayTypeInfo *dataInfo)
{
    __GLnamesArray *array;
    int i;

    array = (__GLnamesArray *) GCALLOC(gc, sizeof(__GLnamesArray));
    if (array == NULL) {
        __glSetError(GL_OUT_OF_MEMORY);
        return NULL;
    }

#ifdef NT
    __try
    {
        InitializeCriticalSection(&array->critsec);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        GCFREE(gc, array);
        __glSetError(GL_OUT_OF_MEMORY);
        return NULL;
    }
#endif

    array->refcount = 1;
    array->tree = NULL;
    array->depth = 0;
    array->dataInfo = dataInfo;
    /*
    ** Pre-allocate a few leaves and branches for paranoid OUT_OF_MEMORY
    ** reasons.
    */
    array->nbranches = __GL_DL_EXTRA_BRANCHES;
    array->nleaves = __GL_DL_EXTRA_LEAVES;
    for (i = 0; i < __GL_DL_EXTRA_BRANCHES; i++) {
        array->branches[i] = (__GLnamesBranch*)
                GCALLOC(gc, sizeof(__GLnamesBranch));
        if (array->branches[i] == NULL) {
            array->nbranches = i;
            break;
        }
    }
    for (i = 0; i < __GL_DL_EXTRA_LEAVES; i++) {
        array->leaves[i] = (__GLnamesLeaf*)
                GCALLOC(gc, sizeof(__GLnamesLeaf));
        if (array->leaves[i] == NULL) {
            array->nleaves = i;
            break;
        }
    }

    return array;
}

static void FASTCALL freeLeafData(__GLcontext *gc, void **dataList)
{
    /*
    ** Note that the actual data pointed to by the elements of this list
    ** have already been freed with the callback.
    */
    GCFREE(gc, dataList);
}


static void FASTCALL freeLeaf(__GLcontext *gc, __GLnamesLeaf *leaf)
{
    if (leaf->dataList) {
        freeLeafData(gc, leaf->dataList);
    }
    GCFREE(gc, leaf);
}


static void FASTCALL freeBranch(__GLcontext *gc, __GLnamesBranch *branch)
{
    GCFREE(gc, branch);
}


/*
** Free an entire names tree.
*/
void FASTCALL __glNamesFreeTree(__GLcontext *gc, __GLnamesArray *array,
                       __GLnamesBranch *tree, GLint depth)
{
    GLuint i;
    __GLnamesLeaf *leaf;
    void *empty;
    GLint maxdepth = array->depth;

    __GL_NAMES_ASSERT_LOCKED(array);

    if (tree == NULL) return;

    if (depth < maxdepth) {
        __glNamesFreeTree(gc, array, tree->children[2], depth+1);
        __glNamesFreeTree(gc, array, tree->children[1], depth+1);
        __glNamesFreeTree(gc, array, tree->children[0], depth+1);

        freeBranch(gc, tree);
    } else {
        leaf = (__GLnamesLeaf *) tree;
        empty = array->dataInfo->empty;

        if (leaf->dataList) {
            for (i=leaf->start; i<=leaf->end; i++) {
                if (leaf->dataList[i - leaf->start] != empty) {
                    ASSERTOPENGL(leaf->dataInfo->free != NULL,
                                 "No free function\n");
                    (*leaf->dataInfo->free)(gc,
                                leaf->dataList[i - leaf->start]);
                    leaf->dataList[i - leaf->start] = empty;
                }
            }
        }
        freeLeaf(gc, leaf);
    }
}

void FASTCALL __glNamesFreeArray(__GLcontext *gc, __GLnamesArray *array)
{
    GLuint i;

    __GL_NAMES_ASSERT_LOCKED(array);

    for (i = 0; i < array->nbranches; i++) {
        GCFREE(gc, array->branches[i]);
    }
    for (i = 0; i < array->nleaves; i++) {
        GCFREE(gc, array->leaves[i]);
    }

    __glNamesFreeTree(gc, array, array->tree, 0);

    __GL_NAMES_UNLOCK(array);
#ifdef NT
    DeleteCriticalSection(&array->critsec);
#endif

    GCFREE(gc, array);
}


/*
** Find the leaf with the given name.
** If exact is TRUE, then only the leaf that contains this name will
**   be returned (NULL, otherwise).
** If exact is FALSE, than the leaf containing the number will be returned
**   if it exists, and otherwise the next highest leaf will be returned.
**   A NULL value indicates that number is higher than any other leaves in
**   the tree.
** This routine has been tuned for the case of finding the number in
** the tree, since this is the most likely case when dispatching a
** display list.
*/
static __GLnamesLeaf * FASTCALL findLeaf(__GLnamesArray *array, GLuint number,
                                                GLint exact)
{
    __GLnamesBranch *branch;
    __GLnamesLeaf *leaf;
    int depth = array->depth, r;

    __GL_NAMES_ASSERT_LOCKED(array);

    branch = array->tree;

    while (depth > 0 && branch) {

        /* rather than following if-then-else code
         * for correct branch, evaluate all conditions
         * quickly to compute correct branch.
         */
        int r = (number > branch->low) + (number > branch->medium);
        ASSERTOPENGL(branch->low <= branch->medium,
                     "Branch ordering wrong\n");
        branch = branch->children[r];
        --depth;
    }
    if (!(leaf = (__GLnamesLeaf *) branch)) return NULL;

    /* the case we want to optimize is the one in which we
     * actually find the node, so evaluate both conditions
     * quickly, since both results are required in this case
     * and return appropriately.  the choice of the final
     * if construct is to match the current vagaries of the
     * 3.19 compiler code generator (db)
     */
    r = (leaf->end < number) | (exact&(number<leaf->start));
    if (!r) return leaf;
        return NULL;
}


/*
** Copy data from leaf->lists into newleaf->lists.
*/
static void FASTCALL copyLeafInfo(__GLnamesLeaf *leaf, __GLnamesLeaf *newleaf)
{
    GLint offset;
    GLuint number;
    GLuint i;

    number = newleaf->end - newleaf->start + 1;
    offset = newleaf->start - leaf->start;

    for (i = 0; i < number; i++) {
        newleaf->dataList[i] = leaf->dataList[i+offset];
    }
}

/*
** Attempt to fix a possible situation caused by lack of memory.
*/
static GLboolean FASTCALL fixMemoryProblem(__GLcontext *gc, __GLnamesArray *array)
{
    GLuint i;

    __GL_NAMES_ASSERT_LOCKED(array);

    for (i = array->nbranches; i < __GL_DL_EXTRA_BRANCHES; i++) {
        array->branches[i] = (__GLnamesBranch*)
            GCALLOC(gc, sizeof(__GLnamesBranch));
        if (array->branches[i] == NULL) {
            array->nbranches = i;
            return GL_FALSE;
        }
    }
    array->nbranches = __GL_DL_EXTRA_BRANCHES;
    for (i = array->nleaves; i < __GL_DL_EXTRA_LEAVES; i++) {
        array->leaves[i] = (__GLnamesLeaf*) GCALLOC(gc, sizeof(__GLnamesLeaf));
        if (array->leaves[i] == NULL) {
            array->nleaves = i;
            return GL_FALSE;
        }
    }
    array->nleaves = __GL_DL_EXTRA_LEAVES;
    return GL_TRUE;
}

/*
** Compute the maximum value contained in the given tree.  If
** curdepth == maxdepth, the tree is simply a leaf.
*/
static GLuint FASTCALL computeMax(__GLnamesBranch *branch, GLint curdepth,
                         GLint maxdepth)
{
    __GLnamesLeaf *leaf;

    while (curdepth < maxdepth) {
        if (branch->children[2] != NULL) {
            branch = branch->children[2];
        } else if (branch->children[1] != NULL) {
            return branch->medium;
        } else {
            return branch->low;
        }
        curdepth++;
    }
    leaf = (__GLnamesLeaf *) branch;
    return leaf->end;
}

/*
** Make sure that all parents of this child know that maxval is the
** highest value that can be found in this child.
*/
static void FASTCALL pushMaxVal(__GLnamesBranch *child, GLuint maxval)
{
    __GLnamesBranch *parent;

    while (parent = child->parent) {
        if (parent->children[0] == child) {
            parent->low = maxval;
            if (parent->children[1] != NULL) {
                return;
            }
        } else if (parent->children[1] == child) {
            parent->medium = maxval;
            if (parent->children[2] != NULL) {
                return;
            }
        } else {
            ASSERTOPENGL(parent->children[2] == child,
                         "Parent/child relationship incorrect\n");
        }
        child = parent;
    }
}

static GLboolean FASTCALL allocLeafData(__GLcontext *gc, __GLnamesLeaf *leaf)
{
    GLint number;
    GLint i;

    number = leaf->end - leaf->start + 1;
    leaf->dataList = (void **) GCALLOC(gc, (size_t)(sizeof(void *)*number));
    if (!leaf->dataList) return GL_FALSE;

    for (i=0; i < number; i++) {
        leaf->dataList[i] = leaf->dataInfo->empty;
    }
    return GL_TRUE;
}

static GLboolean FASTCALL reallocLeafData(__GLcontext *gc, __GLnamesLeaf *leaf)
{
    size_t number;
    void **answer;

    number = (size_t) (leaf->end - leaf->start + 1);
    answer = (void **) GCREALLOC(gc, leaf->dataList, sizeof(void *)*number);
    if (answer) {
        leaf->dataList = answer;
        return GL_TRUE;
    } else {
        /*
        ** Crud!  Out of memory!
        */
        return GL_FALSE;
    }
}

static __GLnamesLeaf * FASTCALL allocLeaf(__GLcontext *gc, __GLnamesArray *array)
{
    __GLnamesLeaf *leaf;

    leaf = (__GLnamesLeaf *) GCALLOC(gc, sizeof(__GLnamesLeaf));

    if (leaf == NULL) {
        /*
        ** Ouch!  No memory?  We had better use one of the preallocated
        ** leaves.
        */

        __GL_NAMES_ASSERT_LOCKED(array);

        ASSERTOPENGL(array->nleaves != 0,
                     "No preallocated leaves\n");
        array->nleaves--;
        leaf = array->leaves[array->nleaves];
    }

    leaf->parent = NULL;
    leaf->dataList = NULL;
    leaf->dataInfo = array->dataInfo;

    return leaf;
}


/*
** Allocates a branch node.
*/
static __GLnamesBranch * FASTCALL allocBranch(__GLcontext *gc, __GLnamesArray *array)
{
    __GLnamesBranch *branch;

    branch = (__GLnamesBranch *) GCALLOC(gc, sizeof(__GLnamesBranch));

    if (branch == NULL) {
        /*
        ** Ouch!  No memory?  We had better use one of the preallocated
        ** branches.
        */

        __GL_NAMES_ASSERT_LOCKED(array);

        ASSERTOPENGL(array->nbranches != 0,
                     "No preallocated branches\n");
        array->nbranches--;
        branch = array->branches[array->nbranches];
    }

    branch->children[0] = branch->children[1] = branch->children[2] = NULL;
    branch->parent = NULL;

    return branch;
}

/*
** Remove the child from the parent.  depth refers to the parent.
** This deletion may delete a child from a parent with only two children.
** If so, the parent itself will soon be deleted, of course.
*/
static void FASTCALL deleteChild(__GLnamesArray *array, __GLnamesBranch *parent,
                        __GLnamesBranch *child, GLint depth)
{
    GLuint maxval;
    GLint maxdepth;

    __GL_NAMES_ASSERT_LOCKED(array);

    maxdepth = array->depth;

    if (parent->children[0] == child) {
        parent->children[0] = parent->children[1];
        parent->children[1] = parent->children[2];
        parent->children[2] = NULL;
        parent->low = parent->medium;
        if (parent->children[1] != NULL) {
            maxval = computeMax(parent->children[1], depth+1, maxdepth);
            parent->medium = maxval;
        } else parent->medium = 0;
    } else if (parent->children[1] == child) {
        parent->children[1] = parent->children[2];
        parent->children[2] = NULL;
        if (parent->children[1] != NULL) {
            maxval = computeMax(parent->children[1], depth+1, maxdepth);
            parent->medium = maxval;
        } else parent->medium = 0;
    } else {
        ASSERTOPENGL(parent->children[2] == child,
                     "Parent/child relationship wrong\n");
        parent->children[2] = NULL;
        pushMaxVal(parent, parent->medium);
    }
}

/*
** Add child to parent.  child is a leaf if curdepth == maxdepth - 1
** (curdepth refers to the depth of the parent, not the child).  Parent
** only has one or two children (thus has room for another child).
*/
static void FASTCALL addChild(__GLnamesBranch *parent, __GLnamesBranch *child,
                     GLint curdepth, GLint maxdepth)
{
    GLuint maxval;

    maxval = computeMax(child, curdepth+1, maxdepth);

    child->parent = parent;
    if (maxval > parent->medium && parent->children[1] != NULL) {
        /* This becomes the third child */
        parent->children[2] = child;

        /* Propagate the maximum value for this child to its parents */
        pushMaxVal(parent, maxval);
    } else if (maxval > parent->low) {
        /* This becomes the second child */
        parent->children[2] = parent->children[1];
        parent->children[1] = child;
        parent->medium = maxval;

        if (parent->children[2] == NULL) {
            pushMaxVal(parent, maxval);
        }
    } else {
        parent->children[2] = parent->children[1];
        parent->children[1] = parent->children[0];
        parent->children[0] = child;
        parent->medium = parent->low;
        parent->low = maxval;
    }
}

/*
** From the three children in parent, and the extraChild, build two parents:
** parent and newParent.  curdepth refers to the depth of parent.  parent
** is part of the tree, so its maxval needs to be propagated up if it
** changes.
*/
static void FASTCALL splitParent(__GLnamesBranch *parent,
                                __GLnamesBranch *newParent,
                                __GLnamesBranch *extraChild,
                                GLint curdepth,
                                GLint maxdepth)
{
    __GLnamesBranch *children[4], *tempchild;
    GLuint maxvals[4], tempval;
    int i;

    /* Collect our four children */
    children[0] = parent->children[0];
    maxvals[0] = parent->low;
    children[1] = parent->children[1];
    maxvals[1] = parent->medium;
    children[2] = parent->children[2];
    maxvals[2] = computeMax(children[2], curdepth+1, maxdepth);
    children[3] = extraChild;
    maxvals[3] = computeMax(extraChild, curdepth+1, maxdepth);

    /* Children 0-2 are sorted.  Sort child 3 too. */
    for (i = 3; i > 0; i--) {
        if (maxvals[i] < maxvals[i-1]) {
            tempval = maxvals[i];
            tempchild = children[i];
            maxvals[i] = maxvals[i-1];
            children[i] = children[i-1];
            maxvals[i-1] = tempval;
            children[i-1] = tempchild;
        }
    }

    /* Construct the two parents */
    parent->low = maxvals[0];
    parent->children[0] = children[0];
    parent->medium = maxvals[1];
    parent->children[1] = children[1];
    parent->children[2] = NULL;
    children[0]->parent = parent;
    children[1]->parent = parent;
    pushMaxVal(parent, maxvals[1]);

    newParent->low = maxvals[2];
    newParent->children[0] = children[2];
    newParent->medium = maxvals[3];
    newParent->children[1] = children[3];
    newParent->children[2] = NULL;
    children[2]->parent = newParent;
    children[3]->parent = newParent;
}

/*
** Build a parent from child1 and child2.  depth tells the depth of
** the trees pointed to by child1 and child2.
*/
static void FASTCALL buildParent(__GLnamesBranch *parent, __GLnamesBranch *child1,
                        __GLnamesBranch *child2, GLint depth)
{
    GLuint maxChild1, maxChild2;

    child1->parent = parent;
    child2->parent = parent;
    maxChild1 = computeMax(child1, 0, depth);
    maxChild2 = computeMax(child2, 0, depth);
    if (maxChild2 > maxChild1) {
        parent->children[0] = child1;
        parent->low = maxChild1;
        parent->children[1] = child2;
        parent->medium = maxChild2;
    } else {
        parent->children[0] = child2;
        parent->low = maxChild2;
        parent->children[1] = child1;
        parent->medium = maxChild1;
    }
}

/*
** Insert the new leaf into the tree.
*/
static void FASTCALL insertLeaf(__GLcontext *gc, __GLnamesArray *array,
                                __GLnamesLeaf *leaf)
{
    __GLnamesBranch *extraChild;
    __GLnamesBranch *branch;
    __GLnamesBranch *parent;
    __GLnamesBranch *newParent;
    GLint maxdepth, curdepth;
    GLuint number;

    __GL_NAMES_ASSERT_LOCKED(array);

    number = leaf->end;
    maxdepth = array->depth;
    branch = array->tree;
    if (!branch) {
        /* No tree!  Make a one leaf tree. */
        array->depth = 0;
        array->tree = (__GLnamesBranch *) leaf;
        return;
    }

    curdepth = 0;
    while (curdepth < maxdepth) {
        if (number <= branch->low) {
            branch = branch->children[0];
        } else if (number <= branch->medium) {
            branch = branch->children[1];
        } else {
            if (branch->children[2] != NULL) {
                branch = branch->children[2];
            } else {
                branch = branch->children[1];
            }
        }
        curdepth++;
    }

    /*
    ** Ok, we just managed to work our way to the bottom of the tree.
    ** 'leaf' becomes the extraChild, and we now try to insert it anywhere
    ** it will fit.
    */
    extraChild = (__GLnamesBranch *) leaf;
    parent = branch->parent;

    curdepth--;
    while (parent) {
        if (parent->children[2] == NULL) {
            /* We have room to squeeze this node in here! */
            addChild(parent, extraChild, curdepth, maxdepth);
            return;
        }

        /*
        ** We have one parent and four children.  This simply
        ** won't do.  We create a new parent, and end up with two
        ** parents with two children each.  That works.
        */
        newParent = allocBranch(gc, array);
        splitParent(parent, newParent, extraChild, curdepth, maxdepth);

        /*
        ** Great.  Now newParent becomes the orphan, and we try to
        ** trivially insert it up a level.
        */
        extraChild = newParent;
        branch = parent;
        parent = branch->parent;
        curdepth--;
    }

    /* We just reached the top node, and there is no parent, and we
    ** still haven't managed to rid ourselves of an extra child.  So,
    ** we make a new parent to take branch and extraChild as it's two
    ** children.  We have to increase the depth of the tree, of course.
    */
    ASSERTOPENGL(curdepth == -1, "Wrong depth at top\n");
    parent = allocBranch(gc, array);
    buildParent(parent, branch, extraChild, maxdepth);
    array->tree = parent;
    array->depth++;
}

/*
** Delete the given leaf from the tree.  The leaf itself is not
** freed or anything, so the calling procedure needs to worry about it.
*/
static void FASTCALL deleteLeaf(__GLcontext *gc, __GLnamesArray *array,
                                __GLnamesLeaf *leaf)
{
    __GLnamesBranch *orphan;
    __GLnamesBranch *parent, *newParent;
    __GLnamesBranch *grandparent;
    GLint depth, maxdepth;
    GLuint maxval;

    __GL_NAMES_ASSERT_LOCKED(array);

    maxdepth = depth = array->depth;
    parent = leaf->parent;
    if (parent == NULL) {
        /* Ack!  We just nuked the only node! */
        array->tree = NULL;
        return;
    }

    deleteChild(array, parent, (__GLnamesBranch *) leaf, depth-1);

    /*
    ** depth is the depth of the child in this case.
    */
    depth--;
    while (parent->children[1] == NULL) {
        /* Crud.  Need to do work. */
        orphan = parent->children[0];

        /* Ax the parent, insert child into grandparent. */
        grandparent = parent->parent;

        if (grandparent == NULL) {
            /*
            ** Hmmm.  Parent was the root.  Nuke it and make the orphan
            ** the new root.
            */
            freeBranch(gc, parent);
            array->tree = orphan;
            orphan->parent = NULL;
            array->depth--;
            return;
        }

        deleteChild(array, grandparent, parent, depth-1);
        freeBranch(gc, parent);

        /* The parent is dead.  Find a new parent. */
        maxval = computeMax(orphan, depth+1, maxdepth);
        if (grandparent->children[1] == NULL ||
                maxval <= grandparent->low) {
            parent = grandparent->children[0];
        } else {
            parent = grandparent->children[1];
        }

        /* Insert orphan into new parent. */
        if (parent->children[2] != NULL) {
            newParent = allocBranch(gc, array);
            splitParent(parent, newParent, orphan, depth, maxdepth);
            /* We know there is room! */
            addChild(grandparent, newParent, depth-1, maxdepth);
            return;
        }

        /* The parent has room for the child */
        addChild(parent, orphan, depth, maxdepth);

        depth--;
        parent = grandparent;
    }
}

/*
** Shrink the leaf by adjusting start and end.
** If necessary, call pushMaxVal() to notify the database about the change.
** Also fix up the lists pointer if necessary.
*/
static void FASTCALL resizeLeaf(__GLcontext *gc, __GLnamesLeaf *leaf,
                                GLuint newstart, GLuint newend)
{
    GLuint oldstart, oldend;
    GLuint newsize, offset, i;

    oldstart = leaf->start;
    oldend = leaf->end;

    leaf->start = newstart;
    if (newend != oldend) {
        leaf->end = newend;
        pushMaxVal((__GLnamesBranch *) leaf, newend);
    }
    if (leaf->dataList == NULL) return;

    /*
    ** Copy the appropriate pointers to the begining of the array, and
    ** realloc it.
    */
    offset = newstart - oldstart;
    newsize = newend - newstart + 1;
    if (offset) {
        for (i=0; i<newsize; i++) {
            /*
            ** Copy the whole structure with one line.
            */
            leaf->dataList[i] = leaf->dataList[i+offset];
        }
    }
    reallocLeafData(gc, leaf);
}

/*
** Find the previous leaf (before "leaf") in the tree.
*/
static __GLnamesLeaf * FASTCALL prevLeaf(__GLnamesLeaf *leaf)
{
    __GLnamesBranch *branch, *child;
    GLint reldepth;

    branch = leaf->parent;
    if (!branch) return NULL;           /* A one leaf tree! */

    child = (__GLnamesBranch *) leaf;

    /* We start off at a relative depth of 1 above the child (-1) */
    reldepth = -1;

    while (branch) {
        /* If the child was the 3rd child, branch down to the second. */
        if (branch->children[2] == child) {
            branch = branch->children[1];
            reldepth++;         /* One level lower */
            break;
        } else if (branch->children[1] == child) {
            /* If the child was the 2nd child, branch down to the first */
            branch = branch->children[0];
            reldepth++;         /* One level lower */
            break;
        } else {
            /* Must have been 1st child */
            ASSERTOPENGL(branch->children[0] == child,
                         "Parent/child relationship wrong\n");
        }
        /*
        ** Otherwise, we have already visited all of this branch's children,
        ** so we go up a level.
        */
        child = branch;
        branch = branch->parent;
        reldepth--;     /* One level higher */
    }
    if (!branch) return NULL;   /* All leaves visited! */

    /* Go down the 'right'most trail of this branch until we get to
    ** a child, then return it.
    */
    while (reldepth) {
        if (branch->children[2] != NULL) {
            branch = branch->children[2];
        } else if (branch->children[1] != NULL) {
            branch = branch->children[1];
        } else {
            branch = branch->children[0];
        }
        reldepth++;             /* One level lower */
    }

    return (__GLnamesLeaf *) branch;
}

/*
** Find the first leaf in the tree.
*/
static __GLnamesLeaf * FASTCALL firstLeaf(__GLnamesArray *array)
{
    __GLnamesBranch *branch;
    GLint maxdepth, curdepth;

    __GL_NAMES_ASSERT_LOCKED(array);

    maxdepth = array->depth;
    curdepth = 0;
    branch = array->tree;

    /* No tree, no leaves! */
    if (!branch) return NULL;

    /* Take the 'left'most branch until we reach a leaf */
    while (curdepth != maxdepth) {
        branch = branch->children[0];
        curdepth++;
    }
    return (__GLnamesLeaf *) branch;
}

/*
** Find the next leaf (after "leaf") in the tree.
*/
static __GLnamesLeaf * FASTCALL nextLeaf(__GLnamesLeaf *leaf)
{
    __GLnamesBranch *branch, *child;
    GLint reldepth;

    branch = leaf->parent;
    if (!branch) return NULL;           /* A one leaf tree! */

    child = (__GLnamesBranch *) leaf;

    /* We start off at a relative depth of 1 above the child (-1) */
    reldepth = -1;

    while (branch) {
        /* If the child was the 1st child, branch down to the second. */
        if (branch->children[0] == child) {
            branch = branch->children[1];
            reldepth++;         /* One level lower */
            break;
        } else if (branch->children[1] == child) {
            /*
            ** If the child was the 2nd child, and there is a third, branch
            ** down to it.
            */
            if (branch->children[2] != NULL) {
                branch = branch->children[2];
                reldepth++;     /* One level lower */
                break;
            }
        } else {
            /* Must have been 3rd child */
            ASSERTOPENGL(branch->children[2] == child,
                         "Parent/child relationship wrong\n");
        }
        /*
        ** Otherwise, we have already visited all of this branch's children,
        ** so we go up a level.
        */
        child = branch;
        branch = branch->parent;
        reldepth--;     /* One level higher */
    }
    if (!branch) return NULL;   /* All leaves visited! */

    /* Go down the 'left'most trail of this branch until we get to
    ** a child, then return it.
    */
    while (reldepth) {
        branch = branch->children[0];
        reldepth++;             /* One level lower */
    }

    return (__GLnamesLeaf *) branch;
}

/*
** Merge leaf2 into leaf1, and free leaf2.
** Need to pushMaxVal on the new leaf.
** We can assume that leaf1 and leaf2 are fit for merging.
** The return value is GL_TRUE if we did it.
*/
static GLboolean FASTCALL mergeLeaves(__GLcontext *gc, __GLnamesLeaf *leaf1,
                             __GLnamesLeaf *leaf2)
{
    GLuint end;
    GLuint i;
    GLuint number, offset;

    /* If we don't have to merge lists, it is easy. */
    if (leaf1->dataList == NULL) {
        ASSERTOPENGL(leaf2->dataList == NULL, "Data already exists\n");
        if (leaf1->start < leaf2->start) {
            leaf1->end = leaf2->end;
            pushMaxVal((__GLnamesBranch *) leaf1, leaf1->end);
        } else {
            leaf1->start = leaf2->start;
        }
        freeLeaf(gc, leaf2);
        return GL_TRUE;
    }

    /*
    ** Yick!  Need to merge lists.
    */
    ASSERTOPENGL(leaf2->dataList != NULL, "No data\n");
    if (leaf1->start < leaf2->start) {
        /*
        ** Expand size of leaf1's array, copy leaf2's array into it,
        ** free leaf2.
        */
        offset = leaf1->end - leaf1->start + 1;
        number = leaf2->end - leaf2->start + 1;
        end = leaf1->end;
        leaf1->end = leaf2->end;
        if (!reallocLeafData(gc, leaf1)) {
            /*
            ** Heavens!  No memory?  That sucks!
            ** We won't bother merging.  It is never an absolutely critical
            ** operation.
            */
            leaf1->end = end;
            return GL_FALSE;
        }
        for (i = 0; i < number; i++) {
            leaf1->dataList[i+offset] = leaf2->dataList[i];
        }

        freeLeaf(gc, leaf2);

        pushMaxVal((__GLnamesBranch *) leaf1, leaf1->end);
    } else {
        /*
        ** Expand the size of leaf2's array, copy leaf1's array into it.
        ** Then free leaf1's array, copy leaf2's array to leaf1, and free
        ** leaf2.
        */
        offset = leaf2->end - leaf2->start + 1;
        number = leaf1->end - leaf1->start + 1;
        end = leaf2->end;
        leaf2->end = leaf1->end;
        if (!reallocLeafData(gc, leaf2)) {
            /*
            ** Heavens!  No memory?  That sucks!
            ** We won't bother merging.  It is never an absolutely critical
            ** operation.
            */
            leaf2->end = end;
            return GL_FALSE;
        }
        for (i = 0; i < number; i++) {
            leaf2->dataList[i+offset] = leaf1->dataList[i];
        }

        freeLeafData(gc, leaf1->dataList);
        leaf1->start = leaf2->start;

        leaf1->dataList = leaf2->dataList;
        leaf2->dataList = NULL;
        freeLeaf(gc, leaf2);
    }
    return GL_TRUE;
}

/*
** Check if this leaf can merge with any neighbors, and if so, do it.
*/
static void FASTCALL mergeLeaf(__GLcontext *gc, __GLnamesArray *array,
                                __GLnamesLeaf *leaf)
{
    __GLnamesLeaf *next, *prev;

    __GL_NAMES_ASSERT_LOCKED(array);

    next = nextLeaf(leaf);
    if (next) {
        /* Try to merge with next leaf */
        if (leaf->end + 1 == next->start) {
            if ((leaf->dataList == NULL && next->dataList == NULL) ||
                    (next->dataList && leaf->dataList &&
                    next->end - leaf->start < (GLuint) __GL_DLIST_MAX_ARRAY_BLOCK)) {
                /* It's legal to merge these leaves */
                deleteLeaf(gc, array, next);
                if (!mergeLeaves(gc, leaf, next)) {
                    /*
                    ** Ack!  No memory?  We bail on the merge.
                    */
                    insertLeaf(gc, array, next);
                    return;
                }
            }
        }
    }

    prev = prevLeaf(leaf);
    if (prev) {
        /* Try to merge with prev leaf */
        if (prev->end + 1 == leaf->start) {
            if ((prev->dataList == NULL && leaf->dataList == NULL) ||
                    (leaf->dataList && prev->dataList &&
                    leaf->end - prev->start < (GLuint) __GL_DLIST_MAX_ARRAY_BLOCK)) {
                /* It's legal to merge these leaves */
                deleteLeaf(gc, array, prev);
                if (!mergeLeaves(gc, leaf, prev)) {
                    /*
                    ** Ack!  No memory?  We bail on the merge.
                    */
                    insertLeaf(gc, array, prev);
                    return;
                }
            }
        }
    }
}

GLboolean FASTCALL __glNamesNewData(__GLcontext *gc, __GLnamesArray *array,
                                GLuint name, void *data)
{
    __GLnamesLeaf *leaf, *newleaf;
    GLint entry;
    GLuint start, end;

    __GL_NAMES_LOCK(array);

    leaf = findLeaf(array, name, GL_TRUE);

    /*
    ** First we check for possible memory problems, since it will be
    ** difficult to back out once we start.
    */
    if (leaf == NULL || leaf->dataList == NULL) {
        /*
        ** May need memory in these cases.
        */
        if (array->nbranches != __GL_DL_EXTRA_BRANCHES ||
                array->nleaves != __GL_DL_EXTRA_LEAVES) {
            if (!fixMemoryProblem(gc, array)) {
                __GL_NAMES_UNLOCK(array);
                __glSetError(GL_OUT_OF_MEMORY);
                return GL_FALSE;
            }
        }
    }

    if (!leaf) {
        /*
        ** Make new leaf with just this display list
        */
        leaf = allocLeaf(gc, array);
        leaf->start = leaf->end = name;
        if (data) {
            if (!allocLeafData(gc, leaf)) {
                /*
                ** Bummer.  No new list for you!
                */
                freeLeaf(gc, leaf);
                __GL_NAMES_UNLOCK(array);
                __glSetError(GL_OUT_OF_MEMORY);
                return GL_FALSE;
            }
            leaf->dataList[0] = data;
            (*(GLint *)data) = 1;               /* set the refcount */
        }
        insertLeaf(gc, array, leaf);
        mergeLeaf(gc, array, leaf);
        __GL_NAMES_UNLOCK(array);
        return GL_TRUE;
    } else if (leaf->dataList) {
        /*
        ** Simply update the appropriate entry in the lists array
        */
        entry = name - leaf->start;
        if (leaf->dataList[entry] != leaf->dataInfo->empty) {
            ASSERTOPENGL(leaf->dataInfo->free != NULL,
                         "No free function\n");
            (*leaf->dataInfo->free)(gc, leaf->dataList[entry]);
            leaf->dataList[entry] = leaf->dataInfo->empty;
        }
        if (data) {
            leaf->dataList[entry] = data;
            (*(GLint *)data) = 1;               /* set the refcount */
        }
        __GL_NAMES_UNLOCK(array);
        return GL_TRUE;
    } else {
        if (!data) {
            /*
            ** If there isn't really any list, we are done.
            */
            __GL_NAMES_UNLOCK(array);
            return GL_TRUE;
        }

        /*
        ** Allocate some or all of the lists in leaf.  If only some, then
        ** leaf needs to be split into two or three leaves.
        **
        ** First we decide what range of numbers to allocate an array for.
        ** (be careful of possible word wrap error)
        */
        start = name - __GL_DLIST_MIN_ARRAY_BLOCK/2;
        if (start < leaf->start || start > name) {
            start = leaf->start;
        }
        end = start + __GL_DLIST_MIN_ARRAY_BLOCK - 1;
        if (end > leaf->end || end < start) {
            end = leaf->end;
        }

        if (start - leaf->start < (GLuint) __GL_DLIST_MIN_ARRAY_BLOCK) {
            start = leaf->start;
        }
        if (leaf->end - end < (GLuint) __GL_DLIST_MIN_ARRAY_BLOCK) {
            end = leaf->end;
        }

        if (start == leaf->start) {
            if (end == leaf->end) {
                /*
                ** Simply allocate the entire array.
                */
                if (!allocLeafData(gc, leaf)) {
                    /*
                    ** Whoa!  No memory!  Never mind!
                    */
                    __glSetError(GL_OUT_OF_MEMORY);
                    __GL_NAMES_UNLOCK(array);
                    return GL_FALSE;
                }
                {
                    GLint entry = name - leaf->start;
                    leaf->dataList[entry] = data;
                    (*(GLint *)data) = 1;               /* set the refcount */
                }
                mergeLeaf(gc, array, leaf);
                __GL_NAMES_UNLOCK(array);
                return GL_TRUE;
            } else {
                /*
                ** Shrink the existing leaf, and create a new one to hold
                ** the new arrays (done outside the "if" statement).
                */
                resizeLeaf(gc, leaf, end+1, leaf->end);
            }
        } else if (end == leaf->end) {
            /*
            ** Shrink the existing leaf, and create a new one to hold
            ** the new arrays (done outside the "if" statement).
            */
            resizeLeaf(gc, leaf, leaf->start, start-1);
        } else {
            /*
            ** Crud.  The middle of the leaf was deleted.  This is tough.
            */
            newleaf = allocLeaf(gc, array);

            newleaf->start = end+1;
            newleaf->end = leaf->end;
            resizeLeaf(gc, leaf, leaf->start, start-1);
            insertLeaf(gc, array, newleaf);
        }
        leaf = allocLeaf(gc, array);
        leaf->start = start;
        leaf->end = end;
        if (!allocLeafData(gc, leaf)) {
            /*
            ** Whoa!  No memory!  Never mind!
            */
            insertLeaf(gc, array, leaf);
            mergeLeaf(gc, array, leaf);
            __glSetError(GL_OUT_OF_MEMORY);
            __GL_NAMES_UNLOCK(array);
            return GL_FALSE;
        }
        {
            GLint entry = name - leaf->start;
            leaf->dataList[entry] = data;
            (*(GLint *)data) = 1;               /* set the refcount */
        }
        insertLeaf(gc, array, leaf);
        mergeLeaf(gc, array, leaf);
        __GL_NAMES_UNLOCK(array);
        return GL_TRUE;
    }
}


/*
** Lock the named data.  Locking data both looks the data up,
** and guarantees that another thread will not delete the data out from
** under us.  This data will be unlocked with __glNamesUnlockData().
**
** A return value of NULL indicates that no data with the specified name
** was found.
*/
void * FASTCALL __glNamesLockData(__GLcontext *gc, __GLnamesArray *array,
                        GLuint name)
{
    __GLnamesLeaf *leaf;
    void *data;
    GLint offset;

    __GL_NAMES_LOCK(array);

    /*
    ** Lock access to data.
    */
    leaf = findLeaf(array, name, GL_TRUE);
    if (leaf == NULL || leaf->dataList == NULL) {
        __GL_NAMES_UNLOCK(array);
        return NULL;
    }
    offset = name - leaf->start;
    data = leaf->dataList[offset];
    if (data) {
        (*(GLint *)data)++;             /* Increment the refcount. */
    }
    __GL_NAMES_UNLOCK(array);
    return data;
}


/*
** Lock all of the data in the user's names array.  Locking data
** both looks the data up, and guarantees that another thread will not
** delete the data out from under us.  These data structs will be unlocked
** with __glNamesUnlockDataList().
**
** All entries of the array are guaranteed to be non-NULL.  This is
** accomplished by sticking an empty data structure in those slots where
** no data was set.
*/
void FASTCALL __glNamesLockDataList(__GLcontext *gc, __GLnamesArray *array,
                        GLsizei n, GLenum type, GLuint base,
                        const GLvoid *names, void *dataPtrs[])
{
    __GLnamesLeaf *leaf;
    void **data;
    void *tempData;
    void *empty;
    GLuint curName;

    __GL_NAMES_LOCK(array);

    empty = array->dataInfo->empty;

    data = dataPtrs;

    /*
    ** Note that this code is designed to take advantage of coherence.
    ** After looking up (and locking) a single display list in
    ** listnums[], the next list is checked for in the same leaf that
    ** contained the previous.  This will make typical uses of CallLists()
    ** quite fast (text, for example).
    */

    /*
    ** Lock access to array.
    */
    switch(type) {
      case GL_BYTE:
        /*
        ** Coded poorly for optimization purposes
        */
        {
            const GLbyte *p = (const GLbyte *) names;

Bstart:
            if (--n >= 0) {
                /* Optimization for possibly common font case */
                curName = base + *p++;
Bfind:
                leaf = findLeaf(array, curName, GL_TRUE);
                if (leaf && leaf->dataList) {
                    GLint reldiff;
                    GLuint relend;
                    void **leafData;

                    leafData = leaf->dataList;
                    tempData = leafData[curName - leaf->start];

                    /* All possible display lists can be found here */
                    reldiff = base - leaf->start;
                    relend = leaf->end - leaf->start;

Bsave:
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                    if (--n >= 0) {
                        curName = *p++ + reldiff;
                        if (curName <= relend) {
                            tempData = leafData[curName];
                            goto Bsave;
                        }
                        curName = curName + leaf->start;
                        goto Bfind;
                    }
                } else {
                    (*(GLint *)empty)++;                /* increment refcount */
                    *data++ = empty;
                    goto Bstart;
                }
            }
        }
        break;
      case GL_UNSIGNED_BYTE:
        /*
        ** Coded poorly for optimization purposes
        */
        {
            const GLubyte *p = (const GLubyte *) names;

UBstart:
            if (--n >= 0) {
                /* Optimization for possibly common font case */
                curName = base + *p++;
UBfind:
                leaf = findLeaf(array, curName, GL_TRUE);
                if (leaf && leaf->dataList) {
                    GLint reldiff;
                    GLuint relend;
                    void **leafData;

                    leafData = leaf->dataList;
                    tempData = leafData[curName - leaf->start];

                    /* All possible display lists can be found here */
                    reldiff = base - leaf->start;
                    relend = leaf->end - leaf->start;

UBsave:
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                    if (--n >= 0) {
                        curName = *p++ + reldiff;
                        if (curName <= relend) {
                            tempData = leafData[curName];
                            goto UBsave;
                        }
                        curName = curName + leaf->start;
                        goto UBfind;
                    }
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                    goto UBstart;
                }
            }
        }
        break;
      case GL_SHORT:
        {
            const GLshort *p = (const GLshort *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + *p++;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_UNSIGNED_SHORT:
        {
            const GLushort *p = (const GLushort *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + *p++;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_INT:
        {
            const GLint *p = (const GLint *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + *p++;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_UNSIGNED_INT:
        {
            const GLuint *p = (const GLuint *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + *p++;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_FLOAT:
        {
            const GLfloat *p = (const GLfloat *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + *p++;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_2_BYTES:
        {
            const GLubyte *p = (const GLubyte *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + ((p[0] << 8) | p[1]);
                p += 2;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_3_BYTES:
        {
            const GLubyte *p = (const GLubyte *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + ((p[0] << 16) | (p[1] << 8) | p[2]);
                p += 3;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      case GL_4_BYTES:
        {
            const GLubyte *p = (const GLubyte *) names;
            leaf = NULL;
            while (--n >= 0) {
                curName = base + ((p[0] << 24) | (p[1] << 16) |
                        (p[2] << 8) | p[3]);
                p += 4;
                if (leaf==NULL || curName<leaf->start || curName>leaf->end) {
                    leaf = findLeaf(array, curName, GL_TRUE);
                }
                if (leaf && leaf->dataList) {
                    tempData = leaf->dataList[curName - leaf->start];
                    (*(GLint *)tempData)++;     /* increment the refcount */
                    *data++ = tempData;
                } else {
                    (*(GLint *)empty)++;        /* increment refcount */
                    *data++ = empty;
                }
            }
        }
        break;
      default:
        /* This should be impossible */
        ASSERTOPENGL(FALSE, "Default hit\n");
    }

    __GL_NAMES_UNLOCK(array);
}

/*
** Unlocks data that was previously locked with __glNamesLockData().
*/
void FASTCALL __glNamesUnlockData(__GLcontext *gc, void *data,
                                  __GLnamesCleanupFunc cleanup)
{
    GLint *pRefcount;
    ASSERTOPENGL(data, "No data to unlock\n");

    pRefcount = data;
    (*pRefcount)--;             /* decrement the refcount */
    ASSERTOPENGL(*pRefcount >= 0, "Invalid refcount\n");
    if (*pRefcount == 0) {
        /*
        ** We are the last person to see this list alive.  Free it.
        */
       (*cleanup)(gc, data);
    }
}



/*
** Unlocks an array of named data that was previously locked with
** __glNamesLockDataList().
*/
void FASTCALL __glNamesUnlockDataList(__GLcontext *gc, GLsizei n,
                                      void *dataList[],
                                      __GLnamesCleanupFunc cleanup)
{
    GLint i;
    GLint *pRefcount;

    /*
    ** The refcount comes first in all data definitions, so the
    ** data pointer also points to the refcount.
    */
    for (i = 0; i < n; i++) {
        pRefcount = (GLint *)(dataList[i]);
        (*pRefcount) --;                        /* decrement the refcount */
        ASSERTOPENGL(*pRefcount >= 0, "Invalid refcount\n");
        if (*pRefcount == 0) {
            /*
            ** We are the last person to see this list alive.  Free it.
            */
            (*cleanup)(gc, (void *)pRefcount);
        }
    }
}


GLuint FASTCALL __glNamesGenRange(__GLcontext *gc, __GLnamesArray *array,
                         GLsizei range)
{
    GLuint lastUsed;
    GLuint nextUsed;
    GLuint maxUsed;
    __GLnamesLeaf *leaf;
    __GLnamesLeaf *nextleaf;
    __GLnamesLeaf *newleaf;

    __GL_NAMES_LOCK(array);

    /*
    ** First we check for possible memory problems, since it will be
    ** difficult to back out once we start.
    */
    if (array->nbranches != __GL_DL_EXTRA_BRANCHES ||
            array->nleaves != __GL_DL_EXTRA_LEAVES) {
        if (!fixMemoryProblem(gc, array)) {
            __GL_NAMES_UNLOCK(array);
            __glSetError(GL_OUT_OF_MEMORY);
            return 0;
        }
    }

    leaf = firstLeaf(array);

    /*
    ** Can we possibly allocate the appropriate number before the first leaf?
    */
    if (leaf && leaf->start > (GLuint)range) {
        if (leaf->dataList == NULL) {
            /*
            ** Ha!  We can trivially extend leaf!
            */
            leaf->start -= range;
            __GL_NAMES_UNLOCK(array);
            return leaf->start;
        } else {
            /*
            ** Must make a new leaf
            */
            newleaf = allocLeaf(gc, array);

            newleaf->start = 1;
            newleaf->end = range;
            insertLeaf(gc, array, newleaf);

            __GL_NAMES_UNLOCK(array);
            return 1;
        }
    }

    while (leaf) {
        nextleaf = nextLeaf(leaf);
        if (!nextleaf) break;

        lastUsed = leaf->end + 1;
        nextUsed = nextleaf->start;

        /* Room for (lastUsed) - (nextUsed-1) here */
        if (nextUsed - lastUsed >= (GLuint)range) {
            if (leaf->dataList == NULL) {
                /* Trivial to expand 'leaf' */
                leaf->end += range;
                pushMaxVal((__GLnamesBranch *) leaf, leaf->end);

                if (nextUsed - lastUsed == (GLuint)range && nextleaf->dataList == NULL) {
                    mergeLeaf(gc, array, leaf);
                }

                __GL_NAMES_UNLOCK(array);
                return lastUsed;
            } else if (nextleaf->dataList == NULL) {
                /* Trivial to expand 'nextleaf' */
                nextleaf->start -= range;

                __GL_NAMES_UNLOCK(array);
                return nextleaf->start;
            } else {
                newleaf = allocLeaf(gc, array);

                newleaf->start = lastUsed;
                newleaf->end = lastUsed + range - 1;
                insertLeaf(gc, array, newleaf);

                __GL_NAMES_UNLOCK(array);
                return lastUsed;
            }
        }

        leaf = nextleaf;
    }

    if (leaf == NULL) {
        newleaf = allocLeaf(gc, array);

        newleaf->start = 1;
        newleaf->end = range;
        insertLeaf(gc, array, newleaf);

        __GL_NAMES_UNLOCK(array);
        return 1;
    } else {
        lastUsed = leaf->end;
        maxUsed = lastUsed + range;
        if (maxUsed < lastUsed) {
            /* Word wrap!  Ack! */
            __GL_NAMES_UNLOCK(array);
            return 0;
        }
        if (leaf->dataList == NULL) {
            /* Trivial to expand 'leaf' */
            leaf->end += range;
            pushMaxVal((__GLnamesBranch *) leaf, leaf->end);

            __GL_NAMES_UNLOCK(array);
            return lastUsed + 1;
        } else {
            /* Need to make new leaf */
            newleaf = allocLeaf(gc, array);

            newleaf->start = lastUsed + 1;
            newleaf->end = maxUsed;
            insertLeaf(gc, array, newleaf);

            __GL_NAMES_UNLOCK(array);
            return lastUsed + 1;
        }
    }
}

void FASTCALL __glNamesDeleteRange(__GLcontext *gc, __GLnamesArray *array,
                          GLuint name, GLsizei range)
{
    __GLnamesLeaf *leaf;
    /*LINTED nextleaf ok; lint doesn't understand for loops*/
    __GLnamesLeaf *nextleaf;
    __GLnamesLeaf *newleaf;
    void *empty;
    GLuint start, end, i;
    GLuint firstdel, lastdel;
    GLuint memoryProblem;

    if (range == 0) return;

    __GL_NAMES_LOCK(array);

    /*
    ** First we check for possible memory problems, since it will be
    ** difficult to back out once we start.  We note a possible problem,
    ** and check for it before fragmenting a leaf.
    */
    memoryProblem = 0;
    if (array->nbranches != __GL_DL_EXTRA_BRANCHES ||
            array->nleaves != __GL_DL_EXTRA_LEAVES) {
        memoryProblem = 1;
    }

    firstdel = name;
    lastdel = name+range-1;

    /*LINTED nextleaf ok; lint bug*/
    for (leaf = findLeaf(array, name, GL_FALSE); leaf != NULL;
            leaf = nextleaf) {
        nextleaf = nextLeaf(leaf);
        start = leaf->start;
        end = leaf->end;
        if (lastdel < start) break;
        if (firstdel > end) continue;

        if (firstdel > start) start = firstdel;
        if (lastdel < end) end = lastdel;

        /*
        ** Need to delete the range of lists from start to end.
        */
        if (leaf->dataList) {
            empty = array->dataInfo->empty;
            for (i=start; i<=end; i++) {
                if (leaf->dataList[i - leaf->start] != empty) {
                    (*leaf->dataInfo->free)(gc,
                        (void *)leaf->dataList[i - leaf->start]);
                    leaf->dataList[i - leaf->start] = empty;
                }
            }
        }

        if (start == leaf->start) {
            if (end == leaf->end) {
                /* Bye bye leaf! */
                deleteLeaf(gc, array, leaf);
                freeLeaf(gc, leaf);
            } else {
                /* Shrink leaf */
                resizeLeaf(gc, leaf, end+1, leaf->end);
            }
        } else if (end == leaf->end) {
            /* Shrink leaf */
            resizeLeaf(gc, leaf, leaf->start, start-1);
        } else {
            if (memoryProblem) {
                if (!fixMemoryProblem(gc, array)) {
                    __GL_NAMES_UNLOCK(array);
                    __glSetError(GL_OUT_OF_MEMORY);
                    return;
                }
            }
            /* Crud.  The middle of the leaf was deleted.  This is tough. */
            newleaf = allocLeaf(gc, array);

            newleaf->start = end+1;
            newleaf->end = leaf->end;
            if (leaf->dataList) {
                if (!allocLeafData(gc, newleaf)) {
                    /*
                    ** Darn!  We are in trouble.  This is a bad spot for an
                    ** out of memory error.  It is also darn unlikely,
                    ** because we just freed up some memory.
                    */
                    freeLeaf(gc, newleaf);
                    __GL_NAMES_UNLOCK(array);
                    __glSetError(GL_OUT_OF_MEMORY);
                    return;
                }
                copyLeafInfo(leaf, newleaf);
            }
            resizeLeaf(gc, leaf, leaf->start, start-1);
            insertLeaf(gc, array, newleaf);
            break;
        }
    }

    __GL_NAMES_UNLOCK(array);
}

GLboolean FASTCALL __glNamesIsName(__GLcontext *gc, __GLnamesArray *array,
                          GLuint name)
{
    GLboolean isName;

    __GL_NAMES_LOCK(array);

    /*
    ** If the name retrieves a leaf, it is in the current name space.
    */
    isName = findLeaf(array, name, GL_TRUE) != NULL;

    __GL_NAMES_UNLOCK(array);

    return isName;
}


/*
** Generates a list of (not necessarily contiguous) names.
*/
void FASTCALL __glNamesGenNames(__GLcontext *gc, __GLnamesArray *array,
                       GLsizei n, GLuint* names)
{
    GLuint start, nameVal;
    int i;

    if (NULL == names) return;

    start = __glNamesGenRange(gc, array, n);
    for (i=0, nameVal=start; i < n; i++, nameVal++) {
        names[i] = nameVal;
    }

}

/*
** Deletes a list of (not necessarily contiguous) names.
*/
void FASTCALL __glNamesDeleteNames(__GLcontext *gc, __GLnamesArray *array,
                          GLsizei n, const GLuint* names)
{
    GLuint start, rangeVal, i;

    /*
    ** Because of resizing leaves, etc, it is best to work in ranges
    ** as much as possible.  So break the list into ranges
    ** and delete them that way.  This degrades into deleting
    ** them one at a time if the list is disjoint or non-ascending.
    ** It also only calls DeleteRange once if the list is a
    ** contiguous range of names.
    */
    start = rangeVal = names[0];
    for (i=0; i < (GLuint)n; i++, rangeVal++) {
        if (names[i] != rangeVal) {
            __glNamesDeleteRange(gc,array,start,rangeVal-start);
            start = rangeVal = names[i];
        }
    }
    __glNamesDeleteRange(gc,array,start,rangeVal-start);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_phong.c ===
/******************************Module*Header*******************************\
* Module Name: so_phong.c
*
* Routines to draw primitives
*
* Created: 10-16-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <fixed.h>
#include <glmath.h>

#ifdef GL_WIN_phong_shading

#ifdef _X86_
#include <gli386.h>
#endif

#define __FASTEST

// Macros
#define DOT(m,a,b)      m = (a)->x*(b)->x + (a)->y*(b)->y + (a)->z*(b)->z
#define MAGN2(m,v)      DOT(m,v,v)

#if _X86_

#define SHADER  __GLcontext.polygon.shader

#define GET_HALF_AREA(gc, a, b, c)\
\
__asm{ mov     eax, a                                                                           };\
__asm{ mov     ecx, c                                                                           };\
__asm{ mov     ebx, b                                                                           };\
__asm{ mov     edx, gc                                                                          };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.x)][eax]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.x)][ecx]      /* dxAC                     */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.y)][ebx]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.y)][ecx]      /* dyBC dxAC                */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.x)][ebx]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.x)][ecx]      /* dxBC dyBC dxAC           */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.y)][eax]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.y)][ecx]      /* dyAC dxBC dyBC dxAC      */ };\
__asm{ fxch    ST(2)                                             /* dyBC dxBC dyAC dxAC      */ };\
__asm{ fst     DWORD PTR [OFFSET(SHADER.dyBC)][edx]                                             };\
__asm{ fmul    ST, ST(3)                                         /* dxACdyBC dxBC dyAC dxAC  */ };\
__asm{ fxch    ST(2)                                             /* dyAC dxBC dxACdyBC dxAC  */ };\
__asm{ fst     DWORD PTR [OFFSET(SHADER.dyAC)][edx]                                             };\
__asm{ fmul    ST, ST(1)                                         /* dxBCdyAC dxBC dxACdyBC dxAC */};\
__asm{ fxch    ST(1)                                             /* dxBC dxBCdyAC dxACdyBC dxAC */};\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.dxBC)][edx]              /* dxBCdyAC dxACdyBC dxAC   */ };\
__asm{ fsubp   ST(1), ST                                /* +1*/  /* area dxAC                */ };\
__asm{ fxch    ST(1)                                             /* dxAC area                */ };\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.dxAC)][edx]              /* area                     */ };\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.area)][edx]     /* +1*/  /* (empty)                  */ };

#define STORE_AREA_PARAMS   

#else

#define GET_HALF_AREA(gc, a, b, c)\
    /* Compute signed half-area of the triangle */                  \
    dxAC = a->window.x - c->window.x;                               \
    dxBC = b->window.x - c->window.x;                               \
    dyAC = a->window.y - c->window.y;                               \
    dyBC = b->window.y - c->window.y;                               \
    gc->polygon.shader.area = dxAC * dyBC - dxBC * dyAC;

#define STORE_AREA_PARAMS\
    gc->polygon.shader.dxAC = dxAC;                                 \
    gc->polygon.shader.dxBC = dxBC;                                 \
    gc->polygon.shader.dyAC = dyAC;                                 \
    gc->polygon.shader.dyBC = dyBC;    

#endif


#if 0
#define ACCUM_MAT_CHANGE(dst,src) \
    if ((src)->dirtyBits & __GL_MATERIAL_AMBIENT)                           \
        (dst).ambient = (src)->ambient;                                     \
    if ((src)->dirtyBits & __GL_MATERIAL_DIFFUSE)                           \
        (dst).diffuse = (src)->diffuse;                                     \
    if ((src)->dirtyBits & __GL_MATERIAL_SPECULAR)                          \
        (dst).specular = (src)->specular;                                   \
    if ((src)->dirtyBits & __GL_MATERIAL_EMISSIVE)                          \
        (dst).emissive = (src)->emissive;                                   \
    if ((src)->dirtyBits & __GL_MATERIAL_SHININESS)                         \
        (dst).shininess = (src)->shininess;                                 \
    if ((src)->dirtyBits & __GL_MATERIAL_COLORINDEXES)                      \
    {                                                                      \
        (dst).cmapa = (src)->cmapa;                                         \ 
        (dst).cmapd = (src)->cmapd;                                         \
        (dst).cmaps = (src)->cmaps;                                         \
    }                                                                      \
    (dst).dirtyBits |= (src)->dirtyBits;                                   
#endif

#define SORT_AND_CULL_FACE(a, b, c, face, ccw)\
                                                                            \
    /*                                                                      \
    ** Sort vertices in y.  Keep track if a reversal of the winding         \
    ** occurs in direction (0 means no reversal, 1 means reversal).         \
    ** Save old vertex pointers in case we end up not doing a fill.         \
    */                                                                      \
    reversed = 0;                                                           \
    if (__GL_VERTEX_COMPARE(a->window.y, <, b->window.y)) {                 \
        if (__GL_VERTEX_COMPARE(b->window.y, <, c->window.y)) {             \
            /* Already sorted */                                            \
        } else {                                                            \
            if (__GL_VERTEX_COMPARE(a->window.y, <, c->window.y)) {         \
                temp=b; b=c; c=temp;                                        \
                reversed = 1;                                               \
            } else {                                                        \
                temp=a; a=c; c=b; b=temp;                                   \
            }                                                               \
        }                                                                   \
    } else {                                                                \
        if (__GL_VERTEX_COMPARE(b->window.y, <, c->window.y)) {             \
            if (__GL_VERTEX_COMPARE(a->window.y, <, c->window.y)) {         \
                temp=a; a=b; b=temp;                                        \
                reversed = 1;                                               \
            } else {                                                        \
                temp=a; a=b; b=c; c=temp;                                   \
            }                                                               \
        } else {                                                            \
            temp=a; a=c; c=temp;                                            \
            reversed = 1;                                                   \
        }                                                                   \
    }                                                                       \
                                                                            \
    GET_HALF_AREA(gc, a, b, c);                                             \
    ccw = !__GL_FLOAT_LTZ(gc->polygon.shader.area);                         \
                                                                            \
    /*                                                                      \
    ** Figure out if face is culled or not.  The face check needs to be     \
    ** based on the vertex winding before sorting.  This code uses the      \
    ** reversed flag to invert the sense of ccw - an xor accomplishes       \
    ** this conversion without an if test.                                  \
    **                                                                      \
    **      ccw reversed        xor                                         \
    **      --- --------        ---                                         \
    **      0   0           0 (remain !ccw)                                 \
    **      1   0           1 (remain ccw)                                  \
    **      0   1           1 (become ccw)                                  \
    **      1   1           0 (become cw)                                   \
    */                                                                      \
    face = gc->polygon.face[ccw ^ reversed];                                \
    if (face == gc->polygon.cullFace) {                                     \
    /* Culled */                                                            \
    return;                                                                 \
    }                                                                       \
                                                                            \
    STORE_AREA_PARAMS;                                                      


//*************** Local functions *******************
void SnapXLeft(__GLcontext *gc, __GLfloat xLeft, __GLfloat dxdyLeft);
void SnapXRight(__GLshade *sh, __GLfloat xRight, __GLfloat dxdyRight);

void InitLineParamsVan (__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                        __GLfloat invDelta);
void InitLineParamsAccel (__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                         __GLfloat invDelta);

static void SetInitialPhongParameters(__GLcontext *gc, __GLvertex *a,
                                      __GLcoord *an, __GLcolor *ac, 
                                      __GLfloat aFog,
                                      __GLfloat dx, __GLfloat dy);

void FASTCALL FillPhongSubTriangle(__GLcontext *gc, GLint iyBottom, 
                                     GLint iyTop);

void InitSpanInterpolationAccel (__GLcontext *gc);
void InitSpanNEInterpolationVan (__GLcontext *gc);
void InitSpanNInterpolationVan (__GLcontext *gc);

void UpdateParamsAlongSpanAccel (__GLcontext *gc);                    
void UpdateNAlongSpanVan (__GLcontext *gc);
void UpdateNEAlongSpanVan (__GLcontext *gc);

void ComputeRGBColorVanZippy (__GLcontext *gc, __GLcolor *outColor); 
void ComputeRGBColorVanFast  (__GLcontext *gc, __GLcolor *outColor); 
void ComputeRGBColorVanSlow  (__GLcontext *gc, __GLcolor *outColor);

void ComputeRGBColorAccelZippy (__GLcontext *gc, __GLcolor *outColor);
void ComputeRGBColorAccelFast  (__GLcontext *gc, __GLcolor *outColor);
// Not implemented yet. This is to accelerate Slow Lights
void ComputeRGBColorAccelSlow  (__GLcontext *gc, __GLcolor *outColor);


// No Zippy versions for CI color
// since there is no Color material for CI
void ComputeCIColorVanFast (__GLcontext *gc, __GLcolor *outColor);   
void ComputeCIColorVanSlow  (__GLcontext *gc, __GLcolor *outColor);

void ComputeCIColorAccelFast (__GLcontext *gc, __GLcolor *outColor);

void ComputePhongInvarientRGBColor (__GLcontext *gc);              

void __glCalcForwardDifferences( GLint w, __GLfloat p0, __GLfloat p1,
                              __GLfloat p2, __GLfloat *d1, __GLfloat *d2 );
#ifdef GL_WIN_specular_fog
__GLfloat ComputeSpecValue (__GLcontext *gc, __GLvertex *vx);
#endif //GL_WIN_specular_fog

/********************* Code **************************************/
#ifdef GL_WIN_specular_fog
__GLfloat ComputeSpecValue (__GLcontext *gc, __GLvertex *vx)
{
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLmaterialMachine *msm;
    GLboolean eyeWIsZero, localViewer;
    static __GLcoord Pe = { 0, 0, 0, 1 };
    __GLcoord n, e;
    __GLfloat fog = 0;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;

    zero = __glZero;

    n = vx->normal;
    e.x = vx->eyeX;
    e.y = vx->eyeY;
    e.z = vx->eyeZ;
    e.w = vx->eyeW;
    
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    msm = &gc->light.front;
    nxi = n.x;
    nyi = n.y;
    nzi = n.z;

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;

    localViewer = gc->state.light.model.localViewer;

    eyeWIsZero = __GL_FLOAT_EQZ(vx->eyeW);
    
    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        __GLfloat n1, n2;
            
        lss = lsm->state;
        lspmm = &lsm->front;
            
        if (lsm->slowPath || eyeWIsZero)
        {
            __GLcoord hHat, vPli, vPliHat, vPeHat;
            __GLfloat att, attSpot;
            __GLfloat hv[3];
                
            /* Compute unit h[i] */
            __glVecSub4(&vPli, &e, &lsm->position);
            __glNormalize(&vPliHat.x, &vPli.x);
            if (localViewer)
            {
                __glVecSub4(&vPeHat, &e, &Pe);
                __glNormalize(&vPeHat.x, &vPeHat.x);
                hv[0] = vPliHat.x + vPeHat.x;
                hv[1] = vPliHat.y + vPeHat.y;
                hv[2] = vPliHat.z + vPeHat.z;
            }
            else
            {
                hv[0] = vPliHat.x;
                hv[1] = vPliHat.y;
                hv[2] = vPliHat.z + __glOne;
            }
            __glNormalize(&hHat.x, hv);
                
            /* Compute attenuation */
            if (__GL_FLOAT_NEZ(lsm->position.w))
            {
                __GLfloat k0, k1, k2, dist;
                    
                k0 = lsm->constantAttenuation;
                k1 = lsm->linearAttenuation;
                k2 = lsm->quadraticAttenuation;
                if (__GL_FLOAT_EQZ(k1) && __GL_FLOAT_EQZ(k2))
                {
                    /* Use pre-computed 1/k0 */
                    att = lsm->attenuation;
                }
                else
                {
                    __GLfloat den;

                    dist = __GL_SQRTF(vPli.x*vPli.x + vPli.y*vPli.y
                                      + vPli.z*vPli.z);
                    den = k0 + k1 * dist + k2 * dist * dist;
                    att = __GL_FLOAT_EQZ(den) ? __glOne : __glOne / den;
                }
            }
            else
            {
                att = __glOne;
            }
                
            /* Compute spot effect if light is a spot light */
            attSpot = att;
            if (lsm->isSpot)
            {
                __GLfloat dot, px, py, pz;
                    
                px = -vPliHat.x;
                py = -vPliHat.y;
                pz = -vPliHat.z;
                dot = px * lsm->direction.x + py * lsm->direction.y
                      + pz * lsm->direction.z;
                if ((dot >= lsm->threshold) && (dot >= lsm->cosCutOffAngle))
                {
                    GLint ix = (GLint)((dot - lsm->threshold) * lsm->scale 
                                       + __glHalf);
                    if (ix < __GL_SPOT_LOOKUP_TABLE_SIZE)
                        attSpot = att * lsm->spotTable[ix];
                }
                else
                {
                    attSpot = zero;
                }
            }
                
            /* Add in remaining effect of light, if any */
            if (attSpot)
            {
                __GLfloat n1, n2;
                __GLcolor sum;
                    
                n1 = nxi * vPliHat.x + nyi * vPliHat.y + nzi * vPliHat.z;
                if (__GL_FLOAT_GTZ(n1))
                {
                    n2 = nxi * hHat.x + nyi * hHat.y + nzi * hHat.z;
                    n2 -= msm_threshold;
                    if (__GL_FLOAT_GEZ(n2))
                    {
                        __GLfloat fx = n2 * msm_scale + __glHalf;
                        if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                            n2 = msm_specTable[(GLint)fx];
                        else
                            n2 = __glOne;
                        fog += n2;
                    }
                }
            }
        }
        else
        {
            __GLfloat n1, n2;
                
            /* Add in specular and diffuse effect of light, if any */
            n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                 nzi * lsm->unitVPpli.z;
            if (__GL_FLOAT_GTZ(n1))
            {
                n2= nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                n2 -= msm_threshold;
                if (__GL_FLOAT_GEZ(n2)) 
                {
                    __GLfloat fx = n2 * msm_scale + __glHalf;
                    if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                        n2 = msm_specTable[(GLint)fx];
                    else
                        n2 = __glOne;
                    fog += n2;
                }
            }
        }
    }
        
    fog = 1.0 - fog;
    if (__GL_FLOAT_LTZ (fog)) fog = __glZero;
    return fog;
}
#endif //GL_WIN_specular_fog

static void AccumMatChange (__GLmatChange *dst, __GLmatChange *src)
{
    if (src->dirtyBits & __GL_MATERIAL_AMBIENT)                          
        dst->ambient = src->ambient;                                     
 
   if (src->dirtyBits & __GL_MATERIAL_DIFFUSE)                 
        dst->diffuse = src->diffuse;                           
    if (src->dirtyBits & __GL_MATERIAL_SPECULAR)                
        dst->specular = src->specular;                         
    if (src->dirtyBits & __GL_MATERIAL_EMISSIVE)                
        dst->emissive = src->emissive;                         
    if (src->dirtyBits & __GL_MATERIAL_SHININESS)               
        dst->shininess = src->shininess;                       
    if (src->dirtyBits & __GL_MATERIAL_COLORINDEXES)            
    {                                                                     
        dst->cmapa = src->cmapa;                                       
        dst->cmapd = src->cmapd;                                       
        dst->cmaps = src->cmaps;                                       
    }                                                                     
    dst->dirtyBits |= src->dirtyBits;                                   
}

// Propagate the valid Normals through the vertex buffer.
//
// IN:  color, normal (front)
// OUT: color, normal (front) (all vertices are updated)

void FASTCALL PolyArrayPhongPropagateColorNormal(__GLcontext *gc, 
                                                 POLYARRAY *pa)
{
    POLYDATA *pd;
    POLYDATA *pdLast;
    GLuint paNeeds;
    GLboolean doFrontColor, doBackColor;
    POLYMATERIAL  *pm;
    __GLphongMaterialData *pmdata = NULL;
    
    
    paNeeds = gc->vertex.paNeeds;
    doFrontColor = paNeeds & PANEEDS_FRONT_COLOR;
    doBackColor  = paNeeds & PANEEDS_BACK_COLOR;

    if (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_EYE_XPOLATE)
        ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, 
                     "Eye coordinate should be available now\n");
    
    // If color is not needed, fill in the colors field 
    // with default.
    
    if (paNeeds & PANEEDS_SKIP_LIGHTING)
    {
        /////?????????!!!!!!!!!!! Look again!!!
        if (doFrontColor) (*gc->procs.paCalcColorSkip)(gc, pa, 0);
        if (doBackColor) (*gc->procs.paCalcColorSkip)(gc, pa, 1);
        return ;
    }


    pdLast = pa->pdNextVertex-1;

    // Check is there are any glMaterial calls that were made 
    // immediately after glBegin, the ones made after the first
    // glVertex call are ignored.

    if (pa->flags & (POLYARRAY_MATERIAL_BACK | POLYARRAY_MATERIAL_BACK))
    {
        pm = GLTEB_CLTPOLYMATERIAL();

        //DbgPrint ("Has the costly material change\n");
        pmdata = (__GLphongMaterialData *)
            GCALLOC(gc, sizeof(__GLphongMaterialData));
        if (pmdata == NULL)
        {
            return;
        }

        pmdata->flags = 0;
        pmdata->matChange[__GL_PHONG_FRONT_FIRST].dirtyBits = 0;
        pmdata->matChange[__GL_PHONG_BACK_FIRST].dirtyBits = 0;
        pmdata->matChange[__GL_PHONG_FRONT_TRAIL].dirtyBits = 0;
        pmdata->matChange[__GL_PHONG_BACK_TRAIL].dirtyBits = 0;

        if (pa->pd0->flags & POLYARRAY_MATERIAL_BACK)
        {
            AccumMatChange (&(pmdata->matChange[__GL_PHONG_BACK_FIRST]),
                            *(&pm->pdMaterial0[pa->pd0 - pa->pdBuffer0].front
                              +1));
            pmdata->flags |= __GL_PHONG_BACK_FIRST_VALID;
        }
        
        if (pa->pd0->flags & POLYARRAY_MATERIAL_FRONT)
        {
            AccumMatChange (&(pmdata->matChange[__GL_PHONG_FRONT_FIRST]),
                            *(&pm->pdMaterial0[pa->pd0 - pa->pdBuffer0].front));
            pmdata->flags |= __GL_PHONG_FRONT_FIRST_VALID;
        }

        // Accumulate the remaining material changes to be applied later
        for (pd = pa->pd0 + 1; pd <= pdLast; pd++)
        {
            if (pd->flags & POLYARRAY_MATERIAL_BACK)
            {
                AccumMatChange (&(pmdata->matChange[__GL_PHONG_BACK_TRAIL]),
                                *(&pm->pdMaterial0[pd - pa->pdBuffer0].front+1));
                pmdata->flags |= __GL_PHONG_BACK_TRAIL_VALID;
            }
            
            if (pd->flags & POLYARRAY_MATERIAL_FRONT)
            {
                AccumMatChange (&(pmdata->matChange[__GL_PHONG_FRONT_TRAIL]), 
                                *(&pm->pdMaterial0[pd - pa->pdBuffer0].front));
                pmdata->flags |= __GL_PHONG_FRONT_TRAIL_VALID;
            }
            
        }
        pa->phong = pmdata;
        pa->flags |= POLYARRAY_PHONG_DATA_VALID;
    }
    

    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        if (gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE)
        {
            if (!(pd->flags & POLYDATA_COLOR_VALID))
            {
                // If color has not changed for this vertex, 
                // use the previously computed color.
                
                ASSERTOPENGL(pd != pa->pd0, "no initial color\n");
                if (gc->modes.colorIndexMode)
                {
                    pd->colors[0].r = (pd-1)->colors[0].r;
                }
                else
                {
                    pd->colors[0].r = (pd-1)->colors[0].r;
                    pd->colors[0].g = (pd-1)->colors[0].g;
                    pd->colors[0].b = (pd-1)->colors[0].b;
                    pd->colors[0].a = (pd-1)->colors[0].a;
                }
                pd->flags |= POLYDATA_COLOR_VALID;
            }
            else if (pa->flags & POLYARRAY_CLAMP_COLOR) 
            {
                if (gc->modes.colorIndexMode)
                {
                    __GL_CLAMP_CI(pd->colors[0].r, gc, pd->colors[0].r);
                }
                else
                {
                    __GL_CLAMP_R(pd->colors[0].r, gc, pd->colors[0].r);
                    __GL_CLAMP_G(pd->colors[0].g, gc, pd->colors[0].g);
                    __GL_CLAMP_B(pd->colors[0].b, gc, pd->colors[0].b);
                    __GL_CLAMP_A(pd->colors[0].a, gc, pd->colors[0].a);
                }
            }
        }
        
        if (!(pd->flags & POLYDATA_NORMAL_VALID))
        {
            // If the normal has not changed for this vertex, 
            // use the previously computed normal.
            ASSERTOPENGL(pd != pa->pd0, "no initial normal\n");
            pd->normal = (pd-1)->normal;
            pd->flags |= POLYDATA_NORMAL_VALID;
        }
        else
        {
            if (gc->vertex.paNeeds & PANEEDS_NORMAL) 
            {
                (*gc->mInv->xf3)(&pd->normal, &pd->normal.x, gc->mInv);
                if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
                    __glNormalize(&pd->normal.x, &pd->normal.x);
            }
        }
    } 

    gc->vertex.paNeeds &= ~PANEEDS_NORMAL;
    pa->flags &= ~POLYARRAY_MATERIAL_FRONT;
    pa->flags &= ~POLYARRAY_MATERIAL_BACK;
    pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

}


void FASTCALL 
__glRenderPhongTriangle(__GLcontext *gc, __GLvertex *a, 
                        __GLvertex *b, __GLvertex *c)
{
    GLuint needs, modeFlags;
    GLint ccw, colorFace, reversed, face;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLvertex *temp;
    
#ifdef NO_RENDERING
    return;
#endif
    
    //Assert that Lighting is on for Phong-shading to take place
    ASSERTOPENGL(gc->state.enables.general & __GL_LIGHTING_ENABLE,
                 "No lighting. Should be smooth-shaded\n");
    
    SORT_AND_CULL_FACE(a, b, c, face, ccw);
    
    if (__GL_FLOAT_EQZ(gc->polygon.shader.area))
        return;
    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
    if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
    {
        gc->polygon.shader.phong.face = __GL_BACKFACE; 
    }
    else
    {
        gc->polygon.shader.phong.face = __GL_FRONTFACE; 
    }
    
    (*gc->procs.fillTriangle) (gc, a, b, c, (GLboolean) ccw);;
}




void FASTCALL 
__glFillPhongTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b, 
                      __GLvertex *c, GLboolean ccw)
{
    __GLfloat oneOverArea, t1, t2, t3, t4;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLfloat aFog, bFog;
    __GLfloat dxAB, dyAB;
    __GLfloat dx, dy, dxdyLeft, dxdyRight;
    __GLcolor *ac, *bc;
    __GLcoord *an, *bn;
    __GLcoord ae, be, ce;
    GLint aIY, bIY, cIY;
    GLuint modeFlags;
    __GLfloat dxdyAC;
    __GLcoord dnAC, dnBC, *cn;
    __GLcoord deAC, deBC;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    GLuint flags = 0, msm_colorMaterialChange;
    GLboolean needColor;

    //CHOP_ROUND_ON();
    FPU_SAVE_MODE ();
    FPU_CHOP_ON ();
    
    /* Pre-compute one over polygon area */

    __GL_FLOAT_BEGIN_DIVIDE(__glOne, gc->polygon.shader.area, &oneOverArea);

    modeFlags = gc->polygon.shader.modeFlags;

    if (gc->polygon.shader.phong.face == __GL_FRONTFACE)
        msm_colorMaterialChange = gc->light.front.colorMaterialChange;
    else
        msm_colorMaterialChange = gc->light.back.colorMaterialChange;

    if ((gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) &&
        msm_colorMaterialChange && (modeFlags & __GL_SHADE_RGB)) 
    {
        flags |= __GL_PHONG_NEED_COLOR_XPOLATE;
        needColor = GL_TRUE;
    }
    
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //!!! Compute Invariant color if possible !!!!!!!!
    //!!!    Use Otto's optimizations here    !!!!!!!!
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if (((!(flags & __GL_PHONG_NEED_COLOR_XPOLATE) || 
        !(msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT | 
                                     __GL_MATERIAL_EMISSIVE))) &&
        (modeFlags & __GL_SHADE_RGB)) &&
        !(phong->flags & __GL_PHONG_NEED_EYE_XPOLATE))
    {
        ComputePhongInvarientRGBColor (gc);
        flags |= __GL_PHONG_INV_COLOR_VALID;
    }
    
    //Store the flags
    phong->flags |= flags;


    /* Fetch some stuff we are going to reuse */
    modeFlags = gc->polygon.shader.modeFlags;
    dxAC = gc->polygon.shader.dxAC;
    dxBC = gc->polygon.shader.dxBC;
    dyAC = gc->polygon.shader.dyAC;
    dyBC = gc->polygon.shader.dyBC;
    ac = a->color;
    bc = b->color;
    an = &(a->normal);
    bn = &(b->normal);
    ae.x = a->eyeX; ae.y = a->eyeY; ae.z = a->eyeZ; ae.w = a->eyeW;
    be.x = b->eyeX; be.y = b->eyeY; be.z = b->eyeZ; be.w = b->eyeW;
    
    /*
    ** Compute delta values for unit changes in x or y for each
    ** parameter.
    */

    __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
    t1 = dyAC * oneOverArea;
    t2 = dyBC * oneOverArea;
    t3 = dxAC * oneOverArea;
    t4 = dxBC * oneOverArea;
    
    /* Normals */
    cn = &(c->normal);
    dnAC.x = an->x - cn->x;
    dnAC.y = an->y - cn->y;
    dnAC.z = an->z - cn->z;

    dnBC.x = bn->x - cn->x;
    dnBC.y = bn->y - cn->y;
    dnBC.z = bn->z - cn->z;

    gc->polygon.shader.phong.dndx.x = dnAC.x * t2 - dnBC.x * t1;
    gc->polygon.shader.phong.dndy.x = dnBC.x * t3 - dnAC.x * t4;
    gc->polygon.shader.phong.dndx.y = dnAC.y * t2 - dnBC.y * t1;
    gc->polygon.shader.phong.dndy.y = dnBC.y * t3 - dnAC.y * t4;
    gc->polygon.shader.phong.dndx.z = dnAC.z * t2 - dnBC.z * t1;
    gc->polygon.shader.phong.dndy.z = dnBC.z * t3 - dnAC.z * t4;

    if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        ce.x = c->eyeX; ce.y = c->eyeY; ce.z = c->eyeZ; ce.w = c->eyeW;

        deAC.x = ae.x - ce.x;
        deAC.y = ae.y - ce.y;
        deAC.z = ae.z - ce.z;
        deAC.w = ae.w - ce.w;

        deBC.x = be.x - ce.x;
        deBC.y = be.y - ce.y;
        deBC.z = be.z - ce.z;
        deBC.w = be.w - ce.w;

        gc->polygon.shader.phong.dedx.x = deAC.x * t2 - deBC.x * t1;
        gc->polygon.shader.phong.dedy.x = deBC.x * t3 - deAC.x * t4;
        gc->polygon.shader.phong.dedx.y = deAC.y * t2 - deBC.y * t1;
        gc->polygon.shader.phong.dedy.y = deBC.y * t3 - deAC.y * t4;
        gc->polygon.shader.phong.dedx.z = deAC.z * t2 - deBC.z * t1;
        gc->polygon.shader.phong.dedy.z = deBC.z * t3 - deAC.z * t4;
        gc->polygon.shader.phong.dedx.w = deAC.w * t2 - deBC.w * t1;
        gc->polygon.shader.phong.dedy.w = deBC.w * t3 - deAC.w * t4;
    }
    
    if (modeFlags & __GL_SHADE_RGB) 
    {
        __GLfloat drAC, dgAC, dbAC, daAC;
        __GLfloat drBC, dgBC, dbBC, daBC;
        __GLcolor *cc;
        
        /* Colors */
        if (needColor)
        {
            cc = c->color;
            drAC = ac->r - cc->r;
            drBC = bc->r - cc->r;
            dgAC = ac->g - cc->g;
            dgBC = bc->g - cc->g;
            dbAC = ac->b - cc->b;
            dbBC = bc->b - cc->b;
            daAC = ac->a - cc->a;
            daBC = bc->a - cc->a;
        
        
            gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
            gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
            gc->polygon.shader.dgdx = dgAC * t2 - dgBC * t1;
            gc->polygon.shader.dgdy = dgBC * t3 - dgAC * t4;
            gc->polygon.shader.dbdx = dbAC * t2 - dbBC * t1;
            gc->polygon.shader.dbdy = dbBC * t3 - dbAC * t4;
            gc->polygon.shader.dadx = daAC * t2 - daBC * t1;
            gc->polygon.shader.dady = daBC * t3 - daAC * t4;
        }

        if (modeFlags & __GL_SHADE_TEXTURE) 
        {
            __GLfloat awinv, bwinv, cwinv, scwinv, tcwinv, qwcwinv;
            __GLfloat dsAC, dsBC, dtAC, dtBC, dqwAC, dqwBC;

            awinv = a->window.w;
            bwinv = b->window.w;
            cwinv = c->window.w;
            scwinv = c->texture.x * cwinv;
            tcwinv = c->texture.y * cwinv;
            qwcwinv = c->texture.w * cwinv;

            dsAC = a->texture.x * awinv - scwinv;
            dsBC = b->texture.x * bwinv - scwinv;
            dtAC = a->texture.y * awinv - tcwinv;
            dtBC = b->texture.y * bwinv - tcwinv;
            dqwAC = a->texture.w * awinv - qwcwinv;
            dqwBC = b->texture.w * bwinv - qwcwinv;

            gc->polygon.shader.dsdx = dsAC * t2 - dsBC * t1;
            gc->polygon.shader.dsdy = dsBC * t3 - dsAC * t4;
            gc->polygon.shader.dtdx = dtAC * t2 - dtBC * t1;
            gc->polygon.shader.dtdy = dtBC * t3 - dtAC * t4;
            gc->polygon.shader.dqwdx = dqwAC * t2 - dqwBC * t1;
            gc->polygon.shader.dqwdy = dqwBC * t3 - dqwAC * t4;
        }
    } 

    if (modeFlags & __GL_SHADE_DEPTH_ITER) 
    {
        __GLfloat dzAC, dzBC;

        dzAC = a->window.z - c->window.z;
        dzBC = b->window.z - c->window.z;
        
        gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
        gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;
        if(( gc->modes.depthBits == 16 ) &&
           ( gc->depthBuffer.scale <= (GLuint)0xffff )) {
            gc->polygon.shader.dzdx = 
              FLT_TO_Z16_SCALE(gc->polygon.shader.dzdxf);
        }
        else {
            gc->polygon.shader.dzdx = FTOL(gc->polygon.shader.dzdxf);
        }
    }

#ifdef GL_WIN_specular_fog
    if (gc->polygon.shader.modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        __GLfloat dfAC, dfBC, cFog;

        /* Use eyeZ for interpolation value */
        aFog = a->eyeZ;
        bFog = b->eyeZ;
        cFog = c->eyeZ;

        dfAC = aFog - cFog;
        dfBC = bFog - cFog;

        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    } 
    else if (gc->polygon.shader.modeFlags & __GL_SHADE_INTERP_FOG)
    {
        __GLfloat dfAC, dfBC, cFog;
        
        aFog = bFog = cFog = 1.0f;
        
        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            aFog = ComputeSpecValue (gc, a);
            bFog = ComputeSpecValue (gc, b);
            cFog = ComputeSpecValue (gc, c);
        }

        if (gc->polygon.shader.modeFlags & __GL_SHADE_SLOW_FOG)
        {
            aFog *= a->fog;
            bFog *= b->fog;
            cFog *= c->fog;
        }
        
        dfAC = aFog - cFog;
        dfBC = bFog - cFog;

        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    }
#else  //GL_WIN_specular_fog
    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        __GLfloat dfAC, dfBC, cFog;

        /* Use eyeZ for interpolation value */
        aFog = a->eyeZ;
        bFog = b->eyeZ;
        cFog = c->eyeZ;

        dfAC = aFog - cFog;
        dfBC = bFog - cFog;

        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    }
    else if (modeFlags & __GL_SHADE_INTERP_FOG)
    {
        /* Use fog for interpolation value */
        aFog = a->fog;
        bFog = b->fog;
        cFog = c->fog;

        dfAC = aFog - cFog;
        dfBC = bFog - cFog;

        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    } 
#endif //GL_WIN_specular_fog
    
    __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(dxAC, dyAC, dxdyAC);
    
    /* Snap each y coordinate to its pixel center */
    aIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(a->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    bIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(b->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    cIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(c->window.y)+
                                   __GL_VERTEX_FRAC_HALF);

#ifdef __DBG_PRINT
    DbgPrint ("aIY=%d, bIY=%d, cIY=%d\n", aIY, bIY, cIY);
#endif
    
    /*
    ** This algorithim always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */
    dxAB = a->window.x - b->window.x;
    dyAB = a->window.y - b->window.y;
    if (ccw) {
        dy = (aIY + __glHalf) - a->window.y;
        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);
        SnapXLeft(gc, a->window.x + dy*dxdyAC, dxdyAC);
        dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
        SetInitialPhongParameters(gc, a, an, ac, aFog, dx, dy);
        if (aIY != bIY) {
            dxdyRight = dxAB / dyAB;
            SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyRight,
                       dxdyRight);
#ifdef __DBG_PRINT
            DbgPrint ("dxdyRight = %f\n", dxdyRight);
#endif
            FillPhongSubTriangle(gc, aIY, bIY);
        }

        if (bIY != cIY) {
            dxdyRight = dxBC / dyBC;
            dy = (bIY + __glHalf) - b->window.y;
            SnapXRight(&gc->polygon.shader, b->window.x + dy*dxdyRight,
                       dxdyRight);
#ifdef __DBG_PRINT
            DbgPrint ("dxdyRight = %f\n", dxdyRight);
#endif
            FillPhongSubTriangle(gc, bIY, cIY);
        }
    } else {
        dy = (aIY + __glHalf) - a->window.y;
        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);
        SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyAC, dxdyAC);
#ifdef __DBG_PRINT
        DbgPrint ("dxdyRight = %f\n", dxdyAC);
#endif
        if (aIY != bIY) {
            dxdyLeft = dxAB / dyAB;
            SnapXLeft(gc, a->window.x + dy*dxdyLeft, dxdyLeft);
            dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
            SetInitialPhongParameters(gc, a, an, ac, aFog, dx, dy);
            FillPhongSubTriangle(gc, aIY, bIY);
        }

        if (bIY != cIY) {
            dxdyLeft = dxBC / dyBC;
            dy = (bIY + __glHalf) - b->window.y;
            SnapXLeft(gc, b->window.x + dy*dxdyLeft, dxdyLeft);
            dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
            SetInitialPhongParameters(gc, b, bn, bc, bFog, dx, dy);
            FillPhongSubTriangle(gc, bIY, cIY);
        }
    }
    
    FPU_RESTORE_MODE();  // CHOP_ROUND_OFF();
}



static void SetInitialPhongParameters(__GLcontext *gc, __GLvertex *a,
                                      __GLcoord *an, __GLcolor *ac, 
                                      __GLfloat aFog, __GLfloat dx, 
                                      __GLfloat dy)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLshade *sh = &gc->polygon.shader;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat big = sh->dxLeftBig;
    GLuint modeFlags = sh->modeFlags;
    GLboolean needColor = (gc->polygon.shader.phong.flags & 
                               __GL_PHONG_NEED_COLOR_XPOLATE);

#define bPolygonOffset \
        (gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE )


     /* Set parameters for the shader */ 
    phong->nCur.x = an->x + dx*phong->dndx.x + dy*phong->dndy.x;
    phong->nCur.y = an->y + dx*phong->dndx.y + dy*phong->dndy.y;
    phong->nCur.z = an->z + dx*phong->dndx.z + dy*phong->dndy.z;

    phong->nLittle.x = phong->dndy.x + little * phong->dndx.x;
    phong->nLittle.y = phong->dndy.y + little * phong->dndx.y;
    phong->nLittle.z = phong->dndy.z + little * phong->dndx.z;

    if (big > little) 
    {
        phong->nBig.x = phong->nLittle.x + phong->dndx.x;
        phong->nBig.y = phong->nLittle.y + phong->dndx.y;
        phong->nBig.z = phong->nLittle.z + phong->dndx.z;
    }
    else
    {
        phong->nBig.x = phong->nLittle.x - phong->dndx.x;
        phong->nBig.y = phong->nLittle.y - phong->dndx.y;
        phong->nBig.z = phong->nLittle.z - phong->dndx.z;
    }

    if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        phong->eCur.x = a->eyeX + dx*phong->dedx.x + dy*phong->dedy.x;
        phong->eCur.y = a->eyeY + dx*phong->dedx.y + dy*phong->dedy.y;
        phong->eCur.z = a->eyeZ + dx*phong->dedx.z + dy*phong->dedy.z;
        phong->eCur.w = a->eyeW + dx*phong->dedx.w + dy*phong->dedy.w;

        phong->eLittle.x = phong->dedy.x + little * phong->dedx.x;
        phong->eLittle.y = phong->dedy.y + little * phong->dedx.y;
        phong->eLittle.z = phong->dedy.z + little * phong->dedx.z;
        phong->eLittle.w = phong->dedy.w + little * phong->dedx.w;

        if (big > little) 
        {
            phong->eBig.x = phong->eLittle.x + phong->dedx.x;
            phong->eBig.y = phong->eLittle.y + phong->dedx.y;
            phong->eBig.z = phong->eLittle.z + phong->dedx.z;
            phong->eBig.w = phong->eLittle.w + phong->dedx.w;
        }
        else
        {
            phong->eBig.x = phong->eLittle.x - phong->dedx.x;
            phong->eBig.y = phong->eLittle.y - phong->dedx.y;
            phong->eBig.z = phong->eLittle.z - phong->dedx.z;
            phong->eBig.w = phong->eLittle.w - phong->dedx.w;
        }
    }
        
    if (big > little) 
    {
        if (modeFlags & __GL_SHADE_RGB) 
        {
            if (needColor)
            {
                
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;

                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle + sh->drdx;
            
                sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
                sh->gLittle = sh->dgdy + little * sh->dgdx;
                sh->gBig = sh->gLittle + sh->dgdx;
            
                sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
                sh->bLittle = sh->dbdy + little * sh->dbdx;
                sh->bBig = sh->bLittle + sh->dbdx;
                
                sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
                sh->aLittle = sh->dady + little * sh->dadx;
                sh->aBig =sh->aLittle + sh->dadx;
            }
            if (modeFlags & __GL_SHADE_TEXTURE) 
            {
                __GLfloat oneOverW = a->window.w;
                sh->frag.s = a->texture.x * oneOverW + dx*sh->dsdx
                  + dy*sh->dsdy;
                sh->sLittle = sh->dsdy + little * sh->dsdx;
                sh->sBig = sh->sLittle + sh->dsdx;
                
                sh->frag.t = a->texture.y * oneOverW + dx*sh->dtdx
                  + dy*sh->dtdy;
                sh->tLittle = sh->dtdy + little * sh->dtdx;
                sh->tBig = sh->tLittle + sh->dtdx;
                
                sh->frag.qw = a->texture.w * oneOverW + dx*sh->dqwdx
                  + dy*sh->dqwdy;
                sh->qwLittle = sh->dqwdy + little * sh->dqwdx;
                sh->qwBig = sh->qwLittle + sh->dqwdx;
            }
        } 

        if (modeFlags & __GL_SHADE_DEPTH_ITER) 
        {
            __GLfloat zLittle, zOffset;

            zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
            if (gc->modes.depthBits == 16) 
            {
                sh->frag.z = (__GLzValue)
                FLT_TO_Z16_SCALE(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf
                                 + zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FLT_TO_Z16_SCALE(zLittle);
                sh->zBig = FLT_TO_Z16_SCALE(zLittle + sh->dzdxf);
            }
            else 
            {
                sh->frag.z = (__GLzValue)
                  FTOL(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf +
                       zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FTOL(zLittle);
                sh->zBig = FTOL(zLittle + sh->dzdxf);
            }
        }

        if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
        {
            sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
            sh->fLittle = sh->dfdy + little * sh->dfdx;
            sh->fBig = sh->fLittle + sh->dfdx;
        }
    } 
    else 
    {    
        if (modeFlags & __GL_SHADE_RGB) 
        {
            if (needColor)
            {
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle - sh->drdx;

                sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
                sh->gLittle = sh->dgdy + little * sh->dgdx;
                sh->gBig = sh->gLittle - sh->dgdx;
                
                sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
                sh->bLittle = sh->dbdy + little * sh->dbdx;
                sh->bBig = sh->bLittle - sh->dbdx;
                
                sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
                sh->aLittle = sh->dady + little * sh->dadx;
                sh->aBig =sh->aLittle - sh->dadx;
            }
            if (modeFlags & __GL_SHADE_TEXTURE) 
            {
                __GLfloat oneOverW = a->window.w;
                sh->frag.s = a->texture.x * oneOverW + dx*sh->dsdx
                  + dy*sh->dsdy;
                sh->sLittle = sh->dsdy + little * sh->dsdx;
                sh->sBig = sh->sLittle - sh->dsdx;
                
                sh->frag.t = a->texture.y * oneOverW + dx*sh->dtdx
                  + dy*sh->dtdy;
                sh->tLittle = sh->dtdy + little * sh->dtdx;
                sh->tBig = sh->tLittle - sh->dtdx;
                
                sh->frag.qw = a->texture.w * oneOverW + dx*sh->dqwdx
                  + dy*sh->dqwdy;
                sh->qwLittle = sh->dqwdy + little * sh->dqwdx;
                sh->qwBig = sh->qwLittle - sh->dqwdx;
            }
        } 

        if (modeFlags & __GL_SHADE_DEPTH_ITER) 
        {
            __GLfloat zLittle, zOffset;

            zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
            if(( gc->modes.depthBits == 16 ) &&
               ( gc->depthBuffer.scale <= (GLuint)0xffff )) 
            {
                sh->frag.z = (__GLzValue)
                  FLT_TO_Z16_SCALE(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf
                                     + zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FLT_TO_Z16_SCALE(zLittle);
                sh->zBig = FLT_TO_Z16_SCALE(zLittle - sh->dzdxf);
            }
            else 
            {
                sh->frag.z = (__GLzValue)
                  FTOL( a->window.z + dx*sh->dzdxf + dy*sh->dzdyf+ zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FTOL(zLittle);
                sh->zBig = FTOL(zLittle - sh->dzdxf);
            }
        }
        if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
        {
            sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
            sh->fLittle = sh->dfdy + little * sh->dfdx;
            sh->fBig = sh->fLittle - sh->dfdx;
        }
    }
}


/* This routine sets gc->polygon.shader.cfb to gc->drawBuffer */

static void FASTCALL FillPhongSubTriangle(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint dxLeftFrac, dxRightFrac;
    GLint dxLeftLittle, dxRightLittle;
    GLint dxLeftBig, dxRightBig;
    GLint spanWidth, clipY0, clipY1;
    GLuint modeFlags;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLboolean needColor = (phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE);
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    __GLcolor colors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor fbcolors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor *vColors, *vFbcolors;
    int iMaxWidth, iDy, dxLeft, dxRight;

    ixLeft = gc->polygon.shader.ixLeft;
    dxLeft = (gc->polygon.shader.dxLeftBig < gc->polygon.shader.dxLeftLittle) ?
             gc->polygon.shader.dxLeftBig : gc->polygon.shader.dxLeftLittle;
    ixRight = gc->polygon.shader.ixRight;
    dxRight = (gc->polygon.shader.dxRightBig > gc->polygon.shader.dxRightLittle) ?
              gc->polygon.shader.dxRightBig : gc->polygon.shader.dxRightLittle;
    iMaxWidth = ixRight - ixLeft;
    iDy = iyTop - iyBottom - 1;
    ixRight += dxRight * iDy;
    ixLeft += dxLeft * iDy;
    iMaxWidth = (iMaxWidth < (ixRight - ixLeft)) ? ixRight - ixLeft :
        iMaxWidth;
    
    if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (iMaxWidth+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return;
        }
    }
    else
    {
        words = stackWords;
    }
    
    if (iMaxWidth > (__GL_MAX_STACKED_COLORS>>1))
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, 
                                               iMaxWidth * sizeof(__GLcolor));
        if (NULL == vColors)
        {
            if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            return;
        }

        vFbcolors = (__GLcolor *) gcTempAlloc(gc, 
                                                 iMaxWidth * sizeof(__GLcolor));
        if (NULL == vFbcolors) {
            if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            gcTempFree(gc, vColors);
            return;
        }
    }
    else
    {
        vColors = colors;
        vFbcolors = fbcolors;
    }

    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;
    dxLeftFrac = gc->polygon.shader.dxLeftFrac;
    dxLeftBig = gc->polygon.shader.dxLeftBig;
    dxLeftLittle = gc->polygon.shader.dxLeftLittle;
    dxRightFrac = gc->polygon.shader.dxRightFrac;
    dxRightBig = gc->polygon.shader.dxRightBig;
    dxRightLittle = gc->polygon.shader.dxRightLittle;
    modeFlags = gc->polygon.shader.modeFlags;

    gc->polygon.shader.colors = vColors;
    gc->polygon.shader.fbcolors = vFbcolors;
    gc->polygon.shader.stipplePat = words;
    if (modeFlags & __GL_SHADE_STENCIL_TEST) {
        gc->polygon.shader.sbuf =
          __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
                            ixLeft, iyBottom);
    }
    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
    if( gc->modes.depthBits == 32 )
        gc->polygon.shader.zbuf = (__GLzValue *)
             __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                ixLeft, iyBottom);
    else
        gc->polygon.shader.zbuf = (__GLzValue *)
            __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                ixLeft, iyBottom);
    }
    gc->polygon.shader.cfb = gc->drawBuffer;
    while (iyBottom < iyTop) 
    {
        spanWidth = ixRight - ixLeft;
        /*
        ** Only render spans that have non-zero width and which are
        ** not scissored out vertically.
        */
        if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) 
        {
            gc->polygon.shader.frag.x = ixLeft;
            gc->polygon.shader.frag.y = iyBottom;
            gc->polygon.shader.length = spanWidth;
            /* Initialize Parameters to interpolate */
            (*gc->procs.phong.InitSpanInterpolation) (gc);
            (*gc->procs.span.processSpan)(gc);
        }

        /* Advance right edge fixed point, adjusting for carry */
        ixRightFrac += dxRightFrac;
        if (ixRightFrac < 0) 
        {
            /* Carry/Borrow'd. Use large step */
            ixRight += dxRightBig;
            ixRightFrac &= ~0x80000000;
        } 
        else 
        {
            ixRight += dxRightLittle;
        }

        iyBottom++;
        ixLeftFrac += dxLeftFrac;

        if (ixLeftFrac < 0) 
        {
            /* Carry/Borrow'd.  Use large step */
            ixLeft += dxLeftBig;
            ixLeftFrac &= ~0x80000000;
            
            phong->nCur.x += phong->nBig.x;
            phong->nCur.y += phong->nBig.y;
            phong->nCur.z += phong->nBig.z;
            
            if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
            {
                phong->eCur.x += phong->eBig.x;
                phong->eCur.y += phong->eBig.y;
                phong->eCur.z += phong->eBig.z;
                phong->eCur.w += phong->eBig.w;
            }

            if (modeFlags & __GL_SHADE_RGB) 
            {
                if (needColor) 
                {
                    gc->polygon.shader.frag.color.r +=gc->polygon.shader.rBig;
                    gc->polygon.shader.frag.color.g +=gc->polygon.shader.gBig;
                    gc->polygon.shader.frag.color.b +=gc->polygon.shader.bBig;
                    gc->polygon.shader.frag.color.a +=gc->polygon.shader.aBig;
                }
                if (modeFlags & __GL_SHADE_TEXTURE) 
                {
                    gc->polygon.shader.frag.s += gc->polygon.shader.sBig;
                    gc->polygon.shader.frag.t += gc->polygon.shader.tBig;
                    gc->polygon.shader.frag.qw += gc->polygon.shader.qwBig;
                }
            } 

            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.sbuf = (__GLstencilCell*)
                  ((GLubyte*) gc->polygon.shader.sbuf
                   + gc->polygon.shader.sbufBig);
            }
            if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                gc->polygon.shader.frag.z += gc->polygon.shader.zBig;
            }

            if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.zbuf = (__GLzValue*)
                  ((GLubyte*) gc->polygon.shader.zbuf
                   + gc->polygon.shader.zbufBig);
            }

            if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
            {
                gc->polygon.shader.frag.f += gc->polygon.shader.fBig;
            }
        } 
        else 
        {
            /* Use small step */
            ixLeft += dxLeftLittle;

            phong->nCur.x += phong->nLittle.x;
            phong->nCur.y += phong->nLittle.y;
            phong->nCur.z += phong->nLittle.z;
            
            if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
            {
                phong->eCur.x += phong->eLittle.x;
                phong->eCur.y += phong->eLittle.y;
                phong->eCur.z += phong->eLittle.z;
                phong->eCur.w += phong->eLittle.w;
            }

            if (modeFlags & __GL_SHADE_RGB) 
            {
                if (needColor) 
                {
                    gc->polygon.shader.frag.color.r += 
                                               gc->polygon.shader.rLittle;
                    gc->polygon.shader.frag.color.g += 
                                               gc->polygon.shader.gLittle;
                    gc->polygon.shader.frag.color.b += 
                                               gc->polygon.shader.bLittle;
                    gc->polygon.shader.frag.color.a += 
                                               gc->polygon.shader.aLittle;
                }
                
                if (modeFlags & __GL_SHADE_TEXTURE) {
                    gc->polygon.shader.frag.s += gc->polygon.shader.sLittle;
                    gc->polygon.shader.frag.t += gc->polygon.shader.tLittle;
                    gc->polygon.shader.frag.qw += gc->polygon.shader.qwLittle;
                }
            } 

            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.sbuf = (__GLstencilCell*)
                  ((GLubyte*) gc->polygon.shader.sbuf
                   + gc->polygon.shader.sbufLittle);
            }
            if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                gc->polygon.shader.frag.z += gc->polygon.shader.zLittle;
            }
            if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.zbuf = (__GLzValue*)
                  ((GLubyte*) gc->polygon.shader.zbuf
                   + gc->polygon.shader.zbufLittle);
            }
            if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
            {
                gc->polygon.shader.frag.f += gc->polygon.shader.fLittle;
            }
        }
    }
    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;
#ifdef NT
    if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
    if (iMaxWidth > (__GL_MAX_STACKED_COLORS>>1))
    {
        gcTempFree(gc, vColors);
        gcTempFree(gc, vFbcolors);
    }
#endif
}

static void SnapXLeft(__GLcontext *gc, __GLfloat xLeft, __GLfloat dxdyLeft)
{
    GLint ixLeft, ixLeftFrac, lineBytes, elementSize, iLittle, iBig;

    ASSERT_CHOP_ROUND();
    
    ixLeft = __GL_VERTEX_FLOAT_TO_INT(xLeft);
    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixLeftFrac = __GL_VERTEX_PROMOTED_FRACTION(xLeft) + 0x40000000;

#ifdef __DBG_PRINT
    DbgPrint ("dxdyLeft = %f\n", dxdyLeft);
#endif
    
    gc->polygon.shader.ixLeft = ixLeft + (((GLuint) ixLeftFrac) >> 31);
    gc->polygon.shader.ixLeftFrac = ixLeftFrac & ~0x80000000;

    /* Compute big and little steps */
    iLittle = FTOL(dxdyLeft);
    gc->polygon.shader.dxLeftFrac = FLT_FRACTION(dxdyLeft - iLittle);
    if (dxdyLeft < 0) {
        iBig = iLittle - 1;
    } else {
        iBig = iLittle + 1;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_STENCIL_TEST) {
        /*
        ** Compute the big and little stencil buffer steps.  We walk the
        ** memory pointers for the stencil buffer along the edge of the
        ** triangle as we walk the edge.  This way we don't have to
        ** recompute the buffer address as we go.
        */
        elementSize = gc->stencilBuffer.buf.elementSize;
        lineBytes = elementSize * gc->stencilBuffer.buf.outerWidth;
        gc->polygon.shader.sbufLittle = lineBytes + iLittle * elementSize;
        gc->polygon.shader.sbufBig = lineBytes + iBig * elementSize;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
        /*
        ** Compute the big and little depth buffer steps.  We walk the
        ** memory pointers for the depth buffer along the edge of the
        ** triangle as we walk the edge.  This way we don't have to
        ** recompute the buffer address as we go.
        */
        elementSize = gc->depthBuffer.buf.elementSize;
        lineBytes = elementSize * gc->depthBuffer.buf.outerWidth;
        gc->polygon.shader.zbufLittle = lineBytes + iLittle * elementSize;
        gc->polygon.shader.zbufBig = lineBytes + iBig * elementSize;
    }
    gc->polygon.shader.dxLeftLittle = iLittle;
    gc->polygon.shader.dxLeftBig = iBig;
}

static void SnapXRight(__GLshade *sh, __GLfloat xRight, __GLfloat dxdyRight)
{
    GLint ixRight, ixRightFrac, iLittle, iBig;

    ASSERT_CHOP_ROUND();
    
    ixRight = __GL_VERTEX_FLOAT_TO_INT(xRight);
    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixRightFrac = __GL_VERTEX_PROMOTED_FRACTION(xRight) + 0x40000000;
    
    sh->ixRight = ixRight + (((GLuint) ixRightFrac) >> 31);
    sh->ixRightFrac = ixRightFrac & ~0x80000000;
    
    /* Compute big and little steps */
    iLittle = FTOL(dxdyRight);
    sh->dxRightFrac = FLT_FRACTION(dxdyRight - iLittle);
    if (dxdyRight < 0) {
        iBig = iLittle - 1;
    } else {
        iBig = iLittle + 1;
    }
    sh->dxRightLittle = iLittle;
    sh->dxRightBig = iBig;
}


void InitLineParamsVan (__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                        __GLfloat invDelta)
{
    __GLcoord *n0 = &(v0->normal);
    __GLcoord *n1 = &(v1->normal);
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLuint msm_colorMaterialChange, flags=0;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    msm_colorMaterialChange = gc->light.front.colorMaterialChange;
    phong->face = __GL_FRONTFACE;

    if ((gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) &&
        msm_colorMaterialChange && (modeFlags & __GL_SHADE_RGB))
        flags |= __GL_PHONG_NEED_COLOR_XPOLATE;

    //Compute Invariant color if possible
    if (((!(flags & __GL_PHONG_NEED_COLOR_XPOLATE) || 
        !(msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT | 
                                     __GL_MATERIAL_EMISSIVE))) &&
        (modeFlags & __GL_SHADE_RGB)) &&
        !(flags & __GL_PHONG_NEED_EYE_XPOLATE))
    {
        ComputePhongInvarientRGBColor (gc);
        flags |= __GL_PHONG_INV_COLOR_VALID;
    }
    
    //Store the flags
    gc->polygon.shader.phong.flags |= flags;

    phong->dndx.x = (n1->x - n0->x) * invDelta;
    phong->dndx.y = (n1->y - n0->y) * invDelta;
    phong->dndx.z = (n1->z - n0->z) * invDelta;

    phong->nTmp.x = n0->x;
    phong->nTmp.y = n0->y;
    phong->nTmp.z = n0->z;

    if (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        phong->dedx.x = (v1->eyeX - v0->eyeX) * invDelta;
        phong->dedx.y = (v1->eyeY - v0->eyeY) * invDelta;
        phong->dedx.z = (v1->eyeZ - v0->eyeZ) * invDelta;

        phong->eTmp.x = v0->eyeX;
        phong->eTmp.y = v0->eyeY;
        phong->eTmp.z = v0->eyeZ;
    }
}


void InitLineParamsAccel (__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                        __GLfloat invDelta)
{
    __GLcoord normal;
    __GLcoord *n0 = &(v0->normal);
    __GLcoord *n1 = &normal;
    __GLcoord *n2 = &(v1->normal);
    __GLlightSourceMachine *lsm;
    GLuint msm_colorMaterialChange, flags = 0;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    GLint face = phong->face, curL, w;
    
    msm_colorMaterialChange = gc->light.front.colorMaterialChange;
    phong->face = __GL_FRONTFACE;
    w = gc->line.options.numPixels;
    
    if ((gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) &&
        msm_colorMaterialChange && (modeFlags & __GL_SHADE_RGB))
        flags |= __GL_PHONG_NEED_COLOR_XPOLATE;

    //Compute Invariant color if possible
    if (((!(flags & __GL_PHONG_NEED_COLOR_XPOLATE) || 
        !(msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT | 
                                     __GL_MATERIAL_EMISSIVE))) &&
        (modeFlags & __GL_SHADE_RGB)) &&
        !(flags & __GL_PHONG_NEED_EYE_XPOLATE))
    {
        ComputePhongInvarientRGBColor (gc);
        flags |= __GL_PHONG_INV_COLOR_VALID;
    }
    
    //Store the flags
    gc->polygon.shader.phong.flags |= flags;

    phong->dndx.x = (n2->x - n0->x) * invDelta;
    phong->dndx.y = (n2->y - n0->y) * invDelta;
    phong->dndx.x = (n2->z - n0->z) * invDelta;


    normal.x = (n0->x + n2->x)/2.0f;
    normal.y = (n0->y + n2->y)/2.0f;
    normal.z = (n0->z + n2->z)/2.0f;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&normal.x, &normal.x);
    
    for (lsm = gc->light.sources, curL = 0; lsm; 
         lsm = lsm->next, curL++)
    {
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        __GLcoord *L = &(lsm->unitVPpli); // L is already normalized here
        __GLcoord *H = &(lsm->hHat);      // H is already normalized here
        GLfloat d0, d1, d2;

        /***** Diffuse *****/
        DOT (d0,n0,L);
        DOT (d1,n1,L);
        DOT (d2,n2,L);
            
        __glCalcForwardDifferences(w, d0, d1, d2, &pld->Ddel, &pld->Ddel2);
        pld->Dcurr = d0;

        /***** Specular ******/
        DOT (d0,n0,H);
        DOT (d1,n1,H);
        DOT (d2,n2,H);
            
        __glCalcForwardDifferences(w, d0, d1, d2, &pld->Sdel, &pld->Sdel2);
        pld->Scurr = d0;
    }

    phong->numLights = curL;
}


void InitSpanNEInterpolationVan (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    phong->nTmp = phong->nCur;
    phong->eTmp = phong->eCur;
}


void InitSpanNInterpolationVan (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    phong->nTmp = phong->nCur;
}

void InitSpanInterpolationAccel (__GLcontext *gc)
{
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLint face = phong->face;
    __GLlightSourceMachine *lsm;
    __GLcoord n0, n1, n2, dndx;
    __GLcoord *N0 = &n0;
    __GLcoord *N1 = &n1;
    __GLcoord *N2 = &n2;
    
    GLint curL, w, w2;
    
    w = gc->polygon.shader.length;
    w2 = w / 2;
    
    if (face == __GL_FRONTFACE)
    {
        //msm = &gc->light.front;
        n0.x = phong->nCur.x;
        n0.y = phong->nCur.y;
        n0.z = phong->nCur.z;

        dndx.x = phong->dndx.x;
        dndx.y = phong->dndx.y;
        dndx.z = phong->dndx.z;
    }
    else
    {
        //msm = &gc->light.back;
        n0.x = -phong->nCur.x;
        n0.y = -phong->nCur.y;
        n0.z = -phong->nCur.z;

        dndx.x = -phong->dndx.x;
        dndx.y = -phong->dndx.y;
        dndx.z = -phong->dndx.z;
    }
    
    if (w > 2)
    {
        n2.x = n0.x + w*dndx.x;
        n2.y = n0.y + w*dndx.y;
        n2.z = n0.z + w*dndx.z;
        
        n1.x = n0.x + w2*dndx.x;
        n1.y = n0.y + w2*dndx.y;
        n1.z = n0.z + w2*dndx.z;
    }
    
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
    {
        __glNormalize(&n0.x, &n0.x);
        if (w > 2)
        {
            __glNormalize(&n1.x, &n1.x);
            __glNormalize(&n2.x, &n2.x);
        }
    }
    
    for (lsm = gc->light.sources, curL=0; lsm; lsm = lsm->next, curL++)
    {
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        __GLcoord *L = &(lsm->unitVPpli); // L is already normalized here
        __GLcoord *H = &(lsm->hHat);      // H is already normalized here
        GLfloat d0, d1, d2;
        
        if (w > 2)
        {
            /***** Diffuse *****/
            DOT (d0,N0,L);
            DOT (d1,N1,L);
            DOT (d2,N2,L);
            
            __glCalcForwardDifferences(w, d0, d1, d2, &pld->Ddel, 
                                    &pld->Ddel2);
            pld->Dcurr = d0;
            
            /***** Specular ******/
            DOT (d0, N0, H);
            DOT (d1, N1, H);
            DOT (d2, N2, H);
            
            __glCalcForwardDifferences(w, d0, d1, d2, &pld->Sdel, 
                                    &pld->Sdel2);
            pld->Scurr = d0;
        }
        else
        {
            /***** Diffuse *****/
            DOT (d0,(&n0),L);
            pld->Dcurr = d0;
            pld->Ddel = 0.0;
            pld->Ddel2 = 0.0;

            /***** Specular ******/
            DOT (d0,(&n0),H);
            pld->Scurr = d0;
            pld->Sdel = 0.0;
            pld->Sdel2 = 0.0;
        }
    }
    phong->numLights = curL;
}


void UpdateParamsAlongSpanAccel (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
  
    for (i=0; i<phong->numLights; i++)
    {
        __GLphongPerLightData *pld = &(phong->perLight[i]);
        
        /* Diffuse */
        pld->Dcurr += pld->Ddel; 
        pld->Ddel += pld->Ddel2;

        /* Specular */
        pld->Scurr += pld->Sdel; 
        pld->Sdel += pld->Sdel2;
    }
}


void UpdateNAlongSpanVan (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    phong->nTmp.x += phong->dndx.x;
    phong->nTmp.y += phong->dndx.y;
    phong->nTmp.z += phong->dndx.z;
}

void UpdateNEAlongSpanVan (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    phong->nTmp.x += phong->dndx.x;
    phong->nTmp.y += phong->dndx.y;
    phong->nTmp.z += phong->dndx.z;

    phong->eTmp.x += phong->dedx.x;
    phong->eTmp.y += phong->dedx.y;
    phong->eTmp.z += phong->dedx.z;
    phong->eTmp.w += phong->dedx.w;
}


GLboolean FASTCALL __glPhongCISpan(__GLcontext *gc)
{
    __GLcolor *cp, outColor;
    __GLfloat r, drdx;
    __GLcoord dndx;
    GLint w;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLboolean needColor = (gc->polygon.shader.phong.flags &
                           __GL_PHONG_NEED_COLOR_XPOLATE);

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;
  
    if (needColor)
    {
        phong->tmpColor.r = gc->polygon.shader.frag.color.r;
        drdx = gc->polygon.shader.drdx;
    }
    
    while (--w >= 0) 
    {
        /* Compute color using appropriate parameters */
        (*gc->procs.phong.ComputeCIColor) (gc, &outColor);

        cp->r = outColor.r;

        /* Update parameters */
        (*gc->procs.phong.UpdateAlongSpan) (gc);
        
        if (needColor)
            phong->tmpColor.r += drdx;

        cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glPhongRGBASpan (__GLcontext *gc)
{
    __GLcolor *cp, dcdx, outColor;
    __GLcoord dndx;
    GLint w;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLboolean needColor = (gc->polygon.shader.phong.flags &
                           __GL_PHONG_NEED_COLOR_XPOLATE);

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;

    if (needColor)
    {
        phong->tmpColor = gc->polygon.shader.frag.color;
        dcdx.r = gc->polygon.shader.drdx;
        dcdx.g = gc->polygon.shader.dgdx;
        dcdx.b = gc->polygon.shader.dbdx;
        dcdx.a = gc->polygon.shader.dadx;
    }
    
    while (--w >= 0) 
    {
        /* Compute color using appropriate parameters */
        (*gc->procs.phong.ComputeRGBColor) (gc, &outColor);
        
        cp->r = outColor.r;
        cp->g = outColor.g;
        cp->b = outColor.b;
        cp->a = outColor.a;
        
        /* Update parameters */
        (*gc->procs.phong.UpdateAlongSpan) (gc);
        
        if (needColor)
        {
            phong->tmpColor.r += dcdx.r;
            phong->tmpColor.g += dcdx.g;
            phong->tmpColor.b += dcdx.b;
            phong->tmpColor.a += dcdx.a;
        }
        cp++;
    }
    return GL_FALSE;
}


/*******************************************************************
 * RGB, Use Normal,                   Fast-lights, no ColorMaterial*
 *******************************************************************/
void ComputeRGBColorVanZippy (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLcoord n;
    __GLfloat nxi, nyi, nzi;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    GLuint numLights;
    __GLfloat rsi=0.0, gsi=0.0, bsi=0.0;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    ASSERTOPENGL (phong->flags & __GL_PHONG_INV_COLOR_VALID, 
                  "Zippy, invarient color should have been computed\n");
    ASSERTOPENGL (!(phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE), 
                  "Zippy, no need for color interpolation\n");

    n = phong->nTmp;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    if (face == __GL_FRONTFACE)
    {
        msm = &gc->light.front;
        nxi = n.x;
        nyi = n.y;
        nzi = n.z;
    }
    else
    {
        msm = &gc->light.back;
        nxi = -n.x;
        nyi = -n.y;
        nzi = -n.z;
    }

    rsi = phong->invColor.r;
    gsi = phong->invColor.g;
    bsi = phong->invColor.b;

    msm_alpha = msm->alpha;
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    
    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        __GLfloat n1, n2;
        
        lspmm = &lsm->front + face;
        
        /* Add in specular and diffuse effect of light, if any */
        n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
          nzi * lsm->unitVPpli.z;

        if (__GL_FLOAT_GTZ(n1))
        {
            n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * 
                  lsm->hHat.z) - msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                rsi += n2 * lspmm->specular.r;
                gsi += n2 * lspmm->specular.g;
                bsi += n2 * lspmm->specular.b;
            }
            rsi += n1 * lspmm->diffuse.r;
            gsi += n1 * lspmm->diffuse.g;
            bsi += n1 * lspmm->diffuse.b;
        }
    }
    __GL_CLAMP_R(outColor->r, gc, rsi);
    __GL_CLAMP_G(outColor->g, gc, gsi);
    __GL_CLAMP_B(outColor->b, gc, bsi);
    outColor->a = msm_alpha;
}


/*******************************************************************
 * RGB, Use Normal,                   Fast-lights, ColorMaterial   *
 *******************************************************************/
void ComputeRGBColorVanFast  (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat ri, gi, bi;
    __GLfloat alpha;
    __GLcolor emissiveAmbientI;
    __GLcolor inColor;
    __GLcolor diffuseSpecularI;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLcolor lm_ambient;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    GLuint    msm_colorMaterialChange;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    __GLcoord n;
    
    zero = __glZero;


    // Optimization: If no colors have been interpolated
    // Use the Zippy function
    if (!(phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE))
        ComputeRGBColorVanZippy  (gc, outColor);
    
    inColor = phong->tmpColor;

    n = phong->nTmp;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    if (face == __GL_FRONTFACE)
    {
        msm = &gc->light.front;
        nxi = n.x;
        nyi = n.y;
        nzi = n.z;
    }
    else
    {
        msm = &gc->light.back;
        nxi = -n.x;
        nyi = -n.y;
        nzi = -n.z;
    }

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;
    msm_colorMaterialChange = msm->colorMaterialChange;

    // Save latest colors normalized to 0..1
    ri = inColor.r * gc->oneOverRedVertexScale;
    gi = inColor.g * gc->oneOverGreenVertexScale;
    bi = inColor.b * gc->oneOverBlueVertexScale;
    alpha = inColor.a;

    // Compute invarient emissive and ambient components for this vertex.
    if (phong->flags & __GL_PHONG_INV_COLOR_VALID)
    {
        emissiveAmbientI.r = phong->invColor.r;
        emissiveAmbientI.g = phong->invColor.g;
        emissiveAmbientI.b = phong->invColor.b;
    }
    else
    {
        lm_ambient.r = gc->state.light.model.ambient.r;
        lm_ambient.g = gc->state.light.model.ambient.g;
        lm_ambient.b = gc->state.light.model.ambient.b;

        baseEmissiveAmbient.r = msm->paSceneColor.r;
        baseEmissiveAmbient.g = msm->paSceneColor.g;
        baseEmissiveAmbient.b = msm->paSceneColor.b;
        
        if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
        {
            emissiveAmbientI.r = baseEmissiveAmbient.r
              + ri * lm_ambient.r;
            emissiveAmbientI.g = baseEmissiveAmbient.g
              + gi * lm_ambient.g;
            emissiveAmbientI.b = baseEmissiveAmbient.b
              + bi * lm_ambient.b;

            // Add per-light per-material ambient
            for (lsm = gc->light.sources; lsm; lsm = lsm->next)
            {
                lss = lsm->state;
                emissiveAmbientI.r += ri * lss->ambient.r;
                emissiveAmbientI.g += gi * lss->ambient.g;
                emissiveAmbientI.b += bi * lss->ambient.b;
            }
        }
        else
        {
            for (lsm = gc->light.sources; lsm; lsm = lsm->next)
            {
                lspmm = &lsm->front + face;
                baseEmissiveAmbient.r += lspmm->ambient.r;
                baseEmissiveAmbient.g += lspmm->ambient.g;
                baseEmissiveAmbient.b += lspmm->ambient.b;
            }
            emissiveAmbientI.r = baseEmissiveAmbient.r + inColor.r;
            emissiveAmbientI.g = baseEmissiveAmbient.g + inColor.g;
            emissiveAmbientI.b = baseEmissiveAmbient.b + inColor.b;
        }
    }

    // Compute the diffuse and specular components for this vertex.

    diffuseSpecularI.r = zero;
    diffuseSpecularI.g = zero;
    diffuseSpecularI.b = zero;

    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        __GLfloat n1, n2;

        lss = lsm->state;
        lspmm = &lsm->front + face;

        /* Add in specular and diffuse effect of light, if any */
        n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
          nzi * lsm->unitVPpli.z;

        if (__GL_FLOAT_GTZ(n1))
        {
            n2 = nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
            n2 -= msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                {
                    /* Recompute per-light per-material cached specular */
                    diffuseSpecularI.r += n2 * ri * lss->specular.r;
                    diffuseSpecularI.g += n2 * gi * lss->specular.g;
                    diffuseSpecularI.b += n2 * bi * lss->specular.b;
                }
                else
                {
                    diffuseSpecularI.r += n2 * lspmm->specular.r;
                    diffuseSpecularI.g += n2 * lspmm->specular.g;
                    diffuseSpecularI.b += n2 * lspmm->specular.b;
                }
            }

            if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
            {
                /* Recompute per-light per-material cached diffuse */
                diffuseSpecularI.r += n1 * ri * lss->diffuse.r;
                diffuseSpecularI.g += n1 * gi * lss->diffuse.g;
                diffuseSpecularI.b += n1 * bi * lss->diffuse.b;
            }
            else
            {
                diffuseSpecularI.r += n1 * lspmm->diffuse.r;
                diffuseSpecularI.g += n1 * lspmm->diffuse.g;
                diffuseSpecularI.b += n1 * lspmm->diffuse.b;
            }
        }
    }

    __GL_CLAMP_R(outColor->r, gc, emissiveAmbientI.r + diffuseSpecularI.r);
    __GL_CLAMP_G(outColor->g, gc, emissiveAmbientI.g + diffuseSpecularI.g);
    __GL_CLAMP_B(outColor->b, gc, emissiveAmbientI.b + diffuseSpecularI.b);

    if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
    {
        __GL_CLAMP_A(outColor->a, gc, alpha);
    }
    else
        outColor->a = msm_alpha;
}


/*******************************************************************
 * RGB, Use Normal,                   Slow-lights, ColorMaterial   *
 *******************************************************************/
void ComputeRGBColorVanSlow  (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat ri, gi, bi;
    __GLfloat alpha;
    __GLfloat rsi, gsi, bsi;
    __GLcolor sceneColorI;
    __GLmaterialMachine *msm;
    __GLcolor inColor;
     __GLcolor lm_ambient;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    __GLcolor msm_paSceneColor;
    GLuint    msm_colorMaterialChange;
    GLboolean eyeWIsZero, localViewer;
    static __GLcoord Pe = { 0, 0, 0, 1 };
    __GLcoord n;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
 
    zero = __glZero;

    inColor = phong->tmpColor;

    n = phong->nTmp;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    if (face == __GL_FRONTFACE)
    {
        msm = &gc->light.front;
        nxi = n.x;
        nyi = n.y;
        nzi = n.z;
    }
    else
    {
        msm = &gc->light.back;
        nxi = -n.x;
        nyi = -n.y;
        nzi = -n.z;
    }
 
    lm_ambient.r = gc->state.light.model.ambient.r;
    lm_ambient.g = gc->state.light.model.ambient.g;
    lm_ambient.b = gc->state.light.model.ambient.b;

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;
    msm_colorMaterialChange = msm->colorMaterialChange;
    msm_paSceneColor = msm->paSceneColor;

    localViewer = gc->state.light.model.localViewer;

    // Get invarient scene color if there is no ambient or emissive color 
    // material.

    sceneColorI.r = msm_paSceneColor.r;
    sceneColorI.g = msm_paSceneColor.g;
    sceneColorI.b = msm_paSceneColor.b;

    if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        // Save latest colors normalized to 0..1
            
        ri = inColor.r * gc->oneOverRedVertexScale;
        gi = inColor.g * gc->oneOverGreenVertexScale;
        bi = inColor.b * gc->oneOverBlueVertexScale;
        alpha = inColor.a;

        // Compute scene color.
        // If color has not changed, the previous sceneColorI values are 
        // used!

        if (msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT | 
                                       __GL_MATERIAL_EMISSIVE))
        {
            if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
            {
                sceneColorI.r = msm_paSceneColor.r + ri * lm_ambient.r;
                sceneColorI.g = msm_paSceneColor.g + gi * lm_ambient.g;
                sceneColorI.b = msm_paSceneColor.b + bi * lm_ambient.b;
            }
            else
            {
                sceneColorI.r = msm_paSceneColor.r + inColor.r;
                sceneColorI.g = msm_paSceneColor.g + inColor.g;
                sceneColorI.b = msm_paSceneColor.b + inColor.b;
            }
        }
    }
        
    // Compute the diffuse and specular components for this vertex.
    rsi = sceneColorI.r;
    gsi = sceneColorI.g;
    bsi = sceneColorI.b;

    eyeWIsZero = __GL_FLOAT_EQZ(phong->eTmp.w);
    
    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        __GLfloat n1, n2;
            
        lss = lsm->state;
        lspmm = &lsm->front + face;
            
        if (lsm->slowPath || eyeWIsZero)
        {
            __GLcoord hHat, vPli, vPliHat, vPeHat;
            __GLfloat att, attSpot;
            __GLfloat hv[3];
                
            /* Compute unit h[i] */
            __glVecSub4(&vPli, &phong->eTmp, &lsm->position);
            __glNormalize(&vPliHat.x, &vPli.x);
            if (localViewer)
            {
                __glVecSub4(&vPeHat, &phong->eTmp, &Pe);
                __glNormalize(&vPeHat.x, &vPeHat.x);
                hv[0] = vPliHat.x + vPeHat.x;
                hv[1] = vPliHat.y + vPeHat.y;
                hv[2] = vPliHat.z + vPeHat.z;
            }
            else
            {
                hv[0] = vPliHat.x;
                hv[1] = vPliHat.y;
                hv[2] = vPliHat.z + __glOne;
            }
            __glNormalize(&hHat.x, hv);
                
            /* Compute attenuation */
            if (__GL_FLOAT_NEZ(lsm->position.w))
            {
                __GLfloat k0, k1, k2, dist;
                    
                k0 = lsm->constantAttenuation;
                k1 = lsm->linearAttenuation;
                k2 = lsm->quadraticAttenuation;
                if (__GL_FLOAT_EQZ(k1) && __GL_FLOAT_EQZ(k2))
                {
                    /* Use pre-computed 1/k0 */
                    att = lsm->attenuation;
                }
                else
                {
                    __GLfloat den;

                    dist = __GL_SQRTF(vPli.x*vPli.x + vPli.y*vPli.y
                                      + vPli.z*vPli.z);
                    den = k0 + k1 * dist + k2 * dist * dist;
                    att = __GL_FLOAT_EQZ(den) ? __glOne : __glOne / den;
                }
            }
            else
            {
                att = __glOne;
            }
                
            /* Compute spot effect if light is a spot light */
            attSpot = att;
            if (lsm->isSpot)
            {
                __GLfloat dot, px, py, pz;
                    
                px = -vPliHat.x;
                py = -vPliHat.y;
                pz = -vPliHat.z;
                dot = px * lsm->direction.x + py * lsm->direction.y
                      + pz * lsm->direction.z;
                if ((dot >= lsm->threshold) && (dot >= lsm->cosCutOffAngle))
                {
                    GLint ix = (GLint)((dot - lsm->threshold) * lsm->scale 
                                       + __glHalf);
                    if (ix < __GL_SPOT_LOOKUP_TABLE_SIZE)
                        attSpot = att * lsm->spotTable[ix];
                }
                else
                {
                    attSpot = zero;
                }
            }
                
            /* Add in remaining effect of light, if any */
            if (attSpot)
            {
                __GLfloat n1, n2;
                __GLcolor sum;
                    
                if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
                {
                    sum.r = ri * lss->ambient.r;
                    sum.g = gi * lss->ambient.g;
                    sum.b = bi * lss->ambient.b;
                }
                else
                {
                    sum.r = lspmm->ambient.r;
                    sum.g = lspmm->ambient.g;
                    sum.b = lspmm->ambient.b;
                }
                    
                n1 = nxi * vPliHat.x + nyi * vPliHat.y + nzi * vPliHat.z;
                if (__GL_FLOAT_GTZ(n1))
                {
                    n2 = nxi * hHat.x + nyi * hHat.y + nzi * hHat.z;
                    n2 -= msm_threshold;
                    if (__GL_FLOAT_GEZ(n2))
                    {
                        __GLfloat fx = n2 * msm_scale + __glHalf;
                        if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                            n2 = msm_specTable[(GLint)fx];
                        else
                            n2 = __glOne;
                        if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                        {
                            /* Recompute per-light per-material cached specular */
                            sum.r += n2 * ri * lss->specular.r;
                            sum.g += n2 * gi * lss->specular.g;
                            sum.b += n2 * bi * lss->specular.b;
                        }
                        else
                        {
                            sum.r += n2 * lspmm->specular.r;
                            sum.g += n2 * lspmm->specular.g;
                            sum.b += n2 * lspmm->specular.b;
                        }
                    }
                    if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
                    {
                        /* Recompute per-light per-material cached diffuse */
                        sum.r += n1 * ri * lss->diffuse.r;
                        sum.g += n1 * gi * lss->diffuse.g;
                        sum.b += n1 * bi * lss->diffuse.b;
                    }
                    else
                    {
                        sum.r += n1 * lspmm->diffuse.r;
                        sum.g += n1 * lspmm->diffuse.g;
                        sum.b += n1 * lspmm->diffuse.b;
                    }
                }
                    
                rsi += attSpot * sum.r;
                gsi += attSpot * sum.g;
                bsi += attSpot * sum.b;
            }
        }
        else
        {
            __GLfloat n1, n2;
                
            if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
            {
                rsi += ri * lss->ambient.r;
                gsi += gi * lss->ambient.g;
                bsi += bi * lss->ambient.b;
            }
            else
            {
                rsi += lspmm->ambient.r;
                gsi += lspmm->ambient.g;
                bsi += lspmm->ambient.b;
            }
                
            /* Add in specular and diffuse effect of light, if any */
            n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                 nzi * lsm->unitVPpli.z;
            if (__GL_FLOAT_GTZ(n1))
            {
                n2= nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                n2 -= msm_threshold;
                if (__GL_FLOAT_GEZ(n2)) 
                {
                    __GLfloat fx = n2 * msm_scale + __glHalf;
                    if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                        n2 = msm_specTable[(GLint)fx];
                    else
                        n2 = __glOne;
                    if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                    {
                        /* Recompute per-light per-material cached specular */
                        rsi += n2 * ri * lss->specular.r;
                        gsi += n2 * gi * lss->specular.g;
                        bsi += n2 * bi * lss->specular.b;
                    }
                    else
                    {
                        rsi += n2 * lspmm->specular.r;
                        gsi += n2 * lspmm->specular.g;
                        bsi += n2 * lspmm->specular.b;
                    }
                }
                if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
                {
                    /* Recompute per-light per-material cached diffuse */
                    rsi += n1 * ri * lss->diffuse.r;
                    gsi += n1 * gi * lss->diffuse.g;
                    bsi += n1 * bi * lss->diffuse.b;
                }
                else
                {
                    rsi += n1 * lspmm->diffuse.r;
                    gsi += n1 * lspmm->diffuse.g;
                    bsi += n1 * lspmm->diffuse.b;
                }
            }
        }
    }
        
    __GL_CLAMP_R(outColor->r, gc, rsi);
    __GL_CLAMP_G(outColor->g, gc, gsi);
    __GL_CLAMP_B(outColor->b, gc, bsi);
          
    if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
    {
        __GL_CLAMP_A(outColor->a, gc, alpha);
    }
    else
        outColor->a = msm_alpha;
}

/*******************************************************************
 * RGB, Use Dot,                Fast-lights, no ColorMaterial      *
 *******************************************************************/
void ComputeRGBColorAccelZippy (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    GLuint numLights;
    __GLfloat rsi=0.0, gsi=0.0, bsi=0.0;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLint curL;

    if (face == __GL_FRONTFACE)
        msm = &gc->light.front;
    else
        msm = &gc->light.back;

    ASSERTOPENGL (phong->flags & __GL_PHONG_INV_COLOR_VALID, 
                  "Zippy, invarient color should have been computed\n");
    ASSERTOPENGL (!(phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE), 
                  "Zippy, no need for color interpolation\n");

    rsi = phong->invColor.r;
    gsi = phong->invColor.g;
    bsi = phong->invColor.b;
    msm_alpha = msm->alpha;
   
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    
    for (lsm = gc->light.sources, curL = 0; lsm; lsm = lsm->next, curL++)
    {
        __GLfloat n1, n2, x, y, x2, y2;
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        __GLfloat a, b, c, d, e, f, g, h, i;   
        
        /* Add in specular and diffuse effect of light, if any */
        n1 = pld->Dcurr;
        lspmm = &lsm->front + face;
        if (__GL_FLOAT_GTZ(n1))
        {
#ifdef __FASTEST
            n2 = pld->Scurr - msm_threshold;
#endif //__FASTEST
#ifdef __SLOW
            x = phong->tmp_pos.x; x2 = x*x;
            y = phong->tmp_pos.y; y2 = y*y;

            a = pld->A[0]; b = pld->A[1];
            c = pld->A[2]; d = pld->A[3];
            e = pld->A[4]; f = pld->A[5];
            g = pld->A[6]; h = pld->A[7];
            i = pld->A[8];
        
            n2 = (a*x+b*y+c)/__GL_SQRTF(d*x2+e*x*y+f*y2+g*x+h*y+i);
#endif //__SLOW
#ifdef __FASTER
            x = phong->tmp_pos.x; x2 = x*x;
            y = phong->tmp_pos.y; y2 = y*y;

            n2 = pld->S[5]*x2 + pld->S[4]*x*y + pld->S[3]*y2 + pld->S[2]*x + 
              pld->S[1]*y + pld->S[0];
#endif //__FASTER
        
            //n2 -= msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                rsi += n2 * lspmm->specular.r;
                gsi += n2 * lspmm->specular.g;
                bsi += n2 * lspmm->specular.b;
                
            }
            rsi += n1 * lspmm->diffuse.r;
            gsi += n1 * lspmm->diffuse.g;
            bsi += n1 * lspmm->diffuse.b;
        }
    }
    __GL_CLAMP_R(outColor->r, gc, rsi);
    __GL_CLAMP_G(outColor->g, gc, gsi);
    __GL_CLAMP_B(outColor->b, gc, bsi);
    outColor->a = msm_alpha;
}


/*******************************************************************
 * RGB, Use Dot,                Fast-lights, ColorMaterial         *
 *******************************************************************/
void ComputeRGBColorAccelFast  (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLfloat zero;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat ri, gi, bi;
    __GLfloat alpha;
    __GLcolor emissiveAmbientI;
    __GLcolor inColor;
    __GLcolor diffuseSpecularI;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLcolor lm_ambient;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    GLuint    msm_colorMaterialChange;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLint curL;
    
    zero = __glZero;

    if (face == __GL_FRONTFACE)
        msm = &gc->light.front;
    else
        msm = &gc->light.back;

    msm_colorMaterialChange = msm->colorMaterialChange;

    ASSERTOPENGL (phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE, 
                  "Fast, need  color interpolation\n");
#if 0
    ASSERTOPENGL (!(gc->state.enables.general & __GL_NORMALIZE_ENABLE), 
                  "Normalization should have been disabled\n");
#endif

    inColor = phong->tmpColor;
    
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;

    // Save latest colors normalized to 0..1
    ri = inColor.r * gc->oneOverRedVertexScale;
    gi = inColor.g * gc->oneOverGreenVertexScale;
    bi = inColor.b * gc->oneOverBlueVertexScale;
    alpha = inColor.a;

    // Compute invarient emissive and ambient components for this vertex.
    if (phong->flags & __GL_PHONG_INV_COLOR_VALID)
    {
        emissiveAmbientI.r = phong->invColor.r;
        emissiveAmbientI.g = phong->invColor.g;
        emissiveAmbientI.b = phong->invColor.b;
    }
    else
    {
        lm_ambient.r = gc->state.light.model.ambient.r;
        lm_ambient.g = gc->state.light.model.ambient.g;
        lm_ambient.b = gc->state.light.model.ambient.b;

        baseEmissiveAmbient.r = msm->paSceneColor.r;
        baseEmissiveAmbient.g = msm->paSceneColor.g;
        baseEmissiveAmbient.b = msm->paSceneColor.b;
        
        if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
        {
            emissiveAmbientI.r = baseEmissiveAmbient.r
              + ri * lm_ambient.r;
            emissiveAmbientI.g = baseEmissiveAmbient.g
              + gi * lm_ambient.g;
            emissiveAmbientI.b = baseEmissiveAmbient.b
              + bi * lm_ambient.b;

            // Add per-light per-material ambient
            for (lsm = gc->light.sources; lsm; lsm = lsm->next)
            {
                lss = lsm->state;
                emissiveAmbientI.r += ri * lss->ambient.r;
                emissiveAmbientI.g += gi * lss->ambient.g;
                emissiveAmbientI.b += bi * lss->ambient.b;
            }
        }
        else
        {
            for (lsm = gc->light.sources; lsm; lsm = lsm->next)
            {
                lspmm = &lsm->front + face;
                baseEmissiveAmbient.r += lspmm->ambient.r;
                baseEmissiveAmbient.g += lspmm->ambient.g;
                baseEmissiveAmbient.b += lspmm->ambient.b;
            }
            emissiveAmbientI.r = baseEmissiveAmbient.r + inColor.r;
            emissiveAmbientI.g = baseEmissiveAmbient.g + inColor.g;
            emissiveAmbientI.b = baseEmissiveAmbient.b + inColor.b;
        }
    }

    // Compute the diffuse and specular components for this vertex.
    diffuseSpecularI.r = zero;
    diffuseSpecularI.g = zero;
    diffuseSpecularI.b = zero;

    for (lsm = gc->light.sources, curL=0; lsm; lsm = lsm->next, curL++)
    {
        __GLfloat n1, n2;
        __GLphongPerLightData *pld = &(phong->perLight[curL]);

        lss = lsm->state;
        lspmm = &lsm->front + face;

        /* Add in specular and diffuse effect of light, if any */
        n1 = pld->Dcurr;

        if (__GL_FLOAT_GTZ(n1))
        {
            n2 = pld->Scurr - msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                {
                    /* Recompute per-light per-material cached specular */
                    diffuseSpecularI.r += n2 * ri * lss->specular.r;
                    diffuseSpecularI.g += n2 * gi * lss->specular.g;
                    diffuseSpecularI.b += n2 * bi * lss->specular.b;
                }
                else
                {
                    diffuseSpecularI.r += n2 * lspmm->specular.r;
                    diffuseSpecularI.g += n2 * lspmm->specular.g;
                    diffuseSpecularI.b += n2 * lspmm->specular.b;
                }
            }

            if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
            {
                /* Recompute per-light per-material cached diffuse */
                diffuseSpecularI.r += n1 * ri * lss->diffuse.r;
                diffuseSpecularI.g += n1 * gi * lss->diffuse.g;
                diffuseSpecularI.b += n1 * bi * lss->diffuse.b;
            }
            else
            {
                diffuseSpecularI.r += n1 * lspmm->diffuse.r;
                diffuseSpecularI.g += n1 * lspmm->diffuse.g;
                diffuseSpecularI.b += n1 * lspmm->diffuse.b;
            }
        }
    }

    __GL_CLAMP_R(outColor->r, gc, emissiveAmbientI.r + diffuseSpecularI.r);
    __GL_CLAMP_G(outColor->g, gc, emissiveAmbientI.g + diffuseSpecularI.g);
    __GL_CLAMP_B(outColor->b, gc, emissiveAmbientI.b + diffuseSpecularI.b);

    if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
    {
        __GL_CLAMP_A(outColor->a, gc, alpha);
    }
    else
        outColor->a = msm_alpha;
}


/*******************************************************************
 * CI, Vanilla,                      Fast-lights                   *
 *******************************************************************/
void ComputeCIColorVanFast (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLfloat zero;
    __GLcoord n;
    __GLfloat nxi, nyi, nzi;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLmaterialState *ms;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;
    GLuint numLights;
    __GLfloat ms_cmapa, ms_cmapd, ms_cmaps;
    __GLfloat ci, si, di;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLfloat   redMaxF;
    GLint     redMaxI;

    zero = __glZero;

    n = phong->nTmp;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        msm = &gc->light.front;
        nxi = n.x;
        nyi = n.y;
        nzi = n.z;
    }
    else
    {
        ms  = &gc->state.light.back;
        msm = &gc->light.back;
        nxi = -n.x;
        nyi = -n.y;
        nzi = -n.z;
    }
    
    ASSERTOPENGL (!(phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE), 
                  "Zippy, no need for color interpolation\n");
   
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    ms_cmapa = ms->cmapa;
    ms_cmapd = ms->cmapd;
    ms_cmaps = ms->cmaps;
    redMaxF = (GLfloat) gc->frontBuffer.redMax;
    redMaxI = (GLint) gc->frontBuffer.redMax;
    
    si = zero;
    di = zero;

    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        __GLfloat n1, n2;
        
        lspmm = &lsm->front + face;
        
        /* Add in specular and diffuse effect of light, if any */
        n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
          nzi * lsm->unitVPpli.z;

        if (__GL_FLOAT_GTZ(n1))
        {
            n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * 
                  lsm->hHat.z) - msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                si += n2 * lsm->sli;
            }
            di += n1 * lsm->dli;
        }
    }

	/* Compute final color */
	if (si > __glOne)
	    si = __glOne;

	ci = ms_cmapa + (__glOne - si) * di * (ms_cmapd - ms_cmapa)
	    + si * (ms_cmaps - ms_cmapa);

    // need to mask color index before color clipping
	if (ci > redMaxF) 
    {
	    GLfloat fraction;
	    GLint integer;

	    integer = (GLint) ci;
	    fraction = ci - (GLfloat) integer;
	    integer = integer & redMaxI;
	    ci = (GLfloat) integer + fraction;
	} 
    else if (ci < 0) 
    {
	    GLfloat fraction;
	    GLint integer;

	    integer = (GLint) __GL_FLOORF(ci);
	    fraction = ci - (GLfloat) integer;
	    integer = integer & redMaxI;
	    ci = (GLfloat) integer + fraction;
	}

    outColor->r = ci;
}


/*******************************************************************
 * CI, Vanilla,                      Slow-lights                   *
 *******************************************************************/
void ComputeCIColorVanSlow  (__GLcontext *gc, __GLcolor *outColor)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourceMachine *lsm;
    __GLmaterialState *ms;
    __GLmaterialMachine *msm;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;
    __GLfloat ms_cmapa, ms_cmapd, ms_cmaps;
    __GLfloat ci, si, di;
    GLfloat   redMaxF;
    GLint     redMaxI;
    GLboolean eyeWIsZero, localViewer;
    static __GLcoord Pe = { 0, 0, 0, 1 };
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    __GLcoord n;


    zero = __glZero;

    n = phong->nTmp;
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        msm = &gc->light.front;
        nxi = n.x;
        nyi = n.y;
        nzi = n.z;
    }
    else
    {
        ms  = &gc->state.light.back;
        msm = &gc->light.back;
        nxi = -n.x;
        nyi = -n.y;
        nzi = -n.z;
    }
    
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    ms_cmapa = ms->cmapa;
    ms_cmapd = ms->cmapd;
    ms_cmaps = ms->cmaps;
    localViewer = gc->state.light.model.localViewer;
    redMaxF = (GLfloat) gc->frontBuffer.redMax;
    redMaxI = (GLint) gc->frontBuffer.redMax;


    si = zero;
    di = zero;

    eyeWIsZero = __GL_FLOAT_EQZ(phong->eTmp.w);

    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        if (lsm->slowPath || eyeWIsZero)
        {
            __GLfloat n1, n2, att, attSpot;
            __GLcoord vPliHat, vPli, hHat, vPeHat;
            __GLfloat hv[3];

            /* Compute vPli, hi (normalized) */
            __glVecSub4(&vPli, &phong->eTmp, &lsm->position);
            __glNormalize(&vPliHat.x, &vPli.x);
            if (localViewer)
            {
                __glVecSub4(&vPeHat, &phong->eTmp, &Pe);
                __glNormalize(&vPeHat.x, &vPeHat.x);
                hv[0] = vPliHat.x + vPeHat.x;
                hv[1] = vPliHat.y + vPeHat.y;
                hv[2] = vPliHat.z + vPeHat.z;
            }
            else
            {
                hv[0] = vPliHat.x;
                hv[1] = vPliHat.y;
                hv[2] = vPliHat.z + __glOne;
            }
            __glNormalize(&hHat.x, hv);

            /* Compute attenuation */
            if (__GL_FLOAT_NEZ(lsm->position.w))
            {
                __GLfloat k0, k1, k2, dist;

                k0 = lsm->constantAttenuation;
                k1 = lsm->linearAttenuation;
                k2 = lsm->quadraticAttenuation;
                if (__GL_FLOAT_EQZ(k1) && __GL_FLOAT_EQZ(k2))
                {
                    /* Use pre-computed 1/k0 */
                    att = lsm->attenuation;
                }
                else
                {
                    __GLfloat den;

                    dist = __GL_SQRTF(vPli.x*vPli.x + vPli.y*vPli.y
                                      + vPli.z*vPli.z);
                    den = k0 + k1 * dist + k2 * dist * dist;
                    att = __GL_FLOAT_EQZ(den) ? __glOne : __glOne / den;
                }
            }
            else
            {
                att = __glOne;
            }

            /* Compute spot effect if light is a spot light */
            attSpot = att;
            if (lsm->isSpot)
            {
                __GLfloat dot, px, py, pz;

                px = -vPliHat.x;
                py = -vPliHat.y;
                pz = -vPliHat.z;
                dot = px * lsm->direction.x + py * lsm->direction.y
                      + pz * lsm->direction.z;
                if ((dot >= lsm->threshold) && (dot >= lsm->cosCutOffAngle))
                {
                    GLint ix = (GLint)((dot - lsm->threshold) * lsm->scale 
                                       + __glHalf);
                    if (ix < __GL_SPOT_LOOKUP_TABLE_SIZE)
                        attSpot = att * lsm->spotTable[ix];
                }
                else
                {
                  attSpot = zero;
                }
            }

            /* Add in remaining effect of light, if any */
            if (attSpot)
            {
                n1 = nxi * vPliHat.x + nyi * vPliHat.y + nzi * vPliHat.z;
                if (__GL_FLOAT_GTZ(n1)) 
                {
                    n2 = nxi * hHat.x + nyi * hHat.y + nzi * hHat.z;
                    n2 -= msm_threshold;
                    if (__GL_FLOAT_GEZ(n2))
                    {
                        __GLfloat fx = n2 * msm_scale + __glHalf;
                        if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                            n2 = msm_specTable[(GLint)fx];
                        else
                            n2 = __glOne;
                        si += attSpot * n2 * lsm->sli;
                    }
                    di += attSpot * n1 * lsm->dli;
                }
            }
        }
        else
        {
            __GLfloat n1, n2;

            /* Compute specular contribution */
            n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                 nzi * lsm->unitVPpli.z;
            if (__GL_FLOAT_GTZ(n1))
            {
                n2= nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                n2 -= msm_threshold;
                if (__GL_FLOAT_GEZ(n2))
                {
                    __GLfloat fx = n2 * msm_scale + __glHalf;
                    if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                        n2 = msm_specTable[(GLint)fx];
                    else
                        n2 = __glOne;
                    si += n2 * lsm->sli;
                }
                di += n1 * lsm->dli;
            }
        }
    }

    /* Compute final color */
    if (si > __glOne)
        si = __glOne;

    ci = ms_cmapa + (__glOne - si) * di * (ms_cmapd - ms_cmapa)
        + si * (ms_cmaps - ms_cmapa);
    if (ci > ms_cmaps)
        ci = ms_cmaps;

    // need to mask color index before color clipping

    if (ci > redMaxF) 
    {
        GLfloat fraction;
        GLint integer;

        integer = (GLint) ci;
        fraction = ci - (GLfloat) integer;
        integer = integer & redMaxI;
        ci = (GLfloat) integer + fraction;
    } 
    else if (ci < 0) 
    {
        GLfloat fraction;
        GLint integer;

        integer = (GLint) __GL_FLOORF(ci);
        fraction = ci - (GLfloat) integer;
        integer = integer & redMaxI;
        ci = (GLfloat) integer + fraction;
    }
    outColor->r = ci;
}



/*******************************************************************
 * CI, Fast-lights, Fast-path                                      *
 *******************************************************************/
void ComputeCIColorAccelFast (__GLcontext *gc, __GLcolor *outColor)
{
    __GLfloat zero;
    GLint face = gc->polygon.shader.phong.face;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLmaterialState *ms;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;
    GLuint numLights;
    __GLfloat ms_cmapa, ms_cmapd, ms_cmaps;
    __GLfloat ci, si, di;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLfloat   redMaxF;
    GLint     redMaxI;
    GLint curL;

    zero = __glZero;

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        msm = &gc->light.front;
    }
    else
    {
        ms  = &gc->state.light.back;
        msm = &gc->light.back;
    }
    

    ASSERTOPENGL (!(phong->flags & __GL_PHONG_NEED_COLOR_XPOLATE), 
                  "Zippy, no need for color interpolation\n");
   
    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    ms_cmapa = ms->cmapa;
    ms_cmapd = ms->cmapd;
    ms_cmaps = ms->cmaps;
    redMaxF = (GLfloat) gc->frontBuffer.redMax;
    redMaxI = (GLint) gc->frontBuffer.redMax;
    
    si = zero;
    di = zero;

    for (lsm = gc->light.sources, curL=0; lsm; lsm = lsm->next, curL++)
    {
        __GLfloat n1, n2;
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        
        lspmm = &lsm->front + face;
        
        /* Add in specular and diffuse effect of light, if any */
        n1 = pld->Dcurr;
        if (__GL_FLOAT_GTZ(n1))
        {
            n2 = pld->Scurr - msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
                __GLfloat fx = n2 * msm_scale + __glHalf;
                
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
                si += n2 * lsm->sli;
            }
            di += n1 * lsm->dli;
        }
    }

	/* Compute final color */
	if (si > __glOne)
	    si = __glOne;

	ci = ms_cmapa + (__glOne - si) * di * (ms_cmapd - ms_cmapa)
	    + si * (ms_cmaps - ms_cmapa);

    // need to mask color index before color clipping
	if (ci > redMaxF) 
    {
	    GLfloat fraction;
	    GLint integer;

	    integer = (GLint) ci;
	    fraction = ci - (GLfloat) integer;
	    integer = integer & redMaxI;
	    ci = (GLfloat) integer + fraction;
	} 
    else if (ci < 0) 
    {
	    GLfloat fraction;
	    GLint integer;

	    integer = (GLint) __GL_FLOORF(ci);
	    fraction = ci - (GLfloat) integer;
	    integer = integer & redMaxI;
	    ci = (GLfloat) integer + fraction;
	}

    outColor->r = ci;
}


void ComputePhongInvarientRGBColor (__GLcontext *gc)
{
    GLint face = gc->polygon.shader.phong.face;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLmaterialMachine *msm;
    __GLfloat msm_alpha;
    __GLfloat rsi, gsi, bsi;
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    if (face == __GL_FRONTFACE)
        msm = &gc->light.front;
    else
        msm = &gc->light.back;

    // Compute invarient emissive and ambient components for this vertex.

    rsi = msm->paSceneColor.r;
    gsi = msm->paSceneColor.g;
    bsi = msm->paSceneColor.b;

    // add invarient per-light per-material cached ambient

    for (lsm = gc->light.sources; lsm; lsm = lsm->next)
    {
        lspmm = &lsm->front + face;
        rsi += lspmm->ambient.r;
        gsi += lspmm->ambient.g;
        bsi += lspmm->ambient.b;
    }
    phong->invColor.r = rsi;
    phong->invColor.g = gsi;
    phong->invColor.b = bsi;
}

void FASTCALL __glGenericPickPhongProcs(__GLcontext *gc)
{
    __GLlightSourceMachine *lsm;
    GLboolean anySlow = GL_FALSE;
    GLboolean colorMaterial = (gc->state.enables.general & 
                               __GL_COLOR_MATERIAL_ENABLE);
    GLboolean rgb_mode = (gc->polygon.shader.modeFlags & __GL_SHADE_RGB);
    GLboolean normalize = (gc->state.enables.general & __GL_NORMALIZE_ENABLE);
    GLboolean doVanilla = GL_FALSE;
    
    gc->polygon.shader.phong.flags = 0;
    for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
        if (lsm->slowPath) {
            anySlow = GL_TRUE;
            // Assuming here that anySlow means need Eye XPolate
            gc->polygon.shader.phong.flags |= __GL_PHONG_NEED_EYE_XPOLATE;
            break;
        }
    }
    
    doVanilla = (!(gc->state.enables.general & __GL_NORMALIZE_ENABLE)
                 || (anySlow)
                 || (gc->state.enables.general & __GL_POLYGON_SMOOTH_ENABLE)
                 || (gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE)
        );
    
    
    if ((gc->state.hints.phong == GL_NICEST) || doVanilla)
    {
        gc->procs.phong.InitLineParams = InitLineParamsVan;
        
        if (anySlow)
        {
            gc->procs.phong.InitSpanInterpolation = InitSpanNEInterpolationVan;
            gc->procs.phong.UpdateAlongSpan = UpdateNEAlongSpanVan;
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorVanSlow;
            gc->procs.phong.ComputeCIColor = ComputeCIColorVanSlow;
        }
        else
        {
            gc->procs.phong.InitSpanInterpolation = InitSpanNInterpolationVan;
            gc->procs.phong.UpdateAlongSpan = UpdateNAlongSpanVan;
            gc->procs.phong.ComputeCIColor = ComputeCIColorVanFast;
            if (colorMaterial)
            {
                gc->procs.phong.ComputeRGBColor = ComputeRGBColorVanFast;
            }
            else
            {
                gc->procs.phong.ComputeRGBColor = ComputeRGBColorVanZippy;
            }
        }
    }
    else
    {
        ASSERTOPENGL (!anySlow, "Slow lights currently turned off\n");
        
        gc->procs.phong.InitSpanInterpolation = InitSpanInterpolationAccel;
        gc->procs.phong.UpdateAlongSpan = UpdateParamsAlongSpanAccel;
        gc->procs.phong.InitLineParams    = InitLineParamsAccel;
        gc->procs.phong.ComputeCIColor = ComputeCIColorAccelFast;
        
        if (colorMaterial)
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelFast;
        else
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelZippy;
        
    }
}

void __glCalcForwardDifferences( GLint w, __GLfloat p0, __GLfloat p1,
        __GLfloat p2, __GLfloat *d1, __GLfloat *d2 )
{
// Compute quadratic forward differences along a span of length w, from
// points p0, p1, p2
    __GLfloat dx;
    __GLfloat a0, a1, a2;

    if( w < 2 ) {
        *d1 = *d2 = 0.0f;
        return;
    }

    dx = 1.0f / w; // normalization factor

    // quadratic polynomial coefficients
    a0 = p0;
    a1 = ( -3.0f*p0 + 4.0f*p1 - p2) * dx;
    a2 = 2.0f * (p0 - 2.0f*p1 + p2) * dx * dx;

#ifdef __DEBUG_PRINT
    DbgPrint ("a2=%f, a1=%f, a0=%f\n", a2, a1, a0);
#endif
    // forward difference parameters
    *d1 = a1 + a2;
    *d2 = 2.0f * a2;
}



#ifdef __JUNKED_CODE
void InitSpanInterpolationFast (__GLcontext *gc)
{
    GLint i;
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    
    phong->tmp_pos.x = phong->cur_pos.x;
    phong->tmp_pos.y = phong->cur_pos.y;
    
    for (i=0; i<phong->numLights; i++)
    {
        __GLphongPerLightData *pld = &(phong->perLight[i]);
        
        /* Diffuse */
        pld->D_tmp = pld->D_curr;
        pld->Ddel_tmp = pld->DdelSpan;

        /* Specular */
        pld->S_tmp = pld->S_curr;
        pld->Sdel_tmp = pld->SdelSpan;
    }
}


#ifdef __TWO
        ASSERTOPENGL (!anySlow, "Slow lights currently turned off\n");

        gc->procs.phong.InitInterpolation = InitializePhongInterpolationVan;
        gc->procs.phong.SetInitParams = SetInitialPhongInterpolationVan;
        gc->procs.phong.UpdateAlongEdge = UpdateParamsAlongEdgeVan;
        
        gc->procs.phong.InitSpanInterpolation = InitSpanInterpolationTWO;
        gc->procs.phong.UpdateAlongSpan = UpdateParamsAlongSpanFast;
        
        //Line related
        gc->procs.phong.InitLineParams    = InitLineParamsFast;

        if (colorMaterial)
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelFast;
        else
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelZippy;
#else
        gc->procs.phong.InitInterpolation = InitializePhongInterpolationFast;
        gc->procs.phong.SetInitParams     = SetInitialPhongInterpolationFast;
        gc->procs.phong.UpdateAlongEdge   = UpdateParamsAlongEdgeFast;
        gc->procs.phong.InitSpanInterpolation = InitSpanInterpolationFast;
        gc->procs.phong.UpdateAlongSpan   = UpdateParamsAlongSpanFast;
        gc->procs.phong.ComputeCIColor    = ComputeCIColorAccelFast;

        //Line related
        gc->procs.phong.InitLineParams    = InitLineParamsFast;

        if (colorMaterial)
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelFast;
        else
            gc->procs.phong.ComputeRGBColor = ComputeRGBColorAccelZippy;
#endif

void InitSpanInterpolationTWO (__GLcontext *gc)
{
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    GLint face = phong->face;
    __GLlightSourceMachine *lsm;
    //__GLmaterialMachine *msm;
    __GLcoord n, dndx;
    __GLcoord *A = &dndx;
    __GLcoord *C = &n;
    __GLfloat a, b, c, d, e, f, g, h, i;   
    GLint curL;
    

    if (face == __GL_FRONTFACE)
    {
        //msm = &gc->light.front;
        n.x = phong->nCur.x;
        n.y = phong->nCur.y;
        n.z = phong->nCur.z;

        dndx.x = phong->dndx.x;
        dndx.y = phong->dndx.y;
        dndx.z = phong->dndx.z;
    }
    else
    {
        //msm = &gc->light.back;
        n.x = -phong->nCur.x;
        n.y = -phong->nCur.y;
        n.z = -phong->nCur.z;

        dndx.x = -phong->dndx.x;
        dndx.y = -phong->dndx.y;
        dndx.z = -phong->dndx.z;
    }
    
    if (gc->state.enables.general & __GL_NORMALIZE_ENABLE)
        __glNormalize(&n.x, &n.x);
    
    MAGN2 (d,A);                  //d = A.A 
    DOT   (g,A,C); g *= 2.0;      //g = 2A.C
    MAGN2 (i,C);                  //i = C.C

    for (lsm = gc->light.sources, curL=0; lsm; lsm = lsm->next, curL++)
    {
        __GLfloat i2, iRt, tmp5, tmp2;
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        __GLcoord *L = &(lsm->unitVPpli); // L is already normalized here
        __GLcoord *H = &(lsm->hHat);      // H is already normalized here
        
        i2 = (i*i);
        iRt = __GL_SQRTF(i);

        /***** Diffuse *****/
        // Remaining Bishop parameters
        DOT (a,L,A);              //a = L.A/|L|
        DOT (c,L,C);              //c = L.C/|L|

        tmp2 = (2.0*a*i - c*g)/(2.0*i*iRt);
        tmp5 = (3.0*c*g*g - 4.0*c*d*i - 4.0*a*g*i)/(8.0*i2*iRt);

        // Constant deltas
        pld->Ddel2Span = 2*tmp5;
        pld->Ddel_tmp = tmp2 + tmp5;
        pld->D_tmp = c/iRt;

        /***** Specular ******/
        // Remaining Bishop parameters
        DOT (a,H,A);              //a = H.A/|H|
        DOT (c,H,C);              //c = H.C/|H|

        // Polynomial coefficients
        tmp2 = (2.0*a*i - c*g)/(2.0*i*iRt);
        tmp5 = (3.0*c*g*g - 4.0*c*d*i - 4.0*a*g*i)/(8.0*i2*iRt);

        // Constant deltas
        pld->Sdel2Span = 2*tmp5;
        pld->Sdel_tmp = tmp2 + tmp5;
        pld->S_tmp = c/iRt;
    }
    phong->numLights = curL;
}

void SetInitialPhongInterpolationVan (__GLcontext *gc, __GLvertex *a, 
                                       __GLcoord *an, __GLfloat dx, 
                                       __GLfloat dy)
{
    __GLshade *sh = &gc->polygon.shader;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat big = sh->dxLeftBig;

    phong->nCur.x = an->x + dx*phong->dndx.x + dy*phong->dndy.x;
    phong->nCur.y = an->y + dx*phong->dndx.y + dy*phong->dndy.y;
    phong->nCur.z = an->z + dx*phong->dndx.z + dy*phong->dndy.z;

    phong->nLittle.x = phong->dndy.x + little * phong->dndx.x;
    phong->nLittle.y = phong->dndy.y + little * phong->dndx.y;
    phong->nLittle.z = phong->dndy.z + little * phong->dndx.z;

    if (big > little) 
    {
        phong->nBig.x = phong->nLittle.x + phong->dndx.x;
        phong->nBig.y = phong->nLittle.y + phong->dndx.y;
        phong->nBig.z = phong->nLittle.z + phong->dndx.z;
    }
    else
    {
        phong->nBig.x = phong->nLittle.x - phong->dndx.x;
        phong->nBig.y = phong->nLittle.y - phong->dndx.y;
        phong->nBig.z = phong->nLittle.z - phong->dndx.z;
    }

    if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        phong->eCur.x = a->eyeX + dx*phong->dedx.x + dy*phong->dedy.x;
        phong->eCur.y = a->eyeY + dx*phong->dedx.y + dy*phong->dedy.y;
        phong->eCur.z = a->eyeZ + dx*phong->dedx.z + dy*phong->dedy.z;
        phong->eCur.w = a->eyeW + dx*phong->dedx.w + dy*phong->dedy.w;

        phong->eLittle.x = phong->dedy.x + little * phong->dedx.x;
        phong->eLittle.y = phong->dedy.y + little * phong->dedx.y;
        phong->eLittle.z = phong->dedy.z + little * phong->dedx.z;
        phong->eLittle.w = phong->dedy.w + little * phong->dedx.w;

        if (big > little) 
        {
            phong->eBig.x = phong->eLittle.x + phong->dedx.x;
            phong->eBig.y = phong->eLittle.y + phong->dedx.y;
            phong->eBig.z = phong->eLittle.z + phong->dedx.z;
            phong->eBig.w = phong->eLittle.w + phong->dedx.w;
        }
        else
        {
            phong->eBig.x = phong->eLittle.x - phong->dedx.x;
            phong->eBig.y = phong->eLittle.y - phong->dedx.y;
            phong->eBig.z = phong->eLittle.z - phong->dedx.z;
            phong->eBig.w = phong->eLittle.w - phong->dedx.w;
        }
    }
}

/* Equivalent to SetInitialPhongParameters. Does for D and S */
void SetInitialPhongInterpolationFast (__GLcontext *gc, __GLvertex *a, 
                                       __GLcoord *an, __GLfloat dx, 
                                       __GLfloat dy)
{
    __GLshade *sh = &gc->polygon.shader;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat little2 = little*little;
    __GLfloat big = sh->dxLeftBig;
    __GLfloat big2 = big*big;
    __GLfloat dx2 = dx*dx;
    __GLfloat dy2 = dy*dy;
    __GLcoord pos;
    int i;
    GLfloat x, x2, y, y2;
    GLfloat aa, b, c, d, e, f, g, h, ii;

    phong->cur_pos.x += dx;
    phong->cur_pos.y += dy;
    pos = phong->cur_pos;
    x = phong->cur_pos.x; x2 = x*x;
    y = phong->cur_pos.y; y2 = y*y;
    
    for (i = 0; i<phong->numLights; i++)
    {
        __GLphongPerLightData *pld = &phong->perLight[i];
        __GLfloat tmp1, tmp2, tmp3;

        /**** Diffuse Parameters *****/
        pld->D_curr = pld->D[5]*x2 + pld->D[4]*x*y + pld->D[3]*y2 + 
                      pld->D[2]*x + pld->D[1]*y + pld->D[0];

        tmp1 = 2*pld->D[5]*x + pld->D[4]*y + pld->D[2];
        tmp2 = 2*pld->D[3]*y + pld->D[4]*x + pld->D[1];

        // Compute the along-edge del2 and del terms (Little)
        tmp3 = pld->D[5]*little2 + pld->D[4]*little + pld->D[3];
        pld->Ddel2EdgeLittle =  2*tmp3;
        pld->DdelEdgeLittle =  tmp1*little + tmp2 + tmp3;

        // Compute the along-edge del2 and del terms (Big)
        tmp3 =  pld->D[5]*big2 + pld->D[4]*big + pld->D[3];
        pld->Ddel2EdgeBig =  2*tmp3;
        pld->DdelEdgeBig =  tmp1*big + tmp2 + tmp3;

        // Compute the along-span del terms
        pld->DdelSpan = tmp1 + pld->D[5];
        pld->DdelSpanEdgeBig = pld->D[4] + 2*pld->D[5]*big;
        pld->DdelSpanEdgeLittle = pld->D[4] + 2*pld->D[5]*little;
        
        /**** Specular Parameters ****/
#ifndef __SLOW
        pld->S_curr = pld->S[5]*x2 + pld->S[4]*x*y + pld->S[3]*y2 + 
                      pld->S[2]*x + pld->S[1]*y + pld->S[0];
#else
        aa = pld->A[0]; b = pld->A[1];
        c = pld->A[2]; d = pld->A[3];
        e = pld->A[4]; f = pld->A[5];
        g = pld->A[6]; h = pld->A[7];
        ii = pld->A[8];
        
        pld->S_curr = (aa*x+b*y+c)/__GL_SQRTF(d*x2+e*x*y+f*y2+g*x+h*y+ii);

#endif

        tmp1 = 2*pld->S[5]*x + pld->S[4]*y + pld->S[2];
        tmp2 = 2*pld->S[3]*y + pld->S[4]*x + pld->S[1];

        // Compute the along-edge del2 and del terms (Little)
        tmp3 = pld->S[5]*little2 + pld->S[4]*little + pld->S[3];
        pld->Sdel2EdgeLittle =  2*tmp3;
        pld->SdelEdgeLittle =  tmp1*little + tmp2 + tmp3;

        // Compute the along-edge del2 and del terms (Big)
        tmp3 =  pld->S[5]*big2 + pld->S[4]*big + pld->S[3];
        pld->Sdel2EdgeBig =  2*tmp3;
        pld->SdelEdgeBig =  tmp1*big + tmp2 + tmp3;

        // Compute the along-span del terms
        pld->SdelSpan = tmp1 + pld->S[5];
        pld->SdelSpanEdgeBig = pld->S[4] + 2*pld->S[5]*big;
        pld->SdelSpanEdgeLittle = pld->S[4] + 2*pld->S[5]*little;
        
    }
}


/* Called when: Normalization Enabled, FastLights */
/******************************************************
 ****Set up the Polynomial for diffuse illumination****
 ******************************************************
 *                                                    *
 *                2              2                    *
 * SD (x,y) = D_5x + D_4xy + D_3y + D_2x + D_1y + D_0 *
 *                                                    *
 * D_i are expressed in terms of: a,b,c,d,e,f,g,h,i   *
 *                                                    *
 * D_0 = c/sqrt(i)                                    *
 * D_1 = (2bi - ch)/(2i*sqrt(i))                      *
 * D_2 = (2ai - cg)/(2i*sqrt(i))                      *
 * D_3 = (3ch^2 - 4cfi - 4bhi)/(4i^2*sqrt(i))         *
 * D_4 = (3cgh - 2ci - 2bgi - 2ahi)/(8i^2*sqrt(i))    *
 * D_5 = (3ig^2 - 4cdi - 4agi)/(4i^2*sqrt(i))         *
 ******************************************************/
void InitializePhongInterpolationFast (__GLcontext *gc, __GLvertex *v)
{
    GLboolean colorMaterial = (gc->state.enables.general & 
                               __GL_COLOR_MATERIAL_ENABLE);
    GLint face = gc->polygon.shader.phong.face;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLmaterialMachine *msm;
    GLuint msm_colorMaterialChange;
    __GLfloat msm_alpha;
    __GLfloat rsi, gsi, bsi;
    __GLcoord normal;
    GLint curL;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    __GLshade *sh = &gc->polygon.shader;
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat big = sh->dxLeftBig;
    __GLcoord *A = &(phong->dndx);
    __GLcoord *B = &(phong->dndy);
    __GLcoord *C;
    //From Bishop's paper
    __GLfloat a, b, c, d, e, f, g, h, i;   

#ifdef __CENTER
    normal.x = v->normal.x + (v->window.x - phong->center.x)*A->x 
                           + (v->window.y - phong->center.y)*B->x;
    normal.y = v->normal.y + (v->window.x - phong->center.x)*A->y
                           + (v->window.y - phong->center.y)*B->y;
    normal.z = v->normal.z + (v->window.x - phong->center.x)*A->z
                           + (v->window.y - phong->center.y)*B->z;
#else
    normal.x = v->normal.x;
    normal.y = v->normal.y;
    normal.z = v->normal.z;
#endif
    if (face == __GL_FRONTFACE)
    {
        msm = &gc->light.front;
    }
    else
    {
        msm = &gc->light.back;
        normal.x = -normal.x;
        normal.y = -normal.y;
        normal.z = -normal.z;
    }
    
    C = &normal;
    //msm_colorMaterialChange = msm->colorMaterialChange;
#ifdef __DBG_PRINT
    DbgPrint ("A = (%f, %f, %f)\n", A->x, A->y, A->z);
    DbgPrint ("B = (%f, %f, %f)\n", B->x, B->y, B->z);
    DbgPrint ("C = (%f, %f, %f)\n", C->x, C->y, C->z);
#endif
    
    //***********Diffuse Bishop Parameters*****************************
    //a, b, c depend upon the light vector, so compute inside the loop
    //d, e, f, g, h, i depend only upon the incoming normal
    
    MAGN2 (d, A);                 //d = A.A 
    DOT   (e,A,B); e *= 2.0;      //e = 2A.B
    MAGN2 (f, B);                 //f = B.B
    DOT   (g,A,C); g *= 2.0;      //g = 2A.C
    DOT   (h,B,C); h *= 2.0;      //h = 2B.C
    MAGN2 (i,C);                  //i = C.C

    // Normalization not needed since 
    // it was done (if needed) during normal propagation.
    // Compute the per-light interpolation parameters 
    
    for (lsm = gc->light.sources, curL = 0; lsm; 
         lsm = lsm->next, curL++)
    {
        __GLphongPerLightData *pld = &(phong->perLight[curL]);
        __GLcoord *L = &(lsm->unitVPpli); // L is already normalized here
        __GLcoord *H = &(lsm->hHat);      // H is already normalized here
        GLfloat i2, iRt;
        
        i2 = i*i;
        iRt = __GL_SQRTF(i);
        
        /***** Diffuse *****/
        // Remaining Bishop parameters
        DOT (a,L,A);              //a = L.A/|L|
        DOT (b,L,B);              //b = L.B/|L|
        DOT (c,L,C);              //c = L.C/|L|


        // Polynomial coefficients
        //DOT (pld->D[0], &normal, L);
        pld->D[0] = c/iRt;
        pld->D[1] = (2.0*b*i - c*h)/(2.0*i*iRt);
        pld->D[2] = (2.0*a*i - c*g)/(2.0*i*iRt);
        pld->D[3] = (3.0*c*h*h - 4.0*c*f*i - 4.0*b*h*i)/(8.0*i2*iRt);
        pld->D[4] = (3.0*c*g*h - 2.0*c*e*i - 2.0*b*g*i - 2.0*a*h*i)/
                    (4.0*i2*iRt);
        pld->D[5] = (3.0*c*g*g - 4.0*c*d*i - 4.0*a*g*i)/(8.0*i2*iRt);

#ifdef __DBG_PRINT
        DbgPrint ("D[0]= %f, D[1]=%f, D[2]=%f, D[3]=%f, D[4]=%f, D[5]=%f\n",
                  pld->D[0], pld->D[1], pld->D[2], pld->D[3], pld->D[4], 
                  pld->D[5]);
#endif
        // Constant deltas
        pld->Ddel2Span = 2*pld->D[5];
        pld->D_curr = pld->D[0];
#ifdef __DBG_PRINT
        DbgPrint ("Ddel2Span= %f, D_curr=%f\n", pld->Ddel2Span, pld->D_curr);
#endif

        /***** Specular ******/
        // Remaining Bishop parameters
        DOT (a,H,A);              //a = H.A/|H|
        DOT (b,H,B);              //b = H.B/|H|
        DOT (c,H,C);              //c = H.C/|H|

        // Polynomial coefficients
        DOT (pld->S[0], &normal, H);
        pld->S[1] = (2.0*b*i - c*h)/(2.0*i*iRt);
        pld->S[2] = (2.0*a*i - c*g)/(2.0*i*iRt);
        pld->S[3] = (3.0*c*h*h - 4.0*c*f*i - 4.0*b*h*i)/(8.0*i2*iRt);
        pld->S[4] = (3.0*c*g*h - 2.0*c*e*i - 2.0*b*g*i - 2.0*a*h*i)/
                    (4.0*i2*iRt);
        pld->S[5] = (3.0*c*g*g - 4.0*c*d*i - 4.0*a*g*i)/(8.0*i2*iRt);

        // Constant deltas
        pld->Sdel2Span = 2*pld->S[5];
        pld->S_curr = pld->S[0];

#ifdef __SLOW
        pld->A[0] = a; pld->A[1] = b;
        pld->A[2] = c; pld->A[3] = d;
        pld->A[4] = e; pld->A[5] = f;
        pld->A[6] = g; pld->A[7] = h;
        pld->A[8] = i; 
#endif        
#ifdef __DBG_PRINT
        DbgPrint ("L = (%f, %f, %f)\n", L->x, L->y, L->z);
        DbgPrint ("H = (%f, %f, %f)\n", H->x, H->y, H->z);
        DbgPrint ("a= %f, b=%f, c=%f, d=%f, e=%f, f=%f, g=%f, h=%f, i=%f\n",
                  a, b, c, d, e, f, g, h, i);
#endif
    }

    phong->numLights = curL;
#ifdef __CENTER
    phong->cur_pos.x = v->window.x - phong->center.x;
    phong->cur_pos.y = v->window.y - phong->center.y;
#else
    phong->cur_pos.x = 0.0;
    phong->cur_pos.y = 0.0;
#endif
}


void InitializePhongInterpolationSlow (__GLcontext *gc, __GLvertex *v)
{
}

/* Do nothing */
void InitializePhongInterpolationVan (__GLcontext *gc, __GLvertex *v)
{
    __GLphongShader *phong = &gc->polygon.shader.phong;

#ifdef __DBG_PRINT
    DbgPrint ("dndx = (%f, %f, %f)\n", phong->dndx.x, phong->dndx.y, 
                                       phong->dndx.z);
    DbgPrint ("dndy = (%f, %f, %f)\n", phong->dndy.x, phong->dndy.y, 
                                       phong->dndy.z);
    DbgPrint ("normal = (%f, %f, %f)\n", v->normal.x, v->normal.y, 
                                         v->normal.z);
#endif
}

void UpdateParamsAlongEdgeFast (__GLcontext *gc, __GLfloat dxLeft, 
                                GLboolean useBigStep)
{
    __GLphongShader *phong = &(gc->polygon.shader.phong);
    __GLphongPerLightData *pld;
    GLint i;

    if (useBigStep)
    {
        for (i=0; i<phong->numLights; i++)
        {
            pld = &(phong->perLight[i]);

            /** Diffuse Parameters **/
            pld->D_curr += pld->DdelEdgeBig;
            pld->DdelEdgeBig += pld->Ddel2EdgeBig;
            pld->DdelEdgeLittle += pld->Ddel2EdgeBig;
            pld->DdelSpan += pld->DdelSpanEdgeBig;

            /** Specular Parameters **/
            pld->S_curr += pld->SdelEdgeBig;
            pld->SdelEdgeBig += pld->Sdel2EdgeBig;
            pld->SdelEdgeLittle += pld->Sdel2EdgeBig;
            pld->SdelSpan += pld->SdelSpanEdgeBig;
        }
    }
    else //Use small step
    {
        for (i=0; i<phong->numLights; i++)
        {
            pld = &(phong->perLight[i]);

            /** Diffuse Parameters **/
            pld->D_curr += pld->DdelEdgeLittle;
            pld->DdelEdgeBig += pld->Ddel2EdgeLittle;
            pld->DdelEdgeLittle += pld->Ddel2EdgeLittle;
            pld->DdelSpan += pld->DdelSpanEdgeLittle;

            /** Specular Parameters **/
            pld->S_curr += pld->SdelEdgeLittle;
            pld->SdelEdgeBig += pld->Sdel2EdgeLittle;
            pld->SdelEdgeLittle += pld->Sdel2EdgeLittle;
            pld->SdelSpan += pld->SdelSpanEdgeLittle;
        }
    }

    phong->cur_pos.x += dxLeft;
    phong->cur_pos.y += 1.0;
}



void UpdateParamsAlongEdgeVan (__GLcontext *gc, __GLfloat dxLeft, 
                                GLboolean useBigStep)
{
    __GLphongShader *phong = &(gc->polygon.shader.phong);

    if (useBigStep)
    {
        phong->nCur.x += phong->nBig.x;
        phong->nCur.y += phong->nBig.y;
        phong->nCur.z += phong->nBig.z;
    }
    else
    {
        phong->nCur.x += phong->nLittle.x;
        phong->nCur.y += phong->nLittle.y;
        phong->nCur.z += phong->nLittle.z;
    }

    if (phong->flags & __GL_PHONG_NEED_EYE_XPOLATE)
    {
        if (useBigStep)
        {
            phong->eCur.x += phong->eBig.x;
            phong->eCur.y += phong->eBig.y;
            phong->eCur.z += phong->eBig.z;
            phong->eCur.w += phong->eBig.w;
        }
        else
        {
            phong->eCur.x += phong->eLittle.x;
            phong->eCur.y += phong->eLittle.y;
            phong->eCur.z += phong->eLittle.z;
            phong->eCur.w += phong->eLittle.w;
        }
    }
}


#endif //__JUNKED_CODE

#endif // GL_WIN_phong_shading
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_pick.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include "texture.h"

/*
** Determine if the alpha color component is needed.  If it's not needed
** then the renderers can avoid computing it.
*/
GLboolean FASTCALL __glNeedAlpha(__GLcontext *gc)
{
    if (gc->modes.colorIndexMode) {
        return GL_FALSE;
    }

    if (gc->state.enables.general & __GL_ALPHA_TEST_ENABLE) {
        return GL_TRUE;
    }
    if (gc->modes.alphaBits > 0) {
        return GL_TRUE;
    }

    if (gc->state.enables.general & __GL_BLEND_ENABLE) {
        GLint src = gc->state.raster.blendSrc;
        GLint dst = gc->state.raster.blendDst;
        /*
        ** See if one of the source alpha combinations are used.
        */
        if ((src == GL_SRC_ALPHA) ||
            (src == GL_ONE_MINUS_SRC_ALPHA) ||
            (src == GL_SRC_ALPHA_SATURATE) ||
            (dst == GL_SRC_ALPHA) ||
            (dst == GL_ONE_MINUS_SRC_ALPHA)) {
            return GL_TRUE;
        }
    }
    return GL_FALSE;
}

/************************************************************************/

/* these are depth test routines for C.. */
GLboolean (FASTCALL *__glCDTPixel[32])(__GLzValue, __GLzValue *) = {
    /* unsigned ops, no mask */
    __glDT_NEVER,
    __glDT_LESS,
    __glDT_EQUAL,
    __glDT_LEQUAL,
    __glDT_GREATER,
    __glDT_NOTEQUAL,
    __glDT_GEQUAL,
    __glDT_ALWAYS,
    /* unsigned ops, mask */
    __glDT_NEVER,
    __glDT_LESS_M,
    __glDT_EQUAL_M,
    __glDT_LEQUAL_M,
    __glDT_GREATER_M,
    __glDT_NOTEQUAL_M,
    __glDT_GEQUAL_M,
    __glDT_ALWAYS_M,
    /* unsigned ops, no mask */
    __glDT_NEVER,
    __glDT16_LESS,
    __glDT16_EQUAL,
    __glDT16_LEQUAL,
    __glDT16_GREATER,
    __glDT16_NOTEQUAL,
    __glDT16_GEQUAL,
    __glDT16_ALWAYS,
    /* unsigned ops, mask */
    __glDT_NEVER,
    __glDT16_LESS_M,
    __glDT16_EQUAL_M,
    __glDT16_LEQUAL_M,
    __glDT16_GREATER_M,
    __glDT16_NOTEQUAL_M,
    __glDT16_GEQUAL_M,
    __glDT16_ALWAYS_M,
};

#ifdef __GL_USEASMCODE
void (*__glSDepthTestPixel[16])(void) = {
    NULL,
    __glDTS_LESS,
    __glDTS_EQUAL,
    __glDTS_LEQUAL,
    __glDTS_GREATER,
    __glDTS_NOTEQUAL,
    __glDTS_GEQUAL,
    __glDTS_ALWAYS,
    NULL,
    __glDTS_LESS_M,
    __glDTS_EQUAL_M,
    __glDTS_LEQUAL_M,
    __glDTS_GREATER_M,
    __glDTS_NOTEQUAL_M,
    __glDTS_GEQUAL_M,
    __glDTS_ALWAYS_M,
};
#endif

/************************************************************************/

void FASTCALL __glGenericPickPointProcs(__GLcontext *gc)
{
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    if (gc->renderMode == GL_FEEDBACK) 
    {
        gc->procs.renderPoint = __glFeedbackPoint;
        return;
    } 
    if (gc->renderMode == GL_SELECT) 
    {
        gc->procs.renderPoint = __glSelectPoint;
        return;
    } 
    if (gc->state.enables.general & __GL_POINT_SMOOTH_ENABLE) 
    {
        if (gc->modes.colorIndexMode) 
        {
            gc->procs.renderPoint = __glRenderAntiAliasedCIPoint;
        } 
        else 
        {
            gc->procs.renderPoint = __glRenderAntiAliasedRGBPoint;
        }
        return;
    } 
    else if (gc->state.point.aliasedSize != 1) 
    {
        gc->procs.renderPoint = __glRenderAliasedPointN;
    } 
    else if (gc->texture.textureEnabled) 
    {
        gc->procs.renderPoint = __glRenderAliasedPoint1;
    } 
    else 
    {
        gc->procs.renderPoint = __glRenderAliasedPoint1_NoTex;
    }

#ifdef __BUGGY_RENDER_POINT
#ifdef NT
    if ((modeFlags & __GL_SHADE_CHEAP_FOG) &&
        !(modeFlags & __GL_SHADE_SMOOTH_LIGHT))
    {
        gc->procs.renderPoint2 = gc->procs.renderPoint;
        gc->procs.renderPoint = __glRenderFlatFogPoint;
    }
    else if (modeFlags & __GL_SHADE_SLOW_FOG)
    {
        gc->procs.renderPoint2 = gc->procs.renderPoint;
        gc->procs.renderPoint = __glRenderFlatFogPointSlow;
    }
#else
// SGIBUG the slow fog path does not compute vertex->fog value!
    if (((modeFlags & __GL_SHADE_CHEAP_FOG) &&
        !(modeFlags & __GL_SHADE_SMOOTH_LIGHT)) ||
        (modeFlags & __GL_SHADE_SLOW_FOG)) {
    gc->procs.renderPoint2 = gc->procs.renderPoint;
    gc->procs.renderPoint = __glRenderFlatFogPoint;
    }
#endif
#endif //__BUGGY_RENDER_POINT
}

#ifdef __GL_USEASMCODE
static void (*LDepthTestPixel[16])(void) = {
    NULL,
    __glDTP_LESS,
    __glDTP_EQUAL,
    __glDTP_LEQUAL,
    __glDTP_GREATER,
    __glDTP_NOTEQUAL,
    __glDTP_GEQUAL,
    __glDTP_ALWAYS,
    NULL,
    __glDTP_LESS_M,
    __glDTP_EQUAL_M,
    __glDTP_LEQUAL_M,
    __glDTP_GREATER_M,
    __glDTP_NOTEQUAL_M,
    __glDTP_GEQUAL_M,
    __glDTP_ALWAYS_M,
};
#endif

void FASTCALL __glGenericPickRenderBitmapProcs(__GLcontext *gc)
{
    gc->procs.renderBitmap = __glRenderBitmap;
}

void FASTCALL __glGenericPickClipProcs(__GLcontext *gc)
{
    gc->procs.clipTriangle = __glClipTriangle;
}

void FASTCALL __glGenericPickTextureProcs(__GLcontext *gc)
{
    __GLtexture *current;
    __GLtextureParamState *params;

#ifdef NT
    /* Pick coordinate generation function */
    if ((gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE) &&
    (gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE) &&
    !(gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE) &&
    !(gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE) &&
    (gc->state.texture.s.mode == gc->state.texture.t.mode))
    {
    /* Use a special function when both modes are enabled and identical */
    if (gc->state.texture.s.mode == GL_SPHERE_MAP)
    {
        gc->procs.paCalcTexture = PolyArrayCalcSphereMap;
    }
    else
    {
        __GLcoord *cs, *ct;

        cs = &gc->state.texture.s.eyePlaneEquation;
        ct = &gc->state.texture.t.eyePlaneEquation;
        if (cs->x == ct->x && cs->y == ct->y
         && cs->z == ct->z && cs->w == ct->w)
        {
        if (gc->state.texture.s.mode == GL_EYE_LINEAR)
            gc->procs.paCalcTexture = PolyArrayCalcEyeLinearSameST;
        else
            gc->procs.paCalcTexture = PolyArrayCalcObjectLinearSameST;
        }
        else
        {
        if (gc->state.texture.s.mode == GL_EYE_LINEAR)
            gc->procs.paCalcTexture = PolyArrayCalcEyeLinear;
        else
            gc->procs.paCalcTexture = PolyArrayCalcObjectLinear;
        }
    }
    }
    else
    {
    if (gc->state.enables.general & (__GL_TEXTURE_GEN_S_ENABLE |
                                     __GL_TEXTURE_GEN_T_ENABLE |
                                     __GL_TEXTURE_GEN_R_ENABLE |
                                     __GL_TEXTURE_GEN_Q_ENABLE))
        /* Use fast function when both are disabled */
        gc->procs.paCalcTexture = PolyArrayCalcMixedTexture;
    else
        gc->procs.paCalcTexture = PolyArrayCalcTexture;
    }
#else
    /* Pick coordinate generation function */
    if ((gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE) &&
	(gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE) &&
	!(gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE) &&
	!(gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE) &&
	(gc->state.texture.s.mode == gc->state.texture.t.mode)) {
	/* Use a special function when both modes are enabled and identical */
	switch (gc->state.texture.s.mode) {
	  case GL_EYE_LINEAR:
	    gc->procs.calcTexture = __glCalcEyeLinear;
	    break;
	  case GL_OBJECT_LINEAR:
	    gc->procs.calcTexture = __glCalcObjectLinear;
	    break;
	  case GL_SPHERE_MAP:
	    gc->procs.calcTexture = __glCalcSphereMap;
	    break;
	}
    } else {
	if (!(gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE) &&
	    !(gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE) &&
	    !(gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE) &&
	    !(gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE)) {
	    /* Use fast function when both are disabled */
	    gc->procs.calcTexture = __glCalcTexture;
	} else {
	    gc->procs.calcTexture = __glCalcMixedTexture;
	}
    }
#endif // NT

    gc->texture.currentTexture = current = 0;
    if (gc->state.enables.general & __GL_TEXTURE_2D_ENABLE) {
    if (__glIsTextureConsistent(gc, GL_TEXTURE_2D)) {
        params = __glLookUpTextureParams(gc, GL_TEXTURE_2D);
        gc->texture.currentTexture =
        current = __glLookUpTexture(gc, GL_TEXTURE_2D);
    }
    } else
    if (gc->state.enables.general & __GL_TEXTURE_1D_ENABLE) {
    if (__glIsTextureConsistent(gc, GL_TEXTURE_1D)) {
        params = __glLookUpTextureParams(gc, GL_TEXTURE_1D);
        gc->texture.currentTexture =
        current = __glLookUpTexture(gc, GL_TEXTURE_1D);
    }
    } else {
    current = NULL;
    }

#ifdef _MCD_
    MCD_STATE_DIRTY(gc, TEXTURE);
#endif

    /* Pick texturing function for the current texture */
    if (current) {
    GLenum baseFormat;

/* XXX most of this should be bound into the texture param code, right? */
        current->params = *params;

    /*
    ** Figure out if mipmapping is being used.  If not, then the
    ** rho computations can be avoided as there is only one texture
    ** to choose from.
    */
    gc->procs.calcLineRho = __glComputeLineRho;
    gc->procs.calcPolygonRho = __glComputePolygonRho;
    if ((current->params.minFilter == GL_LINEAR)
        || (current->params.minFilter == GL_NEAREST)) {
        /* No mipmapping needed */
        if (current->params.minFilter == current->params.magFilter) {
        /* No rho needed as min/mag application is identical */
        current->textureFunc = __glFastTextureFragment;
        gc->procs.calcLineRho = __glNopLineRho;
        gc->procs.calcPolygonRho = __glNopPolygonRho;
        } else {
        current->textureFunc = __glTextureFragment;

        /*
        ** Pre-calculate min/mag switchover point.  The rho calculation
        ** doesn't perform a square root (ever).  Consequently, these
        ** constants are squared.
        */
        if ((current->params.magFilter == GL_LINEAR) &&
            ((current->params.minFilter == GL_NEAREST_MIPMAP_NEAREST) ||
             (current->params.minFilter == GL_LINEAR_MIPMAP_NEAREST))) {
            current->c = ((__GLfloat) 2.0);
        } else {
            current->c = __glOne;
        }
        }
    } else {
        current->textureFunc = __glMipMapFragment;

        /*
        ** Pre-calculate min/mag switchover point.  The rho
        ** calculation doesn't perform a square root (ever).
        ** Consequently, these constants are squared.
        */
        if ((current->params.magFilter == GL_LINEAR) &&
        ((current->params.minFilter == GL_NEAREST_MIPMAP_NEAREST) ||
         (current->params.minFilter == GL_LINEAR_MIPMAP_NEAREST))) {
        current->c = ((__GLfloat) 2.0);
        } else {
        current->c = __glOne;
        }
    }

    /* Pick environment function */
    baseFormat = current->level[0].baseFormat;
    switch (gc->state.texture.env[0].mode) {
      case GL_MODULATE:
        switch (baseFormat) {
          case GL_LUMINANCE:
        current->env = __glTextureModulateL;
        break;
          case GL_LUMINANCE_ALPHA:
        current->env = __glTextureModulateLA;
        break;
          case GL_RGB:
        current->env = __glTextureModulateRGB;
        break;
          case GL_RGBA:
        current->env = __glTextureModulateRGBA;
        break;
          case GL_ALPHA:
        current->env = __glTextureModulateA;
        break;
          case GL_INTENSITY:
        current->env = __glTextureModulateI;
        break;
#ifdef NT
            default:
                ASSERTOPENGL(FALSE, "Unexpected baseFormat\n");
                break;
#endif
        }
        break;
      case GL_DECAL:
        switch (baseFormat) {
          case GL_LUMINANCE:
        current->env = __glNopGCCOLOR;
                break;
          case GL_LUMINANCE_ALPHA:
        current->env = __glNopGCCOLOR;
                break;
          case GL_RGB:
        current->env = __glTextureDecalRGB;
        break;
          case GL_RGBA:
        current->env = __glTextureDecalRGBA;
        break;
          case GL_ALPHA:
        current->env = __glNopGCCOLOR;
        break;
          case GL_INTENSITY:
        current->env = __glNopGCCOLOR;
        break;
#ifdef NT
            default:
                ASSERTOPENGL(FALSE, "Unexpected baseFormat\n");
                break;
#endif
        }
        break;
      case GL_BLEND:
        switch (baseFormat) {
          case GL_LUMINANCE:
        current->env = __glTextureBlendL;
                break;
          case GL_LUMINANCE_ALPHA:
        current->env = __glTextureBlendLA;
        break;
          case GL_RGB:
        current->env = __glTextureBlendRGB;
        break;
          case GL_RGBA:
        current->env = __glTextureBlendRGBA;
        break;
          case GL_ALPHA:
        current->env = __glTextureBlendA;
        break;
          case GL_INTENSITY:
        current->env = __glTextureBlendI;
        break;
#ifdef NT
            default:
                ASSERTOPENGL(FALSE, "Unexpected baseFormat\n");
                break;
#endif
        }
        break;
      case GL_REPLACE:
        switch (baseFormat) {
          case GL_LUMINANCE:
        current->env = __glTextureReplaceL;
        break;
          case GL_LUMINANCE_ALPHA:
        current->env = __glTextureReplaceLA;
        break;
          case GL_RGB:
        current->env = __glTextureReplaceRGB;
        break;
          case GL_RGBA:
        current->env = __glTextureReplaceRGBA;
        break;
          case GL_ALPHA:
        current->env = __glTextureReplaceA;
        break;
          case GL_INTENSITY:
        current->env = __glTextureReplaceI;
        break;
#ifdef NT
            default:
                ASSERTOPENGL(FALSE, "Unexpected baseFormat\n");
                break;
#endif
        }
        break;
#ifdef NT
        default:
            ASSERTOPENGL(FALSE, "Unexpected texture mode\n");
            break;
#endif
    }

    /* Pick mag/min functions */
    switch (current->dim) {
      case 1:
        current->nearest = __glNearestFilter1;
        current->linear = __glLinearFilter1;
        break;
      case 2:
        current->nearest = __glNearestFilter2;
        current->linear = __glLinearFilter2;

        // Accelerate BGR{A}8 case when wrap modes are both REPEAT
        if( (current->params.sWrapMode == GL_REPEAT) &&
            (current->params.tWrapMode == GL_REPEAT)
          )
        {
            __GLmipMapLevel *lp = &current->level[0];

            if( lp->extract == __glExtractTexelBGR8 ) 
             current->linear = __glLinearFilter2_BGR8Repeat;
            else if( lp->extract == __glExtractTexelBGRA8 ) 
	            current->linear = __glLinearFilter2_BGRA8Repeat;
        }
        break;
    }

    /* set mag filter function */
    switch (current->params.magFilter) {
      case GL_LINEAR:
        current->magnify = __glLinearFilter;
        break;
      case GL_NEAREST:
        current->magnify = __glNearestFilter;
        break;
    }

    /* set min filter function */
    switch (current->params.minFilter) {
      case GL_LINEAR:
        current->minnify = __glLinearFilter;
        break;
      case GL_NEAREST:
        current->minnify = __glNearestFilter;
        break;
      case GL_NEAREST_MIPMAP_NEAREST:
        current->minnify = __glNMNFilter;
        break;
      case GL_LINEAR_MIPMAP_NEAREST:
        current->minnify = __glLMNFilter;
        break;
      case GL_NEAREST_MIPMAP_LINEAR:
        current->minnify = __glNMLFilter;
        break;
      case GL_LINEAR_MIPMAP_LINEAR:
        current->minnify = __glLMLFilter;
        break;
    }

    gc->procs.texture = current->textureFunc;
    } else {
    gc->procs.texture = 0;
    }
}


void FASTCALL __glGenericPickFogProcs(__GLcontext *gc)
{
#ifdef GL_WIN_specular_fog
    /*
    ** If specular shading is on, coerce the fog sub-system to go through
    ** DONT_CARE path. Disregard the GL_NICEST hint!!!
    */
#endif //GL_WIN_specular_fog

    if ((gc->state.enables.general & __GL_FOG_ENABLE) 
#ifdef GL_WIN_specular_fog
        || (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG) 
#endif //GL_WIN_specular_fog
        )
    {
        if ((gc->state.hints.fog == GL_NICEST) 
#ifdef GL_WIN_specular_fog
            && !(gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG) 
#endif //GL_WIN_specular_fog
            ) 
        {
            gc->procs.fogVertex = 0;    /* Better not be called */
        } 
        else 
        {
            if (gc->state.fog.mode == GL_LINEAR) 
                gc->procs.fogVertex = __glFogVertexLinear;
            else
                gc->procs.fogVertex = __glFogVertex;
        }
        gc->procs.fogPoint = __glFogFragmentSlow;
        gc->procs.fogColor = __glFogColorSlow;
    } 
    else 
    {
        gc->procs.fogVertex = 0;
        gc->procs.fogPoint = 0;
        gc->procs.fogColor = 0;
    }
}

void FASTCALL __glGenericPickBufferProcs(__GLcontext *gc)
{
    GLint i;
    __GLbufferMachine *buffers;

    buffers = &gc->buffers;
    buffers->doubleStore = GL_FALSE;

    /* Set draw buffer pointer */
    switch (gc->state.raster.drawBuffer) {
      case GL_FRONT:
    gc->drawBuffer = gc->front;
    break;
      case GL_FRONT_AND_BACK:
    if (gc->modes.doubleBufferMode) {
        gc->drawBuffer = gc->back;
        buffers->doubleStore = GL_TRUE;
    } else {
        gc->drawBuffer = gc->front;
    }
    break;
      case GL_BACK:
    gc->drawBuffer = gc->back;
    break;
      case GL_AUX0:
      case GL_AUX1:
      case GL_AUX2:
      case GL_AUX3:
    i = gc->state.raster.drawBuffer - GL_AUX0;
#if __GL_NUMBER_OF_AUX_BUFFERS > 0
    gc->drawBuffer = &gc->auxBuffer[i];
#endif
    break;
    }
}

void FASTCALL __glGenericPickPixelProcs(__GLcontext *gc)
{
    __GLpixelTransferMode *tm;
    __GLpixelMachine *pm;
    GLboolean mapColor;
    GLfloat red, green, blue, alpha;
    GLint entry;
    GLuint enables = gc->state.enables.general;
    __GLpixelMapHead *pmap;
    GLint i;

    /* Set read buffer pointer */
    switch (gc->state.pixel.readBuffer) {
      case GL_FRONT:
    gc->readBuffer = gc->front;
    break;
      case GL_BACK:
    gc->readBuffer = gc->back;
    break;
      case GL_AUX0:
      case GL_AUX1:
      case GL_AUX2:
      case GL_AUX3:
    i = gc->state.pixel.readBuffer - GL_AUX0;
#if __GL_NUMBER_OF_AUX_BUFFERS > 0
    gc->readBuffer = &gc->auxBuffer[i];
#endif
    break;
    }

    if (gc->texture.textureEnabled
        || (gc->polygon.shader.modeFlags & __GL_SHADE_SLOW_FOG)) {
    gc->procs.pxStore = __glSlowDrawPixelsStore;
    } else {
    gc->procs.pxStore = gc->procs.store;
    }

    tm = &gc->state.pixel.transferMode;
    pm = &(gc->pixel);
    mapColor = tm->mapColor;
    if (mapColor || gc->modes.rgbMode || tm->indexShift || tm->indexOffset) {
    pm->iToICurrent = GL_FALSE;
    pm->iToRGBACurrent = GL_FALSE;
    pm->modifyCI = GL_TRUE;
    } else {
    pm->modifyCI = GL_FALSE;
    }
    if (tm->mapStencil || tm->indexShift || tm->indexOffset) {
    pm->modifyStencil = GL_TRUE;
    } else {
    pm->modifyStencil = GL_FALSE;
    }
    if (tm->d_scale != __glOne || tm->d_bias) {
    pm->modifyDepth = GL_TRUE;
    } else {
    pm->modifyDepth = GL_FALSE;
    }
    if (mapColor || tm->r_bias || tm->g_bias || tm->b_bias || tm->a_bias ||
    tm->r_scale != __glOne || tm->g_scale != __glOne ||
    tm->b_scale != __glOne || tm->a_scale != __glOne) {
    pm->modifyRGBA = GL_TRUE;
    pm->rgbaCurrent = GL_FALSE;
    } else {
    pm->modifyRGBA = GL_FALSE;
    }

    if (pm->modifyRGBA) {
    /* Compute default values for red, green, blue, alpha */
    red = gc->state.pixel.transferMode.r_bias;
    green = gc->state.pixel.transferMode.g_bias;
    blue = gc->state.pixel.transferMode.b_bias;
    alpha = gc->state.pixel.transferMode.a_scale +
        gc->state.pixel.transferMode.a_bias;
    if (mapColor) {
        pmap = 
        &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_R_TO_R];
        entry = (GLint)(red * pmap->size);
        if (entry < 0) entry = 0;
        else if (entry > pmap->size-1) entry = pmap->size-1;
        red = pmap->base.mapF[entry];

        pmap = 
        &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_G_TO_G];
        entry = (GLint)(green * pmap->size);
        if (entry < 0) entry = 0;
        else if (entry > pmap->size-1) entry = pmap->size-1;
        green = pmap->base.mapF[entry];

        pmap = 
        &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_B_TO_B];
        entry = (GLint)(blue * pmap->size);
        if (entry < 0) entry = 0;
        else if (entry > pmap->size-1) entry = pmap->size-1;
        blue = pmap->base.mapF[entry];

        pmap = 
        &gc->state.pixel.pixelMap[__GL_PIXEL_MAP_A_TO_A];
        entry = (GLint)(alpha * pmap->size);
        if (entry < 0) entry = 0;
        else if (entry > pmap->size-1) entry = pmap->size-1;
        alpha = pmap->base.mapF[entry];
    } else {
        if (red > __glOne) red = __glOne;
        else if (red < 0) red = 0;
        if (green > __glOne) green = __glOne;
        else if (green < 0) green = 0;
        if (blue > __glOne) blue = __glOne;
        else if (blue < 0) blue = 0;
        if (alpha > __glOne) alpha = __glOne;
        else if (alpha < 0) alpha = 0;
    }
    pm->red0Mod = red * gc->frontBuffer.redScale;
    pm->green0Mod = green * gc->frontBuffer.greenScale;
    pm->blue0Mod = blue * gc->frontBuffer.blueScale;
    pm->alpha1Mod = alpha * gc->frontBuffer.alphaScale;
    } else {
    pm->red0Mod = __glZero;
    pm->green0Mod = __glZero;
    pm->blue0Mod = __glZero;
    pm->alpha1Mod = gc->frontBuffer.alphaScale;
    }

    gc->procs.drawPixels = __glSlowPickDrawPixels;
    gc->procs.readPixels = __glSlowPickReadPixels;
    gc->procs.copyPixels = __glSlowPickCopyPixels;
}

/*
** pick the depth function pointers
*/
int FASTCALL __glGenericPickDepthProcs(__GLcontext *gc)
{
    GLint   depthIndex;

    depthIndex = gc->state.depth.testFunc - GL_NEVER;

    if (gc->modes.depthBits && gc->modes.haveDepthBuffer) {
        if (gc->state.depth.writeEnable == GL_FALSE)
            depthIndex += 8;

        if (gc->depthBuffer.buf.elementSize == 2)
            depthIndex += 16;
    } else {
        /*
        ** No depthBits so force StoreALWAYS_W, _glDT_ALWAYS_M, etc.
        */
        depthIndex = (GL_ALWAYS - GL_NEVER) + 8;
    }

    (*gc->depthBuffer.pick)(gc, &gc->depthBuffer, depthIndex);

    gc->procs.DTPixel = __glCDTPixel[depthIndex];
#ifdef __GL_USEASMCODE
    gc->procs.span.depthTestPixel = __glSDepthTestPixel[depthIndex];
    gc->procs.line.depthTestPixel = __glPDepthTestPixel[depthIndex];

    if( gc->procs.line.depthTestLine ) {
    if( __glDTLine[depthIndex] ) {
        *(gc->procs.line.depthTestLine) = __glDTLine[depthIndex];
    } else {
        /*
        ** If this happens, it may mean one of two things:
        ** (a) __glDTLine is malformed
        ** (b) A device-dependent line picker was a bit careless.
        **     This will probably happen if that implementation is
        **     not using the slow path.  
        **  Eg: For NEWPORT, AA depth lines go through slow path,
        **  but non-AA depth lines have a fast path.  When switching
        **  to a non-AA path, we may end up here, but that's ok, since
        **  we are not using the slow path.  If that is about to happen,
        **  the line picker will be reinvoked.
        */

        /*
        ** use some generic function here that will work
        */
        *(gc->procs.line.depthTestLine) = __glDepthTestLine_asm;
    }
    }
#endif

    return depthIndex;
}

void FASTCALL __glGenericValidate(__GLcontext *gc)
{
    (*gc->procs.pickAllProcs)(gc);
}

void FASTCALL __glGenericPickAllProcs(__GLcontext *gc)
{
    GLuint enables = gc->state.enables.general;
    GLuint modeFlags = 0;

    if (gc->dirtyMask & (__GL_DIRTY_TEXTURE | __GL_DIRTY_GENERIC)) {
        /* 
        ** Set textureEnabled flag early on, so we can set modeFlags
        ** based upon it.
        */
        (*gc->procs.pickTextureProcs)(gc);
        gc->texture.textureEnabled = gc->modes.rgbMode
          && gc->texture.currentTexture;
    }

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_LIGHTING)) {

#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif

        // Check and see whether the current texturing settings will
        // completely replace the polygon color
        if (gc->texture.textureEnabled &&
#ifdef GL_EXT_flat_paletted_lighting
            (enables & __GL_PALETTED_LIGHTING_ENABLE) == 0 &&
#endif
            gc->state.texture.env[0].mode == GL_REPLACE &&
            (gc->texture.currentTexture->level[0].baseFormat == GL_RGBA ||
             gc->texture.currentTexture->level[0].baseFormat == GL_INTENSITY ||
             gc->texture.currentTexture->level[0].baseFormat ==
             GL_LUMINANCE_ALPHA ||
             ((enables & __GL_BLEND_ENABLE) == 0 &&
              (gc->texture.currentTexture->level[0].baseFormat ==
               GL_LUMINANCE ||
               gc->texture.currentTexture->level[0].baseFormat == GL_RGB)))) 
        {
            modeFlags |= __GL_SHADE_FULL_REPLACE_TEXTURE;
        }
    }

    /* Compute shading mode flags before triangle, span, and line picker */
    if (gc->modes.rgbMode) {
        modeFlags |= __GL_SHADE_RGB;
        if (gc->texture.textureEnabled) {
            modeFlags |= __GL_SHADE_TEXTURE;
        }
        if (enables & __GL_BLEND_ENABLE) {
            modeFlags |= __GL_SHADE_BLEND;
        }
        if (enables & __GL_ALPHA_TEST_ENABLE) {
            modeFlags |= __GL_SHADE_ALPHA_TEST;
        }
        if (enables & __GL_COLOR_LOGIC_OP_ENABLE) {
            modeFlags |= __GL_SHADE_LOGICOP;
        }
        if (!gc->state.raster.rMask ||
            !gc->state.raster.gMask ||
            !gc->state.raster.bMask
#ifndef NT
            // NT doesn't support destination alpha so there's no point
            // in worrying about the alpha mask since we'll never write
            // alpha values anyway
            || !gc->state.raster.aMask
#endif
            )
        {
            modeFlags |= __GL_SHADE_MASK;
        }
    } else {
        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
            modeFlags |= __GL_SHADE_LOGICOP;
        }
        if (gc->state.raster.writeMask != __GL_MASK_INDEXI(gc, ~0)) {
            modeFlags |= __GL_SHADE_MASK;
        }
    }

    if (gc->state.light.shadingModel == GL_SMOOTH) {
        modeFlags |= __GL_SHADE_SMOOTH | __GL_SHADE_SMOOTH_LIGHT;

#ifdef GL_WIN_phong_shading
    } else if (gc->state.light.shadingModel == GL_PHONG_WIN) {
        if (enables & __GL_LIGHTING_ENABLE)
            modeFlags |= __GL_SHADE_PHONG;
        else
            modeFlags |= __GL_SHADE_SMOOTH | __GL_SHADE_SMOOTH_LIGHT;
#endif //GL_WIN_phong_shading
    }

    if ((enables & __GL_DEPTH_TEST_ENABLE) && 
        gc->modes.haveDepthBuffer) {
        modeFlags |= ( __GL_SHADE_DEPTH_TEST |  __GL_SHADE_DEPTH_ITER );
    }
    if (enables & __GL_CULL_FACE_ENABLE) {
        modeFlags |= __GL_SHADE_CULL_FACE;
    }
    if (enables & __GL_DITHER_ENABLE) {
        modeFlags |= __GL_SHADE_DITHER;
    }
    if (enables & __GL_POLYGON_STIPPLE_ENABLE) {
        modeFlags |= __GL_SHADE_STIPPLE;
    }
    if (enables & __GL_LINE_STIPPLE_ENABLE) {
        modeFlags |= __GL_SHADE_LINE_STIPPLE;
    }
    if ((enables & __GL_STENCIL_TEST_ENABLE) && 
        gc->modes.haveStencilBuffer) {
        modeFlags |= __GL_SHADE_STENCIL_TEST;
    }
    if ((enables & __GL_LIGHTING_ENABLE) && 
        gc->state.light.model.twoSided) {
        modeFlags |= __GL_SHADE_TWOSIDED;
    }

#ifdef GL_WIN_specular_fog
    /*
    ** Specularly lit textures using fog only if: 
    ** -- Lighting is enabled
    ** -- Texturing is enabled
    ** -- Texturing mode is GL_MODULATE
    ** -- Lighting calculation is not skipped
    ** -- No two sided lighting
    */
    if (
        (gc->state.texture.env[0].mode == GL_MODULATE) &&
        (enables &  __GL_FOG_SPEC_TEX_ENABLE) &&
        (enables & __GL_LIGHTING_ENABLE) &&
        !(modeFlags & __GL_SHADE_TWOSIDED) &&
         (modeFlags & __GL_SHADE_TEXTURE) &&
        !(
          (modeFlags & __GL_SHADE_FULL_REPLACE_TEXTURE) &&
          (gc->renderMode == GL_RENDER)
          )
        )
    {
        modeFlags |= __GL_SHADE_SPEC_FOG;
        modeFlags |= __GL_SHADE_INTERP_FOG;
    }
#endif //GL_WIN_specular_fog

    if (enables & __GL_FOG_ENABLE) 
    {
        /* Figure out type of fogging to do.  Try to do cheap fog */
        if (!(modeFlags & __GL_SHADE_TEXTURE) &&
#ifdef GL_WIN_phong_shading
            !(modeFlags & __GL_SHADE_PHONG) &&
#endif //GL_WIN_phong_shading
            (gc->state.hints.fog != GL_NICEST)) {
            /*
            #ifdef NT
            ** Cheap fog can be done.  Now figure out which kind we
            ** will do.  If smooth shading, its easy - just update
            ** the color in DrawPolyArray.  Otherwise, set has flag
            ** later on to use smooth shading to do flat shaded fogging.
            #else
            ** Cheap fog can be done.  Now figure out which kind we
            ** will do.  If smooth shading, its easy - just change
            ** the calcColor proc (let the color proc picker do it).
            ** Otherwise, set has flag later on to use smooth shading
            ** to do flat shaded fogging.
            #endif
            */
            modeFlags |= __GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH;
        } else {
            /* Use slowest fog mode */
            modeFlags |= __GL_SHADE_SLOW_FOG;

            if ((gc->state.hints.fog == GL_NICEST) 
#ifdef GL_WIN_specular_fog
                && (!(modeFlags & __GL_SHADE_SPEC_FOG))
#endif //GL_WIN_specular_fog
                )
            {
                modeFlags |= __GL_SHADE_COMPUTE_FOG;
            }
            else
            {
                modeFlags |= __GL_SHADE_INTERP_FOG;
            }
        }
    }
    gc->polygon.shader.modeFlags = modeFlags;

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_LIGHTING)) {
        (*gc->front->pick)(gc, gc->front);
        if (gc->modes.doubleBufferMode) {
            (*gc->back->pick)(gc, gc->back);
        }
#if __GL_NUMBER_OF_AUX_BUFFERS > 0
        {
            GLint i;

            for (i = 0; i < gc->modes.maxAuxBuffers; i++) {
                (*gc->auxBuffer[i].pick)(gc, &gc->auxBuffer[i]);
            }
        }
#endif
        if (gc->modes.haveStencilBuffer) {
            (*gc->stencilBuffer.pick)(gc, &gc->stencilBuffer);
        }
        (*gc->procs.pickBufferProcs)(gc);

        /* 
        ** Note: Must call gc->front->pick and gc->back->pick before calling
        ** pickStoreProcs.  This also must be called prior to line, point, 
        ** polygon, clipping, or bitmap pickers.  The LIGHT implementation
        ** depends upon it.
        */
        (*gc->procs.pickStoreProcs)(gc);

#ifdef NT
        /*
        ** Compute the color material change bits before lighting since
        ** __glValidateLighting calls ComputeMaterialState.
        */
        ComputeColorMaterialChange(gc);
#endif

        __glValidateLighting(gc);
        
        /*
        ** Note: pickColorMaterialProcs is called frequently outside of this
        ** generic picking routine.
        */
        (*gc->procs.pickColorMaterialProcs)(gc);
        
        (*gc->procs.pickBlendProcs)(gc);
        (*gc->procs.pickFogProcs)(gc);
        
        (*gc->procs.pickParameterClipProcs)(gc);
        (*gc->procs.pickClipProcs)(gc);
        
        /*
        ** Needs to be done after pickStoreProcs.
        */
        (*gc->procs.pickRenderBitmapProcs)(gc);
        
        if (gc->validateMask & __GL_VALIDATE_ALPHA_FUNC) {
            __glValidateAlphaTest(gc);
        }
    }

#ifdef NT
    // Compute paNeeds flags PANEEDS_TEXCOORD, PANEEDS_NORMAL,
    // PANEEDS_RASTERPOS_NORMAL, PANEEDS_CLIP_ONLY, and PANEEDS_SKIP_LIGHTING.

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_LIGHTING)) 
    {
        GLuint paNeeds;

        paNeeds = gc->vertex.paNeeds;
        paNeeds &= ~(PANEEDS_TEXCOORD | PANEEDS_NORMAL |
                     PANEEDS_RASTERPOS_NORMAL | PANEEDS_CLIP_ONLY |
                     PANEEDS_SKIP_LIGHTING);

        // Compute PANEEDS_SKIP_LIGHTING flag.
        // If we're rendering with a replace mode texture which fills all
        // the color components then lighting is unnecessary in most cases.
        if ((modeFlags & __GL_SHADE_FULL_REPLACE_TEXTURE) &&
            (gc->renderMode == GL_RENDER))
            paNeeds |= PANEEDS_SKIP_LIGHTING;
        
        // Compute PANEEDS_TEXCOORD.
        // Feedback needs texture coordinates when the feedback type is
        // GL_3D_COLOR_TEXTURE or GL_4D_COLOR_TEXTURE whether or not it is
        // enabled.
        if (gc->texture.textureEnabled || gc->renderMode == GL_FEEDBACK)
            paNeeds |= PANEEDS_TEXCOORD;

        // Compute PANEEDS_NORMAL.
#ifdef NEW_NORMAL_PROCESSING
	if(enables & __GL_LIGHTING_ENABLE && 
       !(paNeeds & PANEEDS_SKIP_LIGHTING)) // uses PANEEDS_SKIP_LIGHTING computed above
        paNeeds |= PANEEDS_NORMAL;
    if (
        ((paNeeds & PANEEDS_TEXCOORD) // uses PANEEDS_TEXCOORD computed above!
	    && (enables & __GL_TEXTURE_GEN_S_ENABLE)
	    && (gc->state.texture.s.mode == GL_SPHERE_MAP))
	    ||
	    ((paNeeds & PANEEDS_TEXCOORD) // uses PANEEDS_TEXCOORD computed above!
	    && (enables & __GL_TEXTURE_GEN_T_ENABLE)
	    && (gc->state.texture.t.mode == GL_SPHERE_MAP))
	   )
        paNeeds |= PANEEDS_NORMAL_FOR_TEXTURE;
#else
	if
	(
	    ((enables & __GL_LIGHTING_ENABLE)
	  && !(paNeeds & PANEEDS_SKIP_LIGHTING)) // uses PANEEDS_SKIP_LIGHTING computed above
	 ||
	    ((paNeeds & PANEEDS_TEXCOORD) // uses PANEEDS_TEXCOORD computed above!
	  && (enables & __GL_TEXTURE_GEN_S_ENABLE)
	  && (gc->state.texture.s.mode == GL_SPHERE_MAP))
	 ||
	    ((paNeeds & PANEEDS_TEXCOORD) // uses PANEEDS_TEXCOORD computed above!
	  && (enables & __GL_TEXTURE_GEN_T_ENABLE)
	  && (gc->state.texture.t.mode == GL_SPHERE_MAP))
	)
            paNeeds |= PANEEDS_NORMAL | PANEEDS_NORMAL_FOR_TEXTURE;
#endif

        // Compute PANEEDS_RASTERPOS_NORMAL.
#ifdef NEW_NORMAL_PROCESSING
	if (enables & __GL_LIGHTING_ENABLE)
        paNeeds |= PANEEDS_RASTERPOS_NORMAL;
	 if ((enables & __GL_TEXTURE_GEN_S_ENABLE && gc->state.texture.s.mode == GL_SPHERE_MAP)
	    ||
	    (enables & __GL_TEXTURE_GEN_T_ENABLE && gc->state.texture.t.mode == GL_SPHERE_MAP))
        paNeeds |= PANEEDS_RASTERPOS_NORMAL_FOR_TEXTURE;
#else
	if
	(
	    (enables & __GL_LIGHTING_ENABLE)
	 ||
	    ((enables & __GL_TEXTURE_GEN_S_ENABLE)
	  && (gc->state.texture.s.mode == GL_SPHERE_MAP))
	 ||
	    ((enables & __GL_TEXTURE_GEN_T_ENABLE)
	  && (gc->state.texture.t.mode == GL_SPHERE_MAP))
	)
            paNeeds |= PANEEDS_RASTERPOS_NORMAL;
#endif
        // Compute PANEEDS_CLIP_ONLY.
        // It is set in selection mode to take a fast path in DrawPolyArray.
        // It must be cleared by RasterPos before calling DrawPolyArray!
        if (gc->renderMode == GL_SELECT) 
        {
            paNeeds |= PANEEDS_CLIP_ONLY;
            paNeeds &= ~PANEEDS_NORMAL;
        }

        gc->vertex.paNeeds = paNeeds;
    }

    // Compute PANEEDS_EDGEFLAG flag

    // __GL_DIRTY_POLYGON test is probably sufficient.
    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_POLYGON)) 
    {
        if (gc->state.polygon.frontMode != GL_FILL
            || gc->state.polygon.backMode  != GL_FILL)
            gc->vertex.paNeeds |= PANEEDS_EDGEFLAG;
        else
            gc->vertex.paNeeds &= ~PANEEDS_EDGEFLAG;
    }
#endif // NT

    if (gc->dirtyMask & __GL_DIRTY_POLYGON_STIPPLE) {
        /*
        ** Usually, the polygon stipple is converted immediately after
        ** it is changed.  However, if the polygon stipple was changed
        ** when this context was the destination of a CopyContext, then
        ** the polygon stipple will be converted here.
        */
        (*gc->procs.convertPolygonStipple)(gc);
    }

// Compute paNeeds flags PANEEDS_FRONT_COLOR and PANEEDS_BACK_COLOR

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_POLYGON |
        __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH))
    {
        GLuint paNeeds;

        /* 
        ** May be used for picking Rect() procs, need to check polygon 
        ** bit.  Must also be called after gc->vertex.needs is set.!!!
        ** Needs to be called prior to point, line, and triangle pickers.
        ** Also needs to be called after the store procs picker is called.
        */
        (*gc->procs.pickVertexProcs)(gc);
        
        (*gc->procs.pickSpanProcs)(gc);
        (*gc->procs.pickTriangleProcs)(gc);

#ifdef NT
// Compute front and back color needs for polygons.
// Points and lines always use the front color.
// Unlit primitives always use the front color.
//
//  Cull enable?    Two sided?  Cull face   Color needs
//       N             N         BACK        FRONT
//       N             N         FRONT       FRONT
//       N             N     FRONT_AND_BACK  FRONT
//       N             Y         BACK        FRONT/BACK
//       N             Y         FRONT       FRONT/BACK
//       N             Y     FRONT_AND_BACK  FRONT/BACK
//       Y             N         BACK        FRONT
//       Y             N         FRONT       FRONT
//       Y             N     FRONT_AND_BACK  None
//       Y             Y         BACK        FRONT
//       Y             Y         FRONT       BACK
//       Y             Y     FRONT_AND_BACK  None

        paNeeds = gc->vertex.paNeeds;
        paNeeds &= ~(PANEEDS_FRONT_COLOR | PANEEDS_BACK_COLOR);
        if (enables & __GL_LIGHTING_ENABLE) 
        {
            if (!(enables & __GL_CULL_FACE_ENABLE)) 
            {
                if (gc->state.light.model.twoSided)
                    paNeeds |= PANEEDS_FRONT_COLOR | PANEEDS_BACK_COLOR;
                else
                    paNeeds |= PANEEDS_FRONT_COLOR;
            } 
            else 
            {
                if (!(gc->state.polygon.cull == GL_FRONT_AND_BACK)) 
                {
                  if (gc->state.polygon.cull == GL_FRONT
                      && gc->state.light.model.twoSided)
                      paNeeds |= PANEEDS_BACK_COLOR;
                  else
                      paNeeds |= PANEEDS_FRONT_COLOR;
                }
            }
        } 
        else
            paNeeds |= PANEEDS_FRONT_COLOR;

        gc->vertex.paNeeds = paNeeds;
#endif
    }

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_POINT |
                         __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH)) {
        (*gc->procs.pickPointProcs)(gc);
    }

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_LINE |
                         __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH)) {
        (*gc->procs.pickLineProcs)(gc);
    }

    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_PIXEL | 
                         __GL_DIRTY_LIGHTING | __GL_DIRTY_DEPTH)) {
        (*gc->procs.pickPixelProcs)(gc);
    }

    /*
    ** deal with the depth function pointers last. This has to be done last.
    */
    if (gc->dirtyMask & (__GL_DIRTY_GENERIC | __GL_DIRTY_DEPTH)) {
        (*gc->procs.pickDepthProcs)(gc);
    }

    gc->validateMask = 0;
    gc->dirtyMask = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_polyc.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.16 $
** $Date: 1993/09/23 16:33:23 $
*/
#include "precomp.h"
#pragma hdrstop
#include <fixed.h>

/*
** Clip an input polygon against a clipping plane outputing the new
** vertex pointers in ov and return the number of them.  See the line
** clipping code for an in depth discussion of how "t" is computed.
**
** NOTE: In order to handle non-convex polygons here without dying,
** we count the number of verticies generated by clipping.  If the
** count ever gets to 3, then it must be a non-convex polygon (because
** it means the polygon crossed the clipping plane three times, which is
** impossible for a convex polygon).
*/
static GLint clipToPlane(__GLcontext *gc, __GLvertex **iv, GLint niv,
             __GLvertex **ov, GLuint offs, GLboolean negate)
{
    GLint i, nout, generated;
    __GLvertex *s, *p, *newVertex, *temp;
    __GLfloat pDist, sDist, t;
    PFN_VERTEX_CLIP_PROC clip;
#ifdef GL_WIN_phong_shading
    GLboolean doNormalize = (gc->state.enables.general & 
                             __GL_NORMALIZE_ENABLE);
#endif //GL_WIN_phong_shading

    nout = 0;
    generated = 0;
    temp = gc->transform.nextClipTemp;
    clip = gc->procs.polyClipParam;

    s = iv[niv-1];
    if (negate)
    {
        sDist = s->clip.w - *(__GLfloat *)((GLubyte *)s + offs);
    }
    else
    {
        sDist = *(__GLfloat *)((GLubyte *)s + offs) + s->clip.w;
    }

    for (i = 0; i < niv; i++) {
        p = iv[i];
        if (negate)
        {
            pDist = p->clip.w - *(__GLfloat *)((GLubyte *)p + offs);
        }
        else
        {
            pDist = *(__GLfloat *)((GLubyte *)p + offs) + p->clip.w;
        }

        if (__GL_FLOAT_GEZ(pDist)) {
            /* p is inside the clipping plane half space */
            if (__GL_FLOAT_GEZ(sDist)) {
                /* s is inside the clipping plane half space */
                *ov++ = p;
                nout++;
            } else {
                /* s is outside the clipping plane half space */
                t = pDist / (pDist - sDist);
                newVertex = temp++;
                (*clip)(newVertex, s, p, t);
#ifdef GL_WIN_phong_shading
                if (doNormalize) __glNormalize(&newVertex->normal.x, 
                                               &newVertex->normal.x);
#endif //GL_WIN_phong_shading
#ifndef NT
                // edgeflag is now part of has field.
                newVertex->boundaryEdge = s->boundaryEdge;
#endif
                newVertex->has = s->has;
                newVertex->clipCode = s->clipCode;
                ASSERTOPENGL(newVertex->color ==
                             &newVertex->colors[__GL_FRONTFACE],
                             "Vertex color pointer wrong\n");
                *ov++ = newVertex;
                *ov++ = p;
                nout += 2;
                
                if (++generated >= 3) {
                    /* Toss the non-convex polygon */
                    return 0;
                }
            }
        } else {
            /* p is outside the clipping plane half space */
            if (__GL_FLOAT_GEZ(sDist)) {
                /*
                ** s is inside the clipping plane half space
                **
                ** NOTE: To avoid cracking in polygons with shared
                ** clipped edges we always compute "t" from the out
                ** vertex to the in vertex.  The above clipping code gets
                ** this for free (p is in and s is out).  In this code p
                ** is out and s is in, so we reverse the t computation
                ** and the argument order to __glDoClip.
                */
                t = sDist / (sDist - pDist);
                newVertex = temp++;
                (*clip)(newVertex, p, s, t);
#ifdef GL_WIN_phong_shading
                if (doNormalize) __glNormalize(&newVertex->normal.x, 
                                               &newVertex->normal.x);
#endif //GL_WIN_phong_shading
#ifdef NT
                // edgeflag is now part of has field.
                newVertex->has = s->has | __GL_HAS_EDGEFLAG_BOUNDARY;
                newVertex->clipCode = p->clipCode;
#else
                newVertex->boundaryEdge = GL_TRUE;
                newVertex->has = s->has;
#endif
                ASSERTOPENGL(newVertex->color ==
                             &newVertex->colors[__GL_FRONTFACE],
                             "Vertex color pointer wrong\n");
                *ov++ = newVertex;
                nout++;
                
                if (++generated >= 3) {
                    /* Toss the non-convex polygon */
                    return 0;
                }
            } else {
                /* both points are outside */
            }
        }
        s = p;
        sDist = pDist;
    }
    gc->transform.nextClipTemp = temp;
    return nout;
}

/* 
** Identical to clipToPlane(), except that the clipping is done in eye
** space.
*/
static GLint clipToPlaneEye(__GLcontext *gc, __GLvertex **iv, GLint niv,
                __GLvertex **ov, __GLcoord *plane)
{
    GLint i, nout, generated;
    __GLvertex *s, *p, *newVertex, *temp;
    __GLfloat pDist, sDist, t;
    PFN_VERTEX_CLIP_PROC clip;
#ifdef GL_WIN_phong_shading
    GLboolean doNormalize = (gc->state.enables.general & 
                             __GL_NORMALIZE_ENABLE);
#endif //GL_WIN_phong_shading

    nout = 0;
    generated = 0;
    temp = gc->transform.nextClipTemp;
    clip = gc->procs.polyClipParam;

    s = iv[niv-1];
    sDist = (((POLYDATA *)s)->eye.x * plane->x) +
      (((POLYDATA *)s)->eye.y * plane->y) +
      (((POLYDATA *)s)->eye.z * plane->z) +
      (((POLYDATA *)s)->eye.w * plane->w);
    for (i = 0; i < niv; i++) {
        p = iv[i];
        pDist = (((POLYDATA *)p)->eye.x * plane->x) +
          (((POLYDATA *)p)->eye.y * plane->y) +
          (((POLYDATA *)p)->eye.z * plane->z) +
          (((POLYDATA *)p)->eye.w * plane->w);
        if (__GL_FLOAT_GEZ(pDist)) {
            /* p is inside the clipping plane half space */
            if (__GL_FLOAT_GEZ(sDist)) {
                /* s is inside the clipping plane half space */
                *ov++ = p;
                nout++;
            } else {
                /* s is outside the clipping plane half space */
                t = pDist / (pDist - sDist);
                newVertex = temp++;
                (*clip)(newVertex, s, p, t);
#ifdef GL_WIN_phong_shading
                if (doNormalize) __glNormalize(&newVertex->normal.x, 
                                               &newVertex->normal.x);
#endif //GL_WIN_phong_shading
                ((POLYDATA *)newVertex)->eye.x =
                  t*(((POLYDATA *)s)->eye.x - ((POLYDATA *)p)->eye.x) +
                  ((POLYDATA *)p)->eye.x;
                ((POLYDATA *)newVertex)->eye.y =
                  t*(((POLYDATA *)s)->eye.y - ((POLYDATA *)p)->eye.y) +
                  ((POLYDATA *)p)->eye.y;
                ((POLYDATA *)newVertex)->eye.z =
                  t*(((POLYDATA *)s)->eye.z - ((POLYDATA *)p)->eye.z) +
                  ((POLYDATA *)p)->eye.z;
                ((POLYDATA *)newVertex)->eye.w =
                  t*(((POLYDATA *)s)->eye.w - ((POLYDATA *)p)->eye.w) +
                  ((POLYDATA *)p)->eye.w;
#ifndef NT
                // edgeflag is now part of has field.
                newVertex->boundaryEdge = s->boundaryEdge;
#endif
                newVertex->has = s->has;
                newVertex->clipCode = s->clipCode;
                ASSERTOPENGL(newVertex->color ==
                             &newVertex->colors[__GL_FRONTFACE],
                             "Vertex color pointer wrong\n");
                *ov++ = newVertex;
                *ov++ = p;
                nout += 2;
                
                if (++generated >= 3) {
                    /* Toss the non-convex polygon */
                  return 0;
                }
            }
        } else {
            /* p is outside the clipping plane half space */
            if (__GL_FLOAT_GEZ(sDist)) {
                /*
                ** s is inside the clipping plane half space
                **
                ** NOTE: To avoid cracking in polygons with shared
                ** clipped edges we always compute "t" from the out
                ** vertex to the in vertex.  The above clipping code gets
                ** this for free (p is in and s is out).  In this code p
                ** is out and s is in, so we reverse the t computation
                ** and the argument order to __glDoClip.
                */
                t = sDist / (sDist - pDist);
                newVertex = temp++;
                (*clip)(newVertex, p, s, t);
#ifdef GL_WIN_phong_shading
                if (doNormalize) __glNormalize(&newVertex->normal.x, 
                                               &newVertex->normal.x);
#endif //GL_WIN_phong_shading

                ((POLYDATA *)newVertex)->eye.x =
                  t*(((POLYDATA *)p)->eye.x - ((POLYDATA *)s)->eye.x) +
                  ((POLYDATA *)s)->eye.x;
                ((POLYDATA *)newVertex)->eye.y =
                  t*(((POLYDATA *)p)->eye.y - ((POLYDATA *)s)->eye.y) +
                  ((POLYDATA *)s)->eye.y;
                ((POLYDATA *)newVertex)->eye.z =
                  t*(((POLYDATA *)p)->eye.z - ((POLYDATA *)s)->eye.z) +
                  ((POLYDATA *)s)->eye.z;
                ((POLYDATA *)newVertex)->eye.w =
                  t*(((POLYDATA *)p)->eye.w - ((POLYDATA *)s)->eye.w) +
                  ((POLYDATA *)s)->eye.w;
#ifdef NT
                // edgeflag is now part of has field.
                newVertex->has = s->has | __GL_HAS_EDGEFLAG_BOUNDARY;
                newVertex->clipCode = p->clipCode;
#else
                newVertex->boundaryEdge = GL_TRUE;
                newVertex->has = s->has;
#endif
                ASSERTOPENGL(newVertex->color ==
                             &newVertex->colors[__GL_FRONTFACE],
                             "Vertex color pointer wrong\n");
                *ov++ = newVertex;
                nout++;
                
                if (++generated >= 3) {
                    /* Toss the non-convex polygon */
                  return 0;
                }
            } else {
                /* both points are outside */
            }
        }
        s = p;
        sDist = pDist;
    }
    gc->transform.nextClipTemp = temp;
    return nout;
}

/*
** Each clipping plane can add at most one vertex to a convex polygon (it may
** remove up to all of the verticies).  The clipping will leave a polygon
** convex.  Because of this the maximum number of verticies output from
** the clipToPlane procedure will be total number of clip planes (assuming
** each plane adds one new vertex) plus the original number of verticies
** (3 since this if for triangles).
*/

#ifndef __CLIP_FIX
#define __GL_TOTAL_CLIP_PLANES 20   /*XXX*/
#ifdef NT
#define __GL_MAX_CLIP_VERTEX (__GL_TOTAL_CLIP_PLANES + __GL_MAX_POLYGON_CLIP_SIZE)
#else
#define __GL_MAX_CLIP_VERTEX (__GL_TOTAL_CLIP_PLANES + __GL_NVBUF)
#endif
#endif


void __glDoPolygonClip(__GLcontext *gc, __GLvertex **iv, GLint nout,
                       GLuint allClipCodes)
{
#ifndef __CLIP_FIX 
    __GLvertex *ov[__GL_TOTAL_CLIP_PLANES][__GL_MAX_CLIP_VERTEX];
#endif
    __GLvertex **ivp;
    __GLvertex **ovp;
    __GLvertex *p0, *p1, *p2;
    __GLcoord *plane;
    GLint i;
    __GLviewport *vp;
    __GLfloat one, vpXScale, vpYScale, vpZScale;
    __GLfloat vpXCenter, vpYCenter, vpZCenter;
    PFN_RENDER_TRIANGLE rt;
    __GLfloat llx, lly, urx, ury;
    __GLfloat winx, winy;
    GLuint clipCodes;

    // We have to turn rounding on.  Otherwise, the fast FP-comparison
    // routines below can fail:
    FPU_SAVE_MODE();
    FPU_ROUND_ON_PREC_HI();

    /*
    ** Reset nextClipTemp pointer for any new verticies that are generated
    ** during the clipping.
    */
    gc->transform.nextClipTemp = gc->transform.clipTemp;

    ivp = &iv[0];

    /*
    ** Check each of the clipping planes by examining the allClipCodes
    ** mask. Note that no bits will be set in allClipCodes for clip
    ** planes that are not enabled.
    */
    if (allClipCodes) {
        /* Now clip against the clipping planes */
#ifndef __CLIP_FIX
        ovp = &ov[0][0];
#else
        ovp = &(((__GLGENcontext *)gc)->pwndLocked->buffers->clip_verts[0][0]);
#endif
        /* 
        ** Do user clip planes first, because we will maintain eye coordinates
        ** only while doing user clip planes.  They are ignored for the 
        ** frustum clipping planes.
        */
        clipCodes = allClipCodes >> 6;
        if (clipCodes) {
            plane = &gc->state.transform.eyeClipPlanes[0];
            do {
                if (clipCodes & 1) {
                    nout = clipToPlaneEye(gc, ivp, nout, ovp, plane);
                    ASSERTOPENGL(nout <= __GL_MAX_CLIP_VERTEX,
                                 "Too many clip vertices\n");
                    if (nout < 3) {
                        FPU_RESTORE_MODE();
                        return;
                    }
                    ivp = ovp;
                    ovp += __GL_MAX_CLIP_VERTEX;
                }
                clipCodes >>= 1;
                plane++;
            } while (clipCodes);
        }

        allClipCodes &= __GL_FRUSTUM_CLIP_MASK;
        if (allClipCodes) {
            i = 0;
            do {
                if (allClipCodes & 1) {
                    nout = clipToPlane(gc, ivp, nout, ovp,
                                       __glFrustumOffsets[i],
                                       (GLboolean)(i & 1));
                    ASSERTOPENGL(nout <= __GL_MAX_CLIP_VERTEX,
                                 "Too many clip vertices\n");
                    if (nout < 3) {
                        FPU_RESTORE_MODE();
                        return;
                    }
                    ivp = ovp;
                    ovp += __GL_MAX_CLIP_VERTEX;
                }
                allClipCodes >>= 1;
                i++;
            } while (allClipCodes);
        }

        /*
        ** Calculate final screen coordinates.  Next phase of polygon
        ** processing assumes that window coordinates are already computed.
        */
        vp = &gc->state.viewport;
        vpXCenter = vp->xCenter;
        vpYCenter = vp->yCenter;
        vpZCenter = vp->zCenter;
        vpXScale = vp->xScale;
        vpYScale = vp->yScale;
        vpZScale = vp->zScale;
        ovp = ivp;
        one = __glOne;
        
        llx = vpXCenter - vpXScale;
        urx = vpXCenter + vpXScale;
        if (vpYScale > 0) {
            lly = vpYCenter - vpYScale;
            ury = vpYCenter + vpYScale;
        } else {
            lly = vpYCenter + vpYScale;
            ury = vpYCenter - vpYScale;
        }
        
        for (i = nout; --i >= 0; ) {
            __GLfloat x, y, z, wInv;

            p0 = *ovp++;
            
            // If the clipCode is zero then the window coordinates
            // were computed at the time of clipCode determination
            // Generated vertices' clipCodes are set to the out vertex
            // to ensure that their window coords are computed
            if (p0->clipCode != 0)
            {
#ifdef NT
                /* XXX (mf) prevent divide-by-zero */
                if (__GL_FLOAT_EQZ(p0->clip.w))
                    wInv = __glZero;
                else 
                    wInv = one / p0->clip.w;
#else
                wInv = one / p0->clip.w;
#endif
                x = p0->clip.x; y = p0->clip.y; z = p0->clip.z;
                winx = x * vpXScale * wInv + vpXCenter;
                winy = y * vpYScale * wInv + vpYCenter;
                p0->window.z = z * vpZScale * wInv + vpZCenter;
                p0->window.w = wInv;
                /* 
                ** Check if these window coordinates are legal.  At this 
                ** point, it is quite possible that they are not.  Trivially
                ** pull them into the legal viewport region if necessary.
                */
                if (winx < llx) winx = llx;
                else if (winx > urx) winx = urx;
                if (winy < lly) winy = lly;
                else if (winy > ury) winy = ury;
                p0->window.x = winx;
                p0->window.y = winy;
            }
        }
    }

    // Restore mode before rendering
    FPU_RESTORE_MODE();

#if 0 //def GL_WIN_phong_shading
    if (gc->state.light.shadingModel == GL_PHONG_EXT)
    {
        __GLvertex *minv;
        __GLvertex **cv;
        GLint j, index;

        minv = *ivp; index=0;
        
        //Reorder the vertices so that p0 is the one with the least y and x 
        for (i=0, cv=ivp; i<nout; i++, cv++)
        {
            if (__GL_VERTEX_COMPARE((*cv)->window.y, <, minv->window.y))
            {
                minv = *cv;
                index = i;
            }
            else if (__GL_VERTEX_COMPARE((*cv)->window.y, ==, minv->window.y))
            {
                if (__GL_VERTEX_COMPARE((*cv)->window.x, <, minv->window.x))
                {
                    minv = *cv;
                    index = i;
                }
            }
        }

        DbgPrint ("MinIndex = %d\n", index);
        
        j = index;
        p0 = (__GLvertex *) ivp[j];
        p1 = (__GLvertex *) ivp[(++j)%nout];
        p2 = (__GLvertex *) ivp[(++j)%nout];
        rt = gc->procs.renderTriangle;
        if (nout == 3) 
        {
            (*rt)(gc, p0, p1, p2);
        } 
        else 
        {
            for (i = 0; i < nout - 2; i++) 
            {
                GLuint t1, t2;
                if (i == 0) 
                {
                    /*
                    ** Third edge of first sub-triangle is always non-boundary
                    */
                    // edgeflag is now part of has field.
                    t1 = p2->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                    p2->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                    (*rt)(gc, p0, p1, p2);
                    p2->has |= t1;
                } 
                else
                    if (i == nout - 3) 
                    {
                        /*
                        ** First edge of last sub-triangle is always 
                        ** non-boundary
                        */
                        // edgeflag is now part of has field.
                        t1 = p0->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                        p0->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                        (*rt)(gc, p0, p1, p2);
                        p0->has |= t1;
                    } 
                    else 
                    {
                        /*
                        ** Interior sub-triangles have the first and last edge
                        ** marked non-boundary
                        */
                        // edgeflag is now part of has field.
                        t1 = p0->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                        t2 = p2->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                        p0->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                        p2->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                        (*rt)(gc, p0, p1, p2);
                        p0->has |= t1;
                        p2->has |= t2;
                    }
                p1 = p2;
                p2 = (__GLvertex *) ivp[(++j)%nout];
            }
        }
    }
    else
    {
#endif //GL_WIN_phong_shading

    /*
    ** Subdivide the clipped polygon into triangles.  Only convex polys
    ** are supported so this is okay to do.  Non-convex polys will do
    ** something odd here, but thats the clients fault.
    */
    p0 = *ivp++;
    p1 = *ivp++;
    p2 = *ivp++;
    rt = gc->procs.renderTriangle;
    if (nout == 3) 
    {
        (*rt)(gc, p0, p1, p2);
    } 
    else 
    {
        for (i = 0; i < nout - 2; i++) 
        {
              GLuint t1, t2;
              if (i == 0) 
              {
                  /*
                  ** Third edge of first sub-triangle is always non-boundary
                  */
                  // edgeflag is now part of has field.
                  t1 = p2->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                  p2->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                  (*rt)(gc, p0, p1, p2);
                  p2->has |= t1;
              } 
              else
                  if (i == nout - 3) 
                  {
                      /*
                      ** First edge of last sub-triangle is always 
                      ** non-boundary
                      */
                      // edgeflag is now part of has field.
                      t1 = p0->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                      p0->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                      (*rt)(gc, p0, p1, p2);
                      p0->has |= t1;
                  } 
                  else 
                  {
                      /*
                      ** Interior sub-triangles have the first and last edge
                      ** marked non-boundary
                      */
                      // edgeflag is now part of has field.
                      t1 = p0->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                      t2 = p2->has & __GL_HAS_EDGEFLAG_BOUNDARY;
                      p0->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                      p2->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
                      (*rt)(gc, p0, p1, p2);
                      p0->has |= t1;
                      p2->has |= t2;
                  }
              p1 = p2;
              p2 = (__GLvertex *) *ivp++;
        }
    }
#if 0 //def GL_WIN_phong_shading
    }
#endif //GL_WIN_phong_shading
}

void FASTCALL __glClipPolygon(__GLcontext *gc, __GLvertex *v0, GLint nv)
{
#ifdef NT
    __GLvertex *iv[__GL_MAX_POLYGON_CLIP_SIZE];
#else
    __GLvertex *iv[__GL_NVBUF];
#endif
    __GLvertex **ivp;
    GLint i;
    GLuint andCodes, orCodes;

    gc->vertex.provoking = v0;

    /*
    ** Generate array of addresses of the verticies.  And all the
    ** clip codes together while we are at it.
    */
    ivp = &iv[0];
    andCodes = (GLuint)(-1);
    orCodes = 0;
    for (i = nv; --i >= 0; ) {
    andCodes &= v0->clipCode;
    orCodes |= v0->clipCode;
    *ivp++ = v0++;
    }

    if (andCodes != 0) {
    /*
    ** Trivially reject the polygon.  If andCodes is non-zero then
    ** every vertex in the polygon is outside of the same set of
    ** clipping planes (at least one).
    */
    return;
    }
    __glDoPolygonClip(gc, &iv[0], nv, orCodes);
}

void FASTCALL __glClipTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
              __GLvertex *c, GLuint orCodes)
{
    __GLvertex *iv[3];

    iv[0] = a;
    iv[1] = b;
    iv[2] = c;

    __glDoPolygonClip(gc, &iv[0], 3, orCodes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_pntaa.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.10 $
** $Date: 1993/06/18 00:30:15 $
*/
#include "precomp.h"
#pragma hdrstop

#include <fixed.h>

/*
** This is a little wierd.  What it does is to dither "comp" into the high
** n-4 bits, and add 16 * antiAliasPercent.  Dithering of the low bits is
** left to the usual methods (the store and span procs, for example).
*/
__GLfloat __glBuildAntiAliasIndex(__GLfloat index, 
				  __GLfloat antiAliasPercent)
{
    GLint newlowbits;

    newlowbits = (GLint)((__GL_CI_ANTI_ALIAS_DIVISOR - 1) * antiAliasPercent + (__GLfloat) 0.5);
    return (((int) index) & ~(__GL_CI_ANTI_ALIAS_DIVISOR - 1)) | newlowbits;
}

/************************************************************************/

/*
** To anti-alias points the below code operates a simple algrorithim that
** sub-samples the bounding box of the pixel area covered by the point.
** At each sub-sample the distance from the sample to the center of the
** point is computed and compared against the distance from the edge of
** the circle to the center.  If the computed distance is <= the edge
** distance then the sample is inside the circle.  All the samples for a
** particular pixel center are summed up and then the resulting value is
** divided by the total samples in the pixel.  This gives us a coverage value
** to use to adjust the fragment alpha with before storing (there is
** an analagous affect when color index anti-aliasing is being done).
**
** The code below implements this simple algrorithim, but has been tuned
** so it might be difficult to translate.  Basically, every possible operation
** that could be moved out of the Coverage code (i.e., invariants across
** the coverage test) has been done.  Also, the minimal area is sampled
** over.
*/

/* Code below knows alot about these constants so beware */
#define	__GL_FILTER_SIZE	__glOne
#define __GL_HALF_FILTER_SIZE	__glHalf
#define __GL_SAMPLES		4
#define __GL_SAMPLE_HIT		((__GLfloat) 0.0625)	/* 1 / (4*4) */
#define __GL_SAMPLE_DELTA	((__GLfloat) 0.25)	/* 1 / 4 */
#define __GL_HALF_SAMPLE_DELTA	((__GLfloat) 0.125)
/* -halffilter + half delta */
#define __GL_COORD_ADJUST	((__GLfloat) -0.375)

/*
** Return an estimate of the pixel coverage using sub-sampling.
**
** NOTE: The subtraction of xCenter,yCenter has been moved into the
** caller to save time.  Consequently the starting coordinate may not be
** on a pixel center, but thats ok.
*/
static __GLfloat Coverage(__GLfloat xStart, __GLfloat yStart,
			  __GLfloat radiusSquared)
{
    GLint i;
    __GLfloat delta, yBottom, sampleX, sampleY;
    __GLfloat hits, hitsInc;

    /*
    ** Get starting sample x & y positions.  We take our starting
    ** coordinate, back off half a filter size then add half a delta to
    ** it.  This constrains the sampling to lie entirely within the
    ** pixel, never on the edges of the pixel.  The constants above
    ** have this adjustment pre-computed.
    */
    sampleX = xStart + __GL_COORD_ADJUST;
    yBottom = yStart + __GL_COORD_ADJUST;

    delta = __GL_SAMPLE_DELTA;
    hits = __glZero;
    hitsInc = __GL_SAMPLE_HIT;
    for (i = __GL_SAMPLES; --i >= 0; ) {
	__GLfloat check = radiusSquared - sampleX * sampleX;

	/* Unrolled inner loop - change this code if __GL_SAMPLES changes */
	sampleY = yBottom;
	if (sampleY * sampleY <= check) {
	    hits += hitsInc;
	}
	sampleY += delta;
	if (sampleY * sampleY <= check) {
	    hits += hitsInc;
	}
	sampleY += delta;
	if (sampleY * sampleY <= check) {
	    hits += hitsInc;
	}
	sampleY += delta;
	if (sampleY * sampleY <= check) {
	    hits += hitsInc;
	}

	sampleX += delta;
    }
    return hits;
}

void FASTCALL __glRenderAntiAliasedRGBPoint(__GLcontext *gc, __GLvertex *vx)
{
    __GLfloat xCenter, yCenter, radius, radiusSquared, coverage, x, y;
    __GLfloat zero, one, oldAlpha, xStart;
    __GLfloat tmp;
    __GLfragment frag;
    GLint w, width, height, ixLeft, iyBottom;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    /*
    ** Determine area to compute coverage over.  The area is bloated by
    ** the filter's width & height implicitly.  By truncating to integer
    ** (NOTE: the x,y coordinate is always positive here) we are
    ** guaranteed to find the lowest coordinate that needs examination
    ** because of the nature of circles.  Similarly, by truncating the
    ** ending coordinate and adding one we get the pixel just past the
    ** upper/right edge of the circle.
    */
    radius = gc->state.point.smoothSize * __glHalf;
    radiusSquared = radius * radius;
    xCenter = vx->window.x;
    yCenter = vx->window.y;

    /* Truncate down to get starting coordinate */
    tmp = xCenter-radius;
    ixLeft = __GL_VERTEX_FLOAT_TO_INT(tmp);
    tmp = yCenter-radius;
    iyBottom = __GL_VERTEX_FLOAT_TO_INT(tmp);

    /*
    ** Truncate down and add 1 to get the ending coordinate, then subtract
    ** out the start to get the width & height.
    */
    tmp = xCenter+radius;
    width = __GL_VERTEX_FLOAT_TO_INT(tmp) + 1 - ixLeft;
    tmp = yCenter+radius;
    height = __GL_VERTEX_FLOAT_TO_INT(tmp) + 1 - iyBottom;

    /*
    ** Setup fragment.  The fragment base color will be constant
    ** (approximately) across the entire pixel.  The only thing that will
    ** change is the alpha (for rgb) or the red component (for color
    ** index).
    */
    frag.z = (__GLzValue)vx->window.z;
    frag.color = *vx->color;
    if (modeFlags & __GL_SHADE_TEXTURE) {
	(*gc->procs.texture)(gc, &frag.color, vx->texture.x, vx->texture.y,
			       __glOne);
    }

    if (gc->polygon.shader.modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        (*gc->procs.fogPoint)(gc, &frag, vx->eyeZ);
    }
    else if ((gc->polygon.shader.modeFlags & __GL_SHADE_INTERP_FOG)
             || 
             ((modeFlags & (__GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH_LIGHT)) 
                 == __GL_SHADE_CHEAP_FOG))
    {
        (*gc->procs.fogColor)(gc, &frag.color, &frag.color, vx->fog);
    }
    

    /*
    ** Now render the circle centered on xCenter,yCenter.  Move the
    ** subtraction of xCenter,yCenter outside of the loop to doing
    ** it up front in xStart and y.  This way the coverage code can
    ** assume the incoming starting coordinate has been properly
    ** adjusted.
    */
    zero = __glZero;
    one = __glOne;
    oldAlpha = frag.color.a;
    xStart = ixLeft + __glHalf - xCenter;
    y = iyBottom + __glHalf - yCenter;
    frag.y = iyBottom;
    while (--height >= 0) {
	x = xStart;
	frag.x = ixLeft;
	for (w = width; --w >= 0; ) {
	    coverage = Coverage(x, y, radiusSquared);
	    if (coverage > zero) {
		frag.color.a = oldAlpha * coverage;
		(*gc->procs.store)(gc->drawBuffer, &frag);
	    }
	    x += one;
	    frag.x++;
	}
	y += one;
	frag.y++;
    }
}

void FASTCALL __glRenderAntiAliasedCIPoint(__GLcontext *gc, __GLvertex *vx)
{
    __GLfloat xCenter, yCenter, radius, radiusSquared, coverage, x, y;
    __GLfloat zero, one, oldIndex, xStart;
    __GLfloat tmp;
    __GLfragment frag;
    GLint w, width, height, ixLeft, iyBottom;

    /*
    ** Determine area to compute coverage over.  The area is bloated by
    ** the filter's width & height implicitly.  By truncating to integer
    ** (NOTE: the x,y coordinate is always positive here) we are
    ** guaranteed to find the lowest coordinate that needs examination
    ** because of the nature of circles.  Similarly, by truncating the
    ** ending coordinate and adding one we get the pixel just past the
    ** upper/right edge of the circle.
    */
    radius = gc->state.point.smoothSize * __glHalf;
    radiusSquared = radius * radius;
    xCenter = vx->window.x;
    yCenter = vx->window.y;

    /* Truncate down to get starting coordinate */
    tmp = xCenter-radius;
    ixLeft = __GL_VERTEX_FLOAT_TO_INT(tmp);
    tmp = yCenter-radius;
    iyBottom = __GL_VERTEX_FLOAT_TO_INT(tmp);

    /*
    ** Truncate down and add 1 to get the ending coordinate, then subtract
    ** out the start to get the width & height.
    */
    tmp = xCenter+radius;
    width = __GL_VERTEX_FLOAT_TO_INT(tmp) + 1 - ixLeft;
    tmp = yCenter+radius;
    height = __GL_VERTEX_FLOAT_TO_INT(tmp) + 1 - iyBottom;

    /*
    ** Setup fragment.  The fragment base color will be constant
    ** (approximately) across the entire pixel.  The only thing that will
    ** change is the alpha (for rgb) or the red component (for color
    ** index).
    */
    frag.z = (__GLzValue)vx->window.z;
    frag.color.r = vx->color->r;

    if (gc->polygon.shader.modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        (*gc->procs.fogPoint)(gc, &frag, vx->eyeZ);
    }
    else if ((gc->polygon.shader.modeFlags & __GL_SHADE_INTERP_FOG)
             || 
             ((gc->polygon.shader.modeFlags & (__GL_SHADE_CHEAP_FOG | 
                                               __GL_SHADE_SMOOTH_LIGHT)) 
              == __GL_SHADE_CHEAP_FOG))
    {
        (*gc->procs.fogColor)(gc, &frag.color, &frag.color, vx->fog);
    }

    /*
    ** Now render the circle centered on xCenter,yCenter.  Move the
    ** subtraction of xCenter,yCenter outside of the loop to doing
    ** it up front in xStart and y.  This way the coverage code can
    ** assume the incoming starting coordinate has been properly
    ** adjusted.
    */
    zero = __glZero;
    one = __glOne;
    oldIndex = frag.color.r;
    xStart = ixLeft + __glHalf - xCenter;
    y = iyBottom + __glHalf - yCenter;
    frag.y = iyBottom;
    while (--height >= 0) {
	x = xStart;
	frag.x = ixLeft;
	for (w = width; --w >= 0; ) {
	    coverage = Coverage(x, y, radiusSquared);
	    if (coverage > zero) {
		frag.color.r = __glBuildAntiAliasIndex(oldIndex, coverage);
		(*gc->procs.store)(gc->drawBuffer, &frag);
	    }
	    x += one;
	    frag.x++;
	}
	y += one;
	frag.y++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_polyd.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include <fixed.h>

/* This routine sets gc->polygon.shader.cfb to gc->drawBuffer */

static void FASTCALL FillSubTriangle(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint dxLeftFrac, dxRightFrac;
    GLint dxLeftLittle, dxRightLittle;
    GLint dxLeftBig, dxRightBig;
    GLint spanWidth, clipY0, clipY1;
    GLuint modeFlags;
#ifdef NT
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    __GLcolor colors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor fbcolors[__GL_MAX_STACKED_COLORS>>1];
    __GLcolor *vColors, *vFbcolors;
    int iMaxWidth, iDy, dxLeft, dxRight;

    ixLeft = gc->polygon.shader.ixLeft;
    dxLeft = (gc->polygon.shader.dxLeftBig < gc->polygon.shader.dxLeftLittle) ?
        gc->polygon.shader.dxLeftBig : gc->polygon.shader.dxLeftLittle;
    ixRight = gc->polygon.shader.ixRight;
    dxRight = (gc->polygon.shader.dxRightBig > gc->polygon.shader.dxRightLittle) ?
        gc->polygon.shader.dxRightBig : gc->polygon.shader.dxRightLittle;
    iMaxWidth = ixRight - ixLeft;
    iDy = iyTop - iyBottom - 1;
    ixRight += dxRight * iDy;
    ixLeft += dxLeft * iDy;
    iMaxWidth = (iMaxWidth < (ixRight - ixLeft)) ? ixRight - ixLeft :
        iMaxWidth;
    
    if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (iMaxWidth+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return;
        }
    }
    else
    {
        words = stackWords;
    }
    
    if (iMaxWidth > (__GL_MAX_STACKED_COLORS>>1))
    {
        vColors = (__GLcolor *) gcTempAlloc(gc, iMaxWidth * sizeof(__GLcolor));
        if (NULL == vColors)
        {
            if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            return;
        }

        vFbcolors = (__GLcolor *) gcTempAlloc(gc, iMaxWidth * sizeof(__GLcolor));
        if (NULL == vFbcolors) {
            if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
            {
                gcTempFree(gc, words);
            }
            gcTempFree(gc, vColors);
            return;
        }
    }
    else
    {
        vColors = colors;
        vFbcolors = fbcolors;
    }
#else
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
    __GLcolor vColors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
    __GLcolor vFbcolors[__GL_MAX_MAX_VIEWPORT];/*XXX oink */
#endif

    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;
    dxLeftFrac = gc->polygon.shader.dxLeftFrac;
    dxLeftBig = gc->polygon.shader.dxLeftBig;
    dxLeftLittle = gc->polygon.shader.dxLeftLittle;
    dxRightFrac = gc->polygon.shader.dxRightFrac;
    dxRightBig = gc->polygon.shader.dxRightBig;
    dxRightLittle = gc->polygon.shader.dxRightLittle;
    modeFlags = gc->polygon.shader.modeFlags;

    gc->polygon.shader.colors = vColors;
    gc->polygon.shader.fbcolors = vFbcolors;
    gc->polygon.shader.stipplePat = words;
    if (modeFlags & __GL_SHADE_STENCIL_TEST) {
        gc->polygon.shader.sbuf =
            __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
                              ixLeft, iyBottom);
    }
    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
#ifdef NT
        if( gc->modes.depthBits == 32 )
            gc->polygon.shader.zbuf = (__GLzValue *)
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                ixLeft, iyBottom);
        else
            gc->polygon.shader.zbuf = (__GLzValue *)
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                ixLeft, iyBottom);
#else
        gc->polygon.shader.zbuf =
            __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                            ixLeft, iyBottom);
#endif
    }
    gc->polygon.shader.cfb = gc->drawBuffer;
    while (iyBottom < iyTop) {
        spanWidth = ixRight - ixLeft;
        /*
        ** Only render spans that have non-zero width and which are
        ** not scissored out vertically.
        */
        if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) {
            gc->polygon.shader.frag.x = ixLeft;
            gc->polygon.shader.frag.y = iyBottom;
            gc->polygon.shader.length = spanWidth;
            (*gc->procs.span.processSpan)(gc);
        }

        /* Advance right edge fixed point, adjusting for carry */
        ixRightFrac += dxRightFrac;
        if (ixRightFrac < 0) {
            /* Carry/Borrow'd. Use large step */
            ixRight += dxRightBig;
            ixRightFrac &= ~0x80000000;
        } else {
            ixRight += dxRightLittle;
        }

        iyBottom++;
        ixLeftFrac += dxLeftFrac;
        if (ixLeftFrac < 0) {
            /* Carry/Borrow'd.  Use large step */
            ixLeft += dxLeftBig;
            ixLeftFrac &= ~0x80000000;

            if (modeFlags & __GL_SHADE_RGB) {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    gc->polygon.shader.frag.color.r += gc->polygon.shader.rBig;
                    gc->polygon.shader.frag.color.g += gc->polygon.shader.gBig;
                    gc->polygon.shader.frag.color.b += gc->polygon.shader.bBig;
                    gc->polygon.shader.frag.color.a += gc->polygon.shader.aBig;
                }
                if (modeFlags & __GL_SHADE_TEXTURE) {
                    gc->polygon.shader.frag.s += gc->polygon.shader.sBig;
                    gc->polygon.shader.frag.t += gc->polygon.shader.tBig;
                    gc->polygon.shader.frag.qw += gc->polygon.shader.qwBig;
                }
            } else {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    gc->polygon.shader.frag.color.r += gc->polygon.shader.rBig;
                }
            }
            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.sbuf = (__GLstencilCell*)
                    ((GLubyte*) gc->polygon.shader.sbuf
                     + gc->polygon.shader.sbufBig);
            }
            if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                gc->polygon.shader.frag.z += gc->polygon.shader.zBig;
            }

            if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.zbuf = (__GLzValue*)
                    ((GLubyte*) gc->polygon.shader.zbuf
                     + gc->polygon.shader.zbufBig);
            }

            if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
            {
                gc->polygon.shader.frag.f += gc->polygon.shader.fBig;
            }
        } else {
            /* Use small step */
            ixLeft += dxLeftLittle;
            if (modeFlags & __GL_SHADE_RGB) {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    gc->polygon.shader.frag.color.r += gc->polygon.shader.rLittle;
                    gc->polygon.shader.frag.color.g += gc->polygon.shader.gLittle;
                    gc->polygon.shader.frag.color.b += gc->polygon.shader.bLittle;
                    gc->polygon.shader.frag.color.a += gc->polygon.shader.aLittle;
                }
                if (modeFlags & __GL_SHADE_TEXTURE) {
                    gc->polygon.shader.frag.s += gc->polygon.shader.sLittle;
                    gc->polygon.shader.frag.t += gc->polygon.shader.tLittle;
                    gc->polygon.shader.frag.qw += gc->polygon.shader.qwLittle;
                }
            } else {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    gc->polygon.shader.frag.color.r += gc->polygon.shader.rLittle;
                }
            }
            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.sbuf = (__GLstencilCell*)
                    ((GLubyte*) gc->polygon.shader.sbuf
                     + gc->polygon.shader.sbufLittle);
            }
            if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                gc->polygon.shader.frag.z += gc->polygon.shader.zLittle;
            }
            if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                /* The implicit multiply is taken out of the loop */
                gc->polygon.shader.zbuf = (__GLzValue*)
                    ((GLubyte*) gc->polygon.shader.zbuf
                     + gc->polygon.shader.zbufLittle);
            }

            if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
            {
                gc->polygon.shader.frag.f += gc->polygon.shader.fLittle;
            }
        }
    }
    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;
#ifdef NT
    if (iMaxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
    if (iMaxWidth > (__GL_MAX_STACKED_COLORS>>1))
    {
        gcTempFree(gc, vColors);
        gcTempFree(gc, vFbcolors);
    }
#endif
}

static void SnapXLeft(__GLcontext *gc, __GLfloat xLeft, __GLfloat dxdyLeft)
{
    GLint ixLeft, ixLeftFrac, lineBytes, elementSize, iLittle, iBig;

    ASSERT_CHOP_ROUND();
    
    ixLeft = __GL_VERTEX_FLOAT_TO_INT(xLeft);
    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixLeftFrac = __GL_VERTEX_PROMOTED_FRACTION(xLeft) + 0x40000000;

    gc->polygon.shader.ixLeft = ixLeft + (((GLuint) ixLeftFrac) >> 31);
    gc->polygon.shader.ixLeftFrac = ixLeftFrac & ~0x80000000;

    /* Compute big and little steps */
    iLittle = FTOL(dxdyLeft);
    gc->polygon.shader.dxLeftFrac = FLT_FRACTION(dxdyLeft - iLittle);
    if (dxdyLeft < 0) {
	iBig = iLittle - 1;
    } else {
	iBig = iLittle + 1;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_STENCIL_TEST) {
	/*
	** Compute the big and little stencil buffer steps.  We walk the
	** memory pointers for the stencil buffer along the edge of the
	** triangle as we walk the edge.  This way we don't have to
	** recompute the buffer address as we go.
	*/
	elementSize = gc->stencilBuffer.buf.elementSize;
	lineBytes = elementSize * gc->stencilBuffer.buf.outerWidth;
	gc->polygon.shader.sbufLittle = lineBytes + iLittle * elementSize;
	gc->polygon.shader.sbufBig = lineBytes + iBig * elementSize;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
	/*
	** Compute the big and little depth buffer steps.  We walk the
	** memory pointers for the depth buffer along the edge of the
	** triangle as we walk the edge.  This way we don't have to
	** recompute the buffer address as we go.
	*/
	elementSize = gc->depthBuffer.buf.elementSize;
	lineBytes = elementSize * gc->depthBuffer.buf.outerWidth;
	gc->polygon.shader.zbufLittle = lineBytes + iLittle * elementSize;
	gc->polygon.shader.zbufBig = lineBytes + iBig * elementSize;
    }
    gc->polygon.shader.dxLeftLittle = iLittle;
    gc->polygon.shader.dxLeftBig = iBig;
}

static void SnapXRight(__GLshade *sh, __GLfloat xRight, __GLfloat dxdyRight)
{
    GLint ixRight, ixRightFrac, iLittle, iBig;

    ASSERT_CHOP_ROUND();
    
    ixRight = __GL_VERTEX_FLOAT_TO_INT(xRight);
    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixRightFrac = __GL_VERTEX_PROMOTED_FRACTION(xRight) + 0x40000000;

    sh->ixRight = ixRight + (((GLuint) ixRightFrac) >> 31);
    sh->ixRightFrac = ixRightFrac & ~0x80000000;

    /* Compute big and little steps */
    iLittle = FTOL(dxdyRight);
    sh->dxRightFrac = FLT_FRACTION(dxdyRight - iLittle);
    if (dxdyRight < 0) {
	iBig = iLittle - 1;
    } else {
	iBig = iLittle + 1;
    }
    sh->dxRightLittle = iLittle;
    sh->dxRightBig = iBig;
}


__GLfloat __glPolygonOffsetZ(__GLcontext *gc )
{

    __GLshade *sh = &gc->polygon.shader;
    __GLfloat factor;
    __GLfloat maxdZ;
    __GLfloat bias;
    __GLfloat offsetZ;

    /*
    ** Calculate factor and bias
    */
    factor = gc->state.polygon.factor;

    // For 16-bit z, bias = units,
    // For 32-bit z, we only have 24 bits of resolution from the floating
    // point z value.  Therefore, the minimum resolvable difference in z
    // values is 8-bits, and we multiply units by 2**8, or 256.

    if( gc->modes.depthBits == 16 )
        bias = gc->state.polygon.units;
    else
        bias = gc->state.polygon.units * __glVal256;

    /*
    ** find the maximum Z slope with respect to X and Y
    */
    // Note: all z values have already been scaled up from [0,1]
    if(__GL_ABSF(sh->dzdxf) > __GL_ABSF(sh->dzdyf))
        maxdZ = __GL_ABSF(sh->dzdxf);
    else
        maxdZ = __GL_ABSF(sh->dzdyf);

    offsetZ = factor * maxdZ + bias;

    // XXX! This value should really be clamped, but supposedly we don't
    // bother in other parts of the code, so leave it for now.  Clamping
    // should also only be applied AFTER the addition of offsetZ to any
    // base value.
    return( offsetZ );
}

#ifdef NT
static void SetInitialParameters(__GLcontext *gc, const __GLvertex *a,
				 const __GLcolor *ac, __GLfloat aFog,
				 __GLfloat dx, __GLfloat dy)
{
    __GLshade *sh = &gc->polygon.shader;
#else
static void SetInitialParameters(__GLshade *sh, const __GLvertex *a,
				 const __GLcolor *ac, __GLfloat aFog,
				 __GLfloat dx, __GLfloat dy)
{
#endif
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat big = sh->dxLeftBig;
    GLuint modeFlags = sh->modeFlags;
#define bPolygonOffset \
        (gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE )


    if (big > little) {
        if (modeFlags & __GL_SHADE_RGB) {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle + sh->drdx;
                
                sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
                sh->gLittle = sh->dgdy + little * sh->dgdx;
                sh->gBig = sh->gLittle + sh->dgdx;
                
                sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
                sh->bLittle = sh->dbdy + little * sh->dbdx;
                sh->bBig = sh->bLittle + sh->dbdx;

                sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
                sh->aLittle = sh->dady + little * sh->dadx;
                sh->aBig =sh->aLittle + sh->dadx;
            }
            if (modeFlags & __GL_SHADE_TEXTURE) {
                __GLfloat oneOverW = a->window.w;
                sh->frag.s = a->texture.x * oneOverW + dx*sh->dsdx
                    + dy*sh->dsdy;
                sh->sLittle = sh->dsdy + little * sh->dsdx;
                sh->sBig = sh->sLittle + sh->dsdx;
                
                sh->frag.t = a->texture.y * oneOverW + dx*sh->dtdx
                    + dy*sh->dtdy;
                sh->tLittle = sh->dtdy + little * sh->dtdx;
                sh->tBig = sh->tLittle + sh->dtdx;
                
                sh->frag.qw = a->texture.w * oneOverW + dx*sh->dqwdx
                    + dy*sh->dqwdy;
                sh->qwLittle = sh->dqwdy + little * sh->dqwdx;
                sh->qwBig = sh->qwLittle + sh->dqwdx;
                }
        } else {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle + sh->drdx;
            }
        }
        if (modeFlags & __GL_SHADE_DEPTH_ITER) {
            __GLfloat zLittle, zOffset;
            
            zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
            if (gc->modes.depthBits == 16) {
                sh->frag.z = (__GLzValue)
                    FLT_TO_Z16_SCALE(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf
                                     + zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FLT_TO_Z16_SCALE(zLittle);
                sh->zBig = FLT_TO_Z16_SCALE(zLittle + sh->dzdxf);
            }
            else {
                sh->frag.z = (__GLzValue)
                    FTOL(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf +
                         zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FTOL(zLittle);
                sh->zBig = FTOL(zLittle + sh->dzdxf);
            }
        }
        
        if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
        {
            sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
            sh->fLittle = sh->dfdy + little * sh->dfdx;
            sh->fBig = sh->fLittle + sh->dfdx;
        }
    } else {	
        if (modeFlags & __GL_SHADE_RGB) {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle - sh->drdx;
                sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
                sh->gLittle = sh->dgdy + little * sh->dgdx;
                sh->gBig = sh->gLittle - sh->dgdx;
                
                sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
                sh->bLittle = sh->dbdy + little * sh->dbdx;
                sh->bBig = sh->bLittle - sh->dbdx;
                
                sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
                sh->aLittle = sh->dady + little * sh->dadx;
                sh->aBig =sh->aLittle - sh->dadx;
            }
            if (modeFlags & __GL_SHADE_TEXTURE) {
                __GLfloat oneOverW = a->window.w;
                sh->frag.s = a->texture.x * oneOverW + dx*sh->dsdx
                    + dy*sh->dsdy;
                sh->sLittle = sh->dsdy + little * sh->dsdx;
                sh->sBig = sh->sLittle - sh->dsdx;
                
                sh->frag.t = a->texture.y * oneOverW + dx*sh->dtdx
                    + dy*sh->dtdy;
                sh->tLittle = sh->dtdy + little * sh->dtdx;
                sh->tBig = sh->tLittle - sh->dtdx;
                
                sh->frag.qw = a->texture.w * oneOverW + dx*sh->dqwdx
                    + dy*sh->dqwdy;
                sh->qwLittle = sh->dqwdy + little * sh->dqwdx;
                sh->qwBig = sh->qwLittle - sh->dqwdx;
            }
        } else {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
                sh->rLittle = sh->drdy + little * sh->drdx;
                sh->rBig = sh->rLittle - sh->drdx;
            }
        }
        if (modeFlags & __GL_SHADE_DEPTH_ITER) {
            __GLfloat zLittle, zOffset;
            
            zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
            if(( gc->modes.depthBits == 16 ) &&
               ( gc->depthBuffer.scale <= (GLuint)0xffff )) {
                sh->frag.z = (__GLzValue)
                    FLT_TO_Z16_SCALE(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf
                                     + zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FLT_TO_Z16_SCALE(zLittle);
                sh->zBig = FLT_TO_Z16_SCALE(zLittle - sh->dzdxf);
            }
            else {
                sh->frag.z = (__GLzValue)
                    FTOL( a->window.z + dx*sh->dzdxf + dy*sh->dzdyf+ zOffset );
                zLittle = sh->dzdyf + little * sh->dzdxf;
                sh->zLittle = FTOL(zLittle);
                sh->zBig = FTOL(zLittle - sh->dzdxf);
            }
        }
        
        if (modeFlags & (__GL_SHADE_COMPUTE_FOG | __GL_SHADE_INTERP_FOG))
        {
            sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
            sh->fLittle = sh->dfdy + little * sh->dfdx;
            sh->fBig = sh->fLittle - sh->dfdx;
        }
    }
}


void FASTCALL __glFillTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
		      __GLvertex *c, GLboolean ccw)

{
    __GLfloat oneOverArea, t1, t2, t3, t4;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLfloat aFog, bFog;
    __GLfloat dxAB, dyAB;
    __GLfloat dx, dy, dxdyLeft, dxdyRight;
    __GLcolor *ac, *bc;
    GLint aIY, bIY, cIY;
    GLuint modeFlags;
    __GLfloat dxdyAC;

    CHOP_ROUND_ON();
    
    /* Pre-compute one over polygon area */

    __GL_FLOAT_BEGIN_DIVIDE(__glOne, gc->polygon.shader.area, &oneOverArea);

    /* Fetch some stuff we are going to reuse */
    modeFlags = gc->polygon.shader.modeFlags;
    dxAC = gc->polygon.shader.dxAC;
    dxBC = gc->polygon.shader.dxBC;
    dyAC = gc->polygon.shader.dyAC;
    dyBC = gc->polygon.shader.dyBC;
    ac = a->color;
    bc = b->color;

    /*
    ** Compute delta values for unit changes in x or y for each
    ** parameter.
    */

    __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
    t1 = dyAC * oneOverArea;
    t2 = dyBC * oneOverArea;
    t3 = dxAC * oneOverArea;
    t4 = dxBC * oneOverArea;
    
    if (modeFlags & __GL_SHADE_RGB) {
	if (modeFlags & __GL_SHADE_SMOOTH) {
	    __GLfloat drAC, dgAC, dbAC, daAC;
	    __GLfloat drBC, dgBC, dbBC, daBC;
	    __GLcolor *cc;

	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;
	    dgAC = ac->g - cc->g;
	    dgBC = bc->g - cc->g;
	    dbAC = ac->b - cc->b;
	    dbBC = bc->b - cc->b;
	    daAC = ac->a - cc->a;
	    daBC = bc->a - cc->a;

	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
	    gc->polygon.shader.dgdx = dgAC * t2 - dgBC * t1;
	    gc->polygon.shader.dgdy = dgBC * t3 - dgAC * t4;
	    gc->polygon.shader.dbdx = dbAC * t2 - dbBC * t1;
	    gc->polygon.shader.dbdy = dbBC * t3 - dbAC * t4;
	    gc->polygon.shader.dadx = daAC * t2 - daBC * t1;
	    gc->polygon.shader.dady = daBC * t3 - daAC * t4;
	} else {
	    __GLcolor *flatColor = gc->vertex.provoking->color;
	    gc->polygon.shader.frag.color = *flatColor;
	}
	if (modeFlags & __GL_SHADE_TEXTURE) {
	    __GLfloat awinv, bwinv, cwinv, scwinv, tcwinv, qwcwinv;
	    __GLfloat dsAC, dsBC, dtAC, dtBC, dqwAC, dqwBC;

	    awinv = a->window.w;
	    bwinv = b->window.w;
	    cwinv = c->window.w;
	    scwinv = c->texture.x * cwinv;
	    tcwinv = c->texture.y * cwinv;
	    qwcwinv = c->texture.w * cwinv;

	    dsAC = a->texture.x * awinv - scwinv;
	    dsBC = b->texture.x * bwinv - scwinv;
	    dtAC = a->texture.y * awinv - tcwinv;
	    dtBC = b->texture.y * bwinv - tcwinv;
	    dqwAC = a->texture.w * awinv - qwcwinv;
	    dqwBC = b->texture.w * bwinv - qwcwinv;

	    gc->polygon.shader.dsdx = dsAC * t2 - dsBC * t1;
	    gc->polygon.shader.dsdy = dsBC * t3 - dsAC * t4;
	    gc->polygon.shader.dtdx = dtAC * t2 - dtBC * t1;
	    gc->polygon.shader.dtdy = dtBC * t3 - dtAC * t4;
	    gc->polygon.shader.dqwdx = dqwAC * t2 - dqwBC * t1;
	    gc->polygon.shader.dqwdy = dqwBC * t3 - dqwAC * t4;

	}
    } else {
	if (modeFlags & __GL_SHADE_SMOOTH) {
	    __GLfloat drAC;
	    __GLfloat drBC;
	    __GLcolor *cc;

	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;

	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
	} else {
	    __GLcolor *flatColor = gc->vertex.provoking->color;
	    gc->polygon.shader.frag.color.r = flatColor->r;
	}
    }
    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	__GLfloat dzAC, dzBC;

	dzAC = a->window.z - c->window.z;
	dzBC = b->window.z - c->window.z;

	gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
	gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;
#ifdef NT
	if(( gc->modes.depthBits == 16 ) &&
           ( gc->depthBuffer.scale <= (GLuint)0xffff )) {
	    gc->polygon.shader.dzdx = 
                FLT_TO_Z16_SCALE(gc->polygon.shader.dzdxf);
	}
	else {
	    gc->polygon.shader.dzdx = FTOL(gc->polygon.shader.dzdxf);
	}
#else
	gc->polygon.shader.dzdx = (GLint) gc->polygon.shader.dzdxf;
#endif
    }

    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        __GLfloat dfAC, dfBC, cFog;

        aFog = a->eyeZ;
        bFog = b->eyeZ;
        cFog = c->eyeZ;

        dfAC = aFog - cFog;
        dfBC = bFog - cFog;
        
        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    }
    else if (modeFlags & __GL_SHADE_INTERP_FOG)
    {
        __GLfloat dfAC, dfBC, cFog;

        aFog = a->fog;
        bFog = b->fog;
        cFog = c->fog;

        dfAC = aFog - cFog;
        dfBC = bFog - cFog;
        
        gc->polygon.shader.dfdx = dfAC * t2 - dfBC * t1;
        gc->polygon.shader.dfdy = dfBC * t3 - dfAC * t4;
    }
    

    __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(dxAC, dyAC, dxdyAC);
    
    /* Snap each y coordinate to its pixel center */
    aIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(a->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    bIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(b->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    cIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(c->window.y)+
                                   __GL_VERTEX_FRAC_HALF);

    /*
    ** This algorithim always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */
    dxAB = a->window.x - b->window.x;
    dyAB = a->window.y - b->window.y;
    if (ccw) {
	dy = (aIY + __glHalf) - a->window.y;
        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);
	SnapXLeft(gc, a->window.x + dy*dxdyAC, dxdyAC);
	dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
#ifdef NT
	SetInitialParameters(gc, a, ac, aFog, dx, dy);
#else
	SetInitialParameters(&gc->polygon.shader, a, ac, aFog, dx, dy);
#endif
	if (aIY != bIY) {
	    dxdyRight = dxAB / dyAB;
	    SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyRight,
		       dxdyRight);
	    FillSubTriangle(gc, aIY, bIY);
	}

	if (bIY != cIY) {
	    dxdyRight = dxBC / dyBC;
	    dy = (bIY + __glHalf) - b->window.y;
	    SnapXRight(&gc->polygon.shader, b->window.x + dy*dxdyRight,
		       dxdyRight);
	    FillSubTriangle(gc, bIY, cIY);
	}
    } else {
	dy = (aIY + __glHalf) - a->window.y;
        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);
	SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyAC, dxdyAC);
	if (aIY != bIY) {
	    dxdyLeft = dxAB / dyAB;
	    SnapXLeft(gc, a->window.x + dy*dxdyLeft, dxdyLeft);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
#ifdef NT
	    SetInitialParameters(gc, a, ac, aFog, dx, dy);
#else
	    SetInitialParameters(&gc->polygon.shader, a, ac, aFog, dx, dy);
#endif
	    FillSubTriangle(gc, aIY, bIY);
	}

	if (bIY != cIY) {
	    dxdyLeft = dxBC / dyBC;
	    dy = (bIY + __glHalf) - b->window.y;
	    SnapXLeft(gc, b->window.x + dy*dxdyLeft, dxdyLeft);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
#ifdef NT
	    SetInitialParameters(gc, b, bc, bFog, dx, dy);
#else
	    SetInitialParameters(&gc->polygon.shader, b, bc, bFog, dx, dy);
#endif
	    FillSubTriangle(gc, bIY, cIY);
	}
    }

    CHOP_ROUND_OFF();

}

void FASTCALL __glFillFlatFogTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
                             __GLvertex *c, GLboolean ccw)
{
    __GLcolor acol, bcol, ccol;
    __GLcolor *aocp, *bocp, *cocp;
    __GLvertex *pv;

    pv = gc->vertex.provoking;
    (*gc->procs.fogColor)(gc, &acol, pv->color, a->fog);
    (*gc->procs.fogColor)(gc, &bcol, pv->color, b->fog);
    (*gc->procs.fogColor)(gc, &ccol, pv->color, c->fog);
    aocp = a->color;
    bocp = b->color;
    cocp = c->color;
    a->color = &acol;
    b->color = &bcol;
    c->color = &ccol;

    (*gc->procs.fillTriangle2)(gc, a, b, c, ccw);

    a->color = aocp;
    b->color = bocp;
    c->color = cocp;
}

#ifdef GL_WIN_specular_fog
void FASTCALL __glFillFlatSpecFogTriangle(__GLcontext *gc, __GLvertex *a, 
                                          __GLvertex *b, __GLvertex *c, 
                                          GLboolean ccw)
{
    __GLfloat af, bf, cf;
    __GLvertex *pv;

    pv = gc->vertex.provoking;
    
    af = a->fog;
    bf = b->fog;
    cf = c->fog;
    
    a->fog = b->fog = c->fog = pv->fog;
    
    (*gc->procs.fillTriangle2)(gc, a, b, c, ccw);

    a->fog = af;
    b->fog = bf;
    c->fog = cf;
}
#endif //GL_WIN_specular_fog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_pntdr.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.12 $
** $Date: 1993/10/07 18:57:21 $
*/
#include "precomp.h"
#pragma hdrstop

#include <fixed.h>

void FASTCALL __glRenderAliasedPoint1_NoTex(__GLcontext *gc, __GLvertex *vx)
{
    __GLfragment frag;

    frag.x = __GL_VERTEX_FLOAT_TO_INT(vx->window.x);
    frag.y = __GL_VERTEX_FLOAT_TO_INT(vx->window.y);
    frag.z = (__GLzValue)FTOL(vx->window.z);
 
    /*
    ** Compute the color
    */
    frag.color = *vx->color;

    /*
    ** Fog if enabled
    */
    if ((gc->polygon.shader.modeFlags & __GL_SHADE_CHEAP_FOG) &&
        !(gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH_LIGHT))
    {
        (*gc->procs.fogColor)(gc, &frag.color, &frag.color, vx->fog);
    }
    else if (gc->polygon.shader.modeFlags & __GL_SHADE_SLOW_FOG)
    {
        (*gc->procs.fogPoint)(gc, &frag, vx->eyeZ);
    }

    /* Render the single point */
    (*gc->procs.store)(gc->drawBuffer, &frag);
}

void FASTCALL __glRenderAliasedPoint1(__GLcontext *gc, __GLvertex *vx)
{
    __GLfragment frag;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    frag.x = __GL_VERTEX_FLOAT_TO_INT(vx->window.x);
    frag.y = __GL_VERTEX_FLOAT_TO_INT(vx->window.y);
    frag.z = (__GLzValue)FTOL(vx->window.z);

    /*
    ** Compute the color
    */
    frag.color = *vx->color;
    if (modeFlags & __GL_SHADE_TEXTURE) {
	__GLfloat qInv = (vx->texture.w == (__GLfloat) 0.0) ? (__GLfloat) 0.0 : __glOne / vx->texture.w;
	(*gc->procs.texture)(gc, &frag.color, vx->texture.x * qInv,
			       vx->texture.y * qInv, __glOne);
    }

    /*
    ** Fog if enabled
    */
    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        (*gc->procs.fogPoint)(gc, &frag, vx->eyeZ);
    }
    else if ((modeFlags & __GL_SHADE_INTERP_FOG) 
             || 
             (((modeFlags & (__GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH_LIGHT)) 
               == __GL_SHADE_CHEAP_FOG)))
    {
        (*gc->procs.fogColor)(gc, &frag.color, &frag.color, vx->fog);
    }



    /* Render the single point */
    (*gc->procs.store)(gc->drawBuffer, &frag);
}

void FASTCALL __glRenderAliasedPointN(__GLcontext *gc, __GLvertex *vx)
{
    GLint pointSize, pointSizeHalf, ix, iy, xLeft, xRight, yBottom, yTop;
    __GLfragment frag;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLfloat tmp;

    /*
    ** Compute the x and y starting coordinates for rendering the square.
    */
    pointSize = gc->state.point.aliasedSize;
    pointSizeHalf = pointSize >> 1;
    if (pointSize & 1) {
	/* odd point size */
	xLeft = __GL_VERTEX_FLOAT_TO_INT(vx->window.x) - pointSizeHalf;
	yBottom = __GL_VERTEX_FLOAT_TO_INT(vx->window.y) - pointSizeHalf;
    } else {
	/* even point size */
        tmp = vx->window.x+__glHalf;
	xLeft = __GL_VERTEX_FLOAT_TO_INT(tmp) - pointSizeHalf;
        tmp = vx->window.y+__glHalf;
	yBottom = __GL_VERTEX_FLOAT_TO_INT(tmp) - pointSizeHalf;
    }
    xRight = xLeft + pointSize;
    yTop = yBottom + pointSize;

    /*
    ** Compute the color
    */
    frag.color = *vx->color;
    if (modeFlags & __GL_SHADE_TEXTURE) {
	__GLfloat qInv = __glOne / vx->texture.w;
	(*gc->procs.texture)(gc, &frag.color, vx->texture.x * qInv,
			       vx->texture.y * qInv, __glOne);
    }

    /*
    ** Fog if enabled
    */

    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        (*gc->procs.fogPoint)(gc, &frag, vx->eyeZ);
    }
    else if ((modeFlags & __GL_SHADE_INTERP_FOG) 
             || 
             (((modeFlags & (__GL_SHADE_CHEAP_FOG | __GL_SHADE_SMOOTH_LIGHT)) 
               == __GL_SHADE_CHEAP_FOG)))
    {
        (*gc->procs.fogColor)(gc, &frag.color, &frag.color, vx->fog);
    }

    
    /*
    ** Now render the square centered on xCenter,yCenter.
    */
    frag.z = (__GLzValue)FTOL(vx->window.z);
    for (iy = yBottom; iy < yTop; iy++) {
	for (ix = xLeft; ix < xRight; ix++) {
	    frag.x = ix;
	    frag.y = iy;
	    (*gc->procs.store)(gc->drawBuffer, &frag);
	}
    }
}


#ifdef __BUGGY_RENDER_POINT
void FASTCALL __glRenderFlatFogPoint(__GLcontext *gc, __GLvertex *vx)
{
    __GLcolor *vxocp;
    __GLcolor vxcol;

    (*gc->procs.fogColor)(gc, &vxcol, vx->color, vx->fog);
    vxocp = vx->color;
    vx->color = &vxcol;

    (*gc->procs.renderPoint2)(gc, vx);

    vx->color = vxocp;
}


#ifdef NT
// vx->fog is invalid if it is __GL_SHADE_SLOW_FOG!
void FASTCALL __glRenderFlatFogPointSlow(__GLcontext *gc, __GLvertex *vx)
{
    __GLcolor *vxocp;
    __GLcolor vxcol;

    // compute fog value first!
    vx->fog = __glFogVertex(gc, vx);

    (*gc->procs.fogColor)(gc, &vxcol, vx->color, vx->fog);
    vxocp = vx->color;
    vx->color = &vxcol;

    (*gc->procs.renderPoint2)(gc, vx);

    vx->color = vxocp;
}
#endif
#endif //__BUGGY_RENDER_POINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_polya.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#ifdef GL_WIN_phong_shading
#include "phong.h"
#endif //GL_WIN_phong_shading


/*
** Normal form of a line: Ax + By + C = 0.  When evaluated at a point P,
** the value is zero when P is on the line.  For points off the line,
** the sign of the value determines which side of the line P is on.
*/
typedef struct {
    __GLfloat a, b, c;

    /*
    ** The sign of an edge is determined by plugging the third vertex
    ** of the triangle into the line equation.  This flag is GL_TRUE when
    ** the sign is positive.
    */
    GLboolean edgeSign;
} __glLineEquation;

/*
** Machine state for rendering triangles.
*/
typedef struct {
    __GLfloat dyAB;
    __GLfloat dyBC;
    __glLineEquation ab;
    __glLineEquation bc;
    __glLineEquation ca;
    __GLfloat area;
    GLint areaSign;
} __glTriangleMachine;

/*
** Plane equation coefficients.  One plane equation exists for each of
** the parameters being computed across the surface of the triangle.
*/
typedef struct {
    __GLfloat a, b, c, d;
} __glPlaneEquation;

/*
** Cache for some of the coverage computation constants.
*/
typedef struct {
    __GLfloat dx, dy;
    GLint samples;
    GLint samplesSquared;
    __GLfloat samplesSquaredInv;
    GLboolean lastCoverageWasOne;
    __GLfloat leftDelta, rightDelta;
    __GLfloat bottomDelta, topDelta;
} __glCoverageStuff;

/*
** Compute the constants A, B and C for a line equation in the general
** form:  Ax + By + C = 0.  A given point at (x,y) can be plugged into
** the left side of the equation and yield a number which indiates whether
** or not the point is on the line.  If the result is zero, then the point
** is on the line.  The sign of the result determines which side of
** the line the point is on.  To handle tie cases properly we need a way
** to assign a point on the edge to only one triangle.  To do this, we
** look at the sign of the equation evaluated at "c".  For edges whose
** sign at "c" is positive, we allow points on the edge to be in the
** triangle.
*/
static void FindLineEqation(__glLineEquation *eq, const __GLvertex *a,
			    const __GLvertex *b, const __GLvertex *c)
{
    __GLfloat dy, dx, valueAtC;

    /*
    ** Sort a,b so that the ordering of the verticies is consistent,
    ** regardless of the order given to this procedure.
    */
    if (b->window.y < a->window.y) {
	const __GLvertex *temp = b;
	b = a;
	a = temp;
    } else
    if ((b->window.y == a->window.y) && (b->window.x < a->window.x)) {
	const __GLvertex *temp = b;
	b = a;
	a = temp;
    }

    dy = b->window.y - a->window.y;
    dx = b->window.x - a->window.x;
    eq->a = -dy;
    eq->b = dx;
    eq->c = dy * a->window.x - dx * a->window.y;

    valueAtC = eq->a * c->window.x + eq->b * c->window.y + eq->c;
    if (valueAtC > 0) {
	eq->edgeSign = GL_TRUE;
    } else {
	eq->edgeSign = GL_FALSE;
    }
}

/*
** Given three points in (x,y,p) find the plane equation coeffecients
** for the plane that contains the three points.  First find the cross
** product of two of the vectors defined by the three points, then
** use one of the points to find "d".
*/
static void FindPlaneEquation(__glPlaneEquation *eq,
			      const __GLvertex *a, const __GLvertex *b,
			      const __GLvertex *c, __GLfloat p1,
			      __GLfloat p2, __GLfloat p3)
{
    __GLfloat v1x, v1y, v1p;
    __GLfloat v2x, v2y, v2p;
    __GLfloat nx, ny, np, k;

    /* find vector v1 */
    v1x = b->window.x - a->window.x;
    v1y = b->window.y - a->window.y;
    v1p = p2 - p1;

    /* find vector v2 */
    v2x = c->window.x - a->window.x;
    v2y = c->window.y - a->window.y;
    v2p = p3 - p1;

    /* find the cross product (== normal) for the plane */
    nx = v1y*v2p - v1p*v2y;
    ny = v1p*v2x - v1x*v2p;
    np = v1x*v2y - v1y*v2x;

    /*
    ** V dot N = k.  Find k.  We can use any of the three points on
    ** the plane, so we use a.
    */
    k = a->window.x*nx + a->window.y*ny + p1*np;

    /*
    ** Finally, setup the plane equation coeffecients.  Force c to be one
    ** by dividing everything through by c.
    */
    eq->a = nx / np;
    eq->b = ny / np;
    eq->c = ((__GLfloat) 1.0);
    eq->d = -k / np;
}

/*
** Solve for p in the plane equation.
*/
static __GLfloat FindP(__glPlaneEquation *eq, __GLfloat x, __GLfloat y)
{
    return -(eq->a * x + eq->b * y + eq->d);
}

/*
** See if a given point is on the same side of the edge as the other
** vertex in the triangle not part of this edge.  When the line
** equation evaluates to zero, make points which are on lines with
** a negative edge sign (edgeSign GL_FALSE) part of the triangle.
*/
#define In(eq,x,y) \
    (((eq)->a * (x) + (eq)->b * (y) + (eq)->c > 0) == (eq)->edgeSign)

/*
** Determine if the point x,y is in or out of the triangle.  Evaluate
** each line equation for the point and compare the sign of the result
** with the edgeSign flag.
*/
#define Inside(tm,x,y) \
    (In(&(tm)->ab, x, y) && In(&(tm)->bc, x, y) && In(&(tm)->ca, x, y))

#define	FILTER_WIDTH	((__GLfloat) 1.0)
#define	FILTER_HEIGHT	((__GLfloat) 1.0)

/*
** Precompute stuff that is constant for all coverage tests.
*/
static void FASTCALL ComputeCoverageStuff(__glCoverageStuff *cs, GLint samples)
{
    __GLfloat dx, dy, fs = samples;
    __GLfloat half = ((__GLfloat) 0.5);

    cs->dx = dx = FILTER_WIDTH / fs;
    cs->dy = dy = FILTER_HEIGHT / fs;
    cs->leftDelta = -(FILTER_WIDTH / 2) + dx * half;
    cs->rightDelta = (FILTER_WIDTH / 2) - dx * half;
    cs->bottomDelta = -(FILTER_HEIGHT / 2) + dy * half;
    cs->topDelta = (FILTER_HEIGHT / 2) - dy * half;
    cs->samplesSquared = samples * samples;
    cs->samplesSquaredInv = ((__GLfloat) 1.0) / cs->samplesSquared;
    cs->samples = samples;
}

/*
** Return an estimate of the pixel coverage using sub-sampling.
*/
static __GLfloat Coverage(__glTriangleMachine *tm, __GLfloat *xs,
			  __GLfloat *ys, __glCoverageStuff *cs)
{
    GLint xx, yy, hits, samples;
    __GLfloat dx, dy, yBottom, px, py;
    __GLfloat minX, minY, maxX, maxY;

    hits = 0;
    samples = cs->samples;
    dx = cs->dx;
    dy = cs->dy;
    px = *xs + cs->leftDelta;
    yBottom = *ys + cs->bottomDelta;

    /*
    ** If the last coverage was one (the pixel to the left in x from us),
    ** then if the upper right and lower right sample positions are
    ** also in then this entire pixel must be in.
    */
    if (cs->lastCoverageWasOne) {
	__GLfloat urx, ury;
	urx = *xs + cs->rightDelta;
	ury = *ys + cs->topDelta;
	if (Inside(tm, urx, ury) && Inside(tm, urx, yBottom)) {
	    return ((__GLfloat) 1.0);
	}
    }

    /*
    ** Setup minimum and maximum x,y coordinates.  The min and max values
    ** are used to find a "good" point that is actually within the
    ** triangle so that parameter values can be computed correctly.
    */
    minX = 999999;
    maxX = __glMinusOne;
    minY = 999999;
    maxY = __glMinusOne;
    for (xx = 0; xx < samples; xx++) {
	py = yBottom;
	for (yy = 0; yy < samples; yy++) {
	    if (Inside(tm, px, py)) {
		if (px < minX) minX = px;
		if (px > maxX) maxX = px;
		if (py < minY) minY = py;
		if (py > maxY) maxY = py;
		hits++;
	    }
	    py += dy;
	}
	px += dx;
    }
    if (hits) {
	/*
	** Return the average of the two coordinates which is guaranteed
	** to be in the triangle.
	*/
	*xs = (minX + maxX) * ((__GLfloat) 0.5);
	*ys = (minY + maxY) * ((__GLfloat) 0.5);
	if (hits == cs->samplesSquared) {
	    /* Keep track when the last coverage was one */
	    cs->lastCoverageWasOne = GL_TRUE;
	    return ((__GLfloat) 1.0);
	}
    }
    cs->lastCoverageWasOne = GL_FALSE;
    return hits * cs->samplesSquaredInv;
}

/*
** Force f to have no more precision than the subpixel precision allows.
** Even though "f" is biased this still works and does not generate an
** overflow.
*/
#define __GL_FIX_PRECISION(f)					 \
    ((__GLfloat) ((GLint) (f * (1 << gc->constants.subpixelBits))) \
     / (1 << gc->constants.subpixelBits))

void FASTCALL __glFillAntiAliasedTriangle(__GLcontext *gc, __GLvertex *a,
				 __GLvertex *b, __GLvertex *c,
				 GLboolean ccw)
{
    __glTriangleMachine tm;
    __glCoverageStuff cs;
    __GLcolor *ca, *cb, *cc, *flatColor;
    GLint x, y, left, right, bottom, top, samples;
    __glPlaneEquation qwp, zp, rp, gp, bp, ap, ezp, sp, tp;
    __glPlaneEquation fp;
    GLboolean rgbMode;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    __GLfloat zero = __glZero;
    __GLfloat area, ax, bx, cx, ay, by, cy;
    __GLshade *sh = &gc->polygon.shader;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

#ifdef __GL_LINT
    ccw = ccw;
#endif
    /*
    ** Recompute the area of the triangle after constraining the incoming
    ** coordinates to the subpixel precision.  The viewport bias gives
    ** more precision (typically) than the subpixel precision.  Because of
    ** this the algorithim below can fail to reject an essentially empty
    ** triangle and instead fill a large area.  The scan converter fill
    ** routines (eg polydraw.c) don't have this trouble because of the
    ** very nature of edge walking.
    **
    ** NOTE: Notice that here as in other places, when the area calculation
    ** is done we are careful to do it as a series of subtractions followed by
    ** multiplications.  This is done to guarantee that no overflow will
    ** occur (remember that the coordinates are biased by a potentially large
    ** number, and that multiplying two biased numbers will square the bias).
    */
    ax = __GL_FIX_PRECISION(a->window.x);
    bx = __GL_FIX_PRECISION(b->window.x);
    cx = __GL_FIX_PRECISION(c->window.x);
    ay = __GL_FIX_PRECISION(a->window.y);
    by = __GL_FIX_PRECISION(b->window.y);
    cy = __GL_FIX_PRECISION(c->window.y);
    area = (ax - cx) * (by - cy) - (bx - cx) * (ay - cy);
    if (area == zero) {
        return;
    }

    ca = a->color;
    cb = b->color;
    cc = c->color;
    flatColor = gc->vertex.provoking->color;

    /*
    ** Construct plane equations for all of the parameters that are
    ** computed for the triangle: z, r, g, b, a, s, t, f
    */
    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
        FindPlaneEquation(&zp, a, b, c, a->window.z, b->window.z, c->window.z);
    }

    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        FindPlaneEquation(&ezp, a, b, c, a->eyeZ, b->eyeZ, c->eyeZ);
    } 
    else if (modeFlags & __GL_SHADE_INTERP_FOG)
    {
        FindPlaneEquation(&fp, a, b, c, a->fog, b->fog, c->fog);
    }

    if (modeFlags & __GL_SHADE_TEXTURE) {
        __GLfloat one = __glOne;
        __GLfloat aWInv = a->window.w;
        __GLfloat bWInv = b->window.w;
        __GLfloat cWInv = c->window.w;
        FindPlaneEquation(&qwp, a, b, c, a->texture.w * aWInv,
                          b->texture.w * bWInv, c->texture.w * cWInv);
        FindPlaneEquation(&sp, a, b, c, a->texture.x * aWInv,
                          b->texture.x * bWInv, c->texture.x * cWInv);
        FindPlaneEquation(&tp, a, b, c, a->texture.y * aWInv,
                          b->texture.y * bWInv, c->texture.y * cWInv);
    }
    rgbMode = gc->modes.rgbMode;
    if (modeFlags & __GL_SHADE_SMOOTH) {
        FindPlaneEquation(&rp, a, b, c, ca->r, cb->r, cc->r);
        if (rgbMode) {
            FindPlaneEquation(&gp, a, b, c, ca->g, cb->g, cc->g);
            FindPlaneEquation(&bp, a, b, c, ca->b, cb->b, cc->b);
            FindPlaneEquation(&ap, a, b, c, ca->a, cb->a, cc->a);
        }
    }

    /*
    ** Compute general form of the line equations for each of the
    ** edges of the triangle.
    */
    FindLineEqation(&tm.ab, a, b, c);
    FindLineEqation(&tm.bc, b, c, a);
    FindLineEqation(&tm.ca, c, a, b);

    /* Compute bounding box of the triangle */
    left = (GLint)a->window.x;
    if (b->window.x < left) left = (GLint)b->window.x;
    if (c->window.x < left) left = (GLint)c->window.x;
    right = (GLint)a->window.x;
    if (b->window.x > right) right = (GLint)b->window.x;
    if (c->window.x > right) right = (GLint)c->window.x;
    bottom = (GLint)a->window.y;
    if (b->window.y < bottom) bottom = (GLint)b->window.y;
    if (c->window.y < bottom) bottom = (GLint)c->window.y;
    top = (GLint)a->window.y;
    if (b->window.y > top) top = (GLint)b->window.y;
    if (c->window.y > top) top = (GLint)c->window.y;

    /* Bloat the bounding box when anti aliasing */
    left -= (GLint)FILTER_WIDTH;
    right += (GLint)FILTER_WIDTH;
    bottom -= (GLint)FILTER_HEIGHT;
    top += (GLint)FILTER_HEIGHT;
    
    /* Init coverage computations */
    samples = (gc->state.hints.polygonSmooth == GL_NICEST) ? 8 : 4;
    ComputeCoverageStuff(&cs, samples);
    
    /* Scan over the bounding box of the triangle */
    for (y = bottom; y <= top; y++) {
        cs.lastCoverageWasOne = GL_FALSE;
        for (x = left; x <= right; x++) {
            __GLfloat coverage;
            __GLfloat xs, ys;

            if (modeFlags & __GL_SHADE_STIPPLE) {
                /*
                ** Check the window coordinate against the stipple and
                ** and see if the pixel can be written
                */
                GLint row = y & 31;
                GLint col = x & 31;
                if ((gc->polygon.stipple[row] & (1<<col)) == 0) {
                    /*
                    ** Stipple bit is clear.  Do not render this pixel
                    ** of the triangle.
                    */
                    continue;
                }
            }
        
            xs = x + __glHalf;      /* sample point is at pixel center */
            ys = y + __glHalf;
            coverage = Coverage(&tm, &xs, &ys, &cs);
            if (coverage != zero) {
                __GLfragment frag;

                /*
                ** Fill in fragment for rendering.  First compute the color
                ** of the fragment.
                */
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    frag.color.r = FindP(&rp, xs, ys);
                    if (rgbMode) {
                        frag.color.g = FindP(&gp, xs, ys);
                        frag.color.b = FindP(&bp, xs, ys);
                        frag.color.a = FindP(&ap, xs, ys);
                    }
                } else {
                    frag.color.r = flatColor->r;
                    if (rgbMode) {
                        frag.color.g = flatColor->g;
                        frag.color.b = flatColor->b;
                        frag.color.a = flatColor->a;
                    }
                }
            
                /*
                ** Texture the fragment.
                */
                if (modeFlags & __GL_SHADE_TEXTURE) {
                    __GLfloat qw, s, t, rho;
                
                    qw = FindP(&qwp, xs, ys);
                    s = FindP(&sp, xs, ys);
                    t = FindP(&tp, xs, ys);
                    rho = (*gc->procs.calcPolygonRho)(gc, sh, s, t, qw);
#ifdef NT
                    if( qw == (__GLfloat) 0.0 )
                        s = t = (__GLfloat) 0;
                    else {
                        s /= qw;
                        t /= qw;
                    }
#else
                    s /= qw;
                    t /= qw;
#endif
                    (*gc->procs.texture)(gc, &frag.color, s, t, rho);
                }
            
                /*
                ** Fog the resulting color.
                */
                if (modeFlags & __GL_SHADE_COMPUTE_FOG)
                {
                    __GLfloat eyeZ = FindP(&ezp, xs, ys);
                    __glFogFragmentSlow(gc, &frag, eyeZ);
                }
                else if (modeFlags & __GL_SHADE_INTERP_FOG)
                {
                    __GLfloat fog = FindP(&fp, xs, ys);
                    __glFogColorSlow(gc, &(frag.color), &(frag.color), fog);  
                }

                /*
                ** Apply anti-aliasing effect
                */
                if (rgbMode) {
                    frag.color.a *= coverage;
                } else {
                    frag.color.r =
                      __glBuildAntiAliasIndex(frag.color.r,
                                              coverage);
                }
                
                /*
                ** Finally, render the fragment.
                */
                frag.x = (GLint)xs;
                frag.y = (GLint)ys;
                if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                    frag.z = (__GLzValue)FindP(&zp, xs, ys);
                }
                (*gc->procs.store)(cfb, &frag);
            }
        }
    }
}


#ifdef GL_WIN_phong_shading

void FASTCALL __glFillAntiAliasedPhongTriangle(__GLcontext *gc, __GLvertex *a,
                                               __GLvertex *b, __GLvertex *c,
                                               GLboolean ccw)
{
#if 1
    __glTriangleMachine tm;
    __glCoverageStuff cs;
    __GLcolor *ca, *cb, *cc, *flatColor;
    GLint x, y, left, right, bottom, top, samples;
    __glPlaneEquation qwp, zp, rp, gp, bp, ap, ezp, sp, tp;
    __glPlaneEquation exp, eyp, ewp, nxp, nyp, nzp;
    __glPlaneEquation fp;
    GLboolean rgbMode;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    __GLfloat zero = __glZero;
    __GLfloat area, ax, bx, cx, ay, by, cy;
    __GLshade *sh = &gc->polygon.shader;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLcoord *na, *nb, *nc, ea, eb, ec;
    GLuint msm_colorMaterialChange, flags=0;
    GLboolean needColor, needEye;
    __GLphongShader *phong = &gc->polygon.shader.phong;
    
    if (gc->polygon.shader.phong.face == __GL_FRONTFACE)
        msm_colorMaterialChange = gc->light.back.colorMaterialChange;
    else
        msm_colorMaterialChange = gc->light.back.colorMaterialChange;

    if ((gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) &&
        msm_colorMaterialChange && (modeFlags & __GL_SHADE_RGB))
        flags |= __GL_PHONG_NEED_COLOR_XPOLATE;

    //Compute Invariant color if possible
    if (((!(flags & __GL_PHONG_NEED_COLOR_XPOLATE) || 
        !(msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT | 
                                     __GL_MATERIAL_EMISSIVE))) &&
        (modeFlags & __GL_SHADE_RGB)) &&
        !(flags & __GL_PHONG_NEED_EYE_XPOLATE))
    {
        ComputePhongInvarientRGBColor (gc);
        flags |= __GL_PHONG_INV_COLOR_VALID;
    }
    
    //Store the flags
    gc->polygon.shader.phong.flags |= flags;

    needColor = (gc->polygon.shader.phong.flags &
                           __GL_PHONG_NEED_COLOR_XPOLATE);
    needEye = (gc->polygon.shader.phong.flags &
                           __GL_PHONG_NEED_EYE_XPOLATE);

#ifdef __GL_LINT
    ccw = ccw;
#endif
    /*
    ** Recompute the area of the triangle after constraining the incoming
    ** coordinates to the subpixel precision.  The viewport bias gives
    ** more precision (typically) than the subpixel precision.  Because of
    ** this the algorithim below can fail to reject an essentially empty
    ** triangle and instead fill a large area.  The scan converter fill
    ** routines (eg polydraw.c) don't have this trouble because of the
    ** very nature of edge walking.
    **
    ** NOTE: Notice that here as in other places, when the area calculation
    ** is done we are careful to do it as a series of subtractions followed by
    ** multiplications.  This is done to guarantee that no overflow will
    ** occur (remember that the coordinates are biased by a potentially large
    ** number, and that multiplying two biased numbers will square the bias).
    */
    ax = __GL_FIX_PRECISION(a->window.x);
    bx = __GL_FIX_PRECISION(b->window.x);
    cx = __GL_FIX_PRECISION(c->window.x);
    ay = __GL_FIX_PRECISION(a->window.y);
    by = __GL_FIX_PRECISION(b->window.y);
    cy = __GL_FIX_PRECISION(c->window.y);
    area = (ax - cx) * (by - cy) - (bx - cx) * (ay - cy);
    if (area == zero) {
        return;
    }

    na = &a->normal;
    nb = &b->normal;
    nc = &c->normal;

    if (needColor)
    {
      ca = a->color;
      cb = b->color;
      cc = c->color;
      flatColor = gc->vertex.provoking->color;
    }

    if (needEye)
    {
        ea.x = a->eyeX; ea.y = a->eyeY; ea.z = a->eyeZ; ea.w = a->eyeW; 
        eb.x = b->eyeX; eb.y = b->eyeY; eb.z = b->eyeZ; eb.w = b->eyeW; 
        ec.x = c->eyeX; ec.y = c->eyeY; ec.z = c->eyeZ; ec.w = c->eyeW; 
    }
    

    /*
    ** Construct plane equations for all of the parameters that are
    ** computed for the triangle: z, r, g, b, a, s, t, f
    */
    if (modeFlags & __GL_SHADE_DEPTH_ITER) 
    {
        FindPlaneEquation(&zp, a, b, c, a->window.z, b->window.z, 
                          c->window.z);
    }

#ifdef GL_WIN_specular_fog
    if (modeFlags & __GL_SHADE_COMPUTE_FOG)
    {
        FindPlaneEquation(&ezp, a, b, c, a->eyeZ, b->eyeZ, c->eyeZ);
    } 
    else if (modeFlags & __GL_SHADE_INTERP_FOG) 
    {
        __GLfloat aFog = 1.0f, bFog = 1.0f, cFog = 1.0f;

        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            aFog = ComputeSpecValue (gc, a);
            bFog = ComputeSpecValue (gc, b);
            cFog = ComputeSpecValue (gc, c);
        }

        if (gc->polygon.shader.modeFlags & __GL_SHADE_SLOW_FOG)
        {
            aFog *= a->fog;
            bFog *= b->fog;
            cFog *= c->fog;
        }

        FindPlaneEquation(&fp, a, b, c, aFog, bFog, cFog);
    }
#else //GL_WIN_specular_fog
    if (modeFlags & __GL_SHADE_SLOW_FOG) 
    {
        FindPlaneEquation(&ezp, a, b, c, a->eyeZ, b->eyeZ, c->eyeZ);
    }
    else if (modeFlags & __GL_SHADE_INTERP_FOG) 
    {
        FindPlaneEquation(&fp, a, b, c, a->fog, b->fog, c->fog);
    }
#endif //GL_WIN_specular_fog

    if (modeFlags & __GL_SHADE_TEXTURE) 
    {
        __GLfloat one = __glOne;
        __GLfloat aWInv = a->window.w;
        __GLfloat bWInv = b->window.w;
        __GLfloat cWInv = c->window.w;
        FindPlaneEquation(&qwp, a, b, c, a->texture.w * aWInv,
                          b->texture.w * bWInv, c->texture.w * cWInv);
        FindPlaneEquation(&sp, a, b, c, a->texture.x * aWInv,
                          b->texture.x * bWInv, c->texture.x * cWInv);
        FindPlaneEquation(&tp, a, b, c, a->texture.y * aWInv,
                          b->texture.y * bWInv, c->texture.y * cWInv);
    }

    rgbMode = gc->modes.rgbMode;

    if (needColor)
    {
        if (modeFlags & __GL_SHADE_SMOOTH) {
            FindPlaneEquation(&rp, a, b, c, ca->r, cb->r, cc->r);
            if (rgbMode) {
               FindPlaneEquation(&gp, a, b, c, ca->g, cb->g, cc->g);
               FindPlaneEquation(&bp, a, b, c, ca->b, cb->b, cc->b);
               FindPlaneEquation(&ap, a, b, c, ca->a, cb->a, cc->a);
            }
        }
    }
    
    if (needEye)
    {
        FindPlaneEquation(&exp, a, b, c, ea.x, eb.x, ec.x);
        FindPlaneEquation(&eyp, a, b, c, ea.y, eb.y, ec.y);
        // FindPlaneEquation(&ezp, a, b, c, ea.z, eb.z, ec.z);
        FindPlaneEquation(&ewp, a, b, c, ea.w, eb.w, ec.w);
    }

    FindPlaneEquation(&nxp, a, b, c, na->x, nb->x, nc->x);
    FindPlaneEquation(&nyp, a, b, c, na->y, nb->y, nc->y);
    FindPlaneEquation(&nzp, a, b, c, na->z, nb->z, nc->z);

    /*
    ** Compute general form of the line equations for each of the
    ** edges of the triangle.
    */
    FindLineEqation(&tm.ab, a, b, c);
    FindLineEqation(&tm.bc, b, c, a);
    FindLineEqation(&tm.ca, c, a, b);

    /* Compute bounding box of the triangle */
    left = (GLint)a->window.x;
    if (b->window.x < left) left = (GLint)b->window.x;
    if (c->window.x < left) left = (GLint)c->window.x;
    right = (GLint)a->window.x;
    if (b->window.x > right) right = (GLint)b->window.x;
    if (c->window.x > right) right = (GLint)c->window.x;
    bottom = (GLint)a->window.y;
    if (b->window.y < bottom) bottom = (GLint)b->window.y;
    if (c->window.y < bottom) bottom = (GLint)c->window.y;
    top = (GLint)a->window.y;
    if (b->window.y > top) top = (GLint)b->window.y;
    if (c->window.y > top) top = (GLint)c->window.y;

    /* Bloat the bounding box when anti aliasing */
    left -= (GLint)FILTER_WIDTH;
    right += (GLint)FILTER_WIDTH;
    bottom -= (GLint)FILTER_HEIGHT;
    top += (GLint)FILTER_HEIGHT;

    /* Init coverage computations */
    samples = (gc->state.hints.polygonSmooth == GL_NICEST) ? 8 : 4;
    ComputeCoverageStuff(&cs, samples);

    /* Scan over the bounding box of the triangle */
    for (y = bottom; y <= top; y++) 
    {
        cs.lastCoverageWasOne = GL_FALSE;
        for (x = left; x <= right; x++) 
        {
            __GLfloat coverage;
            __GLfloat xs, ys;

            if (modeFlags & __GL_SHADE_STIPPLE) 
            {
                /*
                ** Check the window coordinate against the stipple and
                ** and see if the pixel can be written
                */
                GLint row = y & 31;
                GLint col = x & 31;
                if ((gc->polygon.stipple[row] & (1<<col)) == 0) 
                {
                    /*
                    ** Stipple bit is clear.  Do not render this pixel
                    ** of the triangle.
                    */
                    continue;
                }
            }

            xs = x + __glHalf;      /* sample point is at pixel center */
            ys = y + __glHalf;
            coverage = Coverage(&tm, &xs, &ys, &cs);
            if (coverage != zero) 
            {
                __GLfragment frag;
                /*
                ** Fill in fragment for rendering.  First compute the color
                ** of the fragment.
                */
                phong->nTmp.x = FindP(&nxp, xs, ys);
                phong->nTmp.y = FindP(&nyp, xs, ys);
                phong->nTmp.z = FindP(&nzp, xs, ys);

                if (needColor) 
                {
                    phong->tmpColor.r = FindP(&rp, xs, ys);
                    if (modeFlags & __GL_SHADE_RGB) 
                    {
                        phong->tmpColor.g = FindP(&gp, xs, ys);
                        phong->tmpColor.b = FindP(&bp, xs, ys);
                        phong->tmpColor.a = FindP(&ap, xs, ys);
                    }
                }
                
                if (needEye) 
                {
                    phong->eTmp.x = FindP(&exp, xs, ys);
                    phong->eTmp.y = FindP(&eyp, xs, ys);
                    phong->eTmp.z = FindP(&ezp, xs, ys);
                    phong->eTmp.w = FindP(&ewp, xs, ys);
                }
                
                
                if (modeFlags & __GL_SHADE_RGB)
                    (*gc->procs.phong.ComputeRGBColor) (gc, &(frag.color));
                else
                    (*gc->procs.phong.ComputeCIColor) (gc, &(frag.color));

                /*
                ** Texture the fragment.
                */
                if (modeFlags & __GL_SHADE_TEXTURE) {
                    __GLfloat qw, s, t, rho;

                    qw = FindP(&qwp, xs, ys);
                    s = FindP(&sp, xs, ys);
                    t = FindP(&tp, xs, ys);
                    rho = (*gc->procs.calcPolygonRho)(gc, sh, s, t, qw);
                    if( qw == (__GLfloat) 0.0 )
                        s = t = (__GLfloat) 0;
                    else {
                        s /= qw;
                        t /= qw;
                    }
                    (*gc->procs.texture)(gc, &frag.color, s, t, rho);
                }

                /*
                ** Fog the resulting color.
                */
                if (modeFlags & __GL_SHADE_COMPUTE_FOG)
                {
                    __GLfloat eyeZ = FindP(&ezp, xs, ys);
                    __glFogFragmentSlow(gc, &frag, eyeZ);
                } 
                else if (modeFlags & __GL_SHADE_INTERP_FOG) 
                {
                    __GLfloat fog = FindP(&fp, xs, ys);
                    __glFogColorSlow(gc, &(frag.color), &(frag.color), fog);  
                }

                /*
                ** Apply anti-aliasing effect
                */
                if (rgbMode) {
                    frag.color.a *= coverage;
                } else {
                    frag.color.r =
                      __glBuildAntiAliasIndex(frag.color.r,
                                          coverage);
                }

                /*
                ** Finally, render the fragment.
                */
                frag.x = (GLint)xs;
                frag.y = (GLint)ys;
                if (modeFlags & __GL_SHADE_DEPTH_ITER) {
                    frag.z = (__GLzValue)FindP(&zp, xs, ys);
                }
                (*gc->procs.store)(cfb, &frag);
            }
        }
    }
#endif
}
#endif //GL_WIN_phong_shading
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_polym.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop
#include <fixed.h>

#if _X86_

#define SHADER	__GLcontext.polygon.shader

#define GET_HALF_AREA(gc, a, b, c)\
\
__asm{ mov     eax, a                                                                           };\
__asm{ mov     ecx, c                                                                           };\
__asm{ mov     ebx, b                                                                           };\
__asm{ mov     edx, gc                                                                          };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.x)][eax]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.x)][ecx]      /* dxAC                     */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.y)][ebx]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.y)][ecx]      /* dyBC dxAC                */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.x)][ebx]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.x)][ecx]      /* dxBC dyBC dxAC           */ };\
__asm{ fld     DWORD PTR [OFFSET(__GLvertex.window.y)][eax]                                     };\
__asm{ fsub    DWORD PTR [OFFSET(__GLvertex.window.y)][ecx]      /* dyAC dxBC dyBC dxAC      */ };\
__asm{ fxch    ST(2)                                             /* dyBC dxBC dyAC dxAC      */ };\
__asm{ fst     DWORD PTR [OFFSET(SHADER.dyBC)][edx]                                             };\
__asm{ fmul    ST, ST(3)                                         /* dxACdyBC dxBC dyAC dxAC  */ };\
__asm{ fxch    ST(2)                                             /* dyAC dxBC dxACdyBC dxAC  */ };\
__asm{ fst     DWORD PTR [OFFSET(SHADER.dyAC)][edx]                                             };\
__asm{ fmul    ST, ST(1)                                         /* dxBCdyAC dxBC dxACdyBC dxAC */};\
__asm{ fxch    ST(1)                                             /* dxBC dxBCdyAC dxACdyBC dxAC */};\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.dxBC)][edx]              /* dxBCdyAC dxACdyBC dxAC   */ };\
__asm{ fsubp   ST(1), ST                                /* +1*/  /* area dxAC                */ };\
__asm{ fxch    ST(1)                                             /* dxAC area                */ };\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.dxAC)][edx]              /* area                     */ };\
__asm{ fstp    DWORD PTR [OFFSET(SHADER.area)][edx]     /* +1*/  /* (empty)                  */ };

#define STORE_AREA_PARAMS   

#else

#define GET_HALF_AREA(gc, a, b, c)\
    /* Compute signed half-area of the triangle */                  \
    dxAC = a->window.x - c->window.x;                               \
    dxBC = b->window.x - c->window.x;                               \
    dyAC = a->window.y - c->window.y;                               \
    dyBC = b->window.y - c->window.y;                               \
    gc->polygon.shader.area = dxAC * dyBC - dxBC * dyAC;

#define STORE_AREA_PARAMS\
    gc->polygon.shader.dxAC = dxAC;                                 \
    gc->polygon.shader.dxBC = dxBC;                                 \
    gc->polygon.shader.dyAC = dyAC;                                 \
    gc->polygon.shader.dyBC = dyBC;    

#endif


#define SORT_AND_CULL_FACE(a, b, c, face, ccw)\
                                                                            \
    /*                                                                      \
    ** Sort vertices in y.  Keep track if a reversal of the winding         \
    ** occurs in direction (0 means no reversal, 1 means reversal).         \
    ** Save old vertex pointers in case we end up not doing a fill.         \
    */                                                                      \
    reversed = 0;                                                           \
    if (__GL_VERTEX_COMPARE(a->window.y, <, b->window.y)) {                 \
        if (__GL_VERTEX_COMPARE(b->window.y, <, c->window.y)) {             \
            /* Already sorted */                                            \
        } else {                                                            \
            if (__GL_VERTEX_COMPARE(a->window.y, <, c->window.y)) {         \
                temp=b; b=c; c=temp;                                        \
                reversed = 1;                                               \
            } else {                                                        \
                temp=a; a=c; c=b; b=temp;                                   \
            }                                                               \
        }                                                                   \
    } else {                                                                \
        if (__GL_VERTEX_COMPARE(b->window.y, <, c->window.y)) {             \
            if (__GL_VERTEX_COMPARE(a->window.y, <, c->window.y)) {         \
                temp=a; a=b; b=temp;                                        \
                reversed = 1;                                               \
            } else {                                                        \
                temp=a; a=b; b=c; c=temp;                                   \
            }                                                               \
        } else {                                                            \
            temp=a; a=c; c=temp;                                            \
            reversed = 1;                                                   \
        }                                                                   \
    }                                                                       \
                                                                            \
    GET_HALF_AREA(gc, a, b, c);                                             \
    ccw = !__GL_FLOAT_LTZ(gc->polygon.shader.area);                         \
                                                                            \
    /*                                                                      \
    ** Figure out if face is culled or not.  The face check needs to be     \
    ** based on the vertex winding before sorting.  This code uses the      \
    ** reversed flag to invert the sense of ccw - an xor accomplishes       \
    ** this conversion without an if test.                                  \
    **                                                                      \
    **      ccw reversed        xor                                         \
    **      --- --------        ---                                         \
    **      0   0           0 (remain !ccw)                                 \
    **      1   0           1 (remain ccw)                                  \
    **      0   1           1 (become ccw)                                  \
    **      1   1           0 (become cw)                                   \
    */                                                                      \
    face = gc->polygon.face[ccw ^ reversed];                                \
    if (face == gc->polygon.cullFace) {                                     \
    /* Culled */                                                            \
    return;                                                                 \
    }                                                                       \
                                                                            \
    STORE_AREA_PARAMS;                                                      


// #define NO_RENDERING


void __glTriangleOffsetZ( __GLcontext *gc, __GLvertex *a, __GLvertex *b,
			  __GLvertex *c)
{
    __GLfloat dzAC, dzBC;
    __GLfloat oneOverArea, t1, t2, t3, t4;
    __GLfloat zOffset;

    // Calc dzdxf, dzdyf values as in __glFillTriangle

    /* Pre-compute one over polygon area */

    if( gc->polygon.shader.area == 0.0f )
        oneOverArea = (__GLfloat)(__glOne / __GL_PGON_OFFSET_NEAR_ZERO);
    else
        oneOverArea = __glOne / gc->polygon.shader.area;

    /*
    ** Compute delta values for unit changes in x or y for each
    ** parameter.
    */
    t1 = gc->polygon.shader.dyAC * oneOverArea;
    t2 = gc->polygon.shader.dyBC * oneOverArea;
    t3 = gc->polygon.shader.dxAC * oneOverArea;
    t4 = gc->polygon.shader.dxBC * oneOverArea;

    dzAC = a->window.z - c->window.z;
    dzBC = b->window.z - c->window.z;
    gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
    gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;

    zOffset = __glPolygonOffsetZ(gc);
    a->window.z += zOffset;
    b->window.z += zOffset;
    c->window.z += zOffset;
}

// Polygon offset z-munge: we modify the window.z of the vertices with the
// offset z, then restore the z after rendering, due to the possibility of the
// vertices being sent down multiple times by a higher-order primitive.

#define SAVE_WINDOW_Z \
    awinz = a->window.z; bwinz = b->window.z; cwinz = c->window.z;

#define RESTORE_WINDOW_Z \
    a->window.z = awinz; \
    b->window.z = bwinz; \
    c->window.z = cwinz;

#ifdef GL_EXT_flat_paletted_lighting
void __glPickLightingPalette(__GLcontext *gc)
{
    __GLtexture *tex;
    GLint loffset;

    tex = gc->texture.currentTexture;
    loffset = (GLint)(gc->vertex.provoking->color->r *
                      gc->oneOverRedVertexScale *
                      tex->paletteDivision) << tex->paletteDivShift;
    tex->paletteData = tex->paletteTotalData+loffset;
    __glGenSetPaletteOffset(gc, tex, loffset);
}
#endif GL_EXT_flat_paletted_lighting

/*
** Generic triangle handling code.  This code is used when render mode
** is GL_RENDER and the polygon modes are not both fill.
*/
void FASTCALL __glRenderTriangle(__GLcontext *gc, __GLvertex *a, 
                                 __GLvertex *b, __GLvertex *c)
{
    GLuint needs, modeFlags, faceNeeds;
    GLint ccw, colorFace, reversed, face;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLvertex *oa, *ob, *oc;
    __GLvertex *temp;
    __GLfloat awinz, bwinz, cwinz;

#ifdef NO_RENDERING
    return;
#endif
    
    oa = a; ob = b; oc = c;

    SORT_AND_CULL_FACE(a, b, c, face, ccw);

    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
#ifdef NT
    if (modeFlags & __GL_SHADE_SMOOTH_LIGHT)
    {   /* Smooth shading */
        if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
        {
            a->color++;
            b->color++;
            c->color++;
        }
    }
#ifdef GL_WIN_phong_shading
    else if (modeFlags & __GL_SHADE_PHONG)
    {   /* Phong shading */
        if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
            gc->polygon.shader.phong.face = __GL_BACKFACE; 
        else
            gc->polygon.shader.phong.face = __GL_FRONTFACE;
    }
#endif //GL_WIN_phong_shading
    else
    {   /* Flat shading */
        __GLvertex *pv = gc->vertex.provoking;
        if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
            pv->color++;
        a->color = pv->color;
        b->color = pv->color;
        c->color = pv->color;
    }
#else
    if (modeFlags & __GL_SHADE_TWOSIDED) {
	colorFace = face;
	faceNeeds = gc->vertex.faceNeeds[face];
    } else {
	colorFace = __GL_FRONTFACE;
	faceNeeds = gc->vertex.faceNeeds[__GL_FRONTFACE];
    }

    /*
    ** Choose colors for the vertices.
    */
    needs = gc->vertex.needs;
    pv = gc->vertex.provoking;
    if (modeFlags & __GL_SHADE_SMOOTH_LIGHT) {
	/* Smooth shading */
	a->color = &a->colors[colorFace];
	b->color = &b->colors[colorFace];
	c->color = &c->colors[colorFace];
	needs |= faceNeeds;
    } else {
	GLuint pvneeds;

	/*
	** Validate the lighting (and color) information in the provoking
	** vertex only.  Fill routines always use gc->vertex.provoking->color
	** to find the color.
	*/
	pv->color = &pv->colors[colorFace];
	a->color = pv->color;
	b->color = pv->color;
	c->color = pv->color;
	pvneeds = faceNeeds & (__GL_HAS_LIGHTING | 
		__GL_HAS_FRONT_COLOR | __GL_HAS_BACK_COLOR);
	if (~pv->has & pvneeds) {
	    (*pv->validate)(gc, pv, pvneeds);
	}
    }

    /* Validate vertices */
    if (~a->has & needs) (*a->validate)(gc, a, needs);
    if (~b->has & needs) (*b->validate)(gc, b, needs);
    if (~c->has & needs) (*c->validate)(gc, c, needs);
#endif

    /* Render triangle using the faces polygon mode */
    switch (gc->polygon.mode[face]) {
      case __GL_POLYGON_MODE_FILL:
	if (__GL_FLOAT_NEZ(gc->polygon.shader.area)) {
#ifdef GL_EXT_flat_paletted_lighting
            if ((gc->state.enables.general & __GL_PALETTED_LIGHTING_ENABLE) &&
                (modeFlags & __GL_SHADE_SMOOTH_LIGHT) == 0 &&
                gc->texture.currentTexture != NULL)
            {
                __glPickLightingPalette(gc);
            }
#endif
	    (*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);
	}
	break;
      case __GL_POLYGON_MODE_POINT:
        if( gc->state.enables.general & __GL_POLYGON_OFFSET_POINT_ENABLE ) {
            SAVE_WINDOW_Z;
            __glTriangleOffsetZ( gc, a, b, c );
        }
#ifdef NT
        if (oa->has & __GL_HAS_EDGEFLAG_BOUNDARY)
            (*gc->procs.renderPoint)(gc, oa);
        if (ob->has & __GL_HAS_EDGEFLAG_BOUNDARY)
            (*gc->procs.renderPoint)(gc, ob);
        if (oc->has & __GL_HAS_EDGEFLAG_BOUNDARY)
          (*gc->procs.renderPoint)(gc, oc);

        if( gc->state.enables.general & __GL_POLYGON_OFFSET_POINT_ENABLE ) {
            RESTORE_WINDOW_Z;
        }
        break;
#else
	if (oa->boundaryEdge) (*gc->procs.renderPoint)(gc, oa);
	if (ob->boundaryEdge) (*gc->procs.renderPoint)(gc, ob);
	if (oc->boundaryEdge) (*gc->procs.renderPoint)(gc, oc);
	break;
#endif
      case __GL_POLYGON_MODE_LINE:
        if( gc->state.enables.general & __GL_POLYGON_OFFSET_LINE_ENABLE ) {
            SAVE_WINDOW_Z;
            __glTriangleOffsetZ( gc, a, b, c );
        }
#ifdef NT
        (*gc->procs.lineBegin)(gc);
        if ((oa->has & __GL_HAS_EDGEFLAG_BOUNDARY) &&
            (ob->has & __GL_HAS_EDGEFLAG_BOUNDARY) &&
            (oc->has & __GL_HAS_EDGEFLAG_BOUNDARY))
        {
            // Is this an important case to optimize?
            (*gc->procs.renderLine)(gc, oa, ob, __GL_LVERT_FIRST);
            (*gc->procs.renderLine)(gc, ob, oc, 0);
            (*gc->procs.renderLine)(gc, oc, oa, 0);
        }
        else
        {
            if (oa->has & __GL_HAS_EDGEFLAG_BOUNDARY)
            {
                (*gc->procs.renderLine)(gc, oa, ob, __GL_LVERT_FIRST);
            }
            if (ob->has & __GL_HAS_EDGEFLAG_BOUNDARY)
            {
                (*gc->procs.renderLine)(gc, ob, oc, __GL_LVERT_FIRST);
            }
            if (oc->has & __GL_HAS_EDGEFLAG_BOUNDARY)
            {
                (*gc->procs.renderLine)(gc, oc, oa, __GL_LVERT_FIRST);
            }
        }
        (*gc->procs.lineEnd)(gc);
        if( gc->state.enables.general & __GL_POLYGON_OFFSET_LINE_ENABLE ) {
            RESTORE_WINDOW_Z;
        }
        break;
#else
	if (oa->boundaryEdge) {
	    (*gc->procs.renderLine)(gc, oa, ob);
	}
	if (ob->boundaryEdge) {
	    (*gc->procs.renderLine)(gc, ob, oc);
	}
	if (oc->boundaryEdge) {
	    (*gc->procs.renderLine)(gc, oc, oa);
	}
	break;
#endif
    }

    /* Restore color pointers */
    a->color = &a->colors[__GL_FRONTFACE];
    b->color = &b->colors[__GL_FRONTFACE];
    c->color = &c->colors[__GL_FRONTFACE];

#ifdef NT
    if (!(modeFlags & __GL_SHADE_SMOOTH_LIGHT)
#ifdef GL_WIN_phong_shading
        && !(modeFlags & __GL_SHADE_PHONG)
#endif //GL_WIN_phong_shading
        )
    {
        __GLvertex *pv = gc->vertex.provoking;
        pv->color = &pv->colors[__GL_FRONTFACE];
    }
#else
    pv->color = &pv->colors[__GL_FRONTFACE];
#endif
}



/************************************************************************/

/*
** Generic triangle handling code.  This code is used when render mode
** is GL_RENDER and both polygon modes are FILL and the triangle is
** being flat shaded.
*/
void FASTCALL __glRenderFlatTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			    __GLvertex *c)
{
    GLuint needs, pvneeds, modeFlags, faceNeeds;
    GLint ccw, colorFace, reversed, face;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLvertex *temp;

#ifdef NO_RENDERING
    return;
#endif
    
    SORT_AND_CULL_FACE(a, b, c, face, ccw);
    if (__GL_FLOAT_EQZ(gc->polygon.shader.area))
	return;

    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
#ifdef GL_EXT_flat_paletted_lighting
    ASSERTOPENGL((modeFlags & __GL_SHADE_SMOOTH_LIGHT) == 0,
                 "Flat triangle with smooth shading\n");
    if ((gc->state.enables.general & __GL_PALETTED_LIGHTING_ENABLE) &&
        gc->texture.currentTexture != NULL)
    {
        __glPickLightingPalette(gc);
    }
#endif
#ifdef NT
//!!! don't we need to update a,b,c color pointers if cheap fog is enabled?
    if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
    {
	__GLvertex *pv = gc->vertex.provoking;

	/* Fill triangle */
	pv->color++;
	(*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);
	pv->color--;
    }
    else
    {
	/* Fill triangle */
	(*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);
    }
#else
    if (modeFlags & __GL_SHADE_TWOSIDED) {
	colorFace = face;
	faceNeeds = gc->vertex.faceNeeds[face];
    } else {
	colorFace = __GL_FRONTFACE;
	faceNeeds = gc->vertex.faceNeeds[__GL_FRONTFACE];
    }

    /*
    ** Choose colors for the vertices.
    */
    needs = gc->vertex.needs;
    pv = gc->vertex.provoking;

    /*
    ** Validate the lighting (and color) information in the provoking
    ** vertex only.  Fill routines always use gc->vertex.provoking->color
    ** to find the color.
    */
    pv->color = &pv->colors[colorFace];
    pvneeds = faceNeeds & (__GL_HAS_LIGHTING |
	    __GL_HAS_FRONT_COLOR | __GL_HAS_BACK_COLOR);
    if (~pv->has & pvneeds) {
	(*pv->validate)(gc, pv, pvneeds);
    }

    /* Validate vertices */
    if (~a->has & needs) (*a->validate)(gc, a, needs);
    if (~b->has & needs) (*b->validate)(gc, b, needs);
    if (~c->has & needs) (*c->validate)(gc, c, needs);

    /* Fill triangle */
    (*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);

    /* Restore color pointers */
    pv->color = &pv->colors[__GL_FRONTFACE];
#endif
}

/************************************************************************/

/*
** Generic triangle handling code.  This code is used when render mode
** is GL_RENDER and both polygon modes are FILL and the triangle is
** being smooth shaded.
*/
void FASTCALL __glRenderSmoothTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			      __GLvertex *c)
 {
    GLuint needs, modeFlags;
    GLint ccw, colorFace, reversed, face;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLvertex *temp;

#ifdef NO_RENDERING
    return;
#endif
    
    SORT_AND_CULL_FACE(a, b, c, face, ccw);
    if (__GL_FLOAT_EQZ(gc->polygon.shader.area))
	return;

    /*
    ** Pick face to use for coloring
    */
    modeFlags = gc->polygon.shader.modeFlags;
#ifdef GL_EXT_flat_paletted_lighting
    // No lighting because smooth shading is always on in this routine
#endif
#ifdef NT
    if (modeFlags & __GL_SHADE_TWOSIDED && face == __GL_BACKFACE)
    {
	/* Fill triangle */
	a->color++;
	b->color++;
	c->color++;
	(*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);
	a->color--;
	b->color--;
	c->color--;
    }
    else
    {
	/* Fill triangle */
	(*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);
    }
#else
    needs = gc->vertex.needs;
    if (modeFlags & __GL_SHADE_TWOSIDED) {
	colorFace = face;
	needs |= gc->vertex.faceNeeds[face];
    } else {
	colorFace = __GL_FRONTFACE;
	needs |= gc->vertex.faceNeeds[__GL_FRONTFACE];
    }

    /*
    ** Choose colors for the vertices.
    */
    a->color = &a->colors[colorFace];
    b->color = &b->colors[colorFace];
    c->color = &c->colors[colorFace];

    /* Validate vertices */
    if (~a->has & needs) (*a->validate)(gc, a, needs);
    if (~b->has & needs) (*b->validate)(gc, b, needs);
    if (~c->has & needs) (*c->validate)(gc, c, needs);

    /* Fill triangle */
    (*gc->procs.fillTriangle)(gc, a, b, c, (GLboolean) ccw);

    /* Restore color pointers */
    a->color = &a->colors[__GL_FRONTFACE];
    b->color = &b->colors[__GL_FRONTFACE];
    c->color = &c->colors[__GL_FRONTFACE];
#endif
}


void FASTCALL __glDontRenderTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			    __GLvertex *c)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_slows.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

GLboolean __glReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
		       __GLcolor *results, GLint w)
{
    while (--w >= 0) {
	(*cfb->readColor)(cfb, x, y, results);
	x++;
	results++;
    }

    return GL_FALSE;
}

/*
** NOTE: this is a hack.  Late in the game we determined that returning
** a span of data should not also blend.  So this code stacks the old
** blend enable value, disables blending, updates the pick procs, and
** then does the store.  Obviously this is a real slow thing to
** do.
*/
void __glReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
		    const __GLaccumCell *ac, __GLfloat scale, GLint w)
{
    __GLfragment frag;
    GLuint oldEnables;
    __GLcontext *gc = cfb->buf.gc;
    __GLfloat rscale, gscale, bscale, ascale;
    __GLaccumBuffer *afb = &gc->accumBuffer;

    /* Temporarily disable blending if its enabled */
    oldEnables = gc->state.enables.general;
    if (oldEnables & __GL_BLEND_ENABLE) {
	gc->state.enables.general &= ~__GL_BLEND_ENABLE;
	__GL_DELAY_VALIDATE(gc);
	(*gc->procs.validate)(gc);
    }

    rscale = scale * afb->oneOverRedScale;
    gscale = scale * afb->oneOverGreenScale;
    bscale = scale * afb->oneOverBlueScale;
    ascale = scale * afb->oneOverAlphaScale;

    frag.x = x;
    frag.y = y;
    while (--w >= 0) {
	frag.color.r = ac->r * rscale;
	frag.color.g = ac->g * gscale;
	frag.color.b = ac->b * bscale;
	frag.color.a = ac->a * ascale;
	__glClampRGBColor(cfb->buf.gc, &frag.color, &frag.color);
	(*cfb->store)(cfb, &frag);
	frag.x++;
	ac++;
    }

    /* Restore blending enable */
    if (oldEnables & __GL_BLEND_ENABLE) {
	gc->state.enables.general = oldEnables;
	__GL_DELAY_VALIDATE(gc);
	(*gc->procs.validate)(gc);
    }
}

GLboolean FASTCALL __glFetchSpan(__GLcontext *gc)
{
    __GLcolor *fcp;
    __GLcolorBuffer *cfb;
    GLint x, y;
    GLint w;

    w = gc->polygon.shader.length;

    fcp = gc->polygon.shader.fbcolors;
    cfb = gc->polygon.shader.cfb;
    x = gc->polygon.shader.frag.x;
    y = gc->polygon.shader.frag.y;
    (*cfb->readSpan)(cfb, x, y, fcp, w);

    return GL_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_selec.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.12 $
** $Date: 1993/09/23 16:30:58 $
*/
#include "precomp.h"
#pragma hdrstop

void APIPRIVATE __glim_SelectBuffer(GLsizei bufferLength, GLuint buffer[])
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (bufferLength < 0) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }
    if (gc->renderMode == GL_SELECT) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }
    gc->select.overFlowed = GL_FALSE;
    gc->select.resultBase = buffer;
    gc->select.resultLength = bufferLength;
    gc->select.result = buffer;
}

void APIPRIVATE __glim_InitNames(void)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->renderMode == GL_SELECT) {
	gc->select.sp = gc->select.stack;
	gc->select.hit = GL_FALSE;
    }
}

void APIPRIVATE __glim_LoadName(GLuint name)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->renderMode == GL_SELECT) {
	if (gc->select.sp == gc->select.stack) {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
	gc->select.sp[ -1 ] = name;
	gc->select.hit = GL_FALSE;
    }
}

void APIPRIVATE __glim_PopName(void)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->renderMode == GL_SELECT) {
	if (gc->select.sp == gc->select.stack) {
	    __glSetError(GL_STACK_UNDERFLOW);
	    return;
	}
	gc->select.sp = gc->select.sp - 1;
	gc->select.hit = GL_FALSE;
    }
}

void APIPRIVATE __glim_PushName(GLuint name)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if (gc->renderMode == GL_SELECT) {
	// make sure that we have a stack
	ASSERTOPENGL(gc->select.stack != 0 && gc->select.sp != 0,
                     "No selection stack\n");
	if (gc->select.sp >= &gc->select.stack[gc->constants.maxNameStackDepth]) {
	    __glSetError(GL_STACK_OVERFLOW);
	    return;
	}
	gc->select.sp[0] = name;
	gc->select.sp = gc->select.sp + 1;
	gc->select.hit = GL_FALSE;
    }
}

/************************************************************************/

#define __GL_CONVERT_Z_TO_UINT(z)  ((GLuint) z)

/*
** Copy current name stack into the users result buffer.
*/
void __glSelectHit(__GLcontext *gc, __GLfloat z)
{
    GLuint *src;
    GLuint *dest = gc->select.result;
    GLuint *end = gc->select.resultBase + gc->select.resultLength;
    GLuint iz;

    if (gc->select.overFlowed) {
	return;
    }
    
    /* Scale z to [0, 2^32 -1] range.
    ** If buffer is 32 bit, no coversion necessary.  Otherwise we
    ** have to unscale to [0,1] range and rescale to final range.
    ** 4294965000 is the number used throughout lighting code to
    ** come short of 2^32-1 to avoid floating point errors.
    */
    if (gc->depthBuffer.buf.depth == 32) {
        iz = __GL_CONVERT_Z_TO_UINT(z);
    } else {
        iz = z * 4294965000 / gc->depthBuffer.scale;
    }

    if (!gc->select.hit) {
	gc->select.hit = GL_TRUE;

	/* Put number of elements in name stack out first */
	if (dest == end) {
	  overflow:
	    gc->select.overFlowed = GL_TRUE;
	    gc->select.result = end;
	    return;
	}
	*dest++ = (GLint)((ULONG_PTR)(gc->select.sp - gc->select.stack));
	gc->select.hits++;

	/* Put out smallest z */
	if (dest == end) goto overflow;
	gc->select.z = dest;
	*dest++ = iz;

	/* Put out largest z */
	if (dest == end) goto overflow;
	*dest++ = iz;

	/* Copy name stack into output buffer */
	for (src = gc->select.stack; src < gc->select.sp; src++) {
	    if (dest == end) {
		goto overflow;
	    }
	    *dest++ = *src;
	}
	gc->select.result = dest;
    } else {
	/* Update range of Z values */
	ASSERTOPENGL(gc->select.z != 0, "Select Z is zero\n");
	if (iz < gc->select.z[0]) {
	    gc->select.z[0] = iz;
	}
	if (iz > gc->select.z[1]) {
	    gc->select.z[1] = iz;
	}
    }
}

#ifdef NT
void FASTCALL __glSelectTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			__GLvertex *c)
{
    __GLfloat dxAC, dxBC, dyAC, dyBC, area;
    GLint ccw, face;

// From __glRenderTriangle.

    /* Compute signed area of the triangle */
    dxAC = a->window.x - c->window.x;
    dxBC = b->window.x - c->window.x;
    dyAC = a->window.y - c->window.y;
    dyBC = b->window.y - c->window.y;
    area = dxAC * dyBC - dxBC * dyAC;
    ccw = area >= __glZero;

    face = gc->polygon.face[ccw];
    if (face == gc->polygon.cullFace)
	/* Culled */
	return;

    __glSelectHit(gc, a->window.z);
    __glSelectHit(gc, b->window.z);
    __glSelectHit(gc, c->window.z);
}
#else
// SGIBUG - This code fails to take into account y inversion when
// computing face orientation!
void __glSelectTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			__GLvertex *c)
{
    __GLfloat x, y, z, wInv;
    __GLfloat vpXScale, vpYScale, vpZScale;
    __GLfloat vpXCenter, vpYCenter, vpZCenter;
    __GLviewport *vp;

    /* Compute window coordinates first, if not already done */
    vp = &gc->state.viewport;
    vpXCenter = vp->xCenter;
    vpYCenter = vp->yCenter;
    vpZCenter = vp->zCenter;
    vpXScale = vp->xScale;
    vpYScale = vp->yScale;
    vpZScale = vp->zScale;

    if (gc->state.enables.general & __GL_CULL_FACE_ENABLE) {
	__GLfloat dxAC, dxBC, dyAC, dyBC, area;
	GLboolean ccw, frontFacing;

	/* Compute signed area of the triangle */
	dxAC = a->window.x - c->window.x;
	dxBC = b->window.x - c->window.x;
	dyAC = a->window.y - c->window.y;
	dyBC = b->window.y - c->window.y;
	area = dxAC * dyBC - dxBC * dyAC;
	ccw = area >= __glZero;

	if (gc->state.polygon.frontFaceDirection == GL_CCW) {
	    frontFacing = ccw;
	} else {
	    frontFacing = !ccw;
	}
	if ((gc->state.polygon.cull == GL_FRONT_AND_BACK) ||
	    ((gc->state.polygon.cull == GL_FRONT) && frontFacing) ||
	    ((gc->state.polygon.cull == GL_BACK) && !frontFacing)) {
	    /* Culled */
	    return;
	}
    }
    __glSelectHit(gc, a->window.z);
    __glSelectHit(gc, b->window.z);
    __glSelectHit(gc, c->window.z);
}
#endif

void FASTCALL __glSelectLine(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
			     GLuint flags)
{
    __glSelectHit(gc, a->window.z);
    __glSelectHit(gc, b->window.z);
}

void FASTCALL __glSelectPoint(__GLcontext *gc, __GLvertex *v)
{
    __glSelectHit(gc, v->window.z);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_stenc.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

GLint FASTCALL Fetch(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    return fb[0];
}

static void Store(__GLstencilBuffer *sfb, GLint x, GLint y,GLint v)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    fb[0] = (__GLstencilCell) ((v & sfb->buf.gc->state.stencil.writeMask)
		       | (fb[0] & ~sfb->buf.gc->state.stencil.writeMask));
}

static GLboolean FASTCALL TestFunc(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    return sfb->testFuncTable[fb[0] & sfb->buf.gc->state.stencil.mask];
}

static void FASTCALL FailOp(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    fb[0] = sfb->failOpTable[fb[0]];
}

static void FASTCALL PassDepthFailOp(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    fb[0] = sfb->depthFailOpTable[fb[0]];
}

static void FASTCALL DepthPassOp(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    __GLstencilCell *fb;

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);
    fb[0] = sfb->depthPassOpTable[fb[0]];
}

static GLboolean FASTCALL NoOp(__GLstencilBuffer *sfb, GLint x, GLint y)
{
    return GL_FALSE;
}

/************************************************************************/

static void FASTCALL Clear(__GLstencilBuffer *sfb)
{
    __GLcontext *gc = sfb->buf.gc;
    __GLstencilCell *fb;
    GLint x, y, x1, y1, skip, w, w8, w1;
    __GLstencilCell sten = (__GLstencilCell)gc->state.stencil.clear;

    x = gc->transform.clipX0;
    y = gc->transform.clipY0;
    x1 = gc->transform.clipX1;
    y1 = gc->transform.clipY1;
    if (((w = x1 - x) == 0) || (y1 - y == 0)) {
	return;
    }

    fb = __GL_STENCIL_ADDR(sfb, (__GLstencilCell*), x, y);

    skip = sfb->buf.outerWidth - w;
    w8 = w >> 3;
    w1 = w & 7;
    if (gc->state.stencil.writeMask == __GL_MAX_STENCIL_VALUE) {
	for (; y < y1; y++) {
	    w = w8;
	    while (--w >= 0) {
		fb[0] = sten; fb[1] = sten; fb[2] = sten; fb[3] = sten;
		fb[4] = sten; fb[5] = sten; fb[6] = sten; fb[7] = sten;
		fb += 8;
	    }
	    w = w1;
	    while (--w >= 0) {
		*fb++ = sten;
	    }
	    fb += skip;
	}
    } else {
	GLint mask;

	mask = gc->state.stencil.writeMask;
	sten = sten & mask;
	mask = ~mask;

	for (; y < y1; y++) {
	    w = w8;
	    while (--w >= 0) {
		fb[0] = (fb[0] & mask) | (sten); 
		fb[1] = (fb[1] & mask) | (sten); 
		fb[2] = (fb[2] & mask) | (sten); 
		fb[3] = (fb[3] & mask) | (sten); 
		fb[4] = (fb[4] & mask) | (sten); 
		fb[5] = (fb[5] & mask) | (sten); 
		fb[6] = (fb[6] & mask) | (sten); 
		fb[7] = (fb[7] & mask) | (sten); 
		fb += 8;
	    }
	    w = w1;
	    while (--w >= 0) {
		fb[0] = (fb[0] & mask) | (sten);
		fb++;
	    }
	    fb += skip;
	}
    }
}

/************************************************************************/

static void buildOpTable(__GLstencilCell *tp, GLenum op,
			 __GLstencilCell reference, __GLstencilCell writeMask)
{
    GLuint i;
    __GLstencilCell newValue;
    __GLstencilCell notWriteMask = ~writeMask;

    for (i = 0; i < __GL_STENCIL_RANGE; i++) {
	switch (op) {
	  case GL_KEEP:		newValue = (__GLstencilCell)i; break;
	  case GL_ZERO:		newValue = 0; break;
	  case GL_REPLACE:	newValue = reference; break;
	  case GL_INVERT:	newValue = ~i; break;
	  case GL_INCR:
	    /* Clamp so no overflow occurs */
	    if (i == __GL_MAX_STENCIL_VALUE) {
		newValue = (__GLstencilCell)i;
	    } else {
		newValue = i + 1;
	    }
	    break;
	  case GL_DECR:
	    /* Clamp so no underflow occurs */
	    if (i == 0) {
		newValue = 0;
	    } else {
		newValue = i - 1;
	    }
	    break;
	}
	*tp++ = (i & notWriteMask) | (newValue & writeMask);
    }
}

#ifdef NT
void FASTCALL __glValidateStencil(__GLcontext *gc, __GLstencilBuffer *sfb)
#else
void FASTCALL __glValidateStencil(__GLcontext *gc)
#endif // NT
{
    GLint i;
    __GLstencilCell reference, mask, writeMask;
    __GLstencilCell refVal; //actual reference value, part of GL state
    
    GLenum testFunc;
    GLboolean *tp;

    /*
    ** Validate the stencil tables even if stenciling is disabled.  This
    ** function is only called if the stencil func or op changes, and it
    ** won't get called later if stenciling is turned on, so we need to get
    ** it right now.
    */

    mask = (__GLstencilCell) gc->state.stencil.mask;
    refVal = ((__GLstencilCell) gc->state.stencil.reference);
    reference = (__GLstencilCell) (refVal & mask);
    testFunc = gc->state.stencil.testFunc;

    /*
    ** Build up test function table.  The current stencil buffer value
    ** will be the index to this table.
    */
    tp = &gc->stencilBuffer.testFuncTable[0];
    
    // If we don't have a stencil buffer then set everything to
    // do nothing
    if (!gc->modes.haveStencilBuffer)
    {
        sfb->testFunc = NoOp;
        sfb->failOp = NoOp;
        sfb->passDepthFailOp = NoOp;
        sfb->depthPassOp = NoOp;
        return;
    }
    else if (tp != NULL && sfb->testFunc == NoOp)
    {
        // If we've recovered from not having a stencil buffer then
        // turn the functions back on
        sfb->testFunc = TestFunc;
        sfb->failOp = FailOp;
        sfb->passDepthFailOp = PassDepthFailOp;
        sfb->depthPassOp = DepthPassOp;
    }

    if (!tp)
    {
        gc->stencilBuffer.testFuncTable = tp = (GLboolean *)
            GCALLOC(gc, (sizeof(GLboolean)+3*sizeof(__GLstencilCell))*
                    __GL_STENCIL_RANGE);
        if (!tp)
        {
            sfb->testFunc = NoOp;
            sfb->failOp = NoOp;
            sfb->passDepthFailOp = NoOp;
            sfb->depthPassOp = NoOp;
            gc->stencilBuffer.failOpTable =
            gc->stencilBuffer.depthFailOpTable =
            gc->stencilBuffer.depthPassOpTable = (__GLstencilCell*) NULL;
            return;
        }
        else
        {
            sfb->testFunc = TestFunc;
            sfb->failOp = FailOp;
            sfb->passDepthFailOp = PassDepthFailOp;
            sfb->depthPassOp = DepthPassOp;
        }
        gc->stencilBuffer.failOpTable = (__GLstencilCell*)
            (gc->stencilBuffer.testFuncTable + __GL_STENCIL_RANGE);
        gc->stencilBuffer.depthFailOpTable = (__GLstencilCell*)
            (gc->stencilBuffer.failOpTable + __GL_STENCIL_RANGE);
        gc->stencilBuffer.depthPassOpTable = (__GLstencilCell*)
            (gc->stencilBuffer.depthFailOpTable + __GL_STENCIL_RANGE);
    }
    for (i = 0; i < __GL_STENCIL_RANGE; i++) {
	switch (testFunc) {
	  case GL_NEVER:	*tp++ = GL_FALSE; break;
	  case GL_LESS:		*tp++ = reference < (i & mask); break;
	  case GL_EQUAL:	*tp++ = reference == (i & mask); break;
	  case GL_LEQUAL:	*tp++ = reference <= (i & mask); break;
	  case GL_GREATER:	*tp++ = reference > (i & mask); break;
	  case GL_NOTEQUAL:	*tp++ = reference != (i & mask); break;
	  case GL_GEQUAL:	*tp++ = reference >= (i & mask); break;
	  case GL_ALWAYS:	*tp++ = GL_TRUE; break;
	}
    }

    /*
    ** Build up fail op table.
    */
    writeMask = (__GLstencilCell) gc->state.stencil.writeMask;
    buildOpTable(&gc->stencilBuffer.failOpTable[0],
		 gc->state.stencil.fail, refVal, writeMask);
    buildOpTable(&gc->stencilBuffer.depthFailOpTable[0],
		 gc->state.stencil.depthFail, refVal, writeMask);
    buildOpTable(&gc->stencilBuffer.depthPassOpTable[0],
		 gc->state.stencil.depthPass, refVal, writeMask);
}

/************************************************************************/

static void FASTCALL Pick(__GLcontext *gc, __GLstencilBuffer *sfb)
{
#ifdef __GL_LINT
    sfb = sfb;
#endif
    if (gc->validateMask & (__GL_VALIDATE_STENCIL_FUNC |
			    __GL_VALIDATE_STENCIL_OP)) {
#ifdef NT
        __glValidateStencil(gc, sfb);
#else
	__glValidateStencil(gc);
#endif // NT
    }
}

void FASTCALL __glInitStencil8(__GLcontext *gc, __GLstencilBuffer *sfb)
{
    sfb->buf.elementSize = sizeof(__GLstencilCell);
    sfb->buf.gc = gc;
    sfb->pick = Pick;
    sfb->store = Store;
    sfb->fetch = Fetch;
#ifndef NT
// Initialized in __glValidateStencil.
    sfb->testFunc = TestFunc;
    sfb->failOp = FailOp;
    sfb->passDepthFailOp = PassDepthFailOp;
    sfb->depthPassOp = DepthPassOp;
#endif // !NT
    sfb->clear = Clear;
}

void FASTCALL __glFreeStencil8(__GLcontext *gc, __GLstencilBuffer *fb)
{
#ifdef __GL_LINT
    gc = gc;
    fb = fb;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_polys.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

/*
** Process the incoming span by calling all of the appropriate span procs.
*/
GLboolean FASTCALL __glProcessSpan(__GLcontext *gc)
{
    GLint m, i;

    m = gc->procs.span.m;

    gc->polygon.shader.done = GL_FALSE;
    for (i = 0; i < m; i++) {
        if ((*gc->procs.span.spanFuncs[i])(gc)) {
            i++;
            break;
        }
    }

    if (i != m && !gc->polygon.shader.done) {
        for (; i<m; i++) {
            if ((*gc->procs.span.stippledSpanFuncs[i])(gc)) {
                break;
            }
        }
    }

    return GL_FALSE;
}

/*
** Process the incoming span by calling all of the appropriate span procs.
**
** This routine sets gc->polygon.shader.cfb to &gc->frontBuffer and then
** to &gc->backBuffer.
*/
GLboolean FASTCALL __glProcessReplicateSpan(__GLcontext *gc)
{
    GLint n, m, i;
    __GLcolor colors[__GL_MAX_MAX_VIEWPORT], *fcp, *tcp;
    GLint w;

    w = gc->polygon.shader.length;
    n = gc->procs.span.n;
    m = gc->procs.span.m; 

    gc->polygon.shader.done = GL_FALSE;
    for (i = 0; i < n; i++) {
        if ((*gc->procs.span.spanFuncs[i])(gc)) {
            i++;
            goto earlyStipple;
        }
    }

    fcp = gc->polygon.shader.colors;
    tcp = colors;
    if (gc->modes.rgbMode) {
        for (i = 0; i < w; i++) {
            *tcp++ = *fcp++;
        }
    } else {
        for (i = 0; i < w; i++) {
            tcp->r = fcp->r;
            fcp++;
            tcp++;
        }
    }
    ASSERTOPENGL (m == n + 1, "m != n+1, wrong spanProc will be chosen");

    gc->polygon.shader.cfb = &gc->frontBuffer;
        (*gc->frontBuffer.storeSpan)(gc);

    // for (i = n; i < m; i++) {
        // (*gc->procs.span.spanFuncs[i])(gc);
    // }

    fcp = colors;
    tcp = gc->polygon.shader.colors;
    if (gc->modes.rgbMode) {
        for (i = 0; i < w; i++) {
            *tcp++ = *fcp++;
        }
    } else {
        for (i = 0; i < w; i++) {
            tcp->r = fcp->r;
            fcp++;
            tcp++;
        }
    }
    gc->polygon.shader.cfb = &gc->backBuffer;
        (*gc->backBuffer.storeSpan)(gc);

    // for (i = n; i < m; i++) {
        // (*gc->procs.span.spanFuncs[i])(gc);
    // }

    return GL_FALSE;

earlyStipple:
    if (gc->polygon.shader.done) return GL_FALSE;

    for (; i < n; i++) {
        if ((*gc->procs.span.stippledSpanFuncs[i])(gc)) {
            return GL_FALSE;
        }
    }

    fcp = gc->polygon.shader.colors;
    tcp = colors;
    if (gc->modes.rgbMode) {
        for (i = 0; i < w; i++) {
            *tcp++ = *fcp++;
        }
    } else {
        for (i = 0; i < w; i++) {
            tcp->r = fcp->r;
            fcp++;
            tcp++;
        }
    }
    gc->polygon.shader.cfb = &gc->frontBuffer;
        (*gc->frontBuffer.storeStippledSpan)(gc);

    // for (i = n; i < m; i++) {
        // (*gc->procs.span.stippledSpanFuncs[i])(gc);
    // }

    fcp = colors;
    tcp = gc->polygon.shader.colors;
    if (gc->modes.rgbMode) {
        for (i = 0; i < w; i++) {
            *tcp++ = *fcp++;
        }
    } else {
        for (i = 0; i < w; i++) {
            tcp->r = fcp->r;
            fcp++;
            tcp++;
        }
    }
    gc->polygon.shader.cfb = &gc->backBuffer;
        (*gc->backBuffer.storeStippledSpan)(gc);

    // for (i = n; i < m; i++) {
        // (*gc->procs.span.stippledSpanFuncs[i])(gc);
    // }

    return GL_FALSE;
}

/*
** Perform scissoring on the incoming span, advancing parameter
** values only if necessary.
**
** Returns GL_TRUE if span was entirely (or sometimes when partially) clipped, 
** GL_FALSE otherwise.
*/
GLboolean FASTCALL __glClipSpan(__GLcontext *gc)
{
    GLint clipX0, clipX1, delta;
    GLint x, xr;
    GLint w, w2;
    GLboolean stippled;

    w = gc->polygon.shader.length;

    x = gc->polygon.shader.frag.x;
    stippled = GL_FALSE;
    clipX0 = gc->transform.clipX0;
    clipX1 = gc->transform.clipX1;
    xr = x + w;
    if ((x < clipX0) || (xr > clipX1)) {
        /*
        ** Span needs to be scissored in some fashion
        */
        if ((xr <= clipX0) || (x >= clipX1)) {
            /* Scissor out the entire span */
            gc->polygon.shader.done = GL_TRUE;
            return GL_TRUE;
        }
        if (xr > clipX1) {
            /*
            ** Span is clipped by the right edge of the scissor.  This is 
            ** easy, we will simply reduce the width of this span!
            */
            w = clipX1 - x;
        }
        if (x < clipX0) {
            __GLstippleWord bit, outMask, *osp;
            GLint count;

            /*
            ** Span is clipped by the left edge of the scissor.  This is hard.
            ** We have two choices.
            **
            ** 1) We can stipple the first half of the span.
            ** 2) We can bump all of the iterator values.
            **
            ** The problem with approach number 2 is that the routine 
            ** which originally asks to have a span processed has assumed 
            ** that the iterator values will not be munged.  So, if we 
            ** wanted to implement 2 (which would make this case faster),
            ** we would need to change that assumption, and make the higher
            ** routine shadow all of the iterator values, which would slow
            ** down all paths.  This is probably not a good trade to speed
            ** this path up, since this path will only occur when the scissor
            ** region (or window) is smaller than the viewport, and this span
            ** happens to hit the left edge of the scissor region (or window).
            **
            ** Therefore, we choose number 1.
            */
            delta = clipX0 - x;

            osp = gc->polygon.shader.stipplePat;
            w2 = w;
            while (w2) {
                count = w2;
                if (count > __GL_STIPPLE_BITS) {
                    count = __GL_STIPPLE_BITS;
                }
                w2 -= count;

                outMask = (__GLstippleWord) ~0;
                bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
                while (--count >= 0) {
                    if (delta > 0) {
                        delta--;
                        outMask &= ~bit;
                    }
#ifdef __GL_STIPPLE_MSB
                    bit >>= 1;
#else
                    bit <<= 1;
#endif
                }

                *osp++ = outMask;
            }

            stippled = GL_TRUE;
        }
    }
    ASSERTOPENGL(w <= __GL_MAX_MAX_VIEWPORT,
                 "Too many pixels generated by clip\n");

    gc->polygon.shader.length = w;

    return stippled;
}

/*
** Generate the polygon stipple for a span.
*/
GLboolean FASTCALL __glStippleSpan(__GLcontext *gc)
{
    __GLstippleWord stipple;
    __GLstippleWord *sp;
    GLint count;
    GLint shift;
    GLint w;

    w = gc->polygon.shader.length;

    if (gc->constants.yInverted) {
        stipple = gc->polygon.stipple[(gc->constants.height - 
                (gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1) 
                & (__GL_STIPPLE_BITS-1)];
    } else {
        stipple = gc->polygon.stipple[gc->polygon.shader.frag.y & 
                (__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
        /* No point in continuing */
        gc->polygon.shader.done = GL_TRUE;
        return GL_TRUE;
    }

    /* Replicate stipple word */
    count = w;
    sp = gc->polygon.shader.stipplePat;
    while (count > 0) {
        *sp++ = stipple;
        count -= __GL_STIPPLE_BITS;
    }

    return GL_TRUE;
}

/*
** Generate the polygon stipple for a stippled span.
*/
GLboolean FASTCALL __glStippleStippledSpan(__GLcontext *gc)
{
    __GLstippleWord stipple;
    __GLstippleWord *sp;
    GLint count;
    GLint shift;
    GLint w;

    w = gc->polygon.shader.length;

    if (gc->constants.yInverted) {
        stipple = gc->polygon.stipple[(gc->constants.height - 
                (gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1) 
                & (__GL_STIPPLE_BITS-1)];
    } else {
        stipple = gc->polygon.stipple[gc->polygon.shader.frag.y & 
                (__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
        /* No point in continuing */
        gc->polygon.shader.done = GL_TRUE;
        return GL_TRUE;
    }

    /* Replicate stipple word */
    count = w;
    sp = gc->polygon.shader.stipplePat;
    while (count > 0) {
        *sp++ &= stipple;
        count -= __GL_STIPPLE_BITS;
    }

    return GL_FALSE;
}

/************************************************************************/

/*
** Alpha test span uses a lookup table to do the alpha test function.
** Output a stipple with 1's where the test passed, and 0's where the
** test failed.
*/
GLboolean FASTCALL __glAlphaTestSpan(__GLcontext *gc)
{
    GLubyte *atft;
    GLint failed, count, ia;
    __GLstippleWord bit, outMask, *osp;
    __GLcolor *cp;
    GLint maxAlpha;
    GLint w;

    w = gc->polygon.shader.length;

    atft = &gc->alphaTestFuncTable[0];
    cp = gc->polygon.shader.colors;
    maxAlpha = gc->constants.alphaTestSize - 1;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            ia = (GLint)(gc->constants.alphaTableConv * cp->a);
            if (ia < 0) ia = 0;
            if (ia > maxAlpha) ia = maxAlpha;
            if (!atft[ia]) {
                /* Test failed */
                outMask &= ~bit;
                failed++;
            }
            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Stippled form of alpha test span that checks the stipple at each
** pixel and avoids the test where the stipple disallows it.
*/
GLboolean FASTCALL __glAlphaTestStippledSpan(__GLcontext *gc)
{
    GLubyte *atft;
    GLint count, ia, failed;
    __GLstippleWord bit, inMask, outMask, *isp;
    __GLcolor *cp;
    GLint maxAlpha;
    GLint w;

    w = gc->polygon.shader.length;
    isp = gc->polygon.shader.stipplePat;

    atft = &gc->alphaTestFuncTable[0];
    cp = gc->polygon.shader.colors;
    maxAlpha = gc->constants.alphaTestSize - 1;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *isp;
        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                ia = (GLint)(gc->constants.alphaTableConv * cp->a);
                if (ia < 0) ia = 0;
                if (ia > maxAlpha) ia = maxAlpha;
                if (!atft[ia]) {
                    /* Test failed */
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *isp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next stippled span proc */
        return GL_FALSE;
    }
    return GL_TRUE;
}

/************************************************************************/

/*
** Perform stencil testing.  Apply test fail operation as we go.
** Generate a stipple with 1's where the test passed and 0's where the
** test failed.
*/
GLboolean FASTCALL __glStencilTestSpan(__GLcontext *gc)
{
    __GLstencilCell *tft, *sfb, *fail, cell;
    GLint count, failed;
    __GLstippleWord bit, outMask, *osp;
    GLint w;

    w = gc->polygon.shader.length;

    sfb = gc->polygon.shader.sbuf;
    tft = gc->stencilBuffer.testFuncTable;
#ifdef NT
    if (!tft)
        return GL_FALSE;
#endif // NT
    fail = gc->stencilBuffer.failOpTable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            cell = sfb[0];
            /* test func table already anded cell values with mask */
            if (!tft[cell]) {
                /* Test failed */
                outMask &= ~bit;
                sfb[0] = fail[cell];
                failed++;
            }
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Stippled form of stencil test.
*/
GLboolean FASTCALL __glStencilTestStippledSpan(__GLcontext *gc)
{
    __GLstencilCell *tft, *sfb, *fail, cell;
    GLint failed, count;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLuint smask;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    sfb = gc->polygon.shader.sbuf;
    tft = gc->stencilBuffer.testFuncTable;
#ifdef NT
    if (!tft)
        return GL_FALSE;
#endif // NT
    fail = gc->stencilBuffer.failOpTable;
    smask = gc->state.stencil.mask;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                cell = sfb[0];
                if (!tft[cell & smask]) {
                    /* Test failed */
                    outMask &= ~bit;
                    sfb[0] = fail[cell];
                    failed++;
                }
            } else failed++;
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }
    return GL_TRUE;
}

/************************************************************************/

/*
** Depth test a span, when stenciling is disabled.
*/
GLboolean FASTCALL __glDepthTestSpan(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint failed, count;
    GLboolean (FASTCALL *testFunc)( __GLzValue, __GLzValue * );
    GLint stride = gc->depthBuffer.buf.elementSize;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    zfb = gc->polygon.shader.zbuf;
    testFunc = gc->procs.DTPixel;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if( (*testFunc)(z, zfb) == GL_FALSE ) {
                outMask &= ~bit;
                failed++;
            }
            z += dzdx;
            (GLubyte *) zfb += stride;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Stippled form of depth test span, when stenciling is disabled.
*/
GLboolean FASTCALL __glDepthTestStippledSpan(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint failed, count;
    GLboolean (FASTCALL *testFunc)( __GLzValue, __GLzValue * );
    GLint stride = gc->depthBuffer.buf.elementSize;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    sp = gc->polygon.shader.stipplePat;
    w = gc->polygon.shader.length;

    zfb = gc->polygon.shader.zbuf;
    testFunc = gc->procs.DTPixel;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                if( (*testFunc)(z, zfb) == GL_FALSE ) {
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            z += dzdx;
            (GLubyte *) zfb += stride;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }
    return GL_TRUE;
}

/*
** Depth test a span when stenciling is enabled.
*/
GLboolean FASTCALL __glDepthTestStencilSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count;
    GLboolean (FASTCALL *testFunc)( __GLzValue, __GLzValue * );
    GLint stride = gc->depthBuffer.buf.elementSize;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    zfb = gc->polygon.shader.zbuf;
    sfb = gc->polygon.shader.sbuf;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    testFunc = gc->procs.DTPixel;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if( (*testFunc)(z, zfb) ) {
                sfb[0] = zPassOp[sfb[0]];
            } else {
                sfb[0] = zFailOp[sfb[0]];
                outMask &= ~bit;
                failed++;
            }
            z += dzdx;
            (GLubyte *) zfb += stride;
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL __glDepthTestStencilStippledSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count;
    GLboolean (FASTCALL *testFunc)( __GLzValue, __GLzValue * );
    GLint stride = gc->depthBuffer.buf.elementSize;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    zfb = gc->polygon.shader.zbuf;
    sfb = gc->polygon.shader.sbuf;
    testFunc = gc->procs.DTPixel;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
#ifdef NT
    if (!zFailOp)
        return GL_FALSE;
#endif // NT
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord) ~0;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                if( (*testFunc)(z, zfb) ) {
                    sfb[0] = zPassOp[sfb[0]];
                } else {
                    sfb[0] = zFailOp[sfb[0]];
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            z += dzdx;
            (GLubyte *) zfb += stride;
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }

    return GL_TRUE;
}

/*
** Apply stencil depth pass op when depth testing is off.
*/
GLboolean FASTCALL __glDepthPassSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp;
    GLint count;
    GLint w;

    w = gc->polygon.shader.length;

    sfb = gc->polygon.shader.sbuf;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
#ifdef NT
    if (!zPassOp)
        return GL_FALSE;
#endif // NT
    count = w;
    while (--count >= 0) {
        sfb[0] = zPassOp[sfb[0]];
        sfb++;
    }

    return GL_FALSE;
}

/*
** Apply stencil depth pass op when depth testing is off.
*/
GLboolean FASTCALL __glDepthPassStippledSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp;
    GLint count;
    __GLstippleWord bit, inMask, *sp;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    sfb = gc->polygon.shader.sbuf;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
#ifdef NT
    if (!zPassOp)
        return GL_FALSE;
#endif // NT
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp++;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                sfb[0] = zPassOp[sfb[0]];
            }
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
    }

    /* Call next proc */
    return GL_FALSE;
}

/************************************************************************/

GLboolean FASTCALL __glShadeCISpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLfloat r, drdx;
    GLint w;

    w = gc->polygon.shader.length;

    r = gc->polygon.shader.frag.color.r;
    drdx = gc->polygon.shader.drdx;
    cp = gc->polygon.shader.colors;
    while (--w >= 0) {
        cp->r = r;
        r += drdx;
        cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glShadeRGBASpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLfloat r, g, b, a;
    __GLfloat drdx, dgdx, dbdx, dadx;
    GLint w;

    w = gc->polygon.shader.length;

    r = gc->polygon.shader.frag.color.r;
    g = gc->polygon.shader.frag.color.g;
    b = gc->polygon.shader.frag.color.b;
    a = gc->polygon.shader.frag.color.a;
    drdx = gc->polygon.shader.drdx;
    dgdx = gc->polygon.shader.dgdx;
    dbdx = gc->polygon.shader.dbdx;
    dadx = gc->polygon.shader.dadx;
    cp = gc->polygon.shader.colors;
    while (--w >= 0) {
        cp->r = r;
        cp->g = g;
        cp->b = b;
        cp->a = a;
        r += drdx;
        g += dgdx;
        b += dbdx;
        a += dadx;
        cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glFlatCISpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLfloat r;
    GLint w;

    w = gc->polygon.shader.length;

    r = gc->polygon.shader.frag.color.r;
    cp = gc->polygon.shader.colors;
    while (--w >= 0) {
        cp->r = r;
        cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glFlatRGBASpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLfloat r, g, b, a;
    GLint w;

    w = gc->polygon.shader.length;

    r = gc->polygon.shader.frag.color.r;
    g = gc->polygon.shader.frag.color.g;
    b = gc->polygon.shader.frag.color.b;
    a = gc->polygon.shader.frag.color.a;
    cp = gc->polygon.shader.colors;
    while (--w >= 0) {
        cp->r = r;
        cp->g = g;
        cp->b = b;
        cp->a = a;
        cp++;
    }

    return GL_FALSE;
}

/************************************************************************/

// Special case where qw = 0 for the span
GLboolean FASTCALL __glTextureSpanZeroQW(__GLcontext *gc)
{
    __GLcolor *cp;
    GLint w;

    w = gc->polygon.shader.length;
    cp = gc->polygon.shader.colors;

    while (--w >= 0) {
        // No need to compute rho here - it is undefined for qw = 0
        (*gc->procs.texture)(gc, cp, __glZero, __glZero, __glZero);
        cp++;
    }
    return GL_FALSE;
}

GLboolean FASTCALL __glTextureSpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLfloat s, t, qw;
    GLint w;

    qw = gc->polygon.shader.frag.qw;

    if( qw == (__GLfloat) 0.0 ) {
        return __glTextureSpanZeroQW( gc );
    }

    w = gc->polygon.shader.length;
    s = gc->polygon.shader.frag.s;
    t = gc->polygon.shader.frag.t;
    cp = gc->polygon.shader.colors;

    while (--w >= 0) {
        __GLfloat sw, tw, rho, qwinv;

        qwinv = __glOne / qw;
        sw = s * qwinv;
        tw = t * qwinv;

        rho = (*gc->procs.calcPolygonRho)(gc, &gc->polygon.shader,
                                            s, t, qw);
        (*gc->procs.texture)(gc, cp, sw, tw, rho);
        s += gc->polygon.shader.dsdx;
        t += gc->polygon.shader.dtdx;
        qw += gc->polygon.shader.dqwdx;
        cp++;
    }

    return GL_FALSE;
}

GLboolean FASTCALL __glTextureStippledSpan(__GLcontext *gc)
{
    __GLstippleWord inMask, bit, *sp;
    GLint count;
    __GLcolor *cp;
    __GLfloat s, t, qw;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    s = gc->polygon.shader.frag.s;
    t = gc->polygon.shader.frag.t;
    qw = gc->polygon.shader.frag.qw;
    cp = gc->polygon.shader.colors;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp++;
        bit = (__GLstippleWord) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                __GLfloat sw, tw, rho, qwinv;

                if( qw == (__GLfloat) 0.0 ) {
                    sw = tw = (__GLfloat) 0.0;
                }
                else {
                    qwinv = __glOne / qw;
                    sw = s * qwinv;
                    tw = t * qwinv;
                }
                rho = (*gc->procs.calcPolygonRho)(gc, &gc->polygon.shader,
                                                    s, t, qw);
                (*gc->procs.texture)(gc, cp, sw, tw, rho);
            }
            s += gc->polygon.shader.dsdx;
            t += gc->polygon.shader.dtdx;
            qw += gc->polygon.shader.dqwdx;
            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
    }

    return GL_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_tcltb.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#ifdef GL_EXT_paletted_texture
GLboolean __glCheckColorTableArgs(__GLcontext *gc, GLenum format, GLenum type)
{
    switch (format)
    {
      case GL_RED:
      case GL_GREEN:		case GL_BLUE:
      case GL_ALPHA:		case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	break;
    default:
    bad_enum:
        __glSetError(GL_INVALID_ENUM);
        return GL_FALSE;
    }
    
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	goto bad_enum;
    }

    return GL_TRUE;
}

void APIPRIVATE __glim_ColorTableEXT(GLenum target,
                                     GLenum internalFormat, GLsizei width,
                                     GLenum format, GLenum type,
                                     const GLvoid *data, GLboolean _IsDlist)
{
    __GLtexture *tex;
    GLint level;
    __GLpixelSpanInfo spanInfo;
    GLenum baseFormat;
    RGBQUAD *newData;

    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    switch(internalFormat)
    {
    case GL_RGB:		case 3:
    case GL_R3_G3_B2:		case GL_RGB4:
    case GL_RGB5:		case GL_RGB8:
    case GL_RGB10:	        case GL_RGB12:
    case GL_RGB16:
	baseFormat = GL_RGB;
        break;
    case GL_RGBA:		case 4:
    case GL_RGBA2:	        case GL_RGBA4:
    case GL_RGBA8:              case GL_RGB5_A1:
    case GL_RGBA12:             case GL_RGBA16:
    case GL_RGB10_A2:
	baseFormat = GL_RGBA;
        break;
    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // width must be a positive power of two greater than zero
    if (width <= 0 || (width & (width-1)) != 0)
    {
        __glSetError(GL_INVALID_VALUE);
        return;
    }

    if (!__glCheckColorTableArgs(gc, format, type))
    {
        return;
    }

    tex = __glLookUpTexture(gc, target);
        
    if (target == GL_PROXY_TEXTURE_1D ||
        target == GL_PROXY_TEXTURE_2D)
    {
        // Consider - How do MCD's indicate their palette support?
        
        // We're only in this case if it's a legal proxy target value
        // so there's no need to do a real check
        ASSERTOPENGL(tex != NULL, "Invalid proxy target");
        
        tex->paletteRequestedFormat = internalFormat;
        tex->paletteTotalSize = width;
        tex->paletteSize = tex->paletteTotalSize;
        
        // Proxies have no data so there's no need to do any more
        return;
    }

    if (data == NULL)
    {
        return;
    }
    
    if (tex == NULL)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // Allocate palette storage
    newData = GCREALLOC(gc, tex->paletteTotalData, sizeof(RGBQUAD)*width);
    if (newData == NULL)
    {
        return;
    }

    tex->paletteBaseFormat = baseFormat;
    tex->paletteRequestedFormat = internalFormat;
    tex->paletteTotalSize = width;
    __glSetPaletteSubdivision(tex, tex->paletteTotalSize);
    tex->paletteTotalData = newData;
    tex->paletteData = tex->paletteTotalData;

    // This routine can be called on any kind of texture, not necessarily
    // color-indexed ones.  If it is a color-index texture then we
    // need to set the appropriate baseFormat and extract procs
    // according to the palette data
    if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT ||
        tex->level[0].internalFormat == GL_COLOR_INDEX16_EXT)
    {
        for (level = 0; level < gc->constants.maxMipMapLevel; level++)
        {
            tex->level[level].baseFormat = tex->paletteBaseFormat;
            // Pick proper extraction proc
            if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT)
            {
                __glSetPaletteLevelExtract8(tex, &tex->level[level],
                                            tex->level[level].border);
            }
            else
            {
                ASSERTOPENGL(tex->level[0].internalFormat ==
                             GL_COLOR_INDEX16_EXT,
                             "Unexpected internalFormat\n");
            
                __glSetPaletteLevelExtract16(tex, &tex->level[level],
                                             tex->level[level].border);
            }
        }
        
        // We need to repick the texture procs because the baseFormat
        // field has changed
        __GL_DELAY_VALIDATE(gc);
    }

    // Copy user palette data into BGRA form
    spanInfo.dstImage = tex->paletteTotalData;
    __glInitTextureUnpack(gc, &spanInfo, width, 1, format, type, data, 
                          GL_BGRA_EXT, _IsDlist);
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);

    // Don't update the optimized palette unless it would actually
    // get used
    if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT ||
        tex->level[0].internalFormat == GL_COLOR_INDEX16_EXT)
    {
        __GLtextureObject *pto;
        
        pto = __glLookUpTextureObject(gc, target);
        __glGenUpdateTexturePalette(gc, tex, pto->loadKey,
                                    0, tex->paletteTotalSize);
    }
}

void APIPRIVATE __glim_ColorSubTableEXT(GLenum target, GLsizei start,
                                        GLsizei count, GLenum format,
                                        GLenum type, const GLvoid *data,
                                        GLboolean _IsDlist)
{
    __GLtexture *tex;
    __GLpixelSpanInfo spanInfo;

    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    if (!__glCheckColorTableArgs(gc, format, type))
    {
        return;
    }

    tex = __glLookUpTexture(gc, target);
    if (tex == NULL ||
        target == GL_PROXY_TEXTURE_1D ||
        target == GL_PROXY_TEXTURE_2D)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    if (data == NULL)
    {
        return;
    }
    
    // Validate start and count
    if (start > tex->paletteTotalSize ||
        start+count > tex->paletteTotalSize)
    {
        __glSetError(GL_INVALID_VALUE);
        return;
    }

    // Copy user palette data into BGRA form
    spanInfo.dstImage = tex->paletteTotalData;
    __glInitTextureUnpack(gc, &spanInfo, count, 1, format, type, data, 
                          GL_BGRA_EXT, _IsDlist);
    spanInfo.dstSkipPixels += start;
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);

    // Don't update the optimized palette unless it would actually
    // get used
    if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT ||
        tex->level[0].internalFormat == GL_COLOR_INDEX16_EXT)
    {
        __GLtextureObject *pto;
        
        pto = __glLookUpTextureObject(gc, target);
        __glGenUpdateTexturePalette(gc, tex, pto->loadKey, start, count);
    }
}

void APIPRIVATE __glim_GetColorTableEXT(GLenum target, GLenum format,
                                        GLenum type, GLvoid *data)
{
    __GLtexture *tex;
    GLint level;
    __GLpixelSpanInfo spanInfo;
    GLenum baseFormat;

    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();
    
    if (!__glCheckColorTableArgs(gc, format, type))
    {
        return;
    }
    
    tex = __glLookUpTexture(gc, target);
    if (tex == NULL ||
        target == GL_PROXY_TEXTURE_1D ||
        target == GL_PROXY_TEXTURE_2D)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    
    ASSERTOPENGL(tex->paletteTotalData != NULL,
                 "GetColorTable with no palette data\n");

    // Copy BGRA data into user buffer
    spanInfo.srcImage = tex->paletteTotalData;
    spanInfo.srcFormat = GL_BGRA_EXT;
    spanInfo.srcType = GL_UNSIGNED_BYTE;
    spanInfo.srcAlignment = 4;
    __glInitImagePack(gc, &spanInfo, tex->paletteTotalSize, 1,
                      format, type, data);
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
}

void APIPRIVATE __glim_GetColorTableParameterivEXT(GLenum target,
                                                   GLenum pname,
                                                   GLint *params)
{
    __GLtexture *tex;

    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);
    if (tex == NULL)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    switch(pname)
    {
    case GL_COLOR_TABLE_FORMAT_EXT:
        *params = tex->paletteRequestedFormat;
        break;
    case GL_COLOR_TABLE_WIDTH_EXT:
        *params = tex->paletteTotalSize;
        break;
    case GL_COLOR_TABLE_RED_SIZE_EXT:
    case GL_COLOR_TABLE_GREEN_SIZE_EXT:
    case GL_COLOR_TABLE_BLUE_SIZE_EXT:
    case GL_COLOR_TABLE_ALPHA_SIZE_EXT:
        *params = 8;
        break;
#ifdef GL_EXT_flat_paletted_lighting
    case GL_COLOR_TABLE_SUBDIVISION_EXT:
        *params = tex->paletteSize;
        break;
#endif

    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

void APIPRIVATE __glim_GetColorTableParameterfvEXT(GLenum target,
                                                   GLenum pname,
                                                   GLfloat *params)
{
    __GLtexture *tex;

    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);
    if (tex == NULL)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    switch(pname)
    {
    case GL_COLOR_TABLE_FORMAT_EXT:
        *params = (GLfloat)tex->paletteRequestedFormat;
        break;
    case GL_COLOR_TABLE_WIDTH_EXT:
        *params = (GLfloat)tex->paletteTotalSize;
        break;
    case GL_COLOR_TABLE_RED_SIZE_EXT:
    case GL_COLOR_TABLE_GREEN_SIZE_EXT:
    case GL_COLOR_TABLE_BLUE_SIZE_EXT:
    case GL_COLOR_TABLE_ALPHA_SIZE_EXT:
        *params = (GLfloat)8;
        break;
#ifdef GL_EXT_flat_paletted_lighting
    case GL_COLOR_TABLE_SUBDIVISION_EXT:
        *params = (GLfloat)tex->paletteSize;
        break;
#endif

    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}
#endif // GL_EXT_paletted_texture

#ifdef GL_EXT_flat_paletted_lighting
void APIPRIVATE __glim_ColorTableParameterivEXT(GLenum target,
                                                GLenum pname,
                                                const GLint *params)
{
    __GLtexture *tex;
    GLint ival;

    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);
    if (tex == NULL)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    switch(pname)
    {
    case GL_COLOR_TABLE_SUBDIVISION_EXT:
        ival = *params;
        
        // Value must be an integer power of two between one and the total
        // palette size
        if ((ival & (ival-1)) != 0 ||
            ival < 1 ||
            ival > tex->paletteTotalSize)
        {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        
        __glSetPaletteSubdivision(tex, ival);
        break;

    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}

void APIPRIVATE __glim_ColorTableParameterfvEXT(GLenum target,
                                                GLenum pname,
                                                const GLfloat *params)
{
    __GLtexture *tex;
    GLfloat fval;
    GLint ival;

    __GL_SETUP_NOT_IN_BEGIN();

    tex = __glLookUpTexture(gc, target);
    if (tex == NULL)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    switch(pname)
    {
    case GL_COLOR_TABLE_SUBDIVISION_EXT:
        fval = *params;
        ival = (int)fval;
        
        // Value must be an integer power of two between one and the total
        // palette size
        if (fval != (GLfloat)ival ||
            (ival & (ival-1)) != 0 ||
            ival < 1 ||
            ival > tex->paletteTotalSize)
        {
            __glSetError(GL_INVALID_VALUE);
            return;
        }
        
        __glSetPaletteSubdivision(tex, ival);
        break;

    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
}
#endif // GL_EXT_flat_paletted_lighting
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_store.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.13 $
** $Date: 1993/05/14 09:00:53 $
*/
#include "precomp.h"
#pragma hdrstop

/*
** Store fragment proc.
** alpha test on, stencil test on, depth test on
*/
void FASTCALL __glDoStore_ASD(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!gc->alphaTestFuncTable[(GLint) (frag->color.a * 
	    gc->constants.alphaTableConv)]) {
	/* alpha test failed */
	return;
    }
    if (!(*gc->stencilBuffer.testFunc)(&gc->stencilBuffer, x, y)) {
	/* stencil test failed */
	(*gc->stencilBuffer.failOp)(&gc->stencilBuffer, x, y);
	return;
    }
    if (!(*gc->depthBuffer.store)(&gc->depthBuffer, x, y, frag->z)) {
	/* depth buffer test failed */
	(*gc->stencilBuffer.passDepthFailOp)(&gc->stencilBuffer, x, y);
	return;
    }
    (*gc->stencilBuffer.depthPassOp)(&gc->stencilBuffer, x, y);


    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test on, stencil test on, depth test off
*/
void FASTCALL __glDoStore_AS(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!gc->alphaTestFuncTable[(GLint) (frag->color.a * 
	    gc->constants.alphaTableConv)]) {
	/* alpha test failed */
	return;
    }
    if (!(*gc->stencilBuffer.testFunc)(&gc->stencilBuffer, x, y)) {
	/* stencil test failed */
	(*gc->stencilBuffer.failOp)(&gc->stencilBuffer, x, y);
	return;
    }
    (*gc->stencilBuffer.depthPassOp)(&gc->stencilBuffer, x, y);

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test on, stencil test off, depth test on
*/
void FASTCALL __glDoStore_AD(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!gc->alphaTestFuncTable[(GLint) (frag->color.a * 
	    gc->constants.alphaTableConv)]) {
	/* alpha test failed */
	return;
    }
    if (!(*gc->depthBuffer.store)(&gc->depthBuffer, x, y, frag->z)) {
	/* depth buffer test failed */
	return;
    }

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test off, stencil test on, depth test on
*/
void FASTCALL __glDoStore_SD(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!(*gc->stencilBuffer.testFunc)(&gc->stencilBuffer, x, y)) {
	/* stencil test failed */
	(*gc->stencilBuffer.failOp)(&gc->stencilBuffer, x, y);
	return;
    }
    if (!(*gc->depthBuffer.store)(&gc->depthBuffer, x, y, frag->z)) {
	/* depth buffer test failed */
	(*gc->stencilBuffer.passDepthFailOp)(&gc->stencilBuffer, x, y);
	return;
    }
    (*gc->stencilBuffer.depthPassOp)(&gc->stencilBuffer, x, y);

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test on, stencil test off, depth test off
*/
void FASTCALL __glDoStore_A(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!gc->alphaTestFuncTable[(GLint) (frag->color.a * 
	    gc->constants.alphaTableConv)]) {
	/* alpha test failed */
	return;
    }

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test off, stencil test on, depth test off, draw to current buffer
*/
void FASTCALL __glDoStore_S(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!(*gc->stencilBuffer.testFunc)(&gc->stencilBuffer, x, y)) {
	/* stencil test failed */
	(*gc->stencilBuffer.failOp)(&gc->stencilBuffer, x, y);
	return;
    }
    (*gc->stencilBuffer.depthPassOp)(&gc->stencilBuffer, x, y);

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test off, stencil test off, depth test on
*/
void FASTCALL __glDoStore_D(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    if (!(*gc->depthBuffer.store)(&gc->depthBuffer, x, y, frag->z)) {
	/* depth buffer test failed */
	return;
    }

    (*gc->procs.cfbStore)( cfb, frag );
}

/*
** Store fragment proc.
** alpha test off, stencil test off, depth test off, draw to current buffer
*/
void FASTCALL __glDoStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext *gc;
    GLint x, y;

    gc = cfb->buf.gc;

    x = frag->x;
    y = frag->y;

    /* Pixel ownership, scissor */
    if (x < gc->transform.clipX0 || y < gc->transform.clipY0 ||
	    x >= gc->transform.clipX1 || y >= gc->transform.clipY1) {
	return;
    }

    (*gc->procs.cfbStore)( cfb, frag );
}

/************************************************************************/

void FASTCALL __glDoNullStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
}

void FASTCALL __glDoDoubleStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    __GLcontext * gc = cfb->buf.gc;
    cfb = gc->front;
    cfb->store( cfb, frag );
    cfb = gc->back;
    cfb->store( cfb, frag );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_specc.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.4 $
** $Date: 1993/07/27 17:42:12 $
*/
#include "precomp.h"
#pragma hdrstop

/*
** A simple few routines which saves a cache for specular and spotlight
** computation (rather than recomputing the tables every time the user
** changes the specular or spotlight exponents).
*/

/*
** Any more than TOO_MANY_LUT_ENTRIES entries, and we free any that 
** become unreferenced.
*/
#define TOO_MANY_LUT_ENTRIES	32

typedef struct {
    __GLfloat exp;
    __GLspecLUTEntry *table;
} __GLspecLUTEntryPtr;

typedef struct __GLspecLUTCache_Rec {
    GLint nentries;
    GLint allocatedSize;
    __GLspecLUTEntryPtr entries[1];
} __GLspecLUTCache;

void FASTCALL __glInitLUTCache(__GLcontext *gc)
{
    __GLspecLUTCache *lutCache;

    lutCache = gc->light.lutCache = (__GLspecLUTCache *) 
	    GCALLOC(gc, sizeof(__GLspecLUTCache));
#ifdef NT
    if (!lutCache)
        return;
#endif // NT
    lutCache->nentries = 0;
    lutCache->allocatedSize = 1;
}

void FASTCALL __glFreeLUTCache(__GLcontext *gc)
{
    int i;
    GLint nentries;
    __GLspecLUTEntryPtr *entry;
    __GLspecLUTCache *lutCache;

    lutCache = gc->light.lutCache;
#ifdef NT
    if (!lutCache)
        return;
#endif // NT
    nentries = lutCache->nentries;
    for (i = 0; i < nentries; i++) {
	entry = &(lutCache->entries[i]);
	GCFREE(gc, entry->table);
    }
    GCFREE(gc, lutCache);
}

static __GLspecLUTEntry *findEntry(__GLspecLUTCache *lutCache, __GLfloat exp, 
				   GLint *location)
{
    GLint nentries;
    GLint bottom, half, top;
    __GLspecLUTEntry *table;
    __GLspecLUTEntryPtr *entry;

#ifdef NT
    ASSERTOPENGL(lutCache != NULL, "No LUT cache\n");
#endif // NT
    nentries = lutCache->nentries;
    /* First attempt to find this entry in our cache */
    bottom = 0;
    top = nentries;
    while (top > bottom) {
	/* Entry might exist in the range [bottom, top-1] */
	half = (bottom+top)/2;
	entry = &(lutCache->entries[half]);
	if (entry->exp == exp) {
	    /* Found the table already cached! */
	    table = entry->table;
	    *location = half;
	    return table;
	}
	if (exp < entry->exp) {
	    /* exp might exist somewhere earlier in the table */
	    top = half;
	} else /* exp > entry->exp */ {
	    /* exp might exist somewhere later in the table */
	    bottom = half+1;
	}
    }
    *location = bottom;
    return NULL;
}

__GLspecLUTEntry *__glCreateSpecLUT(__GLcontext *gc, __GLfloat exp)
{
    GLint nentries, allocatedSize;
    GLint location;
    __GLspecLUTCache *lutCache;
    __GLspecLUTEntryPtr *entry;
    __GLspecLUTEntry *table;
    __GLfloat *tableEntry;
    GLdouble threshold, scale, x, dx;
    GLint i;

    /* This code uses double-precision math, so make sure that the FPU */
    /* is set properly: */

    FPU_SAVE_MODE();
    FPU_CHOP_OFF_PREC_HI();

    lutCache = gc->light.lutCache;
#ifdef NT
    if (!lutCache)
        return (__GLspecLUTEntry *)NULL;
#endif // NT

    if (table = findEntry(lutCache, exp, &location)) {
	table->refcount++;
	return table;
    }
    /* 
    ** We failed to find our entry in our cache anywhere, and have to compute 
    ** it.
    */
    lutCache->nentries = nentries = 1 + lutCache->nentries;
    allocatedSize = lutCache->allocatedSize;

    if (nentries > allocatedSize) {
        /* Allocate space for another six entries (arbitrarily) */
        lutCache->allocatedSize = allocatedSize = allocatedSize + 6;
        if (!(lutCache = (__GLspecLUTCache *)
                GCREALLOC(gc, lutCache, sizeof(__GLspecLUTCache) +
                          allocatedSize * sizeof(__GLspecLUTEntryPtr))))
        {
            gc->light.lutCache->allocatedSize -= 6;
            gc->light.lutCache->nentries -= 1;
            return (__GLspecLUTEntry *)NULL;
        }
        gc->light.lutCache = lutCache;
    }

    /*
    ** We have enough space now.  So we stick the new entry in the array
    ** at entry 'location'.  The rest of the entries need to be moved up
    ** (move [location, nentries-2] up to [location+1, nentries-1]).
    */
    if (nentries-location-1) {
#ifdef NT
	__GL_MEMMOVE(&(lutCache->entries[location+1]), 
		&(lutCache->entries[location]),
		(nentries-location-1) * sizeof(__GLspecLUTEntryPtr));
#else
	__GL_MEMCOPY(&(lutCache->entries[location+1]), 
		&(lutCache->entries[location]),
		(nentries-location-1) * sizeof(__GLspecLUTEntryPtr));
#endif
    }
    entry = &(lutCache->entries[location]);
    entry->exp = exp;
    table = entry->table = (__GLspecLUTEntry *) 
	    GCALLOC(gc, sizeof(__GLspecLUTEntry));
#ifdef NT
    if (!table)
        return (__GLspecLUTEntry *)NULL;
#endif // NT

    /* Compute threshold */
    if (exp == (__GLfloat) 0.0) {
	threshold = (GLdouble) 0.0;
    } else {
#ifdef NT
    // Changing this enabled conformance to pass for color index visuals
    // with 4096 colors, and did not seem to affect anything else.
    // What this does is sort of reduce the granularity at the beginning
    // of the table, because without it we were getting too big a jump
    // between 0 and the first entry in the table, causing l_sen.c to fail.
	threshold = (GLdouble) __GL_POWF((__GLfloat) 0.0005, (__GLfloat) 1.0 / exp);
#else
	threshold = __GL_POWF(0.002, 1.0 / exp);
#endif
    }

    scale = (GLdouble) (__GL_SPEC_LOOKUP_TABLE_SIZE - 1) / ((GLdouble) 1.0 - threshold);
    dx = (GLdouble) 1.0 / scale;
    x = threshold;
    tableEntry = table->table;
    for (i = __GL_SPEC_LOOKUP_TABLE_SIZE; --i >= 0; ) {
	*tableEntry++ = __GL_POWF(x, exp);
	x += dx;
    }
    table->threshold = threshold;
    table->scale = scale;
    table->refcount = 1;
    table->exp = exp;

    FPU_RESTORE_MODE();

    return table;
}

void FASTCALL __glFreeSpecLUT(__GLcontext *gc, __GLspecLUTEntry *lut)
{
    __GLspecLUTCache *lutCache;
    GLint location, nentries;
    __GLspecLUTEntry *table;

    if (lut == NULL) return;

    ASSERTOPENGL(lut->refcount != 0, "Invalid refcount\n");

    lut->refcount--;
    if (lut->refcount > 0) return;

    lutCache = gc->light.lutCache;
#ifdef NT
    ASSERTOPENGL(lutCache != NULL, "No LUT cache\n");
#endif // NT

    table = findEntry(lutCache, lut->exp, &location);

    ASSERTOPENGL(table == lut, "Wrong LUT found\n");

    if (table->refcount == 0 && lutCache->nentries >= TOO_MANY_LUT_ENTRIES) {
	/* 
	** Free entry 'location'.
	** This requires reducing lutCache->nentries by one, and copying 
	** entries [location+1, nentries] to [location, nentries-1].
	*/
	lutCache->nentries = nentries = lutCache->nentries - 1;
#ifdef NT
	__GL_MEMMOVE(&(lutCache->entries[location]),
		&(lutCache->entries[location+1]),
		(nentries-location) * sizeof(__GLspecLUTEntryPtr));
#else
	__GL_MEMCOPY(&(lutCache->entries[location]),
		&(lutCache->entries[location+1]),
		(nentries-location) * sizeof(__GLspecLUTEntryPtr));
#endif
	GCFREE(gc, table);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_prim.c ===
/******************************Module*Header*******************************\
* Module Name: so_prim.c
*
* Routines to draw primitives
*
* Created: 10-16-1995
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.13 $
** $Date: 1993/08/31 16:23:41 $
*/
#include "precomp.h"
#pragma hdrstop

#include "glmath.h"
#include "devlock.h"

typedef void (FASTCALL *PFN_XFORM)
    (__GLcoord *, const __GLfloat *, const __GLmatrix *);

typedef void (FASTCALL *PFN_XFORMBATCH)
    (__GLcoord *, __GLcoord *, const __GLmatrix *);

#ifndef NEW_PARTIAL_PRIM
typedef void (FASTCALL *PFN_POLYARRAYDRAW)(__GLcontext *, POLYARRAY *);
#endif // NEW_PARTIAL_PRIM

typedef void (FASTCALL *PFN_POLYARRAYRENDER)(__GLcontext *, POLYARRAY *);

// The PA* functions apply to one array entry only.
// The PolyArray* functions apply to the whole array.

void FASTCALL PARenderPoint(__GLcontext *gc, __GLvertex *v);
void FASTCALL PARenderTriangle(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2);
void PARenderQuadFast(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2, __GLvertex *v3);
void PARenderQuadSlow(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2, __GLvertex *v3);
void FASTCALL PAApplyMaterial(__GLcontext *gc, __GLmatChange *mat, GLint face);
void FASTCALL PASphereGen(POLYDATA *pd, __GLcoord *result);

GLuint FASTCALL PAClipCheckFrustum(__GLcontext *gc, POLYARRAY *pa,
                                   POLYDATA *pdLast);
GLuint FASTCALL PAClipCheckFrustumWOne(__GLcontext *gc, POLYARRAY *pa,
                                   POLYDATA *pdLast);
GLuint FASTCALL PAClipCheckFrustum2D(__GLcontext *gc, POLYARRAY *pa,
                                     POLYDATA *pdLast);
GLuint FASTCALL PAClipCheckAll(__GLcontext *gc, POLYARRAY *pa,
                               POLYDATA *pdLast);

void FASTCALL PolyArrayRenderPoints(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderLines(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderLStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderTriangles(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderTStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderTFan(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderQuads(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderQStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayRenderPolygon(__GLcontext *gc, POLYARRAY *pa);

#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawPoints(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawLines(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawLLoop(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawLStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawTriangles(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawTStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawTFan(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawQuads(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawQStrip(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayDrawPolygon(__GLcontext *gc, POLYARRAY *pa);
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayPropagateIndex(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayPropagateSameIndex(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayPropagateSameColor(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayPropagateColor(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayProcessEye(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayProcessEdgeFlag(POLYARRAY *pa);

void FASTCALL PolyArrayComputeFog(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayApplyMaterials(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCalcLightCache(__GLcontext *gc);
GLuint FASTCALL PolyArrayCheckClippedPrimitive(__GLcontext *gc, POLYARRAY *pa, GLuint andCodes);
POLYARRAY * FASTCALL PolyArrayRemoveClippedPrimitives(POLYARRAY *pa0);

void RestoreAfterMcd(__GLGENcontext *gengc,
                     POLYARRAY *paBegin, POLYARRAY *paEnd);

// Turn on clipcode optimization
#define POLYARRAY_AND_CLIPCODES     1

// Some assertions used in this code

// ASSERT_PRIMITIVE
#if !((GL_POINTS         == 0x0000)     \
   && (GL_LINES          == 0x0001)     \
   && (GL_LINE_LOOP      == 0x0002)     \
   && (GL_LINE_STRIP     == 0x0003)     \
   && (GL_TRIANGLES      == 0x0004)     \
   && (GL_TRIANGLE_STRIP == 0x0005)     \
   && (GL_TRIANGLE_FAN   == 0x0006)     \
   && (GL_QUADS          == 0x0007)     \
   && (GL_QUAD_STRIP     == 0x0008)     \
   && (GL_POLYGON        == 0x0009))
#error "bad primitive ordering\n"
#endif

// ASSERT_FACE
#if !((__GL_FRONTFACE == 0) && (__GL_BACKFACE == 1))
#error "bad face ordering\n"
#endif

// ASSERT_MATERIAL
#if !((POLYARRAY_MATERIAL_FRONT == POLYDATA_MATERIAL_FRONT)      \
   && (POLYARRAY_MATERIAL_BACK  == POLYDATA_MATERIAL_BACK))
#error "bad material mask\n"
#endif

// ASSERT_VERTEX
#if !((POLYARRAY_VERTEX2 == POLYDATA_VERTEX2)   \
   && (POLYARRAY_VERTEX3 == POLYDATA_VERTEX3)   \
   && (POLYARRAY_VERTEX4 == POLYDATA_VERTEX4))
#error "bad vertex flags\n"
#endif

//!!! Set it to 0!
#define ENABLE_PERF_CHECK 0
#if ENABLE_PERF_CHECK
// Performance check macro
#define PERF_CHECK(expr,str)            \
    {                                   \
        static BOOL bPrinted = FALSE;   \
        if (!(expr) && !bPrinted)       \
        {                               \
            bPrinted = TRUE;            \
            WARNING("PERF_CHECK: " str);\
        }                               \
    }
#else
#define PERF_CHECK(expr,str)
#endif // ENABLE_PERF_CHECK

// Copy processed vertex.
#define PA_COPY_PROCESSED_VERTEX(pdDst,pdSrc)                   \
    {                                                           \
        *(pdDst) = *(pdSrc);                                    \
        /* must update color pointer for polygon to work! */    \
        (pdDst)->color = &(pdDst)->colors[__GL_FRONTFACE];      \
    }
#define PA_COPY_VERTEX(pdDst,pdSrc)     PA_COPY_PROCESSED_VERTEX(pdDst,pdSrc)

#define PD_ARRAY(ary, idx) \
    ((POLYDATA *)((GLubyte *)(ary)+(sizeof(POLYDATA) * idx)))
#define PD_VERTEX(ary, idx) \
    ((__GLvertex *)((GLubyte *)(ary)+(sizeof(__GLvertex) *idx)))

#ifndef NEW_PARTIAL_PRIM
// Poly array draw routines.
// ASSERT_PRIMITIVE
PFN_POLYARRAYDRAW afnPolyArrayDraw[] =
{
    (PFN_POLYARRAYDRAW) PolyArrayDrawPoints,
    (PFN_POLYARRAYDRAW) PolyArrayDrawLines,
    (PFN_POLYARRAYDRAW) PolyArrayDrawLLoop,
    (PFN_POLYARRAYDRAW) PolyArrayDrawLStrip,
    (PFN_POLYARRAYDRAW) PolyArrayDrawTriangles,
    (PFN_POLYARRAYDRAW) PolyArrayDrawTStrip,
    (PFN_POLYARRAYDRAW) PolyArrayDrawTFan,
    (PFN_POLYARRAYDRAW) PolyArrayDrawQuads,
    (PFN_POLYARRAYDRAW) PolyArrayDrawQStrip,
    (PFN_POLYARRAYDRAW) PolyArrayDrawPolygon,
};
#endif // NEW_PARTIAL_PRIM

// READ THIS NOTE BEFORE YOU MAKE ANY CHANGES!
//
// NOTE: This function is also called by RasterPos to compute its associated
//       color and texture coordinates!
//       This code has to update current values and material even if there is
//       no vertex.

//!!! special case provoking vertex?

void APIPRIVATE __glim_DrawPolyArray(void *_pa0)
{
    __GLtransform *trMV;
    __GLmatrix    *m, *mEye;
    GLuint        enables;
    GLuint        paNeeds;
    GLuint        orCodes, andCodes;
    GLuint        paflagsAll;
    POLYDATA      *pd;
    POLYARRAY     *pa0 = (POLYARRAY *) _pa0;
    POLYARRAY     *pa;
    PFN_XFORM     pfnXformEye;
    PFN_XFORMBATCH pfnXform;
    GLuint (FASTCALL *clipCheck)(__GLcontext *gc, POLYARRAY *pa,
                                 POLYDATA *pdLast);

    __GLmatrix    *mInv;
    GLboolean     doEye;
    __GLcolor     scaledUserColor;
    GLuint        paFlags;
    __GLcolor     *pScaledUserColor;
    __GLcoord     *pCurrentNormal;
    __GLcoord     *pCurrentTexture;
    GLboolean     bXformLightToNorm = FALSE;
    GLuint        primFlags;
    BOOL          bMcdProcessDone;
    BOOL          bIsRasterPos;
    POLYARRAY*    paPrev = 0;

    __GL_SETUP();

    // Crank down the fpu precision to 24-bit mantissa to gain front-end speed.
    // This will only affect code which relies on double arithmetic.  Also,
    // mask off FP exceptions:

    FPU_SAVE_MODE();
    FPU_PREC_LOW_MASK_EXCEPTIONS();

// There are 3 possible begin modes.  If we are in the begin/end bracket,
// it is __GL_IN_BEGIN.  If we are not in the begin/end bracket, it is either
// __GL_NOT_IN_BEGIN or __GL_NEED_VALIDATE.
// Validation should only be done inside the display lock!

    ASSERTOPENGL(gc->beginMode != __GL_IN_BEGIN, "bad beginMode!");

    if (gc->beginMode == __GL_NEED_VALIDATE)
        (*gc->procs.validate)(gc);

    gc->beginMode = __GL_IN_BEGIN;

    // Initialize variables.

    enables = gc->state.enables.general;

    paNeeds = gc->vertex.paNeeds;

    paflagsAll = 0;

    // Need to save this flag because pa0 can be modified later,
    // possibly dropping the flag.
    bIsRasterPos = pa0->flags & POLYARRAY_RASTERPOS;

// ---------------------------------------------------------
// Update final current values and initialize current values at index 0
// if not given.  Material changes are updated later.

    paFlags = 0;

    if (!gc->modes.colorIndexMode) {
        __GL_SCALE_AND_CHECK_CLAMP_RGBA(scaledUserColor.r,
                                        scaledUserColor.g,
                                        scaledUserColor.b,
                                        scaledUserColor.a,
                                        gc, paFlags,
                                        gc->state.current.userColor.r,
                                        gc->state.current.userColor.g,
                                        gc->state.current.userColor.b,
                                        gc->state.current.userColor.a);
        pScaledUserColor = &scaledUserColor;
    } else {
        __GL_CHECK_CLAMP_CI(scaledUserColor.r, gc, paFlags, gc->state.current.userColorIndex);
    }

    pCurrentNormal = &gc->state.current.normal;
    pCurrentTexture = &gc->state.current.texture;
    primFlags = 0;

    // Optimization Possibility:
    // Currently, for every Primitive, we check to see if any of the
    // Attributes have been set by the evaluator. This could be potentially
    // optimized by having two versions of this loop (perhaps in a macro or
    // a function call); one which makes the checks and the other which doesnt.
    // If no evaluator is enabled, we could call the faster version (with
    // no checks)

    for (pa = pa0; pa; pa = pa->paNext)
    {
        POLYDATA *pd0;

        pd0 = pa->pd0;
        if (gc->modes.colorIndexMode)
        {
            // CI mode.
            // Update final current RGBA color incase one is given.

            if (pa->flags & POLYARRAY_OTHER_COLOR)
                gc->state.current.userColor = pa->otherColor;

            // Update final current CI color.

            if (!(pd0->flags & POLYDATA_COLOR_VALID))
            {
                pd0->flags |= POLYDATA_COLOR_VALID;
                pd0->colors[0].r = gc->state.current.userColorIndex;
                pa->flags |= paFlags;
            }

            // Update current color. pdCurColor could be NULL is there
            // were no glColor calls.
            if (pa->pdCurColor)
            {
                gc->state.current.userColorIndex = pa->pdCurColor->colors[0].r;
            }

            paFlags = (pa->flags & POLYARRAY_CLAMP_COLOR);
        }
        else
        {
            // RGBA mode.
            // Update final current CI color in case one is given.

            if (pa->flags & POLYARRAY_OTHER_COLOR)
                gc->state.current.userColorIndex = pa->otherColor.r;

            // Update final current RGBA color.

            if (!(pd0->flags & POLYDATA_COLOR_VALID))
            {
                pd0->flags |= POLYDATA_COLOR_VALID;
                pd0->colors[0] = *pScaledUserColor;
                pa->flags |= paFlags;
            }

            // Update current color. pdCurColor could be NULL is there
            // were no glColor calls.
            if (pa->pdCurColor)
            {
                pScaledUserColor = &pa->pdCurColor->colors[0];
            }

            paFlags = (pa->flags & POLYARRAY_CLAMP_COLOR);
        }

        // Update final current normal.

        if (!(pd0->flags & POLYDATA_NORMAL_VALID))
        {
            if (paNeeds & PANEEDS_NORMAL) {
                pd0->flags |= POLYDATA_NORMAL_VALID;
                // can also be pd0->normal = gc->state.current.normal!
                pd0->normal.x = pCurrentNormal->x;
                pd0->normal.y = pCurrentNormal->y;
                pd0->normal.z = pCurrentNormal->z;
            }
        }

        // Update current normal. pdCurNormal could be NULL if there
        // were no glNormal calls.
        if (pa->pdCurNormal)
        {
            pCurrentNormal = &pa->pdCurNormal->normal;
        }

        // Update final current texture coordinates.

        if (!(pd0->flags & POLYDATA_TEXTURE_VALID))
        {
            if (paNeeds & PANEEDS_TEXCOORD) {
                pd0->flags |= POLYDATA_TEXTURE_VALID;
                pd0->texture = *pCurrentTexture;

                if (__GL_FLOAT_COMPARE_PONE(pd0->texture.w, !=))
                    pa->flags |= POLYARRAY_TEXTURE4;
                else if (__GL_FLOAT_NEZ(pd0->texture.z))
                    pa->flags |= POLYARRAY_TEXTURE3;
                else if (__GL_FLOAT_NEZ(pd0->texture.y))
                    pa->flags |= POLYARRAY_TEXTURE2;
                else
                    pa->flags |= POLYARRAY_TEXTURE1;
            }
        }

        // Update current texture. pdCurTexture could be NULL if there
        // were no glTexture calls.
        if (pa->pdCurTexture)
        {
            pCurrentTexture = &pa->pdCurTexture->texture;
        }

        /*
         * Update current pointers. They have to point to the latest valid data.
         */
        if (pa->pdCurColor < pa->pdLastEvalColor)
        {
            pa->pdCurColor = pa->pdLastEvalColor;
        }
        if (pa->pdCurNormal < pa->pdLastEvalNormal)
        {
            pa->pdCurNormal = pa->pdLastEvalNormal;
        }
        if (pa->pdCurTexture < pa->pdLastEvalTexture)
        {
            pa->pdCurTexture = pa->pdLastEvalTexture;
        }
        // Update the texture key for hardware accelaration:

        pa->textureKey = gc->textureKey;

        // Update final current edge flag.

        if (!(pd0->flags & POLYDATA_EDGEFLAG_VALID))
        {
            if (gc->state.current.edgeTag)
                pd0->flags |= POLYDATA_EDGEFLAG_VALID | POLYDATA_EDGEFLAG_BOUNDARY;
            else
                pd0->flags |= POLYDATA_EDGEFLAG_VALID;
        }

        if (pa->pdCurEdgeFlag)
        {
            gc->state.current.edgeTag = (GLboolean)
                (pa->pdCurEdgeFlag->flags & POLYDATA_EDGEFLAG_BOUNDARY);
        }

        // Accumulate pa flags.

        paflagsAll |= pa->flags;

        // Accumulate primitive type bits
        primFlags |= 1 << pa->primType;

        if (pa->pd0 == pa->pdNextVertex)
        {
        // The polyarray has no vertices.
        // We have to apply material changes if there were any between BEGIN/END
        // and remove the polyarray from the chain
            if (pa->flags & (POLYARRAY_MATERIAL_FRONT | POLYARRAY_MATERIAL_BACK))
                PolyArrayApplyMaterials(gc, pa);
            if (paPrev)
                paPrev->paNext = pa->paNext;
            else
                pa0 = pa->paNext;
            PolyArrayRestoreColorPointer(pa);
        }
        else
        {
            paPrev = pa;
        }
    }

    // Store the normalized user color:

    if (!gc->modes.colorIndexMode)
    {
        gc->state.current.userColor.r = pScaledUserColor->r * gc->oneOverRedVertexScale;
        gc->state.current.userColor.g = pScaledUserColor->g * gc->oneOverGreenVertexScale;
        gc->state.current.userColor.b = pScaledUserColor->b * gc->oneOverBlueVertexScale;
        gc->state.current.userColor.a = pScaledUserColor->a * gc->oneOverAlphaVertexScale;
    }

    gc->state.current.normal.x = pCurrentNormal->x;
    gc->state.current.normal.y = pCurrentNormal->y;
    gc->state.current.normal.z = pCurrentNormal->z;

    gc->state.current.texture = *pCurrentTexture;

    // All polyarrays could be removed if they had no vertices
    if (!pa0)
    {
        bXformLightToNorm = FALSE;
        goto drawpolyarray_exit;
    }

    //
    // Get the modeling matrix:
    //

    trMV = gc->transform.modelView;


    // ---------------------------------------------------------
    //
    // Allow MCD 2.0 to do transform and light if possible.
    // Don't try it for rasterpos calls.
    //

    bMcdProcessDone = FALSE;

#if MCD_VER_MAJOR >= 2
    if (((__GLGENcontext *)gc)->pMcdState != NULL &&
        McdDriverInfo.mcdDriver.pMCDrvProcess != NULL &&
        gc->renderMode == GL_RENDER &&
        !bIsRasterPos)
#else
    if (0)
#endif
    {
        POLYMATERIAL *pm;
        PDMATERIAL *pdMat;
        POLYARRAY *paEnd;

        // If no material changes have ever been seen then there
        // won't be a polymaterial at all.
        pm = GLTEB_CLTPOLYMATERIAL();
        if (pm != NULL)
        {
            pdMat = pm->pdMaterial0;
        }
        else
        {
            pdMat = NULL;
        }

        paEnd = GenMcdProcessPrim((__GLGENcontext *)gc,
                                  pa0, paflagsAll, primFlags,
                                  (MCDTRANSFORM *)trMV,
                                  (MCDMATERIALCHANGES *)pdMat);

        RestoreAfterMcd((__GLGENcontext *)gc, pa0, paEnd);
        bMcdProcessDone = TRUE;

        if (paEnd == NULL)
        {
            goto drawpolyarray_exit;
        }
        else
        {
            // If MCDrvProcess kicks back we will not
            // call MCDrvDraw.  We could check for non-generic
            // here and abandon the batch, saving the front-end processing.
            // I don't think it's worth it since kicking back on
            // a non-generic format is basically a driver bug.
            pa0 = paEnd;
        }
    }


// ---------------------------------------------------------
// Initialize the normal matrix:
// Normals are not needed after color assignment and texture generation!
// The above is not true anymore. You need Normals for true PHONG shading.
// IN:  normal matrix
// OUT: normal matrix (processed)

    if (paNeeds & (PANEEDS_NORMAL | PANEEDS_NORMAL_FOR_TEXTURE))
    {
        if (trMV->flags & XFORM_UPDATE_INVERSE)
            __glComputeInverseTranspose(gc, trMV);
        gc->mInv = mInv = &trMV->inverseTranspose;
    }
#if DBG
    else
        gc->mInv = mInv = (__GLmatrix *) -1;
#endif

// ---------------------------------------------------------
// Find out is we have to transform normals for lighting
// We can only do lighting in object space if:
//      we're using infinite lighting AND
//      we're not doing two-sided lighting AND
//      we're rendering AND
//      the transformation matrix has unity scaling
//
    bXformLightToNorm =
        (gc->vertex.paNeeds & PANEEDS_NORMAL) &&
        (gc->renderMode == GL_RENDER) &&
        (mInv->nonScaling) &&
        ((paNeeds & (PANEEDS_FRONT_COLOR | PANEEDS_BACK_COLOR)) ==
                    PANEEDS_FRONT_COLOR) &&
        ((gc->procs.paCalcColor == PolyArrayFastCalcRGBColor) ||
         (gc->procs.paCalcColor == PolyArrayZippyCalcRGBColor) ||
         (gc->procs.paCalcColor == PolyArrayFastCalcCIColor));

// Transform normals for spherical map texture generation
//
    if (paNeeds & PANEEDS_NORMAL_FOR_TEXTURE)
    {
    // If we transform normals for texture, we have to process lighting in camera space
        bXformLightToNorm = FALSE;
    // Now transform normals
        for (pa = pa0; pa; pa = pa->paNext)
        {
            if (!(enables & __GL_NORMALIZE_ENABLE))
                (*mInv->xfNormBatch)(pa, mInv);
            else
                (*mInv->xfNormBatchN)(pa, mInv);
        }
        paNeeds &= ~PANEEDS_NORMAL;
    }

// ---------------------------------------------------------
// Process texture coordinates.  We need to do this while we still have
// valid object coordinate data.  If we need normals to perform the texture
// generation, we also transform the normals.
//
// Texture coordinates are modified in place.
//
// IN:  texture, obj, (eye), normal
// OUT: texture, (eye)

    if (paNeeds & PANEEDS_TEXCOORD)
    {
        if ((gc->procs.paCalcTexture == PolyArrayCalcTexture) &&
            (gc->transform.texture->matrix.matrixType == __GL_MT_IDENTITY)) {

            for (pa = pa0; pa; pa = pa->paNext)
            {
                PERF_CHECK(!(pa->flags & (POLYARRAY_TEXTURE3 | POLYARRAY_TEXTURE4)),
                           "Uses r, q texture coordinates!\n");

                // If all incoming vertices have valid texcoords, and texture
                // matrix is identity, and texgen is disabled, we are done.
                if ((pa->flags & POLYARRAY_SAME_POLYDATA_TYPE)
                    && (pa->pdCurTexture != pa->pd0)
                // Need to test 2nd vertex because pdCurTexture may have been
                // advanced as a result of combining TexCoord command after End
                    && ((pa->pd0 + 1)->flags & POLYDATA_TEXTURE_VALID))
                  ;
                else
                    PolyArrayCalcTexture(gc, pa);
            }
        } else {
            for (pa = pa0; pa; pa = pa->paNext)
            {
                PERF_CHECK(!(pa->flags & (POLYARRAY_TEXTURE3 | POLYARRAY_TEXTURE4)),
                           "Uses r, q texture coordinates!\n");

                (*gc->procs.paCalcTexture)(gc, pa);
            }
        }
    }

    //
    // Process the eye coordinate if:
    //   user clip planes are enabled
    //   we're processing RASTERPOS
    //   we have slow lighting which needs the eye coordinate
    //
    // We need to process the eye coordinate here because the
    // object coordinate gets trashed by the initial obj->clip
    // transform.
    //
    //
    //

    clipCheck = gc->procs.paClipCheck;

    // Compute eye coord first
    // We need eye coordinates to do user clip plane clipping
    if ((clipCheck == PAClipCheckAll) ||
        bIsRasterPos ||
        (gc->procs.paCalcColor == PolyArrayCalcCIColor) ||
        (gc->procs.paCalcColor == PolyArrayCalcRGBColor) ||
#ifdef GL_WIN_phong_shading
        (gc->polygon.shader.phong.flags & __GL_PHONG_NEED_EYE_XPOLATE) ||
#endif //GL_WIN_phong_shading
        (enables & __GL_FOG_ENABLE && gc->renderMode == GL_RENDER))
    {
        mEye = &trMV->matrix;

        if (paflagsAll & POLYARRAY_VERTEX4)
            pfnXformEye = mEye->xf4;
        else if (paflagsAll & POLYARRAY_VERTEX3)
            pfnXformEye = mEye->xf3;
        else
            pfnXformEye = mEye->xf2;

        doEye = TRUE;
    } else
        doEye = FALSE;


    // If any incoming coords contains w coord, use xf4.

    m = &trMV->mvp;

    if (paflagsAll & POLYARRAY_VERTEX4)
        pfnXform = (void*)m->xf4Batch;
    else if (paflagsAll & POLYARRAY_VERTEX3)
        pfnXform = (void*)m->xf3Batch;
    else
        pfnXform = (void*)m->xf2Batch;

//---------------------------------------------------------------------------
// If normalization is on, we will handle it here in one pass.  We will
// then transform the light into normal space
// flag.  Note that we need to save the original light values away so
// we can restore them before we exit.
//
    if (bXformLightToNorm)
    {
        __GLlightSourceMachine *lsm;
        LONG i;
        __GLmatrix matrix2;

        __glTranspose3x3(&matrix2, &trMV->matrix);
        for (i = 0, lsm = gc->light.sources; lsm; lsm = lsm->next, i++) {
            __GLcoord hv;
            __GLmatrix matrix;

            lsm->tmpHHat = lsm->hHat;
            lsm->tmpUnitVPpli = lsm->unitVPpli;


            __glMultMatrix(&matrix,
                           &gc->state.light.source[i].lightMatrix, &matrix2);

            hv = gc->state.light.source[i].position;

            __glXForm3x3(&hv, &hv.x, &matrix);
            __glNormalize(&lsm->unitVPpli.x, &hv.x);

            hv = lsm->unitVPpli;

            hv.x += matrix.matrix[2][0];
            hv.y += matrix.matrix[2][1];
            hv.z += matrix.matrix[2][2];

            __glNormalize(&lsm->hHat.x, &hv.x);
        }
    }

    PolyArrayCalcLightCache(gc);

// ---------------------------------------------------------
// Do transform, color, and lighting calculations.
//
// This is the heart of the rendering pipeline, so we try
// to do as many operations as possible while touching the
// least amount of memory to reduce cache affects.
//
// If it is phong-shading, dont update materials and dont do
// lighting.
// ---------------------------------------------------------

    for (pa = pa0; pa; pa = pa->paNext)
    {
        POLYDATA *pdLast;

#ifdef NEW_PARTIAL_PRIM
        pa->flags |= POLYARRAY_RENDER_PRIMITIVE;    // Needed for MCD
#endif
        pdLast = pa->pdNextVertex - 1;

// ---------------------------------------------------------
// Process the eye coordinate if we will need it in the
// pipeline and haven't yet processed it in texture generation.
// We have to do this before we trash the object coord in the
// next phase.
//
// IN:  obj
// OUT: eye

        if (doEye && !(pa->flags & POLYARRAY_EYE_PROCESSED)) {

            pa->flags |= POLYARRAY_EYE_PROCESSED;

            if (mEye->matrixType == __GL_MT_IDENTITY) {
                for (pd = pa->pd0; pd <= pdLast; pd++)
                    pd->eye = pd->obj;
            } else {
                for (pd = pa->pd0; pd <= pdLast; pd++)
                    (*pfnXformEye)(&pd->eye, (__GLfloat *) &pd->obj, mEye);
            }
        }

// ---------------------------------------------------------
// Process the object coordinate.  This generates the clip
// and window coordinates, along with the clip codes.
//
// IN:  obj (destroyed)
// OUT: clip, window

        orCodes  = 0;   // accumulate all clip codes
#ifdef POLYARRAY_AND_CLIPCODES
        andCodes = (GLuint) -1;
#endif


        if (m->matrixType == __GL_MT_IDENTITY)
        {
            // pd->clip = pd->obj;
            ASSERTOPENGL(&pd->clip == &pd->obj, "bad clip offset\n");
        }
        else
           (*pfnXform)(&pa->pd0->clip, &pdLast->clip, m);

        pa->orClipCodes  = 0;
        pa->andClipCodes = (GLuint)-1;

        if (clipCheck != PAClipCheckFrustum2D)
        {
            if (m->matrixType != __GL_MT_GENERAL &&
                !(pa->flags & POLYDATA_VERTEX4)  &&
                clipCheck != PAClipCheckAll)
                andCodes = PAClipCheckFrustumWOne(gc, pa, pdLast);
            else
                andCodes = (*clipCheck)(gc, pa, pdLast);
        }
        else
        {
            if (pa->flags & (POLYDATA_VERTEX3 | POLYDATA_VERTEX4))
                andCodes = PAClipCheckFrustum(gc, pa, pdLast);
            else
                andCodes = PAClipCheckFrustum2D(gc, pa, pdLast);
        }
#ifdef POLYARRAY_AND_CLIPCODES
        if (andCodes)
        {
            andCodes = PolyArrayCheckClippedPrimitive(gc, pa, andCodes);
            // add POLYARRAY_REMOVE_PRIMITIVE flag
            paflagsAll |= pa->flags;
        }
        pa->andClipCodes = andCodes;
#endif

// ---------------------------------------------------------
// Process colors and materials if we're not in selection and
// haven't been completely clipped out.
//
// IN:  obj/eye, color (front), normal
// OUT: (normal), color (front and back)

        if (!(pa->flags & POLYARRAY_REMOVE_PRIMITIVE) &&
            !(paNeeds & PANEEDS_CLIP_ONLY))
        {
            if (!(enables & __GL_LIGHTING_ENABLE))
            {
                // Lighting is disabled.
                // Clamp RGBA colors, mask color index values.
                // Only front colors are computed, back colors are not needed.

                if (paNeeds & PANEEDS_SKIP_LIGHTING)
                {
                    // Note that when lighting calculation is skipped,
                    // we still need to fill in the colors field.
                    // Otherwise, the rasterization routines may get FP
                    // exceptions on invalid colors.

                    pa->flags |= POLYARRAY_SAME_COLOR_DATA;
                    (*gc->procs.paCalcColorSkip)(gc, pa, __GL_FRONTFACE);
                }
                else if (pa->flags & POLYARRAY_SAME_COLOR_DATA)
                {
                    if (gc->modes.colorIndexMode)
                        PolyArrayPropagateSameIndex(gc, pa);
                    else
                        PolyArrayPropagateSameColor(gc, pa);
                }
                else if (gc->modes.colorIndexMode)
                {
                    PolyArrayPropagateIndex(gc, pa);
                }
                else
                {
                    PolyArrayPropagateColor(gc, pa);
                }
            }
            else
            {
            // It is time to transform and normalize normals if nesessary
                if (bXformLightToNorm)
                {
                    if(enables & __GL_NORMALIZE_ENABLE)
                    {
                        __glNormalizeBatch(pa);
                    }
                }
                else
                {
                    if (paNeeds & PANEEDS_NORMAL)
                    {
                        if (!(enables & __GL_NORMALIZE_ENABLE))
                            (*mInv->xfNormBatch)(pa, mInv);
                        else
                            (*mInv->xfNormBatchN)(pa, mInv);
                    }
                }
#ifdef GL_WIN_phong_shading
                // if phong-shading, then do this at rendering time
                // else do it here
                if (!(gc->state.light.shadingModel == GL_PHONG_WIN)
                    || (pa->primType <= GL_POINTS))
#endif //GL_WIN_phong_shading
                {

                    // Lighting is enabled.

                    POLYDATA  *pd1, *pd2, *pdN;
                    GLint     face;
                    GLuint    matMask;
                    GLboolean doFrontColor, doBackColor, doColor;

                    // Clear POLYARRAY_SAME_COLOR_DATA flag if lighting is
                    // enabled.

                    pa->flags &= ~POLYARRAY_SAME_COLOR_DATA;

                    pdN = pa->pdNextVertex;

                    // Needs only front color for points and lines.

                    // ASSERT_PRIMITIVE
                    if ((unsigned int) pa->primType <= GL_LINE_STRIP)
                    {
                        doFrontColor = GL_TRUE;
                        doBackColor  = GL_FALSE;
                    }
                    else
                    {
                        doFrontColor = paNeeds & PANEEDS_FRONT_COLOR;
                        doBackColor  = paNeeds & PANEEDS_BACK_COLOR;
                    }

                    // Process front and back colors in two passes.
                    // Do back colors first!
                    //!!! We can potentially optimize 2-sided lighting in the
                    // slow path by running through all vertices and look for
                    // color needs for each vertex!
                    // See RenderSmoothTriangle.

                    PERF_CHECK
                      (
                       !(doFrontColor && doBackColor),
                       "Two-sided lighting - need both colors!\n"
                       );

                    // ASSERT_FACE
                    // ASSERT_MATERIAL
                    for (face = 1,
                           matMask = POLYARRAY_MATERIAL_BACK,
                           doColor = doBackColor;
                         face >= 0;
                         face--,
                           matMask = POLYARRAY_MATERIAL_FRONT,
                           doColor = doFrontColor
                         )
                    {
                        POLYMATERIAL  *pm;

                        if (!doColor)
                            continue;

                        // If color is not needed, fill in the colors field
                        // with default.

                        if (paNeeds & PANEEDS_SKIP_LIGHTING)
                        {
                            (*gc->procs.paCalcColorSkip)(gc, pa, face);
                            continue;
                        }

                        // Process color ranges that include no material
                        // changes (excluding color material) one at a time.
                        // Color material changes are handled in the color
                        // procs.

                        if (!(pa->flags & matMask))
                        {
                            // process the whole color array
                            (*gc->procs.paCalcColor)(gc, face, pa, pa->pd0,
                                                     pdN - 1);
                            continue;
                        }

                        // There are material changes, we need to recompute
                        // material and light source machine values before
                        // processing the next color range.
                        // Each range below is given by [pd1, pd2-1].
                        //!!! it is possible to fix polyarraycalcrgbcolor to
                        // accept certain material!

                        pm = GLTEB_CLTPOLYMATERIAL();

                        // no need to do this material later
                        pa->flags &= ~matMask;

                        for (pd1 = pa->pd0; pd1 <= pdN; pd1 = pd2)
                        {
                            POLYDATA *pdColor, *pdNormal;

                            // Apply material changes to the current vertex.
                            // It also applies trailing material changes
                            // following the last vertex.
                            if (pd1->flags & matMask)
                                PAApplyMaterial(gc,
                                        *(&pm->pdMaterial0[pd1 -
                                         pa->pdBuffer0].front + face), face);

                            // If this is the trailing material change, we are
                            // done.
                            if (pd1 == pdN)
                                break;

                            // Find next vertex with material changes. We
                            // need to track current color and normal so that
                            // the next color range begins with valid color
                            // and normal. We cannot track current values on
                            // client side because we don't have initial
                            // current values when batching this function.

                            pdColor  = pd1;
                            pdNormal = pd1;
                            for (pd2 = pd1 + 1; pd2 < pdN; pd2++)
                            {
                                // track current color
                                if (pd2->flags & POLYDATA_COLOR_VALID)
                                    pdColor = pd2;

                                // track current normal
                                if (pd2->flags & POLYDATA_NORMAL_VALID)
                                    pdNormal = pd2;

                                if (pd2->flags & matMask)
                                    break;
                            }

                            // Update next vertex's current color and normal
                            // if not given. The paCalcColor proc assumes that
                            // the first vertex contains a valid current color
                            // and normal.  We need to save the current values
                            // before they are modified by the color procs.

                            if (!(pd2->flags & POLYDATA_COLOR_VALID))
                            {
                                pd2->flags |= POLYDATA_COLOR_VALID;
                                pd2->colors[0] = pdColor->colors[0];
                            }

                            if (!(pd2->flags & POLYDATA_NORMAL_VALID))
                            {
                                pd2->flags |= POLYDATA_NORMAL_VALID;
                                pd2->normal.x = pdNormal->normal.x;
                                pd2->normal.y = pdNormal->normal.y;
                                pd2->normal.z = pdNormal->normal.z;
                            }

                            // Compute the colos range [pd1, pd2-1] that
                            // contains no material changes.
                            (*gc->procs.paCalcColor)(gc, face, pa, pd1, pd2-1);
                        }
                    } // for (faces)

                } // Not phong-shading
#ifdef GL_WIN_phong_shading
                else
                {
                    PolyArrayPhongPropagateColorNormal(gc, pa);
                }
#endif //GL_WIN_phong_shading
            } // lighting enabled
        }

        // Update material.
        if ((pa->flags & (POLYARRAY_MATERIAL_FRONT |
                         POLYARRAY_MATERIAL_BACK))
#ifdef GL_WIN_phong_shading
            && ((gc->state.light.shadingModel != GL_PHONG_WIN)
                || (pa->primType <= GL_POINTS))
#endif //GL_WIN_phong_shading
            )
            PolyArrayApplyMaterials(gc, pa);
    } // end of transform, color, and lighting calculations.

// ---------------------------------------------------------
// This is the end of the main pipeline loop.  At this point,
// we need to take care of selection, removal of rejected
// primitives, cheap fog, and edge-flag processing.
// ---------------------------------------------------------


    // In selection, we need only clip and window (and possibly eye values
    // computed above.)  At this point, we have already applied materials as
    // well. But we still need to apply materials and colors.

    if (paNeeds & PANEEDS_CLIP_ONLY)
        goto drawpolyarray_render_primitives;

    // If any of the andClipCodes is nonzero, we may be able to throw away
    // some primitives.

#ifdef POLYARRAY_AND_CLIPCODES
    if (paflagsAll & POLYARRAY_REMOVE_PRIMITIVE)
    {
        pa0 = PolyArrayRemoveClippedPrimitives(pa0);
        if (!pa0)
            goto drawpolyarray_apply_color;
    }
#endif


// ---------------------------------------------------------
// Process cheap fog.
//
// IN:  obj/eye, color
// OUT: eye, fog, color

    // if this is changed, need to fix RasterPos's setup!
    if ((gc->renderMode == GL_RENDER)
        && (enables & __GL_FOG_ENABLE)
        && (gc->polygon.shader.modeFlags & (__GL_SHADE_INTERP_FOG |
                                            __GL_SHADE_CHEAP_FOG)))
    {
        for (pa = pa0; pa; pa = pa->paNext)
        {
            // Note: the eye coordinate has already been computed.

            // compute fog values
            PolyArrayComputeFog(gc, pa);

            if (gc->polygon.shader.modeFlags & __GL_SHADE_CHEAP_FOG)
            {
#ifdef GL_WIN_specular_fog
              ASSERTOPENGL (!(gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG), "Cheap fog cannot be done if Specular fog is needed\n");
#endif //GL_WIN_specular_fog


                // Apply fog if it is smooth shading and in render mode.
                // In flat/phong shading, cheap fogging is currently done at
                // render procs we can probably do cheap fog in flat shading
                // here but we will need to compute the provoking colors with
                // z info correctly so we can interpolate in the clipping
                // procs.  It would require rewriting the clipping routines
                // in so_clip.c too!
                if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH_LIGHT)
                    (*gc->procs.paApplyCheapFog)(gc, pa);
            }
            else
            {
                PERF_CHECK(FALSE, "Uses slow fog\n");
            }
        }
    }

// ---------------------------------------------------------
// Process edge flags.
//
// IN:  edge
// OUT: edge (all vertices)

    if (paNeeds & PANEEDS_EDGEFLAG)
    {
        for (pa = pa0; pa; pa = pa->paNext)
        {
            if (pa->primType == GL_TRIANGLES
                || pa->primType == GL_QUADS
                || pa->primType == GL_POLYGON)
            {
                // If all incoming vertices have valid edgeflags, we are done.
                // When all polydata's are of the same type, there are 2 cases
                // where edge flag processing can be skipped:
                //   1. All edge flags were given.
                //   2. No edge flag was given and the initial edge flag (i.e.
                //      current gc edge flag) is non boundary.  In this case,
                //      all edge flags were set to non boundary in pd->flags
                //      initialization.
              if ((pa->flags & POLYARRAY_SAME_POLYDATA_TYPE)
                  && (((pa->pdCurEdgeFlag != pa->pd0) &&
                       // Need to test 2nd vertex because pdCurEdgeFlag may
                       // have been advanced as a result of combining EdgeFlag
                       // command after End
                       ((pa->pd0 + 1)->flags & POLYDATA_EDGEFLAG_VALID))
                      || !(pa->pd0->flags & POLYDATA_EDGEFLAG_BOUNDARY)))
                ;
              else
                  PolyArrayProcessEdgeFlag(pa);
#ifdef NEW_PARTIAL_PRIM
              // For partial begin polygon we have to clear edge flag for first vertex.
              // For partial end polygon we have to clear edge flag for last vertex.
              //
              if (pa->primType == GL_POLYGON)
              {
                    if (pa->flags & POLYARRAY_PARTIAL_END)
                        (pa->pdNextVertex-1)->flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;
                    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
                        pa->pd0->flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;
              }
#endif // NEW_PARTIAL_PRIM
            }
        }
    }

// ---------------------------------------------------------
// Process the primitives.

drawpolyarray_render_primitives:

    // Skip the rest if this is a RasterPos
    if (bIsRasterPos)
        goto drawpolyarray_exit;

#ifndef NEW_PARTIAL_PRIM
    for (pa = pa0; pa; pa = pa->paNext)
    {
        ASSERTOPENGL(pa->primType >= GL_POINTS && pa->primType <= GL_POLYGON,
                     "DrawPolyArray: bad primitive type\n");

        (*afnPolyArrayDraw[pa->primType])(gc, pa);
    }
#endif // NEW_PARTIAL_PRIM
// ---------------------------------------------------------
// Update final light source machine.
// The user color was initialized above.

#ifndef GL_WIN_phong_shading
drawpolyarray_apply_color:
    (*gc->procs.applyColor)(gc);
#endif //GL_WIN_phong_shading

// ---------------------------------------------------------
// Flush the primitive chain.

    // To draw primitives, we can let the FPU run in chop (truncation) mode
    // since we have enough precision left to convert to pixel units.

    FPU_CHOP_ON_PREC_LOW();

#if 1
    if (pa0)
        glsrvFlushDrawPolyArray(pa0, bMcdProcessDone);
#endif

drawpolyarray_exit:
    // Out of begin mode.
#ifdef GL_WIN_phong_shading
drawpolyarray_apply_color:
        (*gc->procs.applyColor)(gc);
#endif //GL_WIN_phong_shading
// Out of begin mode.

    FPU_RESTORE_MODE_NO_EXCEPTIONS();

    ASSERTOPENGL(gc->beginMode == __GL_IN_BEGIN, "bad beginMode!");
    gc->beginMode = __GL_NOT_IN_BEGIN;
//
// If we were using object-space lighting, restore the original lighting values:
//

    if (bXformLightToNorm) {
        __GLlightSourceMachine *lsm;

        for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
            lsm->hHat = lsm->tmpHHat;
            lsm->unitVPpli = lsm->tmpUnitVPpli;
        }
    }

    return;
}


#ifdef POLYARRAY_AND_CLIPCODES
// Determine if a clipped primitive can be removed early.
// If the logical AND of vertex clip codes of a primitive is non-zero,
// the primitive is completely clipped and can be removed early.
// However, if a primitive is partially built, we may not be able to
// remove it yet to maintain connectivity between the partial primitives.
// By eliminating a primitive early, we save on lighting and other calculations.
//
// Set POLYARRAY_REMOVE_PRIMITIVE flag if the primitve can be removed early.
// Return new andCodes.

GLuint FASTCALL PolyArrayCheckClippedPrimitive(__GLcontext *gc, POLYARRAY *pa, GLuint andCodes)
{
    ASSERTOPENGL(andCodes, "bad andCodes\n");

    // Don't eliminate RasterPos

    if (pa->flags & POLYARRAY_RASTERPOS)
        return andCodes;

#ifndef NEW_PARTIAL_PRIM

    // If this is a partial begin, include previous clipcode.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        switch (pa->primType)
        {
          case GL_LINE_LOOP:
            // previous vertex
            andCodes &= gc->vertex.pdSaved[0].clipCode;
            // loop vertex
            if (!(pa->flags & POLYARRAY_PARTIAL_END))
                andCodes &= gc->vertex.pdSaved[1].clipCode;
            break;

          case GL_POLYGON:
            andCodes &= gc->vertex.pdSaved[2].clipCode;
            // fall through
          case GL_TRIANGLE_FAN:
          case GL_TRIANGLE_STRIP:
          case GL_QUAD_STRIP:
            andCodes &= gc->vertex.pdSaved[1].clipCode;
            // fall through
          case GL_LINE_STRIP:
            andCodes &= gc->vertex.pdSaved[0].clipCode;
            break;

          case GL_POINTS:
          case GL_LINES:
          case GL_TRIANGLES:
          case GL_QUADS:
          default:
            break;
        }
    }
    if (andCodes
      &&
        (
            !(pa->flags & POLYARRAY_PARTIAL_END) ||
            pa->primType == GL_POINTS    ||
            pa->primType == GL_LINES     ||
            pa->primType == GL_TRIANGLES ||
            pa->primType == GL_QUADS
        )
       )
        pa->flags |= POLYARRAY_REMOVE_PRIMITIVE;
#else
    //
    // If we have partial end primitive we cannot remove line strip, line loop or
    // polygon to preserve stipple pattern. Line loop was converted to line strip.
    //
    if (andCodes &&
        !(pa->flags & POLYARRAY_PARTIAL_END &&
         (pa->primType == GL_LINE_STRIP || pa->primType == GL_POLYGON)))
        pa->flags |= POLYARRAY_REMOVE_PRIMITIVE;
#endif // NEW_PARTIAL_PRIM

    // return new andCodes.

    return andCodes;
}

// Remove completely clipped primitives from the polyarray chain.
POLYARRAY * FASTCALL PolyArrayRemoveClippedPrimitives(POLYARRAY *pa0)
{
    POLYARRAY *pa, *paNext, *pa2First, *pa2Last;

    // Eliminate the trivially clipped primitives and build a new pa chain.

    pa2First = pa2Last = NULL;

    for (pa = pa0; pa; pa = paNext)
    {
        // get next pa first
        paNext = pa->paNext;

        if (pa->flags & POLYARRAY_REMOVE_PRIMITIVE)
        {
            PolyArrayRestoreColorPointer(pa);
        }
        else
        {
            // add to the new pa chain

            if (!pa2First)
                pa2First = pa;
            else
                pa2Last->paNext = pa;
            pa2Last = pa;
            pa2Last->paNext = NULL;
        }
    }

    // Return the new pa chain.

    return pa2First;
}
#endif // POLYARRAY_AND_CLIPCODES

/******************************Public*Routine******************************\
*
* RestoreAfterMcd
*
* Handles final bookkeeping necessary after the MCD has processed
* some or all of a batch.
*
* History:
*  Thu Mar 20 12:04:49 1997     -by-    Drew Bliss [drewb]
*   Split from glsrvFlushDrawPolyArray.
*
\**************************************************************************/

void RestoreAfterMcd(__GLGENcontext *gengc,
                     POLYARRAY *paBegin, POLYARRAY *paEnd)
{
    POLYARRAY *pa, *paNext;

    // Restore color pointer in the vertex buffer (for the POLYARRAYs
    // that have been processed by MCD; leave the unprocessed ones
    // alone).
    //
    // If the driver is using DMA, it must do the reset.  If not DMA,
    // we will do it for the driver.

    if (!(McdDriverInfo.mcdDriverInfo.drvMemFlags & MCDRV_MEM_DMA))
    {
        for (pa = paBegin; pa != paEnd; pa = paNext)
        {
            paNext = pa->paNext;
            PolyArrayRestoreColorPointer(pa);
        }
    }
    else
    {
        // With DMA, the driver must either process the entire batch
        // or reject the entire batch.
        //
        // Therefore, if the MCD call returns success (paEnd == NULL),
        // the POLYARRAY is being sent via DMA to the driver and we
        // need to switch to the other buffer.  Otherwise, we need to
        // drop down into the software implementation.

        if (!paEnd)
        {
            GenMcdSwapBatch(gengc);
        }
    }
}

/******************************Public*Routine******************************\
*
* RescaleVertexColorsToBuffer
*
* Scales vertex colors from vertex (MCD) color range to buffer color
* range for software simulations.
*
* History:
*  Thu Mar 20 16:21:16 1997     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void RescaleVertexColorsToBuffer(__GLcontext *gc, POLYARRAY *pa)
{
    int idx;
    POLYDATA *pd, *pdLast;

    idx = 0;
    if (pa->primType <= GL_LINE_STRIP)
    {
        idx |= 1;
    }
    else
    {
        if (gc->vertex.paNeeds & PANEEDS_FRONT_COLOR)
        {
            idx |= 1;
        }
        if (gc->vertex.paNeeds & PANEEDS_BACK_COLOR)
        {
            idx |= 2;
        }
    }

    pdLast = pa->pdNextVertex-1;

    switch(idx)
    {
    case 1:
        // Front color only.

        if (gc->modes.colorIndexMode)
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[0].r *= gc->redVertexToBufferScale;
            }
        }
        else
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[0].r *= gc->redVertexToBufferScale;
                pd->colors[0].g *= gc->greenVertexToBufferScale;
                pd->colors[0].b *= gc->blueVertexToBufferScale;
                pd->colors[0].a *= gc->alphaVertexToBufferScale;
            }
        }
        break;

    case 2:
        // Back color only.

        if (gc->modes.colorIndexMode)
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[1].r *= gc->redVertexToBufferScale;
            }
        }
        else
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[1].r *= gc->redVertexToBufferScale;
                pd->colors[1].g *= gc->greenVertexToBufferScale;
                pd->colors[1].b *= gc->blueVertexToBufferScale;
                pd->colors[1].a *= gc->alphaVertexToBufferScale;
            }
        }
        break;

    case 3:
        // Front and back colors.

        if (gc->modes.colorIndexMode)
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[0].r *= gc->redVertexToBufferScale;
                pd->colors[1].r *= gc->redVertexToBufferScale;
            }
        }
        else
        {
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                pd->colors[0].r *= gc->redVertexToBufferScale;
                pd->colors[0].g *= gc->greenVertexToBufferScale;
                pd->colors[0].b *= gc->blueVertexToBufferScale;
                pd->colors[0].a *= gc->alphaVertexToBufferScale;
                pd->colors[1].r *= gc->redVertexToBufferScale;
                pd->colors[1].g *= gc->greenVertexToBufferScale;
                pd->colors[1].b *= gc->blueVertexToBufferScale;
                pd->colors[1].a *= gc->alphaVertexToBufferScale;
            }
        }
    }
}

/******************************Public*Routine******************************\
* glsrvFlushDrawPolyArray
*
* The dispatch code in glsrvAttention links together the POLYARRAY data
* structures of consecutive glim_DrawPolyArray calls.  The front end
* preprocessing of the vertices in each POLYARRAY is executed immediately
* in glim_DrawPolyArray (i.e., PolyArrayDrawXXX), but the actually back end
* rendering (PolyArrayRenderXXX) is delayed until the chain is broken (either
* by a non-DrawPolyArray call, the end of the batch, or a batch timeout).
*
* glsrvFlushDrawPolyArray is the function that is called to flush the
* chained POLYARRAYs by invoking the back end rendering code.  The back end
* may be the generic software-only implementation or the MCD driver.
*
* History:
*  12-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

// Poly array render routines.
// ASSERT_PRIMITIVE
PFN_POLYARRAYRENDER afnPolyArrayRender[] =
{
    (PFN_POLYARRAYRENDER) PolyArrayRenderPoints,
    (PFN_POLYARRAYRENDER) PolyArrayRenderLines,
    (PFN_POLYARRAYRENDER) NULL,         // line loop not required
    (PFN_POLYARRAYRENDER) PolyArrayRenderLStrip,
    (PFN_POLYARRAYRENDER) PolyArrayRenderTriangles,
    (PFN_POLYARRAYRENDER) PolyArrayRenderTStrip,
    (PFN_POLYARRAYRENDER) PolyArrayRenderTFan,
    (PFN_POLYARRAYRENDER) PolyArrayRenderQuads,
    (PFN_POLYARRAYRENDER) PolyArrayRenderQStrip,
    (PFN_POLYARRAYRENDER) PolyArrayRenderPolygon,
};

void APIPRIVATE glsrvFlushDrawPolyArray(POLYARRAY *paBegin,
                                        BOOL bMcdProcessDone)
{
    POLYARRAY *pa, *paNext;
    __GLGENcontext *gengc;
    BOOL bResetViewportAdj = FALSE;
    __GL_SETUP();

//#define FRONT_END_ONLY 1

#if FRONT_END_ONLY

    if (paBegin)
    {
        for (pa = paNext = paBegin; pa = paNext; )
        {
            ASSERTOPENGL(pa->primType >= GL_POINTS &&
                         pa->primType <= GL_POLYGON,
                         "DrawPolyArray: bad primitive type\n");

            // Get next pointer first!
            paNext = pa->paNext;
            // Restore color pointer in the vertex buffer!
            PolyArrayRestoreColorPointer(pa);
        }
    }

    return;
#endif

    gengc = (__GLGENcontext *) gc;

#ifdef _MCD_
#if DBG
    if (gengc->pMcdState && !(glDebugFlags & GLDEBUG_DISABLEPRIM) &&
        (gc->renderMode == GL_RENDER))
#else
    if ((gengc->pMcdState) && (gc->renderMode == GL_RENDER))
#endif
    {
        POLYARRAY *paEnd;

        // If no commands were processed via MCD front-end support
        // then try the rasterization support.
        if (!bMcdProcessDone)
        {
            // Let the MCD driver have first crack.  If the MCD processes
            // the entire batch, then it will return NULL.  Otherwise, it
            // will return a pointer to a chain of unprocessed POLYARRAYs.
            paEnd = GenMcdDrawPrim(gengc, paBegin);
            RestoreAfterMcd(gengc, paBegin, paEnd);
        }
        else
        {
            // MCD has already kicked back so nothing is consumed.
            paEnd = paBegin;
        }

        // Prepare to use generic to provide simulations for the
        // unhandled POLYARRAYs, if any.

        paBegin = paEnd;
        if (paBegin)
        {
            // Check if generic simulations can be used.  If not, we must
            // abandon the rest of the batch.

            if (!(gengc->flags & GENGC_GENERIC_COMPATIBLE_FORMAT) ||
                (gengc->gc.texture.ddtex.levels > 0 &&
                 (gengc->gc.texture.ddtex.flags & DDTEX_GENERIC_FORMAT) == 0))
            {
                goto PA_abandonBatch;
            }

            // If we need to kickback to simulations, now is the time to
            // grab the device lock.  If the lock fails, abandon the rest
            // of the batch.

            {
                __GLbeginMode beginMode = gengc->gc.beginMode;

                // Why save/restore beginMode?
                //
                // The glim_DrawPolyArray function plays with the beginMode
                // value.  However, in delayed locking the MCD state is
                // validated, but the generic state is not properly validated
                // if the lock is not held.  So we need to also play with
                // the beginMode so that the validation code can be called.

                gengc->gc.beginMode = __GL_NOT_IN_BEGIN;

                if (!glsrvLazyGrabSurfaces(gengc, gengc->fsGenLocks))
                {
                    gengc->gc.beginMode = beginMode;
                    goto PA_abandonBatch;
                }

                gengc->gc.beginMode = beginMode;
            }

            // We may need to temporarily reset the viewport adjust values
            // before calling simulations.  If GenMcdResetViewportAdj returns
            // TRUE, the viewport is changed and we need restore later with
            // VP_NOBIAS.

            bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
        }
    }

    if (paBegin)
#endif
    {
        for (pa = paNext = paBegin; pa = paNext; )
        {
            ASSERTOPENGL(/* pa->primType >= GL_POINTS &&  <always true since primType is unsigned> */
                         pa->primType <= GL_POLYGON,
                         "DrawPolyArray: bad primitive type\n");

#ifndef NEW_PARTIAL_PRIM
            if (pa->flags & POLYARRAY_RENDER_PRIMITIVE)
#endif // NEW_PARTIAL_PRIM
            {
                // Rescale colors if necessary.
                if (!gc->vertexToBufferIdentity)
                {
                    RescaleVertexColorsToBuffer(gc, pa);
                }

#ifdef GL_WIN_phong_shading
                if (pa->flags & POLYARRAY_PHONG_DATA_VALID)
                {
                    if (pa->phong->flags & __GL_PHONG_FRONT_FIRST_VALID)
                        PAApplyMaterial(gc,
                                        &(pa->phong->matChange[__GL_PHONG_FRONT_FIRST]),
                                        0);
                    if (pa->phong->flags & __GL_PHONG_BACK_FIRST_VALID)
                        PAApplyMaterial(gc,
                                        &(pa->phong->matChange[__GL_PHONG_BACK_FIRST]),
                                        1);
                }

                (*afnPolyArrayRender[pa->primType])(gc, pa);

                if (pa->flags & POLYARRAY_PHONG_DATA_VALID)
                {
                    if (pa->phong->flags & __GL_PHONG_FRONT_TRAIL_VALID)
                        PAApplyMaterial(gc,
                                        &(pa->phong->matChange[__GL_PHONG_FRONT_TRAIL]),
                                        0);
                    if (pa->phong->flags & __GL_PHONG_BACK_TRAIL_VALID)
                        PAApplyMaterial(gc,
                                        &(pa->phong->matChange[__GL_PHONG_BACK_TRAIL]),
                                        1);
                    //Free the pa->phong data-structure
                    GCFREE(gc, pa->phong);
                }
#else
                (*afnPolyArrayRender[pa->primType])(gc, pa);
#endif //GL_WIN_phong_shading
            }

            // Get next pointer first!
            paNext = pa->paNext;
            // Restore color pointer in the vertex buffer!
            PolyArrayRestoreColorPointer(pa);
        }

        // Restore viewport values if needed.
        if (bResetViewportAdj)
        {
            GenMcdResetViewportAdj(gc, VP_NOBIAS);
        }
    }

    return;

PA_abandonBatch:

    if (paBegin)
    {
    // Abandoning the remainder of the batch.  Must reset the color
    // pointers in the remainder of the batch.
    //
    // Note that paBegin must point to the beginning of the chain of
    // unprocessed POLYARRAYs.

        for (pa = paBegin; pa; pa = paNext)
        {
            paNext = pa->paNext;
            PolyArrayRestoreColorPointer(pa);
        }
        __glSetError(GL_OUT_OF_MEMORY);
    }
}

/****************************************************************************/
// Restore color pointer in the vertex buffer!
// However, don't restore the color pointer if it is a RasterPos call.
GLvoid FASTCALL PolyArrayRestoreColorPointer(POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;

    ASSERTOPENGL(!(pa->flags & POLYARRAY_RASTERPOS),
                 "RasterPos unexpected\n");

    // See also glsbResetBuffers.

    // Reset color pointer in output index array
    if (pa->aIndices)
    {
        ASSERTOPENGL((POLYDATA *) pa->aIndices >= pa->pdBuffer0 &&
                     (POLYDATA *) pa->aIndices <= pa->pdBufferMax,
                     "bad index map pointer\n");

        pdLast = (POLYDATA *) (pa->aIndices + pa->nIndices);
        for (pd = (POLYDATA *) pa->aIndices; pd < pdLast; pd++)
            pd->color = &pd->colors[__GL_FRONTFACE];

        ASSERTOPENGL(pd >= pa->pdBuffer0 &&
                     pd <= pa->pdBufferMax + 1,
                     "bad polyarray pointer\n");
    }

    // Reset color pointer in the POLYARRAY structure last!
    ASSERTOPENGL((POLYDATA *) pa >= pa->pdBuffer0 &&
                 (POLYDATA *) pa <= pa->pdBufferMax,
                 "bad polyarray pointer\n");
    ((POLYDATA *) pa)->color = &((POLYDATA *) pa)->colors[__GL_FRONTFACE];
}
/****************************************************************************/
// Compute generic fog value for the poly array.
//
// IN:  eye
// OUT: fog
#ifdef GL_WIN_specular_fog
void FASTCALL PolyArrayComputeFog(__GLcontext *gc, POLYARRAY *pa)
{
    __GLfloat density, density2neg, end, oneOverEMinusS;
    POLYDATA  *pd, *pdLast;
    __GLfloat fog;
    BOOL bNeedModulate = (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG);

    ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, "need eye\n");

    pdLast = pa->pdNextVertex-1;
    switch (gc->state.fog.mode)
    {
    case GL_EXP:
        PERF_CHECK(FALSE, "Uses GL_EXP fog\n");
        density = gc->state.fog.density;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;    // used by clipping code!
            eyeZ = pd->eye.z;
            if (__GL_FLOAT_LTZ(eyeZ))
                fog = __GL_POWF(__glE,  density * eyeZ);
            else
                fog = __GL_POWF(__glE, -density * eyeZ);

            // clamp the fog value to [0.0,1.0]
            if (fog > __glOne)
                fog = __glOne;

            if (bNeedModulate)
                pd->fog *= fog;
            else
                pd->fog = fog;
        }
        break;
    case GL_EXP2:
        PERF_CHECK(FALSE, "Uses GL_EXP2 fog\n");
        density2neg = gc->state.fog.density2neg;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;
            eyeZ = pd->eye.z;
            fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);

            // clamp the fog value to [0.0,1.0]
            if (fog > __glOne)
                fog = __glOne;

            if (bNeedModulate)
                pd->fog *= fog;
            else
                pd->fog = fog;
        }
        break;
    case GL_LINEAR:
        end = gc->state.fog.end;
        oneOverEMinusS = gc->state.fog.oneOverEMinusS;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;
            eyeZ = pd->eye.z;
            if (__GL_FLOAT_LTZ(eyeZ))
                fog = (end + eyeZ) * oneOverEMinusS;
            else
                fog = (end - eyeZ) * oneOverEMinusS;

            // clamp the fog value here
            if (__GL_FLOAT_LTZ(pd->fog))
                fog = __glZero;
            else if (__GL_FLOAT_COMPARE_PONE(pd->fog, >))
                fog = __glOne;

            if (bNeedModulate)
                pd->fog *= fog;
            else
                pd->fog = fog;
        }
        break;
    }
}

#else //GL_WIN_specular_fog

void FASTCALL PolyArrayComputeFog(__GLcontext *gc, POLYARRAY *pa)
{
    __GLfloat density, density2neg, end, oneOverEMinusS;
    POLYDATA  *pd, *pdLast;

    ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, "need eye\n");

    pdLast = pa->pdNextVertex-1;
    switch (gc->state.fog.mode)
    {
    case GL_EXP:
        PERF_CHECK(FALSE, "Uses GL_EXP fog\n");
        density = gc->state.fog.density;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;    // used by clipping code!
            eyeZ = pd->eye.z;
            if (__GL_FLOAT_LTZ(eyeZ))
                pd->fog = __GL_POWF(__glE,  density * eyeZ);
            else
                pd->fog = __GL_POWF(__glE, -density * eyeZ);

            // clamp the fog value to [0.0,1.0]
            if (pd->fog > __glOne)
                pd->fog = __glOne;
        }
        break;
    case GL_EXP2:
        PERF_CHECK(FALSE, "Uses GL_EXP2 fog\n");
        density2neg = gc->state.fog.density2neg;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;
            eyeZ = pd->eye.z;
            pd->fog = __GL_POWF(__glE, density2neg * eyeZ * eyeZ);

            // clamp the fog value to [0.0,1.0]
            if (pd->fog > __glOne)
                pd->fog = __glOne;
        }
        break;
    case GL_LINEAR:
        end = gc->state.fog.end;
        oneOverEMinusS = gc->state.fog.oneOverEMinusS;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat eyeZ;

            pd->flags |= POLYDATA_FOG_VALID;
            eyeZ = pd->eye.z;
            if (__GL_FLOAT_LTZ(eyeZ))
                pd->fog = (end + eyeZ) * oneOverEMinusS;
            else
                pd->fog = (end - eyeZ) * oneOverEMinusS;

            // clamp the fog value here
            if (__GL_FLOAT_LTZ(pd->fog))
                pd->fog = __glZero;
            else if (__GL_FLOAT_COMPARE_PONE(pd->fog, >))
                pd->fog = __glOne;
        }
        break;
    }
}
#endif //GL_WIN_specular_fog

// Apply cheap fog to RGB colors.
//
// IN:  fog, color (front/back)
// OUT: color (front/back)

void FASTCALL PolyArrayCheapFogRGBColor(__GLcontext *gc, POLYARRAY *pa)
{
    __GLfloat fogColorR, fogColorG, fogColorB;
    POLYDATA  *pd, *pdLast;
    GLboolean bGrayFog;
    GLboolean doFrontColor, doBackColor;

    if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE))
    {
        ASSERTOPENGL(!(gc->vertex.paNeeds & PANEEDS_BACK_COLOR),
                     "no back color needed when lighting is disabled\n");
    }

    // ASSERT_PRIMITIVE
    if ((unsigned int) pa->primType <= GL_LINE_STRIP)
    {
        doFrontColor = GL_TRUE;
        doBackColor  = GL_FALSE;
    }
    else
    {
        doFrontColor = gc->vertex.paNeeds & PANEEDS_FRONT_COLOR;
        doBackColor  = gc->vertex.paNeeds & PANEEDS_BACK_COLOR;
    }

    pdLast = pa->pdNextVertex-1;
    fogColorR = gc->state.fog.color.r;
    fogColorG = gc->state.fog.color.g;
    fogColorB = gc->state.fog.color.b;
    bGrayFog  = (gc->state.fog.flags & __GL_FOG_GRAY_RGB) ? GL_TRUE : GL_FALSE;

    PERF_CHECK(bGrayFog, "Uses non gray fog color\n");

    if (bGrayFog)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat fog, oneMinusFog, delta;

            /* Get the vertex fog value */
            fog = pd->fog;
            oneMinusFog = __glOne - fog;
            delta = oneMinusFog * fogColorR;

            /* Now whack the color */
            if (doFrontColor)
            {
                pd->colors[0].r = fog * pd->colors[0].r + delta;
                pd->colors[0].g = fog * pd->colors[0].g + delta;
                pd->colors[0].b = fog * pd->colors[0].b + delta;
            }
            if (doBackColor)
            {
                pd->colors[1].r = fog * pd->colors[1].r + delta;
                pd->colors[1].g = fog * pd->colors[1].g + delta;
                pd->colors[1].b = fog * pd->colors[1].b + delta;
            }
        }
    }
    else
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            __GLfloat fog, oneMinusFog;

            /* Get the vertex fog value */
            fog = pd->fog;
            oneMinusFog = __glOne - fog;

            /* Now whack the color */
            if (doFrontColor)
            {
                pd->colors[0].r = fog * pd->colors[0].r + oneMinusFog * fogColorR;
                pd->colors[0].g = fog * pd->colors[0].g + oneMinusFog * fogColorG;
                pd->colors[0].b = fog * pd->colors[0].b + oneMinusFog * fogColorB;
            }
            if (doBackColor)
            {
                pd->colors[1].r = fog * pd->colors[1].r + oneMinusFog * fogColorR;
                pd->colors[1].g = fog * pd->colors[1].g + oneMinusFog * fogColorG;
                pd->colors[1].b = fog * pd->colors[1].b + oneMinusFog * fogColorB;
            }
        }
    }
}


// Apply cheap fog to color index values.
//
// IN:  fog, color.r (front/back)
// OUT: color.r (front/back)

void FASTCALL PolyArrayCheapFogCIColor(__GLcontext *gc, POLYARRAY *pa)
{
    __GLfloat maxR, fogIndex;
    POLYDATA  *pd, *pdLast;
    GLboolean doFrontColor, doBackColor;

    if (!(gc->state.enables.general & __GL_LIGHTING_ENABLE))
    {
        ASSERTOPENGL(!(gc->vertex.paNeeds & PANEEDS_BACK_COLOR),
                     "no back color needed when lighting is disabled\n");
    }

    // ASSERT_PRIMITIVE
    if ((unsigned int) pa->primType <= GL_LINE_STRIP)
    {
        doFrontColor = GL_TRUE;
        doBackColor  = GL_FALSE;
    }
    else
    {
        doFrontColor = gc->vertex.paNeeds & PANEEDS_FRONT_COLOR;
        doBackColor  = gc->vertex.paNeeds & PANEEDS_BACK_COLOR;
    }

    fogIndex = gc->state.fog.index;
    maxR = (1 << gc->modes.indexBits) - 1;

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        __GLfloat fogDelta;

        fogDelta = (__glOne - pd->fog) * fogIndex;

        /* Now whack the color */
        if (doFrontColor)
        {
            pd->colors[0].r = pd->colors[0].r + fogDelta;
            if (pd->colors[0].r > maxR)
                pd->colors[0].r = maxR;
        }
        if (doBackColor)
        {
            pd->colors[1].r = pd->colors[1].r + fogDelta;
            if (pd->colors[1].r > maxR)
                pd->colors[1].r = maxR;
        }
    }
}

/****************************************************************************/


/****************************************************************************/
// Compute eye coordinates
//
// IN:  obj
// OUT: eye

void FASTCALL PolyArrayProcessEye(__GLcontext *gc, POLYARRAY *pa)
{
    __GLtransform *trMV;
    __GLmatrix    *m;
    POLYDATA      *pd, *pdLast;

    if (pa->flags & POLYARRAY_EYE_PROCESSED)
        return;

    pa->flags |= POLYARRAY_EYE_PROCESSED;

    trMV = gc->transform.modelView;
    m    = &trMV->matrix;
    pdLast = pa->pdNextVertex-1;

// The primitive may contain a mix of vertex types (2,3,4)!

    if (m->matrixType == __GL_MT_IDENTITY)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
                pd->eye = pd->obj;
    }
    else
    {
        PFN_XFORM     pfnXform;

        // If any incoming coords contains w coord, use xf4.
        if (pa->flags & POLYARRAY_VERTEX4)
                pfnXform = m->xf4;
        else if (pa->flags & POLYARRAY_VERTEX3)
                pfnXform = m->xf3;
        else
                pfnXform = m->xf2;

        for (pd = pa->pd0; pd <= pdLast; pd++)
                (*pfnXform)(&pd->eye, (__GLfloat *) &pd->obj, m);
    }
}

/****************************************************************************/
// Process edge flags.
//
// IN:  edge
// OUT: edge (all vertices)

void FASTCALL PolyArrayProcessEdgeFlag(POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;
    GLuint    prevEdgeFlag;

    PERF_CHECK(FALSE, "Uses edge flags!\n");

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_EDGEFLAG_VALID,
        "need initial edgeflag value\n");

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        if (pd->flags & POLYDATA_EDGEFLAG_VALID)
            prevEdgeFlag = pd->flags & (POLYDATA_EDGEFLAG_VALID | POLYDATA_EDGEFLAG_BOUNDARY);
        else
            pd->flags |= prevEdgeFlag;
    }
}

/****************************************************************************/
// transform texture coordinates
// there is no generated texture coords.
// texture coordinates are modified in place
//
// IN:  texture
// OUT: texture (all vertices are updated)

void FASTCALL PolyArrayCalcTexture(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    POLYDATA  *pd, *pdLast;
    PFN_XFORM xf;

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
                 "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
                 "bad paflags\n");

    m = &gc->transform.texture->matrix;

    pdLast = pa->pdNextVertex-1;
    if (m->matrixType == __GL_MT_IDENTITY)
    {
        // Identity texture xform.
        //Incoming texcoord already has all s,t,q,r values.

        for (pd = pa->pd0; pd <= pdLast; pd++)
            if (!(pd->flags & POLYDATA_TEXTURE_VALID))
                pd->texture = (pd-1)->texture;
    }
    else
    {

        // If any incoming texture coords contains q coord, use xf4.
        if (pa->flags & POLYARRAY_TEXTURE4)
            xf = m->xf4;
        else if (pa->flags & POLYARRAY_TEXTURE3)
            xf = m->xf3;
        else if (pa->flags & POLYARRAY_TEXTURE2)
            xf = m->xf2;
        else
            xf = m->xf1;

        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            // Apply texture matrix
            if (pd->flags & POLYDATA_TEXTURE_VALID)
                (*xf)(&pd->texture, (__GLfloat *) &pd->texture, m);
            else
                pd->texture = (pd-1)->texture;
        }
    }
}

// Generate texture coordinates from object coordinates
// object linear texture generation
// s and t are enabled but r and q are disabled
// both s and t use the object linear mode
// both s and t have the SAME plane equation
// texture coordinates are modified in place
//
// IN:  texture, obj
// OUT: texture (all vertices are updated)

void FASTCALL PolyArrayCalcObjectLinearSameST(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    __GLcoord *cs, gen;
    POLYDATA  *pd, *pdLast;
    PFN_XFORM xf;

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
        "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
        "bad paflags\n");

    cs = &gc->state.texture.s.objectPlaneEquation;
    pdLast = pa->pdNextVertex-1;
    m = &gc->transform.texture->matrix;

    if (m->matrixType == __GL_MT_IDENTITY)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            if (!(pd->flags & POLYDATA_TEXTURE_VALID))
            {
                pd->texture.z = (pd-1)->texture.z;
                pd->texture.w = (pd-1)->texture.w;
            }

            // both s and t have the SAME plane equation
            pd->texture.x = cs->x * pd->obj.x + cs->y * pd->obj.y +
                            cs->z * pd->obj.z + cs->w * pd->obj.w;
            pd->texture.y = pd->texture.x;
        }
    }
    else
    {
        // If any incoming texture coords contains q coord, use xf4.
        if (pa->flags & POLYARRAY_TEXTURE4)
            xf = m->xf4;
        else if (pa->flags & POLYARRAY_TEXTURE3)
            xf = m->xf3;
        else
            xf = m->xf2;        // at least 2 generated values

        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            if (pd->flags & POLYDATA_TEXTURE_VALID)
            {
                gen.z = pd->texture.z;
                gen.w = pd->texture.w;
            }

            // both s and t have the SAME plane equation
            gen.x = cs->x * pd->obj.x + cs->y * pd->obj.y +
                    cs->z * pd->obj.z + cs->w * pd->obj.w;
            gen.y = gen.x;

            // Finally, apply texture matrix
            (*xf)(&pd->texture, (__GLfloat *) &gen, m);
        }
    }
}

// Generate texture coordinates from object coordinates
// object linear texture generation
// s and t are enabled but r and q are disabled
// both s and t use the object linear mode
// both s and t have DIFFERENT plane equations
// texture coordinates are modified in place
//
// IN:  texture, obj
// OUT: texture (all vertices are updated)

void FASTCALL PolyArrayCalcObjectLinear(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    __GLcoord *cs, *ct, gen;
    POLYDATA  *pd, *pdLast;
    PFN_XFORM xf;

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
        "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
        "bad paflags\n");

    cs = &gc->state.texture.s.objectPlaneEquation;
    ct = &gc->state.texture.t.objectPlaneEquation;
    pdLast = pa->pdNextVertex-1;
    m = &gc->transform.texture->matrix;

    if (m->matrixType == __GL_MT_IDENTITY)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
                if (!(pd->flags & POLYDATA_TEXTURE_VALID))
                {
                pd->texture.z = (pd-1)->texture.z;
                pd->texture.w = (pd-1)->texture.w;
                }

                pd->texture.x = cs->x * pd->obj.x + cs->y * pd->obj.y +
                                cs->z * pd->obj.z + cs->w * pd->obj.w;
                pd->texture.y = ct->x * pd->obj.x + ct->y * pd->obj.y +
                                ct->z * pd->obj.z + ct->w * pd->obj.w;
        }
    }
    else
    {
        // If any incoming texture coords contains q coord, use xf4.
        if (pa->flags & POLYARRAY_TEXTURE4)
                xf = m->xf4;
        else if (pa->flags & POLYARRAY_TEXTURE3)
                xf = m->xf3;
        else
                xf = m->xf2;    // at least 2 generated values

        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
                if (pd->flags & POLYDATA_TEXTURE_VALID)
                {
                    gen.z = pd->texture.z;
                    gen.w = pd->texture.w;
                }

                gen.x = cs->x * pd->obj.x + cs->y * pd->obj.y +
                        cs->z * pd->obj.z + cs->w * pd->obj.w;
                gen.y = ct->x * pd->obj.x + ct->y * pd->obj.y +
                        ct->z * pd->obj.z + ct->w * pd->obj.w;

                // Finally, apply texture matrix
                (*xf)(&pd->texture, (__GLfloat *) &gen, m);
        }
    }
}

// Generate texture coordinates from eye coordinates
// eye linear texture generation
// s and t are enabled but r and q are disabled
// both s and t use the eye linear mode
// both s and t have SAME plane equations
// texture coordinates are modified in place
// we may be able to get away without computing eye coord!
//
// IN:  texture; obj or eye
// OUT: texture and eye (all vertices are updated)

void FASTCALL PolyArrayCalcEyeLinearSameST(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    __GLcoord *cs, gen;
    POLYDATA  *pd, *pdLast;
    PFN_XFORM xf;

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
        "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
        "bad paflags\n");

// Compute eye coord first

    if (!(pa->flags & POLYARRAY_EYE_PROCESSED))
        PolyArrayProcessEye(gc, pa);

    cs = &gc->state.texture.s.eyePlaneEquation;
    pdLast = pa->pdNextVertex-1;
    m = &gc->transform.texture->matrix;

    if (m->matrixType == __GL_MT_IDENTITY)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            if (!(pd->flags & POLYDATA_TEXTURE_VALID))
            {
                pd->texture.z = (pd-1)->texture.z;
                pd->texture.w = (pd-1)->texture.w;
            }

            // both s and t have the SAME plane equation
            pd->texture.x = cs->x * pd->eye.x + cs->y * pd->eye.y +
                            cs->z * pd->eye.z + cs->w * pd->eye.w;
            pd->texture.y = pd->texture.x;
        }
    }
    else
    {
        // If any incoming texture coords contains q coord, use xf4.
        if (pa->flags & POLYARRAY_TEXTURE4)
            xf = m->xf4;
        else if (pa->flags & POLYARRAY_TEXTURE3)
            xf = m->xf3;
        else
            xf = m->xf2;        // at least 2 generated values

        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            if (pd->flags & POLYDATA_TEXTURE_VALID)
            {
                gen.z = pd->texture.z;
                gen.w = pd->texture.w;
            }

            // both s and t have the SAME plane equation
            gen.x = cs->x * pd->eye.x + cs->y * pd->eye.y +
                    cs->z * pd->eye.z + cs->w * pd->eye.w;
            gen.y = gen.x;

            // Finally, apply texture matrix
            (*xf)(&pd->texture, (__GLfloat *) &gen, m);
        }
    }
}

// Generate texture coordinates from eye coordinates
// eye linear texture generation
// s and t are enabled but r and q are disabled
// both s and t use the eye linear mode
// both s and t have SAME plane equations
// texture coordinates are modified in place
// we may be able to get away without computing eye coord!
//
// IN:  texture; obj or eye
// OUT: texture and eye (all vertices are updated)

void FASTCALL PolyArrayCalcEyeLinear(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    __GLcoord *cs, *ct, gen;
    POLYDATA  *pd, *pdLast;
    PFN_XFORM xf;

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
        "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
        "bad paflags\n");

// Compute eye coord first

    if (!(pa->flags & POLYARRAY_EYE_PROCESSED))
        PolyArrayProcessEye(gc, pa);

    cs = &gc->state.texture.s.eyePlaneEquation;
    ct = &gc->state.texture.t.eyePlaneEquation;
    pdLast = pa->pdNextVertex-1;
    m = &gc->transform.texture->matrix;

    if (m->matrixType == __GL_MT_IDENTITY)
    {
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
                if (!(pd->flags & POLYDATA_TEXTURE_VALID))
                {
                pd->texture.z = (pd-1)->texture.z;
                pd->texture.w = (pd-1)->texture.w;
                }

                pd->texture.x = cs->x * pd->eye.x + cs->y * pd->eye.y +
                                cs->z * pd->eye.z + cs->w * pd->eye.w;
                pd->texture.y = ct->x * pd->eye.x + ct->y * pd->eye.y +
                                ct->z * pd->eye.z + ct->w * pd->eye.w;
        }
    }
    else
    {
        // If any incoming texture coords contains q coord, use xf4.
        if (pa->flags & POLYARRAY_TEXTURE4)
                xf = m->xf4;
        else if (pa->flags & POLYARRAY_TEXTURE3)
                xf = m->xf3;
        else
                xf = m->xf2;    // at least 2 generated values

        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
                if (pd->flags & POLYDATA_TEXTURE_VALID)
                {
                gen.z = pd->texture.z;
                gen.w = pd->texture.w;
                }

                gen.x = cs->x * pd->eye.x + cs->y * pd->eye.y +
                        cs->z * pd->eye.z + cs->w * pd->eye.w;
                gen.y = ct->x * pd->eye.x + ct->y * pd->eye.y +
                        ct->z * pd->eye.z + ct->w * pd->eye.w;

                // Finally, apply texture matrix
                (*xf)(&pd->texture, (__GLfloat *) &gen, m);
        }
    }
}

// Compute the s & t coordinates for a sphere map.  The s & t values
// are stored in "result" even if both coordinates are not being
// generated.  The caller picks the right values out.
//
// IN:  eye, normal

void FASTCALL PASphereGen(POLYDATA *pd, __GLcoord *result)
{
    __GLcoord u, r;
    __GLfloat m, ndotu;

    // Get unit vector from origin to the vertex in eye coordinates into u
    __glNormalize(&u.x, &pd->eye.x);

    // Dot the normal with the unit position u
    ndotu = pd->normal.x * u.x + pd->normal.y * u.y + pd->normal.z * u.z;

    // Compute r
    r.x = u.x - 2 * pd->normal.x * ndotu;
    r.y = u.y - 2 * pd->normal.y * ndotu;
    r.z = u.z - 2 * pd->normal.z * ndotu;

    // Compute m
    m = 2 * __GL_SQRTF(r.x*r.x + r.y*r.y + (r.z + 1) * (r.z + 1));

    if (m)
    {
        result->x = r.x / m + __glHalf;
        result->y = r.y / m + __glHalf;
    }
    else
    {
        result->x = __glHalf;
        result->y = __glHalf;
    }
}

// Generate texture coordinates for sphere map
// sphere map texture generation
// s and t are enabled but r and q are disabled
// both s and t use the sphere map mode
// texture coordinates are modified in place
// we may be able to get away without computing eye coord!
//
// IN:  texture; obj or eye; normal
// OUT: texture and eye (all vertices are updated)

void FASTCALL PolyArrayCalcSphereMap(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    __GLcoord gen;
    POLYDATA  *pd, *pdLast, *pdNormal;
    PFN_XFORM xf;
    GLboolean bIdentity;

    // this is really okay
    PERF_CHECK(FALSE, "Uses sphere map texture generation!\n");

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
        "need initial texcoord value\n");

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_NORMAL_VALID,
        "need initial normal\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
        "bad paflags\n");

// Compute eye coord first

    if (!(pa->flags & POLYARRAY_EYE_PROCESSED))
        PolyArrayProcessEye(gc, pa);

    m = &gc->transform.texture->matrix;
    bIdentity = (m->matrixType == __GL_MT_IDENTITY);

    // If any incoming texture coords contains q coord, use xf4.
    if (pa->flags & POLYARRAY_TEXTURE4)
        xf = m->xf4;
    else if (pa->flags & POLYARRAY_TEXTURE3)
        xf = m->xf3;
    else
        xf = m->xf2;    // at least 2 generated values

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        if (pd->flags & POLYDATA_TEXTURE_VALID)
        {
                gen.z = pd->texture.z;
                gen.w = pd->texture.w;
        }

        if (pd->flags & POLYDATA_NORMAL_VALID)
        {
            // track current normal
            pdNormal = pd;
        }
        else
        {
            // pd->flags |= POLYDATA_NORMAL_VALID;
            pd->normal.x = pdNormal->normal.x;
            pd->normal.y = pdNormal->normal.y;
            pd->normal.z = pdNormal->normal.z;
        }

        PASphereGen(pd, &gen);  // compute s, t values

        // Finally, apply texture matrix
        if (!bIdentity)
            (*xf)(&pd->texture, (__GLfloat *) &gen, m);
        else
            pd->texture = gen;
    }
}

// Transform or compute the texture coordinates for the polyarray
// It handles all texture generation modes.  Texture coordinates are
// generated (if necessary) and transformed.
// Note that texture coordinates are modified in place.
//
// IN:  texture (always)
//      obj in GL_OBJECT_LINEAR mode
//      obj or eye in GL_EYE_LINEAR mode
//      obj or eye; normal in GL_SPHERE_MAP mode
// OUT: texture (all vertices are updated)
//      eye in GL_EYE_LINEAR and GL_SPHERE_MAP modes (all vertices
//      are updated)
void FASTCALL PolyArrayCalcMixedTexture(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatrix *m;
    GLuint     enables;
    POLYDATA   *pd, *pdLast, *pdNormal;
    PFN_XFORM  xf;
    BOOL       needNormal, didSphereGen;
    __GLcoord  savedTexture, sphereCoord, *c;
    GLboolean  bIdentity;

    enables = gc->state.enables.general;

    PERF_CHECK
    (
        !(enables & (__GL_TEXTURE_GEN_R_ENABLE | __GL_TEXTURE_GEN_Q_ENABLE)),
        "Uses r, q texture generation!\n"
    );

    if ((enables & __GL_TEXTURE_GEN_S_ENABLE)
     && (enables & __GL_TEXTURE_GEN_T_ENABLE)
     && (gc->state.texture.s.mode != gc->state.texture.t.mode))
    {
        PERF_CHECK(FALSE, "Uses different s and t tex gen modes!\n");
    }

    ASSERTOPENGL(pa->pd0->flags & POLYDATA_TEXTURE_VALID,
                 "need initial texcoord value\n");

    ASSERTOPENGL(pa->flags & (POLYARRAY_TEXTURE1|POLYARRAY_TEXTURE2|
                              POLYARRAY_TEXTURE3|POLYARRAY_TEXTURE4),
                 "bad paflags\n");

    if ((enables & __GL_TEXTURE_GEN_S_ENABLE) && (gc->state.texture.s.mode == GL_SPHERE_MAP)
     || (enables & __GL_TEXTURE_GEN_T_ENABLE) && (gc->state.texture.t.mode == GL_SPHERE_MAP))
    {
        ASSERTOPENGL(pa->pd0->flags & POLYDATA_NORMAL_VALID,
                     "need initial normal\n");

        needNormal = TRUE;
    }
    else
    {
            needNormal = FALSE;
    }

// Compute eye coord first

    if (!(pa->flags & POLYARRAY_EYE_PROCESSED))
    {
        if ((enables & __GL_TEXTURE_GEN_S_ENABLE)
                && (gc->state.texture.s.mode != GL_OBJECT_LINEAR)
         || (enables & __GL_TEXTURE_GEN_T_ENABLE)
                && (gc->state.texture.t.mode != GL_OBJECT_LINEAR)
         || (enables & __GL_TEXTURE_GEN_R_ENABLE)
                && (gc->state.texture.r.mode != GL_OBJECT_LINEAR)
         || (enables & __GL_TEXTURE_GEN_Q_ENABLE)
                && (gc->state.texture.q.mode != GL_OBJECT_LINEAR))
                PolyArrayProcessEye(gc, pa);
    }

    m = &gc->transform.texture->matrix;
    bIdentity = (m->matrixType == __GL_MT_IDENTITY);

    // If any incoming texture coords contains q coord, use xf4.
    if (pa->flags & POLYARRAY_TEXTURE4 || enables & __GL_TEXTURE_GEN_Q_ENABLE)
        xf = m->xf4;
    else if (pa->flags & POLYARRAY_TEXTURE3 || enables & __GL_TEXTURE_GEN_R_ENABLE)
        xf = m->xf3;
    else if (pa->flags & POLYARRAY_TEXTURE2 || enables & __GL_TEXTURE_GEN_T_ENABLE)
        xf = m->xf2;
    else
        xf = m->xf1;

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        // texture coordinates are modified in place.
        // save the valid values to use for the invalid entries.
        if (pd->flags & POLYDATA_TEXTURE_VALID)
                savedTexture = pd->texture;
        else
                pd->texture = savedTexture;

        if (needNormal)
        {
                if (pd->flags & POLYDATA_NORMAL_VALID)
                {
                // track current normal
                pdNormal = pd;
                }
                else
                {
                // pd->flags |= POLYDATA_NORMAL_VALID;
                pd->normal.x = pdNormal->normal.x;
                pd->normal.y = pdNormal->normal.y;
                pd->normal.z = pdNormal->normal.z;
                }
        }

        didSphereGen = GL_FALSE;

        /* Generate s coordinate */
        if (enables & __GL_TEXTURE_GEN_S_ENABLE)
        {
                if (gc->state.texture.s.mode == GL_EYE_LINEAR)
                {
                c = &gc->state.texture.s.eyePlaneEquation;
                pd->texture.x = c->x * pd->eye.x + c->y * pd->eye.y
                        + c->z * pd->eye.z + c->w * pd->eye.w;
                }
                else if (gc->state.texture.s.mode == GL_OBJECT_LINEAR)
                {
                // the primitive may contain a mix of vertex types (2,3,4)!
                c = &gc->state.texture.s.objectPlaneEquation;
                pd->texture.x = c->x * pd->obj.x + c->y * pd->obj.y +
                                c->z * pd->obj.z + c->w * pd->obj.w;
                }
                else
                {
                ASSERTOPENGL(gc->state.texture.s.mode == GL_SPHERE_MAP,
                        "invalide texture s mode");
                PASphereGen(pd, &sphereCoord);  // compute s, t values
                pd->texture.x = sphereCoord.x;
                didSphereGen = GL_TRUE;
                }
        }

        /* Generate t coordinate */
        if (enables & __GL_TEXTURE_GEN_T_ENABLE)
        {
                if (gc->state.texture.t.mode == GL_EYE_LINEAR)
                {
                c = &gc->state.texture.t.eyePlaneEquation;
                pd->texture.y = c->x * pd->eye.x + c->y * pd->eye.y
                        + c->z * pd->eye.z + c->w * pd->eye.w;
                }
                else if (gc->state.texture.t.mode == GL_OBJECT_LINEAR)
                {
                // the primitive may contain a mix of vertex types (2,3,4)!
                c = &gc->state.texture.t.objectPlaneEquation;
                pd->texture.y = c->x * pd->obj.x + c->y * pd->obj.y +
                                c->z * pd->obj.z + c->w * pd->obj.w;
                }
                else
                {
                ASSERTOPENGL(gc->state.texture.t.mode == GL_SPHERE_MAP,
                        "invalide texture t mode");
                if (!didSphereGen)
                        PASphereGen(pd, &sphereCoord);  // compute s, t values
                pd->texture.y = sphereCoord.y;
                }
        }

        /* Generate r coordinate */
        if (enables & __GL_TEXTURE_GEN_R_ENABLE)
        {
                if (gc->state.texture.r.mode == GL_EYE_LINEAR)
                {
                c = &gc->state.texture.r.eyePlaneEquation;
                pd->texture.z = c->x * pd->eye.x + c->y * pd->eye.y
                        + c->z * pd->eye.z + c->w * pd->eye.w;
                }
                else
                {
                ASSERTOPENGL(gc->state.texture.r.mode == GL_OBJECT_LINEAR,
                        "invalide texture r mode");

                // the primitive may contain a mix of vertex types (2,3,4)!
                c = &gc->state.texture.r.objectPlaneEquation;
                pd->texture.z = c->x * pd->obj.x + c->y * pd->obj.y +
                                c->z * pd->obj.z + c->w * pd->obj.w;
                }
        }

        /* Generate q coordinate */
        if (enables & __GL_TEXTURE_GEN_Q_ENABLE)
        {
                if (gc->state.texture.q.mode == GL_EYE_LINEAR)
                {
                c = &gc->state.texture.q.eyePlaneEquation;
                pd->texture.w = c->x * pd->eye.x + c->y * pd->eye.y
                        + c->z * pd->eye.z + c->w * pd->eye.w;
                }
                else
                {
                ASSERTOPENGL(gc->state.texture.q.mode == GL_OBJECT_LINEAR,
                        "invalide texture q mode");

                // the primitive may contain a mix of vertex types (2,3,4)!
                c = &gc->state.texture.q.objectPlaneEquation;
                pd->texture.w = c->x * pd->obj.x + c->y * pd->obj.y +
                                c->z * pd->obj.z + c->w * pd->obj.w;
                }
        }

        /* Finally, apply texture matrix */
        if (!bIdentity)
                (*xf)(&pd->texture, (__GLfloat *) &pd->texture, m);
    }
}

/****************************************************************************/
// Cache whatever values are possible for the current material and lights.
// This will let us avoid doing these computations for each primitive.
void FASTCALL PolyArrayCalcLightCache(__GLcontext *gc)
{
    __GLcolor baseEmissiveAmbient;
    __GLmaterialMachine *msm;
    __GLlightSourceMachine *lsm;
    __GLlightSourcePerMaterialMachine *lspmm;
    GLuint face;

    for (face = __GL_FRONTFACE; face <= __GL_BACKFACE; face++) {

        if (face == __GL_FRONTFACE) {
            if (!(gc->vertex.paNeeds & PANEEDS_FRONT_COLOR))
                continue;
            msm = &gc->light.front;
        }
        else {
            if (!(gc->vertex.paNeeds & PANEEDS_BACK_COLOR))
                return;
            msm = &gc->light.back;
        }

        msm->cachedEmissiveAmbient.r = msm->paSceneColor.r;
        msm->cachedEmissiveAmbient.g = msm->paSceneColor.g;
        msm->cachedEmissiveAmbient.b = msm->paSceneColor.b;

        // add invarient per-light per-material cached ambient
        for (lsm = gc->light.sources; lsm; lsm = lsm->next)
        {
            lspmm = &lsm->front + face;
            msm->cachedEmissiveAmbient.r += lspmm->ambient.r;
            msm->cachedEmissiveAmbient.g += lspmm->ambient.g;
            msm->cachedEmissiveAmbient.b += lspmm->ambient.b;
        }

        __GL_CLAMP_RGB(msm->cachedNonLit.r,
                       msm->cachedNonLit.g,
                       msm->cachedNonLit.b,
                       gc,
                       msm->cachedEmissiveAmbient.r,
                       msm->cachedEmissiveAmbient.g,
                       msm->cachedEmissiveAmbient.b);
    }
}

/****************************************************************************/
// Apply the accumulated material changes to a vertex
void FASTCALL PAApplyMaterial(__GLcontext *gc, __GLmatChange *mat, GLint face)
{
    __GLmaterialState *ms;
    GLuint changeBits;

    PERF_CHECK(FALSE, "Primitives contain glMaterial calls!\n");

    // Don't modify color materials if they are in effect!

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        changeBits = mat->dirtyBits & ~gc->light.front.colorMaterialChange;
    }
    else
    {
        ms  = &gc->state.light.back;
        changeBits = mat->dirtyBits & ~gc->light.back.colorMaterialChange;
    }

    if (changeBits & __GL_MATERIAL_AMBIENT)
        ms->ambient = mat->ambient;

    if (changeBits & __GL_MATERIAL_DIFFUSE)
        ms->diffuse = mat->diffuse;

    if (changeBits & __GL_MATERIAL_SPECULAR)
        ms->specular = mat->specular;

    if (changeBits & __GL_MATERIAL_EMISSIVE)
    {
        ms->emissive.r = mat->emissive.r * gc->redVertexScale;
        ms->emissive.g = mat->emissive.g * gc->greenVertexScale;
        ms->emissive.b = mat->emissive.b * gc->blueVertexScale;
        ms->emissive.a = mat->emissive.a * gc->alphaVertexScale;
    }

    if (changeBits & __GL_MATERIAL_SHININESS)
        ms->specularExponent = mat->shininess;

    if (changeBits & __GL_MATERIAL_COLORINDEXES)
    {
        ms->cmapa = mat->cmapa;
        ms->cmapd = mat->cmapd;
        ms->cmaps = mat->cmaps;
    }

    // Re-calculate the precomputed values.  This works for RGBA and CI modes.

    if (face == __GL_FRONTFACE)
        __glValidateMaterial(gc, (GLint) changeBits, 0);
    else
        __glValidateMaterial(gc, 0, (GLint) changeBits);

// Recompute cached RGB material values:

    PolyArrayCalcLightCache(gc);
}

void FASTCALL PolyArrayApplyMaterials(__GLcontext *gc, POLYARRAY *pa)
{
    __GLmatChange matChange, *pdMat;
    GLuint        matMask;
    POLYDATA      *pd, *pdN;
    GLint         face;
    POLYMATERIAL  *pm;

    pm = GLTEB_CLTPOLYMATERIAL();

    // Need to apply material changes defined after the last vertex!

    pdN = pa->pdNextVertex;

    // ASSERT_FACE
    for (face = __GL_BACKFACE, matMask = POLYARRAY_MATERIAL_BACK;
         face >= 0;
         face--,   matMask = POLYARRAY_MATERIAL_FRONT
        )
    {
        if (!(pa->flags & matMask))
            continue;

        // Accumulate all changes into one material change record
        // We need to process (n + 1) vertices for material changes!

        matChange.dirtyBits = 0;
        for (pd = pa->pd0; pd <= pdN; pd++)
        {
            // ASSERT_MATERIAL
            if (pd->flags & matMask)
            {
                GLuint dirtyBits;

                pdMat = *(&pm->pdMaterial0[pd - pa->pdBuffer0].front + face);
                dirtyBits  = pdMat->dirtyBits;
                matChange.dirtyBits |= dirtyBits;

                if (dirtyBits & __GL_MATERIAL_AMBIENT)
                    matChange.ambient = pdMat->ambient;

                if (dirtyBits & __GL_MATERIAL_DIFFUSE)
                    matChange.diffuse = pdMat->diffuse;

                if (dirtyBits & __GL_MATERIAL_SPECULAR)
                    matChange.specular = pdMat->specular;

                if (dirtyBits & __GL_MATERIAL_EMISSIVE)
                    matChange.emissive = pdMat->emissive;

                if (dirtyBits & __GL_MATERIAL_SHININESS)
                    matChange.shininess = pdMat->shininess;

                if (dirtyBits & __GL_MATERIAL_COLORINDEXES)
                {
                    matChange.cmapa = pdMat->cmapa;
                    matChange.cmapd = pdMat->cmapd;
                    matChange.cmaps = pdMat->cmaps;
                }
            }
        }

        // apply material changes for this face
        PAApplyMaterial(gc, &matChange, face);
    }
}

/****************************************************************************/
#ifndef __GL_ASM_POLYARRAYFILLINDEX0
// Fill the index values with 0
//
// IN:  none
// OUT: colors[face].r (all vertices are updated)

void FASTCALL PolyArrayFillIndex0(__GLcontext *gc, POLYARRAY *pa, GLint face)
{
    POLYDATA  *pd, *pdLast;

    ASSERTOPENGL((GLuint) face <= 1, "bad face value\n");

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        pd->colors[face].r = __glZero;
    }
}
#endif // __GL_ASM_POLYARRAYFILLINDEX0

#ifndef __GL_ASM_POLYARRAYFILLCOLOR0
// Fill the color values with 0,0,0,0
//
// IN:  none
// OUT: colors[face] (all vertices are updated)

void FASTCALL PolyArrayFillColor0(__GLcontext *gc, POLYARRAY *pa, GLint face)
{
    POLYDATA  *pd, *pdLast;

    ASSERTOPENGL((GLuint) face <= 1, "bad face value\n");

    pdLast = pa->pdNextVertex-1;
    for (pd = pa->pd0; pd <= pdLast; pd++)
    {
        pd->colors[face].r = __glZero;
        pd->colors[face].g = __glZero;
        pd->colors[face].b = __glZero;
        pd->colors[face].a = __glZero;
    }
}
#endif // __GL_ASM_POLYARRAYFILLCOLOR0

#ifndef __GL_ASM_POLYARRAYPROPAGATESAMECOLOR
// All vertices have the same color values.
// Clamp and scale the current color using the color buffer scales.
// From here on out the colors in the vertex are in their final form.
//
// Note: The first vertex must have a valid color!
//       Back color is not needed when lighting is disabled.
//
// IN:  color (front)
// OUT: color (front) (all vertices are updated)

void FASTCALL PolyArrayPropagateSameColor(__GLcontext *gc, POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;
    __GLfloat r, g, b, a;

    pdLast = pa->pdNextVertex-1;
    pd = pa->pd0;
    if (pd > pdLast)
        return;

    ASSERTOPENGL(pd->flags & POLYDATA_COLOR_VALID, "no initial color\n");

    if (pa->flags & POLYARRAY_CLAMP_COLOR) {
        __GL_CLAMP_RGBA(pd->colors[0].r,
                        pd->colors[0].g,
                        pd->colors[0].b,
                        pd->colors[0].a,
                        gc,
                        pd->colors[0].r,
                        pd->colors[0].g,
                        pd->colors[0].b,
                        pd->colors[0].a);
    }

    r = pd->colors[0].r;
    g = pd->colors[0].g;
    b = pd->colors[0].b;
    a = pd->colors[0].a;

    for (pd = pd + 1 ; pd <= pdLast; pd++)
    {
        pd->colors[0].r = r;
        pd->colors[0].g = g;
        pd->colors[0].b = b;
        pd->colors[0].a = a;
    }
}
#endif // __GL_ASM_POLYARRAYPROPAGATESAMECOLOR

#ifndef __GL_ASM_POLYARRAYPROPAGATESAMEINDEX
// All vertices have the same index values.
// Mask the index values befor color clipping
// SGIBUG: The sample implementation fails to do this!
//
// Note: The first vertex must have a valid color index!
//       Back color is not needed when lighting is disabled.
//
// IN:  color.r (front)
// OUT: color.r (front) (all vertices are updated)

void FASTCALL PolyArrayPropagateSameIndex(__GLcontext *gc, POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;
    __GLfloat index;

    pdLast = pa->pdNextVertex-1;
    pd = pa->pd0;
    if (pd > pdLast)
        return;

    ASSERTOPENGL(pd->flags & POLYDATA_COLOR_VALID, "no initial color index\n");

    if (pa->flags & POLYARRAY_CLAMP_COLOR) {
        __GL_CLAMP_CI(pd->colors[0].r, gc, pd->colors[0].r);
    }

    index = pd->colors[0].r;

    for (pd = pd + 1; pd <= pdLast; pd++)
    {
        pd->colors[0].r = index;
    }
}
#endif // __GL_ASM_POLYARRAYPROPAGATESAMEINDEX

#ifndef __GL_ASM_POLYARRAYPROPAGATEINDEX

// Propagate the valid CI colors through the vertex buffer.
//
// IN:  color.r (front)
// OUT: color.r (front) (all vertices are updated)

void FASTCALL PolyArrayPropagateIndex(__GLcontext *gc, POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;

    if (pa->flags & POLYARRAY_CLAMP_COLOR) {
        pdLast = pa->pdNextVertex-1;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {
            if (!(pd->flags & POLYDATA_COLOR_VALID))
            {
                // If color has not changed for this vertex,
                // use the previously computed color.

                ASSERTOPENGL(pd != pa->pd0, "no initial color index\n");
                pd->colors[0].r = (pd-1)->colors[0].r;
                continue;
            }

            __GL_CLAMP_CI(pd->colors[0].r, gc, pd->colors[0].r);

        }
    } else {
        // If all incoming vertices have valid colors, we are done.
        if ((pa->flags & POLYARRAY_SAME_POLYDATA_TYPE)
            && (pa->pdCurColor != pa->pd0)
            // Need to test 2nd vertex because pdCurColor may have been
            // advanced as a result of combining Color command after End
            && ((pa->pd0 + 1)->flags & POLYDATA_COLOR_VALID))
          ;
        else
        {
            pdLast = pa->pdNextVertex-1;
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                if (!(pd->flags & POLYDATA_COLOR_VALID))
                {
                    // If color has not changed for this vertex,
                    // use the previously computed color.

                    ASSERTOPENGL(pd != pa->pd0, "no initial color index\n");
                    pd->colors[0].r = (pd-1)->colors[0].r;
                }
            }
        }
    }
}
#endif // __GL_ASM_POLYARRAYPROPAGATEINDEX

#ifndef __GL_ASM_POLYARRAYPROPAGATECOLOR

// Propagate the valid RGBA colors through the vertex buffer.
//
// IN:  color (front)
// OUT: color (front) (all vertices are updated)

void FASTCALL PolyArrayPropagateColor(__GLcontext *gc, POLYARRAY *pa)
{
    POLYDATA  *pd, *pdLast;

    if (pa->flags & POLYARRAY_CLAMP_COLOR) {
        pdLast = pa->pdNextVertex-1;
        for (pd = pa->pd0; pd <= pdLast; pd++)
        {

            if (!(pd->flags & POLYDATA_COLOR_VALID))
            {
                // If color has not changed for this vertex,
                // use the previously computed color.

                ASSERTOPENGL(pd != pa->pd0, "no initial color\n");
                pd->colors[0] = (pd-1)->colors[0];
                continue;
            }

            __GL_CLAMP_RGBA(pd->colors[0].r,
                            pd->colors[0].g,
                            pd->colors[0].b,
                            pd->colors[0].a,
                            gc,
                            pd->colors[0].r,
                            pd->colors[0].g,
                            pd->colors[0].b,
                            pd->colors[0].a);
        }
    } else {
        // If all incoming vertices have valid colors, we are done.
        if ((pa->flags & POLYARRAY_SAME_POLYDATA_TYPE)
            && (pa->pdCurColor != pa->pd0)
            // Need to test 2nd vertex because pdCurColor may have been
            // advanced as a result of combining Color command after End
            && ((pa->pd0 + 1)->flags & POLYDATA_COLOR_VALID))
          ;
        else
        {
            pdLast = pa->pdNextVertex-1;
            for (pd = pa->pd0; pd <= pdLast; pd++)
            {
                if (!(pd->flags & POLYDATA_COLOR_VALID))
                {
                    // If color has not changed for this vertex,
                    // use the previously computed color.

                    ASSERTOPENGL(pd != pa->pd0, "no initial color\n");
                    pd->colors[0] = (pd-1)->colors[0];
                }
            }
        }
    }
}
#endif // __GL_ASM_POLYARRAYPROPAGATECOLOR

/****************************************************************************/
#if 0
//!!! remove this
// do we need clip?
// need __GL_HAS_FOG bit for line and polygon clipping!
// The boundaryEdge field is initialized in the calling routine.
#define PA_STORE_PROCESSED_POLYGON_VERTEX(v,pd,bits)                        \
        {                                                                   \
            (v)->clip = (pd)->clip;                                         \
            (v)->window = (pd)->window;                                     \
            (v)->eye.z = (pd)->eye.z; /* needed by slow fog */              \
            (v)->fog = (pd)->fog; /* needed by cheap fog in flat shading */ \
            (v)->texture.x = (pd)->texture.x;                               \
            (v)->texture.y = (pd)->texture.y;                               \
            (v)->texture.z = (pd)->texture.z; /* z is needed by feedback! */\
            (v)->texture.w = (pd)->texture.w;                               \
            (v)->color = &(pd)->color;                                      \
            (v)->clipCode = (pd)->clipCode;                                 \
            (v)->has = bits;                                                \
        }

// need eye if there is eyeClipPlanes
// need texture if there is texture
// need __GL_HAS_FOG bit for line and polygon clipping!
#define PA_STORE_PROCESSED_LINE_VERTEX(v,pd,bits)                           \
        {                                                                   \
            (v)->clip = (pd)->clip;                                         \
            (v)->window = (pd)->window;                                     \
            (v)->eye.z = (pd)->eye.z; /* needed by slow fog */              \
            (v)->fog = (pd)->fog; /* needed by cheap fog in flat shading */ \
            (v)->texture.x = (pd)->texture.x;                               \
            (v)->texture.y = (pd)->texture.y;                               \
            (v)->texture.z = (pd)->texture.z; /* z is needed by feedback! */\
            (v)->texture.w = (pd)->texture.w;                               \
            (v)->colors[__GL_FRONTFACE] = (pd)->color;                      \
            (v)->clipCode = (pd)->clipCode;                                 \
            (v)->has = bits;                                                \
        }

// need eye if antialised is on
// need texture if there is texture
#define PA_STORE_PROCESSED_POINT_VERTEX(v,pd,bits)                          \
        {                                                                   \
            (v)->window = (pd)->window;                                     \
            (v)->eye.z = (pd)->eye.z; /* needed by slow fog */              \
            (v)->fog = (pd)->fog; /* needed by cheap fog in flat shading */ \
            (v)->clip.w = (pd)->clip.w; /* needed by feedback! */           \
            (v)->texture.x = (pd)->texture.x;                               \
            (v)->texture.y = (pd)->texture.y;                               \
            (v)->texture.z = (pd)->texture.z; /* z is needed by feedback! */\
            (v)->texture.w = (pd)->texture.w;                               \
            (v)->color = &(pd)->color;                                      \
            (v)->has = bits;                                                \
        }
#endif // 0

// ---------------------------------------------------------
// The primitive is clipped.
void FASTCALL PARenderPoint(__GLcontext *gc, __GLvertex *v)
{
    if (v->clipCode == 0)
        (*gc->procs.renderPoint)(gc, v);
}

// ---------------------------------------------------------
// The primitive is clipped.
void FASTCALL PARenderLine(__GLcontext *gc, __GLvertex *v0,
                           __GLvertex *v1, GLuint flags)
{
    if (v0->clipCode | v1->clipCode)
    {
        /*
         * The line must be clipped more carefully.  Cannot
         * trivially accept the lines.
         *
         * If anding the codes is non-zero then every vertex
         * in the line is outside of the same set of clipping
         * planes (at least one).  Trivially reject the line.
         */
        if ((v0->clipCode & v1->clipCode) == 0)
            __glClipLine(gc, v0, v1, flags);
    }
    else
    {
        // Line is trivially accepted so render it
        (*gc->procs.renderLine)(gc, v0, v1, flags);
    }
}
// ---------------------------------------------------------
// The primitive is clipped.
void FASTCALL PARenderTriangle(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2)
{
    GLuint orCodes;

    /* Clip check */
    orCodes = v0->clipCode | v1->clipCode | v2->clipCode;
    if (orCodes)
    {
        /* Some kind of clipping is needed.
         *
         * If anding the codes is non-zero then every vertex
         * in the triangle is outside of the same set of
         * clipping planes (at least one).  Trivially reject
         * the triangle.
         */
        if (!(v0->clipCode & v1->clipCode & v2->clipCode))
            (*gc->procs.clipTriangle)(gc, v0, v1, v2, orCodes);
    }
    else
    {
        (*gc->procs.renderTriangle)(gc, v0, v1, v2);
    }
}

// ---------------------------------------------------------
// The primitive is not clipped.
void PARenderQuadFast(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2, __GLvertex *v3)
{
    // Vertex ordering is important.  Line stippling uses it.
    // SGIBUG: The sample implementation does it wrong.

    GLuint savedTag;

    /* Render the quad as two triangles */
    savedTag = v2->has & __GL_HAS_EDGEFLAG_BOUNDARY;
    v2->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
    (*gc->procs.renderTriangle)(gc, v0, v1, v2);
    v2->has |= savedTag;
    savedTag = v0->has & __GL_HAS_EDGEFLAG_BOUNDARY;
    v0->has &= ~__GL_HAS_EDGEFLAG_BOUNDARY;
    (*gc->procs.renderTriangle)(gc, v2, v3, v0);
    v0->has |= savedTag;
}

// ---------------------------------------------------------
// The primitive is clipped.
void PARenderQuadSlow(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2, __GLvertex *v3)
{
    GLuint orCodes;

    orCodes = v0->clipCode | v1->clipCode | v2->clipCode | v3->clipCode;

    if (orCodes)
    {
        /* Some kind of clipping is needed.
         *
         * If anding the codes is non-zero then every vertex
         * in the quad is outside of the same set of
         * clipping planes (at least one).  Trivially reject
         * the quad.
         */
        if (!(v0->clipCode & v1->clipCode & v2->clipCode & v3->clipCode))
        {
            /* Clip the quad as a polygon */
            __GLvertex *iv[4];

            iv[0] = v0;
            iv[1] = v1;
            iv[2] = v2;
            iv[3] = v3;
            __glDoPolygonClip(gc, &iv[0], 4, orCodes);
        }
    }
    else
    {
        PARenderQuadFast(gc, v0, v1, v2, v3);
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM

void FASTCALL PolyArrayDrawPoints(__GLcontext *gc, POLYARRAY *pa)
{
// Index mapping is always identity in Points.

    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

    // Assert that pa->nIndices is correct
    ASSERTOPENGL(pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Call PolyArrayRenderPoints later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderPoints(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, nIndices;
    POLYDATA   *pd0;
    void (FASTCALL *rp)(__GLcontext *gc, __GLvertex *v);

// Index mapping is always identity in Points.

    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

    nIndices = pa->nIndices;
    pd0      = pa->pd0;
    rp = pa->orClipCodes ? PARenderPoint : gc->procs.renderPoint;

    // Identity mapping
    for (i = 0; i < nIndices; i++)
        /* Render the point */
        (*rp)(gc, (__GLvertex *) &pd0[i]);
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawLines(__GLcontext *gc, POLYARRAY *pa)
{
    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Call PolyArrayRenderLines later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif //NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderLines(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast2;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    PFN_RENDER_LINE rl;
    GLuint     modeFlags;

    iLast2 = pa->nIndices - 2;
    pd0    = pa->pd0;
    rl = pa->orClipCodes ? PARenderLine : gc->procs.renderLine;

    if (pa->flags & POLYARRAY_SAME_COLOR_DATA) {
        modeFlags = gc->polygon.shader.modeFlags;
        gc->polygon.shader.modeFlags &= ~__GL_SHADE_SMOOTH;
    }

    (*gc->procs.lineBegin)(gc);

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        for (i = 0; i <= iLast2; i += 2)
        {
            /* setup for rendering this line */
            gc->line.notResetStipple = GL_FALSE;

            (*rl)(gc, (__GLvertex *) &pd0[i  ],
                  (__GLvertex *) &pd0[i+1], __GL_LVERT_FIRST);
        }
    }
    else
    {
        for (i = 0; i <= iLast2; i += 2)
        {
            /* setup for rendering this line */
            gc->line.notResetStipple = GL_FALSE;

            (*rl)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                  (__GLvertex *) &pd0[aIndices[i+1]], __GL_LVERT_FIRST);
        }
    }

    (*gc->procs.lineEnd)(gc);

    if (pa->flags & POLYARRAY_SAME_COLOR_DATA) {
        gc->polygon.shader.modeFlags = modeFlags;
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawLLoop(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    POLYDATA   *pd, *pd0;

// Index mapping is always identity in Line Loop.

    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

// A line loop is the same as a line strip except that a final segment is
// added from the final specified vertex to the first vertex.  We will
// convert the line loop into a strip here.

    nIndices = pa->nIndices;

// If we are continuing with a previously decomposed line loop, we need to
// connect the last vertex of the previous primitive and the first vertex
// of the current primitive with a line segment.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_RESET_STIPPLE),
                "bad stipple reset flag!\n");

        // Insert previous end vertex at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
    }
    else
    {
// New line loop.

        ASSERTOPENGL(pa->flags & POLYARRAY_RESET_STIPPLE,
            "bad stipple reset flag!\n");

// At least two vertices must be given for anything to occur.
// An extra vertex was added to close the loop.

        if (nIndices < 3)
        {
                ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                         "Partial end with insufficient vertices\n");
                pa->nIndices--;
                goto DrawLLoop_end;
        }
    }

    pd0 = pa->pd0;

// If the primitive is only partially complete, save the last vertex for
// next batch.

    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        pd = &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd);

// Save the the original first vertex for closing the loop later.

        if (!(pa->flags & POLYARRAY_PARTIAL_BEGIN))
                PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[1], pd0);

// Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
                goto DrawLLoop_end;
#endif
    }
    else
    {
        POLYDATA *pdOrigin;

// Insert the original first vertex to close the loop and update clip code.

        if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
                pdOrigin = &gc->vertex.pdSaved[1];
        else
                pdOrigin = pd0;

        pd = pa->pdNextVertex++;
        ASSERTOPENGL(pd <= pa->pdBufferMax, "vertex overflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, pdOrigin);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
    }

    // Assert that pa->nIndices is correct
    ASSERTOPENGL(pa->nIndices == pa->pdNextVertex - pa->pd0,
        "bad nIndices\n");

// Render the line strip.

    // Call PolyArrayRenderLStrip later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
DrawLLoop_end:
    // Change primitive type to line strip!
    pa->primType = GL_LINE_STRIP;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderLStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    PFN_RENDER_LINE rl;
    GLuint     modeFlags;

// Render the line strip.

    iLast = pa->nIndices - 1;
    pd0   = pa->pd0;
    rl = pa->orClipCodes ? PARenderLine : gc->procs.renderLine;
    if (iLast <= 0)
        return;

// Reset the line stipple if this is a new strip.

    if (pa->flags & POLYARRAY_RESET_STIPPLE)
        gc->line.notResetStipple = GL_FALSE;

    if (pa->flags & POLYARRAY_SAME_COLOR_DATA) {
        modeFlags = gc->polygon.shader.modeFlags;
        gc->polygon.shader.modeFlags &= ~__GL_SHADE_SMOOTH;
    }

    (*gc->procs.lineBegin)(gc);

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        // Add first line segment (NOTE: 0, 1)
        (*rl)(gc, (__GLvertex *) &pd0[0],
                  (__GLvertex *) &pd0[1], __GL_LVERT_FIRST);

        // Add subsequent line segments (NOTE: i, i+1)
        for (i = 1; i < iLast; i++)
            (*rl)(gc, (__GLvertex *) &pd0[i  ],
                      (__GLvertex *) &pd0[i+1], 0);
    }
    else
    {
        // Add first line segment (NOTE: 0, 1)
        (*rl)(gc, (__GLvertex *) &pd0[aIndices[0]],
                  (__GLvertex *) &pd0[aIndices[1]], __GL_LVERT_FIRST);

        // Add subsequent line segments (NOTE: i, i+1)
        for (i = 1; i < iLast; i++)
            (*rl)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                      (__GLvertex *) &pd0[aIndices[i+1]], 0);
    }

    if (pa->flags & POLYARRAY_SAME_COLOR_DATA) {
        gc->polygon.shader.modeFlags = modeFlags;
    }

    (*gc->procs.lineEnd)(gc);
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawLStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    GLubyte    *aIndices;
    POLYDATA   *pd, *pd0;

    nIndices = pa->nIndices;
    aIndices = pa->aIndices;

// If we are continuing with a previously decomposed line strip, we need to
// connect the last vertex of the previous primitive and the first vertex
// of the current primitive with a line segment.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_RESET_STIPPLE),
            "bad stipple reset flag!\n");

        // Insert previous end vertex at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[0] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[0] == 0, "bad index mapping\n");
    }
    else
    {
// New line strip.

        ASSERTOPENGL(pa->flags & POLYARRAY_RESET_STIPPLE,
            "bad stipple reset flag!\n");
    }

// At least two vertices must be given for anything to occur.

    if (nIndices < 2)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                     "Partial end with insufficient vertices\n");
        return;
    }

// If the primitive is only partially complete, save the last vertex for
// next batch.

    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        pd0 = pa->pd0;
        pd  = aIndices ? &pd0[aIndices[nIndices-1]] : &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd);

// Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
                return;
#endif
    }

    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
        "bad nIndices\n");

// Render the line strip.

    // Call PolyArrayRenderLStrip later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}

// ---------------------------------------------------------
void FASTCALL PolyArrayDrawTriangles(__GLcontext *gc, POLYARRAY *pa)
{
    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Call PolyArrayRenderTriangles later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderTriangles(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast3;
    GLubyte    *aIndices, *aIndicesEnd;
    POLYDATA   *pd0;
    __GLvertex *provoking;
    PFN_RENDER_TRIANGLE rt;

// Vertex ordering is important.  Line stippling uses it.
// SGIBUG: The sample implementation does it wrong.

    iLast3 = pa->nIndices - 3;
    pd0    = pa->pd0;
    rt = pa->orClipCodes ? PARenderTriangle : gc->procs.renderTriangle;

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        for (i = 0; i <= iLast3; i += 3)
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+2];

            /* Render the triangle (NOTE: i, i+1, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[i  ],
                  (__GLvertex *) &pd0[i+1],
            (__GLvertex *) &pd0[i+2]);
        }
    }
    else
    {
#if 0
        for (i = 0; i <= iLast3; i += 3)
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+2]];

            /* Render the triangle (NOTE: i, i+1, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                      (__GLvertex *) &pd0[aIndices[i+1]],
                      (__GLvertex *) &pd0[aIndices[i+2]]);
        }
#else
    aIndicesEnd = aIndices+iLast3;
    while (aIndices <= aIndicesEnd)
    {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            provoking = PD_VERTEX(pd0, aIndices[2]);
            gc->vertex.provoking = provoking;

            /* Render the triangle (NOTE: i, i+1, i+2) */
            (*rt)(gc, PD_VERTEX(pd0, aIndices[0]),
                      PD_VERTEX(pd0, aIndices[1]),
                      provoking);
            aIndices += 3;
        }
#endif
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawTStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    GLubyte    *aIndices;
    POLYDATA   *pd, *pd0;

    nIndices = pa->nIndices;
    aIndices = pa->aIndices;

    // If we are continuing with a previously decomposed triangle strip,
    // we need to start from the last two vertices of the previous primitive.
    //
    // Note that the flush vertex ensures that the continuing triangle strip
    // is in the default orientation so that it can fall through the normal
    // code.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        // Insert previous end vertices at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[1]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[1] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[1] == 1, "bad index mapping\n");

        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[0] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[0] == 0, "bad index mapping\n");
    }

// Need at least 3 vertices.

    if (nIndices < 3)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                     "Partial end with insufficient vertices\n");
        return;
    }

    // If the primitive is only partially complete,
    // save the last two vertices for next batch.
#ifdef GL_WIN_phong_shading
    // !!If phong shaded, also save the current material parameters.
    // No need, since in Phong shading, I am throwing away all glMaterial
    // calls between glBegin/glEnd. If it is a PARTIAL_PRIMITIVE, then
    // there were no material changes (except ColorMaterial) immediately
    // before.
#endif //GL_WIN_phong_shading
    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        pd0 = pa->pd0;
        pd  = aIndices ? &pd0[aIndices[nIndices-2]] : &pd0[nIndices-2];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd);
        pd  = aIndices ? &pd0[aIndices[nIndices-1]] : &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[1], pd);

        // Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
            return;
#endif
    }

    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Render the triangle strip.

    // Call PolyArrayRenderTStrip later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif //NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderTStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast3;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    PFN_RENDER_TRIANGLE rt;

    iLast3 = pa->nIndices - 3;
    pd0    = pa->pd0;
    rt = pa->orClipCodes ? PARenderTriangle : gc->procs.renderTriangle;
    if (iLast3 < 0)
        return;

    // Vertex ordering is important.  Line stippling uses it.

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        // Initialize first 2 vertices so we can start rendering the strip
        // below.  The edge flags are not modified by our lower level
        // routines.
        pd0[0].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[1].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        for (i = 0; i <= iLast3; )
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+2];
            pd0[i+2].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: i, i+1, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[i  ],
                  (__GLvertex *) &pd0[i+1],
            (__GLvertex *) &pd0[i+2]);
            i++;

            if (i > iLast3)
              break;

            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+2];
            pd0[i+2].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: i+1, i, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[i+1],
                  (__GLvertex *) &pd0[i  ],
            (__GLvertex *) &pd0[i+2]);
            i++;
        }
    }
    else
    {
        // Initialize first 2 vertices so we can start rendering the strip
        // below.  The edge flags are not modified by our lower level routines.
        pd0[aIndices[0]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[aIndices[1]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        for (i = 0; i <= iLast3; )
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+2]];
            pd0[aIndices[i+2]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: i, i+1, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                  (__GLvertex *) &pd0[aIndices[i+1]],
            (__GLvertex *) &pd0[aIndices[i+2]]);
            i++;

            if (i > iLast3)
              break;

            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+2]];
            pd0[aIndices[i+2]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: i+1, i, i+2) */
            (*rt)(gc, (__GLvertex *) &pd0[aIndices[i+1]],
                  (__GLvertex *) &pd0[aIndices[i  ]],
            (__GLvertex *) &pd0[aIndices[i+2]]);
            i++;
        }
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawTFan(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    GLubyte    *aIndices;
    POLYDATA   *pd, *pd0;

    nIndices = pa->nIndices;
    aIndices = pa->aIndices;

    // If we are continuing with a previously decomposed triangle fan,
    // we need to connect the last vertex of the previous primitive and the
    // first vertex of the current primitive with a triangle.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        // Insert previous end vertex at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[1]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[1] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[1] == 1, "bad index mapping\n");

        // Insert the origin first vertex at the beginning and update
        // clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[0] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[0] == 0, "bad index mapping\n");
    }

    // Need at least 3 vertices.

    if (nIndices < 3)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                     "Partial end with insufficient vertices\n");
        return;
    }

    // If the primitive is only partially complete, save the last vertex
    // for next batch.  Also save the original first vertex of the triangle
    // fan.

    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        pd0 = pa->pd0;
        pd  = aIndices ? &pd0[aIndices[nIndices-1]] : &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[1], pd);

        if (!(pa->flags & POLYARRAY_PARTIAL_BEGIN))
        {
            pd = aIndices ? &pd0[aIndices[0]] : &pd0[0];
            PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd);
        }

        // Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
            return;
#endif
    }

    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Render the triangle fan.

    // Call PolyArrayRenderTFan later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderTFan(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast2;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    PFN_RENDER_TRIANGLE rt;

    iLast2 = pa->nIndices - 2;
    pd0    = pa->pd0;
    rt = pa->orClipCodes ? PARenderTriangle : gc->procs.renderTriangle;
    if (iLast2 <= 0)
        return;

    // Vertex ordering is important.  Line stippling uses it.
    // SGIBUG: The sample implementation does it wrong.

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        // Initialize first 2 vertices so we can start rendering the tfan
        // below.  The edge flags are not modified by our lower level routines.
        pd0[0].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[1].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        for (i = 1; i <= iLast2; i++)
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+1];
            pd0[i+1].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: 0, i, i+1) */
            (*rt)(gc, (__GLvertex *) &pd0[0  ],
                  (__GLvertex *) &pd0[i  ],
            (__GLvertex *) &pd0[i+1]);
        }
    }
    else
    {
        POLYDATA *pdOrigin;

        // Initialize first 2 vertices so we can start rendering the tfan
        // below.  The edge flags are not modified by our lower level
        // routines.
        pd0[aIndices[0]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[aIndices[1]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        pdOrigin = &pd0[aIndices[0]];
        for (i = 1; i <= iLast2; i++)
        {
            /* setup for rendering this triangle */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+1]];
            pd0[aIndices[i+1]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the triangle (NOTE: 0, i, i+1) */
            (*rt)(gc, (__GLvertex *) pdOrigin,
                  (__GLvertex *) &pd0[aIndices[i  ]],
                  (__GLvertex *) &pd0[aIndices[i+1]]);
        }
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawQuads(__GLcontext *gc, POLYARRAY *pa)
{
    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Call PolyArrayRenderQuad later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderQuads(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast4;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    void (*rq)(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2,
               __GLvertex *v3);

    // Vertex ordering is important.  Line stippling uses it.

    iLast4 = pa->nIndices - 4;
    pd0    = pa->pd0;
    rq = pa->orClipCodes ? PARenderQuadSlow : PARenderQuadFast;

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        for (i = 0; i <= iLast4; i += 4)
        {
            /* setup for rendering this quad */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+3];

            /* Render the quad (NOTE: i, i+1, i+2, i+3) */
            (*rq)(gc, (__GLvertex *) &pd0[i  ],
                  (__GLvertex *) &pd0[i+1],
            (__GLvertex *) &pd0[i+2],
                  (__GLvertex *) &pd0[i+3]);
        }
    }
    else
    {
        for (i = 0; i <= iLast4; i += 4)
        {
            /* setup for rendering this quad */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+3]];

            /* Render the quad (NOTE: i, i+1, i+2, i+3) */
            (*rq)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                  (__GLvertex *) &pd0[aIndices[i+1]],
            (__GLvertex *) &pd0[aIndices[i+2]],
                  (__GLvertex *) &pd0[aIndices[i+3]]);
        }
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawQStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    GLubyte    *aIndices;
    POLYDATA   *pd, *pd0;

    nIndices = pa->nIndices;
    aIndices = pa->aIndices;

    // If we are continuing with a previously decomposed quad strip, we need
    // to start from the last two vertices of the previous primitive.
    //
    // Note that the flush vertex ensures that the continuing quad strip
    // starts at an odd vertex so that it can fall through the normal code.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        // Insert previous end vertices at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[1]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[1] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[1] == 1,
                     "bad index mapping\n");

        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
        // Assert that aIndices[0] was initialized in Begin
        ASSERTOPENGL(!pa->aIndices || pa->aIndices[0] == 0,
                     "bad index mapping\n");
    }

    // Need at least 4 vertices.

    if (nIndices < 4)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                     "Partial end with insufficient vertices\n");
        return;
    }

    // If the primitive is only partially complete, save the last two
    // vertices for next batch.

    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        pd0 = pa->pd0;
        pd  = aIndices ? &pd0[aIndices[nIndices-2]] : &pd0[nIndices-2];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd);
        pd  = aIndices ? &pd0[aIndices[nIndices-1]] : &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[1], pd);

        // Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
            return;
#endif
    }

    // Assert that pa->nIndices is correct if aIndices is identity
    ASSERTOPENGL(pa->aIndices || pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Render the quad strip.

    // Call PolyArrayRenderQStrip later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderQStrip(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      i, iLast4;
    GLubyte    *aIndices;
    POLYDATA   *pd0;
    void (*rq)(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1, __GLvertex *v2,
               __GLvertex *v3);

    iLast4 = pa->nIndices - 4;
    pd0    = pa->pd0;
    rq = pa->orClipCodes ? PARenderQuadSlow : PARenderQuadFast;
    if (iLast4 < 0)
        return;

    // Vertex ordering is important.  Line stippling uses it.

    if (!(aIndices = pa->aIndices))
    {
        // Identity mapping
        // Initialize first 2 vertices so we can start rendering the quad
        // below. The edge flags are not modified by our lower level routines.
        pd0[0].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[1].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        for (i = 0; i <= iLast4; i += 2)
        {
            /* setup for rendering this quad */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[i+3];
            pd0[i+2].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
            pd0[i+3].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the quad (NOTE: i, i+1, i+3, i+2) */
            (*rq)(gc, (__GLvertex *) &pd0[i  ],
                  (__GLvertex *) &pd0[i+1],
            (__GLvertex *) &pd0[i+3],
                  (__GLvertex *) &pd0[i+2]);
        }
    }
    else
    {
        // Initialize first 2 vertices so we can start rendering the quad
        // below.  The edge flags are not modified by our lower level routines.
        pd0[aIndices[0]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
        pd0[aIndices[1]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

        for (i = 0; i <= iLast4; i += 2)
        {
            /* setup for rendering this quad */
            gc->line.notResetStipple = GL_FALSE;
            gc->vertex.provoking = (__GLvertex *) &pd0[aIndices[i+3]];
            pd0[aIndices[i+2]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;
            pd0[aIndices[i+3]].flags |= POLYDATA_EDGEFLAG_BOUNDARY;

            /* Render the quad (NOTE: i, i+1, i+3, i+2) */
            (*rq)(gc, (__GLvertex *) &pd0[aIndices[i  ]],
                  (__GLvertex *) &pd0[aIndices[i+1]],
            (__GLvertex *) &pd0[aIndices[i+3]],
                  (__GLvertex *) &pd0[aIndices[i+2]]);
        }
    }
}

// ---------------------------------------------------------
#ifndef NEW_PARTIAL_PRIM
void FASTCALL PolyArrayDrawPolygon(__GLcontext *gc, POLYARRAY *pa)
{
    GLint      nIndices;
    POLYDATA   *pd, *pd0;

    // Index mapping is always identity in Polygon.

    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

    nIndices = pa->nIndices;

    // If we are continuing with a previously decomposed polygon, we need to
    // insert the original first vertex and the last two vertices of the
    // previous polygon at the beginning of the current batch(see note below).
    // The decomposer expects the polygon vertices to be in sequential memory
    // order.

    if (pa->flags & POLYARRAY_PARTIAL_BEGIN)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_RESET_STIPPLE),
                     "bad stipple reset flag!\n");

        // Insert previous end vertices at the beginning and update clip code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[2]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif

        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[1]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif

        // Insert the origin first vertex at the beginning and update clip
        // code
        pd = --pa->pd0;
        ASSERTOPENGL(pd > (POLYDATA *) pa, "vertex underflows\n");
        PA_COPY_PROCESSED_VERTEX(pd, &gc->vertex.pdSaved[0]);
        pa->orClipCodes  |= pd->clipCode;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= pd->clipCode;
#endif
    }
    else
    {
      // New polygon.

      ASSERTOPENGL(pa->flags & POLYARRAY_RESET_STIPPLE,
                   "bad stipple reset flag!\n");
    }

// Need at least 3 vertices.

    if (nIndices < 3)
    {
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_END),
                     "Partial end with insufficient vertices\n");
        ASSERTOPENGL(!(pa->flags & POLYARRAY_PARTIAL_BEGIN),
                     "Partial begin with insufficient vertices\n");
        return;
    }

    // If the primitive is only partially complete, save the last 2 vertices
    // for next batch.  Also save the original first vertex of the polygon.

    if (pa->flags & POLYARRAY_PARTIAL_END)
    {
        // Since there may be no vertex following this partial primitive, we
        // cannot determine the edge flag of the last vertex in this batch.
        // So we save the last vertex for next batch instead.

        pd0 = pa->pd0;
        pd  = &pd0[nIndices-1];
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[2], pd);

        // Remove the last vertex from this partial primitive
        nIndices = --pa->nIndices;
        pa->pdNextVertex--;

        // Mark the closing edge of this decomposed polygon as non-boundary
        // because we are synthetically generating it.

        pd--;
        PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[1], pd);
        pd->flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;

        if (!(pa->flags & POLYARRAY_PARTIAL_BEGIN))
        {
            PA_COPY_PROCESSED_VERTEX(&gc->vertex.pdSaved[0], pd0);

            // Mark the first polygon vertex's edge tag as non-boundary
            // because when it gets rendered again it will no longer be
            // a boundary edge.
            gc->vertex.pdSaved[0].flags &= ~POLYDATA_EDGEFLAG_BOUNDARY;
        }

        // Need not render this partial primitive if it is completely clipped.

#ifdef POLYARRAY_AND_CLIPCODES
        if (pa->andClipCodes != 0)
            return;
#endif
    }

    // The polygon clipper can only handle this many vertices.
    ASSERTOPENGL(nIndices <= __GL_MAX_POLYGON_CLIP_SIZE,
                 "too many points for the polygon clipper!\n");

    // Assert that pa->nIndices is correct
    ASSERTOPENGL(pa->nIndices == pa->pdNextVertex - pa->pd0,
                 "bad nIndices\n");

    // Render the polygon.

    // Call PolyArrayRenderPolygon later
    pa->flags |= POLYARRAY_RENDER_PRIMITIVE;
}
#endif // NEW_PARTIAL_PRIM

void FASTCALL PolyArrayRenderPolygon(__GLcontext *gc, POLYARRAY *pa)
{
    // Index mapping is always identity in Polygon.

    ASSERTOPENGL(!pa->aIndices, "Index mapping must be identity\n");

    // Reset the line stipple if this is a new polygon.

    if (pa->flags & POLYARRAY_RESET_STIPPLE)
        gc->line.notResetStipple = GL_FALSE;

    // Note that the provoking vertex is set to pd0 in clipPolygon

    (*gc->procs.clipPolygon)(gc, (__GLvertex *) pa->pd0, pa->nIndices);
}

/****************************************************************************/
// Note: The first vertex must have a valid normal!
//
// IN:  obj/eye, normal
// OUT: eye, color.r (front or back depending on face) (all vertices are
//      updated)

void FASTCALL PolyArrayCalcCIColor(__GLcontext *gc, GLint face, POLYARRAY *pa, POLYDATA *pdFirst, POLYDATA *pdLast)
{
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourceMachine *lsm;
    __GLmaterialState *ms;
    __GLmaterialMachine *msm;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;
    __GLfloat ms_cmapa, ms_cmapd, ms_cmaps;
    __GLfloat si, di;
    POLYDATA  *pd;
    GLfloat   redMaxF;
    GLint     redMaxI;
    GLboolean eyeWIsZero, localViewer;
    static __GLcoord Pe = { 0, 0, 0, 1 };
#ifdef GL_WIN_specular_fog
    __GLfloat fog;
#endif //GL_WIN_specular_fog

    PERF_CHECK(FALSE, "Uses slow lights\n");

    zero = __glZero;

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        msm = &gc->light.front;
    }
    else
    {
        ms  = &gc->state.light.back;
        msm = &gc->light.back;
    }

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    ms_cmapa = ms->cmapa;
    ms_cmapd = ms->cmapd;
    ms_cmaps = ms->cmaps;
    localViewer = gc->state.light.model.localViewer;
    redMaxF = (GLfloat) gc->frontBuffer.redMax;
    redMaxI = (GLint) gc->frontBuffer.redMax;

// Eye coord should have been processed

    ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, "need eye\n");

// NOTE: the following values may be re-used in the next iteration:
//       nxi, nyi, nzi

    for (pd = pdFirst; pd <= pdLast; pd++)
    {
        __GLfloat ci;

        if (pd->flags & POLYDATA_NORMAL_VALID)
        {
            if (face == __GL_FRONTFACE)
            {
            nxi = pd->normal.x;
            nyi = pd->normal.y;
            nzi = pd->normal.z;
            }
            else
            {
            nxi = -pd->normal.x;
            nyi = -pd->normal.y;
            nzi = -pd->normal.z;
            }
        }
        else
        {
            // use previous normal (nxi, nyi, nzi)!
#ifdef GL_WIN_specular_fog
            // use previous fog (fog)!
#endif  //GL_WIN_specular_fog
            ASSERTOPENGL(pd != pdFirst, "no initial normal\n");
        }

        si = zero;
        di = zero;
        eyeWIsZero = __GL_FLOAT_EQZ(pd->eye.w);
#ifdef GL_WIN_specular_fog
        // Initialize Fog value to 0 here;
        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            ASSERTOPENGL (face == __GL_FRONTFACE,
                          "Specular fog works for only GL_FRONT\n");
            fog = __glZero;
        }
#endif //GL_WIN_specular_fog


        for (lsm = gc->light.sources; lsm; lsm = lsm->next)
        {
            if (lsm->slowPath || eyeWIsZero)
            {
                __GLfloat n1, n2, att, attSpot;
                __GLcoord vPliHat, vPli, hHat, vPeHat;
                __GLfloat hv[3];

                /* Compute vPli, hi (normalized) */
                __glVecSub4(&vPli, &pd->eye, &lsm->position);
                __glNormalize(&vPliHat.x, &vPli.x);
                if (localViewer)
                {
                    __glVecSub4(&vPeHat, &pd->eye, &Pe);
                    __glNormalize(&vPeHat.x, &vPeHat.x);
                    hv[0] = vPliHat.x + vPeHat.x;
                    hv[1] = vPliHat.y + vPeHat.y;
                    hv[2] = vPliHat.z + vPeHat.z;
                }
                else
                {
                    hv[0] = vPliHat.x;
                    hv[1] = vPliHat.y;
                    hv[2] = vPliHat.z + __glOne;
                }
                __glNormalize(&hHat.x, hv);

                /* Compute attenuation */
                if (__GL_FLOAT_NEZ(lsm->position.w))
                {
                    __GLfloat k0, k1, k2, dist;

                    k0 = lsm->constantAttenuation;
                    k1 = lsm->linearAttenuation;
                    k2 = lsm->quadraticAttenuation;
                    if (__GL_FLOAT_EQZ(k1) && __GL_FLOAT_EQZ(k2))
                    {
                        /* Use pre-computed 1/k0 */
                        att = lsm->attenuation;
                    }
                    else
                    {

                dist = __GL_SQRTF(vPli.x*vPli.x + vPli.y*vPli.y
                                  + vPli.z*vPli.z);
                att = __glOne / (k0 + k1 * dist + k2 * dist * dist);
                    }
                }
                else
                {
                    att = __glOne;
                }

                /* Compute spot effect if light is a spot light */
                attSpot = att;
                if (lsm->isSpot)
                {
                    __GLfloat dot, px, py, pz;

                    px = -vPliHat.x;
                    py = -vPliHat.y;
                    pz = -vPliHat.z;
                    dot = px * lsm->direction.x + py * lsm->direction.y
                        + pz * lsm->direction.z;
                    if ((dot >= lsm->threshold) && (dot >= lsm->cosCutOffAngle))
                    {
                        GLint ix = (GLint)((dot - lsm->threshold) * lsm->scale
                                    + __glHalf);
                        if (ix < __GL_SPOT_LOOKUP_TABLE_SIZE)
                            attSpot = att * lsm->spotTable[ix];
                    }
                    else
                    {
                        attSpot = zero;
                    }
                }

                /* Add in remaining effect of light, if any */
                if (attSpot)
                {
                    n1 = nxi * vPliHat.x + nyi * vPliHat.y + nzi * vPliHat.z;
                    if (__GL_FLOAT_GTZ(n1)) {
                        n2 = nxi * hHat.x + nyi * hHat.y + nzi * hHat.z;
                        n2 -= msm_threshold;
                        if (__GL_FLOAT_GEZ(n2))
                        {
#ifdef NT
                            __GLfloat fx = n2 * msm_scale + __glHalf;
                            if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                                n2 = msm_specTable[(GLint)fx];
                            else
                                n2 = __glOne;
#ifdef GL_WIN_specular_fog
                            if (gc->polygon.shader.modeFlags &
                                __GL_SHADE_SPEC_FOG)
                            {
                                fog += attSpot * n2;
                            }
#endif //GL_WIN_specular_fog
#else
                            GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                            if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                                n2 = msm_specTable[ix];
                            else
                                n2 = __glOne;
#endif
                            si += attSpot * n2 * lsm->sli;
                        }
                        di += attSpot * n1 * lsm->dli;
                    }
                }
            }
            else
            {
                __GLfloat n1, n2;

                /* Compute specular contribution */
                n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                    nzi * lsm->unitVPpli.z;
                if (__GL_FLOAT_GTZ(n1))
                {
                    n2 = nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                    n2 -= msm_threshold;
                    if (__GL_FLOAT_GEZ(n2))
                    {
#ifdef NT
                        __GLfloat fx = n2 * msm_scale + __glHalf;
                        if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                            n2 = msm_specTable[(GLint)fx];
                        else
                            n2 = __glOne;
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags &
                            __GL_SHADE_SPEC_FOG)
                        {
                            fog += n2;
                        }
#endif //GL_WIN_specular_fog
#else
                        GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                        if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                            n2 = msm_specTable[ix];
                        else
                            n2 = __glOne;
#endif
                        si += n2 * lsm->sli;
                    }
                    di += n1 * lsm->dli;
                }
            }
        }

        /* Compute final color */
        if (si > __glOne)
            si = __glOne;

        ci = ms_cmapa + (__glOne - si) * di * (ms_cmapd - ms_cmapa)
            + si * (ms_cmaps - ms_cmapa);
        if (ci > ms_cmaps)
            ci = ms_cmaps;

// need to mask color index before color clipping

        if (ci > redMaxF) {
            GLfloat fraction;
            GLint integer;

            integer = (GLint) ci;
            fraction = ci - (GLfloat) integer;
            integer = integer & redMaxI;
            ci = (GLfloat) integer + fraction;
        } else if (ci < 0) {
            GLfloat fraction;
            GLint integer;

            integer = (GLint) __GL_FLOORF(ci);
            fraction = ci - (GLfloat) integer;
            integer = integer & redMaxI;
            ci = (GLfloat) integer + fraction;
        }
        pd->colors[face].r = ci;
#ifdef GL_WIN_specular_fog
        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            pd->fog = 1.0 - fog;
            if (__GL_FLOAT_LTZ (pd->fog)) pd->fog = __glZero;
        }
#endif //GL_WIN_specular_fog
    }
}


// No slow lights version
// Note: The first vertex must have a valid normal!
//
// IN:  normal
// OUT: color.r (front or back depending on face) (all vertices are updated)

void FASTCALL PolyArrayFastCalcCIColor(__GLcontext *gc, GLint face, POLYARRAY *pa, POLYDATA *pdFirst, POLYDATA *pdLast)
{
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourceMachine *lsm;
    __GLmaterialState *ms;
    __GLmaterialMachine *msm;
    __GLfloat msm_threshold, msm_scale, *msm_specTable;
    __GLfloat ms_cmapa, ms_cmapd, ms_cmaps;
    __GLfloat si, di;
    POLYDATA  *pd;
    GLfloat   redMaxF;
    GLint     redMaxI;
#ifdef GL_WIN_specular_fog
    __GLfloat fog;
#endif //GL_WIN_specular_fog

#if LATER
// if eye.w is zero, it should really take the slow path!
// Since the RGB version ignores it, we will also ignore it here.
// Even the original generic implementation may not have computed eye values.
#endif

    zero = __glZero;

    if (face == __GL_FRONTFACE)
    {
        ms  = &gc->state.light.front;
        msm = &gc->light.front;
    }
    else
    {
        ms  = &gc->state.light.back;
        msm = &gc->light.back;
    }

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    ms_cmapa = ms->cmapa;
    ms_cmapd = ms->cmapd;
    ms_cmaps = ms->cmaps;
    redMaxF = (GLfloat) gc->frontBuffer.redMax;
    redMaxI = (GLint) gc->frontBuffer.redMax;

// NOTE: the following values may be re-used in the next iteration:
//       nxi, nyi, nzi

    for (pd = pdFirst; pd <= pdLast; pd++)
    {
        __GLfloat ci;

        // If normal has not changed for this vertex, use the previously
        // computed color index.

        if (!(pd->flags & POLYDATA_NORMAL_VALID))
        {
            ASSERTOPENGL(pd != pdFirst, "no initial normal\n");
            pd->colors[face].r = (pd-1)->colors[face].r;
#ifdef GL_WIN_specular_fog
            // Initialize Fog value to 0 here;
            if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
            {
                ASSERTOPENGL (face == __GL_FRONTFACE,
                              "Specular fog works for only GL_FRONT\n");
                pd->fog = (pd-1)->fog;
            }
#endif //GL_WIN_specular_fog
            continue;
        }

        if (face == __GL_FRONTFACE)
        {
            nxi = pd->normal.x;
            nyi = pd->normal.y;
            nzi = pd->normal.z;
        }
        else
        {
            nxi = -pd->normal.x;
            nyi = -pd->normal.y;
            nzi = -pd->normal.z;
        }

        si = zero;
        di = zero;
#ifdef GL_WIN_specular_fog
        // Initialize Fog value to 0 here;
        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            fog = __glZero;
        }
#endif //GL_WIN_specular_fog

        for (lsm = gc->light.sources; lsm; lsm = lsm->next)
        {
            __GLfloat n1, n2;

            /* Compute specular contribution */
            n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
            nzi * lsm->unitVPpli.z;
            if (__GL_FLOAT_GTZ(n1))
        {
            n2 = nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
            n2 -= msm_threshold;
            if (__GL_FLOAT_GEZ(n2))
            {
#ifdef NT
                __GLfloat fx = n2 * msm_scale + __glHalf;
                if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                    n2 = msm_specTable[(GLint)fx];
                else
                    n2 = __glOne;
#else
                    GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                    if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                        n2 = msm_specTable[ix];
                    else
                        n2 = __glOne;
#endif
                si += n2 * lsm->sli;
#ifdef GL_WIN_specular_fog
                    if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                    {
                        fog += n2;
                    }
#endif //GL_WIN_specular_fog
            }
            di += n1 * lsm->dli;
        }
        }

        /* Compute final color */
        if (si > __glOne)
            si = __glOne;

        ci = ms_cmapa + (__glOne - si) * di * (ms_cmapd - ms_cmapa)
            + si * (ms_cmaps - ms_cmapa);
        if (ci > ms_cmaps)
            ci = ms_cmaps;

// need to mask color index before color clipping
// SGIBUG: The sample implementation fails to do this!

        if (ci > redMaxF) {
            GLfloat fraction;
            GLint integer;

            integer = (GLint) ci;
            fraction = ci - (GLfloat) integer;
            integer = integer & redMaxI;
            ci = (GLfloat) integer + fraction;
        } else if (ci < 0) {
            GLfloat fraction;
            GLint integer;

            integer = (GLint) __GL_FLOORF(ci);
            fraction = ci - (GLfloat) integer;
            integer = integer & redMaxI;
            ci = (GLfloat) integer + fraction;
        }
        pd->colors[face].r = ci;
#ifdef GL_WIN_specular_fog
        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
        {
            pd->fog = 1.0 - fog;
            if (__GL_FLOAT_LTZ (pd->fog)) pd->fog = __glZero;
        }
#endif //GL_WIN_specular_fog
    }
}


// If both front and back colors are needed, the back colors must be computed
// first!  Otherwise, the front colors can be overwritten prematurely.
// Note: The first vertex must have valid normal and color!
//
// IN:  obj/eye, color (front), normal
// OUT: eye, color (front or back depending on face) (all vertices are updated)

void FASTCALL PolyArrayCalcRGBColor(__GLcontext *gc, GLint face, POLYARRAY *pa, POLYDATA *pdFirst, POLYDATA *pdLast)
{
    __GLfloat nxi, nyi, nzi;
    __GLfloat zero;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat ri, gi, bi;
    __GLfloat alpha;
    __GLfloat rsi, gsi, bsi;
    __GLcolor sceneColorI;
    __GLmaterialMachine *msm;
    __GLcolor lm_ambient;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    __GLcolor msm_paSceneColor;
    GLuint    msm_colorMaterialChange;
    POLYDATA  *pd;
    GLboolean eyeWIsZero, localViewer;
    static __GLcoord Pe = { 0, 0, 0, 1 };
#ifdef GL_WIN_specular_fog
    __GLfloat fog;
#endif //GL_WIN_specular_fog

    PERF_CHECK(FALSE, "Uses slow lights\n");

    zero = __glZero;

    // Eye coord should have been processed

    ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, "need eye\n");

    if (face == __GL_FRONTFACE)
        msm = &gc->light.front;
    else
        msm = &gc->light.back;

    lm_ambient.r = gc->state.light.model.ambient.r;
    lm_ambient.g = gc->state.light.model.ambient.g;
    lm_ambient.b = gc->state.light.model.ambient.b;

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;
    msm_colorMaterialChange = msm->colorMaterialChange;
    msm_paSceneColor = msm->paSceneColor;

    localViewer = gc->state.light.model.localViewer;

    // Get invarient scene color if there is no ambient or emissive color
    // material.

    sceneColorI.r = msm_paSceneColor.r;
    sceneColorI.g = msm_paSceneColor.g;
    sceneColorI.b = msm_paSceneColor.b;

    // NOTE: the following values may be re-used in the next iteration:
    //       ri, gi, bi, alpha, nxi, nyi, nzi, sceneColorI

    for (pd = pdFirst; pd <= pdLast; pd++)
    {
        if (pd->flags & POLYDATA_COLOR_VALID)
        {
            // Save latest colors normalized to 0..1

            ri = pd->colors[0].r * gc->oneOverRedVertexScale;
            gi = pd->colors[0].g * gc->oneOverGreenVertexScale;
            bi = pd->colors[0].b * gc->oneOverBlueVertexScale;
            alpha = pd->colors[0].a;

            // Compute scene color.
            // If color has not changed, the previous sceneColorI values are
            // used!

            if (msm_colorMaterialChange & (__GL_MATERIAL_AMBIENT |
                                           __GL_MATERIAL_EMISSIVE))
            {
                if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
                {
                    sceneColorI.r = msm_paSceneColor.r + ri * lm_ambient.r;
                    sceneColorI.g = msm_paSceneColor.g + gi * lm_ambient.g;
                    sceneColorI.b = msm_paSceneColor.b + bi * lm_ambient.b;
                }
                else
                {
                    sceneColorI.r = msm_paSceneColor.r + pd->colors[0].r;
                    sceneColorI.g = msm_paSceneColor.g + pd->colors[0].g;
                    sceneColorI.b = msm_paSceneColor.b + pd->colors[0].b;
                }
            }
        }
        else
        {
            // use previous ri, gi, bi, alpha, and sceneColorI!
            ASSERTOPENGL(pd != pdFirst, "no initial color\n");
        }

        // Compute the diffuse and specular components for this vertex.

        if (pd->flags & POLYDATA_NORMAL_VALID)
        {
            if (face == __GL_FRONTFACE)
            {
                nxi = pd->normal.x;
                nyi = pd->normal.y;
                nzi = pd->normal.z;
            }
            else
            {
                nxi = -pd->normal.x;
                nyi = -pd->normal.y;
                nzi = -pd->normal.z;
            }
#ifdef GL_WIN_specular_fog
            // Initialize Fog value to 0 here;
            if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
            {
                ASSERTOPENGL (face == __GL_FRONTFACE,
                              "Specular fog works for only GL_FRONT\n");
                fog = __glZero;
            }
#endif //GL_WIN_specular_fog
        }
        else
        {
            // use previous normal (nxi, nyi, nzi)!
            ASSERTOPENGL(pd != pdFirst, "no initial normal\n");
#ifdef GL_WIN_specular_fog
            // use previous fog (fog)!
#endif //GL_WIN_specular_fog
        }

        rsi = sceneColorI.r;
        gsi = sceneColorI.g;
        bsi = sceneColorI.b;

        eyeWIsZero = __GL_FLOAT_EQZ(pd->eye.w);

        for (lsm = gc->light.sources; lsm; lsm = lsm->next)
        {
            __GLfloat n1, n2;

            lss = lsm->state;
            lspmm = &lsm->front + face;

            if (lsm->slowPath || eyeWIsZero)
            {
                __GLcoord hHat, vPli, vPliHat, vPeHat;
                __GLfloat att, attSpot;
                __GLfloat hv[3];

                /* Compute unit h[i] */
                __glVecSub4(&vPli, &pd->eye, &lsm->position);
                __glNormalize(&vPliHat.x, &vPli.x);
                if (localViewer)
                {
                    __glVecSub4(&vPeHat, &pd->eye, &Pe);
                    __glNormalize(&vPeHat.x, &vPeHat.x);
                    hv[0] = vPliHat.x + vPeHat.x;
                    hv[1] = vPliHat.y + vPeHat.y;
                    hv[2] = vPliHat.z + vPeHat.z;
                }
                else
                {
                    hv[0] = vPliHat.x;
                    hv[1] = vPliHat.y;
                    hv[2] = vPliHat.z + __glOne;
                }
                __glNormalize(&hHat.x, hv);

                /* Compute attenuation */
                if (__GL_FLOAT_NEZ(lsm->position.w))
                {
                    __GLfloat k0, k1, k2, dist;

                    k0 = lsm->constantAttenuation;
                    k1 = lsm->linearAttenuation;
                    k2 = lsm->quadraticAttenuation;
                    if (__GL_FLOAT_EQZ(k1) && __GL_FLOAT_EQZ(k2))
                    {
                        /* Use pre-computed 1/k0 */
                        att = lsm->attenuation;
                    }
                    else
                    {
                        dist = __GL_SQRTF(vPli.x*vPli.x + vPli.y*vPli.y
                                      + vPli.z*vPli.z);
                        att = __glOne / (k0 + k1 * dist + k2 * dist * dist);
                    }
                }
                else
                {
                    att = __glOne;
                }

                /* Compute spot effect if light is a spot light */
                attSpot = att;
                if (lsm->isSpot)
                {
                    __GLfloat dot, px, py, pz;

                    px = -vPliHat.x;
                    py = -vPliHat.y;
                    pz = -vPliHat.z;
                    dot = px * lsm->direction.x + py * lsm->direction.y
                      + pz * lsm->direction.z;
                    if ((dot >= lsm->threshold) && (dot >= lsm->cosCutOffAngle))
                      {
                        GLint ix = (GLint)((dot - lsm->threshold) * lsm->scale
                                           + __glHalf);
                        if (ix < __GL_SPOT_LOOKUP_TABLE_SIZE)
                          attSpot = att * lsm->spotTable[ix];
                      }
                    else
                      {
                        attSpot = zero;
                      }
                }

                /* Add in remaining effect of light, if any */
                if (attSpot)
                {
                    __GLfloat n1, n2;
                    __GLcolor sum;

                    if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
                    {
                        sum.r = ri * lss->ambient.r;
                        sum.g = gi * lss->ambient.g;
                        sum.b = bi * lss->ambient.b;
                    }
                    else
                    {
                        sum.r = lspmm->ambient.r;
                        sum.g = lspmm->ambient.g;
                        sum.b = lspmm->ambient.b;
                    }

                    n1 = nxi * vPliHat.x + nyi * vPliHat.y + nzi * vPliHat.z;
                    if (__GL_FLOAT_GTZ(n1))
                    {
                        n2 = nxi * hHat.x + nyi * hHat.y + nzi * hHat.z;
                        n2 -= msm_threshold;
                        if (__GL_FLOAT_GEZ(n2))
                        {
#ifdef NT
                            __GLfloat fx = n2 * msm_scale + __glHalf;
                            if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                              n2 = msm_specTable[(GLint)fx];
                            else
                              n2 = __glOne;
#ifdef GL_WIN_specular_fog
                            if (gc->polygon.shader.modeFlags &
                                __GL_SHADE_SPEC_FOG)
                            {
                                fog += attSpot * n2;
                            }
#endif //GL_WIN_specular_fog
#else
                            GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                            if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                              n2 = msm_specTable[ix];
                            else
                              n2 = __glOne;
#endif
                            if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                            {
                                /* Recompute per-light per-material cached specular */
                                sum.r += n2 * ri * lss->specular.r;
                                sum.g += n2 * gi * lss->specular.g;
                                sum.b += n2 * bi * lss->specular.b;
                            }
                            else
                            {
                                sum.r += n2 * lspmm->specular.r;
                                sum.g += n2 * lspmm->specular.g;
                                sum.b += n2 * lspmm->specular.b;
                            }
                        }
                        if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
                          {
                            /* Recompute per-light per-material cached diffuse */
                            sum.r += n1 * ri * lss->diffuse.r;
                            sum.g += n1 * gi * lss->diffuse.g;
                            sum.b += n1 * bi * lss->diffuse.b;
                          }
                        else
                          {
                            sum.r += n1 * lspmm->diffuse.r;
                            sum.g += n1 * lspmm->diffuse.g;
                            sum.b += n1 * lspmm->diffuse.b;
                          }
                    }

                    rsi += attSpot * sum.r;
                    gsi += attSpot * sum.g;
                    bsi += attSpot * sum.b;
                }
            }
            else
            {
                __GLfloat n1, n2;

                if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT)
                {
                    rsi += ri * lss->ambient.r;
                    gsi += gi * lss->ambient.g;
                    bsi += bi * lss->ambient.b;
                }
                else
                {
                    rsi += lspmm->ambient.r;
                    gsi += lspmm->ambient.g;
                    bsi += lspmm->ambient.b;
                }

                /* Add in specular and diffuse effect of light, if any */
                n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                  nzi * lsm->unitVPpli.z;
                if (__GL_FLOAT_GTZ(n1))
                {
                    n2 = nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                    n2 -= msm_threshold;
                    if (__GL_FLOAT_GEZ(n2)) {
#ifdef NT
                      __GLfloat fx = n2 * msm_scale + __glHalf;
                      if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE )
                        n2 = msm_specTable[(GLint)fx];
                      else
                        n2 = __glOne;
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags &
                            __GL_SHADE_SPEC_FOG)
                        {
                            fog += n2;
                        }
#endif //GL_WIN_specular_fog
#else
                      GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                      if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                        n2 = msm_specTable[ix];
                      else
                        n2 = __glOne;
#endif
                      if (msm_colorMaterialChange & __GL_MATERIAL_SPECULAR)
                        {
                            /* Recompute per-light per-material cached
                               specular */
                          rsi += n2 * ri * lss->specular.r;
                          gsi += n2 * gi * lss->specular.g;
                          bsi += n2 * bi * lss->specular.b;
                        }
                      else
                        {
                          rsi += n2 * lspmm->specular.r;
                          gsi += n2 * lspmm->specular.g;
                          bsi += n2 * lspmm->specular.b;
                        }
                    }
                    if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
                      {
                        /* Recompute per-light per-material cached diffuse */
                        rsi += n1 * ri * lss->diffuse.r;
                        gsi += n1 * gi * lss->diffuse.g;
                        bsi += n1 * bi * lss->diffuse.b;
                      }
                    else
                      {
                        rsi += n1 * lspmm->diffuse.r;
                        gsi += n1 * lspmm->diffuse.g;
                        bsi += n1 * lspmm->diffuse.b;
                      }
                }
            }
        }

        {
            __GLcolor *pd_color_dst;

            pd_color_dst = &pd->colors[face];

            __GL_CLAMP_RGB(pd_color_dst->r,
                           pd_color_dst->g,
                           pd_color_dst->b,
                           gc, rsi, gsi, bsi);

            if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
            {
                if (pa->flags & POLYARRAY_CLAMP_COLOR)
                {
                    __GL_CLAMP_A(pd_color_dst->a, gc, alpha);
                }
                else
                    pd_color_dst->a = alpha;
            }
            else
            {
                pd_color_dst->a = msm_alpha;
            }
#ifdef GL_WIN_specular_fog
            if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
            {
                  pd->fog = 1.0 - fog;
                  if (__GL_FLOAT_LTZ (pd->fog)) pd->fog = __glZero;
            }
#endif //GL_WIN_specular_fog
        }
    }
}

// If both front and back colors are needed, the back color must be computed
// first!  Otherwise, the front color can be overwritten prematurely.
// Note: The first vertex must have valid normal and color!
//
// IN:  color (front), normal
// OUT: color (front or back depending on face) (all vertices are updated)

#ifndef __GL_ASM_POLYARRAYFASTCALCRGBCOLOR
void FASTCALL PolyArrayFastCalcRGBColor(__GLcontext *gc, GLint face, POLYARRAY *pa, POLYDATA *pdFirst, POLYDATA *pdLast)
{
    __GLfloat nxi, nyi, nzi;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat ri, gi, bi;
    __GLfloat alpha;
        // Don't use a structure.  Compiler wants to store it on the stack,
        // even though that's not necessary.
    __GLfloat baseEmissiveAmbient_r, emissiveAmbientI_r, diffuseSpecularI_r;
    __GLfloat baseEmissiveAmbient_g, emissiveAmbientI_g, diffuseSpecularI_g;
    __GLfloat baseEmissiveAmbient_b, emissiveAmbientI_b, diffuseSpecularI_b;
    __GLfloat lm_ambient_r;
        __GLfloat lm_ambient_g;
        __GLfloat lm_ambient_b;
    __GLmaterialMachine *msm, *msm_front, *msm_back;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    GLuint    msm_colorMaterialChange;
    POLYDATA  *pd;
        __GLfloat diff_r, diff_g, diff_b;
        __GLfloat spec_r, spec_g, spec_b;
        __GLcolor *lss_diff_color, *lss_spec_color;
        __GLcolor *lspmm_diff_color, *lspmm_spec_color;
        __GLcolor *diff_color, *spec_color;
        GLuint use_material_diffuse, use_material_specular;
        GLuint use_material_ambient, use_material_emissive;
        __GLfloat spec_r_sum, spec_g_sum, spec_b_sum;
        __GLfloat diff_r_sum, diff_g_sum, diff_b_sum;
        __GLfloat ambient_r_sum, ambient_g_sum, ambient_b_sum;
        GLuint pd_flags, normal_valid, color_valid;
#ifdef GL_WIN_specular_fog
    __GLfloat fog;
#endif //GL_WIN_specular_fog


#if LATER
        // if eye.w is zero, it should really take the slow path!
        // Since the sample implementation ignores it, we will also ignore it here.
#endif

    PERF_CHECK(FALSE, "Primitives contain glColorMaterial calls\n");

        msm_front = &gc->light.front;
        msm_back = &gc->light.back;
        msm = msm_back;
    if (face == __GL_FRONTFACE)
                msm = msm_front;

        // If there is no color material change for this face, we can call the
        // zippy function!

    msm_colorMaterialChange = msm->colorMaterialChange;
    if (!msm_colorMaterialChange)
    {
                PolyArrayZippyCalcRGBColor(gc, face, pa, pdFirst, pdLast);
                return;
    }

        // Compute invarient emissive and ambient components for this vertex.

    lm_ambient_r = gc->state.light.model.ambient.r;
    lm_ambient_g = gc->state.light.model.ambient.g;
    lm_ambient_b = gc->state.light.model.ambient.b;

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;

    use_material_ambient = msm_colorMaterialChange & __GL_MATERIAL_AMBIENT;
    use_material_emissive = msm_colorMaterialChange & __GL_MATERIAL_EMISSIVE;

    if (!use_material_ambient) {
        baseEmissiveAmbient_r = msm->cachedEmissiveAmbient.r;
        baseEmissiveAmbient_g = msm->cachedEmissiveAmbient.g;
        baseEmissiveAmbient_b = msm->cachedEmissiveAmbient.b;
    } else {
        baseEmissiveAmbient_r = msm->paSceneColor.r;
        baseEmissiveAmbient_g = msm->paSceneColor.g;
        baseEmissiveAmbient_b = msm->paSceneColor.b;
    }

        // If there is no emissive or ambient color material change, this
        // will be the emissive and ambient components.

        emissiveAmbientI_r = baseEmissiveAmbient_r;
        emissiveAmbientI_g = baseEmissiveAmbient_g;
        emissiveAmbientI_b = baseEmissiveAmbient_b;

        use_material_diffuse = msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE;
        use_material_specular = msm_colorMaterialChange & __GL_MATERIAL_SPECULAR;

        // NOTE: the following values may be re-used in the next iteration:
        //       ri, gi, bi, alpha, nxi, nyi, nzi, emissiveAmbientI, diffuseSpecularI

        for (pd = pdFirst; pd <= pdLast; pd++)
        {
                // If color and normal have not changed for this vertex, use the previously
                // computed color.

                pd_flags = pd->flags;
                normal_valid = pd_flags & POLYDATA_NORMAL_VALID;
                color_valid = pd_flags & POLYDATA_COLOR_VALID;

                if (!(normal_valid || color_valid))
                {
                        ASSERTOPENGL(pd != pdFirst, "no initial normal and color\n");
                        pd->colors[face] = (pd-1)->colors[face];
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                        {
                                pd->fog = (pd-1)->fog;
                        }
#endif //GL_WIN_specular_fog
                        continue;
                }

                if (color_valid)
                {
                        __GLfloat pd_r, pd_g, pd_b;

            // Save latest colors normalized to 0..1

                        pd_r = pd->colors[0].r;
                        pd_g = pd->colors[0].g;
                        pd_b = pd->colors[0].b;
                        ri = pd_r * gc->oneOverRedVertexScale;
                        gi = pd_g * gc->oneOverGreenVertexScale;
                        bi = pd_b * gc->oneOverBlueVertexScale;
                        alpha = pd->colors[0].a;

                        // Compute the emissive and ambient components for this vertex if necessary.
                        // If color has not changed, the previous emissveAmbientI values are used!

                        if (use_material_ambient || use_material_emissive)
                        {
                                if (use_material_ambient)
                                {
                                        ambient_r_sum = lm_ambient_r;
                                        ambient_g_sum = lm_ambient_g;
                                        ambient_b_sum = lm_ambient_b;

                                        // Add per-light per-material ambient
                                        for (lsm = gc->light.sources; lsm; lsm = lsm->next)
                                        {
                                                lss = lsm->state;
                                                ambient_r_sum += lss->ambient.r;
                                                ambient_g_sum += lss->ambient.g;
                                                ambient_b_sum += lss->ambient.b;
                                        }

                                        ambient_r_sum *= ri;
                                        ambient_g_sum *= gi;
                                        ambient_b_sum *= bi;

                                        emissiveAmbientI_r = baseEmissiveAmbient_r + ambient_r_sum;
                                        emissiveAmbientI_g = baseEmissiveAmbient_g + ambient_g_sum;
                                        emissiveAmbientI_b = baseEmissiveAmbient_b + ambient_b_sum;

                                }
                                else
                                {
                                        emissiveAmbientI_r = baseEmissiveAmbient_r + pd_r;
                                        emissiveAmbientI_g = baseEmissiveAmbient_g + pd_g;
                                        emissiveAmbientI_b = baseEmissiveAmbient_b + pd_b;
                                }
                        }
                }
                else
                {
                        // use previous ri, gi, bi, alpha, and emissiveAmbientI!
                        ASSERTOPENGL(pd != pdFirst, "no initial color\n");
                }

                // Compute the diffuse and specular components for this vertex.

                if (normal_valid)
                {
                        nxi = pd->normal.x;
                        nyi = pd->normal.y;
                        nzi = pd->normal.z;
                        if (face != __GL_FRONTFACE)
                        {
                                nxi = -nxi;
                                nyi = -nyi;
                                nzi = -nzi;
                        }
#ifdef GL_WIN_specular_fog
            // Initialize Fog value to 0 here;
            if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
            {
                ASSERTOPENGL (face == __GL_FRONTFACE,
                              "Specular fog works for only GL_FRONT\n");
                fog = __glZero;
            }
#endif //GL_WIN_specular_fog

                }
                else
                {
                        ASSERTOPENGL(pd != pdFirst, "no initial normal\n");

                        // If normal and diffuse and specular components have not changed,
                        // use the previously computed diffuse and specular values.
                        // otherwise, use previous normal (nxi, nyi, nzi) and
                        // diffuseSpecularI!

                        if (!(use_material_diffuse || use_material_specular))
                                goto store_color;
                }

                spec_r_sum = (__GLfloat)0.0;
                spec_g_sum = (__GLfloat)0.0;
                spec_b_sum = (__GLfloat)0.0;
                diff_r_sum = (__GLfloat)0.0;
                diff_g_sum = (__GLfloat)0.0;
                diff_b_sum = (__GLfloat)0.0;

                for (lsm = gc->light.sources; lsm; lsm = lsm->next)
                {
                        __GLfloat n1, n2;

                        lss = lsm->state;
                        lspmm = &lsm->front + face;

                        lss_diff_color = &lss->diffuse;
                        lss_spec_color = &lss->specular;
                        lspmm_diff_color = &lspmm->diffuse;
                        lspmm_spec_color = &lspmm->specular;

                        diff_color = lspmm_diff_color;
                        spec_color = lspmm_spec_color;
                        if (use_material_diffuse)
                                diff_color = lss_diff_color;
                        if (use_material_specular)
                                spec_color = lss_spec_color;

                        /* Add in specular and diffuse effect of light, if any */
                        n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
                                nzi * lsm->unitVPpli.z;
                        if (n1 > 0.0)
                        {
                                diff_r = diff_color->r;
                                diff_g = diff_color->g;
                                diff_b = diff_color->b;

                                n2 = nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z;
                                n2 -= msm_threshold;
                                if (n2 >= 0.0)
                                {
                                        __GLfloat fx = n2 * msm_scale + __glHalf;

                                        spec_r = spec_color->r;
                                        spec_g = spec_color->g;
                                        spec_b = spec_color->b;

                                        if( fx < (__GLfloat)__GL_SPEC_LOOKUP_TABLE_SIZE ){
                                                n2 = msm_specTable[(GLint)fx];
                                                spec_r *= n2;
                                                spec_g *= n2;
                                                spec_b *= n2;
                                        }
                                        /* else n2 = 1.0.
                                        Before, we multiplied (spec_r *= n2) in all cases.
                                        But since n2 == 1.0, there's no need to do it in this case.
                                        Thus there is no need to load n2 = 1.0. */

#ifdef GL_WIN_specular_fog
                                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                                        {
                                                pd->fog += n2;
                                        }
#endif //GL_WIN_specular_fog


                                        spec_r_sum += spec_r;
                                        spec_g_sum += spec_g;
                                        spec_b_sum += spec_b;
                                }

                                diff_r *= n1;
                                diff_g *= n1;
                                diff_b *= n1;

                                diff_r_sum += diff_r;
                                diff_g_sum += diff_g;
                                diff_b_sum += diff_b;
                        }
                }

                if (use_material_specular){
                        /* Recompute per-light per-material cached specular */
                        spec_r_sum *= ri;
                        spec_g_sum *= gi;
                        spec_b_sum *= bi;
                }
                if (use_material_diffuse){
                        /* Recompute per-light per-material cached diffuse */
                        diff_r_sum *= ri;
                        diff_g_sum *= gi;
                        diff_b_sum *= bi;
                }

                diffuseSpecularI_r = diff_r_sum + spec_r_sum;
                diffuseSpecularI_g = diff_g_sum + spec_g_sum;
                diffuseSpecularI_b = diff_b_sum + spec_b_sum;


store_color:
                {
                        __GLcolor *pd_color_dst;

                        pd_color_dst = &pd->colors[face];

                        __GL_CLAMP_RGB( pd_color_dst->r,
                                                        pd_color_dst->g,
                                                        pd_color_dst->b,
                                                        gc,
                                                        emissiveAmbientI_r + diffuseSpecularI_r,
                                                        emissiveAmbientI_g + diffuseSpecularI_g,
                                                        emissiveAmbientI_b + diffuseSpecularI_b);

                        if (msm_colorMaterialChange & __GL_MATERIAL_DIFFUSE)
                        {
                                if (pa->flags & POLYARRAY_CLAMP_COLOR)
                                {
                                    __GL_CLAMP_A(pd_color_dst->a, gc, alpha);
                                }
                                else
                                        pd_color_dst->a = alpha;
                        }
                        else
                        {
                                pd_color_dst->a = msm_alpha;
                        }
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                        {
                                pd->fog = 1.0 - fog;
                                if (__GL_FLOAT_LTZ (pd->fog)) pd->fog = __glZero;
                        }
#endif //GL_WIN_specular_fog

                }
        }
}
#endif // __GL_ASM_POLYARRAYFASTCALCRGBCOLOR


// This function is called when color material is disabled and there are no
// slow lights.
//
// Note: The first vertex must have a valid normal!
//
// IN:  normal
// OUT: color (front or back depending on face) (all vertices are updated)

#ifndef __GL_ASM_POLYARRAYZIPPYCALCRGBCOLOR
void FASTCALL PolyArrayZippyCalcRGBColor(__GLcontext *gc, GLint face, POLYARRAY *pa, POLYDATA *pdFirst, POLYDATA *pdLast)
{
    register __GLfloat nxi, nyi, nzi;
    __GLlightSourcePerMaterialMachine *lspmm;
    __GLlightSourceMachine *lsm;
    __GLlightSourceState *lss;
    __GLfloat baseEmissiveAmbient_r, baseEmissiveAmbient_g, baseEmissiveAmbient_b;
    __GLmaterialMachine *msm;
    __GLfloat msm_alpha, msm_threshold, msm_scale, *msm_specTable;
    __GLcolor *pd_color_dst;
    GLboolean notBackface = FALSE;
    POLYDATA  *pd;
    ULONG normal_valid, paneeds_valid;
    register GLfloat diff_r, diff_g, diff_b;
    register GLfloat spec_r, spec_g, spec_b;
    GLfloat lsmx, lsmy, lsmz;
    ULONG fast_path = 0;
#ifdef GL_WIN_specular_fog
    __GLfloat fog;
#endif //GL_WIN_specular_fog


#if LATER
// if eye.w is zero, it should really take the slow path!
// Since the sample implementation ignores it, we will also ignore it here.
#endif

    if (face == __GL_FRONTFACE)
        msm = &gc->light.front;
    else
        msm = &gc->light.back;

    lsm = gc->light.sources;
    if (lsm && !lsm->next)
        fast_path = 1;

    msm_scale     = msm->scale;
    msm_threshold = msm->threshold;
    msm_specTable = msm->specTable;
    msm_alpha     = msm->alpha;

// Compute invarient emissive and ambient components for this vertex.

    baseEmissiveAmbient_r = msm->cachedEmissiveAmbient.r;
    baseEmissiveAmbient_g = msm->cachedEmissiveAmbient.g;
    baseEmissiveAmbient_b = msm->cachedEmissiveAmbient.b;


// NOTE: the following values may be re-used in the next iteration:
//       nxi, nyi, nzi

#ifdef GL_WIN_specular_fog
    if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
    {
        ASSERTOPENGL (face == __GL_FRONTFACE,
                      "Specular fog works only with GL_FRONT\n");
    }
#endif //GL_WIN_specular_fog


    if (fast_path)
    {
        __GLfloat n1, n2;

        lspmm = &lsm->front + face;
        lss = lsm->state;
        lsmx = lsm->unitVPpli.x;
        lsmy = lsm->unitVPpli.y;
        lsmz = lsm->unitVPpli.z;

        diff_r = lspmm->diffuse.r;
        diff_g = lspmm->diffuse.g;
        diff_b = lspmm->diffuse.b;

        spec_r = lspmm->specular.r;
        spec_g = lspmm->specular.g;
        spec_b = lspmm->specular.b;

        for (pd = pdFirst; pd <= pdLast; pd++)
        {
                __GLfloat rsi, gsi, bsi;

// If normal has not changed for this vertex, use the previously computed color.

                normal_valid = pd->flags & POLYDATA_NORMAL_VALID;
                paneeds_valid = gc->vertex.paNeeds & PANEEDS_NORMAL;

                if (!(normal_valid))
                {
                        ASSERTOPENGL(pd != pdFirst, "no initial normal\n");
                        pd->colors[face] = (pd-1)->colors[face];
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                        {
                                pd->fog = (pd-1)->fog;
                        }
#endif //GL_WIN_specular_fog
                        continue;
                }

                if (face == __GL_FRONTFACE)
                {
                        nxi = pd->normal.x;
                        nyi = pd->normal.y;
                        nzi = pd->normal.z;
                }
                else
                {
                        nxi = -pd->normal.x;
                        nyi = -pd->normal.y;
                        nzi = -pd->normal.z;
                }

#ifdef GL_WIN_specular_fog
                if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                {
                        fog = __glZero;
                }
#endif //GL_WIN_specular_fog

                rsi = baseEmissiveAmbient_r;
                gsi = baseEmissiveAmbient_g;
                bsi = baseEmissiveAmbient_b;

// Compute the diffuse and specular components for this vertex.

        /* Add in specular and diffuse effect of light, if any */

                n1 = nxi * lsmx + nyi * lsmy + nzi * lsmz;
                pd_color_dst = &pd->colors[face];
                if (n1 > 0.0)
                {
                        n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z)
                        - msm_threshold;

                        rsi += n1 * diff_r;
                        gsi += n1 * diff_g;
                        bsi += n1 * diff_b;

                        if (n2 >= 0.0)
                        {
                                GLint ix = (GLint)(n2 * msm_scale + __glHalf);

                                if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                                        n2 = msm_specTable[ix];
                                else
                                        n2 = __glOne;

#ifdef GL_WIN_specular_fog
                                if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                                {
                                        fog += n2;
                                }
#endif //GL_WIN_specular_fog


                                rsi += n2 * spec_r;
                                gsi += n2 * spec_g;
                                bsi += n2 * spec_b;
                        }
                        pd_color_dst->r = rsi;
                        pd_color_dst->g = gsi;
                        pd_color_dst->b = bsi;
                        if (__GL_COLOR_CHECK_CLAMP_RGB(gc, rsi, gsi, bsi)) {
                                __GL_CLAMP_RGB(pd_color_dst->r,
                               pd_color_dst->g,
                               pd_color_dst->b,
                               gc, rsi, gsi, bsi);
                        }
                        pd_color_dst->a = msm_alpha;
                }
                else
                {
                        pd_color_dst->r = msm->cachedNonLit.r;
                        pd_color_dst->g = msm->cachedNonLit.g;
                        pd_color_dst->b = msm->cachedNonLit.b;
                        pd_color_dst->a = msm_alpha;
                }
        }
    }
    else
    {
        for (pd = pdFirst; pd <= pdLast; pd++)
        {
                __GLfloat rsi, gsi, bsi;

// If normal has not changed for this vertex, use the previously computed color.

                normal_valid = pd->flags & POLYDATA_NORMAL_VALID;
                paneeds_valid = gc->vertex.paNeeds & PANEEDS_NORMAL;

                if (!(normal_valid))
                {
                        ASSERTOPENGL(pd != pdFirst, "no initial normal\n");
                        pd->colors[face] = (pd-1)->colors[face];
#ifdef GL_WIN_specular_fog
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                        {
                                pd->fog = (pd-1)->fog;
                        }
#endif //GL_WIN_specular_fog
                        continue;
                }


                if (face == __GL_FRONTFACE)
                {
                        nxi = pd->normal.x;
                        nyi = pd->normal.y;
                        nzi = pd->normal.z;
                }
                else
                {
                        nxi = -pd->normal.x;
                        nyi = -pd->normal.y;
                        nzi = -pd->normal.z;
                }

#ifdef GL_WIN_specular_fog
                if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                {
                        fog = __glZero;
                }
#endif //GL_WIN_specular_fog

                rsi = baseEmissiveAmbient_r;
                gsi = baseEmissiveAmbient_g;
                bsi = baseEmissiveAmbient_b;

// Compute the diffuse and specular components for this vertex.

                for (lsm = gc->light.sources; lsm; lsm = lsm->next)
                {
                        __GLfloat n1, n2;

                        lspmm = &lsm->front + face;
                        lss = lsm->state;
                        lsmx = lsm->unitVPpli.x;
                        lsmy = lsm->unitVPpli.y;
                        lsmz = lsm->unitVPpli.z;

                        diff_r = lspmm->diffuse.r;
                        diff_g = lspmm->diffuse.g;
                        diff_b = lspmm->diffuse.b;

            /* Add in specular and diffuse effect of light, if any */

                        n1 = nxi * lsmx + nyi * lsmy + nzi * lsmz;

                        if (n1 > 0.0)
                        {
                                notBackface = TRUE;

                                n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z)
                                - msm_threshold;

                                if (n2 >= 0.0)
                                {
                                        GLint ix = (GLint)(n2 * msm_scale + __glHalf);
                                        spec_r = lspmm->specular.r;
                                        spec_g = lspmm->specular.g;
                                        spec_b = lspmm->specular.b;

                                        if (ix < __GL_SPEC_LOOKUP_TABLE_SIZE)
                                                n2 = msm_specTable[ix];
                                        else
                                        n2 = __glOne;

#ifdef GL_WIN_specular_fog
                                        if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                                        {
                                                fog += n2;
                                        }
#endif //GL_WIN_specular_fog

                                        rsi += n2 * spec_r;
                                        gsi += n2 * spec_g;
                                        bsi += n2 * spec_b;
                                }
                                rsi += n1 * diff_r;
                                gsi += n1 * diff_g;
                                bsi += n1 * diff_b;
                        }
                }

                pd_color_dst = &pd->colors[face];

#ifdef GL_WIN_specular_fog
                if (gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG)
                {
                        pd->fog = 1.0 - fog;
                        if (__GL_FLOAT_LTZ (pd->fog)) pd->fog = __glZero;
                }
#endif //GL_WIN_specular_fog


                if (notBackface)
                {
                        pd_color_dst->r = rsi;
                        pd_color_dst->g = gsi;
                        pd_color_dst->b = bsi;

                        if (__GL_COLOR_CHECK_CLAMP_RGB(gc, rsi, gsi, bsi)) {
                                __GL_CLAMP_RGB(pd_color_dst->r,
                                                pd_color_dst->g,
                                                pd_color_dst->b,
                                                gc, rsi, gsi, bsi);
                        }

                        pd_color_dst->a = msm_alpha;

                }
                else
                {
                        pd_color_dst->r = msm->cachedNonLit.r;
                        pd_color_dst->g = msm->cachedNonLit.g;
                        pd_color_dst->b = msm->cachedNonLit.b;
                        pd_color_dst->a = msm_alpha;
                }
        }
    }

}

#endif // __GL_ASM_POLYARRAYZIPPYCALCRGBCOLOR

#ifdef _X86_

// See comments in xform.asm (NORMALIZE macro) about format of this table
//
#define K 9                         // Number of used mantissa bits
#define MAX_ENTRY  (1 << (K+1))
#define EXPONENT_BIT (1 << K)
#define MANTISSA_MASK (EXPONENT_BIT - 1)
#define FRACTION_VALUE ((float)EXPONENT_BIT)

float invSqrtTable[MAX_ENTRY];      // used by glNormalizeBatch

void initInvSqrtTable()
{
    int i;
    for (i=0; i < MAX_ENTRY; i++)
    {
        if (i & EXPONENT_BIT)
            invSqrtTable[i] = (float)(1.0/sqrt(((i & MANTISSA_MASK)/FRACTION_VALUE+1.0)));
        else
            invSqrtTable[i] = (float)(1.0/sqrt(((i & MANTISSA_MASK)/FRACTION_VALUE+1.0)/2));
    }
}

/*
    __glClipCodes table has precomputed clip codes.
    Index to this table:
    bit 6  - 1 if clipW < 0
    bit 5  - 1 if clipX < 0
    bit 4  - 1 if abs(clipX) < abs(clipW)
    bit 3  - 1 if clipY < 0
    bit 2  - 1 if abs(clipY) < abs(clipW)
    bit 1  - 1 if clipZ < 0
    bit 0  - 1 if abs(clipZ) < abs(clipW)
*/
ULONG __glClipCodes[128];

void initClipCodesTable()
{
    int i, v, w;
    for (i=0; i < 128; i++)
    {
        int code = 0;
        if (i & 0x10)
        { // x < w
           v = 1; w = 2;
        }
        else
        {
           v = 2; w = 1;
        }
        if (i & 0x20) v = -v;
        if (i & 0x40) w = -w;
        if (v >  w) code|= __GL_CLIP_RIGHT;
        if (v < -w) code|= __GL_CLIP_LEFT;

        if (i & 0x04)
        { // y < w
           v = 1; w = 2;
        }
        else
        {
           v = 2; w = 1;
        }
        if (i & 0x08) v = -v;
        if (i & 0x40) w = -w;
        if (v >  w) code|= __GL_CLIP_TOP;
        if (v < -w) code|= __GL_CLIP_BOTTOM;

        if (i & 0x01)
        { // v < w
           v = 1; w = 2;
        }
        else
        {
           v = 2; w = 1;
        }
        if (i & 0x02) v = -v;
        if (i & 0x40) w = -w;
        if (v >  w) code|= __GL_CLIP_FAR;
        if (v < -w) code|= __GL_CLIP_NEAR;

        __glClipCodes[i] = code;
    }
}
#endif // _X86_

#ifndef __GL_ASM_PACLIPCHECKFRUSTUM
/****************************************************************************/
// Clip check the clip coordinates against the frustum planes.
// Compute the window coordinates if not clipped!
//
// IN:  clip
// OUT: window (if not clipped)

GLuint FASTCALL PAClipCheckFrustum(__GLcontext *gc, POLYARRAY *pa,
                                   POLYDATA *pdLast)
{
    __GLfloat x, y, z, w, invW, negW;
    GLuint code;
    POLYDATA *pd;

    for (pd = pa->pd0; pd <= pdLast; pd++)
    {

        w = pd->clip.w;
        /* Set clip codes */

        /* XXX (mf) prevent divide-by-zero */
        if (__GL_FLOAT_NEZ(w))
        {
                __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, w, invW);
        }
        else
        {
                invW = __glZero;
        }

        x = pd->clip.x;
        y = pd->clip.y;
        z = pd->clip.z;

        code = 0;
        negW = -w;

        __GL_FLOAT_SIMPLE_END_DIVIDE(invW);

        pd->window.w = invW;

        /*
        ** NOTE: it is possible for x to be less than negW and greater
            ** than w (if w is negative).  Otherwise there would be "else"
            ** clauses here.
        */
        if (x < negW) code |= __GL_CLIP_LEFT;
        if (x > w) code |= __GL_CLIP_RIGHT;
        if (y < negW) code |= __GL_CLIP_BOTTOM;
        if (y > w) code |= __GL_CLIP_TOP;
        if (z < negW) code |= __GL_CLIP_NEAR;
        if (z > w) code |= __GL_CLIP_FAR;

        /* Compute window coordinates if not clipped */
        if (!code)
        {
                __GLfloat wx, wy, wz;

                wx = x * gc->state.viewport.xScale * invW +
                    gc->state.viewport.xCenter;
                wy = y * gc->state.viewport.yScale * invW +
                    gc->state.viewport.yCenter;
                wz = z * gc->state.viewport.zScale * invW +
                    gc->state.viewport.zCenter;
                pd->window.x = wx;
                pd->window.y = wy;
                pd->window.z = wz;
        }
        pd->clipCode = code;

        pa->orClipCodes |= code;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= code;
#endif
    }
    return pa->andClipCodes;
}

GLuint FASTCALL PAClipCheckFrustumWOne(__GLcontext *gc, POLYARRAY *pa,
                                   POLYDATA *pdLast)
{
    __GLfloat x, y, z, w, invW, negW;
    GLuint code;
    POLYDATA *pd;

    for (pd = pa->pd0; pd <= pdLast; pd++)
    {

        w = pd->clip.w;
        pd->window.w = __glOne;

        /* Set clip codes */

        x = pd->clip.x;
        y = pd->clip.y;
        z = pd->clip.z;
        code = 0;
        negW = __glMinusOne;
        if (x < negW) code |= __GL_CLIP_LEFT;
        else if (x > w) code |= __GL_CLIP_RIGHT;
        if (y < negW) code |= __GL_CLIP_BOTTOM;
        else if (y > w) code |= __GL_CLIP_TOP;
        if (z < negW) code |= __GL_CLIP_NEAR;
        else if (z > w) code |= __GL_CLIP_FAR;

        /* Compute window coordinates if not clipped */
        if (!code)
        {
            __GLfloat wx, wy, wz;

                wx = x * gc->state.viewport.xScale + gc->state.viewport.xCenter;
                wy = y * gc->state.viewport.yScale + gc->state.viewport.yCenter;
                wz = z * gc->state.viewport.zScale + gc->state.viewport.zCenter;

                pd->window.x = wx;
                pd->window.y = wy;
                pd->window.z = wz;
        }
        pd->clipCode = code;
        pa->orClipCodes |= code;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= code;
#endif
    }
    return pa->andClipCodes;
}
#endif // __GL_ASM_PACLIPCHECKFRUSTUM

// Clip check the clip coordinates against the frustum planes.
// Compute the window coordinates if not clipped!
//
// IN:  clip
// OUT: window (if not clipped)

#ifndef __GL_ASM_PACLIPCHECKFRUSTUM2D
GLuint FASTCALL PAClipCheckFrustum2D(__GLcontext *gc, POLYARRAY *pa,
                                     POLYDATA *pdLast)
{
    __GLfloat x, y, z, w, negW, invW;
    GLuint code;
    POLYDATA *pd;

    for (pd = pa->pd0; pd <= pdLast; pd++) {

        /* W is 1.0 */

        pd->window.w = __glOne;

        x = pd->clip.x;
        y = pd->clip.y;
        z = pd->clip.z;
        w = pd->clip.w;
        negW = __glMinusOne;

        /* Set clip codes */
        code = 0;

        if (x < negW) code |= __GL_CLIP_LEFT;
        else if (x > w) code |= __GL_CLIP_RIGHT;
        if (y < negW) code |= __GL_CLIP_BOTTOM;
        else if (y > w) code |= __GL_CLIP_TOP;

        /* Compute window coordinates if not clipped */
        if (!code)
        {
            __GLfloat wx, wy, wz;

            wx = x * gc->state.viewport.xScale + gc->state.viewport.xCenter;
                wy = y * gc->state.viewport.yScale + gc->state.viewport.yCenter;
                wz = z * gc->state.viewport.zScale + gc->state.viewport.zCenter;
                pd->window.x = wx;
                pd->window.y = wy;
            pd->window.z = wz;
        }

        pd->clipCode = code;

        pa->orClipCodes |= code;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= code;
#endif
    }
    return pa->andClipCodes;
}
#endif // __GL_ASM_PACLIPCHECKFRUSTUM2D

// Clip check against the frustum and user clipping planes.
// Compute the window coordinates if not clipped!
//
// IN:  clip, eye
// OUT: window (if not clipped)

#ifndef __GL_ASM_PACLIPCHECKALL

GLuint FASTCALL PAClipCheckAll(__GLcontext *gc, POLYARRAY *pa,
                               POLYDATA *pdLast)
{
    __GLfloat x, y, z, w, negW, invW;
    GLuint code, bit, clipPlanesMask;
    __GLcoord *plane;
    POLYDATA *pd;

    // We need double precision to do this correctly.  If precision is
    // lowered (as it was in a previous version of this routine), triangles
    // may be clipped incorrectly with user planes (very visible in tlogo)!

    FPU_SAVE_MODE();
    FPU_ROUND_ON_PREC_HI();

    for (pd = pa->pd0; pd <= pdLast; pd++) {

        PERF_CHECK(FALSE, "Performs user plane clipping!\n");

        /*
        ** Do frustum checks.
        **
        ** NOTE: it is possible for x to be less than negW and greater than w
        ** (if w is negative).  Otherwise there would be "else" clauses here.
        */

        x = pd->clip.x;
        y = pd->clip.y;
        z = pd->clip.z;
        w = pd->clip.w;

        /* Set clip codes */

        /* XXX (mf) prevent divide-by-zero */
        if (__GL_FLOAT_NEZ(w))
        {
            __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, w, invW);
            __GL_FLOAT_SIMPLE_END_DIVIDE(invW);
        }
        else
        {
            invW = __glZero;
        }
        pd->window.w = invW;
        negW = -w;
        code = 0;
        if (x < negW) code |= __GL_CLIP_LEFT;
        if (x > w) code |= __GL_CLIP_RIGHT;
        if (y < negW) code |= __GL_CLIP_BOTTOM;
        if (y > w) code |= __GL_CLIP_TOP;
        if (z < negW) code |= __GL_CLIP_NEAR;
        if (z > w) code |= __GL_CLIP_FAR;

        /*
        ** Now do user clip plane checks
        */
        x = pd->eye.x;
        y = pd->eye.y;
        z = pd->eye.z;
        w = pd->eye.w;
        clipPlanesMask = gc->state.enables.clipPlanes;
        plane = &gc->state.transform.eyeClipPlanes[0];
        bit = __GL_CLIP_USER0;
        while (clipPlanesMask)
        {
            if (clipPlanesMask & 1)
                {
                    /*
                    ** Dot the vertex clip coordinate against the clip plane and
                    ** see if the sign is negative.  If so, then the point is out.
                    */

                    if (x * plane->x + y * plane->y + z * plane->z + w * plane->w <
                        __glZero)
                {
                    code |= bit;
                }
                }
                clipPlanesMask >>= 1;
                bit <<= 1;
                plane++;
        }

        /* Compute window coordinates if not clipped */
        if (!code)
        {
            __GLfloat wx, wy, wz;

                x = pd->clip.x;
                y = pd->clip.y;
                z = pd->clip.z;

            wx = x * gc->state.viewport.xScale * invW +
                     gc->state.viewport.xCenter;
            wy = y * gc->state.viewport.yScale * invW +
                     gc->state.viewport.yCenter;
            wz = z * gc->state.viewport.zScale * invW +
                     gc->state.viewport.zCenter;
            pd->window.x = wx;
            pd->window.y = wy;
            pd->window.z = wz;
        }

        pd->clipCode = code;

        pa->orClipCodes |= code;
#ifdef POLYARRAY_AND_CLIPCODES
        pa->andClipCodes &= code;
#endif
    }

    FPU_RESTORE_MODE();
    return pa->andClipCodes;
}

#endif // __GL_ASM_PACLIPCHECKALL

/****************************************************************************/
void APIPRIVATE __glim_EdgeFlag(GLboolean tag)
{
    __GL_SETUP();
    gc->state.current.edgeTag = tag;
}

void APIPRIVATE __glim_TexCoord4fv(const GLfloat x[4])
{
    __GL_SETUP();
    gc->state.current.texture.x = x[0];
    gc->state.current.texture.y = x[1];
    gc->state.current.texture.z = x[2];
    gc->state.current.texture.w = x[3];
}

void APIPRIVATE __glim_Normal3fv(const GLfloat v[3])
{
    __GL_SETUP();
    GLfloat x, y, z;

    x = v[0];
    y = v[1];
    z = v[2];
    gc->state.current.normal.x = x;
    gc->state.current.normal.y = y;
    gc->state.current.normal.z = z;
}

void APIPRIVATE __glim_Color4fv(const GLfloat v[4])
{
    __GL_SETUP();

    gc->state.current.userColor.r = v[0];
    gc->state.current.userColor.g = v[1];
    gc->state.current.userColor.b = v[2];
    gc->state.current.userColor.a = v[3];
    (*gc->procs.applyColor)(gc);
}

void APIPRIVATE __glim_Indexf(GLfloat c)
{
    __GL_SETUP();
    gc->state.current.userColorIndex = c;
}

#if DBG
#define DEBUG_RASTERPOS 1
#endif

// This is not very efficient but it should work fine.
void APIPRIVATE __glim_RasterPos4fv(const GLfloat v[4])
{
    POLYDATA   pd3[3];  // one pa, one pd, followed by one spare.
    POLYARRAY  *pa = (POLYARRAY *) &pd3[0];
    POLYDATA   *pd = &pd3[1];
    __GLvertex *rp;
    GLuint     oldPaNeeds, oldEnables;
#ifdef DEBUG_RASTERPOS
    void (FASTCALL *oldRenderPoint)(__GLcontext *gc, __GLvertex *v);
#endif
    GLuint     pdflags;

    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

// ASSERT_VERTEX

    if (v[3] == (GLfloat) 1.0)
    {
        if (v[2] == (GLfloat) 0.0)
            pdflags = POLYDATA_VERTEX2;
        else
            pdflags = POLYDATA_VERTEX3;
    }
    else
    {
        pdflags = POLYDATA_VERTEX4;
    }

    rp = &gc->state.current.rasterPos;

// Initialize POLYARRAY structure with one vertex

    pa->flags         = pdflags | POLYARRAY_RASTERPOS;
    pa->pdNextVertex  = pd+1;
    pa->pdCurColor    =
    pa->pdCurNormal   =
    pa->pdCurTexture  =
    pa->pdCurEdgeFlag = NULL;
    pa->pd0           = pd;
    pa->primType      = GL_POINTS;
    pa->nIndices      = 1;
    pa->aIndices      = NULL;   // identity mapping
    pa->paNext        = NULL;

    pd->flags         = pdflags;
    pd->obj           = *(__GLcoord *) &v[0];
    pd->color         = &pd->colors[__GL_FRONTFACE];
    pd->clipCode      = 1;      // set for debugging
    (pd+1)->flags     = 0;
    pa->pdLastEvalColor   =
    pa->pdLastEvalNormal  =
    pa->pdLastEvalTexture = NULL;

// Set up states.

    // need transformed texcoord in all cases
    oldPaNeeds = gc->vertex.paNeeds;
    gc->vertex.paNeeds |= PANEEDS_TEXCOORD;
    // no front-end optimization
    gc->vertex.paNeeds &= ~(PANEEDS_CLIP_ONLY | PANEEDS_SKIP_LIGHTING | PANEEDS_NORMAL);
    // set normal need
    if (gc->vertex.paNeeds & PANEEDS_RASTERPOS_NORMAL)
        gc->vertex.paNeeds |= PANEEDS_NORMAL;
    if (gc->vertex.paNeeds & PANEEDS_RASTERPOS_NORMAL_FOR_TEXTURE)
        gc->vertex.paNeeds |= PANEEDS_NORMAL_FOR_TEXTURE;

    // don't apply cheap fog!
    oldEnables = gc->state.enables.general;
    gc->state.enables.general &= ~__GL_FOG_ENABLE;

#ifdef DEBUG_RASTERPOS
// Debug only!
    // allow DrawPolyArray to perform selection but not feedback and rendering
    oldRenderPoint = gc->procs.renderPoint;
    if (gc->renderMode != GL_SELECT)
        gc->procs.renderPoint = NULL;   // was __glRenderPointNop but set to 0
                                        // for debugging
#endif

// Call DrawPolyArray to 'draw' the point.
// Begin validation has already been done.

    __glim_DrawPolyArray(pa);

// 'Render' the point in selection but not in feedback and render modes.

    if (gc->renderMode == GL_SELECT)
    {
        PARenderPoint(gc, (__GLvertex *)pa->pd0);
    }

// Eye coord should have been processed

    ASSERTOPENGL(pa->flags & POLYARRAY_EYE_PROCESSED, "need eye\n");

// Restore states.

    gc->vertex.paNeeds        = oldPaNeeds;
    gc->state.enables.general = oldEnables;
#ifdef DEBUG_RASTERPOS
    gc->procs.renderPoint     = oldRenderPoint;
#endif

// If the point is clipped, the raster position is invalid.

    if (pd->clipCode)
    {
        gc->state.current.validRasterPos = GL_FALSE;
        return;
    }
    gc->state.current.validRasterPos = GL_TRUE;

// Update raster pos data structure!
// Only the following fields are needed.

    rp->window.x = pd->window.x;
    rp->window.y = pd->window.y;
    rp->window.z = pd->window.z;
    rp->clip.w   = pd->clip.w;
    rp->eyeZ     = pd->eye.z;
    rp->colors[__GL_FRONTFACE] = pd->colors[__GL_FRONTFACE];
    rp->texture = pd->texture;
    ASSERTOPENGL(rp->color == &rp->colors[__GL_FRONTFACE],
                 "Color pointer not restored\n");
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, PIXELSTATE);
#endif
}

/************************************************************************/

void FASTCALL __glNop(void) {}
void FASTCALL __glNopGC(__GLcontext* gc) {}
GLboolean FASTCALL __glNopGCBOOL(__GLcontext* gc) { return FALSE; }
void FASTCALL __glNopGCFRAG(__GLcontext* gc, __GLfragment *frag, __GLtexel *texel) {}
void FASTCALL __glNopGCCOLOR(__GLcontext* gc, __GLcolor *color, __GLtexel *texel) {}
void FASTCALL __glNopLight(__GLcontext*gc, GLint i, __GLvertex*v) {}
void FASTCALL __glNopExtract(__GLmipMapLevel *level, __GLtexture *tex,
                             GLint row, GLint col, __GLtexel *result) {}

void FASTCALL ComputeColorMaterialChange(__GLcontext *gc)
{
    gc->light.front.colorMaterialChange = 0;
    gc->light.back.colorMaterialChange  = 0;

    if (gc->modes.rgbMode
        && gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE)
    {
        GLuint colorMaterialChange;

        switch (gc->state.light.colorMaterialParam)
        {
        case GL_EMISSION:
            colorMaterialChange = __GL_MATERIAL_EMISSIVE;
            break;
        case GL_SPECULAR:
            colorMaterialChange = __GL_MATERIAL_SPECULAR;
            break;
        case GL_AMBIENT:
            colorMaterialChange = __GL_MATERIAL_AMBIENT;
            break;
        case GL_DIFFUSE:
            colorMaterialChange = __GL_MATERIAL_DIFFUSE;
            break;
        case GL_AMBIENT_AND_DIFFUSE:
            colorMaterialChange = __GL_MATERIAL_AMBIENT | __GL_MATERIAL_DIFFUSE;
            break;
        }

        if (gc->state.light.colorMaterialFace == GL_FRONT_AND_BACK
         || gc->state.light.colorMaterialFace == GL_FRONT)
            gc->light.front.colorMaterialChange = colorMaterialChange;

        if (gc->state.light.colorMaterialFace == GL_FRONT_AND_BACK
         || gc->state.light.colorMaterialFace == GL_BACK)
            gc->light.back.colorMaterialChange = colorMaterialChange;
    }
}

void FASTCALL __glGenericPickVertexProcs(__GLcontext *gc)
{
    GLuint enables = gc->state.enables.general;
    GLenum mvpMatrixType;
    __GLmatrix *m;

    m = &(gc->transform.modelView->mvp);
    mvpMatrixType = m->matrixType;

    /* Pick paClipCheck proc */
    //!!! are there better clip procs?
    if (gc->state.enables.clipPlanes)
    {
        gc->procs.paClipCheck  = PAClipCheckAll;
    }
    else
    {
        if (mvpMatrixType >= __GL_MT_IS2D &&
            m->matrix[3][2] >= -1.0f && m->matrix[3][2] <= 1.0f)
            gc->procs.paClipCheck = PAClipCheckFrustum2D;
        else
            gc->procs.paClipCheck = PAClipCheckFrustum;
    }
}

// Allocate the POLYDATA vertex buffer.
// Align the buffer on a cache line boundary

GLboolean FASTCALL PolyArrayAllocBuffer(__GLcontext *gc, GLuint nVertices)
{
    GLuint cjSize;

// Make sure that the vertex buffer holds a minimum number of vertices.

    if (nVertices < MINIMUM_POLYDATA_BUFFER_SIZE)
    {
        ASSERTOPENGL(FALSE, "vertex buffer too small\n");
        return GL_FALSE;
    }

// Allocate the vertex buffer.

    cjSize = (nVertices * sizeof(POLYDATA));

    if (!(gc->vertex.pdBuf = (POLYDATA *)GCALLOCALIGN32(gc, cjSize)))
        return GL_FALSE;

    gc->vertex.pdBufSizeBytes = cjSize;

    // Only (n-1) vertices are available for use.  The last one is reserved
    // by polyarray code.
    gc->vertex.pdBufSize = nVertices - 1;

// Initialize the vertex buffer.

    PolyArrayResetBuffer(gc);

    return GL_TRUE;
}

// Reset the color pointers in vertex buffer.
GLvoid FASTCALL PolyArrayResetBuffer(__GLcontext *gc)
{
    GLuint i;

    for (i = 0; i <= gc->vertex.pdBufSize; i++)
        gc->vertex.pdBuf[i].color = &gc->vertex.pdBuf[i].colors[__GL_FRONTFACE];
}

// Free the POLYDATA vertex buffer.
GLvoid FASTCALL PolyArrayFreeBuffer(__GLcontext *gc)
{
#ifdef _MCD_
    // If MCD, the POLYDATA vertex buffer is freed when the MCD context is
    // destroyed (see GenMcdDestroy).
    if (((__GLGENcontext *) gc)->_pMcdState)
        return;
#endif

    if (gc->vertex.pdBuf)
        GCFREEALIGN32(gc, gc->vertex.pdBuf);
    gc->vertex.pdBufSizeBytes = 0;
    gc->vertex.pdBufSize = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_texfn.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

/* 1 Component modulate */
void FASTCALL __glTextureModulateL(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->r = texel->luminance * color->r;
    color->g = texel->luminance * color->g;
    color->b = texel->luminance * color->b;
}

/* 2 Component modulate */
void FASTCALL __glTextureModulateLA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->r = texel->luminance * color->r;
    color->g = texel->luminance * color->g;
    color->b = texel->luminance * color->b;
    color->a = texel->alpha * color->a;
}

/* 3 Component modulate */
void FASTCALL __glTextureModulateRGB(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->r = texel->r * color->r;
    color->g = texel->g * color->g;
    color->b = texel->b * color->b;
}

/* 4 Component modulate */
void FASTCALL __glTextureModulateRGBA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->r = texel->r * color->r;
    color->g = texel->g * color->g;
    color->b = texel->b * color->b;
    color->a = texel->alpha * color->a;
}

/* Alpha modulate */
void FASTCALL __glTextureModulateA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->a = texel->alpha * color->a;
}

/* Intensity modulate */
void FASTCALL __glTextureModulateI(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->r = texel->intensity * color->r;
    color->g = texel->intensity * color->g;
    color->b = texel->intensity * color->b;
    color->a = texel->intensity * color->a;
}

/***********************************************************************/

/* 3 Component decal */
void FASTCALL __glTextureDecalRGB(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->r * gc->frontBuffer.redScale;
    color->g = texel->g * gc->frontBuffer.greenScale;
    color->b = texel->b * gc->frontBuffer.blueScale;
}

/* 4 Component decal */
void FASTCALL __glTextureDecalRGBA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat a = texel->alpha;
    __GLfloat oma = __glOne - a;

    color->r = oma * color->r
	+ a * texel->r * gc->frontBuffer.redScale;
    color->g = oma * color->g
	+ a * texel->g * gc->frontBuffer.greenScale;
    color->b = oma * color->b
	+ a * texel->b * gc->frontBuffer.blueScale;
}

/***********************************************************************/

/* 1 Component blend */
void FASTCALL __glTextureBlendL(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat l = texel->luminance;
    __GLfloat oml = __glOne - l;
    __GLcolor *cc = &gc->state.texture.env[0].color;

    color->r = oml * color->r + l * cc->r;
    color->g = oml * color->g + l * cc->g;
    color->b = oml * color->b + l * cc->b;
}

/* 2 Component blend */
void FASTCALL __glTextureBlendLA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat l = texel->luminance;
    __GLfloat oml = __glOne - l;
    __GLcolor *cc = &gc->state.texture.env[0].color;

    color->r = oml * color->r + l * cc->r;
    color->g = oml * color->g + l * cc->g;
    color->b = oml * color->b + l * cc->b;
    color->a = texel->alpha * color->a;
}

/* 3 Component blend */
void FASTCALL __glTextureBlendRGB(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat r = texel->r;
    __GLfloat g = texel->g;
    __GLfloat b = texel->b;
    __GLcolor *cc = &gc->state.texture.env[0].color;

    color->r = (__glOne - r) * color->r + r * cc->r;
    color->g = (__glOne - g) * color->g + g * cc->g;
    color->b = (__glOne - b) * color->b + b * cc->b;
}

/* 4 Component blend */
void FASTCALL __glTextureBlendRGBA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat r = texel->r;
    __GLfloat g = texel->g;
    __GLfloat b = texel->b;
    __GLcolor *cc = &gc->state.texture.env[0].color;

    color->r = (__glOne - r) * color->r + r * cc->r;
    color->g = (__glOne - g) * color->g + g * cc->g;
    color->b = (__glOne - b) * color->b + b * cc->b;
    color->a = texel->alpha * color->a;
}

/* Alpha blend */
void FASTCALL __glTextureBlendA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    color->a = texel->alpha * color->a;
}

/* Intensity blend */
void FASTCALL __glTextureBlendI(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    __GLfloat i = texel->intensity;
    __GLfloat omi = __glOne - i;
    __GLcolor *cc = &gc->state.texture.env[0].color;

    color->r = omi * color->r + i * cc->r;
    color->g = omi * color->g + i * cc->g;
    color->b = omi * color->b + i * cc->b;
    color->a = omi * color->a + i * cc->a;
}

/***********************************************************************/

/* 1 Component replace */
void FASTCALL __glTextureReplaceL(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->luminance * gc->frontBuffer.redScale;
    color->g = texel->luminance * gc->frontBuffer.greenScale;
    color->b = texel->luminance * gc->frontBuffer.blueScale;
}

/* 2 Component replace */
void FASTCALL __glTextureReplaceLA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->luminance * gc->frontBuffer.redScale;
    color->g = texel->luminance * gc->frontBuffer.greenScale;
    color->b = texel->luminance * gc->frontBuffer.blueScale;
    color->a = texel->alpha * gc->frontBuffer.alphaScale;
}

/* 3 Component replace */
void FASTCALL __glTextureReplaceRGB(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->r * gc->frontBuffer.redScale;
    color->g = texel->g * gc->frontBuffer.greenScale;
    color->b = texel->b * gc->frontBuffer.blueScale;
}

/* 4 Component replace */
void FASTCALL __glTextureReplaceRGBA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->r * gc->frontBuffer.redScale;
    color->g = texel->g * gc->frontBuffer.greenScale;
    color->b = texel->b * gc->frontBuffer.blueScale;
    color->a = texel->alpha * gc->frontBuffer.alphaScale;
}

/* Alpha replace */
void FASTCALL __glTextureReplaceA(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->a = texel->alpha * gc->frontBuffer.alphaScale;
}

/* Intensity replace */
void FASTCALL __glTextureReplaceI(__GLcontext *gc, __GLcolor *color, __GLtexel *texel)
{
    color->r = texel->intensity * gc->frontBuffer.redScale;
    color->g = texel->intensity * gc->frontBuffer.greenScale;
    color->b = texel->intensity * gc->frontBuffer.blueScale;
    color->a = texel->intensity * gc->frontBuffer.alphaScale;
}

/************************************************************************/

/*
** Get a texture element out of the one component texture buffer
** with no border.
*/
void FASTCALL __glExtractTexelL(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->luminance = tex->params.borderColor.r;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col);
	result->luminance = image[0];
    }
}

/*
** Get a texture element out of the two component texture buffer
** with no border.
*/
void FASTCALL __glExtractTexelLA(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->luminance = tex->params.borderColor.r;
	result->alpha = tex->params.borderColor.a;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col) * 2;
	result->luminance = image[0];
	result->alpha = image[1];
    }
}

/*
** Get a texture element out of the three component texture buffer
** with no border.
*/
void FASTCALL __glExtractTexelRGB(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col) * 3;
	result->r = image[0];
	result->g = image[1];
	result->b = image[2];
    }
}

/*
** Get a texture element out of the four component texture buffer
** with no border.
*/
void FASTCALL __glExtractTexelRGBA(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
	result->alpha = tex->params.borderColor.a;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col) * 4;
	result->r = image[0];
	result->g = image[1];
	result->b = image[2];
	result->alpha = image[3];
    }
}

void FASTCALL __glExtractTexelA(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->alpha = tex->params.borderColor.a;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col);
	result->alpha = image[0];
    }
}

void FASTCALL __glExtractTexelI(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->intensity = tex->params.borderColor.r;
    } else {
	image = level->buffer + ((row << level->widthLog2) + col);
	result->intensity = image[0];
    }
}

void FASTCALL __glExtractTexelBGR8(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
    } else {
	image = (GLubyte *)level->buffer + ((row << level->widthLog2) + col) * 4;
	result->r = __GL_UB_TO_FLOAT(image[2]);
	result->g = __GL_UB_TO_FLOAT(image[1]);
	result->b = __GL_UB_TO_FLOAT(image[0]);
    }
}

void FASTCALL __glExtractTexelBGRA8(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
	result->alpha = tex->params.borderColor.a;
    } else {
	image = (GLubyte *)level->buffer + ((row << level->widthLog2) + col) * 4;
	result->r = __GL_UB_TO_FLOAT(image[2]);
	result->g = __GL_UB_TO_FLOAT(image[1]);
	result->b = __GL_UB_TO_FLOAT(image[0]);
	result->alpha = __GL_UB_TO_FLOAT(image[3]);
    }
}

#ifdef GL_EXT_paletted_texture
void FASTCALL __glExtractTexelPI8BGRA(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;
    RGBQUAD *rgb;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
	result->alpha = tex->params.borderColor.a;
    } else {
	image = (GLubyte *)level->buffer + ((row << level->widthLog2) + col);
        rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
	result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
	result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
	result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
	result->alpha = __GL_UB_TO_FLOAT(rgb->rgbReserved);
    }
}

void FASTCALL __glExtractTexelPI8BGR(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;
    RGBQUAD *rgb;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
    } else {
	image = (GLubyte *)level->buffer + ((row << level->widthLog2) + col);
        rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
	result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
	result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
	result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
    }
}

void FASTCALL __glExtractTexelPI16BGRA(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLushort *image;
    RGBQUAD *rgb;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
	result->alpha = tex->params.borderColor.a;
    } else {
	image = (GLushort *)level->buffer + ((row << level->widthLog2) + col);
        rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
	result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
	result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
	result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
	result->alpha = __GL_UB_TO_FLOAT(rgb->rgbReserved);
    }
}

void FASTCALL __glExtractTexelPI16BGR(__GLmipMapLevel *level, __GLtexture *tex,
		       GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLushort *image;
    RGBQUAD *rgb;

    if ((row < 0) || (col < 0) || (row >= level->height2) ||
	(col >= level->width2)) {
	/*
	** Use border color when the texture supplies no border.
	*/
	result->r = tex->params.borderColor.r;
	result->g = tex->params.borderColor.g;
	result->b = tex->params.borderColor.b;
    } else {
	image = (GLushort *)level->buffer + ((row << level->widthLog2) + col);
        rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
	result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
	result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
	result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
    }
}
#endif // GL_EXT_paletted_texture

/*
** Get a texture element out of the one component texture buffer
** with a border.
*/
void FASTCALL __glExtractTexelL_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col);
    result->luminance = image[0];
}

/*
** Get a texture element out of the two component texture buffer
** with a border.
*/
void FASTCALL __glExtractTexelLA_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col) * 2;
    result->luminance = image[0];
    result->alpha = image[1];
}

/*
** Get a texture element out of the three component texture buffer
** with a border.
*/
void FASTCALL __glExtractTexelRGB_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col) * 3;
    result->r = image[0];
    result->g = image[1];
    result->b = image[2];
}

/*
** Get a texture element out of the four component texture buffer
** with a border.
*/
void FASTCALL __glExtractTexelRGBA_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col) * 4;
    result->r = image[0];
    result->g = image[1];
    result->b = image[2];
    result->alpha = image[3];
}

void FASTCALL __glExtractTexelA_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col);
    result->alpha = image[0];
}

void FASTCALL __glExtractTexelI_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col);
    result->intensity = image[0];
}

void FASTCALL __glExtractTexelBGR8_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = (GLubyte *)level->buffer + (row * level->width + col) * 4;
    result->r = __GL_UB_TO_FLOAT(image[2]);
    result->g = __GL_UB_TO_FLOAT(image[1]);
    result->b = __GL_UB_TO_FLOAT(image[0]);
}

void FASTCALL __glExtractTexelBGRA8_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = (GLubyte *)level->buffer + (row * level->width + col) * 4;
    result->r = __GL_UB_TO_FLOAT(image[2]);
    result->g = __GL_UB_TO_FLOAT(image[1]);
    result->b = __GL_UB_TO_FLOAT(image[0]);
    result->alpha = __GL_UB_TO_FLOAT(image[3]);
}

#ifdef GL_EXT_paletted_texture
void FASTCALL __glExtractTexelPI8BGRA_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;
    RGBQUAD *rgb;

    row++;
    col++;
    image = (GLubyte *)level->buffer + (row * level->width + col);
    rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
    result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
    result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
    result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
    result->alpha = __GL_UB_TO_FLOAT(rgb->rgbReserved);
}

void FASTCALL __glExtractTexelPI8BGR_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;
    RGBQUAD *rgb;

    row++;
    col++;
    image = (GLubyte *)level->buffer + (row * level->width + col);
    rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
    result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
    result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
    result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
}

void FASTCALL __glExtractTexelPI16BGRA_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLushort *image;
    RGBQUAD *rgb;

    row++;
    col++;
    image = (GLushort *)level->buffer + (row * level->width + col);
    rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
    result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
    result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
    result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
    result->alpha = __GL_UB_TO_FLOAT(rgb->rgbReserved);
}

void FASTCALL __glExtractTexelPI16BGR_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLushort *image;
    RGBQUAD *rgb;

    row++;
    col++;
    image = (GLushort *)level->buffer + (row * level->width + col);
    rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
    result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
    result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
    result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
}
#endif // GL_EXT_paletted_texture
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_texfi.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include <namesint.h>
#include <math.h>

/*
** Some math routines that are optimized in assembly
*/

#define __GL_FRAC(f)	        ((f) - __GL_FAST_FLOORF(f))

/************************************************************************/

// Repeats the given float value in float [0, scale) and converts to
// int.  The repeat count is an integer which is a power of two
#define REPEAT_SCALED_VAL(val, scale, repeat)                           \
    (__GL_FLOAT_GEZ(val) ? (FTOL((val) * (scale)) & ((repeat)-1)) :     \
     ((repeat)-1)-(FTOL(-(val) * (scale)) & ((repeat)-1)))
    
// Clamps the given float value to float [0, scale) and converts to int
#define CLAMP_SCALED_VAL(val, scale)                                    \
    (__GL_FLOAT_LEZ(val) ? 0 :                                          \
     __GL_FLOAT_COMPARE_PONE(val, >=) ? (FTOL(scale)-1) :               \
     FTOL((val) * (scale)))

/*
** Return texel nearest the s coordinate.  s is converted to u
** implicitly during this step.
*/
void FASTCALL __glNearestFilter1(__GLcontext *gc, __GLtexture *tex,
			__GLmipMapLevel *lp, __GLcolor *color,
			__GLfloat s, __GLfloat t, __GLtexel *result)
{
    GLint col;
    __GLfloat w2f;

    CHOP_ROUND_ON();
    
#ifdef __GL_LINT
    gc = gc;
    color = color;
    t = t;
#endif

    /* Find texel index */
    w2f = lp->width2f;
    if (tex->params.sWrapMode == GL_REPEAT) {
	col = REPEAT_SCALED_VAL(s, w2f, lp->width2);
    } else {
        col = CLAMP_SCALED_VAL(s, w2f);
    }

    CHOP_ROUND_OFF();
    
    /* Lookup texel */
    (*lp->extract)(lp, tex, 0, col, result);
}

/*
** Return texel nearest the s&t coordinates.  s&t are converted to u&v
** implicitly during this step.
*/
void FASTCALL __glNearestFilter2(__GLcontext *gc, __GLtexture *tex,
			__GLmipMapLevel *lp, __GLcolor *color,
			__GLfloat s, __GLfloat t, __GLtexel *result)
{
    GLint row, col;
    __GLfloat w2f, h2f;

    CHOP_ROUND_ON();
    
#ifdef __GL_LINT
    gc = gc;
    color = color;
#endif

    /* Find texel column address */
    w2f = lp->width2f;
    if (tex->params.sWrapMode == GL_REPEAT) {
	col = REPEAT_SCALED_VAL(s, w2f, lp->width2);
    } else {
        col = CLAMP_SCALED_VAL(s, w2f);
    }

    /* Find texel row address */
    h2f = lp->height2f;
    if (tex->params.tWrapMode == GL_REPEAT) {
	row = REPEAT_SCALED_VAL(t, h2f, lp->height2);
    } else {
        row = CLAMP_SCALED_VAL(t, h2f);
    }

    CHOP_ROUND_OFF();
    
    /* Lookup texel */
    (*lp->extract)(lp, tex, row, col, result);
}

/*
** Return texel which is a linear combination of texels near s.
*/
void FASTCALL __glLinearFilter1(__GLcontext *gc, __GLtexture *tex,
		       __GLmipMapLevel *lp, __GLcolor *color,
		       __GLfloat s, __GLfloat t, __GLtexel *result)
{
    __GLfloat u, alpha, omalpha, w2f;
    GLint col0, col1;
    __GLtexel t0, t1;

#ifdef __GL_LINT
    color = color;
    t = t;
#endif

    /* Find col0 and col1 */
    w2f = lp->width2f;
    u = s * w2f;
    if (tex->params.sWrapMode == GL_REPEAT) {
	GLint w2mask = lp->width2 - 1;
	u -= __glHalf;
        col0 = __GL_FAST_FLOORF_I(u);
        alpha = u - (__GLfloat) col0; // Get fractional part
        col0 &= w2mask;
	col1 = (col0 + 1) & w2mask;
    } else {
	if (u < __glZero) u = __glZero;
	else if (u > w2f) u = w2f;
	u -= __glHalf;
	col0 = __GL_FAST_FLOORF_I(u);
        alpha = u - (__GLfloat) col0; // Get fractional part
	col1 = col0 + 1;
    }

    /* Calculate the final texel value as a combination of the two texels */
    (*lp->extract)(lp, tex, 0, col0, &t0);
    (*lp->extract)(lp, tex, 0, col1, &t1);

    omalpha = __glOne - alpha;
    switch (lp->baseFormat) {
      case GL_LUMINANCE_ALPHA:
	result->alpha = omalpha * t0.alpha + alpha * t1.alpha;
	/* FALLTHROUGH */
      case GL_LUMINANCE:
	result->luminance = omalpha * t0.luminance + alpha * t1.luminance;
	break;
      case GL_RGBA:
	result->alpha = omalpha * t0.alpha + alpha * t1.alpha;
	/* FALLTHROUGH */
      case GL_RGB:
	result->r = omalpha * t0.r + alpha * t1.r;
	result->g = omalpha * t0.g + alpha * t1.g;
	result->b = omalpha * t0.b + alpha * t1.b;
	break;
      case GL_ALPHA:
	result->alpha = omalpha * t0.alpha + alpha * t1.alpha;
	break;
      case GL_INTENSITY:
	result->intensity = omalpha * t0.intensity + alpha * t1.intensity;
	break;
    }
}

/*
** Return texel which is a linear combination of texels near s&t.
*/
void FASTCALL __glLinearFilter2(__GLcontext *gc, __GLtexture *tex,
		       __GLmipMapLevel *lp, __GLcolor *color,
		       __GLfloat s, __GLfloat t, __GLtexel *result)
{
    __GLfloat u, v, alpha, beta, half, w2f, h2f;
    GLint col0, row0, col1, row1;
    __GLtexel t00, t01, t10, t11;
    __GLfloat omalpha, ombeta, m00, m01, m10, m11;

#ifdef __GL_LINT
    color = color;
#endif

    /* Find col0, col1 */
    w2f = lp->width2f;
    u = s * w2f;
    half = __glHalf;
    if (tex->params.sWrapMode == GL_REPEAT) {
	GLint w2mask = lp->width2 - 1;
	u -= half;
        col0 = __GL_FAST_FLOORF_I(u);
        alpha = u - (__GLfloat) col0; // Get fractional part
        col0 &= w2mask;
	col1 = (col0 + 1) & w2mask;
    } else {
	if (u < __glZero) u = __glZero;
	else if (u > w2f) u = w2f;
	u -= half;
	col0 = __GL_FAST_FLOORF_I(u);
        alpha = u - (__GLfloat) col0; // Get fractional part
	col1 = col0 + 1;
    }

    /* Find row0, row1 */
    h2f = lp->height2f;
    v = t * h2f;
    if (tex->params.tWrapMode == GL_REPEAT) {
	GLint h2mask = lp->height2 - 1;
	v -= half;
	row0 = (__GL_FAST_FLOORF_I(v));
        beta = v - (__GLfloat) row0; // Get fractional part
        row0 &= h2mask;
	row1 = (row0 + 1) & h2mask;
    } else {
	if (v < __glZero) v = __glZero;
	else if (v > h2f) v = h2f;
	v -= half;
	row0 = __GL_FAST_FLOORF_I(v);
        beta = v - (__GLfloat) row0; // Get fractional part
	row1 = row0 + 1;
    }

    /* Calculate the final texel value as a combination of the square chosen */
    (*lp->extract)(lp, tex, row0, col0, &t00);
    (*lp->extract)(lp, tex, row0, col1, &t10);
    (*lp->extract)(lp, tex, row1, col0, &t01);
    (*lp->extract)(lp, tex, row1, col1, &t11);

    omalpha = __glOne - alpha;
    ombeta = __glOne - beta;

    m00 = omalpha * ombeta;
    m10 = alpha * ombeta;
    m01 = omalpha * beta;
    m11 = alpha * beta;

    switch (lp->baseFormat) {
      case GL_LUMINANCE_ALPHA:
	/* FALLTHROUGH */
	result->alpha = m00*t00.alpha + m10*t10.alpha + m01*t01.alpha
	    + m11*t11.alpha;
      case GL_LUMINANCE:
	result->luminance = m00*t00.luminance + m10*t10.luminance
	    + m01*t01.luminance + m11*t11.luminance;
	break;
      case GL_RGBA:
	/* FALLTHROUGH */
	result->alpha = m00*t00.alpha + m10*t10.alpha + m01*t01.alpha
	    + m11*t11.alpha;
      case GL_RGB:
	result->r = m00*t00.r + m10*t10.r + m01*t01.r + m11*t11.r;
	result->g = m00*t00.g + m10*t10.g + m01*t01.g + m11*t11.g;
	result->b = m00*t00.b + m10*t10.b + m01*t01.b + m11*t11.b;
	break;
      case GL_ALPHA:
	result->alpha = m00*t00.alpha + m10*t10.alpha + m01*t01.alpha
	    + m11*t11.alpha;
	break;
      case GL_INTENSITY:
	result->intensity = m00*t00.intensity + m10*t10.intensity
	    + m01*t01.intensity + m11*t11.intensity;
	break;
    }
}

// Macros to convert unsigned byte rgb{a} to float

#define __glBGRByteToFloat( fdst, bsrc ) \
    (fdst)->b = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (fdst)->g = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (fdst)->r = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (bsrc)++;

#define __glBGRAByteToFloat( fdst, bsrc ) \
    (fdst)->b = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (fdst)->g = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (fdst)->r = __GL_UB_TO_FLOAT( *(bsrc)++ ); \
    (fdst)->a = __GL_UB_TO_FLOAT( *(bsrc)++ );

void FASTCALL __glLinearFilter2_BGR8Repeat(__GLcontext *gc, __GLtexture *tex,
                       __GLmipMapLevel *lp, __GLcolor *color,
                       __GLfloat s, __GLfloat t, __GLtexel *result)
{
    __GLfloat u, v, alpha, beta, half;
    GLint col, row, rowLen;
    __GLcolor t00, t01, t10, t11;
    __GLfloat omalpha, ombeta, m00, m01, m10, m11;
    GLint width2m1, height2m1;
    GLubyte *image, *pData;

#ifdef __GL_LINT
    color = color;
#endif

    half = __glHalf;
    width2m1 = lp->width2 - 1;
    height2m1 = lp->height2 - 1;

    /* Find col, compute alpha */

    u = (s * lp->width2f) - half;
    col = __GL_FAST_FLOORF_I(u);
    alpha = u - (__GLfloat) col; // Get fractional part
    col &= width2m1;

    /* Find row, compute beta */

    v = (t * lp->height2f) - half;
    row = __GL_FAST_FLOORF_I(v);
    beta = v - (__GLfloat) row;  // Get fractional part
    row &= height2m1;

    // Extract first texel at row, col

    pData = image = 
        (GLubyte *)lp->buffer + (((row << lp->widthLog2) + col) << 2);

    __glBGRByteToFloat( &t00, pData );

    // Extract remaining texels

    rowLen = lp->width2 << 2; // row length in bytes

    if( (row < height2m1) &&
        (col < width2m1) )
    {
        // Most common case - the texels are a compact block of 4
        // Next texel along row
        __glBGRByteToFloat( &t10, pData );
        // Up to next row...
        pData += (rowLen-8);
        __glBGRByteToFloat( &t01, pData );
        __glBGRByteToFloat( &t11, pData );
    } else {
        // Exceptional case : one or both of row, col are on edge
        GLint rowInc, colInc; // increments in bytes

        // Calc increments to next texel along row/col

        if( col < width2m1 ) 
            rowInc = 4;
        else
            // increment to left edge
            rowInc = -(rowLen - 4);

        if( row < height2m1 )
            // increment by row length
            colInc = rowLen;
        else
            // increment to lower edge
            colInc = - height2m1 * rowLen;

        // Next texel along row
        pData = image + rowInc;
        __glBGRByteToFloat( &t10, pData );

        // Second row, first texel
        pData = image + colInc;
        __glBGRByteToFloat( &t01, pData );

        // Next texel along row
        pData += (rowInc - 4);
        __glBGRByteToFloat( &t11, pData );
    }
    
    omalpha = __glOne - alpha;
    ombeta = __glOne - beta;

    m00 = omalpha * ombeta;
    m10 = alpha * ombeta;
    m01 = omalpha * beta;
    m11 = alpha * beta;

    result->r = m00*t00.r + m10*t10.r + m01*t01.r + m11*t11.r;
    result->g = m00*t00.g + m10*t10.g + m01*t01.g + m11*t11.g;
    result->b = m00*t00.b + m10*t10.b + m01*t01.b + m11*t11.b;
}

void FASTCALL __glLinearFilter2_BGRA8Repeat(__GLcontext *gc, __GLtexture *tex,
                       __GLmipMapLevel *lp, __GLcolor *color,
                       __GLfloat s, __GLfloat t, __GLtexel *result)
{
    __GLfloat u, v, alpha, beta, half;
    GLint col, row, rowLen;
    __GLcolor t00, t01, t10, t11;
    __GLfloat omalpha, ombeta, m00, m01, m10, m11;
    GLint width2m1, height2m1;
    GLubyte *image, *pData;

#ifdef __GL_LINT
    color = color;
#endif

    half = __glHalf;
    width2m1 = lp->width2 - 1;
    height2m1 = lp->height2 - 1;

    /* Find col, compute alpha */

    u = (s * lp->width2f) - half;
    col = __GL_FAST_FLOORF_I(u);
    alpha = u - (__GLfloat) col; // Get fractional part
    col &= width2m1;

    /* Find row, compute beta */

    v = (t * lp->height2f) - half;
    row = __GL_FAST_FLOORF_I(v);
    beta = v - (__GLfloat) row;  // Get fractional part
    row &= height2m1;

    // Extract first texel

    pData = image = 
        (GLubyte *)lp->buffer + (((row << lp->widthLog2) + col) << 2);

    // Extract the first texel at row, col
    __glBGRAByteToFloat( &t00, pData );

    // Extract remaining texels

    rowLen = lp->width2 << 2; // row length in bytes

    if( (row < height2m1) &&
        (col < width2m1) )
    {
        // Most common case - the texels are a compact block of 4
        // Next texel along row...
        __glBGRAByteToFloat( &t10, pData );
        // Up to next row...
        pData += (rowLen-8);
        __glBGRAByteToFloat( &t01, pData );
        __glBGRAByteToFloat( &t11, pData );
    } else {
        // Exceptional case : one or both of row, col are on edge
        GLint rowInc, colInc; // increments in bytes

        // Calc increments to next texel along row/col

        if( col < width2m1 ) 
            rowInc = 4;
        else
            // increment to left edge
            rowInc = -(rowLen - 4);

        if( row < height2m1 )
            // increment by row length
            colInc = rowLen;
        else
            // increment to lower edge
            colInc = - height2m1 * rowLen;

        // Next texel along row
        pData = image + rowInc;
        __glBGRAByteToFloat( &t10, pData );

        // Second row, first texel
        pData = image + colInc;
        __glBGRAByteToFloat( &t01, pData );

        // Next texel along row
        pData += (rowInc - 4);
        __glBGRAByteToFloat( &t11, pData );
    }
    
    omalpha = __glOne - alpha;
    ombeta = __glOne - beta;

    m00 = omalpha * ombeta;
    m10 = alpha * ombeta;
    m01 = omalpha * beta;
    m11 = alpha * beta;

    result->r = m00*t00.r + m10*t10.r + m01*t01.r + m11*t11.r;
    result->g = m00*t00.g + m10*t10.g + m01*t01.g + m11*t11.g;
    result->b = m00*t00.b + m10*t10.b + m01*t01.b + m11*t11.b;
    result->alpha = m00*t00.a + m10*t10.a + m01*t01.a + m11*t11.a;
}

/*
** Linear min/mag filter
*/
void FASTCALL __glLinearFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		      __GLcolor *color, __GLfloat s, __GLfloat t,
		      __GLtexel *result)
{
#ifdef __GL_LINT
    lod = lod;
#endif
    (*tex->linear)(gc, tex, &tex->level[0], color, s, t, result);
}

/*
** Nearest min/mag filter
*/
void FASTCALL __glNearestFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		       __GLcolor *color, __GLfloat s, __GLfloat t,
		       __GLtexel *result)
{
#ifdef __GL_LINT
    lod = lod;
#endif
    (*tex->nearest)(gc, tex, &tex->level[0], color, s, t, result);
}

/*
** Apply minification rules to find the texel value.
*/
void FASTCALL __glNMNFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		   __GLcolor *color, __GLfloat s, __GLfloat t,
		   __GLtexel *result)
{
    __GLmipMapLevel *lp;
    GLint p, d;

    if (lod <= ((__GLfloat)0.5)) {
	d = 0;
    } else {
	p = tex->p;
	d = FTOL(lod + ((__GLfloat)0.49995)); /* NOTE: .5 minus epsilon */
	if (d > p) {
	    d = p;
	}
    }
    lp = &tex->level[d];
    (*tex->nearest)(gc, tex, lp, color, s, t, result);
}

/*
** Apply minification rules to find the texel value.
*/
void FASTCALL __glLMNFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		   __GLcolor *color, __GLfloat s, __GLfloat t,
		   __GLtexel *result)
{
    __GLmipMapLevel *lp;
    GLint p, d;

    if (lod <= ((__GLfloat) 0.5)) {
	d = 0;
    } else {
	p = tex->p;
	d = FTOL(lod + ((__GLfloat) 0.49995)); /* NOTE: .5 minus epsilon */
	if (d > p) {
	    d = p;
	}
    }
    lp = &tex->level[d];
    (*tex->linear)(gc, tex, lp, color, s, t, result);
}

/*
** Apply minification rules to find the texel value.
*/
void FASTCALL __glNMLFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		   __GLcolor *color, __GLfloat s, __GLfloat t,
		   __GLtexel *result)
{
    __GLmipMapLevel *lp;
    GLint p, d;
    __GLtexel td, td1;
    __GLfloat f, omf;

    p = tex->p;
    d = (FTOL(lod)) + 1;
    if (d > p || d < 0) {
	/* Clamp d to last available mipmap */
	lp = &tex->level[p];
	(*tex->nearest)(gc, tex, lp, color, s, t, result);
    } else {
	(*tex->nearest)(gc, tex, &tex->level[d], color, s, t, &td);
	(*tex->nearest)(gc, tex, &tex->level[d-1], color, s, t, &td1);
	f = __GL_FRAC(lod);
	omf = __glOne - f;
	switch (tex->level[0].baseFormat) {
	  case GL_LUMINANCE_ALPHA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    /* FALLTHROUGH */
	  case GL_LUMINANCE:
	    result->luminance = omf * td1.luminance + f * td.luminance;
	    break;
	  case GL_RGBA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    /* FALLTHROUGH */
	  case GL_RGB:
	    result->r = omf * td1.r + f * td.r;
	    result->g = omf * td1.g + f * td.g;
	    result->b = omf * td1.b + f * td.b;
	    break;
	  case GL_ALPHA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    break;
	  case GL_INTENSITY:
	    result->intensity = omf * td1.intensity + f * td.intensity;
	    break;
	}
    }
}

/*
** Apply minification rules to find the texel value.
*/
void FASTCALL __glLMLFilter(__GLcontext *gc, __GLtexture *tex, __GLfloat lod,
		   __GLcolor *color, __GLfloat s, __GLfloat t,
		   __GLtexel *result)
{
    __GLmipMapLevel *lp;
    GLint p, d;
    __GLtexel td, td1;
    __GLfloat f, omf;

    p = tex->p;
    d = (FTOL(lod)) + 1;
    if (d > p || d < 0) {
	/* Clamp d to last available mipmap */
	lp = &tex->level[p];
	(*tex->linear)(gc, tex, lp, color, s, t, result);
    } else {
	(*tex->linear)(gc, tex, &tex->level[d], color, s, t, &td);
	(*tex->linear)(gc, tex, &tex->level[d-1], color, s, t, &td1);
	f = __GL_FRAC(lod);
	omf = __glOne - f;
	switch (tex->level[0].baseFormat) {
	  case GL_LUMINANCE_ALPHA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    /* FALLTHROUGH */
	  case GL_LUMINANCE:
	    result->luminance = omf * td1.luminance + f * td.luminance;
	    break;
	  case GL_RGBA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    /* FALLTHROUGH */
	  case GL_RGB:
	    result->r = omf * td1.r + f * td.r;
	    result->g = omf * td1.g + f * td.g;
	    result->b = omf * td1.b + f * td.b;
	    break;
	  case GL_ALPHA:
	    result->alpha = omf * td1.alpha + f * td.alpha;
	    break;
	  case GL_INTENSITY:
	    result->intensity = omf * td1.intensity + f * td.intensity;
	    break;
	}
    }
}

/************************************************************************/

__GLfloat __glNopPolygonRho(__GLcontext *gc, const __GLshade *sh,
			    __GLfloat s, __GLfloat t, __GLfloat winv)
{
#ifdef __GL_LINT
    gc = gc;
    sh = sh;
    s = s;
    t = t;
    winv = winv;
#endif
    return __glZero;
}

/*
** Compute the "rho" (level of detail) parameter used by the texturing code.
** Instead of fully computing the derivatives compute nearby texture coordinates
** and discover the derivative.  The incoming s & t arguments have not
** been divided by winv yet.
*/
__GLfloat __glComputePolygonRho(__GLcontext *gc, const __GLshade *sh,
				__GLfloat s, __GLfloat t, __GLfloat qw)
{
    __GLfloat w0, w1, p0, p1;
    __GLfloat pupx, pupy, pvpx, pvpy;
    __GLfloat px, py, one;
    __GLtexture *tex = gc->texture.currentTexture;

    if( qw == (__GLfloat) 0.0 ) {
	return (__GLfloat) 0.0;
    }

    /* Compute partial of u with respect to x */
    one = __glOne;
    w0 = one / (qw - sh->dqwdx);
    w1 = one / (qw + sh->dqwdx);
    p0 = (s - sh->dsdx) * w0;
    p1 = (s + sh->dsdx) * w1;
    pupx = (p1 - p0) * tex->level[0].width2f;

    /* Compute partial of v with repsect to y */
    p0 = (t - sh->dtdx) * w0;
    p1 = (t + sh->dtdx) * w1;
    pvpx = (p1 - p0) * tex->level[0].height2f;

    /* Compute partial of u with respect to y */
    w0 = one / (qw - sh->dqwdy);
    w1 = one / (qw + sh->dqwdy);
    p0 = (s - sh->dsdy) * w0;
    p1 = (s + sh->dsdy) * w1;
    pupy = (p1 - p0) * tex->level[0].width2f;

    /* Figure partial of u&v with repsect to y */
    p0 = (t - sh->dtdy) * w0;
    p1 = (t + sh->dtdy) * w1;
    pvpy = (p1 - p0) * tex->level[0].height2f;

    /* Finally, figure sum of squares */
    px = pupx * pupx + pvpx * pvpx;
    py = pupy * pupy + pvpy * pvpy;

    /* Return largest value as the level of detail */
    if (px > py) {
	return px * ((__GLfloat) 0.25);
    } else {
	return py * ((__GLfloat) 0.25);
    }
}

__GLfloat __glNopLineRho(__GLcontext *gc, __GLfloat s, __GLfloat t, 
			 __GLfloat wInv)
{
#ifdef __GL_LINT
    gc = gc;
    s = s;
    t = t;
    wInv = wInv;
#endif
    return __glZero;
}

__GLfloat __glComputeLineRho(__GLcontext *gc, __GLfloat s, __GLfloat t, 
			     __GLfloat wInv)
{
    __GLfloat pspx, pspy, ptpx, ptpy;
    __GLfloat pupx, pupy, pvpx, pvpy;
    __GLfloat temp, pu, pv;
    __GLfloat magnitude, invMag, invMag2;
    __GLfloat dx, dy;
    __GLfloat s0w0, s1w1, t0w0, t1w1, w1Inv, w0Inv;
    const __GLvertex *v0 = gc->line.options.v0;
    const __GLvertex *v1 = gc->line.options.v1;

    /* Compute the length of the line (its magnitude) */
    dx = v1->window.x - v0->window.x;
    dy = v1->window.y - v0->window.y;
    magnitude = __GL_SQRTF(dx*dx + dy*dy);
    invMag = __glOne / magnitude;
    invMag2 = invMag * invMag;

    w0Inv = v0->window.w;
    w1Inv = v1->window.w;
    s0w0 = v0->texture.x * w0Inv;
    t0w0 = v0->texture.y * w0Inv;
    s1w1 = v1->texture.x * w1Inv;
    t1w1 = v1->texture.y * w1Inv;

    /* Compute s partials */
    temp = ((s1w1 - s0w0) - s * (w1Inv - w0Inv)) / wInv;
    pspx = temp * dx * invMag2;
    pspy = temp * dy * invMag2;

    /* Compute t partials */
    temp = ((t1w1 - t0w0) - t * (w1Inv - w0Inv)) / wInv;
    ptpx = temp * dx * invMag2;
    ptpy = temp * dy * invMag2;

    pupx = pspx * gc->texture.currentTexture->level[0].width2;
    pupy = pspy * gc->texture.currentTexture->level[0].width2;
    pvpx = ptpx * gc->texture.currentTexture->level[0].height2;
    pvpy = ptpy * gc->texture.currentTexture->level[0].height2;

    /* Now compute rho */
    pu = pupx * dx + pupy * dy;
    pu = pu * pu;
    pv = pvpx * dx + pvpy * dy;
    pv = pv * pv;
    return (pu + pv) * invMag2;
}

/************************************************************************/

/*
** Fast texture a fragment assumes that rho is noise - this is true
** when no mipmapping is being done and the min and mag filters are
** the same.
*/
void __glFastTextureFragment(__GLcontext *gc, __GLcolor *color,
			     __GLfloat s, __GLfloat t, __GLfloat rho)
{
    __GLtexture *tex = gc->texture.currentTexture;
    __GLtexel texel;

#ifdef __GL_LINT
    rho = rho;
#endif
    (*tex->magnify)(gc, tex, __glZero, color, s, t, &texel);
    (*tex->env)(gc, color, &texel);
}

/*
** Non-mipmapping texturing function.
*/
void __glTextureFragment(__GLcontext *gc, __GLcolor *color,
			 __GLfloat s, __GLfloat t, __GLfloat rho)
{
    __GLtexture *tex = gc->texture.currentTexture;
    __GLtexel texel;

    if (rho <= tex->c) {
	(*tex->magnify)(gc, tex, __glZero, color, s, t, &texel);
    } else {
	(*tex->minnify)(gc, tex, __glZero, color, s, t, &texel);
    }

    /* Now apply texture environment to get final color */
    (*tex->env)(gc, color, &texel);
}

void __glMipMapFragment(__GLcontext *gc, __GLcolor *color,
			__GLfloat s, __GLfloat t, __GLfloat rho)
{
    __GLtexture *tex = gc->texture.currentTexture;
    __GLtexel texel;

    /* In the spec c is given in terms of lambda.
    ** Here c is compared to rho (really rho^2) and adjusted accordingly.
    */
    if (rho <= tex->c) {
	/* NOTE: rho is ignored by magnify proc */
	(*tex->magnify)(gc, tex, rho, color, s, t, &texel);
    } else {
	if (rho) {
	    /* Convert rho to lambda */
	    /* This is an approximation of log base 2 */
            // Note that these approximations are inaccurate for rho < 1.0, but
            // rho is less than tex->c to get here.  Since currently tex->c is
            // a constant 1.0, this is not a problem.
            // This method directly manipulates the floating point binary
            // representation.

#define __GL_FLOAT_EXPONENT_ZERO \
    (__GL_FLOAT_EXPONENT_BIAS << __GL_FLOAT_EXPONENT_SHIFT)

            unsigned int lrho;
            LONG exponent;

            ASSERTOPENGL( rho >= 1.0f, "Log base 2 approximation not accurate");
            // Extract exponent
            lrho = CASTFIX(rho);
            exponent = ( (lrho & __GL_FLOAT_EXPONENT_MASK) 
                         >> __GL_FLOAT_EXPONENT_SHIFT )
                       - __GL_FLOAT_EXPONENT_BIAS;

            // Extract fractional part of the floating point number
            lrho &= ~__GL_FLOAT_EXPONENT_MASK; // dump current exponent
            lrho |= __GL_FLOAT_EXPONENT_ZERO;  // zap in zero exponent
            // Convert back to float, subtract implicit mantissa 1.0, and
            // add the exponent value to yield the approximation.
            rho = (CASTFLOAT(lrho) - 1.0f + (__GLfloat) exponent) * 0.5f;
	} else {
	    rho = __glZero;
	}
	(*tex->minnify)(gc, tex, rho, color, s, t, &texel);
    }

    /* Now apply texture environment to get final color */
    (*tex->env)(gc, color, &texel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_texim.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include <glmath.h>
#include <devlock.h>

static __GLtexture *CheckTexImageArgs(__GLcontext *gc, GLenum target, GLint lod,
				      GLint components, GLint border,
				      GLenum format, GLenum type, GLint dim)
{
    __GLtexture *tex = __glLookUpTexture(gc, target);

    if (!tex || (tex->dim != dim)) {
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return 0;
    }

    switch (type) {
      case GL_BITMAP:
	if (format != GL_COLOR_INDEX) goto bad_enum;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	goto bad_enum;
    }

    switch (format) {
      case GL_COLOR_INDEX:	case GL_RED:
      case GL_GREEN:		case GL_BLUE:
      case GL_ALPHA:		case GL_RGB:
      case GL_RGBA:		case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	break;
      default:
	goto bad_enum;
    }

    if ((lod < 0) || (lod >= gc->constants.maxMipMapLevel)) {
	__glSetError(GL_INVALID_VALUE);
	return 0;
    }

    switch (components) {
      case GL_LUMINANCE:	case 1:
      case GL_LUMINANCE4:	case GL_LUMINANCE8:
      case GL_LUMINANCE12:	case GL_LUMINANCE16:
	break;
      case GL_LUMINANCE_ALPHA:	        case 2:
      case GL_LUMINANCE4_ALPHA4:	case GL_LUMINANCE6_ALPHA2:
      case GL_LUMINANCE8_ALPHA8:	case GL_LUMINANCE12_ALPHA4:
      case GL_LUMINANCE12_ALPHA12:	case GL_LUMINANCE16_ALPHA16:
	break;
      case GL_RGB:		case 3:
      case GL_R3_G3_B2:		case GL_RGB4:
      case GL_RGB5:		case GL_RGB8:
      case GL_RGB10:	        case GL_RGB12:
      case GL_RGB16:
	break;
      case GL_RGBA:		case 4:
      case GL_RGBA2:	        case GL_RGBA4:
      case GL_RGBA8:	        case GL_RGBA12:
      case GL_RGBA16:	        case GL_RGB5_A1:
      case GL_RGB10_A2:
	break;
      case GL_ALPHA:
      case GL_ALPHA4:	        case GL_ALPHA8:
      case GL_ALPHA12:	        case GL_ALPHA16:
	break;
      case GL_INTENSITY:
      case GL_INTENSITY4:	case GL_INTENSITY8:
      case GL_INTENSITY12:	case GL_INTENSITY16:
	break;
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX1_EXT:     case GL_COLOR_INDEX2_EXT:
      case GL_COLOR_INDEX4_EXT:     case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX12_EXT:    case GL_COLOR_INDEX16_EXT:
        if (format != GL_COLOR_INDEX)
        {
            __glSetError(GL_INVALID_OPERATION);
            return NULL;
        }
        break;
#endif
      default:
	goto bad_enum;
    }

    if ((border < 0) || (border > 1)) {
#ifdef NT
	__glSetError(GL_INVALID_VALUE);
	return 0;
#else
	goto bad_enum;
#endif
    }

    return tex;
}

#ifdef GL_EXT_paletted_texture
// Attempt to set the extraction function.  If no palette is set,
// this can't be done
void __glSetPaletteLevelExtract8(__GLtexture *tex, __GLmipMapLevel *lp,
                                 GLint border)
{
    if (tex->paletteBaseFormat == GL_RGB)
    {
        if (border)
        {
            lp->extract = __glExtractTexelPI8BGR_B;
        }
        else
        {
            lp->extract = __glExtractTexelPI8BGR;
        }
    }
    else if (tex->paletteBaseFormat == GL_RGBA)
    {
            
        if (border)
        {
            lp->extract = __glExtractTexelPI8BGRA_B;
        }
        else
        {
            lp->extract = __glExtractTexelPI8BGRA;
        }
    }
#if DBG
    else
    {
        ASSERTOPENGL(tex->paletteBaseFormat == GL_NONE,
                     "Unexpected paletteBaseFormat\n");
    }
#endif
}

void __glSetPaletteLevelExtract16(__GLtexture *tex, __GLmipMapLevel *lp,
                                  GLint border)
{
    if (tex->paletteBaseFormat == GL_RGB)
    {
        if (border)
        {
            lp->extract = __glExtractTexelPI16BGR_B;
        }
        else
        {
            lp->extract = __glExtractTexelPI16BGR;
        }
    }
    else if (tex->paletteBaseFormat == GL_RGBA)
    {
        if (border)
        {
            lp->extract = __glExtractTexelPI16BGRA_B;
        }
        else
        {
            lp->extract = __glExtractTexelPI16BGRA;
        }
    }
#if DBG
    else
    {
        ASSERTOPENGL(tex->paletteBaseFormat == GL_NONE,
                     "Unexpected paletteBaseFormat\n");
    }
#endif
}
#endif // GL_EXT_paletted_texture

static GLint ComputeTexLevelSize(__GLcontext *gc, __GLtexture *tex,
				 __GLmipMapLevel *lp, GLint lod,
				 GLint components, GLsizei w, GLsizei h,
				 GLint border, GLint dim)
{
    GLint texelStorageSize;

    if ((w - border*2) > gc->constants.maxTextureSize ||
	(h - border*2) > gc->constants.maxTextureSize)
    {
	return -1;
    }

    lp->requestedFormat = (GLenum) components;
    lp->redSize = 0;
    lp->greenSize = 0;
    lp->blueSize = 0;
    lp->alphaSize = 0;
    lp->luminanceSize = 0;
    lp->intensitySize = 0;

    switch (lp->requestedFormat) {
      case GL_LUMINANCE:	case 1:
      case GL_LUMINANCE4:	case GL_LUMINANCE8:
      case GL_LUMINANCE12:	case GL_LUMINANCE16:
	lp->baseFormat = GL_LUMINANCE;
	lp->internalFormat = GL_LUMINANCE;
	lp->luminanceSize = 24;
	texelStorageSize = 1 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelL_B;
	} else {
	    lp->extract = __glExtractTexelL;
	}
	break;
      case GL_LUMINANCE_ALPHA:	        case 2:
      case GL_LUMINANCE4_ALPHA4:	case GL_LUMINANCE6_ALPHA2:
      case GL_LUMINANCE8_ALPHA8:	case GL_LUMINANCE12_ALPHA4:
      case GL_LUMINANCE12_ALPHA12:	case GL_LUMINANCE16_ALPHA16:
	lp->baseFormat = GL_LUMINANCE_ALPHA;
	lp->internalFormat = GL_LUMINANCE_ALPHA;
	lp->luminanceSize = 24;
	lp->alphaSize = 24;
	texelStorageSize = 2 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelLA_B;
	} else {
	    lp->extract = __glExtractTexelLA;
	}
	break;
      case GL_RGB:		case 3:
      case GL_R3_G3_B2:		case GL_RGB4:
      case GL_RGB5:		case GL_RGB8:
	lp->baseFormat = GL_RGB;
	lp->internalFormat = GL_BGR_EXT;
	lp->redSize = 8;
	lp->greenSize = 8;
	lp->blueSize = 8;
        // Kept as 32-bit quantities for alignment
	texelStorageSize = 4 * sizeof(GLubyte);
	if (border) {
	    lp->extract = __glExtractTexelBGR8_B;
	} else {
	    lp->extract = __glExtractTexelBGR8;
	}
        break;
      case GL_RGB10:	case GL_RGB12:
      case GL_RGB16:
	lp->baseFormat = GL_RGB;
	lp->internalFormat = GL_RGB;
	lp->redSize = 24;
	lp->greenSize = 24;
	lp->blueSize = 24;
	texelStorageSize = 3 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelRGB_B;
	} else {
	    lp->extract = __glExtractTexelRGB;
	}
	break;
      case GL_RGBA:		case 4:
      case GL_RGBA2:	        case GL_RGBA4:
      case GL_RGBA8:            case GL_RGB5_A1:
	lp->baseFormat = GL_RGBA;
	lp->internalFormat = GL_BGRA_EXT;
	lp->redSize = 8;
	lp->greenSize = 8;
	lp->blueSize = 8;
	lp->alphaSize = 8;
	texelStorageSize = 4 * sizeof(GLubyte);
	if (border) {
	    lp->extract = __glExtractTexelBGRA8_B;
	} else {
	    lp->extract = __glExtractTexelBGRA8;
	}
        break;
      case GL_RGBA12:       case GL_RGBA16:
      case GL_RGB10_A2:
	lp->baseFormat = GL_RGBA;
	lp->internalFormat = GL_RGBA;
	lp->redSize = 24;
	lp->greenSize = 24;
	lp->blueSize = 24;
	lp->alphaSize = 24;
	texelStorageSize = 4 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelRGBA_B;
	} else {
	    lp->extract = __glExtractTexelRGBA;
	}
	break;
      case GL_ALPHA:
      case GL_ALPHA4:	case GL_ALPHA8:
      case GL_ALPHA12:	case GL_ALPHA16:
	lp->baseFormat = GL_ALPHA;
	lp->internalFormat = GL_ALPHA;
	lp->alphaSize = 24;
	texelStorageSize = 1 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelA_B;
	} else {
	    lp->extract = __glExtractTexelA;
	}
	break;
      case GL_INTENSITY:
      case GL_INTENSITY4:	case GL_INTENSITY8:
      case GL_INTENSITY12:	case GL_INTENSITY16:
	lp->baseFormat = GL_INTENSITY;
	lp->internalFormat = GL_INTENSITY;
	lp->intensitySize = 24;
	texelStorageSize = 1 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelI_B;
	} else {
	    lp->extract = __glExtractTexelI;
	}
	break;
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX1_EXT:
      case GL_COLOR_INDEX2_EXT:
      case GL_COLOR_INDEX4_EXT:
      case GL_COLOR_INDEX8_EXT:
        // Inherit the current palette data type
	lp->baseFormat = tex->paletteBaseFormat;
	lp->internalFormat = GL_COLOR_INDEX8_EXT;
	texelStorageSize = sizeof(GLubyte);
        __glSetPaletteLevelExtract8(tex, lp, border);
        break;
      case GL_COLOR_INDEX12_EXT:
      case GL_COLOR_INDEX16_EXT:
        // Inherit the current palette data type
	lp->baseFormat = tex->paletteBaseFormat;
	lp->internalFormat = GL_COLOR_INDEX16_EXT;
	texelStorageSize = sizeof(GLushort);
        __glSetPaletteLevelExtract16(tex, lp, border);
        break;
#endif
      default:
	break;
    }

    return (w * h * texelStorageSize);
}

__GLtextureBuffer *FASTCALL __glCreateProxyLevel(__GLcontext *gc,
                                                 __GLtexture *tex,
				      GLint lod, GLint components,
				      GLsizei w, GLsizei h, GLint border,
				      GLint dim)
{
    __GLmipMapLevel templ, *lp = &tex->level[lod];
    GLint size;

    size = ComputeTexLevelSize(gc, tex, &templ, lod, components,
			       w, h, border, dim);

    if (size < 0) {
	/* Proxy allocation failed */
	lp->width = 0;
	lp->height = 0;
	lp->border = 0;
	lp->requestedFormat = 0;
	lp->baseFormat = 0;
	lp->internalFormat = 0;
	lp->redSize = 0;
	lp->greenSize = 0;
	lp->blueSize = 0;
	lp->alphaSize = 0;
	lp->luminanceSize = 0;
	lp->intensitySize = 0;
	lp->extract = __glNopExtract;
    } else {
	/* Proxy allocation succeeded */
	lp->width = w;
	lp->height = h;
	lp->border = border;
	lp->requestedFormat = templ.requestedFormat;
	lp->baseFormat = templ.baseFormat;
	lp->internalFormat = templ.internalFormat;
	lp->redSize = templ.redSize;
	lp->greenSize = templ.greenSize;
	lp->blueSize = templ.blueSize;
	lp->alphaSize = templ.alphaSize;
	lp->luminanceSize = templ.luminanceSize;
	lp->intensitySize = templ.intensitySize;
	lp->extract = templ.extract;
    }
    return 0;
}

__GLtextureBuffer *FASTCALL __glCreateLevel(__GLcontext *gc, __GLtexture *tex,
				      GLint lod, GLint components,
				      GLsizei w, GLsizei h, GLint border,
				      GLint dim)
{
    __GLmipMapLevel templ, *lp = &tex->level[lod];
    GLint size;
#ifdef NT
    __GLtextureBuffer* pbuffer;
#endif

    size = ComputeTexLevelSize(gc, tex, &templ, lod, components,
			       w, h, border, dim);

    if (size < 0) {
	__glSetError(GL_INVALID_VALUE);
	return 0;
    }

    pbuffer = (__GLtextureBuffer*)
        GCREALLOC(gc, lp->buffer, (size_t)size);
    if (!pbuffer && size != 0)
        GCFREE(gc, lp->buffer);
    lp->buffer = pbuffer;

    if (lp->buffer) {
	/* Fill in new level info */
	lp->width = w;
	lp->height = h;
	lp->width2 = w - border*2;
	lp->widthLog2 = __glIntLog2(lp->width2);
        lp->height2 = h - border*2;
        lp->heightLog2 = __glIntLog2(lp->height2);
	lp->width2f = lp->width2;
	lp->height2f = lp->height2;
	lp->border = border;
	lp->requestedFormat = templ.requestedFormat;
	lp->baseFormat = templ.baseFormat;
	lp->internalFormat = templ.internalFormat;
	lp->redSize = templ.redSize;
	lp->greenSize = templ.greenSize;
	lp->blueSize = templ.blueSize;
	lp->alphaSize = templ.alphaSize;
	lp->luminanceSize = templ.luminanceSize;
	lp->intensitySize = templ.intensitySize;
	lp->extract = templ.extract;
    } else {
	/* Out of memory or the texture level is being freed */
	lp->width = 0;
	lp->height = 0;
	lp->width2 = 0;
	lp->height2 = 0;
	lp->widthLog2 = 0;
	lp->heightLog2 = 0;
	lp->border = 0;
	lp->requestedFormat = 0;
	lp->baseFormat = 0;
	lp->internalFormat = 0;
	lp->redSize = 0;
	lp->greenSize = 0;
	lp->blueSize = 0;
	lp->alphaSize = 0;
	lp->luminanceSize = 0;
	lp->intensitySize = 0;
	lp->extract = __glNopExtract;
    }

    if (lod == 0) {
	tex->p = lp->heightLog2;
	if (lp->widthLog2 > lp->heightLog2) {
	    tex->p = lp->widthLog2;
	}
    }
    return lp->buffer;
}

void FASTCALL __glInitTextureStore(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLenum internalFormat)
{
    spanInfo->dstSkipPixels = 0;
    spanInfo->dstSkipLines = 0;
    spanInfo->dstSwapBytes = GL_FALSE;
    spanInfo->dstLsbFirst = GL_TRUE;
    spanInfo->dstLineLength = spanInfo->width;

    switch(internalFormat) {
      case GL_LUMINANCE:
	spanInfo->dstFormat = GL_RED;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_LUMINANCE_ALPHA:
	spanInfo->dstFormat = __GL_RED_ALPHA;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_RGB:
	spanInfo->dstFormat = GL_RGB;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_RGBA:
	spanInfo->dstFormat = GL_RGBA;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_ALPHA:
	spanInfo->dstFormat = GL_ALPHA;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_INTENSITY:
	spanInfo->dstFormat = GL_RED;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_BGR_EXT:
        // Be a little tricky here to pad the data out
        // to 32 bits
	spanInfo->dstFormat = GL_BGRA_EXT;
	spanInfo->dstType = GL_UNSIGNED_BYTE;
        spanInfo->dstAlignment = 4;
	break;
      case GL_BGRA_EXT:
	spanInfo->dstFormat = GL_BGRA_EXT;
	spanInfo->dstType = GL_UNSIGNED_BYTE;
        spanInfo->dstAlignment = 4;
	break;
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX16_EXT:
        spanInfo->dstFormat = GL_COLOR_INDEX;
        spanInfo->dstType =
            internalFormat == GL_COLOR_INDEX8_EXT ?
            GL_UNSIGNED_BYTE : GL_UNSIGNED_SHORT;
        spanInfo->dstAlignment = 1;
        break;
#endif
    }
}

/*
** Used for extraction from textures.  "packed" is set to GL_TRUE if this
** image is being pulled out of a display list, and GL_FALSE if it is 
** being pulled directly out of an application.
*/
void FASTCALL __glInitTextureUnpack(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
		           GLint width, GLint height, GLenum format, 
			   GLenum type, const GLvoid *buf,
			   GLenum internalFormat, GLboolean packed)
{
    spanInfo->x = 0;
    spanInfo->zoomx = __glOne;
    spanInfo->realWidth = spanInfo->width = width;
    spanInfo->height = height;
    spanInfo->srcFormat = format;
    spanInfo->srcType = type;
    spanInfo->srcImage = buf;
    __glInitTextureStore(gc, spanInfo, internalFormat);
    __glLoadUnpackModes(gc, spanInfo, packed);
}

/*
** Return GL_TRUE if the given range (length or width/height) is a legal
** power of 2, taking into account the border.  The range is not allowed
** to be negative either.
*/
static GLboolean FASTCALL IsLegalRange(__GLcontext *gc, GLsizei r, GLint border)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    r -= border * 2;
    if ((r < 0) || (r & (r - 1))) {
	__glSetError(GL_INVALID_VALUE);
	return GL_FALSE;
    }
    return GL_TRUE;
}

__GLtexture *FASTCALL __glCheckTexImage1DArgs(__GLcontext *gc, GLenum target, GLint lod,
				     GLint components, GLsizei length,
				     GLint border, GLenum format, GLenum type)
{
    __GLtexture *tex;

    /* Check arguments and get the right texture being changed */
    tex = CheckTexImageArgs(gc, target, lod, components, border,
			    format, type, 1);
    if (!tex) {
	return 0;
    }
    if (!IsLegalRange(gc, length, border)) {
	return 0;
    }
    return tex;
}

__GLtexture *FASTCALL __glCheckTexImage2DArgs(__GLcontext *gc, GLenum target, GLint lod,
				     GLint components, GLsizei w, GLsizei h,
				     GLint border, GLenum format, GLenum type)
{
    __GLtexture *tex;

    /* Check arguments and get the right texture being changed */
    tex = CheckTexImageArgs(gc, target, lod, components, border,
			    format, type, 2);
    if (!tex) {
	return 0;
    }
    if (!IsLegalRange(gc, w, border)) {
	return 0;
    }
    if (!IsLegalRange(gc, h, border)) {
	return 0;
    }
    return tex;
}

#ifdef NT
void APIPRIVATE __glim_TexImage1D(GLenum target, GLint lod, 
		       GLint components, GLsizei length,
		       GLint border, GLenum format,
		       GLenum type, const GLvoid *buf, GLboolean _IsDlist)
#else
void APIPRIVATE __glim_TexImage1D(GLenum target, GLint lod, 
		       GLint components, GLsizei length,
		       GLint border, GLenum format,
		       GLenum type, const GLvoid *buf)
#endif
{
    __GLtexture *tex;
    __GLtextureBuffer *dest;
    __GLpixelSpanInfo spanInfo;
    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    /* Check arguments and get the right texture being changed */
    tex = __glCheckTexImage1DArgs(gc, target, lod, components, length,
				  border, format, type);
    if (!tex) {
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Allocate memory for the level data */
    dest = (*tex->createLevel)(gc, tex, lod, components,
			       length, 1+border*2, border, 1);

    /* Copy image data */
    if (buf && dest) {
        spanInfo.dstImage = dest;
#ifdef NT
        __glInitTextureUnpack(gc, &spanInfo, length, 1, format, type, buf, 
			      tex->level[lod].internalFormat,
			      (GLboolean) (_IsDlist ? GL_TRUE : GL_FALSE));
#else
        __glInitTextureUnpack(gc, &spanInfo, length, 1, format, type, buf, 
			      tex->level[lod].internalFormat, GL_FALSE);
#endif
	spanInfo.dstSkipLines += border;
        __glInitUnpacker(gc, &spanInfo);
        __glInitPacker(gc, &spanInfo);
        (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
        __glTexPriListLoadImage(gc, GL_TEXTURE_1D);
#endif
    }

    /* Might have just disabled texturing... */
    __GL_DELAY_VALIDATE(gc);
}

#ifndef NT
void __gllei_TexImage1D(__GLcontext *gc, GLenum target, GLint lod,
		        GLint components, GLsizei length, GLint border,
		        GLenum format, GLenum type, const GLubyte *image)
{
    __GLtexture *tex;
    __GLtextureBuffer *dest;
    __GLpixelSpanInfo spanInfo;
    GLuint beginMode;

    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

    /* Check arguments and get the right texture being changed */
    tex = __glCheckTexImage1DArgs(gc, target, lod, components, length,
				  border, format, type);
    if (!tex) {
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Allocate memory for the level data */
    dest = (*tex->createLevel)(gc, tex, lod, components,
			       length, 1+border*2, border, 1);

    /* Copy image data */
    if (image && dest) {
        spanInfo.dstImage = dest;
        __glInitTextureUnpack(gc, &spanInfo, length, 1, format, type, image,
			      tex->level[lod].internalFormat, GL_TRUE);
	spanInfo.dstSkipLines += border;
        __glInitUnpacker(gc, &spanInfo);
        __glInitPacker(gc, &spanInfo);
        (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
        __glTexPriListLoadImage(gc, GL_TEXTURE_1D);
#endif
    }

    /* Might have just disabled texturing... */
    __GL_DELAY_VALIDATE(gc);
}
#endif // !NT

/************************************************************************/

void APIPRIVATE __glim_TexImage2D(GLenum target, GLint lod, GLint components,
		       GLsizei w, GLsizei h, GLint border, GLenum format,
		       GLenum type, const GLvoid *buf, GLboolean _IsDlist)
{
    __GLtexture *tex;
    __GLtextureBuffer *dest;
    __GLpixelSpanInfo spanInfo;
    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    /* Check arguments and get the right texture being changed */
    tex = __glCheckTexImage2DArgs(gc, target, lod, components, w, h,
				  border, format, type);
    if (!tex) {
	return;
    }

    // Check for a DirectDraw texture
    if (target == GL_TEXTURE_2D && gc->texture.ddtex.levels > 0)
    {
        __glSetError(GL_INVALID_OPERATION);
        return;
    }
    
    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Allocate memory for the level data */
    dest = (*tex->createLevel)(gc, tex, lod, components, w, h, border, 2);

    /* Copy image data */
    if (buf && dest) {
        spanInfo.dstImage = dest;
#ifdef NT
        __glInitTextureUnpack(gc, &spanInfo, w, h, format, type, buf,
			      (GLenum) tex->level[lod].internalFormat,
			      (GLboolean) (_IsDlist ? GL_TRUE : GL_FALSE));
#else
        __glInitTextureUnpack(gc, &spanInfo, w, h, format, type, buf,
			      tex->level[lod].internalFormat, GL_FALSE);
#endif
        __glInitUnpacker(gc, &spanInfo);
        __glInitPacker(gc, &spanInfo);
        (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
        __glTexPriListLoadImage(gc, GL_TEXTURE_2D);
#endif
    }

    /* Might have just disabled texturing... */
    __GL_DELAY_VALIDATE(gc);
}

#ifndef NT
void __gllei_TexImage2D(__GLcontext *gc, GLenum target, GLint lod, 
		        GLint components, GLsizei w, GLsizei h, 
		        GLint border, GLenum format, GLenum type,
		        const GLubyte *image)
{
    __GLtexture *tex;
    __GLtextureBuffer *dest;
    __GLpixelSpanInfo spanInfo;
    GLuint beginMode;

    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

    /* Check arguments and get the right texture being changed */
    tex = __glCheckTexImage2DArgs(gc, target, lod, components, w, h,
				  border, format, type);
    if (!tex) {
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Allocate memory for the level data */
    dest = (*tex->createLevel)(gc, tex, lod, components, w, h, border, 2);

    /* Copy image data */
    if (image && dest) {
        spanInfo.dstImage = dest;
        __glInitTextureUnpack(gc, &spanInfo, w, h, format, type, image,
			      tex->level[lod].internalFormat, GL_TRUE);
        __glInitUnpacker(gc, &spanInfo);
        __glInitPacker(gc, &spanInfo);
        (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
        __glTexPriListLoadImage(gc, GL_TEXTURE_2D);
#endif
    }

    /* Might have just disabled texturing... */
    __GL_DELAY_VALIDATE(gc);
}
#endif // !NT

/***********************************************************************/

static __GLtexture *CheckTexSubImageArgs(__GLcontext *gc, GLenum target,
					 GLint lod, GLenum format,
					 GLenum type, GLint dim)
{
    __GLtexture *tex = __glLookUpTexture(gc, target);
    __GLmipMapLevel *lp;

    if (!tex || (target == GL_PROXY_TEXTURE_1D) ||
		(target == GL_PROXY_TEXTURE_2D))
    {
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return 0;
    }

    if (tex->dim != dim) {
	goto bad_enum;
    }

    switch (type) {
      case GL_BITMAP:
	if (format != GL_COLOR_INDEX) goto bad_enum;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	goto bad_enum;
    }

    switch (format) {
      case GL_COLOR_INDEX:	case GL_RED:
      case GL_GREEN:		case GL_BLUE:
      case GL_ALPHA:		case GL_RGB:
      case GL_RGBA:		case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	break;
      default:
	goto bad_enum;
    }

    if ((lod < 0) || (lod >= gc->constants.maxMipMapLevel)) {
	__glSetError(GL_INVALID_VALUE);
	return 0;
    }

#ifdef GL_EXT_paletted_texture
    lp = &tex->level[lod];
    if ((lp->internalFormat == GL_COLOR_INDEX8_EXT ||
         lp->internalFormat == GL_COLOR_INDEX16_EXT) &&
        format != GL_COLOR_INDEX)
    {
        goto bad_enum;
    }
#endif

    return tex;
}

/*
** Used for extraction from textures.  "packed" is set to GL_TRUE if this
** image is being pulled out of a display list, and GL_FALSE if it is 
** being pulled directly out of an application.
*/
void __glInitTexSubImageUnpack(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
			       __GLmipMapLevel *lp,
		               GLsizei xoffset, GLsizei yoffset,
			       GLint width, GLint height, GLenum format, 
			       GLenum type, const GLvoid *buf, GLboolean packed)
{
    spanInfo->x = 0;
    spanInfo->zoomx = __glOne;
    spanInfo->realWidth = spanInfo->width = width;
    spanInfo->height = height;
    spanInfo->srcFormat = format;
    spanInfo->srcType = type;
    spanInfo->srcImage = buf;

    __glLoadUnpackModes(gc, spanInfo, packed);

    spanInfo->dstImage = lp->buffer;
    spanInfo->dstSkipPixels = xoffset + lp->border;
    spanInfo->dstSkipLines = yoffset + lp->border;
    spanInfo->dstSwapBytes = GL_FALSE;
    spanInfo->dstLsbFirst = GL_TRUE;
    spanInfo->dstLineLength = lp->width;

    switch(lp->internalFormat) {
      case GL_LUMINANCE:
	spanInfo->dstFormat = GL_RED;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
      case GL_LUMINANCE_ALPHA:
	spanInfo->dstFormat = __GL_RED_ALPHA;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
      case GL_RGB:
	spanInfo->dstFormat = GL_RGB;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
      case GL_RGBA:
	spanInfo->dstFormat = GL_RGBA;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
      case GL_ALPHA:
	spanInfo->dstFormat = GL_ALPHA;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
      case GL_INTENSITY:
	spanInfo->dstFormat = GL_RED;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
    case GL_BGR_EXT:
        // Be a little tricky here to pad the data out to 32 bits
	spanInfo->dstFormat = GL_BGRA_EXT;
	spanInfo->dstType = GL_UNSIGNED_BYTE;
	spanInfo->dstAlignment = 4;
        break;
    case GL_BGRA_EXT:
	spanInfo->dstFormat = GL_BGRA_EXT;
	spanInfo->dstType = GL_UNSIGNED_BYTE;
	spanInfo->dstAlignment = 4;
        break;
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX16_EXT:
        spanInfo->dstFormat = GL_COLOR_INDEX;
        spanInfo->dstType =
            lp->internalFormat == GL_COLOR_INDEX8_EXT ?
            GL_UNSIGNED_BYTE : GL_UNSIGNED_SHORT;
	spanInfo->dstAlignment = 1;
        break;
#endif
    }
}

static GLboolean CheckTexSubImageRange(__GLcontext *gc, __GLmipMapLevel *lp,
				       GLint xoffset, GLint yoffset,
				       GLsizei w, GLsizei h)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    if ((w < 0) || (h < 0) ||
	(xoffset < -lp->border) || (xoffset+w > lp->width-lp->border) ||
        (yoffset < -lp->border) || (yoffset+h > lp->height-lp->border))
    {
	__glSetError(GL_INVALID_VALUE);
	return GL_FALSE;
    }
    return GL_TRUE;
}

__GLtexture *__glCheckTexSubImage1DArgs(__GLcontext *gc, GLenum target,
					GLint lod,
					GLint xoffset, GLint length,
					GLenum format, GLenum type)
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;

    /* Check arguments and get the right texture being changed */
    tex = CheckTexSubImageArgs(gc, target, lod, format, type, 1);
    if (!tex) {
	return 0;
    }
    lp = &tex->level[lod];
    if (!CheckTexSubImageRange(gc, lp, xoffset, 0, length, 1)) {
	return 0;
    }
    return tex;
}

__GLtexture *__glCheckTexSubImage2DArgs(__GLcontext *gc, GLenum target,
					GLint lod,
					GLint xoffset, GLint yoffset,
					GLsizei w, GLsizei h,
					GLenum format, GLenum type)
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;

    /* Check arguments and get the right texture being changed */
    tex = CheckTexSubImageArgs(gc, target, lod, format, type, 2);
    if (!tex) {
	return 0;
    }
    lp = &tex->level[lod];
    if (!CheckTexSubImageRange(gc, lp, xoffset, yoffset, w, h)) {
	return 0;
    }
    return tex;
}

#ifdef NT
void APIPRIVATE __glim_TexSubImage1D(GLenum target, GLint lod, 
		       GLint xoffset, GLint length,
		       GLenum format, GLenum type, const GLvoid *buf,
		       GLboolean _IsDlist)
#else
void APIPRIVATE __glim_TexSubImage1D(GLenum target, GLint lod, 
		       GLint xoffset, GLint length,
		       GLenum format, GLenum type, const GLvoid *buf)
#endif
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GLpixelSpanInfo spanInfo;
    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    /* Check arguments and get the right texture level being changed */
    tex = __glCheckTexSubImage1DArgs(gc, target, lod, xoffset, length,
				     format, type);
    if (!tex) {
	return;
    }

    lp = &tex->level[lod];
    if (lp->buffer == NULL) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Copy sub-image data */
#ifdef NT
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, 0, length, 1,
			      format, type, buf,
			      (GLboolean) (_IsDlist ? GL_TRUE : GL_FALSE));
#else
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, 0, length, 1,
			      format, type, buf, GL_FALSE);
#endif
    spanInfo.dstSkipLines += lp->border;
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
    __glTexPriListLoadSubImage(gc, GL_TEXTURE_1D, lod, xoffset, 0,
                               length, 1);
#endif
}

#ifndef NT
void __gllei_TexSubImage1D(__GLcontext *gc, GLenum target, GLint lod,
		        GLint xoffset, GLint length,
		        GLenum format, GLenum type, const GLubyte *image)
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GLpixelSpanInfo spanInfo;
    GLuint beginMode;

    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

    /* Check arguments and get the right texture level being changed */
    tex = __glCheckTexSubImage1DArgs(gc, target, lod, xoffset, length,
				     format, type);
    if (!tex) {
	return;
    }

    lp = &tex->level[lod];
    if (lp->buffer == NULL) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Copy sub-image data */
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, 0, length, 1,
			      format, type, image, GL_TRUE);
    spanInfo.dstSkipLines += lp->border;
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
    __glTexPriListLoadSubImage(gc, GL_TEXTURE_1D, lod, xoffset, 0,
                               length, 1);
#endif
}
#endif // !NT

#ifdef NT
void APIPRIVATE __glim_TexSubImage2D(GLenum target, GLint lod,
		       GLint xoffset, GLint yoffset,
		       GLsizei w, GLsizei h, GLenum format,
		       GLenum type, const GLvoid *buf, GLboolean _IsDlist)
#else
void APIPRIVATE __glim_TexSubImage2D(GLenum target, GLint lod,
		       GLint xoffset, GLint yoffset,
		       GLsizei w, GLsizei h, GLenum format,
		       GLenum type, const GLvoid *buf)
#endif
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GLpixelSpanInfo spanInfo;
    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    /* Check arguments and get the right texture level being changed */
    tex = __glCheckTexSubImage2DArgs(gc, target, lod, xoffset, yoffset, w, h,
				     format, type);
    if (!tex) {
	return;
    }

    lp = &tex->level[lod];
    if (lp->buffer == NULL) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Copy sub-image data */
#ifdef NT
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, yoffset, w, h,
			      format, type, buf,
			      (GLboolean) (_IsDlist ? GL_TRUE : GL_FALSE));
#else
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, yoffset, w, h,
			      format, type, buf, GL_FALSE);
#endif
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
    __glTexPriListLoadSubImage(gc, GL_TEXTURE_2D, lod, xoffset, yoffset,
                               w, h);
#endif
}

#ifndef NT
void __gllei_TexSubImage2D(__GLcontext *gc, GLenum target, GLint lod, 
		        GLint xoffset, GLint yoffset,
			GLsizei w, GLsizei h, GLenum format, GLenum type,
		        const GLubyte *image)
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GLpixelSpanInfo spanInfo;
    GLuint beginMode;

    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

    /* Check arguments and get the right texture level being changed */
    tex = __glCheckTexSubImage2DArgs(gc, target, lod, xoffset, yoffset, w, h,
				     format, type);
    if (!tex) {
	return;
    }

    lp = &tex->level[lod];
    if (lp->buffer == NULL) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Copy sub-image data */
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, yoffset, w, h,
			      format, type, image, GL_TRUE);
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
    __glTexPriListLoadSubImage(gc, GL_TEXTURE_2D, lod, xoffset, yoffset,
                               w, h);
#endif
}
#endif // !NT

/************************************************************************/

// Routine to set up all the correct pixel modes for a straight data
// copy.  Preserves state for later shutoff
typedef struct _StraightCopyStorage
{
    __GLpixelPackMode pack;
    __GLpixelUnpackMode unpack;
    __GLpixelTransferMode transfer;
} StraightCopyStorage;

void StartStraightCopy(__GLcontext *gc, StraightCopyStorage *state)
{
    state->pack = gc->state.pixel.packModes;
    state->unpack = gc->state.pixel.unpackModes;
    state->transfer = gc->state.pixel.transferMode;

    gc->state.pixel.packModes.swapEndian = GL_FALSE;
    gc->state.pixel.packModes.lsbFirst = GL_FALSE;
    gc->state.pixel.packModes.lineLength = 0;
    gc->state.pixel.packModes.skipLines = 0;
    gc->state.pixel.packModes.skipPixels = 0;
    gc->state.pixel.packModes.alignment = 4;
    gc->state.pixel.unpackModes.swapEndian = GL_FALSE;
    gc->state.pixel.unpackModes.lsbFirst = GL_FALSE;
    gc->state.pixel.unpackModes.lineLength = 0;
    gc->state.pixel.unpackModes.skipLines = 0;
    gc->state.pixel.unpackModes.skipPixels = 0;
    gc->state.pixel.unpackModes.alignment = 4;
    gc->state.pixel.transferMode.r_scale = 1.0f;
    gc->state.pixel.transferMode.g_scale = 1.0f;
    gc->state.pixel.transferMode.b_scale = 1.0f;
    gc->state.pixel.transferMode.a_scale = 1.0f;
    gc->state.pixel.transferMode.d_scale = 1.0f;
    gc->state.pixel.transferMode.r_bias = 0.0f;
    gc->state.pixel.transferMode.g_bias = 0.0f;
    gc->state.pixel.transferMode.b_bias = 0.0f;
    gc->state.pixel.transferMode.a_bias = 0.0f;
    gc->state.pixel.transferMode.d_bias = 0.0f;
    gc->state.pixel.transferMode.zoomX = 1.0f;
    gc->state.pixel.transferMode.zoomY = 1.0f;
    gc->state.pixel.transferMode.indexShift = 0;
    gc->state.pixel.transferMode.indexOffset = 0;
    gc->state.pixel.transferMode.mapColor = GL_FALSE;
    gc->state.pixel.transferMode.mapStencil = GL_FALSE;

    // Many states have changed so force a repick
    __GL_DELAY_VALIDATE(gc);
}

void EndStraightCopy(__GLcontext *gc, StraightCopyStorage *state)
{
    gc->state.pixel.packModes = state->pack;
    gc->state.pixel.unpackModes = state->unpack;
    gc->state.pixel.transferMode = state->transfer;

    // Many states have changed so force a repick
    __GL_DELAY_VALIDATE(gc);
}

void APIPRIVATE __glim_CopyTexImage1D(GLenum target, GLint level,
                           GLenum internalformat, GLint x, GLint y,
                           GLsizei width, GLint border)
{
    GLubyte *pixels;
    GLenum format, type;
    StraightCopyStorage state;

    __GL_SETUP();
    
    if (target != GL_TEXTURE_1D ||
        (internalformat >= 1 && internalformat <= 4))
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // Use BGRA format because that matches our internal texture format
    format = GL_BGRA_EXT;
    type = GL_UNSIGNED_BYTE;
    
    // Allocate space for pixel data, read pixels into it from the
    // frame buffer and then do a TexImage
    
    pixels = (GLubyte *)GCALLOC(gc, width*4);
    if (pixels == NULL)
    {
        return;
    }

    StartStraightCopy(gc, &state);

    // __glim_ReadPixels will take the texture lock.
    __glim_ReadPixels(x, y, width, 1, format, type, pixels);
    __glim_TexImage1D(target, level, internalformat,
                      width, border, format, type,
                      pixels, GL_FALSE);

    EndStraightCopy(gc, &state);
    
    GCFREE(gc, pixels);
}

void APIPRIVATE __glim_CopyTexImage2D(GLenum target, GLint level,
                           GLenum internalformat, GLint x, GLint y,
                           GLsizei width, GLsizei height, GLint border)
{
    GLubyte *pixels;
    GLenum format, type;
    StraightCopyStorage state;

    __GL_SETUP();
    
    if (target != GL_TEXTURE_2D ||
        (internalformat >= 1 && internalformat <= 4))
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // Check for a DirectDraw texture
    if (target == GL_TEXTURE_2D && gc->texture.ddtex.levels > 0)
    {
        __glSetError(GL_INVALID_OPERATION);
        return;
    }
    
    // Use BGRA format because that matches our internal texture format
    format = GL_BGRA_EXT;
    type = GL_UNSIGNED_BYTE;
    
    // Allocate space for pixel data, read pixels into it from the
    // frame buffer and then do a TexImage
    
    pixels = (GLubyte *)GCALLOC(gc, width*height*4);
    if (pixels == NULL)
    {
        return;
    }

    StartStraightCopy(gc, &state);
    
    // __glim_ReadPixels will take the texture lock.
    __glim_ReadPixels(x, y, width, height, format, type, pixels);
    __glim_TexImage2D(target, level, internalformat,
                      width, height, border, format,
                      type, pixels, GL_FALSE);

    EndStraightCopy(gc, &state);
    
    GCFREE(gc, pixels);
}

void APIPRIVATE __glim_CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                              GLint x, GLint y, GLsizei width)
{
    GLubyte *pixels;
    GLenum format, type;
    StraightCopyStorage state;

    __GL_SETUP();
    
    if (target != GL_TEXTURE_1D)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // Use BGRA format because that matches our internal texture format
    format = GL_BGRA_EXT;
    type = GL_UNSIGNED_BYTE;
    
    // Allocate space for pixel data, read pixels into it from the
    // frame buffer and then do a TexImage
    
    pixels = (GLubyte *)GCALLOC(gc, width*4);
    if (pixels == NULL)
    {
        return;
    }

    StartStraightCopy(gc, &state);
    
    // __glim_ReadPixels will take the texture lock.
    __glim_ReadPixels(x, y, width, 1, format, type, pixels);
    __glim_TexSubImage1D(target, level, xoffset,
                         width, format, type,
                         pixels, GL_FALSE);

    EndStraightCopy(gc, &state);
    
    GCFREE(gc, pixels);
}

void APIPRIVATE __glim_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                              GLint yoffset, GLint x, GLint y,
                              GLsizei width, GLsizei height)
{
    GLubyte *pixels;
    GLenum format, type;
    StraightCopyStorage state;

    __GL_SETUP();
    
    if (target != GL_TEXTURE_2D)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // Use BGRA format because that matches our internal texture format
    format = GL_BGRA_EXT;
    type = GL_UNSIGNED_BYTE;
    
    // Allocate space for pixel data, read pixels into it from the
    // frame buffer and then do a TexImage
    
    pixels = (GLubyte *)GCALLOC(gc, width*height*4);
    if (pixels == NULL)
    {
        return;
    }

    StartStraightCopy(gc, &state);
    
    // __glim_ReadPixels will take the texture lock.
    __glim_ReadPixels(x, y, width, height, format, type, pixels);
    __glim_TexSubImage2D(target, level, xoffset,
                         yoffset, width, height,
                         format, type, pixels, GL_FALSE);

    EndStraightCopy(gc, &state);
    
    GCFREE(gc, pixels);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_textu.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include <namesint.h>
#include <math.h>
#include <glmath.h>

/*
** Some math routines that are optimized in assembly
*/

#define __GL_M_LN2_INV		((__GLfloat) (1.0 / 0.69314718055994530942))
#define __GL_M_SQRT2		((__GLfloat) 1.41421356237309504880)

/************************************************************************/

__GLtextureParamState * FASTCALL __glLookUpTextureParams(__GLcontext *gc, GLenum target)
{
    switch (target) {
      case GL_TEXTURE_1D:
	return &gc->state.texture.texture[2].params;
      case GL_TEXTURE_2D:
	return &gc->state.texture.texture[3].params;
      default:
	return 0;
    }
}

__GLtextureObjectState * FASTCALL __glLookUpTextureTexobjs(__GLcontext *gc, 
						    GLenum target)
{
    switch (target) {
      case GL_TEXTURE_1D:
	return &gc->state.texture.texture[2].texobjs;
      case GL_TEXTURE_2D:
	return &gc->state.texture.texture[3].texobjs;
      default:
	return 0;
    }
}


__GLtexture * FASTCALL __glLookUpTexture(__GLcontext *gc, GLenum target)
{
    switch (target) {
      case GL_PROXY_TEXTURE_1D:
	return &gc->texture.texture[0]->map;
      case GL_PROXY_TEXTURE_2D:
	return &gc->texture.texture[1]->map;
      case GL_TEXTURE_1D:
	return &gc->texture.texture[2]->map;
      case GL_TEXTURE_2D:
        return &gc->texture.texture[3]->map;
      default:
	return 0;
    }
}

__GLtextureObject * FASTCALL __glLookUpTextureObject(__GLcontext *gc, GLenum target)
{
    switch (target) {
      case GL_TEXTURE_1D:
	return gc->texture.boundTextures[2];
      case GL_TEXTURE_2D:
	return gc->texture.boundTextures[3];
      default:
	return 0;
    }
}

/************************************************************************/

/*
 * Set palette subdivision parameters
 */
void FASTCALL __glSetPaletteSubdivision(__GLtexture *tex, GLsizei subdiv)
{
    tex->paletteSize = subdiv;
    tex->paletteDivShift = __glIntLog2(subdiv);
    tex->paletteDivision = (tex->paletteTotalSize >> tex->paletteDivShift)-1;
}

/*
 * Initialize palette portion of a texture
 */
GLboolean FASTCALL __glInitTexturePalette(__GLcontext *gc, __GLtexture *tex)
{
#ifdef GL_EXT_paletted_texture
    tex->paletteBaseFormat = GL_RGBA;
    tex->paletteRequestedFormat = GL_RGBA;
    tex->paletteTotalSize = 1;
    __glSetPaletteSubdivision(tex, tex->paletteTotalSize);
    tex->paletteTotalData = GCALLOC(gc, sizeof(RGBQUAD));
    tex->paletteData = tex->paletteTotalData;
    if (tex->paletteTotalData != NULL)
    {
        *(DWORD *)&tex->paletteTotalData[0] = 0xffffffff;
        return GL_TRUE;
    }
    else
    {
        return GL_FALSE;
    }
#else
    return GL_TRUE;
#endif
}

/*
** Initialize everything in a texture object except the textureMachine.
*/
GLboolean FASTCALL __glInitTextureObject(__GLcontext *gc,
                                         __GLtextureObject *texobj, 
                                         GLuint name, GLuint targetIndex)
{
    ASSERTOPENGL(NULL != texobj, "No texobj\n");
    texobj->targetIndex = targetIndex;
    texobj->resident = GL_FALSE;
    texobj->texture.map.texobjs.name = name;
    texobj->texture.map.texobjs.priority = 1.0;
    texobj->lowerPriority = NULL;
    texobj->higherPriority = NULL;
    texobj->loadKey = 0;
    return __glInitTexturePalette(gc, &texobj->texture.map);
}

void __glCleanupTexture(__GLcontext *gc, __GLtexture *tex,
                        GLboolean freeBuffers)
{
    GLint level, maxLevel;

    if (tex->level != NULL)
    {
        if (freeBuffers)
        {
            maxLevel = gc->constants.maxMipMapLevel;
            for (level = 0; level < maxLevel; level++)
            {
                if (tex->level[level].buffer != NULL)
                {
                    GCFREE(gc, tex->level[level].buffer);
                }
            }
        }
        
        GCFREE(gc, tex->level);
    }
#ifdef GL_EXT_paletted_texture
    if (tex->paletteTotalData != NULL)
    {
        GCFREE(gc, tex->paletteTotalData);
    }
#endif
}

GLvoid FASTCALL __glCleanupTexObj(__GLcontext *gc, void *pData)
{
    __GLtextureObject *texobj = (__GLtextureObject *)pData;

    // The last context to clean up shared state sets shared to NULL
    // so don't depend on it being non-NULL
    if (gc->texture.shared != NULL)
    {
        __glTexPriListRemove(gc, texobj, GL_TRUE);
    }
    __glCleanupTexture(gc, &texobj->texture.map, GL_TRUE);
    GCFREE(gc, texobj);
}

GLvoid WINAPIV __glDisposeTexObj(__GLcontext *gc, void *pData)
{
    __GLtextureObject *texobj = (__GLtextureObject *)pData;

#if DBG
    if (gc->texture.shared != NULL)
    {
        __GL_NAMES_ASSERT_LOCKED(gc->texture.shared->namesArray);
    }
#endif
    
    texobj->refcount--;
    ASSERTOPENGL(texobj->refcount >= 0, "Invalid refcount\n");

    if (texobj->refcount == 0) {
        __glCleanupTexObj(gc, pData);
    }
}

static __GLnamesArrayTypeInfo texTypeInfo =
{
    NULL,				/* ptr to empty data struct */
    sizeof(__GLtextureObject),	        /* dataSize */
    __glDisposeTexObj,		        /* free callback */
    NULL				/* alloc callback */
};

void FASTCALL __glEarlyInitTextureState(__GLcontext *gc)
{
    GLint numTextures, numEnvs;
    GLint i,maxMipMapLevel;
    __GLtextureObject *texobj;

    /* XXX Override device dependent values */
    gc->constants.numberOfTextures = 4;
    gc->constants.maxTextureSize = 1 << (gc->constants.maxMipMapLevel - 1);

    /* Allocate memory based on number of textures supported */
    numTextures = gc->constants.numberOfTextures;
    numEnvs = gc->constants.numberOfTextureEnvs;
    gc->state.texture.texture = (__GLperTextureState*)
	GCALLOCZ(gc, numTextures*sizeof(__GLperTextureState));
    gc->texture.texture = (__GLperTextureMachine**)
	GCALLOCZ(gc, numTextures*sizeof(__GLperTextureMachine*));
#ifdef NT
    if (gc->texture.texture == NULL)
    {
        return;
    }
#endif
    gc->state.texture.env = (__GLtextureEnvState*)
	GCALLOCZ(gc, numEnvs*sizeof(__GLtextureEnvState));
    /*
    ** Init texture object structures.
    ** The default textures need to be turned into texture objects
    ** and stored away in the namesArray so they can be retrieved.
    ** Normally a texture object has only one textureMachine allocated
    ** with it because it supports only one object.  The default texture
    ** texture object is special in that its textureMachine is an array
    ** of textureMachines, one for each target.
    */

    gc->texture.shared = GCALLOCZ(gc, sizeof(__GLsharedTextureState));
    if (gc->texture.shared == NULL)
    {
        return;
    }
    
    if (NULL == gc->texture.shared->namesArray) {
	gc->texture.shared->namesArray = __glNamesNewArray(gc, &texTypeInfo);
    }

    maxMipMapLevel = gc->constants.maxMipMapLevel;

    /*
    ** Set up the dummy texture objects for the default textures. 
    ** Because the default textures are not shared, they should
    ** not be hung off of the namesArray structure.
    */
    gc->texture.defaultTextures = (__GLtextureObject *)GCALLOCZ
		    (gc, numTextures*sizeof(__GLtextureObject));
    if (gc->texture.defaultTextures == NULL)
    {
        return;
    }

    /* allocate the boundTextures array */
    gc->texture.boundTextures = (__GLtextureObject **)GCALLOCZ
		    (gc, numTextures*sizeof(__GLtextureObject *));
    if (gc->texture.boundTextures == NULL)
    {
        return;
    }

    // Allocate DirectDraw texture surface pointers
    gc->texture.ddtex.pdds = (LPDIRECTDRAWSURFACE *)GCALLOCZ
        (gc, maxMipMapLevel*sizeof(LPDIRECTDRAWSURFACE));
    if (gc->texture.ddtex.pdds == NULL)
    {
        return;
    }

    if (!__glInitTextureObject(gc, &gc->texture.ddtex.texobj, __GL_TEX_DDRAW,
                               __GL_TEX_TARGET_INDEX_2D))
    {
        return;
    }
    gc->texture.ddtex.texobj.refcount = 1;
    gc->texture.ddtex.texobj.texture.map.level = (__GLmipMapLevel*)
        GCALLOCZ(gc, maxMipMapLevel*sizeof(__GLmipMapLevel));
    
    texobj = gc->texture.defaultTextures;
    for (i=0; i < numTextures; i++, texobj++) {
	__glInitTextureObject(gc, texobj, 0/*name*/, i/*targetIndex*/);
	ASSERTOPENGL(texobj->texture.map.texobjs.name == 0,
                     "Non-default texture at init time\n");
	/*
	** The refcount is unused because default textures aren't
	** shared.
	*/
	texobj->refcount = 1;
	/*
	** Install the default textures into the gc.
	*/
	gc->texture.texture[i] = &(texobj->texture);
	gc->texture.boundTextures[i] = texobj;

	/* Allocate memory based on max mipmap level supported */
	texobj->texture.map.level = (__GLmipMapLevel*)
	    GCALLOCZ(gc, maxMipMapLevel*sizeof(__GLmipMapLevel));
        if (texobj->texture.map.level == NULL)
        {
            return;
        }

        __glTexPriListAdd(gc, texobj, GL_TRUE);
    }
}

/*
** This routine is used to initialize a texture object. 
** Texture objects must be initialized exactly the way the default
** textures are initialized at startup of the library.
*/
void FASTCALL __glInitTextureMachine(__GLcontext *gc, GLuint targetIndex, 
                                     __GLperTextureMachine *ptm,
                                     GLboolean allocLevels)
{
    GLint level, maxMipMapLevel;

    ptm->map.gc = gc;
    /*
    ** Can't copy the params currently in the gc state.texture params,
    ** because they might not be at init conditions.
    */
    ptm->map.params.sWrapMode = GL_REPEAT;
    ptm->map.params.tWrapMode = GL_REPEAT;
    ptm->map.params.minFilter = GL_NEAREST_MIPMAP_LINEAR;
    ptm->map.params.magFilter = GL_LINEAR;
    switch (targetIndex) {
      case 0:
	ptm->map.dim = 1;
	ptm->map.createLevel = __glCreateProxyLevel;
	break;
      case 1:
	ptm->map.dim = 2;
	ptm->map.createLevel = __glCreateProxyLevel;
	break;
      case 2:
	ptm->map.dim = 1;
	ptm->map.createLevel = __glCreateLevel;
	break;
      case 3:
	ptm->map.dim = 2;
	ptm->map.createLevel = __glCreateLevel;
	break;
      default:
	break;
    }

    maxMipMapLevel = gc->constants.maxMipMapLevel;

    if (allocLevels)
    {
        ptm->map.level = (__GLmipMapLevel*)
	    GCALLOCZ(gc, maxMipMapLevel*sizeof(__GLmipMapLevel));
        if (ptm->map.level == NULL)
        {
            return;
        }
    }

    /* Init each texture level */
    for (level = 0; level < maxMipMapLevel; level++) {
	ptm->map.level[level].requestedFormat = 1;
    }

}

void FASTCALL __glInitTextureState(__GLcontext *gc)
{
    __GLperTextureState *pts;
    __GLtextureEnvState *tes;
    __GLperTextureMachine **ptm;
    GLint i, numTextures, numEnvs;

    numTextures = gc->constants.numberOfTextures;
    numEnvs = gc->constants.numberOfTextureEnvs;

    gc->state.current.texture.w = __glOne;

    /* Init each texture environment state */
    tes = &gc->state.texture.env[0];
    for (i = 0; i < numEnvs; i++, tes++) {
	tes->mode = GL_MODULATE;
    }

    /* Init each textures state */
    pts = &gc->state.texture.texture[0];
    ptm = gc->texture.texture;
    for (i = 0; i < numTextures; i++, pts++, ptm++) {
        /* Init client state */
	pts->texobjs.name = 0;
	pts->texobjs.priority = 1.0;

        /* Init machine state */
        __glInitTextureMachine(gc, i, *ptm, GL_FALSE);
	pts->params = (*ptm)->map.params;
    }

    /* Init rest of texture state */
    gc->state.texture.s.mode = GL_EYE_LINEAR;
    gc->state.texture.s.eyePlaneEquation.x = __glOne;
    gc->state.texture.s.objectPlaneEquation.x = __glOne;
    gc->state.texture.t.mode = GL_EYE_LINEAR;
    gc->state.texture.t.eyePlaneEquation.y = __glOne;
    gc->state.texture.t.objectPlaneEquation.y = __glOne;
    gc->state.texture.r.mode = GL_EYE_LINEAR;
    gc->state.texture.q.mode = GL_EYE_LINEAR;

    // Initialize DirectDraw texture
    __glInitTextureMachine(gc, __GL_TEX_TARGET_INDEX_2D,
                           &gc->texture.ddtex.texobj.texture, GL_FALSE);
}

void __glFreeSharedTextureState(__GLcontext *gc)
{
#ifdef NT
    __glNamesLockArray(gc, gc->texture.shared->namesArray);
    
    gc->texture.shared->namesArray->refcount--;
    if (gc->texture.shared->namesArray->refcount == 0)
    {
        __GLsharedTextureState *shared;
        
        __glTexPriListUnloadAll(gc);
        
        // NULL the shared pointer first, preventing its reuse
        // after we unlock it.  We need to unlock before we free it
        // because the critical section will be cleaned up in the
        // free
        shared = gc->texture.shared;
        gc->texture.shared = NULL;
        __glNamesFreeArray(gc, shared->namesArray);
        GCFREE(gc, shared);
    }
    else
    {
        __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
        gc->texture.shared = NULL;
    }
#else
    gc->texture.namesArray->refcount--;
    if (gc->texture.namesArray->refcount == 0)
    {
        __glNamesFreeArray(gc, gc->texture.namesArray);
    }
    gc->texture.namesArray = NULL;
#endif
}

void FASTCALL __glFreeTextureState(__GLcontext *gc)
{
    __GLperTextureMachine **ptm;
    GLint i, level, numTextures;

    /*
    ** Clean up all allocs associated with texture objects.
    */

    numTextures = gc->constants.numberOfTextures;
    ptm = gc->texture.texture;
    for (i = 0; i < numTextures; i++, ptm++)
    {
        // If the texture selected is a texture object, unbind it
        // This protects any shared texture objects plus it selects
        // the default texture so it gets cleaned up
        if ( (*ptm) != NULL)
        {
            if ((*ptm)->map.texobjs.name != 0)
            {
                __glBindTexture(gc, i, 0, GL_FALSE);
            }
            ASSERTOPENGL((*ptm)->map.texobjs.name == 0,
                         "Texture object still bound during cleanup");
        }
      
        // Pull the default texture out of the priority list.
        // If we failed partway through initialization we may not
        // have added the texture to the list so we need to check
        // whether it is appropriate to call remove.
        if (gc->texture.defaultTextures != NULL)
        {
            if (gc->texture.defaultTextures[i].texture.map.level != NULL)
            {
                __glTexPriListRemove(gc, gc->texture.defaultTextures+i,
                                     GL_FALSE);
            }
        }
        
        if ( (*ptm) != NULL)
        {
            __glCleanupTexture(gc, &(*ptm)->map, GL_TRUE);
        }
    }
    
    __glFreeSharedTextureState(gc);

    GCFREE(gc, gc->texture.texture);
    GCFREE(gc, gc->texture.boundTextures);
    GCFREE(gc, gc->texture.defaultTextures);
    GCFREE(gc, gc->state.texture.texture);
    GCFREE(gc, gc->state.texture.env);
    gc->texture.texture = NULL;
    gc->texture.boundTextures = NULL;
    gc->texture.defaultTextures = NULL;
    gc->state.texture.texture = NULL;
    gc->state.texture.env = NULL;

    // Free DirectDraw texture state
    GCFREE(gc, gc->texture.ddtex.pdds);
    gc->texture.ddtex.pdds = NULL;
    __glCleanupTexture(gc, &gc->texture.ddtex.texobj.texture.map, GL_FALSE);
}

/************************************************************************/

void APIPRIVATE __glim_TexGenfv(GLenum coord, GLenum pname, const GLfloat pv[])
{
    __GLtextureCoordState *tcs;
    __GLtransform *tr;
    __GL_SETUP_NOT_IN_BEGIN();

    switch (coord) {
      case GL_S: tcs = &gc->state.texture.s; break;
      case GL_T: tcs = &gc->state.texture.t; break;
      case GL_R: tcs = &gc->state.texture.r; break;
      case GL_Q: tcs = &gc->state.texture.q; break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    switch (pname) {
      case GL_TEXTURE_GEN_MODE:
	switch (((GLenum) FTOL(pv[0]))) {
	  case GL_EYE_LINEAR:
	  case GL_OBJECT_LINEAR:
	    tcs->mode = (GLenum) FTOL(pv[0]);
            break;
	  case GL_SPHERE_MAP:
	    if ((coord == GL_R) || (coord == GL_Q)) {
		__glSetError(GL_INVALID_ENUM);
		return;
	    }
	    tcs->mode = (GLenum) FTOL(pv[0]);
	    break;
	  default:
	    __glSetError(GL_INVALID_ENUM);
	    return;
	}
	break;
      case GL_OBJECT_PLANE:
	tcs->objectPlaneEquation.x = pv[0];
	tcs->objectPlaneEquation.y = pv[1];
	tcs->objectPlaneEquation.z = pv[2];
	tcs->objectPlaneEquation.w = pv[3];
	break;
      case GL_EYE_PLANE:
#ifdef NT
	tr = gc->transform.modelView;
	if (tr->flags & XFORM_UPDATE_INVERSE)
	    __glComputeInverseTranspose(gc, tr);
	(*tr->inverseTranspose.xf4)(&tcs->eyePlaneEquation, pv,
				    &tr->inverseTranspose);
#else
	/*XXX transform should not be in generic code */
        tcs->eyePlaneSet.x = pv[0];
        tcs->eyePlaneSet.y = pv[1];
        tcs->eyePlaneSet.z = pv[2];
        tcs->eyePlaneSet.w = pv[3];
	tr = gc->transform.modelView;
	if (tr->flags & XFORM_UPDATE_INVERSE) {
	    (*gc->procs.computeInverseTranspose)(gc, tr);
	}
	(*tr->inverseTranspose.xf4)(&tcs->eyePlaneEquation,
                                    &tcs->eyePlaneSet.x,
				    &tr->inverseTranspose);
#endif
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    __GL_DELAY_VALIDATE(gc);
    MCD_STATE_DIRTY(gc, TEXGEN);
}

/************************************************************************/

void APIPRIVATE __glim_TexParameterfv(GLenum target, GLenum pname, const GLfloat pv[])
{
    __GLtextureParamState *pts;
    GLenum e;
    GLboolean bTexState = GL_TRUE;
    __GL_SETUP_NOT_IN_BEGIN();

    pts = __glLookUpTextureParams(gc, target);

    if (!pts) {
      bad_enum:
        bTexState = GL_FALSE;
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
	switch (e = (GLenum) FTOL(pv[0])) {
	  case GL_REPEAT:
	  case GL_CLAMP:
	    pts->sWrapMode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_WRAP_T:
	switch (e = (GLenum) FTOL(pv[0])) {
	  case GL_REPEAT:
	  case GL_CLAMP:
	    pts->tWrapMode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_MIN_FILTER:
	switch (e = (GLenum)FTOL(pv[0])) {
	  case GL_NEAREST:
	  case GL_LINEAR:
	  case GL_NEAREST_MIPMAP_NEAREST:
	  case GL_LINEAR_MIPMAP_NEAREST:
	  case GL_NEAREST_MIPMAP_LINEAR:
	  case GL_LINEAR_MIPMAP_LINEAR:
	    pts->minFilter = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_MAG_FILTER:
	switch (e = (GLenum)FTOL(pv[0])) {
	  case GL_NEAREST:
	  case GL_LINEAR:
	    pts->magFilter = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_BORDER_COLOR:
	__glClampColorf(gc, &pts->borderColor, pv);
	break;
      
      case GL_TEXTURE_PRIORITY:
	{
	    __GLtextureObject *texobj;
	    __GLtextureObjectState *ptos;

	    ptos = __glLookUpTextureTexobjs(gc, target);
            ptos->priority = __glClampf(pv[0], __glZero, __glOne);
            
	    texobj = __glLookUpTextureObject(gc, target);
	    texobj->texture.map.texobjs.priority = ptos->priority;
            __glTexPriListChangePriority(gc, texobj, GL_TRUE);
        }
        bTexState = GL_FALSE;
	break;

      default:
	goto bad_enum;
    }
    __GL_DELAY_VALIDATE(gc);

#ifdef _MCD_
    if (bTexState &&
        gc->texture.currentTexture &&
        (pts == &gc->texture.currentTexture->params))
    {
        MCD_STATE_DIRTY(gc, TEXTURE);
    }
#endif
}

void APIPRIVATE __glim_TexParameteriv(GLenum target, GLenum pname, const GLint pv[])
{
    __GLtextureParamState *pts;
    GLenum e;
    GLboolean bTexState = GL_TRUE;
    __GL_SETUP_NOT_IN_BEGIN();

    pts = __glLookUpTextureParams(gc, target);

    if (!pts) {
      bad_enum:
        bTexState = GL_FALSE;
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    switch (pname) {
      case GL_TEXTURE_WRAP_S:
	switch (e = (GLenum) pv[0]) {
	  case GL_REPEAT:
	  case GL_CLAMP:
	    pts->sWrapMode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_WRAP_T:
	switch (e = (GLenum) pv[0]) {
	  case GL_REPEAT:
	  case GL_CLAMP:
	    pts->tWrapMode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_MIN_FILTER:
	switch (e = (GLenum) pv[0]) {
	  case GL_NEAREST:
	  case GL_LINEAR:
	  case GL_NEAREST_MIPMAP_NEAREST:
	  case GL_LINEAR_MIPMAP_NEAREST:
	  case GL_NEAREST_MIPMAP_LINEAR:
	  case GL_LINEAR_MIPMAP_LINEAR:
	    pts->minFilter = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_MAG_FILTER:
	switch (e = (GLenum) pv[0]) {
	  case GL_NEAREST:
	  case GL_LINEAR:
	    pts->magFilter = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_BORDER_COLOR:
	__glClampColori(gc, &pts->borderColor, pv);
	break;
      case GL_TEXTURE_PRIORITY:
	{
	    __GLfloat priority;
	    __GLtextureObjectState *ptos;
	    __GLtextureObject *texobj;
            
	    ptos = __glLookUpTextureTexobjs(gc, target);
	    priority = __glClampf(__GL_I_TO_FLOAT(pv[0]), __glZero, __glOne);
	    ptos->priority = priority;

	    texobj = __glLookUpTextureObject(gc, target);
	    texobj->texture.map.texobjs.priority = priority;
            __glTexPriListChangePriority(gc, texobj, GL_TRUE);
	}
        bTexState = GL_FALSE;
	break;
      default:
	goto bad_enum;
    }
    __GL_DELAY_VALIDATE(gc);

#ifdef _MCD_
    if (bTexState &&
        gc->texture.currentTexture &&
        (pts == &gc->texture.currentTexture->params))
    {
        MCD_STATE_DIRTY(gc, TEXTURE);
    }
#endif
}

/************************************************************************/

void APIPRIVATE __glim_TexEnvfv(GLenum target, GLenum pname, const GLfloat pv[])
{
    __GLtextureEnvState *tes;
    GLenum e;
    __GL_SETUP_NOT_IN_BEGIN();

    
    if(target < GL_TEXTURE_ENV) {
      __glSetError(GL_INVALID_ENUM);
      return;
    }
    target -= GL_TEXTURE_ENV;
#ifdef NT
    // target is unsigned!
    if (target >= (GLenum) gc->constants.numberOfTextureEnvs) {
#else
    if (target >= gc->constants.numberOfTextureEnvs) {
#endif // NT
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    tes = &gc->state.texture.env[target];

    switch (pname) {
      case GL_TEXTURE_ENV_MODE:
	switch(e = (GLenum) FTOL(pv[0])) {
	  case GL_MODULATE:
	  case GL_DECAL:
	  case GL_BLEND:
	  case GL_REPLACE:
	    tes->mode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_ENV_COLOR:
	__glClampAndScaleColorf(gc, &tes->color, pv);
	break;
      default:
	goto bad_enum;
    }
    __GL_DELAY_VALIDATE(gc);
    MCD_STATE_DIRTY(gc, TEXENV);
}

void APIPRIVATE __glim_TexEnviv(GLenum target, GLenum pname, const GLint pv[])
{
    __GLtextureEnvState *tes;
    GLenum e;
    __GL_SETUP_NOT_IN_BEGIN();


    if(target < GL_TEXTURE_ENV) {
      __glSetError(GL_INVALID_ENUM);
      return;
    }
    target -= GL_TEXTURE_ENV;
#ifdef NT
    // target is unsigned!
    if (target >= (GLenum) gc->constants.numberOfTextureEnvs) {
#else
    if (target >= gc->constants.numberOfTextureEnvs) {
#endif // NT
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    tes = &gc->state.texture.env[target];

    switch (pname) {
      case GL_TEXTURE_ENV_MODE:
	switch(e = (GLenum) pv[0]) {
	  case GL_MODULATE:
	  case GL_DECAL:
	  case GL_BLEND:
	  case GL_REPLACE:
	    tes->mode = e;
	    break;
	  default:
	    goto bad_enum;
	}
	break;
      case GL_TEXTURE_ENV_COLOR:
	__glClampAndScaleColori(gc, &tes->color, pv);
	break;
      default:
	goto bad_enum;
    }
    __GL_DELAY_VALIDATE(gc);
    MCD_STATE_DIRTY(gc, TEXENV);
}

/************************************************************************/

GLboolean FASTCALL __glIsTextureConsistent(__GLcontext *gc, GLenum name)
{
    __GLtexture *tex = __glLookUpTexture(gc, name);
    __GLtextureParamState *params = __glLookUpTextureParams(gc, name);
    GLint i, width, height;
    GLint maxLevel;
    GLint border;
    GLenum baseFormat;
    GLenum requestedFormat;

    if ((tex->level[0].width == 0) || (tex->level[0].height == 0)) {
	return GL_FALSE;
    }

    border = tex->level[0].border;
    width = tex->level[0].width - border*2;
    height = tex->level[0].height - border*2;
    maxLevel = gc->constants.maxMipMapLevel;
    baseFormat = tex->level[0].baseFormat;
    requestedFormat = tex->level[0].requestedFormat;

    switch(gc->state.texture.env[0].mode) {
      case GL_DECAL:
	if (baseFormat != GL_RGB && baseFormat != GL_RGBA) {
	    return GL_FALSE;
	}
	break;
      default:
	break;
    }

    /* If not-mipmapping, we are ok */
    switch (params->minFilter) {
      case GL_NEAREST:
      case GL_LINEAR:
	return GL_TRUE;
      default:
	break;
    }

    i = 0;
    while (++i < maxLevel) {
	if (width == 1 && height == 1) break;
	width >>= 1;
	if (width == 0) width = 1;
	height >>= 1;
	if (height == 0) height = 1;

	if (tex->level[i].border != border ||
            (GLenum)tex->level[i].requestedFormat != requestedFormat ||
            tex->level[i].width != width + border*2 ||
            tex->level[i].height != height + border*2)
        {
	    return GL_FALSE;
	}
    }

    return GL_TRUE;
}

/***********************************************************************/

#ifdef GL_WIN_multiple_textures
void APIPRIVATE __glim_CurrentTextureIndexWIN(GLuint index)
{
}

void APIPRIVATE __glim_NthTexCombineFuncWIN(GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor)
{
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_tprls.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include <namesint.h>

void __glTexPriListRealize(__GLcontext *gc)
{
    __GLtextureObject *high, *low;
    GLboolean tryUnload = GL_TRUE;
    MCDHANDLE loadKey;
    
    __GL_NAMES_ASSERT_LOCKED(gc->texture.shared->namesArray);
    
    // Attempt to load as many of the highest priority textures as
    // possible.  If a lower priority texture is resident and a
    // higher priority texture is unable to load, kick it out
    // and try again
    high = gc->texture.shared->priorityListHighest;
    low = gc->texture.shared->priorityListLowest;

    while (high != NULL)
    {
        // We only want to load textures that have image data
        // Consider - Should check all mipmap levels?
        if (high->loadKey == 0 && high->texture.map.level[0].buffer != NULL)
        {
            for (;;)
            {
                // If high == low then there are no longer any
                // lower-priority textures to consider for unloading
                if (high == low)
                {
                    tryUnload = GL_FALSE;
                }
        
                loadKey = __glGenLoadTexture(gc, &high->texture.map, 0);
                if (loadKey != 0)
                {
                    high->resident = GL_TRUE;
                    high->loadKey = loadKey;
                    break;
                }

                if (tryUnload)
                {
                    while (low->loadKey == 0 && low != high)
                    {
                        low = low->higherPriority;
                    }

                    if (low->loadKey != 0)
                    {
                        __glGenFreeTexture(gc, &low->texture.map, low->loadKey);
                        low->loadKey = 0;
                        low->resident = GL_FALSE;
                    }
                }
                else
                {
                    break;
                }
            }
        }

        high = high->lowerPriority;
    }
}

void __glTexPriListAddToList(__GLcontext *gc, __GLtextureObject *texobj)
{
    __GLtextureObject *texobjLower;

    __GL_NAMES_ASSERT_LOCKED(gc->texture.shared->namesArray);
    
    // Walk the priority list to find a lower priority texture object
    texobjLower = gc->texture.shared->priorityListHighest;
    while (texobjLower != NULL &&
           texobjLower->texture.map.texobjs.priority >
           texobj->texture.map.texobjs.priority)
    {
        texobjLower = texobjLower->lowerPriority;
    }

    if (texobjLower == NULL)
    {
        // Place at end of list
        if (gc->texture.shared->priorityListLowest != NULL)
        {
            gc->texture.shared->priorityListLowest->lowerPriority = texobj;
        }
        else
        {
            gc->texture.shared->priorityListHighest = texobj;
        }
        texobj->higherPriority = gc->texture.shared->priorityListLowest;
        gc->texture.shared->priorityListLowest = texobj;
    }
    else
    {
        if (texobjLower->higherPriority != NULL)
        {
            texobjLower->higherPriority->lowerPriority = texobj;
        }
        else
        {
            gc->texture.shared->priorityListHighest = texobj;
        }
        texobj->higherPriority = texobjLower->higherPriority;
        texobjLower->higherPriority = texobj;
    }
    texobj->lowerPriority = texobjLower;
}

void __glTexPriListAdd(__GLcontext *gc, __GLtextureObject *texobj,
                       GLboolean realize)
{
    __glNamesLockArray(gc, gc->texture.shared->namesArray);
    
    __glTexPriListAddToList(gc, texobj);
    if (realize)
    {
        __glTexPriListRealize(gc);
    }

    __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
}

void __glTexPriListRemoveFromList(__GLcontext *gc, __GLtextureObject *texobj)
{
    __GL_NAMES_ASSERT_LOCKED(gc->texture.shared->namesArray);
    
#if DBG
    {
        __GLtextureObject *t;

        for (t = gc->texture.shared->priorityListHighest;
             t != NULL; t = t->lowerPriority)
        {
            if (t == texobj)
            {
                break;
            }
        }
        ASSERTOPENGL(t != NULL, "Removing an unlisted texobj");
    }
#endif

    if (texobj->higherPriority != NULL)
    {
        texobj->higherPriority->lowerPriority = texobj->lowerPriority;
    }
    else
    {
        gc->texture.shared->priorityListHighest = texobj->lowerPriority;
    }
    if (texobj->lowerPriority != NULL)
    {
        texobj->lowerPriority->higherPriority = texobj->higherPriority;
    }
    else
    {
        gc->texture.shared->priorityListLowest = texobj->higherPriority;
    }
}

void __glTexPriListRemove(__GLcontext *gc, __GLtextureObject *texobj,
                          GLboolean realize)
{
    __glNamesLockArray(gc, gc->texture.shared->namesArray);
    
    __glTexPriListRemoveFromList(gc, texobj);

    __glGenFreeTexture(gc, &texobj->texture.map, texobj->loadKey);
    texobj->loadKey = 0;
    texobj->resident = GL_FALSE;

    if (realize)
    {
        __glTexPriListRealize(gc);
    }

    __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
}

void __glTexPriListChangePriority(__GLcontext *gc, __GLtextureObject *texobj,
                                  GLboolean realize)
{
    __glNamesLockArray(gc, gc->texture.shared->namesArray);
    
    __glTexPriListRemoveFromList(gc, texobj);
    __glTexPriListAddToList(gc, texobj);

    // If we're re-realizing, don't bother calling the MCD texture-priority
    // function:

    if (realize) {
        __glTexPriListRealize(gc);
    } else if (((__GLGENcontext *)gc)->pMcdState && texobj->loadKey) {
        GenMcdUpdateTexturePriority((__GLGENcontext *)gc, 
                                    &texobj->texture.map, texobj->loadKey);
    }

    __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
}

void __glTexPriListLoadSubImage(__GLcontext *gc, GLenum target, GLint lod, 
                                GLint xoffset, GLint yoffset, 
                                GLsizei w, GLsizei h)
{
    __GLtextureObject *pto;

    // Always mark things as resident:

    pto = __glLookUpTextureObject(gc, target);
    pto->resident = GL_TRUE;
    __glGenUpdateTexture(gc, &pto->texture.map, pto->loadKey);

    // For MCD, send down the full subimage command:

    if (((__GLGENcontext *)gc)->pMcdState && pto->loadKey) {
        GenMcdUpdateSubTexture((__GLGENcontext *)gc, &pto->texture.map, 
                               pto->loadKey, lod, 
                               xoffset, yoffset, w, h);
    }
}

void __glTexPriListLoadImage(__GLcontext *gc, GLenum target)
{
    __GLtextureObject *pto;

    // If we're unaccelerated then always mark things as resident
    pto = __glLookUpTextureObject(gc, target);
    pto->resident = GL_TRUE;
    __glGenUpdateTexture(gc, &pto->texture.map, pto->loadKey);

    // For simplicity, we will assume that the texture size or format
    // has changed, so delete the texture and re-realize the list.
    //
    // !!! If this becomes a performance issue, we *could* be smart about
    // !!! detecting the cases where the texture size and format remains the
    // !!! same.  However, modifying a texture should really be done through
    // !!! SubImage calls.

    if (((__GLGENcontext *)gc)->pMcdState) {
        if (pto->loadKey) {
            GenMcdDeleteTexture((__GLGENcontext *)gc, pto->loadKey);
            pto->loadKey = 0;
        }
        __glNamesLockArray(gc, gc->texture.shared->namesArray);
        __glTexPriListRealize(gc);
        __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
    }
}

void __glTexPriListUnloadAll(__GLcontext *gc)
{
    __GLtextureObject *texobj;

    __GL_NAMES_ASSERT_LOCKED(gc->texture.shared->namesArray);

    texobj = gc->texture.shared->priorityListHighest;
    while (texobj != NULL)
    {
        __glGenFreeTexture(gc, &texobj->texture.map, texobj->loadKey);
        texobj->loadKey = 0;
        texobj->resident = GL_FALSE;

        texobj = texobj->lowerPriority;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_txobj.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include <namesint.h>
#include <glmath.h>
#include <devlock.h>

/************************************************************************/
/*
** Texture Object routines.
*/
/************************************************************************/


#define __GL_CHECK_VALID_N_PARAM(failStatement)                         \
    if (n < 0) {                                                        \
        __glSetError(GL_INVALID_VALUE);                                 \
    }                                                                   \
    if (n == 0) {                                                       \
        failStatement;                                                  \
    }                                                                   \


GLvoid APIPRIVATE __glim_GenTextures(GLsizei n, GLuint* textures)
{
    __GL_SETUP_NOT_IN_BEGIN();
    __GL_CHECK_VALID_N_PARAM(return);

    if (NULL == textures) return;

    ASSERTOPENGL(NULL != gc->texture.shared->namesArray,
                 "No texture names array\n");

    __glNamesGenNames(gc, gc->texture.shared->namesArray, n, textures);

}

GLvoid APIPRIVATE __glim_DeleteTextures(GLsizei n, const GLuint* textures)
{
    GLuint start, rangeVal, numTextures, targetIndex, i;
    __GLnamesArray *array;
    __GLtextureObject *texobj, **pBoundTexture;

    __GL_SETUP_NOT_IN_BEGIN();
    __GL_CHECK_VALID_N_PARAM(return);

    array = gc->texture.shared->namesArray;
    numTextures = gc->constants.numberOfTextures;

    /*
    ** Send the texture names in ranges to the names module to be
    ** deleted.  Ignore any references to default textures.
    ** If a texture that is being deleted is currently bound,
    ** bind the default texture to its target.
    ** The names routine ignores any names that don't refer to
    ** textures.
    */
    start = rangeVal = textures[0];
    for (i=0; i < (GLuint)n; i++, rangeVal++) {
        if (0 == textures[i]) {         /* skip default textures */
            /* delete up to this one */
            __glNamesDeleteRange(gc,array,start,rangeVal-start);
            /* skip over this one by setting start to the next one */
            start = textures[i+1];
            rangeVal = start-1;         /* because it gets incremented later */
            continue;
        }
        /*
        ** If the texture is currently bound, bind the defaultTexture
        ** to its target.  The problem here is identifying the target.
        ** One way is to look up the texobj with the name.  Another is
        ** to look through all of the currently bound textures and
        ** check each for the name.  It has been implemented with the
        ** assumption that looking through the currently bound textures
        ** is faster than retrieving the texobj that corresponds to
        ** the name.
        */
        for (targetIndex=0, pBoundTexture = gc->texture.boundTextures;
                targetIndex < numTextures; targetIndex++, pBoundTexture++) {

            /* Is the texture currently bound? */
            if (*pBoundTexture != &gc->texture.ddtex.texobj &&
                (*pBoundTexture)->texture.map.texobjs.name == textures[i]) {
                __GLperTextureState *pts;
                pts = &gc->state.texture.texture[targetIndex];
                /* if we don't unlock it, it won't get deleted */
                __glNamesUnlockData(gc, *pBoundTexture, __glCleanupTexObj);

                /* bind the default texture to this target */
                texobj = gc->texture.defaultTextures + targetIndex;
                ASSERTOPENGL(texobj->texture.map.texobjs.name == 0,
                             "Non-default texture\n");
                gc->texture.texture[targetIndex] = &(texobj->texture);
                *pBoundTexture = texobj;
                pts->texobjs = texobj->texture.map.texobjs;
                pts->params = texobj->texture.map.params;

                /* Need to reset the current texture and such. */
                __GL_DELAY_VALIDATE(gc);
                break;
            }
        }
        if (textures[i] != rangeVal) {
            /* delete up to this one */
            __glNamesDeleteRange(gc,array,start,rangeVal-start);
            start = rangeVal = textures[i];
        }
    }
    __glNamesDeleteRange(gc,array,start,rangeVal-start);
}


// These macros used for comparing properties of 2 textures

#define _DIFFERENT_TEX_PARAMS( tex1, tex2 ) \
      ( ! RtlEqualMemory( &(tex1)->params, &(tex2)->params, sizeof(__GLtextureParamState)) )

#define _DIFFERENT_TEXDATA_FORMATS( tex1, tex2 ) \
    ( (tex1)->level[0].internalFormat != (tex2)->level[0].internalFormat )

/*
** This routine is used by the pick routines to actually perform
** the bind.
*/
void FASTCALL __glBindTexture(__GLcontext *gc, GLuint targetIndex,
                              GLuint texture, GLboolean callGen)
{
    __GLtextureObject *texobj;

    ASSERTOPENGL(NULL != gc->texture.shared->namesArray,
                 "No texture names array\n");

    // Check if this texture is the currently bound one
    if( (targetIndex != __GL_TEX_TARGET_INDEX_DDRAW &&
         gc->texture.boundTextures[targetIndex] != &gc->texture.ddtex.texobj &&
         texture == gc->texture.boundTextures[targetIndex]->
         texture.map.texobjs.name) ||
        (targetIndex == __GL_TEX_TARGET_INDEX_DDRAW &&
         gc->texture.boundTextures[__GL_TEX_TARGET_INDEX_2D] ==
         &gc->texture.ddtex.texobj))
    {
        return;
    }

    /*
    ** Retrieve the texture object from the namesArray structure.
    */
    if (targetIndex == __GL_TEX_TARGET_INDEX_DDRAW)
    {
        targetIndex = __GL_TEX_TARGET_INDEX_2D;
        texobj = &gc->texture.ddtex.texobj;
    }
    else if (texture == 0)
    {
        texobj = gc->texture.defaultTextures + targetIndex;
        ASSERTOPENGL(NULL != texobj, "No default texture\n");
        ASSERTOPENGL(texobj->texture.map.texobjs.name == 0,
                     "Non-default texture\n");
    }
    else
    {
        texobj = (__GLtextureObject *)
                __glNamesLockData(gc, gc->texture.shared->namesArray, texture);
    }


    /*
    ** Is this the first time this name has been bound?
    ** If so, create a new texture object and initialize it.
    */
    if (NULL == texobj) {
        texobj = (__GLtextureObject *)GCALLOCZ(gc, sizeof(*texobj));
        if (texobj == NULL)
        {
            return;
        }
        if (!__glInitTextureObject(gc, texobj, texture, targetIndex))
        {
            GCFREE(gc, texobj);
            return;
        }
        __glInitTextureMachine(gc, targetIndex, &(texobj->texture), GL_TRUE);
        __glNamesNewData(gc, gc->texture.shared->namesArray, texture, texobj);
        /*
        ** Shortcut way to lock without doing another lookup.
        */
        __glNamesLockArray(gc, gc->texture.shared->namesArray);
        texobj->refcount++;
        __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
        __glTexPriListAdd(gc, texobj, GL_TRUE);
    }
    else {
        /*
        ** Retrieved an existing texture object.  Do some
        ** sanity checks.
        */
        if (texobj->targetIndex != targetIndex) {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
        ASSERTOPENGL(texture == texobj->texture.map.texobjs.name,
                     "Texture name mismatch\n");
    }

    {
        __GLperTextureState *pts;
        __GLtexture *ptm;
        __GLtextureObject *boundTexture;

        pts = &(gc->state.texture.texture[targetIndex]);
        ptm = &(gc->texture.texture[targetIndex]->map);
        boundTexture = gc->texture.boundTextures[targetIndex];

        /* Copy the current stackable state into the bound texture. */
        ptm->params = pts->params;
        ptm->texobjs = pts->texobjs;

        // If the DDraw texture is currently bound, release its
        // resources
        if (boundTexture == &gc->texture.ddtex.texobj)
        {
            glsrvUnbindDirectDrawTexture(gc);
        }
        else if (boundTexture->texture.map.texobjs.name != 0)
        {
            /* Unlock the texture that is being unbound.  */
            __glNamesUnlockData(gc, boundTexture, __glCleanupTexObj);
        }

        /*
        ** Install the new texture into the correct target and save
        ** its pointer so it can be unlocked easily when it is unbound.
        */
        gc->texture.texture[targetIndex] = &(texobj->texture);
        gc->texture.boundTextures[targetIndex] = texobj;

        /* Copy the new texture's stackable state into the context state. */
        pts->params = texobj->texture.map.params;
        pts->texobjs = texobj->texture.map.texobjs;

        if (callGen)
        {
            __glGenMakeTextureCurrent(gc, &texobj->texture.map,
                                      texobj->loadKey);
        }

        __GL_DELAY_VALIDATE_MASK( gc, __GL_DIRTY_TEXTURE );

        // We can avoid dirtying generic if the new texture has same
        // properties as the old one...

        if( !( gc->dirtyMask & __GL_DIRTY_GENERIC ) )
        {
            // GL_DIRTY_GENERIC has not yet been set
            __GLtexture *newTex = &texobj->texture.map;
            __GLtexture *oldTex = &boundTexture->texture.map;

            if( (_DIFFERENT_TEX_PARAMS( newTex, oldTex )) ||
                (_DIFFERENT_TEXDATA_FORMATS( newTex, oldTex )) ||
                (texobj->targetIndex != boundTexture->targetIndex) )
            {
                __GL_DELAY_VALIDATE( gc ); // dirty generic
            }
        }
    }
}

GLvoid APIPRIVATE __glim_BindTexture(GLenum target, GLuint texture)
{
    GLuint targetIndex;
    /*
    ** Need to validate in case a new texture was popped into
    ** the state immediately prior to this call.
    */
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    switch (target) {
    case GL_TEXTURE_1D:
        targetIndex = 2;
        break;
    case GL_TEXTURE_2D:
        targetIndex = 3;
        break;
    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    __glBindTexture(gc, targetIndex, texture, GL_TRUE);
}

#ifdef GL_WIN_multiple_textures
void APIPRIVATE __glim_BindNthTextureWIN(GLuint index, GLenum target, GLuint texture)
{
}
#endif // GL_WIN_multiple_textures

GLvoid APIPRIVATE __glim_PrioritizeTextures(GLsizei n,
                           const GLuint* textures,
                           const GLclampf* priorities)
{
    int i;
    __GLtextureObject *texobj;
    GLuint targetIndex;
    __GLtextureObject **pBoundTexture;
    GLclampf priority;

    __GL_SETUP_NOT_IN_BEGIN();
    __GL_CHECK_VALID_N_PARAM(return);

    for (i=0; i < n; i++) {
        /* silently ignore default texture */
        if (0 == textures[i]) continue;

        texobj = (__GLtextureObject *)
            __glNamesLockData(gc, gc->texture.shared->namesArray, textures[i]);

        /* silently ignore non-texture */
        if (NULL == texobj) continue;

        priority = __glClampf(priorities[i], __glZero, __glOne);
        texobj->texture.map.texobjs.priority = priority;

        // If this texture is currently bound, also update the
        // copy of the priority in the gc's state
        // Keeping copies is not a good design.  This
        // should be improved
        for (targetIndex = 0, pBoundTexture = gc->texture.boundTextures;
             targetIndex < (GLuint)gc->constants.numberOfTextures;
             targetIndex++, pBoundTexture++)
        {
            /* Is the texture currently bound? */
            if (*pBoundTexture != &gc->texture.ddtex.texobj &&
                (*pBoundTexture)->texture.map.texobjs.name == textures[i])
            {
                gc->state.texture.texture[targetIndex].texobjs.priority =
                    priority;
                break;
            }
        }

        __glTexPriListChangePriority(gc, texobj, GL_FALSE);
        __glNamesUnlockData(gc, texobj, __glCleanupTexObj);
    }
    __glNamesLockArray(gc, gc->texture.shared->namesArray);
    __glTexPriListRealize(gc);
    __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
}

GLboolean APIPRIVATE __glim_AreTexturesResident(GLsizei n,
                               const GLuint* textures,
                               GLboolean* residences)
{
    int i;
    __GLtextureObject *texobj;
    GLboolean allResident = GL_TRUE;
    GLboolean currentResident;

    __GL_SETUP_NOT_IN_BEGIN2();
    __GL_CHECK_VALID_N_PARAM(return GL_FALSE);

    for (i=0; i < n; i++) {
        /* Can't query a default texture. */
        if (0 == textures[i]) {
            __glSetError(GL_INVALID_VALUE);
            return GL_FALSE;
        }
        texobj = (__GLtextureObject *)
            __glNamesLockData(gc, gc->texture.shared->namesArray, textures[i]);
        /*
        ** Ensure that all of the names have corresponding textures.
        */
        if (NULL == texobj) {
            __glSetError(GL_INVALID_VALUE);
            return GL_FALSE;
        }

        if (((__GLGENcontext *)gc)->pMcdState && texobj->loadKey) {
            currentResident = ((GenMcdTextureStatus((__GLGENcontext *)gc, texobj->loadKey) & MCDRV_TEXTURE_RESIDENT) != 0);
        } else
            currentResident = texobj->resident;

        if (!currentResident) {
            allResident = GL_FALSE;
        }
        residences[i] = currentResident;
        __glNamesUnlockData(gc, texobj, __glCleanupTexObj);
    }

    return allResident;
}

GLboolean APIPRIVATE __glim_IsTexture(GLuint texture)
{
    __GLtextureObject *texobj;
    __GL_SETUP_NOT_IN_BEGIN2();

    if (0 == texture) return GL_FALSE;

    texobj = (__GLtextureObject *)
        __glNamesLockData(gc, gc->texture.shared->namesArray, texture);
    if (texobj != NULL)
    {
        __glNamesUnlockData(gc, texobj, __glCleanupTexObj);
        return GL_TRUE;
    }
    return GL_FALSE;
}

#ifdef NT
GLboolean FASTCALL __glCanShareTextures(__GLcontext *gc, __GLcontext *shareMe)
{
    GLboolean canShare = GL_TRUE;

    if (gc->texture.shared != NULL)
    {
        __glNamesLockArray(gc, gc->texture.shared->namesArray);

        // Make sure we're not trying to replace a shared object
        // The spec also says that it is illegal for the new context
        // to have any textures
        canShare = gc->texture.shared->namesArray->refcount == 1 &&
            gc->texture.shared->namesArray->tree == NULL;

        __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
    }

    return canShare;
}

void FASTCALL __glShareTextures(__GLcontext *gc, __GLcontext *shareMe)
{
    GLint i, numTextures;

    if (gc->texture.shared != NULL)
    {
        // We know that the names array doesn't have any contents
        // so no texture names can be selected as the current texture
        // or anything else.  Therefore it is safe to simply free
        // our array
        __glFreeSharedTextureState(gc);
    }

    __glNamesLockArray(gc, shareMe->texture.shared->namesArray);

    gc->texture.shared = shareMe->texture.shared;
    gc->texture.shared->namesArray->refcount++;

    // Add the new sharer's default textures to the priority list
    numTextures = gc->constants.numberOfTextures;
    for (i = 0; i < numTextures; i++)
    {
        __glTexPriListAddToList(gc, gc->texture.defaultTextures+i);
    }
    // No realization of priority list because these contexts aren't
    // current

    DBGLEVEL3(LEVEL_INFO, "Sharing textures %p with %p, count %d\n",
              gc, shareMe, gc->texture.shared->namesArray->refcount);

    __glNamesUnlockArray(gc, shareMe->texture.shared->namesArray);
}
#endif

/******************************Public*Routine******************************\
*
* glsrvBindDirectDrawTexture
*
* Make the DirectDraw texture data in gc->texture the current 2D texture
*
* History:
*  Wed Sep 04 11:35:59 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY glsrvBindDirectDrawTexture(__GLcontext *gc,
                                         int levels,
                                         LPDIRECTDRAWSURFACE *apdds,
                                         DDSURFACEDESC *pddsd,
                                         ULONG flags)
{
    __GLmipMapLevel *lev;
    __GLtexture *tex;
    GLint levIndex;
    GLint width, height;
    GLint wlog2, hlog2;
    __GLddrawTexture *pddtex;

    ASSERTOPENGL(levels <= gc->constants.maxMipMapLevel,
                 "Too many levels in DDraw texture\n");

    // Bind the fake DDraw texture.
    __glBindTexture(gc, __GL_TEX_TARGET_INDEX_DDRAW, __GL_TEX_DDRAW, GL_FALSE);

    pddtex = &gc->texture.ddtex;
    tex = &pddtex->texobj.texture.map;

    pddtex->levels = levels;
    memcpy(gc->texture.ddtex.pdds, apdds, levels*sizeof(LPDIRECTDRAWSURFACE));
    pddtex->gdds.pdds = apdds[0];
    pddtex->gdds.ddsd = *pddsd;
    pddtex->gdds.dwBitDepth =
        DdPixDepthToCount(pddsd->ddpfPixelFormat.dwRGBBitCount);
    pddtex->flags = flags;

    // Fill out the DirectDraw texture data

    width = (GLint)pddtex->gdds.ddsd.dwWidth;
    wlog2 = __glIntLog2(width);
    height = (GLint)pddtex->gdds.ddsd.dwHeight;
    hlog2 = __glIntLog2(height);

    if (wlog2 > hlog2)
    {
        tex->p = wlog2;
    }
    else
    {
        tex->p = hlog2;
    }

    lev = tex->level;
    for (levIndex = 0; levIndex < gc->texture.ddtex.levels; levIndex++)
    {
        // Buffer pointer is filled in at attention time.
        // If we're going to pass this texture to the MCD then we
        // fill in the surface handles at this time so they're
        // given to the driver at create time.
        if (flags & DDTEX_VIDEO_MEMORY)
        {
            lev->buffer = (__GLtextureBuffer *)
                ((LPDDRAWI_DDRAWSURFACE_INT)apdds[levIndex])->
                lpLcl->hDDSurface;
        }
        else
        {
            lev->buffer = NULL;
        }

        lev->width = width;
        lev->height = height;
        lev->width2 = width;
        lev->height2 = height;
        lev->width2f = (__GLfloat)width;
        lev->height2f = (__GLfloat)height;
        lev->widthLog2 = wlog2;
        lev->heightLog2 = hlog2;
        lev->border = 0;

        lev->luminanceSize = 0;
        lev->intensitySize = 0;

        if (pddtex->gdds.ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
        {
            lev->requestedFormat = tex->paletteRequestedFormat;
            lev->baseFormat = tex->paletteBaseFormat;
            lev->internalFormat = GL_COLOR_INDEX8_EXT;

            __glSetPaletteLevelExtract8(tex, lev, 0);

            lev->redSize = 0;
            lev->greenSize = 0;
            lev->blueSize = 0;
            lev->alphaSize = 0;
        }
        else
        {
            if (pddtex->gdds.ddsd.ddsCaps.dwCaps & DDSCAPS_ALPHA)
            {
                lev->requestedFormat = GL_RGBA;
                lev->baseFormat = GL_RGBA;
            }
            else
            {
                lev->requestedFormat = GL_RGB;
                lev->baseFormat = GL_RGB;
            }
            lev->internalFormat = GL_BGRA_EXT;

            lev->extract = __glExtractTexelBGRA8;

            lev->redSize = 8;
            lev->greenSize = 8;
            lev->blueSize = 8;
            lev->alphaSize = 8;
        }

        if (width != 1)
        {
            width >>= 1;
            wlog2--;
        }
        if (height != 1)
        {
            height >>= 1;
            hlog2--;
        }

        lev++;
    }

    // If the texture is in VRAM then attempt to create an MCD handle for it.
    // This must be done before palette operations so that
    // the loadKey is set.
    if (flags & DDTEX_VIDEO_MEMORY)
    {
        pddtex->texobj.loadKey =
            __glGenLoadTexture(gc, tex, MCDTEXTURE_DIRECTDRAW_SURFACES);

        // Remove handles that were set earlier.
        lev = tex->level;
        for (levIndex = 0; levIndex < gc->texture.ddtex.levels; levIndex++)
        {
            lev->buffer = NULL;
            lev++;
        }
    }
    else
    {
        pddtex->texobj.loadKey = 0;
    }

    // Pick up palette for paletted surface
    if (pddtex->gdds.ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
    {
        LPDIRECTDRAWPALETTE pddp;
        HRESULT hr;

        hr = pddtex->gdds.pdds->lpVtbl->
            GetPalette(pddtex->gdds.pdds, &pddp);
        if (hr == DD_OK && pddp != NULL)
        {
            PALETTEENTRY pe[256];

            if (pddp->lpVtbl->GetEntries(pddp, 0, 0, 256, pe) == DD_OK)
            {
                __glim_ColorTableEXT(GL_TEXTURE_2D, GL_RGB,
                                     256, GL_RGBA, GL_UNSIGNED_BYTE,
                                     pe, GL_FALSE);
            }

            pddp->lpVtbl->Release(pddp);
        }
    }

    // If we have a loadKey, make the texture current
    if (pddtex->texobj.loadKey != 0)
    {
        __glGenMakeTextureCurrent(gc, tex, pddtex->texobj.loadKey);
    }

    __GL_DELAY_VALIDATE(gc);

    return TRUE;
}

/******************************Public*Routine******************************\
*
* glsrvUnbindDirectDrawTexture
*
* Cleans up DirectDraw texture data
*
* History:
*  Wed Sep 04 13:45:08 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY glsrvUnbindDirectDrawTexture(__GLcontext *gc)
{
    GLint i;
    __GLddrawTexture *pddtex;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    pddtex = &gc->texture.ddtex;

    // Make sure a texture is bound
    if (pddtex->levels <= 0)
    {
        return;
    }

    // Delete any MCD information
    if (pddtex->texobj.loadKey != 0)
    {
        __glGenFreeTexture(gc, &pddtex->texobj.texture.map,
                           pddtex->texobj.loadKey);
        pddtex->texobj.loadKey = 0;
    }

    for (i = 0; i < pddtex->levels; i++)
    {
        // If we're currently in an attention then we locked the texture
        // surfaces and need to unlock them before we release them.
        //
        // Since there's no way to bind new DD textures in a batch, we
        // are guaranteed to have had the texture active at the beginning
        // of the batch and therefore we're guaranteed to have the texture
        // locks.
        if (gengc->fsLocks & LOCKFLAG_DD_TEXTURE)
        {
            DDSUNLOCK(pddtex->pdds[i],
                      pddtex->texobj.texture.map.level[i].buffer);
#if DBG
            pddtex->texobj.texture.map.level[i].buffer = NULL;
#endif
        }

        pddtex->pdds[i]->lpVtbl->
            Release(pddtex->pdds[i]);
#if DBG
        pddtex->pdds[i] = NULL;
#endif
    }

#if DBG
    memset(&pddtex->gdds, 0, sizeof(pddtex->gdds));
#endif

    pddtex->levels = 0;
    if (gengc->fsGenLocks & LOCKFLAG_DD_TEXTURE)
    {
        gengc->fsGenLocks &= ~LOCKFLAG_DD_TEXTURE;
        gengc->fsLocks &= ~LOCKFLAG_DD_TEXTURE;
    }

    __GL_DELAY_VALIDATE(gc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_zfunc.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#ifndef __GL_USEASMCODE

/*
** this is a series of depth testers written in C
*/

/***********************  non-masked writes ***********************/

/*
** NEVER, no mask
*/
GLboolean FASTCALL
__glDT_NEVER( __GLzValue z, __GLzValue *zfb )
{
    return GL_FALSE;
}

/*
** LEQUAL, no mask
*/
GLboolean FASTCALL
__glDT_LEQUAL( __GLzValue z, __GLzValue *zfb )
{
    if( z <= *zfb ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** LESS, no mask
*/
GLboolean FASTCALL
__glDT_LESS( __GLzValue z, __GLzValue *zfb )
{
    if( z < *zfb ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** EQUAL, no mask
*/
GLboolean FASTCALL
__glDT_EQUAL( __GLzValue z, __GLzValue *zfb )
{
    if( z == *zfb ) {
        zfb[0] = z;     /* why is this there?  Who uses GL_EQUAL anyway? */
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** GREATER, no mask
*/
GLboolean FASTCALL
__glDT_GREATER( __GLzValue z, __GLzValue *zfb )
{
    if( z > *zfb ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** NOTEQUAL, no mask
*/
GLboolean FASTCALL
__glDT_NOTEQUAL( __GLzValue z, __GLzValue *zfb )
{
    if( z != *zfb ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** GEQUAL, no mask
*/
GLboolean FASTCALL
__glDT_GEQUAL( __GLzValue z, __GLzValue *zfb )
{
    if( z >= *zfb ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** ALWAYS, no mask
*/
GLboolean FASTCALL
__glDT_ALWAYS( __GLzValue z, __GLzValue *zfb )
{
    zfb[0] = z;
    return GL_TRUE;
}



/***********************  masked writes ***********************/

/*
** LEQUAL, mask
*/
GLboolean FASTCALL
__glDT_LEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return (z <= *zfb);
}

/*
** LESS, mask
*/
GLboolean FASTCALL
__glDT_LESS_M( __GLzValue z, __GLzValue *zfb )
{
    return (z < *zfb);
}

/*
** EQUAL, mask
*/
GLboolean FASTCALL
__glDT_EQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return (z == *zfb);
}

/*
** GREATER, mask
*/
GLboolean FASTCALL
__glDT_GREATER_M( __GLzValue z, __GLzValue *zfb )
{
    return (z > *zfb);
}

/*
** NOTEQUAL, mask
*/
GLboolean FASTCALL
__glDT_NOTEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return (z != *zfb);
}

/*
** GEQUAL, mask
*/
GLboolean FASTCALL
__glDT_GEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return (z >= *zfb);
}

/*
** ALWAYS, mask
*/
GLboolean FASTCALL
__glDT_ALWAYS_M( __GLzValue z, __GLzValue *zfb )
{
    return GL_TRUE;
}


/***********************  16-bit z versions ***********************/

/*
** LEQUAL, no mask
*/
GLboolean FASTCALL
__glDT16_LEQUAL( __GLzValue z, __GLzValue *zfb )
{
#if 0
    if( (GLuint)z <= (GLuint)zbv ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
#else
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 <= *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
#endif
}

/*
** LESS, no mask
*/
GLboolean FASTCALL
__glDT16_LESS( __GLzValue z, __GLzValue *zfb )
{
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 < *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** EQUAL, no mask
*/
GLboolean FASTCALL
__glDT16_EQUAL( __GLzValue z, __GLzValue *zfb )
{
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 == *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** GREATER, no mask
*/
GLboolean FASTCALL
__glDT16_GREATER( __GLzValue z, __GLzValue *zfb )
{
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 > *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** NOTEQUAL, no mask
*/
GLboolean FASTCALL
__glDT16_NOTEQUAL( __GLzValue z, __GLzValue *zfb )
{
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 != *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** GEQUAL, no mask
*/
GLboolean FASTCALL
__glDT16_GEQUAL( __GLzValue z, __GLzValue *zfb )
{
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 >= *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** ALWAYS, no mask
*/
GLboolean FASTCALL
__glDT16_ALWAYS( __GLzValue z, __GLzValue *zfb )
{
    *((__GLz16Value *)zfb) = z >> Z16_SHIFT;
    return GL_TRUE;
}



/***********************  masked writes ***********************/

/*
** LEQUAL, mask
*/
GLboolean FASTCALL
__glDT16_LEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) <= *((__GLz16Value *)zfb) );
}

/*
** LESS, mask
*/
GLboolean FASTCALL
__glDT16_LESS_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) < *((__GLz16Value *)zfb) );
}

/*
** EQUAL, mask
*/
GLboolean FASTCALL
__glDT16_EQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) == *((__GLz16Value *)zfb) );
}

/*
** GREATER, mask
*/
GLboolean FASTCALL
__glDT16_GREATER_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) > *((__GLz16Value *)zfb) );
}

/*
** NOTEQUAL, mask
*/
GLboolean FASTCALL
__glDT16_NOTEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) != *((__GLz16Value *)zfb) );
}

/*
** GEQUAL, mask
*/
GLboolean FASTCALL
__glDT16_GEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) >= *((__GLz16Value *)zfb) );
}

/*
** ALWAYS, mask
*/
GLboolean FASTCALL
__glDT16_ALWAYS_M( __GLzValue z, __GLzValue *zfb )
{
    return GL_TRUE;
}


#endif /* !__GL_USEASMCODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\soft\so_xform.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Transformation procedures.
**
** $Revision: 1.38 $
** $Date: 1993/11/29 20:34:48 $
*/
#include "precomp.h"
#pragma hdrstop

#define __glGenericPickIdentityMatrixProcs(gc, m)	    \
{							                            \
    (m)->xf1 = __glXForm1_2DNRW;			            \
    (m)->xf2 = __glXForm2_2DNRW;			            \
    (m)->xf3 = __glXForm3_2DNRW;			            \
    (m)->xf4 = __glXForm4_2DNRW;			            \
    (m)->xfNorm = __glXForm3_2DNRW;			            \
    (m)->xf1Batch = __glXForm1_2DNRWBatch;		        \
    (m)->xf2Batch = __glXForm2_2DNRWBatch;		        \
    (m)->xf3Batch = __glXForm3_2DNRWBatch;		        \
    (m)->xf4Batch = __glXForm4_2DNRWBatch;		        \
    (m)->xfNormBatch = __glXForm3_2DNRWBatchNormal;		\
    (m)->xfNormBatchN = __glXForm3_2DNRWBatchNormalN;	\
}

void FASTCALL __glScaleMatrix(__GLcontext *gc, __GLmatrix *m, void *data);
void FASTCALL __glTranslateMatrix(__GLcontext *gc, __GLmatrix *m, void *data);
void FASTCALL __glMultiplyMatrix(__GLcontext *gc, __GLmatrix *m, void *data);

// Bit flags that identify matrix entries that contain 0 or 1.

#define _M00_0  0x00000001
#define _M01_0  0x00000002
#define _M02_0  0x00000004
#define _M03_0  0x00000008
#define _M10_0  0x00000010
#define _M11_0  0x00000020
#define _M12_0  0x00000040
#define _M13_0  0x00000080
#define _M20_0  0x00000100
#define _M21_0  0x00000200
#define _M22_0  0x00000400
#define _M23_0  0x00000800
#define _M30_0  0x00001000
#define _M31_0  0x00002000
#define _M32_0  0x00004000
#define _M33_0  0x00008000

#define _M00_1  0x00010000
#define _M01_1  0x00020000
#define _M02_1  0x00040000
#define _M03_1  0x00080000
#define _M10_1  0x00100000
#define _M11_1  0x00200000
#define _M12_1  0x00400000
#define _M13_1  0x00800000
#define _M20_1  0x01000000
#define _M21_1  0x02000000
#define _M22_1  0x04000000
#define _M23_1  0x08000000
#define _M30_1  0x10000000
#define _M31_1  0x20000000
#define _M32_1  0x40000000
#define _M33_1  0x80000000

// Pre-defined matrix types.
#define _MT_IDENTITY                            \
    (_M00_1 | _M01_0 | _M02_0 | _M03_0 |        \
     _M10_0 | _M11_1 | _M12_0 | _M13_0 |        \
     _M20_0 | _M21_0 | _M22_1 | _M23_0 |        \
     _M30_0 | _M31_0 | _M32_0 | _M33_1)

#define _MT_IS2DNR                              \
    (         _M01_0 | _M02_0 | _M03_0 |        \
     _M10_0 |          _M12_0 | _M13_0 |        \
     _M20_0 | _M21_0 |          _M23_0 |        \
                                _M33_1)

#define _MT_IS2D                                \
    (                  _M02_0 | _M03_0 |        \
                       _M12_0 | _M13_0 |        \
     _M20_0 | _M21_0 |          _M23_0 |        \
                                _M33_1)

#define _MT_W0001                               \
    (                           _M03_0 |        \
                                _M13_0 |        \
                                _M23_0 |        \
                                _M33_1)

#define GET_MATRIX_MASK(m,i,j)                                  \
        if ((m)->matrix[i][j] == zer) rowMask |= _M##i##j##_0;  \
        else if ((m)->matrix[i][j] == one) rowMask |= _M##i##j##_1;

// Note: If you are adding a new type, make sure all functions
// using matrixType are correct!  (__glScaleMatrix, __glTranslateMatrix, 
// __glInvertTransposeMatrix, and __glGenericPickVertexProcs)

void FASTCALL __glUpdateMatrixType(__GLmatrix *m)
{
    register __GLfloat zer = __glZero;
    register __GLfloat one = __glOne;
    DWORD rowMask = 0; // identifies 0 and 1 entries

    GET_MATRIX_MASK(m,0,0);
    GET_MATRIX_MASK(m,0,1);
    GET_MATRIX_MASK(m,0,2);
    GET_MATRIX_MASK(m,0,3);
    GET_MATRIX_MASK(m,1,0);
    GET_MATRIX_MASK(m,1,1);
    GET_MATRIX_MASK(m,1,2);
    GET_MATRIX_MASK(m,1,3);
    GET_MATRIX_MASK(m,2,0);
    GET_MATRIX_MASK(m,2,1);
    GET_MATRIX_MASK(m,2,2);
    GET_MATRIX_MASK(m,2,3);
    GET_MATRIX_MASK(m,3,0);
    GET_MATRIX_MASK(m,3,1);
    GET_MATRIX_MASK(m,3,2);
    GET_MATRIX_MASK(m,3,3);

// Some common cases.
// Order of finding matrix type is important!

    if ((rowMask & _MT_IDENTITY) == _MT_IDENTITY)
        m->matrixType = __GL_MT_IDENTITY;
    else if ((rowMask & _MT_IS2DNR) == _MT_IS2DNR)
        m->matrixType = __GL_MT_IS2DNR;
    else if ((rowMask & _MT_IS2D) == _MT_IS2D)
        m->matrixType = __GL_MT_IS2D;
    else if ((rowMask & _MT_W0001) == _MT_W0001)
        m->matrixType = __GL_MT_W0001;
    else 
        m->matrixType = __GL_MT_GENERAL;
}

static void SetDepthRange(__GLcontext *gc, double zNear, double zFar)
{
    __GLviewport *vp = &gc->state.viewport;
    double scale, zero = __glZero, one = __glOne;

    /* Clamp depth range to legal values */
    if (zNear < zero) zNear = zero;
    if (zNear > one) zNear = one;
    if (zFar < zero) zFar = zero;
    if (zFar > one) zFar = one;
    vp->zNear = zNear;
    vp->zFar = zFar;

    /* Compute viewport values for the new depth range */
    if (((__GLGENcontext *)gc)->pMcdState)
        scale = GENACCEL(gc).zDevScale * __glHalf;
    else
        scale = gc->depthBuffer.scale * __glHalf;
    gc->state.viewport.zScale =	(zFar - zNear) * scale;
    gc->state.viewport.zCenter = (zFar + zNear) * scale;

#ifdef _MCD_
    MCD_STATE_DIRTY(gc, VIEWPORT);
#endif
}

void FASTCALL __glInitTransformState(__GLcontext *gc)
{
    GLint i, numClipPlanes, numClipTemp;
    __GLtransform *tr;
    __GLtransformP *ptr;
    __GLtransformT *ttr;
    __GLvertex *vx;

    /* Allocate memory for clip planes */
    numClipPlanes = gc->constants.numberOfClipPlanes;
    numClipTemp = (numClipPlanes + 6) * 2;

    gc->state.transform.eyeClipPlanes = (__GLcoord *)
	GCALLOCZ(gc, 2 * numClipPlanes * sizeof(__GLcoord));
#ifdef NT
    if (NULL == gc->state.transform.eyeClipPlanes)
        return;
#endif
    gc->state.transform.eyeClipPlanesSet =
        gc->state.transform.eyeClipPlanes + numClipPlanes;

    /* Allocate memory for matrix stacks */
    gc->transform.modelViewStack = (__GLtransform*)
	GCALLOCZ(gc, __GL_WGL_MAX_MODELVIEW_STACK_DEPTH*sizeof(__GLtransform));
#ifdef NT
    if (NULL == gc->transform.modelViewStack)
        return;
#endif

    gc->transform.projectionStack = (__GLtransformP*)
	GCALLOCZ(gc, __GL_WGL_MAX_PROJECTION_STACK_DEPTH*
                 sizeof(__GLtransformP));
#ifdef NT
    if (NULL == gc->transform.projectionStack)
        return;
#endif

    gc->transform.textureStack = (__GLtransformT*)
	GCALLOCZ(gc, __GL_WGL_MAX_TEXTURE_STACK_DEPTH*
                 sizeof(__GLtransformT));
#ifdef NT
    if (NULL == gc->transform.textureStack)
        return;
#endif

    /* Allocate memory for clipping temporaries */
    gc->transform.clipTemp = (__GLvertex*)
	GCALLOCZ(gc, numClipTemp * sizeof(__GLvertex));
#ifdef NT
    if (NULL == gc->transform.clipTemp)
        return;
#endif


    gc->state.transform.matrixMode = GL_MODELVIEW;
    SetDepthRange(gc, __glZero, __glOne);

    gc->transform.modelView = tr = &gc->transform.modelViewStack[0];
    __glMakeIdentity(&tr->matrix);
    __glGenericPickIdentityMatrixProcs(gc, &tr->matrix);
    __glMakeIdentity(&tr->inverseTranspose);
    __glGenericPickIdentityMatrixProcs(gc, &tr->inverseTranspose);
    tr->flags = XFORM_CHANGED;

    __glMakeIdentity(&tr->mvp);
    gc->transform.projection = ptr = &gc->transform.projectionStack[0];
    __glMakeIdentity((__GLmatrix *) &ptr->matrix);
    __glGenericPickMvpMatrixProcs(gc, &tr->mvp);

    gc->transform.texture = ttr = &gc->transform.textureStack[0];
    __glMakeIdentity(&ttr->matrix);
    __glGenericPickIdentityMatrixProcs(gc, &ttr->matrix);

    vx = &gc->transform.clipTemp[0];
    for (i = 0; i < numClipTemp; i++, vx++) {/*XXX*/
	vx->color = &vx->colors[__GL_FRONTFACE];
    }

    gc->state.current.normal.z = __glOne;
}

/************************************************************************/

void APIPRIVATE __glim_MatrixMode(GLenum mode)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (mode) {
      case GL_MODELVIEW:
      case GL_PROJECTION:
      case GL_TEXTURE:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    gc->state.transform.matrixMode = mode;
}

void APIPRIVATE __glim_LoadIdentity(void)
{
    __GL_SETUP_NOT_IN_BEGIN();
    __glDoLoadMatrix(gc, NULL, TRUE);
}

void APIPRIVATE __glim_LoadMatrixf(const GLfloat m[16])
{
    __GL_SETUP_NOT_IN_BEGIN();
    __glDoLoadMatrix(gc, (__GLfloat (*)[4])m, FALSE);
}

void APIPRIVATE __glim_MultMatrixf(const GLfloat m[16])
{
    __GL_SETUP_NOT_IN_BEGIN();
    __glDoMultMatrix(gc, (void *) m, __glMultiplyMatrix);
}

void APIPRIVATE __glim_Rotatef(GLfloat angle, GLfloat ax, GLfloat ay, GLfloat az)
{
    __GLmatrix m;
    __GLfloat radians, sine, cosine, ab, bc, ca, t;
    __GLfloat av[4], axis[4];

    __GL_SETUP_NOT_IN_BEGIN();

    av[0] = ax;
    av[1] = ay;
    av[2] = az;
    av[3] = 0;
    __glNormalize(axis, av);

    radians = angle * __glDegreesToRadians;
    sine = __GL_SINF(radians);
    cosine = __GL_COSF(radians);
    ab = axis[0] * axis[1] * (1 - cosine);
    bc = axis[1] * axis[2] * (1 - cosine);
    ca = axis[2] * axis[0] * (1 - cosine);

#ifdef NT
    m.matrix[0][3] = __glZero;
    m.matrix[1][3] = __glZero;
    m.matrix[2][3] = __glZero;
    m.matrix[3][0] = __glZero;
    m.matrix[3][1] = __glZero;
    m.matrix[3][2] = __glZero;
    m.matrix[3][3] = __glOne;
#else
    __glMakeIdentity(&m);
#endif // NT
    t = axis[0] * axis[0];
    m.matrix[0][0] = t + cosine * (1 - t);
    m.matrix[2][1] = bc - axis[0] * sine;
    m.matrix[1][2] = bc + axis[0] * sine;

    t = axis[1] * axis[1];
    m.matrix[1][1] = t + cosine * (1 - t);
    m.matrix[2][0] = ca + axis[1] * sine;
    m.matrix[0][2] = ca - axis[1] * sine;

    t = axis[2] * axis[2];
    m.matrix[2][2] = t + cosine * (1 - t);
    m.matrix[1][0] = ab - axis[2] * sine;
    m.matrix[0][1] = ab + axis[2] * sine;
    __glDoMultMatrix(gc, &m, __glMultiplyMatrix);
}

struct __glScaleRec {
    __GLfloat x,y,z;
};

void APIPRIVATE __glim_Scalef(GLfloat x, GLfloat y, GLfloat z)
{
    struct __glScaleRec scale;
    __GL_SETUP_NOT_IN_BEGIN();

    scale.x = x;
    scale.y = y;
    scale.z = z;
    __glDoMultMatrix(gc, &scale, __glScaleMatrix);
}

struct __glTranslationRec {
    __GLfloat x,y,z;
};

void APIPRIVATE __glim_Translatef(GLfloat x, GLfloat y, GLfloat z)
{
    struct __glTranslationRec trans;
    __GL_SETUP_NOT_IN_BEGIN();

    trans.x = x;
    trans.y = y;
    trans.z = z;
    __glDoMultMatrix(gc, &trans, __glTranslateMatrix);
}

void APIPRIVATE __glim_PushMatrix(void)
{
#ifdef NT
    __GL_SETUP_NOT_IN_BEGIN();	// no need to validate
    switch (gc->state.transform.matrixMode)
    {
      case GL_MODELVIEW:
	__glPushModelViewMatrix(gc);
	break;
      case GL_PROJECTION:
	__glPushProjectionMatrix(gc);
	break;
      case GL_TEXTURE:
	__glPushTextureMatrix(gc);
	break;
    }
#else
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();
    (*gc->procs.pushMatrix)(gc);
#endif
}

void APIPRIVATE __glim_PopMatrix(void)
{
#ifdef NT
    __GL_SETUP_NOT_IN_BEGIN();	// no need to validate
    switch (gc->state.transform.matrixMode)
    {
      case GL_MODELVIEW:
	__glPopModelViewMatrix(gc);
	break;
      case GL_PROJECTION:
	__glPopProjectionMatrix(gc);
	break;
      case GL_TEXTURE:
	__glPopTextureMatrix(gc);
	break;
    }
#else
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();
    (*gc->procs.popMatrix)(gc);
#endif
}

void APIPRIVATE __glim_Frustum(GLdouble left, GLdouble right,
		    GLdouble bottom, GLdouble top,
		    GLdouble zNear, GLdouble zFar)
{
    __GLmatrix m;
    __GLfloat deltaX, deltaY, deltaZ;
    __GL_SETUP_NOT_IN_BEGIN();

    deltaX = right - left;
    deltaY = top - bottom;
    deltaZ = zFar - zNear;
    if ((zNear <= (GLdouble) __glZero) || (zFar <= (GLdouble) __glZero) || (deltaX == __glZero) || 
	    (deltaY == __glZero) || (deltaZ == __glZero)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }

#ifdef NT
    m.matrix[0][1] = __glZero;
    m.matrix[0][2] = __glZero;
    m.matrix[0][3] = __glZero;
    m.matrix[1][0] = __glZero;
    m.matrix[1][2] = __glZero;
    m.matrix[1][3] = __glZero;
    m.matrix[3][0] = __glZero;
    m.matrix[3][1] = __glZero;
#else
    __glMakeIdentity(&m);
#endif
    m.matrix[0][0] = zNear * __glDoubleTwo / deltaX;
    m.matrix[1][1] = zNear * __glDoubleTwo / deltaY;
    m.matrix[2][0] = (right + left) / deltaX;
    m.matrix[2][1] = (top + bottom) / deltaY;
    m.matrix[2][2] = -(zFar + zNear) / deltaZ;
    m.matrix[2][3] = __glMinusOne;
    m.matrix[3][2] = __glDoubleMinusTwo * zNear * zFar / deltaZ;
    m.matrix[3][3] = __glZero;
    __glDoMultMatrix(gc, &m, __glMultiplyMatrix);
}

void APIPRIVATE __glim_Ortho(GLdouble left, GLdouble right, GLdouble bottom, 
		  GLdouble top, GLdouble zNear, GLdouble zFar)
{
    __GLmatrix m;
    GLdouble deltax, deltay, deltaz;
    __GL_SETUP_NOT_IN_BEGIN();

    deltax = right - left;
    deltay = top - bottom;
    deltaz = zFar - zNear;
    if ((deltax == (GLdouble) __glZero) || (deltay == (GLdouble) __glZero) || (deltaz == (GLdouble) __glZero)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }

#ifdef NT
    m.matrix[0][1] = __glZero;
    m.matrix[0][2] = __glZero;
    m.matrix[0][3] = __glZero;
    m.matrix[1][0] = __glZero;
    m.matrix[1][2] = __glZero;
    m.matrix[1][3] = __glZero;
    m.matrix[2][0] = __glZero;
    m.matrix[2][1] = __glZero;
    m.matrix[2][3] = __glZero;
    m.matrix[3][3] = __glOne;
#else
    __glMakeIdentity(&m);
#endif
    m.matrix[0][0] = __glDoubleTwo / deltax;
    m.matrix[3][0] = -(right + left) / deltax;
    m.matrix[1][1] = __glDoubleTwo / deltay;
    m.matrix[3][1] = -(top + bottom) / deltay;
    m.matrix[2][2] = __glDoubleMinusTwo / deltaz;
    m.matrix[3][2] = -(zFar + zNear) / deltaz;

    __glDoMultMatrix(gc, &m, __glMultiplyMatrix);
}

void FASTCALL __glUpdateViewport(__GLcontext *gc)
{
    __GLfloat ww, hh, w2, h2;

    /* Compute operational viewport values */
    w2 = gc->state.viewport.width * __glHalf;
    h2 = gc->state.viewport.height * __glHalf;
    ww = w2 - gc->constants.viewportEpsilon;
    hh = h2 - gc->constants.viewportEpsilon;
    gc->state.viewport.xScale = ww;
    gc->state.viewport.xCenter = gc->state.viewport.x + w2 +
	gc->constants.fviewportXAdjust;
    if (gc->constants.yInverted) {
	gc->state.viewport.yScale = -hh;
	gc->state.viewport.yCenter =
	    gc->constants.height - (gc->state.viewport.y + h2) +
	    gc->constants.fviewportYAdjust;

#if 0
        DbgPrint("UV ys %.3lf, yc %.3lf (%.3lf)\n",
                 -hh, gc->state.viewport.yCenter,
                 gc->constants.height - (gc->state.viewport.y + h2));
#endif
    } else {
	gc->state.viewport.yScale = hh;
	gc->state.viewport.yCenter = gc->state.viewport.y + h2 +
	    gc->constants.fviewportYAdjust;
    }
}

void FASTCALL __glUpdateViewportDependents(__GLcontext *gc)
{
    /* 
    ** Now that the implementation may have found us a new window size,
    ** we compute these offsets...
    */
    gc->transform.minx = gc->state.viewport.x + gc->constants.viewportXAdjust;
    gc->transform.maxx = gc->transform.minx + gc->state.viewport.width;
    gc->transform.fminx = gc->transform.minx;
    gc->transform.fmaxx = gc->transform.maxx;

    gc->transform.miny =
        (gc->constants.height -
         (gc->state.viewport.y + gc->state.viewport.height)) + 
         gc->constants.viewportYAdjust;
    gc->transform.maxy = gc->transform.miny + gc->state.viewport.height;
    gc->transform.fminy = gc->transform.miny;
    gc->transform.fmaxy = gc->transform.maxy;
}

void APIPRIVATE __glim_Viewport(GLint x, GLint y, GLsizei w, GLsizei h)
{
    __GLfloat ww, hh;
    __GL_SETUP_NOT_IN_BEGIN();

    if ((w < 0) || (h < 0)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }

    if ((gc->state.viewport.x == x) && (gc->state.viewport.y == y) &&
        (gc->state.viewport.width == w) && (gc->state.viewport.height == h))
        return;
    
    if (h > gc->constants.maxViewportHeight) {
	h = gc->constants.maxViewportHeight;
    }
    if (w > gc->constants.maxViewportWidth) {
	w = gc->constants.maxViewportWidth;
    }

    gc->state.viewport.x = x;
    gc->state.viewport.y = y;
    gc->state.viewport.width = w;
    gc->state.viewport.height = h;

    __glUpdateViewport(gc);

    (*gc->procs.applyViewport)(gc);

    __glUpdateViewportDependents(gc);
    
    /*
    ** Pickers that notice when the transformation matches the viewport
    ** exactly need to be revalidated.  Ugh.
    */
    __GL_DELAY_VALIDATE(gc);
}

void APIPRIVATE __glim_DepthRange(GLdouble zNear, GLdouble zFar)
{
    __GL_SETUP_NOT_IN_BEGIN();

    SetDepthRange(gc, zNear, zFar);
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
}

void APIPRIVATE __glim_Scissor(GLint x, GLint y, GLsizei w, GLsizei h)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((w < 0) || (h < 0)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }

    gc->state.scissor.scissorX = x;
    gc->state.scissor.scissorY = y;
    gc->state.scissor.scissorWidth = w;
    gc->state.scissor.scissorHeight = h;

#ifdef NT
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, SCISSOR);
#endif

    // applyViewport does both
    (*gc->procs.applyViewport)(gc);
#else
    (*gc->procs.applyScissor)(gc);
    (*gc->procs.computeClipBox)(gc);
#endif
}

void APIPRIVATE __glim_ClipPlane(GLenum pi, const GLdouble pv[])
{
    __GLtransform *tr;
    __GL_SETUP_NOT_IN_BEGIN();

    pi -= GL_CLIP_PLANE0;
#ifdef NT
    // pi is unsigned!
    if (pi >= (GLenum) gc->constants.numberOfClipPlanes) {
#else
    if ((pi < 0) || (pi >= gc->constants.numberOfClipPlanes)) {
#endif // NT
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    gc->state.transform.eyeClipPlanesSet[pi].x = pv[0];
    gc->state.transform.eyeClipPlanesSet[pi].y = pv[1];
    gc->state.transform.eyeClipPlanesSet[pi].z = pv[2];
    gc->state.transform.eyeClipPlanesSet[pi].w = pv[3];

    /*
    ** Project user clip plane into eye space.
    */
    tr = gc->transform.modelView;
    if (tr->flags & XFORM_UPDATE_INVERSE) {
	__glComputeInverseTranspose(gc, tr);
    }
    (*tr->inverseTranspose.xf4)(&gc->state.transform.eyeClipPlanes[pi],
                                &gc->state.transform.eyeClipPlanesSet[pi].x,
				&tr->inverseTranspose);

    __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, CLIPCTRL);
#endif
}

/************************************************************************/

void FASTCALL __glPushModelViewMatrix(__GLcontext *gc)
{
    __GLtransform **trp, *tr, *stack;

    trp = &gc->transform.modelView;
    stack = gc->transform.modelViewStack;
    tr = *trp;
    if (tr < &stack[__GL_WGL_MAX_MODELVIEW_STACK_DEPTH-1]) {
	tr[1] = tr[0];
	*trp = tr + 1;
    } else {
	__glSetError(GL_STACK_OVERFLOW);
    }
}

void FASTCALL __glPopModelViewMatrix(__GLcontext *gc)
{
    __GLtransform **trp, *tr, *stack, *mvtr;
    __GLtransformP *ptr;

    trp = &gc->transform.modelView;
    stack = gc->transform.modelViewStack;
    tr = *trp;
    if (tr > &stack[0]) {
	*trp = tr - 1;

	/*
	** See if sequence number of modelView matrix is the same as the
	** sequence number of the projection matrix.  If not, then
	** recompute the mvp matrix.
	*/
	mvtr = gc->transform.modelView;
	ptr = gc->transform.projection;
	if (mvtr->sequence != ptr->sequence) {
	    mvtr->sequence = ptr->sequence;
	    __glMultMatrix(&mvtr->mvp, &mvtr->matrix, (__GLmatrix *) &ptr->matrix);
            __glUpdateMatrixType(&mvtr->mvp);
	}
        __glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
    } else {
        __glSetError(GL_STACK_UNDERFLOW);
        return;
    }
}

void FASTCALL __glComputeInverseTranspose(__GLcontext *gc, __GLtransform *tr)
{
    __GLmatrix inv;

    __glInvertTransposeMatrix(&tr->inverseTranspose, &tr->matrix);
    __glUpdateMatrixType(&tr->inverseTranspose);
    __glGenericPickMatrixProcs(gc, &tr->inverseTranspose);
    tr->flags &= ~XFORM_UPDATE_INVERSE;
}

/************************************************************************/

void FASTCALL __glPushProjectionMatrix(__GLcontext *gc)
{
    __GLtransformP **trp, *tr, *stack;

    trp = &gc->transform.projection;
    stack = gc->transform.projectionStack;
    tr = *trp;
    if (tr < &stack[__GL_WGL_MAX_PROJECTION_STACK_DEPTH-1]) {
	tr[1] = tr[0];
	*trp = tr + 1;
    } else {
	__glSetError(GL_STACK_OVERFLOW);
    }
}

void FASTCALL __glPopProjectionMatrix(__GLcontext *gc)
{
    __GLtransform *mvtr;
    __GLtransformP **trp, *tr, *stack, *ptr;

    trp = &gc->transform.projection;
    stack = gc->transform.projectionStack;
    tr = *trp;
    if (tr > &stack[0]) {
	*trp = tr - 1;

	/*
	** See if sequence number of modelView matrix is the same as the
	** sequence number of the projection matrix.  If not, then
	** recompute the mvp matrix.
	*/
	mvtr = gc->transform.modelView;
	ptr = gc->transform.projection;
	if (mvtr->sequence != ptr->sequence) {
	    mvtr->sequence = ptr->sequence;
	    __glMultMatrix(&mvtr->mvp, &mvtr->matrix, (__GLmatrix *) &ptr->matrix);
            __glUpdateMatrixType(&mvtr->mvp);
	}
	__glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
    } else {
	__glSetError(GL_STACK_UNDERFLOW);
	return;
    }
}

/************************************************************************/

void FASTCALL __glPushTextureMatrix(__GLcontext *gc)
{
    __GLtransformT **trp, *tr, *stack;

    trp = &gc->transform.texture;
    stack = gc->transform.textureStack;
    tr = *trp;
    if (tr < &stack[__GL_WGL_MAX_TEXTURE_STACK_DEPTH-1]) {
	tr[1] = tr[0];
	*trp = tr + 1;
    } else {
	__glSetError(GL_STACK_OVERFLOW);
    }
}

void FASTCALL __glPopTextureMatrix(__GLcontext *gc)
{
    __GLtransformT **trp, *tr, *stack;

    trp = &gc->transform.texture;
    stack = gc->transform.textureStack;
    tr = *trp;
    if (tr > &stack[0]) {
	*trp = tr - 1;
        MCD_STATE_DIRTY(gc, TEXTRANSFORM);
    } else {
	__glSetError(GL_STACK_UNDERFLOW);
	return;
    }
}

/************************************************************************/


void FASTCALL __glDoLoadMatrix(__GLcontext *gc, const __GLfloat m[4][4], BOOL bIsIdentity)
{
    __GLtransform *mvtr;
    __GLtransformP *ptr;
    __GLtransformT *ttr;

    switch (gc->state.transform.matrixMode) {
      case GL_MODELVIEW:
	mvtr = gc->transform.modelView;
	if (bIsIdentity)
	{
            __glMakeIdentity(&mvtr->matrix);
	    __glGenericPickIdentityMatrixProcs(gc, &mvtr->matrix);
            __glMakeIdentity(&mvtr->inverseTranspose);
	    __glGenericPickIdentityMatrixProcs(gc, &mvtr->inverseTranspose);
            mvtr->flags = XFORM_CHANGED;
	}
	else
	{
	    *(__GLmatrixBase *)mvtr->matrix.matrix = *(__GLmatrixBase *)m;
            __glUpdateMatrixType(&mvtr->matrix);
	    __glGenericPickMatrixProcs(gc, &mvtr->matrix);
	    mvtr->flags = XFORM_CHANGED | XFORM_UPDATE_INVERSE;
	}

        /* Update mvp matrix */
        ptr = gc->transform.projection;
            ASSERTOPENGL(mvtr->sequence == ptr->sequence,
                "__glDoLoadMatrix: bad projection sequence\n");
        if (bIsIdentity)
        {
                *(__GLmatrixBase *)mvtr->mvp.matrix = *(__GLmatrixBase *)ptr->matrix.matrix;
                mvtr->mvp.matrixType = ptr->matrix.matrixType;
        }
        else
        {
	        __glMultMatrix(&mvtr->mvp, &mvtr->matrix, (__GLmatrix *) &ptr->matrix);
                __glUpdateMatrixType(&mvtr->mvp);
        }
        __glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
        break;

      case GL_PROJECTION:
        ptr = gc->transform.projection;
        if (bIsIdentity)
        {
                __glMakeIdentity((__GLmatrix *) &ptr->matrix);
        }
        else
        {
	        *(__GLmatrixBase *)ptr->matrix.matrix = *(__GLmatrixBase *)m;
                __glUpdateMatrixType((__GLmatrix *) &ptr->matrix);
        }

#ifdef NT
        ptr->sequence = ++gc->transform.projectionSequence;
#else
        if (++gc->transform.projectionSequence == 0) {
	        __glInvalidateSequenceNumbers(gc);
        } else {
	        ptr->sequence = gc->transform.projectionSequence;
        }
#endif // NT

	/* Update mvp matrix */
	mvtr = gc->transform.modelView;
	mvtr->sequence = ptr->sequence;
        mvtr->flags |= XFORM_CHANGED;
	if (bIsIdentity)
	{
            *(__GLmatrixBase *)mvtr->mvp.matrix = *(__GLmatrixBase *)mvtr->matrix.matrix;
            mvtr->mvp.matrixType = mvtr->matrix.matrixType;
	}
	else
	{
	    __glMultMatrix(&mvtr->mvp, &mvtr->matrix, (__GLmatrix *) &ptr->matrix);
            __glUpdateMatrixType(&mvtr->mvp);
	}
	__glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
	break;

      case GL_TEXTURE:
        ttr = gc->transform.texture;
        if (bIsIdentity)
        {
            __glMakeIdentity(&ttr->matrix);
            __glGenericPickIdentityMatrixProcs(gc, &ttr->matrix);
        }
        else
        {
            *(__GLmatrixBase *)ttr->matrix.matrix = *(__GLmatrixBase *)m;
            __glUpdateMatrixType(&ttr->matrix);
            __glGenericPickMatrixProcs(gc, &ttr->matrix);
        }
        MCD_STATE_DIRTY(gc, TEXTRANSFORM);
	break;
    }
}

void FASTCALL __glDoMultMatrix(__GLcontext *gc, void *data, 
    void (FASTCALL *multiply)(__GLcontext *gc, __GLmatrix *m, void *data))
{
    __GLtransform *mvtr;
    __GLtransformT *ttr;
    __GLtransformP *ptr;

    switch (gc->state.transform.matrixMode) {
      case GL_MODELVIEW:
	mvtr = gc->transform.modelView;
	(*multiply)(gc, &mvtr->matrix, data);
	mvtr->flags = XFORM_CHANGED | XFORM_UPDATE_INVERSE;
	__glGenericPickMatrixProcs(gc, &mvtr->matrix);

        /* Update mvp matrix */
            ASSERTOPENGL(mvtr->sequence == gc->transform.projection->sequence,
                "__glDoMultMatrix: bad projection sequence\n");
        (*multiply)(gc, &mvtr->mvp, data);
        __glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
        break;

      case GL_PROJECTION:
        ptr = gc->transform.projection;
        (*multiply)(gc, (__GLmatrix *) &ptr->matrix, data);
#ifdef NT
        ptr->sequence = ++gc->transform.projectionSequence;
#else
        if (++gc->transform.projectionSequence == 0) {
	        __glInvalidateSequenceNumbers(gc);
        } else {
	        ptr->sequence = gc->transform.projectionSequence;
        }
#endif

	/* Update mvp matrix */
	mvtr = gc->transform.modelView;
	mvtr->sequence = ptr->sequence;
        mvtr->flags |= XFORM_CHANGED;
	__glMultMatrix(&mvtr->mvp, &mvtr->matrix, (__GLmatrix *) &ptr->matrix);
        __glUpdateMatrixType(&mvtr->mvp);
	__glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
	break;

      case GL_TEXTURE:
	ttr = gc->transform.texture;
	(*multiply)(gc, &ttr->matrix, data);
	__glGenericPickMatrixProcs(gc, &ttr->matrix);
        MCD_STATE_DIRTY(gc, TEXTRANSFORM);
	break;
    }
}

/************************************************************************/

/*
** Muliply the first matrix by the second one keeping track of the matrix
** type of the newly combined matrix.
*/
void FASTCALL __glMultiplyMatrix(__GLcontext *gc, __GLmatrix *m, void *data)
{
    __GLmatrix *tm;

    tm = data;
    __glMultMatrix(m, tm, m);
    __glUpdateMatrixType(m);
}

void FASTCALL __glScaleMatrix(__GLcontext *gc, __GLmatrix *m, void *data)
{
    struct __glScaleRec *scale;
    __GLfloat x,y,z;
    __GLfloat M0, M1, M2, M3;

    if (m->matrixType > __GL_MT_IS2DNR) {
	m->matrixType = __GL_MT_IS2DNR;
    }
    scale = data;
    x = scale->x;
    y = scale->y;
    z = scale->z;
    
    M0 = x * m->matrix[0][0];
    M1 = x * m->matrix[0][1];
    M2 = x * m->matrix[0][2];
    M3 = x * m->matrix[0][3];
    m->matrix[0][0] = M0;
    m->matrix[0][1] = M1;
    m->matrix[0][2] = M2;
    m->matrix[0][3] = M3;

    M0 = y * m->matrix[1][0];
    M1 = y * m->matrix[1][1];
    M2 = y * m->matrix[1][2];
    M3 = y * m->matrix[1][3];
    m->matrix[1][0] = M0;
    m->matrix[1][1] = M1;
    m->matrix[1][2] = M2;
    m->matrix[1][3] = M3;

    M0 = z * m->matrix[2][0];
    M1 = z * m->matrix[2][1];
    M2 = z * m->matrix[2][2];
    M3 = z * m->matrix[2][3];
    m->matrix[2][0] = M0;
    m->matrix[2][1] = M1;
    m->matrix[2][2] = M2;
    m->matrix[2][3] = M3;
}

/*
** Matrix type of m stays the same.
*/
void FASTCALL __glTranslateMatrix(__GLcontext *gc, __GLmatrix *m, void *data)
{
    struct __glTranslationRec *trans;
    __GLfloat x,y,z;
    __GLfloat M30, M31, M32, M33;

    if (m->matrixType > __GL_MT_IS2DNR) {
	m->matrixType = __GL_MT_IS2DNR;
    }
    trans = data;
    x = trans->x;
    y = trans->y;
    z = trans->z;
    M30 = x * m->matrix[0][0] + y * m->matrix[1][0] + z * m->matrix[2][0] + 
	    m->matrix[3][0];
    M31 = x * m->matrix[0][1] + y * m->matrix[1][1] + z * m->matrix[2][1] + 
	    m->matrix[3][1];
    M32 = x * m->matrix[0][2] + y * m->matrix[1][2] + z * m->matrix[2][2] + 
	    m->matrix[3][2];
    M33 = x * m->matrix[0][3] + y * m->matrix[1][3] + z * m->matrix[2][3] + 
	    m->matrix[3][3];
    m->matrix[3][0] = M30;
    m->matrix[3][1] = M31;
    m->matrix[3][2] = M32;
    m->matrix[3][3] = M33;
}

/************************************************************************/

#define __GLXFORM1_INIT(v)                  \
    __GLfloat x = (v)[0];                   \
    __GLfloat mat00, mat01, mat02, mat03;   \
    __GLfloat mat30, mat31, mat32, mat33;   \
    __GLfloat a0, a1, a2, a3;               \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
    mat03 = m->matrix[0][3];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];                \
    mat33 = m->matrix[3][3];                

#define __GLXFORM1_CONT(v)                  \
    x = (v)[0];

#define __GLXFORM1(res)                     \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
    a2 = x * mat02;                         \
    a3 = x * mat03;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = a1 + mat31;                    \
    res->z = a2 + mat32;                    \
    res->w = a3 + mat33;


#define __GLXFORM1_W_INIT(v)                \
    __GLfloat x = (v)[0];                   \
    __GLfloat mat00, mat01, mat02;          \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1, a2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];

#define __GLXFORM1_W(res)                   \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
    a2 = x * mat02;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = a1 + mat31;                    \
    res->z = a2 + mat32;                    \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM1_2DW_INIT(v)              \
    __GLfloat x = (v)[0];                   \
    __GLfloat mat00, mat01;                 \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1;                       \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
                                            \
    mat32 = m->matrix[3][2];



#define __GLXFORM1_2DW(res)                 \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = a1 + mat31;                    \
    res->z = mat32;                         \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM1_2DNRW_INIT(v)            \
    __GLfloat x = (v)[0];                   \
    __GLfloat mat00, mat01;                 \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0;                           \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
                                            \
    mat32 = m->matrix[3][2];


#define __GLXFORM1_2DNRW(res)               \
    a0 = x * mat00;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = mat31;                         \
    res->z = mat32;                         \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM2_INIT(v)                  \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat mat00, mat01, mat02, mat03;   \
    __GLfloat mat10, mat11, mat12, mat13;   \
    __GLfloat mat30, mat31, mat32, mat33;   \
    __GLfloat a0, a1, a2, a3;               \
    __GLfloat b0, b1, b2, b3;               \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
    mat03 = m->matrix[0][3];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
    mat13 = m->matrix[1][3];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];                \
    mat33 = m->matrix[3][3];

#define __GLXFORM2_CONT(v)                  \
    x = (v)[0];                             \
    y = (v)[1];


#define __GLXFORM2(res)                     \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
    a2 = x * mat02;                         \
    a3 = x * mat03;                         \
                                            \
    b0 = y * mat10;                         \
    b1 = y * mat11;                         \
    b2 = y * mat12;                         \
    b3 = y * mat13;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
    a2 += mat32;                            \
    a3 += mat33;                            \
                                            \
    res->x = a0 + b0;                       \
    res->y = a1 + b1;                       \
    res->z = a2 + b2;                       \
    res->w = a3 + b3;


#define __GLXFORM2_W_INIT(v)                \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat mat00, mat01, mat02;          \
    __GLfloat mat10, mat11, mat12;          \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1, a2;                   \
    __GLfloat b0, b1, b2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];


#define __GLXFORM2_W(res)                   \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
    a2 = x * mat02;                         \
                                            \
    b0 = y * mat10;                         \
    b1 = y * mat11;                         \
    b2 = y * mat12;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
    a2 += mat32;                            \
                                            \
    res->x = a0 + b0;                       \
    res->y = a1 + b1;                       \
    res->z = a2 + b2;                       \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM2_2DW_INIT(v)              \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat mat00, mat01;                 \
    __GLfloat mat10, mat11;                 \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1;                       \
    __GLfloat b0, b1;                       \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];


#define __GLXFORM2_2DW(res)                 \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
                                            \
    b0 = y * mat10;                         \
    b1 = y * mat11;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
                                            \
    res->x = a0 + b0;                       \
    res->y = a1 + b1;                       \
    res->z = mat32;                         \
    res->w = ((__GLfloat) 1.0);



#define __GLXFORM2_2DNRW_INIT(v)            \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat mat00;                        \
    __GLfloat mat11;                        \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, b0;                       \
                                            \
    mat00 = m->matrix[0][0];                \
                                            \
    mat11 = m->matrix[1][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];


#define __GLXFORM2_2DNRW(res)               \
    a0 = x * mat00;                         \
                                            \
    b0 = y * mat11;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = b0 + mat31;                    \
    res->z = mat32;                         \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM3_INIT(v)                  \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat mat00, mat01, mat02, mat03;   \
    __GLfloat mat10, mat11, mat12, mat13;   \
    __GLfloat mat20, mat21, mat22, mat23;   \
    __GLfloat mat30, mat31, mat32, mat33;   \
    __GLfloat a0, a1, a2, a3;               \
    __GLfloat b0, b1, b2, b3;               \
    __GLfloat c0, c1, c2, c3;               \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
    mat03 = m->matrix[0][3];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
    mat13 = m->matrix[1][3];                \
                                            \
    mat20 = m->matrix[2][0];                \
    mat21 = m->matrix[2][1];                \
    mat22 = m->matrix[2][2];                \
    mat23 = m->matrix[2][3];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];                \
    mat33 = m->matrix[3][3];

#define __GLXFORM3_CONT(v)                  \
    x = (v)[0];                             \
    y = (v)[1];                             \
    z = (v)[2];

#define __GLXFORM3(res)                     \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    a2 = mat02 * x;                         \
    a3 = mat03 * x;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
    b2 = mat12 * y;                         \
    b3 = mat13 * y;                         \
                                            \
    c0 = mat20 * z;                         \
    c1 = mat21 * z;                         \
    c2 = mat22 * z;                         \
    c3 = mat23 * z;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
    a2 += mat32;                            \
    a3 += mat33;                            \
                                            \
    a0 += b0;                               \
    a1 += b1;                               \
    a2 += b2;                               \
    a3 += b3;                               \
                                            \
    res->x = a0 + c0;                       \
    res->y = a1 + c1;                       \
    res->z = a2 + c2;                       \
    res->w = a3 + c3;


#define __GLXFORM3_W_INIT(v)                \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat mat00, mat01, mat02;          \
    __GLfloat mat10, mat11, mat12;          \
    __GLfloat mat20, mat21, mat22;          \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1, a2;                   \
    __GLfloat b0, b1, b2;                   \
    __GLfloat c0, c1, c2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
                                            \
    mat20 = m->matrix[2][0];                \
    mat21 = m->matrix[2][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];

#define __GLXFORM3x3_INIT(v)                \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat mat00, mat01, mat02;          \
    __GLfloat mat10, mat11, mat12;          \
    __GLfloat mat20, mat21, mat22;          \
    __GLfloat a0, a1, a2;                   \
    __GLfloat b0, b1, b2;                   \
    __GLfloat c0, c1, c2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
                                            \
    mat20 = m->matrix[2][0];                \
    mat21 = m->matrix[2][1];                \
    mat22 = m->matrix[2][2];                \
                                            \

#define __GLXFORM3x3(res)                   \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    a2 = mat02 * x;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
    b2 = mat12 * y;                         \
                                            \
    c0 = mat20 * z;                         \
    c1 = mat21 * z;                         \
    c2 = mat22 * z;                         \
                                            \
    a0 += b0;                               \
    a1 += b1;                               \
    a2 += b2;                               \
                                            \
    res->x = a0 + c0;                       \
    res->y = a1 + c1;                       \
    res->z = a2 + c2;                       

#define __GLXFORM3_W(res)                   \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    a2 = mat02 * x;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
    b2 = mat12 * y;                         \
                                            \
    c0 = mat20 * z;                         \
    c1 = mat21 * z;                         \
    c2 = mat22 * z;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
    a2 += mat32;                            \
                                            \
    a0 += b0;                               \
    a1 += b1;                               \
    a2 += b2;                               \
                                            \
    res->x = a0 + c0;                       \
    res->y = a1 + c1;                       \
    res->z = a2 + c2;                       \
    res->w = ((__GLfloat) 1.0);

#define __GLXFORM3_2DW_INIT(v)              \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat mat00, mat01;                 \
    __GLfloat mat10, mat11;                 \
    __GLfloat mat22;                        \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1;                       \
    __GLfloat b0, b1;                       \
    __GLfloat c0;                           \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];

#define __GLXFORM3_2DW(res)                 \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
                                            \
    c0 = mat22 * z;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
                                            \
    res->x = a0 + b0;                       \
    res->y = a1 + b1;                       \
    res->z = c0 + mat32;                    \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM3_2DNRW_INIT(v)            \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat mat00, mat11, mat22;          \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0;                           \
    __GLfloat b0;                           \
    __GLfloat c0;                           \
                                            \
    mat00 = m->matrix[0][0];                \
    mat11 = m->matrix[1][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];

#define __GLXFORM3_2DNRW(res)               \
    a0 = mat00 * x;                         \
    b0 = mat11 * y;                         \
    c0 = mat22 * z;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = b0 + mat31;                    \
    res->z = c0 + mat32;                    \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM4_INIT(v)                  \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat w = (v)[3];                   \
                                            \
    __GLfloat mat00, mat01, mat02, mat03;   \
    __GLfloat mat10, mat11, mat12, mat13;   \
    __GLfloat mat20, mat21, mat22, mat23;   \
    __GLfloat mat30, mat31, mat32, mat33;   \
    __GLfloat a0, a1, a2, a3;               \
    __GLfloat b0, b1, b2, b3;               \
    __GLfloat c0, c1, c2, c3;               \
    __GLfloat d0, d1, d2, d3;               \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
    mat03 = m->matrix[0][3];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
    mat13 = m->matrix[1][3];                \
                                            \
    mat20 = m->matrix[2][0];                \
    mat21 = m->matrix[2][1];                \
    mat22 = m->matrix[2][2];                \
    mat23 = m->matrix[2][3];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];                \
    mat33 = m->matrix[3][3];

#define __GLXFORM4_CONT(v)                  \
    x = (v)[0];                             \
    y = (v)[1];                             \
    z = (v)[2];                             \
    w = (v)[3];


#define __GLXFORM4(res)                     \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    a2 = mat02 * x;                         \
    a3 = mat03 * x;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
    b2 = mat12 * y;                         \
    b3 = mat13 * y;                         \
                                            \
    c0 = mat20 * z;                         \
    c1 = mat21 * z;                         \
    c2 = mat22 * z;                         \
    c3 = mat23 * z;                         \
                                            \
    d0 = mat30 * w;                         \
    d1 = mat31 * w;                         \
    d2 = mat32 * w;                         \
    d3 = mat33 * w;                         \
                                            \
    a0 += b0;                               \
    a1 += b1;                               \
    a2 += b2;                               \
    a3 += b3;                               \
                                            \
    a0 += c0;                               \
    a1 += c1;                               \
    a2 += c2;	                            \
    a3 += c3;                               \
                                            \
    res->x = a0 + d0;                       \
    res->y = a1 + d1;                       \
    res->z = a2 + d2;                       \
    res->w = a3 + d3;

#define __GLXFORM4_W_INIT(v)                \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat w = (v)[3];                   \
    __GLfloat mat00, mat01, mat02;          \
    __GLfloat mat10, mat11, mat12;          \
    __GLfloat mat20, mat21, mat22;          \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1, a2;                   \
    __GLfloat b0, b1, b2;                   \
    __GLfloat c0, c1, c2;                   \
    __GLfloat d0, d1, d2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
                                            \
    mat20 = m->matrix[2][0];                \
    mat21 = m->matrix[2][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];


#define __GLXFORM4_W(res)                   \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    a2 = mat02 * x;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
    b2 = mat12 * y;                         \
                                            \
    c0 = mat20 * z;                         \
    c1 = mat21 * z;                         \
    c2 = mat22 * z;                         \
                                            \
    d0 = mat30 * w;                         \
    d1 = mat31 * w;                         \
    d2 = mat32 * w;                         \
                                            \
    a0 += b0;                               \
    a1 += b1;                               \
    a2 += b2;                               \
                                            \
    a0 += c0;                               \
    a1 += c1;                               \
    a2 += c2;                               \
                                            \
    res->x = a0 + d0;                       \
    res->y = a1 + d1;                       \
    res->z = a2 + d2;                       \
    res->w = w;

#define __GLXFORM4_2DW_INIT(v)              \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat w = (v)[3];                   \
    __GLfloat mat00, mat01;                 \
    __GLfloat mat10, mat11;                 \
    __GLfloat mat22;                        \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1;                       \
    __GLfloat b0, b1;                       \
    __GLfloat c0;                           \
    __GLfloat d0;                           \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];


#define __GLXFORM4_2DW(res)                 \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    c0 = mat22 * z;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
                                            \
    d0 = mat32 * w;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
                                            \
    res->x = a0 + b0;                       \
	res->y = a1 + b1;                       \
    res->z = c0 + d0;                       \
    res->w = w;

#define __GLXFORM4_2DNRW_INIT(v)            \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat w = (v)[3];                   \
    __GLfloat mat00;                        \
    __GLfloat mat11;                        \
    __GLfloat mat22;                        \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0;                           \
    __GLfloat b0;                           \
    __GLfloat c0;                           \
    __GLfloat d0, d1, d2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat11 = m->matrix[1][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];

#define __GLXFORM4_2DNRW(res)               \
    a0 = mat00 * x;                         \
    b0 = mat11 * y;                         \
    c0 = mat22 * z;                         \
                                            \
    d0 = mat30 * w;                         \
    d1 = mat31 * w;                         \
    d2 = mat32 * w;                         \
                                            \
    res->x = a0 + d0;                       \
    res->y = b0 + d1;                       \
    res->z = c0 + d2;                       \
    res->w = w;

#define __GLXFORM_NORMAL_BATCH(funcName, initFunc, workFunc, continueFunc)  \
void FASTCALL funcName(POLYARRAY *pa, const __GLmatrix *m)                  \
{                                                                           \
    POLYDATA *pd = pa->pd0;                                                 \
    POLYDATA *pdLast = pa->pdNextVertex;                                    \
                                                                            \
    for (;pd < pdLast; pd++) {                                              \
        if (pd->flags & POLYDATA_NORMAL_VALID)                              \
        {                                                                   \
            __GLcoord *res = &pd->normal;                                   \
            initFunc((__GLfloat *)res);                                     \
            workFunc(res);                                                  \
            continueFunc((__GLfloat *)res);                                 \
        }                                                                   \
    }                                                                       \
}

#define __GLXFORM_NORMAL_BATCHN(funcName, initFunc, workFunc, continueFunc) \
void FASTCALL funcName(POLYARRAY *pa,  const __GLmatrix *m)                 \
{                                                                           \
    POLYDATA *pd = pa->pd0;                                                 \
    POLYDATA *pdLast = pa->pdNextVertex;                                    \
                                                                            \
    for (;pd < pdLast; pd++) {                                              \
        if (pd->flags & POLYDATA_NORMAL_VALID)                              \
        {                                                                   \
            __GLcoord *res = &pd->normal;                                   \
            initFunc((__GLfloat *)res);                                     \
            workFunc(res);                                                  \
            continueFunc((__GLfloat *)res);                                 \
            __glNormalize((__GLfloat *)res, (__GLfloat *)res);              \
        }                                                                   \
    }                                                                       \
}

#define __GLXFORM_BATCH(funcName, initFunc, workFunc, continueFunc)         \
void FASTCALL funcName(__GLcoord *res, __GLcoord *end, const __GLmatrix *m) \
{                                                                           \
    initFunc((__GLfloat *)res);                                             \
                                                                            \
    for (;;) {                                                              \
        workFunc(res);                                                      \
        (char *)res += sizeof(POLYDATA);                                    \
        if (res > end)                                                      \
            break;                                                          \
        continueFunc((__GLfloat *)res);                                     \
    }                                                                       \
}

/*
** Note: These xform routines must allow for the case where the result
** vector is equal to the source vector.
*/

#ifndef __GL_ASM_XFORM1
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has y=0, z=0 and w=1.
*/
void FASTCALL __glXForm1(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m)
{
    __GLXFORM1_INIT(v)

    __GLXFORM1(res);
}
#endif /* !__GL_ASM_XFORM1 */

#ifndef __GL_ASM_XFORM1BATCH
__GLXFORM_BATCH(__glXForm1Batch, __GLXFORM1_INIT, __GLXFORM1, __GLXFORM1_CONT);
#endif /* !__GL_ASM_XFORM1BATCH */

#ifndef __GL_ASM_XFORM2
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has z=0 and w=1
*/
void FASTCALL __glXForm2(__GLcoord *res, const __GLfloat v[2], const __GLmatrix *m)
{
    __GLXFORM2_INIT(v)

    __GLXFORM2(res);
}
#endif /* !__GL_ASM_XFORM2 */

#ifndef __GL_ASM_XFORM2BATCH
__GLXFORM_BATCH (__glXForm2Batch, __GLXFORM2_INIT, __GLXFORM2, __GLXFORM2_CONT);
#endif /* !__GL_ASM_XFORM2BATCH */

#ifndef __GL_ASM_XFORM3
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has w=1.
*/
void FASTCALL __glXForm3(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m)
{
    __GLXFORM3_INIT(v)

    __GLXFORM3(res);
}
#endif /* !__GL_ASM_XFORM3 */

#ifndef __GL_ASM_XFORM3BATCH
__GLXFORM_BATCH (__glXForm3Batch, __GLXFORM3_INIT, __GLXFORM3, __GLXFORM3_CONT);
#endif /* !__GL_ASM_XFORM3BATCH */

#ifndef __GL_ASM_XFORM4
/*
** Full 4x4 transformation.
*/
void FASTCALL __glXForm4(__GLcoord *res, const __GLfloat v[4], const __GLmatrix *m)
{
    __GLXFORM4_INIT(v)

    __GLXFORM4(res);
}
#endif /* !__GL_ASM_XFORM4 */

#ifndef __GL_ASM_XFORM4BATCH
__GLXFORM_BATCH (__glXForm4Batch, __GLXFORM4_INIT, __GLXFORM4, __GLXFORM4_CONT);
#endif /* !__GL_ASM_XFORM4BATCH */

/************************************************************************/

#ifndef __GL_ASM_XFORM1_W
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has y=0, z=0 and w=1.  The w column of the matrix is [0 0 0 1].
*/
void FASTCALL __glXForm1_W(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m)
{
    __GLXFORM1_W_INIT(v)

    __GLXFORM1_W(res);
}
#endif /* !__GL_ASM_XFORM1_W */

#ifndef __GL_ASM_XFORM1_WBATCH
__GLXFORM_BATCH (__glXForm1_WBatch, __GLXFORM1_W_INIT, __GLXFORM1_W, __GLXFORM1_CONT);
#endif /* !__GL_ASM_XFORM1_WBATCH */

#ifndef __GL_ASM_XFORM2_W
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has z=0 and w=1.  The w column of the matrix is [0 0 0 1].
*/
void FASTCALL __glXForm2_W(__GLcoord *res, const __GLfloat v[2], const __GLmatrix *m)
{
    __GLXFORM2_W_INIT(v)

    __GLXFORM2_W(res);
}
#endif /* !__GL_ASM_XFORM2_W */

#ifndef __GL_ASM_XFORM2_WBATCH
__GLXFORM_BATCH (__glXForm2_WBatch, __GLXFORM2_W_INIT, __GLXFORM2_W, __GLXFORM2_CONT);
#endif /* !__GL_ASM_XFORM2_WBATCH */

#ifndef __GL_ASM_XFORM3_W
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has w=1.  The w column of the matrix is [0 0 0 1].
*/
void FASTCALL __glXForm3_W(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m)
{
    __GLXFORM3_W_INIT(v)

    __GLXFORM3_W(res);
}
#endif /* !__GL_ASM_XFORM3_W */

#ifndef __GL_ASM_XFORM3_WBATCH
__GLXFORM_BATCH (__glXForm3_WBatch, __GLXFORM3_W_INIT, __GLXFORM3_W, __GLXFORM3_CONT);
#endif /* !__GL_ASM_XFORM3_WBATCH */

#ifndef __GL_ASM_XFORM3x3
/*
** Avoid some transformation computations by knowing that the incoming
** vertex is a normal.  This is allowed according to the OpenGL spec.
*/
void FASTCALL __glXForm3x3(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m)
{
    __GLXFORM3x3_INIT(v);

    __GLXFORM3x3(res);
}
#endif /* !__GL_ASM_XFORM3x3 */

#ifndef __GL_ASM_XFORM3x3BATCH
__GLXFORM_BATCH (__glXForm3x3Batch, __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);
#endif /* !__GL_ASM_XFORM3x3BATCH */

#ifndef __GL_ASM_XFORM4_W
/*
** Full 4x4 transformation.  The w column of the matrix is [0 0 0 1].
*/
void FASTCALL __glXForm4_W(__GLcoord *res, const __GLfloat v[4], const __GLmatrix *m)
{
    __GLXFORM4_W_INIT(v)

    __GLXFORM4_W(res);
}
#endif /* !__GL_ASM_XFORM4_W */

#ifndef __GL_ASM_XFORM4_WBATCH
__GLXFORM_BATCH (__glXForm4_WBatch, __GLXFORM4_W_INIT, __GLXFORM4_W, __GLXFORM4_CONT);
#endif /* !__GL_ASM_XFORM4_WBATCH */

#ifndef __GL_ASM_XFORM1_2DW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has y=0, z=0 and w=1.
**
** The matrix looks like:
** | . . 0 0 |
** | . . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm1_2DW(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m)
{
    __GLXFORM1_2DW_INIT(v)

    __GLXFORM1_2DW(res);
}
#endif /* !__GL_ASM_XFORM1_2DW */

#ifndef __GL_ASM_XFORM1_2DWBATCH
__GLXFORM_BATCH (__glXForm1_2DWBatch, __GLXFORM1_2DW_INIT, __GLXFORM1_2DW, __GLXFORM1_CONT);
#endif /* !__GL_ASM_XFORM1_2DWBATCH */

#ifndef __GL_ASM_XFORM2_2DW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has z=0 and w=1.
**
** The matrix looks like:
** | . . 0 0 |
** | . . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm2_2DW(__GLcoord *res, const __GLfloat v[2],
		    const __GLmatrix *m)
{
    __GLXFORM2_2DW_INIT(v)

    __GLXFORM2_2DW(res);
}
#endif /* !__GL_ASM_XFORM2_2DW */

#ifndef __GL_ASM_XFORM2_2DWBATCH
__GLXFORM_BATCH (__glXForm2_2DWBatch, __GLXFORM2_2DW_INIT, __GLXFORM2_2DW, __GLXFORM2_CONT);
#endif /* !__GL_ASM_XFORM2_2DWBATCH */

#ifndef __GL_ASM_XFORM3_2DW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has w=1.
**
** The matrix looks like:
** | . . 0 0 |
** | . . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm3_2DW(__GLcoord *res, const __GLfloat v[3],
		    const __GLmatrix *m)
{
    __GLXFORM3_2DW_INIT(v)

    __GLXFORM3_2DW(res);
}
#endif /* !__GL_ASM_XFORM3_2DW */

#ifndef __GL_ASM_XFORM3_2DWBATCH
__GLXFORM_BATCH (__glXForm3_2DWBatch, __GLXFORM3_2DW_INIT, __GLXFORM3_2DW, __GLXFORM3_CONT);
#endif /* !__GL_ASM_XFORM3_2DWBATCH */

#ifndef __GL_ASM_XFORM4_2DW
/*
** Full 4x4 transformation.
**
** The matrix looks like:
** | . . 0 0 |
** | . . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm4_2DW(__GLcoord *res, const __GLfloat v[4],
		    const __GLmatrix *m)
{
    __GLXFORM4_2DW_INIT(v)

    __GLXFORM4_2DW(res);
}
#endif /* !__GL_ASM_XFORM4_2DW */

#ifndef __GL_ASM_XFORM4_2DWBATCH
__GLXFORM_BATCH (__glXForm4_2DWBatch, __GLXFORM4_2DW_INIT, __GLXFORM4_2DW, __GLXFORM4_CONT);
#endif /* !__GL_ASM_XFORM4_2DWBATCH */

#ifndef __GL_ASM_XFORM1_2DNRW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has y=0, z=0 and w=1.
**
** The matrix looks like:
** | . 0 0 0 |
** | 0 . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm1_2DNRW(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m)
{
    __GLXFORM1_2DNRW_INIT(v)

    __GLXFORM1_2DNRW(res);
}
#endif /* !__GL_ASM_XFORM1_2DNRW */

#ifndef __GL_ASM_XFORM1_2DNRWBATCH
__GLXFORM_BATCH (__glXForm1_2DNRWBatch, __GLXFORM1_2DNRW_INIT, __GLXFORM1_2DNRW, __GLXFORM1_CONT);
#endif /* !__GL_ASM_XFORM1_2DNRWBATCH */

#ifndef __GL_ASM_XFORM2_2DNRW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has z=0 and w=1.
**
** The matrix looks like:
** | . 0 0 0 |
** | 0 . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm2_2DNRW(__GLcoord *res, const __GLfloat v[2],
		      const __GLmatrix *m)
{
    __GLXFORM2_2DNRW_INIT(v)

    __GLXFORM2_2DNRW(res);
}
#endif /* !__GL_ASM_XFORM2_2DNRW */

#ifndef __GL_ASM_XFORM2_2DNRWBATCH
__GLXFORM_BATCH (__glXForm2_2DNRWBatch, __GLXFORM2_2DNRW_INIT, __GLXFORM2_2DNRW, __GLXFORM2_CONT);
#endif /* !__GL_ASM_XFORM2_2DNRWBATCH */

#ifndef __GL_ASM_XFORM3_2DNRW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has w=1.
**
** The matrix looks like:
** | . 0 0 0 |
** | 0 . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm3_2DNRW(__GLcoord *res, const __GLfloat v[3],
		      const __GLmatrix *m)
{
    __GLXFORM3_2DNRW_INIT(v)

    __GLXFORM3_2DNRW(res);
}
#endif /* !__GL_ASM_XFORM3_2DNRW */

#ifndef __GL_ASM_XFORM3_2DNRWBATCH
__GLXFORM_BATCH (__glXForm3_2DNRWBatch, __GLXFORM3_2DNRW_INIT, __GLXFORM3_2DNRW, __GLXFORM3_CONT);
#endif /* !__GL_ASM_XFORM3_2DNRWBATCH */

#ifndef __GL_ASM_XFORM4_2DNRW
/*
** Full 4x4 transformation.
**
** The matrix looks like:
** | . 0 0 0 |
** | 0 . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm4_2DNRW(__GLcoord *res, const __GLfloat v[4],
		      const __GLmatrix *m)
{
    __GLXFORM4_2DNRW_INIT(v)

    __GLXFORM4_2DNRW(res);
}
#endif /* !__GL_ASM_XFORM4_2DNRW */

#ifndef __GL_ASM_XFORM4_2DNRWBATCH
__GLXFORM_BATCH (__glXForm4_2DNRWBatch, __GLXFORM4_2DNRW_INIT, __GLXFORM4_2DNRW, __GLXFORM4_CONT);
#endif /* !__GL_ASM_XFORM4_2DNRWBATCH */

#ifndef __GL_ASM_NORMAL_BATCH

__GLXFORM_NORMAL_BATCH (__glXForm3_2DNRWBatchNormal,  __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);
__GLXFORM_NORMAL_BATCHN(__glXForm3_2DNRWBatchNormalN, __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);

__GLXFORM_NORMAL_BATCH (__glXForm3_2DWBatchNormal,  __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);
__GLXFORM_NORMAL_BATCHN(__glXForm3_2DWBatchNormalN, __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);

__GLXFORM_NORMAL_BATCH (__glXForm3x3BatchNormal,  __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);
__GLXFORM_NORMAL_BATCHN(__glXForm3x3BatchNormalN, __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);

#endif //  __GL_ASM_NORMAL_BATCH

/************************************************************************/
/*
** A special picker for the mvp matrix which picks the mvp matrix, then
** calls the vertex picker, because the vertex picker depends upon the mvp 
** matrix.
*/
void FASTCALL __glGenericPickMvpMatrixProcs(__GLcontext *gc, __GLmatrix *m)
{
    __glGenericPickMatrixProcs(gc, m);
    (*gc->procs.pickVertexProcs)(gc);
}

void FASTCALL __glGenericPickMatrixProcs(__GLcontext *gc, __GLmatrix *m)
{
    switch(m->matrixType) 
    {
    case __GL_MT_GENERAL:
        m->xf1 = __glXForm1;
        m->xf2 = __glXForm2;
        m->xf3 = __glXForm3;
        m->xf4 = __glXForm4;
        m->xfNorm = __glXForm3x3;
        m->xf1Batch = __glXForm1Batch;
        m->xf2Batch = __glXForm2Batch;
        m->xf3Batch = __glXForm3Batch;
        m->xf4Batch = __glXForm4Batch;
        m->xfNormBatch = __glXForm3x3BatchNormal;
        m->xfNormBatchN = __glXForm3x3BatchNormalN;
        break;
    case __GL_MT_W0001:
        m->xf1 = __glXForm1_W;
        m->xf2 = __glXForm2_W;
        m->xf3 = __glXForm3_W;
        m->xf4 = __glXForm4_W;
        m->xfNorm = __glXForm3x3;
        m->xf1Batch = __glXForm1_WBatch;
        m->xf2Batch = __glXForm2_WBatch;
        m->xf3Batch = __glXForm3_WBatch;
        m->xf4Batch = __glXForm4_WBatch;
        m->xfNormBatch = __glXForm3x3BatchNormal;
        m->xfNormBatchN = __glXForm3x3BatchNormalN;
        break;
    case __GL_MT_IS2D:
        m->xf1 = __glXForm1_2DW;
        m->xf2 = __glXForm2_2DW;
        m->xf3 = __glXForm3_2DW;
        m->xf4 = __glXForm4_2DW;
        m->xfNorm = __glXForm3_2DW;
        m->xf1Batch = __glXForm1_2DWBatch;
        m->xf2Batch = __glXForm2_2DWBatch;
        m->xf3Batch = __glXForm3_2DWBatch;
        m->xf4Batch = __glXForm4_2DWBatch;
        m->xfNormBatch = __glXForm3_2DWBatchNormal;
        m->xfNormBatchN = __glXForm3_2DWBatchNormalN;
        break;
    case __GL_MT_IS2DNR:
    case __GL_MT_IDENTITY:	/* probably never hit */
        // Update __glGenericPickIdentityMatrixProcs if we change __GL_MT_IDENTITY
        // procs!
        m->xf1 = __glXForm1_2DNRW;
        m->xf2 = __glXForm2_2DNRW;
        m->xf3 = __glXForm3_2DNRW;
        m->xf4 = __glXForm4_2DNRW;
        m->xfNorm = __glXForm3_2DNRW;
        m->xf1Batch = __glXForm1_2DNRWBatch;
        m->xf2Batch = __glXForm2_2DNRWBatch;
        m->xf3Batch = __glXForm3_2DNRWBatch;
        m->xf4Batch = __glXForm4_2DNRWBatch;
        m->xfNormBatch = __glXForm3_2DNRWBatchNormal;
        m->xfNormBatchN = __glXForm3_2DNRWBatchNormalN;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\wgl\glsrvgs.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#include "precomp.h"
#pragma hdrstop

#define const           // Don't bother with const

#include <imfuncs.h>
#include "glsbmsg.h"
#include "glsbmsgh.h"

VOID * FASTCALL
sbs_glAddSwapHintRectWIN ( __GLcontext *gc, IN GLMSG_ADDSWAPHINTRECTWIN *pMsg )
{
    __glim_AddSwapHintRectWIN(
        pMsg->xs, pMsg->ys, pMsg->xe, pMsg->ye);

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDrawPolyArray ( __GLcontext *gc, IN GLMSG_DRAWPOLYARRAY *pMsg )
{
    __glim_DrawPolyArray( pMsg->pa0 );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColor4fv ( __GLcontext *gc, IN GLMSG_COLOR4FV *pMsg )
{
    __glim_Color4fv( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glEdgeFlag ( __GLcontext *gc, IN GLMSG_EDGEFLAG *pMsg )
{
    __glim_EdgeFlag( pMsg->flag );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIndexf ( __GLcontext *gc, IN GLMSG_INDEXF *pMsg )
{
    __glim_Indexf( pMsg->c );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glNormal3fv ( __GLcontext *gc, IN GLMSG_NORMAL3FV *pMsg )
{
    __glim_Normal3fv( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glRasterPos4fv ( __GLcontext *gc, IN GLMSG_RASTERPOS4FV *pMsg )
{
    __glim_RasterPos4fv( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexCoord4fv ( __GLcontext *gc, IN GLMSG_TEXCOORD4FV *pMsg )
{
    __glim_TexCoord4fv( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClipPlane ( __GLcontext *gc, IN GLMSG_CLIPPLANE *pMsg )
{
    __glim_ClipPlane( pMsg->plane, pMsg->equation );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColorMaterial ( __GLcontext *gc, IN GLMSG_COLORMATERIAL *pMsg )
{
    __glim_ColorMaterial( pMsg->face, pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCullFace ( __GLcontext *gc, IN GLMSG_CULLFACE *pMsg )
{
    __glim_CullFace( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glFogfv ( __GLcontext *gc, IN GLMSG_FOGFV *pMsg )
{
    __glim_Fogfv( pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glFrontFace ( __GLcontext *gc, IN GLMSG_FRONTFACE *pMsg )
{
    __glim_FrontFace( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glHint ( __GLcontext *gc, IN GLMSG_HINT *pMsg )
{
    __glim_Hint( pMsg->target, pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLightfv ( __GLcontext *gc, IN GLMSG_LIGHTFV *pMsg )
{
    __glim_Lightfv( pMsg->light, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLightModelfv ( __GLcontext *gc, IN GLMSG_LIGHTMODELFV *pMsg )
{
    __glim_LightModelfv( pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLineStipple ( __GLcontext *gc, IN GLMSG_LINESTIPPLE *pMsg )
{
    __glim_LineStipple( pMsg->factor, pMsg->pattern );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLineWidth ( __GLcontext *gc, IN GLMSG_LINEWIDTH *pMsg )
{
    __glim_LineWidth( pMsg->width );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMaterialfv ( __GLcontext *gc, IN GLMSG_MATERIALFV *pMsg )
{
    __glim_Materialfv( pMsg->face, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPointSize ( __GLcontext *gc, IN GLMSG_POINTSIZE *pMsg )
{
    __glim_PointSize( pMsg->size );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPolygonMode ( __GLcontext *gc, IN GLMSG_POLYGONMODE *pMsg )
{
    __glim_PolygonMode( pMsg->face, pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glScissor ( __GLcontext *gc, IN GLMSG_SCISSOR *pMsg )
{
    __glim_Scissor( pMsg->x, pMsg->y, pMsg->width, pMsg->height );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glShadeModel ( __GLcontext *gc, IN GLMSG_SHADEMODEL *pMsg )
{
    __glim_ShadeModel( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexParameterfv ( __GLcontext *gc, IN GLMSG_TEXPARAMETERFV *pMsg )
{
    __glim_TexParameterfv( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexParameteriv ( __GLcontext *gc, IN GLMSG_TEXPARAMETERIV *pMsg )
{
    __glim_TexParameteriv( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexEnvfv ( __GLcontext *gc, IN GLMSG_TEXENVFV *pMsg )
{
    __glim_TexEnvfv( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexEnviv ( __GLcontext *gc, IN GLMSG_TEXENVIV *pMsg )
{
    __glim_TexEnviv( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexGenfv ( __GLcontext *gc, IN GLMSG_TEXGENFV *pMsg )
{
    __glim_TexGenfv( pMsg->coord, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glInitNames ( __GLcontext *gc, IN GLMSG_INITNAMES *pMsg )
{
    __glim_InitNames( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLoadName ( __GLcontext *gc, IN GLMSG_LOADNAME *pMsg )
{
    __glim_LoadName( pMsg->name );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPassThrough ( __GLcontext *gc, IN GLMSG_PASSTHROUGH *pMsg )
{
    __glim_PassThrough( pMsg->token );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPopName ( __GLcontext *gc, IN GLMSG_POPNAME *pMsg )
{
    __glim_PopName( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPushName ( __GLcontext *gc, IN GLMSG_PUSHNAME *pMsg )
{
    __glim_PushName( pMsg->name );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDrawBuffer ( __GLcontext *gc, IN GLMSG_DRAWBUFFER *pMsg )
{
    __glim_DrawBuffer( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClear ( __GLcontext *gc, IN GLMSG_CLEAR *pMsg )
{
    __glim_Clear( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearAccum ( __GLcontext *gc, IN GLMSG_CLEARACCUM *pMsg )
{
    __glim_ClearAccum( pMsg->red, pMsg->green, pMsg->blue, pMsg->alpha );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearIndex ( __GLcontext *gc, IN GLMSG_CLEARINDEX *pMsg )
{
    __glim_ClearIndex( pMsg->c );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearColor ( __GLcontext *gc, IN GLMSG_CLEARCOLOR *pMsg )
{
    __glim_ClearColor( pMsg->red, pMsg->green, pMsg->blue, pMsg->alpha );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearStencil ( __GLcontext *gc, IN GLMSG_CLEARSTENCIL *pMsg )
{
    __glim_ClearStencil( pMsg->s );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearDepth ( __GLcontext *gc, IN GLMSG_CLEARDEPTH *pMsg )
{
    __glim_ClearDepth( pMsg->depth );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glStencilMask ( __GLcontext *gc, IN GLMSG_STENCILMASK *pMsg )
{
    __glim_StencilMask( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColorMask ( __GLcontext *gc, IN GLMSG_COLORMASK *pMsg )
{
    __glim_ColorMask( pMsg->red, pMsg->green, pMsg->blue, pMsg->alpha );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDepthMask ( __GLcontext *gc, IN GLMSG_DEPTHMASK *pMsg )
{
    __glim_DepthMask( pMsg->flag );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIndexMask ( __GLcontext *gc, IN GLMSG_INDEXMASK *pMsg )
{
    __glim_IndexMask( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glAccum ( __GLcontext *gc, IN GLMSG_ACCUM *pMsg )
{
    __glim_Accum( pMsg->op, pMsg->value );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDisable ( __GLcontext *gc, IN GLMSG_DISABLE *pMsg )
{
    __glim_Disable( pMsg->cap );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glEnable ( __GLcontext *gc, IN GLMSG_ENABLE *pMsg )
{
    __glim_Enable( pMsg->cap );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPopAttrib ( __GLcontext *gc, IN GLMSG_POPATTRIB *pMsg )
{
    __glim_PopAttrib( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPushAttrib ( __GLcontext *gc, IN GLMSG_PUSHATTRIB *pMsg )
{
    __glim_PushAttrib( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glAlphaFunc ( __GLcontext *gc, IN GLMSG_ALPHAFUNC *pMsg )
{
    __glim_AlphaFunc( pMsg->func, pMsg->ref );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glBlendFunc ( __GLcontext *gc, IN GLMSG_BLENDFUNC *pMsg )
{
    __glim_BlendFunc( pMsg->sfactor, pMsg->dfactor );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLogicOp ( __GLcontext *gc, IN GLMSG_LOGICOP *pMsg )
{
    __glim_LogicOp( pMsg->opcode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glStencilFunc ( __GLcontext *gc, IN GLMSG_STENCILFUNC *pMsg )
{
    __glim_StencilFunc( pMsg->func, pMsg->ref, pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glStencilOp ( __GLcontext *gc, IN GLMSG_STENCILOP *pMsg )
{
    __glim_StencilOp( pMsg->fail, pMsg->zfail, pMsg->zpass );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDepthFunc ( __GLcontext *gc, IN GLMSG_DEPTHFUNC *pMsg )
{
    __glim_DepthFunc( pMsg->func );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelZoom ( __GLcontext *gc, IN GLMSG_PIXELZOOM *pMsg )
{
    __glim_PixelZoom( pMsg->xfactor, pMsg->yfactor );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelTransferf ( __GLcontext *gc, IN GLMSG_PIXELTRANSFERF *pMsg )
{
    __glim_PixelTransferf( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelTransferi ( __GLcontext *gc, IN GLMSG_PIXELTRANSFERI *pMsg )
{
    __glim_PixelTransferi( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelStoref ( __GLcontext *gc, IN GLMSG_PIXELSTOREF *pMsg )
{
    __glim_PixelStoref( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelStorei ( __GLcontext *gc, IN GLMSG_PIXELSTOREI *pMsg )
{
    __glim_PixelStorei( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelMapfv ( __GLcontext *gc, IN GLMSG_PIXELMAPFV *pMsg )
{

// VARIABLE_IN

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_PixelMapfv( pMsg->map, pMsg->mapsize, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glPixelMapuiv ( __GLcontext *gc, IN GLMSG_PIXELMAPUIV *pMsg )
{

// VARIABLE_IN

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_PixelMapuiv( pMsg->map, pMsg->mapsize, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glPixelMapusv ( __GLcontext *gc, IN GLMSG_PIXELMAPUSV *pMsg )
{

// VARIABLE_IN

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_PixelMapusv( pMsg->map, pMsg->mapsize, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glReadBuffer ( __GLcontext *gc, IN GLMSG_READBUFFER *pMsg )
{
    __glim_ReadBuffer( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyPixels ( __GLcontext *gc, IN GLMSG_COPYPIXELS *pMsg )
{
#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // This function potentially touches the framebuffer memory.  Since,
    // this function is not going to first pass through the MCD driver
    // (which would give the MCD driver the oportunity to sync to the HW),
    // we need to do this synchronization explicitly.

        GenMcdSynchronize((__GLGENcontext *)gc);
    }
#endif

    __glim_CopyPixels( pMsg->x, pMsg->y, pMsg->width, pMsg->height, pMsg->type );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetBooleanv ( __GLcontext *gc, IN GLMSG_GETBOOLEANV *pMsg )
{
    __glim_GetBooleanv( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetClipPlane ( __GLcontext *gc, IN GLMSG_GETCLIPPLANE *pMsg )
{
    __glim_GetClipPlane( pMsg->plane, pMsg->equation );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetDoublev ( __GLcontext *gc, IN GLMSG_GETDOUBLEV *pMsg )
{
    __glim_GetDoublev( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetError ( __GLcontext *gc, IN GLMSG_GETERROR *pMsg )
{
    GLTEB_RETURNVALUE() =
        (ULONG)__glim_GetError( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetFloatv ( __GLcontext *gc, IN GLMSG_GETFLOATV *pMsg )
{
    __glim_GetFloatv( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetIntegerv ( __GLcontext *gc, IN GLMSG_GETINTEGERV *pMsg )
{
    __glim_GetIntegerv( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetLightfv ( __GLcontext *gc, IN GLMSG_GETLIGHTFV *pMsg )
{
    __glim_GetLightfv( pMsg->light, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetLightiv ( __GLcontext *gc, IN GLMSG_GETLIGHTIV *pMsg )
{
    __glim_GetLightiv( pMsg->light, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetMapdv ( __GLcontext *gc, IN GLMSG_GETMAPDV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->vOff;

    __glim_GetMapdv( pMsg->target, pMsg->query, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetMapfv ( __GLcontext *gc, IN GLMSG_GETMAPFV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->vOff;

    __glim_GetMapfv( pMsg->target, pMsg->query, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetMapiv ( __GLcontext *gc, IN GLMSG_GETMAPIV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->vOff;

    __glim_GetMapiv( pMsg->target, pMsg->query, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetMaterialfv ( __GLcontext *gc, IN GLMSG_GETMATERIALFV *pMsg )
{
    __glim_GetMaterialfv( pMsg->face, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetMaterialiv ( __GLcontext *gc, IN GLMSG_GETMATERIALIV *pMsg )
{
    __glim_GetMaterialiv( pMsg->face, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetPixelMapfv ( __GLcontext *gc, IN GLMSG_GETPIXELMAPFV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_GetPixelMapfv( pMsg->map, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetPixelMapuiv ( __GLcontext *gc, IN GLMSG_GETPIXELMAPUIV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_GetPixelMapuiv( pMsg->map, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetPixelMapusv ( __GLcontext *gc, IN GLMSG_GETPIXELMAPUSV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_GetPixelMapusv( pMsg->map, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetTexEnvfv ( __GLcontext *gc, IN GLMSG_GETTEXENVFV *pMsg )
{
    __glim_GetTexEnvfv( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexEnviv ( __GLcontext *gc, IN GLMSG_GETTEXENVIV *pMsg )
{
    __glim_GetTexEnviv( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexGendv ( __GLcontext *gc, IN GLMSG_GETTEXGENDV *pMsg )
{
    __glim_GetTexGendv( pMsg->coord, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexGenfv ( __GLcontext *gc, IN GLMSG_GETTEXGENFV *pMsg )
{
    __glim_GetTexGenfv( pMsg->coord, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexGeniv ( __GLcontext *gc, IN GLMSG_GETTEXGENIV *pMsg )
{
    __glim_GetTexGeniv( pMsg->coord, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexParameterfv ( __GLcontext *gc, IN GLMSG_GETTEXPARAMETERFV *pMsg )
{
    __glim_GetTexParameterfv( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexParameteriv ( __GLcontext *gc, IN GLMSG_GETTEXPARAMETERIV *pMsg )
{
    __glim_GetTexParameteriv( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexLevelParameterfv ( __GLcontext *gc, IN GLMSG_GETTEXLEVELPARAMETERFV *pMsg )
{
    __glim_GetTexLevelParameterfv( pMsg->target, pMsg->level, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexLevelParameteriv ( __GLcontext *gc, IN GLMSG_GETTEXLEVELPARAMETERIV *pMsg )
{
    __glim_GetTexLevelParameteriv( pMsg->target, pMsg->level, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIsEnabled ( __GLcontext *gc, IN GLMSG_ISENABLED *pMsg )
{
    GLTEB_RETURNVALUE() =
        (ULONG)__glim_IsEnabled( pMsg->cap );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDepthRange ( __GLcontext *gc, IN GLMSG_DEPTHRANGE *pMsg )
{
    __glim_DepthRange( pMsg->zNear, pMsg->zFar );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glFrustum ( __GLcontext *gc, IN GLMSG_FRUSTUM *pMsg )
{
    __glim_Frustum( pMsg->left, pMsg->right, pMsg->bottom, pMsg->top, pMsg->zNear, pMsg->zFar );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLoadIdentity ( __GLcontext *gc, IN GLMSG_LOADIDENTITY *pMsg )
{
    __glim_LoadIdentity( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLoadMatrixf ( __GLcontext *gc, IN GLMSG_LOADMATRIXF *pMsg )
{
    __glim_LoadMatrixf( pMsg->m );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMatrixMode ( __GLcontext *gc, IN GLMSG_MATRIXMODE *pMsg )
{
    __glim_MatrixMode( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMultMatrixf ( __GLcontext *gc, IN GLMSG_MULTMATRIXF *pMsg )
{
    __glim_MultMatrixf( pMsg->m );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glOrtho ( __GLcontext *gc, IN GLMSG_ORTHO *pMsg )
{
    __glim_Ortho( pMsg->left, pMsg->right, pMsg->bottom, pMsg->top, pMsg->zNear, pMsg->zFar );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPopMatrix ( __GLcontext *gc, IN GLMSG_POPMATRIX *pMsg )
{
    __glim_PopMatrix( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPushMatrix ( __GLcontext *gc, IN GLMSG_PUSHMATRIX *pMsg )
{
    __glim_PushMatrix( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glRotatef ( __GLcontext *gc, IN GLMSG_ROTATEF *pMsg )
{
    __glim_Rotatef( pMsg->angle, pMsg->x, pMsg->y, pMsg->z );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glScalef ( __GLcontext *gc, IN GLMSG_SCALEF *pMsg )
{
    __glim_Scalef( pMsg->x, pMsg->y, pMsg->z );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTranslatef ( __GLcontext *gc, IN GLMSG_TRANSLATEF *pMsg )
{
    __glim_Translatef( pMsg->x, pMsg->y, pMsg->z );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glViewport ( __GLcontext *gc, IN GLMSG_VIEWPORT *pMsg )
{
    __glim_Viewport( pMsg->x, pMsg->y, pMsg->width, pMsg->height );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\wgl\glsrvgsh.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include <imfuncs.h>
#include "glsbmsg.h"
#include "glsbmsgh.h"

#include "srvsize.h"

/********************************************************************/


VOID * FASTCALL
sbs_glRenderMode( __GLcontext *gc, IN GLMSG_RENDERMODE *pMsg)
{
    GLint Result;

    /*
     *  Make the call
     *
     *  When exiting Selection mode, RenderMode returns the number of hit
     *  records or -1 if an overflow occured.
     *
     *  When exiting Feedback mode, RenderMode returns the number of values
     *  placed in the feedback buffer or -1 if an overflow occured.
     */

    Result =
        __glim_RenderMode
            ( pMsg->mode );

    GLTEB_RETURNVALUE() = (ULONG)Result;

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}


VOID * FASTCALL
sbs_glFeedbackBuffer( __GLcontext *gc, IN GLMSG_FEEDBACKBUFFER *pMsg )
{
    __GLGENcontext *gengc;
    GLint PreviousError;
    GLfloat *Buffer;
    GLuint SizeInBytes;

    gengc = (__GLGENcontext *)gc;

    /*
     *  Save the current error code so that we can determine
     *  if the call was successful.
     */

    PreviousError = gc->error;
    gc->error     = GL_NO_ERROR;    /* clear the error code */

    /*
     *  Figure out the size of the buffer in bytes
     */

    SizeInBytes = pMsg->size * sizeof(GLfloat);

    /*
     *  Allocate the server side buffer
     *  Use GenMalloc() because it may be used indefinitely.
     */

    if ( NULL == (Buffer = (GLfloat *) pMsg->bufferOff) )
    {
        __glSetError(GL_OUT_OF_MEMORY);
        DBGERROR("GenMalloc failed\n");
    }
    else
    {
        /*
         *  Make the call
         */

        __glim_FeedbackBuffer(
                pMsg->size, pMsg->type, Buffer );

        /*
         *  If the call was successful, save the parameters
         */

        if ( GL_NO_ERROR == gc->error )
        {
            gc->error = PreviousError;      /* Restore the error code */

            gengc->RenderState.SrvFeedbackBuffer  = Buffer;
            gengc->RenderState.CltFeedbackBuffer  = (GLfloat *)pMsg->bufferOff;
            gengc->RenderState.FeedbackBufferSize = SizeInBytes;
            gengc->RenderState.FeedbackType       = pMsg->type;
        }
    }
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glSelectBuffer( __GLcontext *gc, IN GLMSG_SELECTBUFFER *pMsg)
{
    __GLGENcontext *gengc;
    GLint PreviousError;
    GLuint *Buffer;
    GLuint SizeInBytes;

    gengc = (__GLGENcontext *)gc;

    /*
     *  Save the current error code so that we can determine
     *  if the call was successful.
     */

    PreviousError = gc->error;
    gc->error     = GL_NO_ERROR;    /* clear the error code */

    /*
     *  Figure out the size of the buffer in bytes
     */

    SizeInBytes = pMsg->size * sizeof(GLuint);

    /*
     *  Allocate the server side buffer
     *  Use GenMalloc() because it may be used indefinitely.
     */

    if ( NULL == (Buffer = (GLuint *) pMsg->bufferOff) )
    {
        __glSetError(GL_OUT_OF_MEMORY);
        DBGERROR("GenMalloc failed\n");
    }
    else
    {
        /*
         *  Make the call
         */

        __glim_SelectBuffer
                    (pMsg->size, Buffer );

        /*
         *  If the call was successful, save the parameters
         */

        if ( GL_NO_ERROR == gc->error )
        {
            gc->error = PreviousError;      /* Restore the error code */

            gengc->RenderState.SrvSelectBuffer  = Buffer;
            gengc->RenderState.CltSelectBuffer  = (GLuint *)pMsg->bufferOff;
            gengc->RenderState.SelectBufferSize = SizeInBytes;
        }
    }
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

/******************* Pixel Functions ********************************/

VOID * FASTCALL
sbs_glReadPixels ( __GLcontext *gc, IN GLMSG_READPIXELS *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // This function potentially touches the framebuffer memory.  Since,
    // this function is not going to first pass through the MCD driver
    // (which would give the MCD driver the oportunity to sync to the HW),
    // we need to do this synchronization explicitly.

        GenMcdSynchronize((__GLGENcontext *)gc);
    }
#endif

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->pixelsOff;

    __glim_ReadPixels
        (   pMsg->x,
            pMsg->y,
            pMsg->width,
            pMsg->height,
            pMsg->format,
            pMsg->type,
            Data );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetPolygonStipple ( __GLcontext *gc, IN GLMSG_GETPOLYGONSTIPPLE *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->maskOff;

    __glim_GetPolygonStipple
            ( Data );

    return( NextOffset );
}

/*
 *  XXXX From Ptar:
 *
 *      This code is very similar to __glCheckReadPixelArgs() in
 *      pixel/px_api.c, and could possibly replace it.
 */


VOID * FASTCALL
sbs_glGetTexImage ( __GLcontext *gc, IN GLMSG_GETTEXIMAGE *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->pixelsOff;

    __glim_GetTexImage
        (   pMsg->target,
            pMsg->level,
            pMsg->format,
            pMsg->type,
            Data );

    return( NextOffset );
}


VOID * FASTCALL
sbs_glDrawPixels ( __GLcontext *gc, IN GLMSG_DRAWPIXELS *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // This function potentially touches the framebuffer memory.  Since,
    // this function is not going to first pass through the MCD driver
    // (which would give the MCD driver the oportunity to sync to the HW),
    // we need to do this synchronization explicitly.

        GenMcdSynchronize((__GLGENcontext *)gc);
    }
#endif

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->pixelsOff;

    __glim_DrawPixels
        (   pMsg->width,
            pMsg->height,
            pMsg->format,
            pMsg->type,
#ifdef NT
            Data,
	    pMsg->_IsDlist);
#else
            Data );
#endif

    return( NextOffset );
}

VOID * FASTCALL
sbs_glPolygonStipple ( __GLcontext *gc, IN GLMSG_POLYGONSTIPPLE *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->maskOff;

    __glim_PolygonStipple
#ifdef NT
            ( Data, pMsg->_IsDlist );
#else
            ( Data );
#endif

    return( NextOffset );
}

/*
 *  XXXX from Ptar:
 *
 *  The whole bitmap is copied, the server (not the client)
 *  could be modified so that only the data starting at
 *  xorig and yorig is copied, then width and height probably
 *  need to be modified.
 *  Note that __glBitmap_size() will also need to be modified
 *
 */

VOID * FASTCALL
sbs_glBitmap ( __GLcontext *gc, IN GLMSG_BITMAP *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // This function potentially touches the framebuffer memory.  Since,
    // this function is not going to first pass through the MCD driver
    // (which would give the MCD driver the oportunity to sync to the HW),
    // we need to do this synchronization explicitly.

        GenMcdSynchronize((__GLGENcontext *)gc);
    }
#endif

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->bitmapOff;

    __glim_Bitmap
        (
            pMsg->width ,
            pMsg->height,
            pMsg->xorig ,
            pMsg->yorig ,
            pMsg->xmove ,
            pMsg->ymove ,
#ifdef NT
            Data        ,
            pMsg->_IsDlist
#else
            Data
#endif
        );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glTexImage1D ( __GLcontext *gc, IN GLMSG_TEXIMAGE1D *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->pixelsOff;

    __glim_TexImage1D
        (
            pMsg->target        ,
            pMsg->level         ,
            pMsg->components    ,
            pMsg->width         ,
            pMsg->border        ,
            pMsg->format        ,
            pMsg->type          ,
#ifdef NT
            Data                ,
            pMsg->_IsDlist
#else
            Data
#endif
        );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glTexImage2D ( __GLcontext *gc, IN GLMSG_TEXIMAGE2D *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );

    Data = (VOID *) pMsg->pixelsOff;

    __glim_TexImage2D
        (
            pMsg->target        ,
            pMsg->level         ,
            pMsg->components    ,
            pMsg->width         ,
            pMsg->height        ,
            pMsg->border        ,
            pMsg->format        ,
            pMsg->type          ,
#ifdef NT
            Data                ,
            pMsg->_IsDlist
#else
            Data
#endif
        );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glAreTexturesResident( __GLcontext *gc, IN GLMSG_ARETEXTURESRESIDENT    *pMsg)
{
    GLboolean retval;
        
    retval = __glim_AreTexturesResident
        ( pMsg->n, pMsg->textures, pMsg->residences );
    
    GLTEB_RETURNVALUE() = (ULONG)retval;
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glBindTexture( __GLcontext *gc, IN GLMSG_BINDTEXTURE            *pMsg)
{
    __glim_BindTexture
        ( pMsg->target, pMsg->texture );
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyTexImage1D( __GLcontext *gc, IN GLMSG_COPYTEXIMAGE1D         *pMsg)
{
    __glim_CopyTexImage1D
        ( pMsg->target, pMsg->level, pMsg->internalformat, pMsg->x,
          pMsg->y, pMsg->width, pMsg->border);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyTexImage2D( __GLcontext *gc, IN GLMSG_COPYTEXIMAGE2D         *pMsg)
{
    __glim_CopyTexImage2D
        ( pMsg->target, pMsg->level, pMsg->internalformat, pMsg->x,
          pMsg->y, pMsg->width, pMsg->height, pMsg->border);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyTexSubImage1D( __GLcontext *gc, IN GLMSG_COPYTEXSUBIMAGE1D      *pMsg)
{
    __glim_CopyTexSubImage1D
        ( pMsg->target, pMsg->level, pMsg->xoffset, pMsg->x,
          pMsg->y, pMsg->width);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyTexSubImage2D( __GLcontext *gc, IN GLMSG_COPYTEXSUBIMAGE2D      *pMsg)
{
    __glim_CopyTexSubImage2D
        ( pMsg->target, pMsg->level, pMsg->xoffset, pMsg->yoffset, pMsg->x,
          pMsg->y, pMsg->width, pMsg->height);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDeleteTextures( __GLcontext *gc, IN GLMSG_DELETETEXTURES         *pMsg)
{
    __glim_DeleteTextures
        ( pMsg->n, pMsg->textures );
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGenTextures( __GLcontext *gc, IN GLMSG_GENTEXTURES            *pMsg)
{
    __glim_GenTextures
        ( pMsg->n, pMsg->textures );
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIsTexture( __GLcontext *gc, IN GLMSG_ISTEXTURE              *pMsg)
{
    GLboolean retval;
    
    retval = __glim_IsTexture
        ( pMsg->texture );
    
    GLTEB_RETURNVALUE() = (ULONG)retval;
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPrioritizeTextures( __GLcontext *gc, IN GLMSG_PRIORITIZETEXTURES     *pMsg)
{
    __glim_PrioritizeTextures
        ( pMsg->n, pMsg->textures, pMsg->priorities );
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexSubImage1D( __GLcontext *gc, IN GLMSG_TEXSUBIMAGE1D          *pMsg)
{
    __glim_TexSubImage1D
        (pMsg->target, pMsg->level, pMsg->xoffset, pMsg->width,
         pMsg->format, pMsg->type,
#ifdef NT
         (const GLvoid *)pMsg->pixelsOff, pMsg->_IsDlist);
#else
         (const GLvoid *)pMsg->pixelsOff);
#endif
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexSubImage2D( __GLcontext *gc, IN GLMSG_TEXSUBIMAGE2D          *pMsg)
{
    __glim_TexSubImage2D
        (pMsg->target, pMsg->level, pMsg->xoffset, pMsg->yoffset, pMsg->width,
         pMsg->height, pMsg->format, pMsg->type,
#ifdef NT
         (const GLvoid *)pMsg->pixelsOff, pMsg->_IsDlist);
#else
         (const GLvoid *)pMsg->pixelsOff);
#endif
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColorTableEXT( __GLcontext *gc, IN GLMSG_COLORTABLEEXT          *pMsg)
{
    __glim_ColorTableEXT
        (pMsg->target, pMsg->internalFormat, pMsg->width, pMsg->format, pMsg->type,
         pMsg->data, pMsg->_IsDlist);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColorSubTableEXT( __GLcontext *gc, IN GLMSG_COLORSUBTABLEEXT    *pMsg)
{
    __glim_ColorSubTableEXT
        (pMsg->target, pMsg->start, pMsg->count, pMsg->format, pMsg->type,
         pMsg->data, pMsg->_IsDlist);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetColorTableEXT( __GLcontext *gc, IN GLMSG_GETCOLORTABLEEXT          *pMsg)
{
    __glim_GetColorTableEXT
        (pMsg->target, pMsg->format, pMsg->type, pMsg->data);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetColorTableParameterivEXT( __GLcontext *gc, IN GLMSG_GETCOLORTABLEPARAMETERIVEXT          *pMsg)
{
    __glim_GetColorTableParameterivEXT
        (pMsg->target, pMsg->pname, pMsg->params);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetColorTableParameterfvEXT( __GLcontext *gc, IN GLMSG_GETCOLORTABLEPARAMETERFVEXT          *pMsg)
{
    __glim_GetColorTableParameterfvEXT
        (pMsg->target, pMsg->pname, pMsg->params);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPolygonOffset( __GLcontext *gc, IN GLMSG_POLYGONOFFSET          *pMsg)
{
    __glim_PolygonOffset
        (pMsg->factor, pMsg->units);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

#ifdef GL_WIN_multiple_textures
VOID * FASTCALL
sbs_glCurrentTextureIndexWIN( __GLcontext *gc, IN GLMSG_CURRENTTEXTUREINDEXWIN *pMsg)
{
    __glim_CurrentTextureIndexWIN
        (pMsg->index);

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glBindNthTextureWIN( __GLcontext *gc, IN GLMSG_BINDNTHTEXTUREWIN *pMsg)
{
    __glim_BindNthTextureWIN
        (pMsg->index, pMsg->target, pMsg->texture);

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glNthTexCombineFuncWIN( __GLcontext *gc, IN GLMSG_NTHTEXCOMBINEFUNCWIN *pMsg)
{
    __glim_NthTexCombineFuncWIN
        (pMsg->index, pMsg->leftColorFactor, pMsg->colorOp,
         pMsg->rightColorFactor, pMsg->leftAlphaFactor,
         pMsg->alphaOp, pMsg->rightAlphaFactor);

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\wgl\driver.c ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include <ntcsrdll.h>   // CSR declarations and data structures.

// #define DETECT_FPE
#ifdef DETECT_FPE
#include <float.h>
#endif

#include "glsbmsg.h"
#include "glsbmsgh.h"
#include "glsrvspt.h"
#include "devlock.h"
#include "global.h"

#include "glscreen.h"

typedef VOID * (FASTCALL *SERVERPROC)(__GLcontext *, IN VOID *);

#define LASTPROCOFFSET(ProcTable)   (sizeof(ProcTable) - sizeof(SERVERPROC))

extern GLSRVSBPROCTABLE glSrvSbProcTable;
#if DBG
char *glSrvSbStringTable[] = {

    NULL,  /* Make First Entry NULL */

/* gl Entry points */

     "glDrawPolyArray          ",
     "glBitmap                 ",
     "glColor4fv               ",
     "glEdgeFlag               ",
     "glIndexf                 ",
     "glNormal3fv              ",
     "glRasterPos4fv           ",
     "glTexCoord4fv            ",
     "glClipPlane              ",
     "glColorMaterial          ",
     "glCullFace               ",
     "glAddSwapHintRectWIN     ",
     "glFogfv                  ",
     "glFrontFace              ",
     "glHint                   ",
     "glLightfv                ",
     "glLightModelfv           ",
     "glLineStipple            ",
     "glLineWidth              ",
     "glMaterialfv             ",
     "glPointSize              ",
     "glPolygonMode            ",
     "glPolygonStipple         ",
     "glScissor                ",
     "glShadeModel             ",
     "glTexParameterfv         ",
     "glTexParameteriv         ",
     "glTexImage1D             ",
     "glTexImage2D             ",
     "glTexEnvfv               ",
     "glTexEnviv               ",
     "glTexGenfv               ",
     "glFeedbackBuffer         ",
     "glSelectBuffer           ",
     "glRenderMode             ",
     "glInitNames              ",
     "glLoadName               ",
     "glPassThrough            ",
     "glPopName                ",
     "glPushName               ",
     "glDrawBuffer             ",
     "glClear                  ",
     "glClearAccum             ",
     "glClearIndex             ",
     "glClearColor             ",
     "glClearStencil           ",
     "glClearDepth             ",
     "glStencilMask            ",
     "glColorMask              ",
     "glDepthMask              ",
     "glIndexMask              ",
     "glAccum                  ",
     "glDisable                ",
     "glEnable                 ",
     "glPopAttrib              ",
     "glPushAttrib             ",
     "glMap1d                  ",
     "glMap1f                  ",
     "glMap2d                  ",
     "glMap2f                  ",
     "glMapGrid1f              ",
     "glMapGrid2f              ",
     "glAlphaFunc              ",
     "glBlendFunc              ",
     "glLogicOp                ",
     "glStencilFunc            ",
     "glStencilOp              ",
     "glDepthFunc              ",
     "glPixelZoom              ",
     "glPixelTransferf         ",
     "glPixelTransferi         ",
     "glPixelStoref            ",
     "glPixelStorei            ",
     "glPixelMapfv             ",
     "glPixelMapuiv            ",
     "glPixelMapusv            ",
     "glReadBuffer             ",
     "glCopyPixels             ",
     "glReadPixels             ",
     "glDrawPixels             ",
     "glGetBooleanv            ",
     "glGetClipPlane           ",
     "glGetDoublev             ",
     "glGetError               ",
     "glGetFloatv              ",
     "glGetIntegerv            ",
     "glGetLightfv             ",
     "glGetLightiv             ",
     "glGetMapdv               ",
     "glGetMapfv               ",
     "glGetMapiv               ",
     "glGetMaterialfv          ",
     "glGetMaterialiv          ",
     "glGetPixelMapfv          ",
     "glGetPixelMapuiv         ",
     "glGetPixelMapusv         ",
     "glGetPolygonStipple      ",
     "glGetTexEnvfv            ",
     "glGetTexEnviv            ",
     "glGetTexGendv            ",
     "glGetTexGenfv            ",
     "glGetTexGeniv            ",
     "glGetTexImage            ",
     "glGetTexParameterfv      ",
     "glGetTexParameteriv      ",
     "glGetTexLevelParameterfv ",
     "glGetTexLevelParameteriv ",
     "glIsEnabled              ",
     "glDepthRange             ",
     "glFrustum                ",
     "glLoadIdentity           ",
     "glLoadMatrixf            ",
     "glMatrixMode             ",
     "glMultMatrixf            ",
     "glOrtho                  ",
     "glPopMatrix              ",
     "glPushMatrix             ",
     "glRotatef                ",
     "glScalef                 ",
     "glTranslatef             ",
     "glViewport               ",
     "glAreTexturesResident    ",
     "glBindTexture            ",
     "glCopyTexImage1D         ",
     "glCopyTexImage2D         ",
     "glCopyTexSubImage1D      ",
     "glCopyTexSubImage2D      ",
     "glDeleteTextures         ",
     "glGenTextures            ",
     "glIsTexture              ",
     "glPrioritizeTextures     ",
     "glTexSubImage1D          ",
     "glTexSubImage2D          ",
     "glColorTableEXT          ",
     "glColorSubTableEXT       ",
     "glGetColorTableEXT       ",
     "glGetColorTableParameterivEXT",
     "glGetColorTableParameterfvEXT",
     "glPolygonOffset          ",
#ifdef GL_WIN_multiple_textures
     "glCurrentTextureIndexWIN ",
     "glBindNthTextureWIN      ",
     "glNthTexCombineFuncWIN   ",
#endif // GL_WIN_multiple_textures

};
#endif

#ifdef DOGLMSGBATCHSTATS
#define STATS_INC_SERVERCALLS()     pMsgBatchInfo->BatchStats.ServerCalls++
#define STATS_INC_SERVERTRIPS()     (pMsgBatchInfo->BatchStats.ServerTrips++)
#else
#define STATS_INC_SERVERCALLS()
#define STATS_INC_SERVERTRIPS()
#endif

DWORD BATCH_LOCK_TICKMAX = 99;
DWORD TICK_RANGE_LO = 60;
DWORD TICK_RANGE_HI = 100;
DWORD gcmsOpenGLTimer;

// The GDISAVESTATE structure is used to save/restore DC drawing state
// that could affect OpenGL rasterization.

typedef struct _GDISAVESTATE {
    int iRop2;
} GDISAVESTATE;

void FASTCALL vSaveGdiState(HDC, GDISAVESTATE *);
void FASTCALL vRestoreGdiState(HDC, GDISAVESTATE *);

#if DBG
extern long glDebugLevel;
#endif


/***************************************************************************\
* CheckCritSectionIn
*
* This function asserts that the current thread owns the specified
* critical section.  If it doesn't it display some output on the debugging
* terminal and breaks into the debugger.  At some point we'll have RIPs
* and this will be a little less harsh.
*
* The function is used in code where global values that both the RIT and
* application threads access are used to verify they are protected via
* the raw input critical section.  There's a macro to use this function
* called CheckCritIn() which will be defined to nothing for a non-debug
* version of the system.
*
* History:
* 11-29-90 DavidPe      Created.
\***************************************************************************/

#if DBG

VOID APIENTRY CheckCritSectionIn(
    LPCRITICAL_SECTION pcs)
{
    //!!!dbug -- implement
    #if 0
    /*
     * If the current thread doesn't own this critical section,
     * that's bad.
     */
    if (NtCurrentTeb()->ClientId.UniqueThread != pcs->OwningThread)
    {
        RIP("CheckCritSectionIn: Not in critical section!");
    }
    #endif
}


VOID APIENTRY CheckCritSectionOut(
    LPCRITICAL_SECTION pcs)
{
    //!!!dbug -- implement
    #if 0
    /*
     * If the current thread owns this critical section, that's bad.
     */
    if (NtCurrentTeb()->ClientId.UniqueThread == pcs->OwningThread)
    {
        RIP("CheckCritSectionOut: In critical section!");
    }
    #endif
}

#endif

/******************************Public*Routine******************************\
* ResizeAlphaBufs
*
* Resize alpha buffers associated with the drawable.
*
* Returns:
*   No return value.
\**************************************************************************/

static void ResizeAlphaBufs(__GLcontext *gc, __GLGENbuffers *buffers,
                            GLint width, GLint height)
{
    __GLbuffer *common, *local;
    BOOL bSuccess;

    // front alpha buffer

    common = buffers->alphaFrontBuffer;
    // We are using the generic ancillary resize here...
    bSuccess = (*buffers->resize)(buffers, common, width, height);
    if( !bSuccess ) {
        __glSetError(GL_OUT_OF_MEMORY);
        return;
    }
    local = &gc->front->alphaBuf.buf;
    UpdateSharedBuffer( local, common );

    if ( gc->modes.doubleBufferMode) {
        // Handle back alpha buffer
        common = buffers->alphaBackBuffer;
        bSuccess = (*buffers->resize)(buffers, common, width, height);
        if( !bSuccess ) {
            __glSetError(GL_OUT_OF_MEMORY);
            return;
        }
        local = &gc->back->alphaBuf.buf;
        UpdateSharedBuffer( local, common );
    }
}

/******************************Public*Routine******************************\
* ResizeAncillaryBufs
*
* Resize each of the ancillary buffers associated with the drawable.
*
* Returns:
*   No return value.
\**************************************************************************/

static void ResizeAncillaryBufs(__GLcontext *gc, __GLGENbuffers *buffers,
                                GLint width, GLint height)
{
    __GLbuffer *common, *local;
    GLboolean forcePick = GL_FALSE;

    if (buffers->createdAccumBuffer)
    {
        common = &buffers->accumBuffer;
        local = &gc->accumBuffer.buf;
        gc->modes.haveAccumBuffer =
            (*buffers->resize)(buffers, common, width, height);

        UpdateSharedBuffer(local, common);
        if (!gc->modes.haveAccumBuffer)    // Lost the ancillary buffer
        {
            forcePick = GL_TRUE;
            __glSetError(GL_OUT_OF_MEMORY);
        }
    }

    if (buffers->createdDepthBuffer)
    {
        common = &buffers->depthBuffer;
        local = &gc->depthBuffer.buf;
        gc->modes.haveDepthBuffer =
            (*buffers->resizeDepth)(buffers, common, width, height);

        UpdateSharedBuffer(local, common);
        if (!gc->modes.haveDepthBuffer)    // Lost the ancillary buffer
        {
            forcePick = GL_TRUE;
            __glSetError(GL_OUT_OF_MEMORY);
        }
    }

    if (buffers->createdStencilBuffer)
    {
        common = &buffers->stencilBuffer;
        local = &gc->stencilBuffer.buf;
        gc->modes.haveStencilBuffer =
            (*buffers->resize)(buffers, common, width, height);

        UpdateSharedBuffer(local, common);
        if (!gc->modes.haveStencilBuffer)    // Lost the ancillary buffer
        {
            forcePick = GL_TRUE;
            gc->validateMask |= (__GL_VALIDATE_STENCIL_FUNC |
                                 __GL_VALIDATE_STENCIL_OP);
            __glSetError(GL_OUT_OF_MEMORY);
        }
    }
    if (forcePick)
    {
    // Cannot use DELAY_VALIDATE, may be in glBegin/End

        __GL_INVALIDATE(gc);
        (*gc->procs.validate)(gc);
    }
}

/******************************Public*Routine******************************\
* wglResizeBuffers
*
* Resize the back and ancillary buffers.
*
* History:
*  20-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID wglResizeBuffers(__GLGENcontext *gengc, GLint width, GLint height)
{
    __GLcontext *gc = &gengc->gc;
    GLGENwindow *pwnd;
    __GLGENbuffers *buffers;

    pwnd = gengc->pwndLocked;
    ASSERTOPENGL(pwnd, "wglResizeBuffers: bad window\n");

    buffers = pwnd->buffers;
    ASSERTOPENGL(buffers, "wglResizeBuffers: bad buffers\n");

    ASSERT_WINCRIT(pwnd);
    
// Resize back buffer.

    gengc->errorcode = 0;
    if ( gengc->pMcdState )
    {
    // If the shared buffer struct has not lost its MCD info and
    // the MCD buffers are still valid, we can use MCD.

        if ( !(buffers->flags & GLGENBUF_MCD_LOST) &&
             GenMcdResizeBuffers(gengc) )
        {
            UpdateSharedBuffer(&gc->backBuffer.buf, &buffers->backBuffer);
            if (gc->modes.doubleBufferMode)
                (*gc->back->resize)(buffers, gc->back, width, height);
        }
        else
        {
        // If GenMcdConvertContext succeeds, then pMcdState will
        // no longer exist.  The context is now an "ordinary"
        // generic context.

            if ( !GenMcdConvertContext(gengc, buffers) )
            {
            // Not only have we lost the MCD buffers, but we cannot
            // convert the context to generic.  For now, disable
            // drawing (by setting the window bounds to empty).  On
            // the next batch we will reattempt MCD buffer access
            // and context conversion.

                buffers->width       = 0;
                buffers->height      = 0;
                gc->constants.width  = 0;
                gc->constants.height = 0;

                (*gc->procs.applyViewport)(gc);
                return;
            }
            else
            {
                goto wglResizeBuffers_GenericBackBuf;
            }
        }
    }
    else
    {
wglResizeBuffers_GenericBackBuf:

        if ( gc->modes.doubleBufferMode )
        {
        // Have to update the back buffer BEFORE resizing because
        // another thread may have changed the shared back buffer
        // already, but this thread was unlucky enough to get yet
        // ANOTHER window resize.

            UpdateSharedBuffer(&gc->backBuffer.buf, &buffers->backBuffer);

            gengc->errorcode = 0;
            (*gc->back->resize)(buffers, gc->back, width, height);

        // If resize failed, set width & height to 0

            if ( gengc->errorcode )
            {
                gc->constants.width  = 0;
                gc->constants.height = 0;

            // Memory failure has occured.  But if a resize happens
            // that returns window size to size before memory error
            // occurred (i.e., consistent with original
            // buffers->{width|height}) we will not try to resize again.
            // Therefore, we need to set buffers->{width|height} to zero
            // to ensure that next thread will attempt to resize.

                buffers->width  = 0;
                buffers->height = 0;
            }
        }
        if ( gc->modes.alphaBits )
        {
            ResizeAlphaBufs( gc, buffers, width, height );
            if (gengc->errorcode)
                return;
        }

    }

    (*gc->procs.applyViewport)(gc);

// Check if new size caused a memory failure.
// The viewport code will set width & height to zero
// punt on ancillary buffers, will try next time.

    if (gengc->errorcode)
        return;

// Resize ancillary buffers (depth, stencil, accum).

    ResizeAncillaryBufs(gc, buffers, width, height);
}

/******************************Public*Routine******************************\
* wglUpdateBuffers
*
* The __GLGENbuffers structure contains the data specifying the shared
* buffers (back, depth, stencil, accum, etc.).
*
* This function updates the context with the shared buffer information.
*
* Returns:
*   TRUE if one of the existence of any of the buffers changes (i.e.,
*   gained or lost).  FALSE if the state is the same as before.
*
*   In other words, if function returns TRUE, the pick procs need to
*   be rerun because one or more of the buffers changed.
*
* History:
*  20-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL wglUpdateBuffers(__GLGENcontext *gengc, __GLGENbuffers *buffers)
{
    BOOL bRet = FALSE;
    __GLcontext *gc = &gengc->gc;

    UpdateSharedBuffer(&gc->backBuffer.buf, &buffers->backBuffer);
    UpdateSharedBuffer(&gc->accumBuffer.buf, &buffers->accumBuffer);
    UpdateSharedBuffer(&gc->depthBuffer.buf, &buffers->depthBuffer);
    UpdateSharedBuffer(&gc->stencilBuffer.buf, &buffers->stencilBuffer);
    if( gc->modes.alphaBits ) {
        UpdateSharedBuffer(&gc->frontBuffer.alphaBuf.buf, buffers->alphaFrontBuffer);
        if (gc->modes.doubleBufferMode)
            UpdateSharedBuffer(&gc->backBuffer.alphaBuf.buf, buffers->alphaBackBuffer);
    }

    (*gc->procs.applyViewport)(gc);

// Check if any ancillary buffers were lost or regained.

    if ( ( gc->modes.haveAccumBuffer && (buffers->accumBuffer.base == NULL)) ||
         (!gc->modes.haveAccumBuffer && (buffers->accumBuffer.base != NULL)) )
    {
        if ( buffers->accumBuffer.base == NULL )
            gc->modes.haveAccumBuffer = GL_FALSE;
        else
            gc->modes.haveAccumBuffer = GL_TRUE;
        bRet = TRUE;
    }
    if ( ( gc->modes.haveDepthBuffer && (buffers->depthBuffer.base == NULL)) ||
         (!gc->modes.haveDepthBuffer && (buffers->depthBuffer.base != NULL)) )
    {
        if ( buffers->depthBuffer.base == NULL )
            gc->modes.haveDepthBuffer = GL_FALSE;
        else
            gc->modes.haveDepthBuffer = GL_TRUE;
        bRet = TRUE;
    }
    if ( ( gc->modes.haveStencilBuffer && (buffers->stencilBuffer.base == NULL)) ||
         (!gc->modes.haveStencilBuffer && (buffers->stencilBuffer.base != NULL)) )
    {
        if ( buffers->stencilBuffer.base == NULL )
            gc->modes.haveStencilBuffer = GL_FALSE;
        else
            gc->modes.haveStencilBuffer = GL_TRUE;
        gc->validateMask |= (__GL_VALIDATE_STENCIL_FUNC |
                             __GL_VALIDATE_STENCIL_OP);
        bRet = TRUE;
    }

    return bRet;
}

/******************************Public*Routine******************************\
* UpdateWindowInfo
*
*  Update context data if window changed
*     position
*     size
*     palette
*
*  No need to worry about clipping changes.
*
* Returns:
*   No return value.
\**************************************************************************/

void UpdateWindowInfo(__GLGENcontext *gengc)
{
    GLGENwindow *pwnd;
    __GLGENbuffers *buffers;
    __GLcontext *gc = (__GLcontext *)gengc;
    GLint width, height, visWidth, visHeight;
    GLboolean forcePick = GL_FALSE;

    pwnd = gengc->pwndLocked;
    ASSERTOPENGL(pwnd, "UpdateWindowInfo(): bad window\n");
    buffers = pwnd->buffers;
    ASSERTOPENGL(buffers, "UpdateWindowInfo(): bad buffers\n");

    ASSERT_WINCRIT(pwnd);
    
// Memory DC case -- need to check bitmap size.  The DC is not bound to
// a window, so there is no message or visrgn watcher to inform us of size
// changes.

    if ( GLSURF_IS_MEMDC(gengc->dwCurrentFlags) )
    {
        DIBSECTION ds;
        int iRetVal;

        if ( iRetVal =
             GetObject(GetCurrentObject(gengc->gwidCurrent.hdc, OBJ_BITMAP),
                       sizeof(ds), &ds) )
        {
            ASSERTOPENGL(pwnd->rclClient.left == 0 &&
                         pwnd->rclClient.top == 0,
                         "UpdateWindowInfo(): bad rclClient for memDc\n");

        // Bitmap may have changed.  If DIB, force reload of base pointer and
        // outer width (buffer pitch).

            if ( (iRetVal == sizeof(ds)) && ds.dsBm.bmBits )
            {
            // For backwards compatibility with Get/SetBitmapBits, GDI does
            // not accurately report the bitmap pitch in bmWidthBytes.  It
            // always computes bmWidthBytes assuming WORD-aligned scanlines
            // regardless of the platform.
            //
            // Therefore, if the platform is WinNT, which uses DWORD-aligned
            // scanlines, adjust the bmWidthBytes value.

                if ( dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }

            // If biHeight is positive, then the bitmap is a bottom-up DIB.
            // If biHeight is negative, then the bitmap is a top-down DIB.

                if ( ds.dsBmih.biHeight > 0 )
                {
                    gengc->gc.frontBuffer.buf.base = (PVOID) (((ULONG_PTR) ds.dsBm.bmBits) +
                        (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
                    gengc->gc.frontBuffer.buf.outerWidth = -ds.dsBm.bmWidthBytes;
                }
                else
                {
                    gengc->gc.frontBuffer.buf.base = ds.dsBm.bmBits;
                    gengc->gc.frontBuffer.buf.outerWidth = ds.dsBm.bmWidthBytes;
                }
            }

        // Bitmap size different from window?

            if ( ds.dsBm.bmWidth != pwnd->rclClient.right ||
                 ds.dsBm.bmHeight != pwnd->rclClient.bottom )
            {
            // Save new size.

                pwnd->rclClient.right  = ds.dsBm.bmWidth;
                pwnd->rclClient.bottom = ds.dsBm.bmHeight;
                pwnd->rclBounds.right  = ds.dsBm.bmWidth;
                pwnd->rclBounds.bottom = ds.dsBm.bmHeight;

            // Increment uniqueness numbers.
            // Don't let it hit -1.  -1 is special and is used by
            // MakeCurrent to signal that an update is required

                buffers->WndUniq++;

                buffers->WndSizeUniq++;

                if (buffers->WndUniq == -1)
                    buffers->WndUniq = 0;

                if (buffers->WndSizeUniq == -1)
                    buffers->WndSizeUniq = 0;
            }
        }
        else
        {
            WARNING("UpdateWindowInfo: could not get bitmap info for memDc\n");
        }
    }

// Compute current window dimensions.

    width = pwnd->rclClient.right - pwnd->rclClient.left;
    height = pwnd->rclClient.bottom - pwnd->rclClient.top;

// Check MCD buffers.

    if ( gengc->pMcdState )
    {
        BOOL bAllocOK;

    // Do we need an initial MCDAllocBuffers (via GenMcdResizeBuffers)?
    // The bAllocOK flag will be set to FALSE if the resize fails.

        if ( gengc->pMcdState->mcdFlags & MCD_STATE_FORCERESIZE )
        {
        // Attempt resize.  If it fails, convert context (see below).

            if (GenMcdResizeBuffers(gengc))
            {
                UpdateSharedBuffer(&gc->backBuffer.buf, &buffers->backBuffer);
                if (gc->modes.doubleBufferMode)
                    (*gc->back->resize)(buffers, gc->back, width, height);

                bAllocOK = TRUE;
            }
            else
                bAllocOK = FALSE;

        // Clear the flag.  If resize succeeded, we don't need to
        // force the resize again.  If resize failed, the context
        // will be converted, so we don't need to force the resize.

            gengc->pMcdState->mcdFlags &= ~MCD_STATE_FORCERESIZE;
        }
        else
            bAllocOK = TRUE;

    // If the shared buffer struct has lost its MCD info or we could
    // not do the initial allocate, convert the context.

        if ( (buffers->flags & GLGENBUF_MCD_LOST) || !bAllocOK )
        {
        // If GenMcdConvertContext succeeds, then pMcdState will
        // no longer exist.  The context is now an "ordinary"
        // generic context.

            if ( !GenMcdConvertContext(gengc, buffers) )
            {
            // Not only have we lost the MCD buffers, but we cannot
            // convert the context to generic.  For now, disable
            // drawing (by setting the window bounds to empty).  On
            // the next batch we will reattempt MCD buffer access
            // and context conversion.

                buffers->width       = 0;
                buffers->height      = 0;
                gc->constants.width  = 0;
                gc->constants.height = 0;

                (*gc->procs.applyViewport)(gc);
                return;
            }
        }
    }

// Check the uniqueness signature.  If different, the window client area
// state has changed.
//
// Note that we actually have two uniqueness numbers, WndUniq and WndSizeUniq.
// WndUniq is incremented whenever any client window state (size or position)
// changes.  WndSizeUniq is incremented only when the size changes and is
// maintained as an optimization.  WndSizeUniq allows us to skip copying
// the shared buffer info and recomputing the viewport if only the position
// has changed.
//
// WndSizeUniq is a subset of WndUniq, so checking only WndUniq suffices at
// this level.

    if ( gengc->WndUniq != buffers->WndUniq )
    {
    // Update origin of front buffer in case it moved

        gc->frontBuffer.buf.xOrigin = pwnd->rclClient.left;
        gc->frontBuffer.buf.yOrigin = pwnd->rclClient.top;

    // If acceleration is wired-in, set the offsets for line drawing.

        if ( gengc->pPrivateArea )
        {
            __fastLineComputeOffsets(gengc);
        }

    // Check for size changed
    // Update viewport and ancillary buffers

        visWidth  = pwnd->rclBounds.right - pwnd->rclBounds.left;
        visHeight = pwnd->rclBounds.bottom - pwnd->rclBounds.top;

    // Sanity check the info from window.

        ASSERTOPENGL(
            width <= __GL_MAX_WINDOW_WIDTH && height <= __GL_MAX_WINDOW_HEIGHT,
            "UpdateWindowInfo(): bad window client size\n"
            );
        ASSERTOPENGL(
            visWidth <= __GL_MAX_WINDOW_WIDTH && visHeight <= __GL_MAX_WINDOW_HEIGHT,
            "UpdateWindowInfo(): bad visible size\n"
            );

        (*gc->front->resize)(buffers, gc->front, width, height);

        if ( (width != buffers->width) ||
             (height != buffers->height) )
        {
            gc->constants.width = width;
            gc->constants.height = height;

        // This RC needs to resize back & ancillary buffers

            gengc->errorcode = 0;
            wglResizeBuffers(gengc, width, height);

        // Check if new size caused a memory failure
        // viewport code will set width & height to zero
        // punt on ancillary buffers, will try next time

            if (gengc->errorcode)
                return;

            buffers->width = width;
            buffers->height = height;
        }
        else if ( (gengc->WndSizeUniq != buffers->WndSizeUniq) ||
                  (width != gc->constants.width) ||
                  (height != gc->constants.height) )
        {
        // The buffer size is consistent with the window, so another thread
        // has already resized the buffer, but we need to update the
        // gc shared buffers and recompute the viewport.

            gc->constants.width = width;
            gc->constants.height = height;

            forcePick = (GLboolean)wglUpdateBuffers(gengc, buffers);

            if ( forcePick )
            {
                /* Cannot use DELAY_VALIDATE, may be in glBegin/End */
                __GL_INVALIDATE(gc);
                (*gc->procs.validate)(gc);
            }
        }
        else if ( (visWidth != gengc->visibleWidth) ||
                  (visHeight != gengc->visibleHeight) )
        {
        // The buffer size has not changed.  However, the visibility of
        // the window has changed so the viewport data must be recomputed.

            (*gc->procs.applyViewport)(gc);
        }

    // Make sure we swap the whole window

        buffers->fMax = TRUE;

    // The context is now up-to-date with the buffer size.  Set the
    // uniqueness numbers to match.

        gengc->WndUniq = buffers->WndUniq;
        gengc->WndSizeUniq = buffers->WndSizeUniq;
    }

// Update palette info is palette has changed

    HandlePaletteChanges(gengc, pwnd);
}

/******************************Public*Routine******************************\
* vSaveGdiState
*
* Saves current GDI drawing state to the GDISAVESTATE structure passed in.
* Sets GDI state needed for OpenGL rendering.
*
* History:
*  19-Jul-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL vSaveGdiState(HDC hdc, GDISAVESTATE *pGdiState)
{
// Currently, the only state needed is the line code which may use
// GDI lines.  Rop2 must be R2_COPYPEN (draws with the pen color).

    pGdiState->iRop2 = SetROP2(hdc, R2_COPYPEN);
}

/******************************Public*Routine******************************\
* vRestoreGdiState
*
* Restores GDI drawing state from the GDISAVESTATE structure passed in.
*
* History:
*  19-Jul-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL vRestoreGdiState(HDC hdc, GDISAVESTATE *pGdiState)
{
    SetROP2(hdc, pGdiState->iRop2);
}

/******************************Public*Routine******************************\
*
* glsrvSynchronizeWithGdi
*
* Synchronizes access to a locked surface with GDI
* This allows GDI calls to be made safely even on a locked surface
* so that we don't have to release the lock we're holding
*
* Win95 doesn't allow this so it just releases the screen lock
*
* History:
*  Wed Aug 28 11:10:27 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef WINNT
void APIENTRY glsrvSynchronizeWithGdi(__GLGENcontext *gengc,
                                      GLGENwindow *pwnd,
                                      FSHORT surfBits)
{
    // Nothing to do
}
#else
void APIENTRY glsrvSynchronizeWithGdi(__GLGENcontext *gengc,
                                      GLGENwindow *pwnd,
                                      FSHORT surfBits)
{
    glsrvReleaseSurfaces(gengc, pwnd, surfBits);
}
#endif

/******************************Public*Routine******************************\
*
* glsrvDecoupleFromGdi
*
* Indicates that it's no longer necessary to have GDI access to a surface
* synchronized with direct memory access
*
* Exists for Win95 where synchronization isn't done so the screen lock
* must be reacquired
*
* History:
*  Wed Aug 28 11:12:50 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef WINNT
void APIENTRY glsrvDecoupleFromGdi(__GLGENcontext *gengc,
                                   GLGENwindow *pwnd,
                                   FSHORT surfBits)
{
    GdiFlush();

    // Consider - How can this code be made surface specific?  Right now
    // surfBits is ignored.
    
    // Wait for any GDI accelerator operations to complete before we
    // return to direct access
    if (gengc->pgddsFront != NULL)
    {
        // Is there a better way to do this than looping?
        //          Does ISBLTDONE cover all the cases we need to wait for?
        for (;;)
        {
            if (gengc->pgddsFront->pdds->lpVtbl->
                GetBltStatus(gengc->pgddsFront->pdds,
                             DDGBS_ISBLTDONE) != DDERR_WASSTILLDRAWING)
            {
                break;
            }

            Sleep(20);
        }
    }
}
#else
void APIENTRY glsrvDecoupleFromGdi(__GLGENcontext *gengc,
                                   GLGENwindow *pwnd,
                                   FSHORT surfBits)
{
    // Failure is unhandled
    glsrvGrabSurfaces(gengc, pwnd, surfBits);
}
#endif

/******************************Public*Routine******************************\
*
* LockDdSurf
*
* Locks a GLDDSURF, handling surface loss
*
* History:
*  Wed Aug 28 15:32:08 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define LDDS_LOCKED             0
#define LDDS_LOCKED_NEW         1
#define LDDS_ERROR              2

// #define VERBOSE_LOCKDDSURF

DWORD LockDdSurf(GLDDSURF *pgdds, RECT *prcClient)
{
    HRESULT hr;
    LPDIRECTDRAWSURFACE pdds;
    DWORD dwRet;

    pdds = pgdds->pdds;
    dwRet = LDDS_LOCKED;
    
    hr = DDSLOCK(pdds, &pgdds->ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, prcClient);
#ifdef VERBOSE_LOCKDDSURF
    if (hr != DD_OK)
    {
	DbgPrint("LockDdSurf: Lock failed with 0x%08lX\n", hr);
    }
#endif
    
// If lock failed because of a resolution change, try to recreate
// the primary surface.  We can only do this if the surface is the
// screen surface because for app-provided DDraw surfaces we don't
// know what content needs to be recreated on the lost surface before
// it can be reused.

    if ( hr == DDERR_SURFACELOST &&
	 pgdds == &GLSCREENINFO->gdds )
    {
        DDSURFACEDESC ddsd;

        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        if (pdds->lpVtbl->Restore(pdds) == DD_OK &&
            pdds->lpVtbl->GetSurfaceDesc(pdds, &ddsd) == DD_OK)
        {
        // While OpenGL generic implementation can handle screen dimension
        // changes, it cannot yet deal with a color depth change.

            if (ddsd.ddpfPixelFormat.dwRGBBitCount ==
                pgdds->ddsd.ddpfPixelFormat.dwRGBBitCount)
            {
                pgdds->ddsd = ddsd;
                
            // Try lock with the new surface.

                dwRet = LDDS_LOCKED_NEW;
                hr = DDSLOCK(pdds, &pgdds->ddsd,
                         DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, prcClient);
#ifdef VERBOSE_LOCKDDSURF
		if (hr != DD_OK)
		{
		    DbgPrint("LockDdSurf: Relock failed with 0x%08lX\n", hr);
		}
#endif
            }
            else
            {
                hr = DDERR_GENERIC;
#ifdef VERBOSE_LOCKDDSURF
		DbgPrint("LockDdSurf: Bit count changed\n");
#endif
            }
        }
        else
        {
            hr = DDERR_GENERIC;
#ifdef VERBOSE_LOCKDDSURF
	    DbgPrint("LockDdSurf: Restore/GetSurfaceDesc failed\n");
#endif
        }
    }

    return hr == DD_OK ? dwRet : LDDS_ERROR;
}

/******************************Public*Routine******************************\
* BeginDirectScreenAccess
*
* Attempts to begin direct screen access for the primary surface.
*
* If the screen resolution changes, the primary surface is invalidated.  To
* regain access, the primary surface must be recreated.  If successful,
* the pointer to the primary surface passed into this function will be
* modified.
*
* Note: as currently written, generic implementation of OpenGL cannot
* handle color depth changes.  So we fail the call if this is detected.
*
* History:
*  21-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL BeginDirectScreenAccess(__GLGENcontext *gengc, GLGENwindow *pwnd,
                             PIXELFORMATDESCRIPTOR *ppfd)
{
    DWORD dwRet;
    
    ASSERTOPENGL((pwnd->ulFlags & GLGENWIN_DIRECTSCREEN) == 0,
                 "BeginDirectScreenAccess called with access\n");
    ASSERT_WINCRIT(pwnd);
    
// Do not acquire access if gengc format does not match pixelformat.

    if (gengc->pgddsFront->dwBitDepth != ppfd->cColorBits)
    {
        WARNING("BeginDirectScreenAccess: "
                "surface not compatible with context\n");
        return FALSE;
    }

// OK to try lock now.

    dwRet = LockDdSurf(gengc->pgddsFront, (RECT*) &pwnd->rclBounds);
    if (dwRet == LDDS_LOCKED_NEW)
    {
        __GLGENbuffers *buffers = (__GLGENbuffers *) NULL;

        // If screen changes, the MCD surfaces are lost and must be
        // recreated from scratch.  This can be triggered by simply
        // changing the window uniqueness numbers.

        buffers = pwnd->buffers;
        if (buffers)
        {
            buffers->WndUniq++;
                    
            buffers->WndSizeUniq++;

            // Don't let it hit -1.  -1 is special and is used by
            // MakeCurrent to signal that an update is required

            if (buffers->WndUniq == -1)
                buffers->WndUniq = 0;

            if (buffers->WndSizeUniq == -1)
                buffers->WndSizeUniq = 0;
        }
    }

// If we really have access to the surface, set the lock flag.
// Otherwise return error.

    if (dwRet != LDDS_ERROR)
    {
        ASSERTOPENGL(gengc->pgddsFront->ddsd.lpSurface != NULL,
                     "BeginDirectScreenAccess: expected non-NULL pointer\n");

        pwnd->pddsDirectScreen = gengc->pgddsFront->pdds;
        pwnd->pddsDirectScreen->lpVtbl->AddRef(pwnd->pddsDirectScreen);
        pwnd->pvDirectScreenLock = gengc->pgddsFront->ddsd.lpSurface;

        // DirectDraw returns a pointer offset to the specified rectangle;
        // undo that offset.

        gengc->pgddsFront->ddsd.lpSurface = (BYTE*) gengc->pgddsFront->ddsd.lpSurface 
            - pwnd->rclBounds.left * (gengc->pgddsFront->ddsd.ddpfPixelFormat.dwRGBBitCount >> 3) 
            - pwnd->rclBounds.top * gengc->pgddsFront->ddsd.lPitch;

        pwnd->pvDirectScreen = gengc->pgddsFront->ddsd.lpSurface;
        
        pwnd->ulFlags |= GLGENWIN_DIRECTSCREEN;

        return TRUE;
    }
    else
    {
        //XXX too noisy in stress when mode changes enabled
        //WARNING("BeginDirectScreenAccess failed\n");
        return FALSE;
    }
}

/******************************Public*Routine******************************\
* EndDirectScreenAccess
*
* Release lock acquired via BeginDirectScreenAccess.
*
* History:
*  28-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID EndDirectScreenAccess(GLGENwindow *pwnd)
{
    ASSERTOPENGL(pwnd->ulFlags & GLGENWIN_DIRECTSCREEN,
                 "EndDirectScreenAccess: not holding screen lock!\n");
    ASSERT_WINCRIT(pwnd);

    pwnd->ulFlags &= ~GLGENWIN_DIRECTSCREEN;
    if (pwnd->pddsDirectScreen != NULL)
    {
        DDSUNLOCK(pwnd->pddsDirectScreen, pwnd->pvDirectScreenLock);
        pwnd->pddsDirectScreen->lpVtbl->Release(pwnd->pddsDirectScreen);
        pwnd->pddsDirectScreen = NULL;
    }
}

/******************************Public*Routine******************************\
*
* glsrvGrabSurfaces
*
* Acquire all necessary surface locks and handle any changes that occurred
* since the last acquisition.
*
* NOTE: surfBits is currently ignored because taking fine-grained
* locks can lead to deadlocks because lock need has no guaranteed
* order.  To avoid this, all locks are taken if any locks are needed.
*
* History:
*  Tue Apr 02 13:10:26 1996	-by-	Drew Bliss [drewb]
*   Split out of glsrvGrabLock
*
\**************************************************************************/

BOOL APIENTRY glsrvGrabSurfaces(__GLGENcontext *gengc, GLGENwindow *pwnd,
                                FSHORT surfBits)
{
#if DBG
// If debugging, remember the surface offset in case it changes when we grab
// the lock.

    static void *pvCurSurf = NULL;
#endif

    BOOL bDoOver;
    FSHORT takeLocks;
    FSHORT locksTaken = 0;
    int lev = 0;

    ASSERT_WINCRIT(pwnd);
    
#ifndef DEADLOCKS_OK
    // See above note.
    surfBits = LAZY_LOCK_FLAGS;
#endif

    // Mask out MCD bit if no MCD.
    if (gengc->pMcdState == NULL)
    {
        surfBits &= ~LOCKFLAG_MCD;
    }
    
    // Early out if we don't actually need locks for the requested surfaces.

    takeLocks = gengc->fsGenLocks & surfBits;
    if (takeLocks == 0)
    {
        return TRUE;
    }

    // We can assume this function is not invoked if we already have the lock.

    ASSERTOPENGL((gengc->fsLocks & surfBits) == 0,
                 "glsrvGrabSurfaces: locks already held\n");

    // We already check this in glsrvAttention, but there are other
    // functions that call this so check that the window is correct
    // to be safe.

    if (pwnd != gengc->pwndMakeCur)
    {
        // One way an app could cause this is if the current HDC is released
        // without releasing (wglMakeCurrent(0, 0)) the corresponding HGLRC.
        // If GetDC returns this same HDC but for a different window, then
        // pwndGetFromID will return the pwnd associated with the new window.
        // However, the HGLRC is still bound to the original window.  In
        // such a situation we must fail the lock.

        WARNING("glsrvGrabSurfaces: mismatched windows\n");
        return FALSE;
    }

    if (takeLocks & LOCKFLAG_FRONT_BUFFER)
    {
        // Grab, test, and release the lock until the visregion is stable.
        // IsClipListChanged is currently hard-coded to return TRUE,
        // so force this loop to terminate after one update.  If
        // IsClipListChanged gets implemented correctly this will be
        // unnecessary.

        bDoOver = FALSE;
    
        do
        {
            UpdateWindowInfo(gengc);

            // Grab the screen lock.

            if (!BeginDirectScreenAccess(gengc, pwnd, &gengc->gsurf.pfd))
            {
#if 0
		// Too verbose under stress.
                WARNING("glsrvGrabLock(): BeginDirectScreenAccess failed\n");
#endif
                goto glsrvGrabSurfaces_exit;
            }

            if (bDoOver)
            {
                break;
            }

            // The surface may not have a clipper associated with it.
            if (pwnd->pddClip == NULL)
            {
                break;
            }
            
            // Did the window change during the time the lock was released?
            // If so, we need recompute the clip list and call UpdateWindowInfo
            // again.
            
            if ( pwnd->pddClip->lpVtbl->
                 IsClipListChanged(pwnd->pddClip, &bDoOver) == DD_OK &&
                 bDoOver )
            {
                BOOL bHaveClip;

                bHaveClip = wglGetClipList(pwnd);

                // Release access because we're going to loop around
                // to UpdateWindowInfo again and it makes a lot of
                // GDI calls.

                EndDirectScreenAccess(pwnd);

                if (!bHaveClip)
                {
                    WARNING("glsrvGrabSurfaces(): wglGetClipList failed\n");
                    goto glsrvGrabSurfaces_exit;
                }
            }
        } while ( bDoOver );

        // UpdateWindowInfo can cause a context conversion so we
        // may have lost MCD state since the start of locking activity.
        // Check again to make sure.

        if (gengc->pMcdState == NULL)
        {
            surfBits &= ~LOCKFLAG_MCD;
            takeLocks &= ~LOCKFLAG_MCD;
        }
        
        // Now that screen lock is held, set the lock flag.
        
        locksTaken |= LOCKFLAG_FRONT_BUFFER;
    }

    // Lock Z surface if necessary.
    if (takeLocks & LOCKFLAG_DD_DEPTH)
    {
        if (LockDdSurf(&gengc->gsurf.dd.gddsZ, NULL) == LDDS_ERROR)
        {
            goto glsrvGrabSurfaces_unlock;
        }
    
        locksTaken |= LOCKFLAG_DD_DEPTH;
    }

    // If there's a DirectDraw texture bound, lock its surface
    // and all mipmaps for use.
    if (takeLocks & LOCKFLAG_DD_TEXTURE)
    {
        GLDDSURF gdds;

        gdds = gengc->gc.texture.ddtex.gdds;
        for (lev = 0; lev < gengc->gc.texture.ddtex.levels; lev++)
        {
            gdds.pdds = gengc->gc.texture.ddtex.pdds[lev];
            if (LockDdSurf(&gdds, NULL) == LDDS_ERROR)
            {
                goto glsrvGrabSurfaces_unlock;
            }
            
            gengc->gc.texture.ddtex.texobj.texture.map.level[lev].buffer =
                gdds.ddsd.lpSurface;
        }

        locksTaken |= LOCKFLAG_DD_TEXTURE;
    }

    // Take MCD lock last so that buffer information is current.
    if (takeLocks & LOCKFLAG_MCD)
    {
        ASSERTOPENGL(gengc->pMcdState != NULL,
                     "MCD lock request but no MCD\n");
        
        if ((gpMcdTable->pMCDLock)(&gengc->pMcdState->McdContext) !=
            MCD_LOCK_TAKEN)
        {
            WARNING("glsrvGrabSurfaces(): MCDLock failed\n");
            goto glsrvGrabSurfaces_unlock;
        }

        locksTaken |= LOCKFLAG_MCD;
    }
    
    gengc->fsLocks |= locksTaken;

    ASSERTOPENGL(((gengc->fsLocks ^ gengc->fsGenLocks) & surfBits) == 0,
                 "Real locks/generic locks mismatch\n");
    
    if (takeLocks & LOCKFLAG_MCD)
    {
        // This must be called after fsLocks is updated since
        // GenMcdUpdateBufferInfo checks fsLocks to see what locks
        // are held.
        GenMcdUpdateBufferInfo(gengc);
    }
        
    // Base and width may have changed since last lock.  Refresh
    // the data in the gengc.

    // If the MCD lock was taken then the front buffer pointer was
    // updated.
    if ((takeLocks & (LOCKFLAG_FRONT_BUFFER | LOCKFLAG_MCD)) ==
         LOCKFLAG_FRONT_BUFFER)
    {
        gengc->gc.frontBuffer.buf.base =
            (VOID *)gengc->pgddsFront->ddsd.lpSurface;
        gengc->gc.frontBuffer.buf.outerWidth =
            gengc->pgddsFront->ddsd.lPitch;
    }

    if (takeLocks & LOCKFLAG_DD_DEPTH)
    {
        gengc->gc.depthBuffer.buf.base =
            gengc->gsurf.dd.gddsZ.ddsd.lpSurface;
        if (gengc->gsurf.dd.gddsZ.dwBitDepth == 16)
        {
            gengc->gc.depthBuffer.buf.outerWidth =
                gengc->gsurf.dd.gddsZ.ddsd.lPitch >> 1;
        }
        else
        {
            gengc->gc.depthBuffer.buf.outerWidth =
                gengc->gsurf.dd.gddsZ.ddsd.lPitch >> 2;
        }
    }

    // Record the approximate time the lock was grabbed.  That way we
    // can compute the time the lock is held and release it if necessary.

    gcmsOpenGLTimer = GetTickCount();
    gengc->dwLockTick = gcmsOpenGLTimer;
    gengc->dwLastTick = gcmsOpenGLTimer;
    gengc->dwCalls = 0;
    gengc->dwCallsPerTick = 16;

#if DBG
#define LEVEL_SCREEN   LEVEL_INFO

    if (takeLocks & LOCKFLAG_FRONT_BUFFER)
    {
        // Did the surface offset change?  If so, report it if debugging.

        if (pvCurSurf != gengc->pgddsFront->ddsd.lpSurface)
        {
            DBGLEVEL (LEVEL_SCREEN, "=============================\n");
            DBGLEVEL (LEVEL_SCREEN, "Surface offset changed\n\n");
            DBGLEVEL1(LEVEL_SCREEN, "\tdwOffSurface  = 0x%lx\n",
                      gengc->pgddsFront->ddsd.lpSurface);
            DBGLEVEL (LEVEL_SCREEN, "=============================\n");

            pvCurSurf = gengc->pgddsFront->ddsd.lpSurface;
        }
    }
#endif

    return TRUE;
    
 glsrvGrabSurfaces_unlock:
    while (--lev >= 0)
    {
        DDSUNLOCK(gengc->gc.texture.ddtex.pdds[lev],
                  gengc->gc.texture.ddtex.
                  texobj.texture.map.level[lev].buffer);

#if DBG
        gengc->gc.texture.ddtex.texobj.texture.map.level[lev].buffer = NULL;
#endif
    }
    
    if (locksTaken & LOCKFLAG_DD_DEPTH)
    {
        DDSUNLOCK(gengc->gsurf.dd.gddsZ.pdds,
                  gengc->gsurf.dd.gddsZ.ddsd.lpSurface);
    }

    if (locksTaken & LOCKFLAG_FRONT_BUFFER)
    {
        EndDirectScreenAccess(pwnd);
    }

 glsrvGrabSurfaces_exit:
    // Set the error codes.  GL_OUT_OF_MEMORY is used not because we
    // actually had a memory failure, but because this implies that
    // the OpenGL state is now indeterminate.

    gengc->errorcode = GLGEN_DEVLOCK_FAILED;
    __glSetError(GL_OUT_OF_MEMORY);

    return FALSE;
}

/******************************Public*Routine******************************\
*
* glsrvReleaseSurfaces
*
* Releases all resources held for screen access
*
* History:
*  Tue Apr 02 13:18:52 1996	-by-	Drew Bliss [drewb]
*   Split from glsrvReleaseLock
*
\**************************************************************************/

VOID APIENTRY glsrvReleaseSurfaces(__GLGENcontext *gengc,
                                   GLGENwindow *pwnd,
                                   FSHORT surfBits)
{
    FSHORT relLocks;

    ASSERT_WINCRIT(pwnd);
    
#ifndef DEADLOCKS_OK
    // See above note.
    surfBits = LAZY_LOCK_FLAGS;
#endif

    // Mask out MCD bit if no MCD.
    if (gengc->pMcdState == NULL)
    {
        surfBits &= ~LOCKFLAG_MCD;
    }
    
    // Early exit if locks are not actually held.

    relLocks = gengc->fsGenLocks & surfBits;
    if (relLocks == 0)
    {
        return;
    }
    
    if (relLocks & LOCKFLAG_MCD)
    {
        ASSERTOPENGL(gengc->pMcdState != NULL,
                     "MCD unlock request but no MCD\n");
        
        (gpMcdTable->pMCDUnlock)(&gengc->pMcdState->McdContext);
        gengc->fsLocks &= ~LOCKFLAG_MCD;
    }

    if (relLocks & LOCKFLAG_DD_TEXTURE)
    {
        int lev;
        
        lev = gengc->gc.texture.ddtex.levels;
        while (--lev >= 0)
        {
            DDSUNLOCK(gengc->gc.texture.ddtex.pdds[lev],
                      gengc->gc.texture.ddtex.
                      texobj.texture.map.level[lev].buffer);
#if DBG
            gengc->gc.texture.ddtex.texobj.texture.
                map.level[lev].buffer = NULL;
#endif
        }
        gengc->fsLocks &= ~LOCKFLAG_DD_TEXTURE;
    }

    if (relLocks & LOCKFLAG_DD_DEPTH)
    {
        DDSUNLOCK(gengc->gsurf.dd.gddsZ.pdds,
                  gengc->gsurf.dd.gddsZ.ddsd.lpSurface);
        gengc->fsLocks &= ~LOCKFLAG_DD_DEPTH;
        
#if DBG
        // NULL out our buffer information to ensure that we
        // can't access the surface unless we're really holding the lock

        gengc->gc.depthBuffer.buf.base = NULL;
        gengc->gc.depthBuffer.buf.outerWidth = 0;
#endif
    }

    if (relLocks & LOCKFLAG_FRONT_BUFFER)
    {
	EndDirectScreenAccess(pwnd);
	gengc->fsLocks &= ~LOCKFLAG_FRONT_BUFFER;
        
#if DBG
        // NULL out our front-buffer information to ensure that we
        // can't access the surface unless we're really holding the lock

        gengc->gc.frontBuffer.buf.base = NULL;
        gengc->gc.frontBuffer.buf.outerWidth = 0;
#endif
    }

    ASSERTOPENGL((gengc->fsLocks & surfBits) == 0,
                 "Surface locks still held after ReleaseSurfaces\n");
}

/******************************Public*Routine******************************\
* glsrvGrabLock
*
* Grab the display lock and tear down the cursor as needed.  Also, initialize
* the tickers and such that help determine when the thread should give up
* the lock.
*
* Note that for contexts that draw only to the generic back buffer do not
* need to grab the display lock or tear down the cursor.  However, to prevent
* another thread of a multithreaded app from resizing the drawable while
* this thread is using it, a per-drawable semaphore will be grabbed.
*
* Note: while the return value indicates whether the function succeeded,
* some APIs that might call this (like the dispatch function for glCallList
* and glCallLists) may not be able to return failure.  So, an error code
* of GLGEN_DEVLOCK_FAILED is posted to the GLGENcontext if the lock fails.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  12-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY glsrvGrabLock(__GLGENcontext *gengc)
{
    BOOL bRet = FALSE;
    BOOL bBackBufferOnly = GENERIC_BACKBUFFER_ONLY((__GLcontext *) gengc);
    GLGENwindow *pwnd;

    ASSERTOPENGL(gengc->pwndLocked == NULL,
                 "Unlocked gengc with window pointer\n");
    
    // Mostly ignore attempts to lock IC's
    if (gengc->gsurf.dwFlags & GLSURF_METAFILE)
    {
        // If we're running with a real window then we need to look it
        // up to detect whether it's died or not
        if (gengc->ipfdCurrent != 0)
        {
            pwnd = pwndGetFromID(&gengc->gwidCurrent);
            if (pwnd == NULL)
            {
                return FALSE;
            }
            if (pwnd != gengc->pwndMakeCur)
            {
                WARNING("glsrvGrabLock: mismatched windows (info DC)\n");
		pwndRelease(pwnd);
                return FALSE;
            }
        }
        else
        {
            pwnd = gengc->pwndMakeCur;
        }

        ENTER_WINCRIT_GC(pwnd, gengc);
        UpdateWindowInfo(gengc);
        return TRUE;
    }

    // Get the window from the DC.  This has the side effect of locking it
    // against deletion.
    
    pwnd = pwndGetFromID(&gengc->gwidCurrent);
    if (pwnd == NULL)
    {
        WARNING("glsrvGrabLock: No pwnd found\n");
        goto glsrvGrabLock_exit;
    }
    if (pwnd != gengc->pwndMakeCur)
    {
        // One way an app could cause this is if the current HDC is released
        // without releasing (wglMakeCurrent(0, 0)) the corresponding HGLRC.
        // If GetDC returns this same HDC but for a different window, then
        // pwndGetFromID will return the pwnd associated with the new window.
        // However, the HGLRC is still bound to the original window.  In
        // such a situation we must fail the lock.

#ifdef BAD_WINDOW_BREAK
        DbgPrint("%p:%p:%p thinks %p:%p but finds %p:%p\n",
                 gengc, gengc->gwidCurrent.hdc, gengc->gwidCurrent.hwnd,
                 gengc->pwndMakeCur, gengc->pwndMakeCur->gwid.hwnd,
                 pwnd, pwnd->gwid.hwnd);
        DebugBreak();
#else
        WARNING("glsrvGrabLock: mismatched windows\n");
#endif
        goto glsrvGrabLock_exit;
    }

    //
    // Compute locks necessary for generic rendering code to operate.
    // If a non-generic code path is going to run first these locks
    // won't actually be taken until after the non-generic code
    // has had a chance at rendering.
    //

    // We always need the window lock.
    gengc->fsGenLocks = LOCKFLAG_WINDOW;

    // If MCD is active we need to do MCD locking.
    if (gengc->pMcdState != NULL)
    {
        gengc->fsGenLocks |= LOCKFLAG_MCD;
    }
    
    // If we're going to be drawing to a direct-access front-buffer
    // then we need the front buffer lock.  MCD always requires
    // a front buffer lock on direct access buffers, so if
    // MCD is active the only thing that is checked is direct access.
    if ((gengc->pMcdState != NULL || !bBackBufferOnly) &&
        gengc->pgddsFront != NULL)
    {
        gengc->fsGenLocks |= LOCKFLAG_FRONT_BUFFER;
    }

    // If we have a DDraw depth buffer we need a lock on it.
    if ((gengc->dwCurrentFlags & GLSURF_DIRECTDRAW) &&
        gengc->gsurf.dd.gddsZ.pdds != NULL)
    {
        gengc->fsGenLocks |= LOCKFLAG_DD_DEPTH;
    }

    // If we have a current DDraw texture we need a lock on it.
    if (gengc->gc.texture.ddtex.levels > 0)
    {
        gengc->fsGenLocks |= LOCKFLAG_DD_TEXTURE;
    }
    
    // All lock types require the GLGENwindow structure lock.

    ENTER_WINCRIT_GC(pwnd, gengc);
    
    gengc->fsLocks |= LOCKFLAG_WINDOW;

    // If the current window is out-of-process then we haven't
    // been receiving any updates on its status.  Manually
    // check its position, size and palette information
    if (pwnd->ulFlags & GLGENWIN_OTHERPROCESS)
    {
        RECT rct;
        POINT pt;
        BOOL bPosChanged, bSizeChanged;

        if (!IsWindow(pwnd->gwid.hwnd))
        {
            // Window was destroyed
            pwndCleanup(pwnd);
            pwnd = NULL;
            goto glsrvGrabLock_exit;
        }

        if (!GetClientRect(pwnd->gwid.hwnd, &rct))
        {
            goto glsrvGrabLock_exit;
        }
        pt.x = rct.left;
        pt.y = rct.top;
        if (!ClientToScreen(pwnd->gwid.hwnd, &pt))
        {
            goto glsrvGrabLock_exit;
        }

        bPosChanged =
            GLDIRECTSCREEN &&
            (pt.x != pwnd->rclClient.left ||
             pt.y != pwnd->rclClient.top);
        bSizeChanged =
            rct.right != (pwnd->rclClient.right-pwnd->rclClient.left) ||
            rct.bottom != (pwnd->rclClient.bottom-pwnd->rclClient.top);

        if (bPosChanged || bSizeChanged)
        {
            __GLGENbuffers *buffers = NULL;

            pwnd->rclClient.left = pt.x;
            pwnd->rclClient.top = pt.y;
            pwnd->rclClient.right = pt.x+rct.right;
            pwnd->rclClient.bottom = pt.y+rct.bottom;
            pwnd->rclBounds = pwnd->rclClient;
            
            buffers = pwnd->buffers;
            if (buffers != NULL)
            {
                // Don't let it hit -1.  -1 is special and is used by
                // MakeCurrent to signal that an update is required
                
                if (++buffers->WndUniq == -1)
                {
                    buffers->WndUniq = 0;
                }
                if (bSizeChanged &&
                    ++buffers->WndSizeUniq == -1)
                {
                    buffers->WndSizeUniq = 0;
                }
            }
        }

        // The palette watcher should be active since we
        // are going to use its count.

        if (tidPaletteWatcherThread == 0)
        {
            goto glsrvGrabLock_exit;
        }
        pwnd->ulPaletteUniq = ulPaletteWatcherCount;
    }

    // If there's no MCD then generic code is going to be entered
    // immediately so go ahead and grab the appropriate locks.
    // Update drawables.

    if ( gengc->pMcdState == NULL &&
         gengc->fsGenLocks != gengc->fsLocks )
    {
        // UpdateWindowInfo needs to be called to ensure that
        // the gc's buffer state is synchronized with the current window
        // state.  Locking the front buffer will do this, but if
        // we aren't locking the front buffer then we need to do
        // it here to make sure it gets done.
        if ((gengc->fsGenLocks & LOCKFLAG_FRONT_BUFFER) == 0)
        {
            UpdateWindowInfo(gengc);
        }
            
        if (!glsrvGrabSurfaces(gengc, pwnd, gengc->fsGenLocks))
        {
            goto glsrvGrabLock_exit;
        }
    }
    else
    {
        UpdateWindowInfo(gengc);

        // Update MCD buffer state for MCD drivers w/o direct support.

        if (gengc->pMcdState)
        {
            GenMcdUpdateBufferInfo(gengc);
        }
        else
        {
            // UpdateWindowInfo can result in a context conversion.
            // This can be detected if pMcdState is NULL but
            // fsGenLocks is different from fsLocks (which implies that
            // pMcdState was not NULL prior to the call to
            // UpdateWindowInfo).
            //
            // If so, the locks must be grabbed immediately.

            gengc->fsGenLocks &= ~LOCKFLAG_MCD;
            if ( gengc->fsGenLocks != gengc->fsLocks )
            {
                if (!glsrvGrabSurfaces(gengc, pwnd, gengc->fsGenLocks))
                {
                    goto glsrvGrabLock_exit;
                }
            }
        }
    }

    bRet = TRUE;

glsrvGrabLock_exit:

    if (!bRet)
    {
        gengc->fsGenLocks = 0;
        gengc->fsLocks = 0;

        if (pwnd != NULL)
        {
	    if (gengc->pwndLocked != NULL)
	    {
		LEAVE_WINCRIT_GC(pwnd, gengc);
	    }
            
            pwndRelease(pwnd);
        }

    // Set the error codes.  GL_OUT_OF_MEMORY is used not because we
    // actually had a memory failure, but because this implies that
    // the OpenGL state is now indeterminate.

        gengc->errorcode = GLGEN_DEVLOCK_FAILED;
        __glSetError(GL_OUT_OF_MEMORY);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* glsrvReleaseLock
*
* Releases display or drawable semaphore as appropriate.
*
* Returns:
*   No return value.
*
* History:
*  12-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY glsrvReleaseLock(__GLGENcontext *gengc)
{
    GLGENwindow *pwnd = gengc->pwndLocked;
    GLint lev;

    ASSERTOPENGL(gengc->pwndLocked != NULL, "glsrvReleaseLock: No window\n");
    
    // Mostly ignore attempts to lock IC's
    if (gengc->gsurf.dwFlags & GLSURF_METAFILE)
    {
        LEAVE_WINCRIT_GC(pwnd, gengc);
        
        // If we have a real window we need to release it
        if (gengc->ipfdCurrent != 0)
        {
            pwndRelease(pwnd);
        }
        
        return;
    }

    if ( gengc->fsLocks & LAZY_LOCK_FLAGS )
    {
        glsrvReleaseSurfaces(gengc, pwnd, gengc->fsLocks);
    }

    ASSERTOPENGL(gengc->fsLocks == LOCKFLAG_WINDOW,
                 "Wrong locks held\n");
    
// Note: pwndUnlock releases the window semaphore.

    pwndUnlock(pwnd, gengc);

    gengc->fsGenLocks = 0;
    gengc->fsLocks = 0;
}

/******************************Public*Routine******************************\
* glsrvAttention
*
* Dispatches each of the OpenGL API calls in the shared memory window.
*
* So that a single complex or long batch does not starve the rest of the
* system, the lock is released periodically based on the number of ticks
* that have elapsed since the lock was acquired.
*
* The user Raw Input Thread (RIT) and OpenGL share the gcmsOpenGLTimer
* value.  Because the RIT may be blocked, it does not always service
* the gcmsOpenGLTimer.  To compensate, glsrvAttention (as well as the
* display list dispatchers for glCallList and glCallLists) update
* gcmsOpenGLTimer explicitly with NtGetTickCount (a relatively expensive
* call) every N calls.
*
* The value N, or the number of APIs dispatched per call to NtGetTickCount,
* is variable.  glsrvAttention and its display list equivalents attempt
* to adjust N so that NtGetTickCount is called approximately every
* TICK_RANGE_LO to TICK_RANGE_HI ticks.
*
* Returns:
*   TRUE if entire batch is processed, FALSE otherwise.
*
* History:
*  12-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY glsrvAttention(PVOID pdlo, PVOID pdco, PVOID pdxo, HANDLE hdev)
{
    BOOL bRet = FALSE;
    ULONG *pOffset;
    SERVERPROC Proc;
    GLMSGBATCHINFO *pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();
    __GLGENcontext *gengc = (__GLGENcontext *) GLTEB_SRVCONTEXT();
#ifdef CHAIN_DRAWPOLYARRAY_MSG
    POLYARRAY *paBegin = (POLYARRAY *) NULL;
    POLYARRAY *paEnd, *pa;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray = NULL;
#endif
    UINT old_fp;
    GDISAVESTATE GdiState;

#ifdef DETECT_FPE
    old_fp = _controlfp(0, 0);
    _controlfp(_EM_INEXACT, _MCW_EM);
#endif
    if ((gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW) == 0)
    {
        vSaveGdiState(gengc->gsurf.hdc, &GdiState);
    }
    
    DBGENTRY("glsrvAttention\n");

    DBGLEVEL1(LEVEL_INFO, "glsrvAttention: pMsgBatchInfo=0x%lx\n",
            pMsgBatchInfo);

    STATS_INC_SERVERTRIPS();

// Grab the lock.

    if (!glsrvGrabLock(gengc))
    {
	//!!! mcd/dma too?
	PolyArrayResetBuffer((__GLcontext *) gengc);
        goto glsrvAttention_exit;
    }

// Dispatch the calls in the batch.

    pOffset = (ULONG *)(((BYTE *)pMsgBatchInfo) + pMsgBatchInfo->FirstOffset);

    // If we don't require any locks we don't need to burden our processing
    // with timer checks.

    if (gengc->fsGenLocks == LOCKFLAG_WINDOW)
    {
        while (*pOffset)
        {
            ASSERTOPENGL(*pOffset <= LASTPROCOFFSET(glSrvSbProcTable),
                "Bad ProcOffset: memory corruption - we are hosed!\n");

            STATS_INC_SERVERCALLS();

            DBGLEVEL1(LEVEL_ENTRY, "%s\n",
                      glSrvSbStringTable[*pOffset / sizeof(SERVERPROC *)]);

#ifdef CHAIN_DRAWPOLYARRAY_MSG
            if (*pOffset == offsetof(GLSRVSBPROCTABLE, glsrvDrawPolyArray))
		pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *) pOffset;
#endif

        // Dispatch the call.  The return value is the offset of the next
        // message in the batch.

            Proc    = (*((SERVERPROC *)( ((BYTE *)(&glSrvSbProcTable)) +
                            *pOffset )));
            pOffset = (*Proc)((__GLcontext *) gengc, pOffset);

#ifdef CHAIN_DRAWPOLYARRAY_MSG
        // If we are processing DrawPolyArray, we need to update the pointers
        // that indicate the beginning and end of the POLYARRAY data for
        // the current range of DrawPolyArray chain.

	    if (pMsgDrawPolyArray)
	    {
		pa = (POLYARRAY *) pMsgDrawPolyArray->pa;
		pMsgDrawPolyArray = NULL;   // get ready for next iteration

		// Skip this primitive if no rendering is needed.
		if (!(pa->flags & POLYARRAY_RENDER_PRIMITIVE))
		{
		    PolyArrayRestoreColorPointer(pa);
		}
		else
		{
		// Add to DrawPolyArray chain
		    pa->paNext = NULL;
		    if (!paBegin)
			paBegin = pa;
		    else
			paEnd->paNext = pa;
		    paEnd = pa;
		}

		// If the next message is not a DrawPolyArray, then we need to
		// flush the primitive drawing.
		if (*pOffset != offsetof(GLSRVSBPROCTABLE, glsrvDrawPolyArray)
		    && paBegin)
		{
		    // Draw all the POLYARRAY primitives between paBegin
		    // and paEnd
		    glsrvFlushDrawPolyArray((void *) paBegin);
		    paBegin = NULL;
		}
	    }
#endif
        }
    }
    else
    {
        while (*pOffset)
        {
            ASSERTOPENGL(*pOffset <= LASTPROCOFFSET(glSrvSbProcTable),
                "Bad ProcOffset: memory corruption - we are hosed!\n");

            STATS_INC_SERVERCALLS();

            DBGLEVEL1(LEVEL_ENTRY, "%s\n",
                      glSrvSbStringTable[*pOffset / sizeof(SERVERPROC *)]);

#ifdef CHAIN_DRAWPOLYARRAY_MSG
            if (*pOffset == offsetof(GLSRVSBPROCTABLE, glsrvDrawPolyArray))
		pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *) pOffset;
#endif

        // Dispatch the call.  The return value is the offset of the next
        // message in the batch.

            Proc    = (*((SERVERPROC *)( ((BYTE *)(&glSrvSbProcTable)) +
                            *pOffset )));
            pOffset = (*Proc)((__GLcontext *) gengc, pOffset);

#ifdef CHAIN_DRAWPOLYARRAY_MSG
        // If we are processing DrawPolyArray, we need to update the pointers
        // that indicate the beginning and end of the POLYARRAY data for
        // the current range of DrawPolyArray chain.

	    if (pMsgDrawPolyArray)
	    {
		pa = (POLYARRAY *) pMsgDrawPolyArray->pa;
		pMsgDrawPolyArray = NULL;   // get ready for next iteration

		// Skip this primitive if no rendering is needed.
		if (!(pa->flags & POLYARRAY_RENDER_PRIMITIVE))
		{
		    PolyArrayRestoreColorPointer(pa);
		}
		else
		{
		// Add to DrawPolyArray chain
		    pa->paNext = NULL;
		    if (!paBegin)
			paBegin = pa;
		    else
			paEnd->paNext = pa;
		    paEnd = pa;
		}

		// If the next message is not a DrawPolyArray, then we need to
		// flush the primitive drawing.
		if (*pOffset != offsetof(GLSRVSBPROCTABLE, glsrvDrawPolyArray)
		    && paBegin)
		{
		    // Draw all the POLYARRAY primitives between paBegin
		    // and paEnd
		    glsrvFlushDrawPolyArray((void *) paBegin);
		    paBegin = NULL;
		}
	    }
#endif

//!!!XXX -- Better to use other loop until lock is grabbed then
//!!!XXX    switch to this loop.  But good enough for now to
//!!!XXX    check flag in loop.

        // If display lock held, we may need to periodically unlock to give
        // other apps a chance.

            if (gengc->fsLocks & LOCKFLAG_FRONT_BUFFER)
            {
            // Force a check of the current tick count every N calls.

                gengc->dwCalls++;

                if (gengc->dwCalls >= gengc->dwCallsPerTick)
                {
                    gcmsOpenGLTimer = GetTickCount();

                // If the tick delta is out of range, then increase or decrease
                // N as appropriate.  Be careful not to let it grow out of
                // bounds or to shrink to zero.

                    if ((gcmsOpenGLTimer - gengc->dwLastTick) < TICK_RANGE_LO)
                        if (gengc->dwCallsPerTick < 64)
                            gengc->dwCallsPerTick *= 2;
                    else if ((gcmsOpenGLTimer - gengc->dwLastTick) > TICK_RANGE_HI)
                        // The + 1 is to keep it from hitting 0
                        gengc->dwCallsPerTick = (gengc->dwCallsPerTick + 1) / 2;

                    gengc->dwLastTick = gcmsOpenGLTimer;
                    gengc->dwCalls = 0;
                }

            // Check if time slice has expired.  If so, relinquish the lock.

                if ((gcmsOpenGLTimer - gengc->dwLockTick) > BATCH_LOCK_TICKMAX)
                {
#ifdef CHAIN_DRAWPOLYARRAY_MSG
                    //!!! Before we release the lock, we may need to flush the
                    //!!! DrawPolyArray chain.  For now, just flush it although
                    //!!! it is probably unnecessary.
                    if (paBegin)
                    {
                        // Draw all the POLYARRAY primitives between paBegin
                        // and paEnd
                        glsrvFlushDrawPolyArray((void *) paBegin);
                        paBegin = NULL;
                    }
#endif

                // Release and regrab lock.  This will allow the cursor to
                // redraw as well as reset the cursor timer.

                    glsrvReleaseLock(gengc);
                    if (!glsrvGrabLock(gengc))
                    {
                        //!!! mcd/dma too?
                        PolyArrayResetBuffer((__GLcontext *) gengc);
                        goto glsrvAttention_exit;
                    }
                }
            }
        }
    }

// Release the lock.

    glsrvReleaseLock(gengc);

// Success.

    bRet = TRUE;

glsrvAttention_exit:

    if ((gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW) == 0)
    {
        vRestoreGdiState(gengc->gsurf.hdc, &GdiState);
    }
    
#ifdef DETECT_FPE
    _controlfp(old_fp, _MCW_EM);
#endif
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\wgl\srvsize.h ===
#ifndef __SRVSIZE_H__
#define __SRVSIZE_H__

#ifndef _CLIENTSIDE_
GLint __glReadPixels_size ( GLenum format, GLenum type, GLint w, GLint h);
GLint __glGetTexImage_size ( GLenum target, GLint  level, GLenum format, GLenum type );
GLint __glDrawPixels_size ( GLenum Format, GLenum Type, GLint Width, GLint Height );
GLint __glTexImage_size ( GLint Level, GLint Components, GLsizei Width, GLsizei Height, GLint Border, GLenum Format, GLenum Type );
#endif

#endif /* !__SRVSIZE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\wgl\glsrvsb.h ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#ifndef __GLSRVSB_H__
#define __GLSRVSB_H__

/* Server Side SubBatch Prototypes */


/* gl Entry points */

VOID * FASTCALL sbs_glDrawPolyArray          ( __GLcontext *gc, IN GLMSG_DRAWPOLYARRAY *pMsg );
VOID * FASTCALL sbs_glBitmap                 ( __GLcontext *gc, IN GLMSG_BITMAP *pMsg );
VOID * FASTCALL sbs_glColor4fv               ( __GLcontext *gc, IN GLMSG_COLOR4FV *pMsg );
VOID * FASTCALL sbs_glEdgeFlag               ( __GLcontext *gc, IN GLMSG_EDGEFLAG *pMsg );
VOID * FASTCALL sbs_glIndexf                 ( __GLcontext *gc, IN GLMSG_INDEXF *pMsg );
VOID * FASTCALL sbs_glNormal3fv              ( __GLcontext *gc, IN GLMSG_NORMAL3FV *pMsg );
VOID * FASTCALL sbs_glRasterPos4fv           ( __GLcontext *gc, IN GLMSG_RASTERPOS4FV *pMsg );
VOID * FASTCALL sbs_glTexCoord4fv            ( __GLcontext *gc, IN GLMSG_TEXCOORD4FV *pMsg );
VOID * FASTCALL sbs_glClipPlane              ( __GLcontext *gc, IN GLMSG_CLIPPLANE *pMsg );
VOID * FASTCALL sbs_glColorMaterial          ( __GLcontext *gc, IN GLMSG_COLORMATERIAL *pMsg );
VOID * FASTCALL sbs_glCullFace               ( __GLcontext *gc, IN GLMSG_CULLFACE *pMsg );
VOID * FASTCALL sbs_glFogfv                  ( __GLcontext *gc, IN GLMSG_FOGFV *pMsg );
VOID * FASTCALL sbs_glFrontFace              ( __GLcontext *gc, IN GLMSG_FRONTFACE *pMsg );
VOID * FASTCALL sbs_glHint                   ( __GLcontext *gc, IN GLMSG_HINT *pMsg );
VOID * FASTCALL sbs_glLightfv                ( __GLcontext *gc, IN GLMSG_LIGHTFV *pMsg );
VOID * FASTCALL sbs_glLightModelfv           ( __GLcontext *gc, IN GLMSG_LIGHTMODELFV *pMsg );
VOID * FASTCALL sbs_glLineStipple            ( __GLcontext *gc, IN GLMSG_LINESTIPPLE *pMsg );
VOID * FASTCALL sbs_glLineWidth              ( __GLcontext *gc, IN GLMSG_LINEWIDTH *pMsg );
VOID * FASTCALL sbs_glMaterialfv             ( __GLcontext *gc, IN GLMSG_MATERIALFV *pMsg );
VOID * FASTCALL sbs_glPointSize              ( __GLcontext *gc, IN GLMSG_POINTSIZE *pMsg );
VOID * FASTCALL sbs_glPolygonMode            ( __GLcontext *gc, IN GLMSG_POLYGONMODE *pMsg );
VOID * FASTCALL sbs_glPolygonStipple         ( __GLcontext *gc, IN GLMSG_POLYGONSTIPPLE *pMsg );
VOID * FASTCALL sbs_glScissor                ( __GLcontext *gc, IN GLMSG_SCISSOR *pMsg );
VOID * FASTCALL sbs_glShadeModel             ( __GLcontext *gc, IN GLMSG_SHADEMODEL *pMsg );
VOID * FASTCALL sbs_glTexParameterfv         ( __GLcontext *gc, IN GLMSG_TEXPARAMETERFV *pMsg );
VOID * FASTCALL sbs_glTexParameteriv         ( __GLcontext *gc, IN GLMSG_TEXPARAMETERIV *pMsg );
VOID * FASTCALL sbs_glTexImage1D             ( __GLcontext *gc, IN GLMSG_TEXIMAGE1D *pMsg );
VOID * FASTCALL sbs_glTexImage2D             ( __GLcontext *gc, IN GLMSG_TEXIMAGE2D *pMsg );
VOID * FASTCALL sbs_glTexEnvfv               ( __GLcontext *gc, IN GLMSG_TEXENVFV *pMsg );
VOID * FASTCALL sbs_glTexEnviv               ( __GLcontext *gc, IN GLMSG_TEXENVIV *pMsg );
VOID * FASTCALL sbs_glTexGenfv               ( __GLcontext *gc, IN GLMSG_TEXGENFV *pMsg );
VOID * FASTCALL sbs_glFeedbackBuffer         ( __GLcontext *gc, IN GLMSG_FEEDBACKBUFFER *pMsg );
VOID * FASTCALL sbs_glSelectBuffer           ( __GLcontext *gc, IN GLMSG_SELECTBUFFER *pMsg );
VOID * FASTCALL sbs_glRenderMode             ( __GLcontext *gc, IN GLMSG_RENDERMODE *pMsg );
VOID * FASTCALL sbs_glInitNames              ( __GLcontext *gc, IN GLMSG_INITNAMES *pMsg );
VOID * FASTCALL sbs_glLoadName               ( __GLcontext *gc, IN GLMSG_LOADNAME *pMsg );
VOID * FASTCALL sbs_glPassThrough            ( __GLcontext *gc, IN GLMSG_PASSTHROUGH *pMsg );
VOID * FASTCALL sbs_glPopName                ( __GLcontext *gc, IN GLMSG_POPNAME *pMsg );
VOID * FASTCALL sbs_glPushName               ( __GLcontext *gc, IN GLMSG_PUSHNAME *pMsg );
VOID * FASTCALL sbs_glDrawBuffer             ( __GLcontext *gc, IN GLMSG_DRAWBUFFER *pMsg );
VOID * FASTCALL sbs_glClear                  ( __GLcontext *gc, IN GLMSG_CLEAR *pMsg );
VOID * FASTCALL sbs_glClearAccum             ( __GLcontext *gc, IN GLMSG_CLEARACCUM *pMsg );
VOID * FASTCALL sbs_glClearIndex             ( __GLcontext *gc, IN GLMSG_CLEARINDEX *pMsg );
VOID * FASTCALL sbs_glClearColor             ( __GLcontext *gc, IN GLMSG_CLEARCOLOR *pMsg );
VOID * FASTCALL sbs_glClearStencil           ( __GLcontext *gc, IN GLMSG_CLEARSTENCIL *pMsg );
VOID * FASTCALL sbs_glClearDepth             ( __GLcontext *gc, IN GLMSG_CLEARDEPTH *pMsg );
VOID * FASTCALL sbs_glStencilMask            ( __GLcontext *gc, IN GLMSG_STENCILMASK *pMsg );
VOID * FASTCALL sbs_glColorMask              ( __GLcontext *gc, IN GLMSG_COLORMASK *pMsg );
VOID * FASTCALL sbs_glDepthMask              ( __GLcontext *gc, IN GLMSG_DEPTHMASK *pMsg );
VOID * FASTCALL sbs_glIndexMask              ( __GLcontext *gc, IN GLMSG_INDEXMASK *pMsg );
VOID * FASTCALL sbs_glAccum                  ( __GLcontext *gc, IN GLMSG_ACCUM *pMsg );
VOID * FASTCALL sbs_glDisable                ( __GLcontext *gc, IN GLMSG_DISABLE *pMsg );
VOID * FASTCALL sbs_glEnable                 ( __GLcontext *gc, IN GLMSG_ENABLE *pMsg );
VOID * FASTCALL sbs_glPopAttrib              ( __GLcontext *gc, IN GLMSG_POPATTRIB *pMsg );
VOID * FASTCALL sbs_glPushAttrib             ( __GLcontext *gc, IN GLMSG_PUSHATTRIB *pMsg );
VOID * FASTCALL sbs_glAlphaFunc              ( __GLcontext *gc, IN GLMSG_ALPHAFUNC *pMsg );
VOID * FASTCALL sbs_glBlendFunc              ( __GLcontext *gc, IN GLMSG_BLENDFUNC *pMsg );
VOID * FASTCALL sbs_glLogicOp                ( __GLcontext *gc, IN GLMSG_LOGICOP *pMsg );
VOID * FASTCALL sbs_glStencilFunc            ( __GLcontext *gc, IN GLMSG_STENCILFUNC *pMsg );
VOID * FASTCALL sbs_glStencilOp              ( __GLcontext *gc, IN GLMSG_STENCILOP *pMsg );
VOID * FASTCALL sbs_glDepthFunc              ( __GLcontext *gc, IN GLMSG_DEPTHFUNC *pMsg );
VOID * FASTCALL sbs_glPixelZoom              ( __GLcontext *gc, IN GLMSG_PIXELZOOM *pMsg );
VOID * FASTCALL sbs_glPixelTransferf         ( __GLcontext *gc, IN GLMSG_PIXELTRANSFERF *pMsg );
VOID * FASTCALL sbs_glPixelTransferi         ( __GLcontext *gc, IN GLMSG_PIXELTRANSFERI *pMsg );
VOID * FASTCALL sbs_glPixelStoref            ( __GLcontext *gc, IN GLMSG_PIXELSTOREF *pMsg );
VOID * FASTCALL sbs_glPixelStorei            ( __GLcontext *gc, IN GLMSG_PIXELSTOREI *pMsg );
VOID * FASTCALL sbs_glPixelMapfv             ( __GLcontext *gc, IN GLMSG_PIXELMAPFV *pMsg );
VOID * FASTCALL sbs_glPixelMapuiv            ( __GLcontext *gc, IN GLMSG_PIXELMAPUIV *pMsg );
VOID * FASTCALL sbs_glPixelMapusv            ( __GLcontext *gc, IN GLMSG_PIXELMAPUSV *pMsg );
VOID * FASTCALL sbs_glReadBuffer             ( __GLcontext *gc, IN GLMSG_READBUFFER *pMsg );
VOID * FASTCALL sbs_glCopyPixels             ( __GLcontext *gc, IN GLMSG_COPYPIXELS *pMsg );
VOID * FASTCALL sbs_glReadPixels             ( __GLcontext *gc, IN GLMSG_READPIXELS *pMsg );
VOID * FASTCALL sbs_glDrawPixels             ( __GLcontext *gc, IN GLMSG_DRAWPIXELS *pMsg );
VOID * FASTCALL sbs_glGetBooleanv            ( __GLcontext *gc, IN GLMSG_GETBOOLEANV *pMsg );
VOID * FASTCALL sbs_glGetClipPlane           ( __GLcontext *gc, IN GLMSG_GETCLIPPLANE *pMsg );
VOID * FASTCALL sbs_glGetDoublev             ( __GLcontext *gc, IN GLMSG_GETDOUBLEV *pMsg );
VOID * FASTCALL sbs_glGetError               ( __GLcontext *gc, IN GLMSG_GETERROR *pMsg );
VOID * FASTCALL sbs_glGetFloatv              ( __GLcontext *gc, IN GLMSG_GETFLOATV *pMsg );
VOID * FASTCALL sbs_glGetIntegerv            ( __GLcontext *gc, IN GLMSG_GETINTEGERV *pMsg );
VOID * FASTCALL sbs_glGetLightfv             ( __GLcontext *gc, IN GLMSG_GETLIGHTFV *pMsg );
VOID * FASTCALL sbs_glGetLightiv             ( __GLcontext *gc, IN GLMSG_GETLIGHTIV *pMsg );
VOID * FASTCALL sbs_glGetMapdv               ( __GLcontext *gc, IN GLMSG_GETMAPDV *pMsg );
VOID * FASTCALL sbs_glGetMapfv               ( __GLcontext *gc, IN GLMSG_GETMAPFV *pMsg );
VOID * FASTCALL sbs_glGetMapiv               ( __GLcontext *gc, IN GLMSG_GETMAPIV *pMsg );
VOID * FASTCALL sbs_glGetMaterialfv          ( __GLcontext *gc, IN GLMSG_GETMATERIALFV *pMsg );
VOID * FASTCALL sbs_glGetMaterialiv          ( __GLcontext *gc, IN GLMSG_GETMATERIALIV *pMsg );
VOID * FASTCALL sbs_glGetPixelMapfv          ( __GLcontext *gc, IN GLMSG_GETPIXELMAPFV *pMsg );
VOID * FASTCALL sbs_glGetPixelMapuiv         ( __GLcontext *gc, IN GLMSG_GETPIXELMAPUIV *pMsg );
VOID * FASTCALL sbs_glGetPixelMapusv         ( __GLcontext *gc, IN GLMSG_GETPIXELMAPUSV *pMsg );
VOID * FASTCALL sbs_glGetPolygonStipple      ( __GLcontext *gc, IN GLMSG_GETPOLYGONSTIPPLE *pMsg );
VOID * FASTCALL sbs_glGetTexEnvfv            ( __GLcontext *gc, IN GLMSG_GETTEXENVFV *pMsg );
VOID * FASTCALL sbs_glGetTexEnviv            ( __GLcontext *gc, IN GLMSG_GETTEXENVIV *pMsg );
VOID * FASTCALL sbs_glGetTexGendv            ( __GLcontext *gc, IN GLMSG_GETTEXGENDV *pMsg );
VOID * FASTCALL sbs_glGetTexGenfv            ( __GLcontext *gc, IN GLMSG_GETTEXGENFV *pMsg );
VOID * FASTCALL sbs_glGetTexGeniv            ( __GLcontext *gc, IN GLMSG_GETTEXGENIV *pMsg );
VOID * FASTCALL sbs_glGetTexImage            ( __GLcontext *gc, IN GLMSG_GETTEXIMAGE *pMsg );
VOID * FASTCALL sbs_glGetTexParameterfv      ( __GLcontext *gc, IN GLMSG_GETTEXPARAMETERFV *pMsg );
VOID * FASTCALL sbs_glGetTexParameteriv      ( __GLcontext *gc, IN GLMSG_GETTEXPARAMETERIV *pMsg );
VOID * FASTCALL sbs_glGetTexLevelParameterfv ( __GLcontext *gc, IN GLMSG_GETTEXLEVELPARAMETERFV *pMsg );
VOID * FASTCALL sbs_glGetTexLevelParameteriv ( __GLcontext *gc, IN GLMSG_GETTEXLEVELPARAMETERIV *pMsg );
VOID * FASTCALL sbs_glIsEnabled              ( __GLcontext *gc, IN GLMSG_ISENABLED *pMsg );
VOID * FASTCALL sbs_glDepthRange             ( __GLcontext *gc, IN GLMSG_DEPTHRANGE *pMsg );
VOID * FASTCALL sbs_glFrustum                ( __GLcontext *gc, IN GLMSG_FRUSTUM *pMsg );
VOID * FASTCALL sbs_glLoadIdentity           ( __GLcontext *gc, IN GLMSG_LOADIDENTITY *pMsg );
VOID * FASTCALL sbs_glLoadMatrixf            ( __GLcontext *gc, IN GLMSG_LOADMATRIXF *pMsg );
VOID * FASTCALL sbs_glMatrixMode             ( __GLcontext *gc, IN GLMSG_MATRIXMODE *pMsg );
VOID * FASTCALL sbs_glMultMatrixf            ( __GLcontext *gc, IN GLMSG_MULTMATRIXF *pMsg );
VOID * FASTCALL sbs_glOrtho                  ( __GLcontext *gc, IN GLMSG_ORTHO *pMsg );
VOID * FASTCALL sbs_glPopMatrix              ( __GLcontext *gc, IN GLMSG_POPMATRIX *pMsg );
VOID * FASTCALL sbs_glPushMatrix             ( __GLcontext *gc, IN GLMSG_PUSHMATRIX *pMsg );
VOID * FASTCALL sbs_glRotatef                ( __GLcontext *gc, IN GLMSG_ROTATEF *pMsg );
VOID * FASTCALL sbs_glScalef                 ( __GLcontext *gc, IN GLMSG_SCALEF *pMsg );
VOID * FASTCALL sbs_glTranslatef             ( __GLcontext *gc, IN GLMSG_TRANSLATEF *pMsg );
VOID * FASTCALL sbs_glViewport               ( __GLcontext *gc, IN GLMSG_VIEWPORT *pMsg );
VOID * FASTCALL sbs_glAddSwapHintRectWIN     ( __GLcontext *gc, IN GLMSG_ADDSWAPHINTRECTWIN *pMsg );
VOID * FASTCALL sbs_glAreTexturesResident    ( __GLcontext *gc, IN GLMSG_ARETEXTURESRESIDENT    *pMsg);
VOID * FASTCALL sbs_glBindTexture            ( __GLcontext *gc, IN GLMSG_BINDTEXTURE            *pMsg);
VOID * FASTCALL sbs_glCopyTexImage1D         ( __GLcontext *gc, IN GLMSG_COPYTEXIMAGE1D         *pMsg);
VOID * FASTCALL sbs_glCopyTexImage2D         ( __GLcontext *gc, IN GLMSG_COPYTEXIMAGE2D         *pMsg);
VOID * FASTCALL sbs_glCopyTexSubImage1D      ( __GLcontext *gc, IN GLMSG_COPYTEXSUBIMAGE1D      *pMsg);
VOID * FASTCALL sbs_glCopyTexSubImage2D      ( __GLcontext *gc, IN GLMSG_COPYTEXSUBIMAGE2D      *pMsg);
VOID * FASTCALL sbs_glDeleteTextures         ( __GLcontext *gc, IN GLMSG_DELETETEXTURES         *pMsg);
VOID * FASTCALL sbs_glGenTextures            ( __GLcontext *gc, IN GLMSG_GENTEXTURES            *pMsg);
VOID * FASTCALL sbs_glIsTexture              ( __GLcontext *gc, IN GLMSG_ISTEXTURE              *pMsg);
VOID * FASTCALL sbs_glPrioritizeTextures     ( __GLcontext *gc, IN GLMSG_PRIORITIZETEXTURES     *pMsg);
VOID * FASTCALL sbs_glTexSubImage1D          ( __GLcontext *gc, IN GLMSG_TEXSUBIMAGE1D          *pMsg);
VOID * FASTCALL sbs_glTexSubImage2D          ( __GLcontext *gc, IN GLMSG_TEXSUBIMAGE2D          *pMsg);
VOID * FASTCALL sbs_glColorTableEXT          ( __GLcontext *, IN GLMSG_COLORTABLEEXT          *pMsg);
VOID * FASTCALL sbs_glColorSubTableEXT       ( __GLcontext *, IN GLMSG_COLORSUBTABLEEXT       *pMsg);
VOID * FASTCALL sbs_glGetColorTableEXT       ( __GLcontext *, IN GLMSG_GETCOLORTABLEEXT       *pMsg);
VOID * FASTCALL sbs_glGetColorTableParameterivEXT( __GLcontext *, IN GLMSG_GETCOLORTABLEPARAMETERIVEXT *pMsg);
VOID * FASTCALL sbs_glGetColorTableParameterfvEXT( __GLcontext *, IN GLMSG_GETCOLORTABLEPARAMETERFVEXT *pMsg);
VOID * FASTCALL sbs_glPolygonOffset          ( __GLcontext *gc, IN GLMSG_POLYGONOFFSET          *pMsg);
#ifdef GL_WIN_multiple_textures
VOID * FASTCALL sbs_glCurrentTextureIndexWIN ( __GLcontext *gc, IN GLMSG_CURRENTTEXTUREINDEXWIN *pMsg);
VOID * FASTCALL sbs_glBindNthTextureWIN      ( __GLcontext *gc, IN GLMSG_BINDNTHTEXTUREWIN *pMsg);
VOID * FASTCALL sbs_glNthTexCombineFuncWIN   ( __GLcontext *gc, IN GLMSG_NTHTEXCOMBINEFUNCWIN *pMsg);
#endif // GL_WIN_multiple_textures

#endif /* __GLSRVSB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\wgl\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stddef.h>
#include <string.h>

#include <wingdip.h>
#define _NO_DDRAWINT_NO_COM
#include <winddi.h>

#include <glp.h>
#include <gencx.h>
#include <fixed.h>
#include <batchinf.h>
#include <glteb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\wgl\glsrvspt.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

/* Server Side Procedure Table */

#include "precomp.h"
#pragma hdrstop

#include "glsbmsg.h"
#include "glsbmsgh.h"
#include "glsrvsb.h"
#include "glsrvspt.h"

GLSRVSBPROCTABLE glSrvSbProcTable = {

    NULL,  /* Make First Entry NULL */

/* gl Entry points */

     sbs_glDrawPolyArray          ,
     sbs_glBitmap                 ,
     sbs_glColor4fv               ,
     sbs_glEdgeFlag               ,
     sbs_glIndexf                 ,
     sbs_glNormal3fv              ,
     sbs_glRasterPos4fv           ,
     sbs_glTexCoord4fv            ,
     sbs_glClipPlane              ,
     sbs_glColorMaterial          ,
     sbs_glCullFace               ,
     sbs_glAddSwapHintRectWIN     ,
     sbs_glFogfv                  ,
     sbs_glFrontFace              ,
     sbs_glHint                   ,
     sbs_glLightfv                ,
     sbs_glLightModelfv           ,
     sbs_glLineStipple            ,
     sbs_glLineWidth              ,
     sbs_glMaterialfv             ,
     sbs_glPointSize              ,
     sbs_glPolygonMode            ,
     sbs_glPolygonStipple         ,
     sbs_glScissor                ,
     sbs_glShadeModel             ,
     sbs_glTexParameterfv         ,
     sbs_glTexParameteriv         ,
     sbs_glTexImage1D             ,
     sbs_glTexImage2D             ,
     sbs_glTexEnvfv               ,
     sbs_glTexEnviv               ,
     sbs_glTexGenfv               ,
     sbs_glFeedbackBuffer         ,
     sbs_glSelectBuffer           ,
     sbs_glRenderMode             ,
     sbs_glInitNames              ,
     sbs_glLoadName               ,
     sbs_glPassThrough            ,
     sbs_glPopName                ,
     sbs_glPushName               ,
     sbs_glDrawBuffer             ,
     sbs_glClear                  ,
     sbs_glClearAccum             ,
     sbs_glClearIndex             ,
     sbs_glClearColor             ,
     sbs_glClearStencil           ,
     sbs_glClearDepth             ,
     sbs_glStencilMask            ,
     sbs_glColorMask              ,
     sbs_glDepthMask              ,
     sbs_glIndexMask              ,
     sbs_glAccum                  ,
     sbs_glDisable                ,
     sbs_glEnable                 ,
     sbs_glPopAttrib              ,
     sbs_glPushAttrib             ,
     sbs_glAlphaFunc              ,
     sbs_glBlendFunc              ,
     sbs_glLogicOp                ,
     sbs_glStencilFunc            ,
     sbs_glStencilOp              ,
     sbs_glDepthFunc              ,
     sbs_glPixelZoom              ,
     sbs_glPixelTransferf         ,
     sbs_glPixelTransferi         ,
     sbs_glPixelStoref            ,
     sbs_glPixelStorei            ,
     sbs_glPixelMapfv             ,
     sbs_glPixelMapuiv            ,
     sbs_glPixelMapusv            ,
     sbs_glReadBuffer             ,
     sbs_glCopyPixels             ,
     sbs_glReadPixels             ,
     sbs_glDrawPixels             ,
     sbs_glGetBooleanv            ,
     sbs_glGetClipPlane           ,
     sbs_glGetDoublev             ,
     sbs_glGetError               ,
     sbs_glGetFloatv              ,
     sbs_glGetIntegerv            ,
     sbs_glGetLightfv             ,
     sbs_glGetLightiv             ,
     sbs_glGetMapdv               ,
     sbs_glGetMapfv               ,
     sbs_glGetMapiv               ,
     sbs_glGetMaterialfv          ,
     sbs_glGetMaterialiv          ,
     sbs_glGetPixelMapfv          ,
     sbs_glGetPixelMapuiv         ,
     sbs_glGetPixelMapusv         ,
     sbs_glGetPolygonStipple      ,
     sbs_glGetTexEnvfv            ,
     sbs_glGetTexEnviv            ,
     sbs_glGetTexGendv            ,
     sbs_glGetTexGenfv            ,
     sbs_glGetTexGeniv            ,
     sbs_glGetTexImage            ,
     sbs_glGetTexParameterfv      ,
     sbs_glGetTexParameteriv      ,
     sbs_glGetTexLevelParameterfv ,
     sbs_glGetTexLevelParameteriv ,
     sbs_glIsEnabled              ,
     sbs_glDepthRange             ,
     sbs_glFrustum                ,
     sbs_glLoadIdentity           ,
     sbs_glLoadMatrixf            ,
     sbs_glMatrixMode             ,
     sbs_glMultMatrixf            ,
     sbs_glOrtho                  ,
     sbs_glPopMatrix              ,
     sbs_glPushMatrix             ,
     sbs_glRotatef                ,
     sbs_glScalef                 ,
     sbs_glTranslatef             ,
     sbs_glViewport               ,
     sbs_glAreTexturesResident    ,
     sbs_glBindTexture            ,
     sbs_glCopyTexImage1D         ,
     sbs_glCopyTexImage2D         ,
     sbs_glCopyTexSubImage1D      ,
     sbs_glCopyTexSubImage2D      ,
     sbs_glDeleteTextures         ,
     sbs_glGenTextures            ,
     sbs_glIsTexture              ,
     sbs_glPrioritizeTextures     ,
     sbs_glTexSubImage1D          ,
     sbs_glTexSubImage2D          ,
     sbs_glColorTableEXT          ,
     sbs_glColorSubTableEXT       ,
     sbs_glGetColorTableEXT       ,
     sbs_glGetColorTableParameterivEXT,
     sbs_glGetColorTableParameterfvEXT,
     sbs_glPolygonOffset          ,
#ifdef GL_WIN_multiple_textures
     sbs_glCurrentTextureIndexWIN,
     sbs_glBindNthTextureWIN,
     sbs_glNthTexCombineFuncWIN,
#endif // GL_WIN_multiple_textures
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\3d.h ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
void	error(char *);
void	diff3(GLdouble [3], GLdouble [3], GLdouble [3]);
void	add3(GLdouble [3], GLdouble [3], GLdouble [3]);
void	scalarmult(GLdouble, GLdouble [3], GLdouble [3]);
GLdouble	dot3(GLdouble [3], GLdouble [3]);
GLdouble	length3(GLdouble [3]);
GLdouble	dist3(GLdouble [3], GLdouble [3]);
void	copy3(GLdouble [3], GLdouble [3]);
void	crossprod(GLdouble [3], GLdouble [3], GLdouble [3]);
void	normalize(GLdouble [3]);
void	print3(GLdouble [3]);
void	printmat3(GLdouble [3][3]);
void	identifymat3(GLdouble [3][3]);
void	copymat3(GLdouble *, GLdouble *);
void	xformvec3(GLdouble [3], GLdouble [3][3], GLdouble [3]);

void m_resetmatrixstack();
void m_xformpt(GLdouble [3], GLdouble [3], GLdouble [3], GLdouble [3]);
void m_xformptonly(GLdouble [3], GLdouble [3]);
void m_pushmatrix();
void m_popmatrix();
void m_shear(GLdouble, GLdouble, GLdouble);
void m_translate(GLdouble, GLdouble, GLdouble);
void m_scale(GLdouble, GLdouble, GLdouble);
void m_rotate(GLdouble, char);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\font.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <gl/glaux.h>
#include "tk.h"

#define static


static GLuint bitmapBase;
void APIENTRY auxDrawStrAW(LPCSTR str, BOOL bUnicode);

void auxCreateFont(void)
{
    bitmapBase = glGenLists(256);
    if (tkCreateBitmapFont(bitmapBase) == GL_FALSE) {
        auxQuit();
    }
}

void APIENTRY auxDrawStrA(LPCSTR str)
{
    auxDrawStrAW(str, FALSE);
}

void APIENTRY auxDrawStrW(LPCWSTR str)
{
    auxDrawStrAW((LPCSTR)str, TRUE);
}

void APIENTRY auxDrawStrAW(LPCSTR str, BOOL bUnicode)
{

    glPushAttrib(GL_LIST_BIT);
    glListBase(bitmapBase);
    if (bUnicode)
        glCallLists(wcslen((LPWSTR) str), GL_UNSIGNED_SHORT, str);
    else
	glCallLists(strlen(str), GL_UNSIGNED_BYTE, str);
    glPopAttrib();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\glaux.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <GL/gl.h>
#include <gl/glaux.h>
#include "tk.h"

#define static

#if defined(__cplusplus) || defined(c_plusplus)
#define class c_class
#endif


static struct {
    int keyField;
    void (*KeyFunc)(void);
} keyTable[200];

static struct {
    int mouseField;
    void (*MouseFunc)(AUX_EVENTREC *);
} mouseDownTable[20], mouseUpTable[20], mouseLocTable[20];

static int keyTableCount = 0;
static int mouseDownTableCount = 0;
static int mouseUpTableCount = 0;
static int mouseLocTableCount = 0;
static GLenum displayModeType = 0;
GLenum APIENTRY auxInitWindowAW(LPCSTR title, BOOL bUnicode);

static void DefaultHandleReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho((GLdouble)0.0, (GLdouble)w, (GLdouble)0.0, (GLdouble)h, (GLdouble)-1.0, (GLdouble)1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

static void DefaultHandleExpose(GLsizei w, GLsizei h)
{
}

static GLenum MouseLoc(int x, int y, GLenum button)
{
    AUX_EVENTREC info;
    GLenum flag;
    int i;

    flag = GL_FALSE;
    for (i = 0; i < mouseLocTableCount; i++) {
        if ((int)(button & AUX_LEFTBUTTON) == mouseLocTable[i].mouseField) {
	    info.event = AUX_MOUSELOC;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_LEFTBUTTON;
	    (*mouseLocTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_RIGHTBUTTON) == mouseLocTable[i].mouseField) {
	    info.event = AUX_MOUSELOC;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_RIGHTBUTTON;
	    (*mouseLocTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_MIDDLEBUTTON) == mouseLocTable[i].mouseField) {
	    info.event = AUX_MOUSELOC;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_MIDDLEBUTTON;
	    (*mouseLocTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
    }
    return flag;
}

static GLenum MouseUp(int x, int y, GLenum button)
{
    AUX_EVENTREC info;
    GLenum flag;
    int i;

    flag = GL_FALSE;
    for (i = 0; i < mouseUpTableCount; i++) {
        if ((int)(button & AUX_LEFTBUTTON) == mouseUpTable[i].mouseField) {
	    info.event = AUX_MOUSEUP;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_LEFTBUTTON;
	    (*mouseUpTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_RIGHTBUTTON) == mouseUpTable[i].mouseField) {
	    info.event = AUX_MOUSEUP;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_RIGHTBUTTON;
	    (*mouseUpTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_MIDDLEBUTTON) == mouseUpTable[i].mouseField) {
	    info.event = AUX_MOUSEUP;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_MIDDLEBUTTON;
	    (*mouseUpTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
    }
    return flag;
}

static GLenum MouseDown(int x, int y, GLenum button)
{
    AUX_EVENTREC info;
    GLenum flag;
    int i;

    flag = GL_FALSE;
    for (i = 0; i < mouseDownTableCount; i++) {
        if ((int)(button & AUX_LEFTBUTTON) == mouseDownTable[i].mouseField) {
	    info.event = AUX_MOUSEDOWN;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_LEFTBUTTON;
	    (*mouseDownTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_RIGHTBUTTON) == mouseDownTable[i].mouseField) {
	    info.event = AUX_MOUSEDOWN;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_RIGHTBUTTON;
	    (*mouseDownTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
        if ((int)(button & AUX_MIDDLEBUTTON) == mouseDownTable[i].mouseField) {
	    info.event = AUX_MOUSEDOWN;
	    info.data[AUX_MOUSEX] = x;
	    info.data[AUX_MOUSEY] = y;
	    info.data[AUX_MOUSESTATUS] = AUX_MIDDLEBUTTON;
	    (*mouseDownTable[i].MouseFunc)(&info);
	    flag |= GL_TRUE;
	}
    }
    return flag;
}

static GLenum KeyDown(int key, GLenum status)
{
    GLenum flag;
    int i;

    flag = GL_FALSE;
    if (keyTableCount) {
	for (i = 0; i < keyTableCount; i++) {
	    if (key == keyTable[i].keyField) {
		(*keyTable[i].KeyFunc)();
		flag |= GL_TRUE;
	    }
	}
    }
    return flag;
}

void auxExposeFunc(AUXEXPOSEPROC Func)
{
    tkExposeFunc(Func);
}

void auxReshapeFunc(AUXRESHAPEPROC Func)
{
    tkExposeFunc((void (*)(int, int))Func);
    tkReshapeFunc((void (*)(int, int))Func);
}

void auxIdleFunc(AUXIDLEPROC Func)
{
    tkIdleFunc(Func);
}

void auxKeyFunc(int key, AUXKEYPROC Func)
{
    keyTable[keyTableCount].keyField = key;
    keyTable[keyTableCount++].KeyFunc = Func;
}

void auxMouseFunc(int mouse, int mode, AUXMOUSEPROC Func)
{
    if (mode == AUX_MOUSEDOWN) {
	mouseDownTable[mouseDownTableCount].mouseField = mouse;
	mouseDownTable[mouseDownTableCount++].MouseFunc = Func;
    } else if (mode == AUX_MOUSEUP) {
	mouseUpTable[mouseUpTableCount].mouseField = mouse;
	mouseUpTable[mouseUpTableCount++].MouseFunc = Func;
    } else if (mode == AUX_MOUSELOC) {
	mouseLocTable[mouseLocTableCount].mouseField = mouse;
	mouseLocTable[mouseLocTableCount++].MouseFunc = Func;
    } 
}

void auxMainLoop(AUXMAINPROC Func)
{
    tkDisplayFunc(Func);
    tkExec();
}

void auxInitPosition(int x, int y, int width, int height)
{
    tkInitPosition(x, y, width, height);
}

void auxInitDisplayMode(GLenum type)
{
    displayModeType = type;
    tkInitDisplayMode(type);
}

void auxInitDisplayModePolicy(GLenum type)
{
    tkInitDisplayModePolicy(type);
}

GLenum auxInitDisplayModeID(GLint id)
{
    return tkInitDisplayModeID(id);
}

GLenum APIENTRY auxInitWindowA(LPCSTR title)
{
    return auxInitWindowAW(title,FALSE);
}

GLenum APIENTRY auxInitWindowW(LPCWSTR title)
{
    return auxInitWindowAW((LPCSTR)title,TRUE);
}

GLenum APIENTRY auxInitWindowAW(LPCSTR title, BOOL bUnicode)
{
    int useDoubleAsSingle = 0;

    if (tkInitWindowAW((char *)title, bUnicode) == GL_FALSE) {
	if (AUX_WIND_IS_SINGLE(displayModeType)) {
	    tkInitDisplayMode(displayModeType | AUX_DOUBLE);
	    if (tkInitWindowAW((char *)title, bUnicode) == GL_FALSE) {
		return GL_FALSE;    /*  curses, foiled again	*/
            }
            MESSAGEBOX(GetFocus(), "Can't initialize a single buffer visual. "
                                   "Will use a double buffer visual instead, "
                                   "only drawing into the front buffer.",
                                   "Warning", MB_OK);
	    displayModeType = displayModeType | AUX_DOUBLE;
	    useDoubleAsSingle = 1;
	}
    }
    tkReshapeFunc((void (*)(int, int))DefaultHandleReshape);
    tkExposeFunc((void (*)(int, int))DefaultHandleExpose);
    tkMouseUpFunc(MouseUp);
    tkMouseDownFunc(MouseDown);
    tkMouseMoveFunc(MouseLoc);
    tkKeyDownFunc(KeyDown);
    auxKeyFunc(AUX_ESCAPE, auxQuit);
    glClearColor((GLclampf)0.0, (GLclampf)0.0, (GLclampf)0.0, (GLclampf)1.0);
    glClearIndex((GLfloat)0.0);
    glLoadIdentity();
    if (useDoubleAsSingle)
	glDrawBuffer(GL_FRONT);
    return GL_TRUE;
}

void auxCloseWindow(void)
{
    tkCloseWindow();
    keyTableCount = 0;
    mouseDownTableCount = 0;
    mouseUpTableCount = 0;
    mouseLocTableCount = 0;
}

void auxQuit(void)
{
    tkQuit();
}

void auxSwapBuffers(void)
{
    tkSwapBuffers();
}

HWND auxGetHWND(void)
{
    return tkGetHWND();
}

HDC auxGetHDC(void)
{
    return tkGetHDC();
}

HGLRC auxGetHGLRC(void)
{
    return tkGetHRC();
}

GLenum auxGetDisplayModePolicy(void)
{
    return tkGetDisplayModePolicy();
}

GLint auxGetDisplayModeID(void)
{
    return tkGetDisplayModeID();
}

GLenum auxGetDisplayMode(void)
{
    return tkGetDisplayMode();
}

void auxSetOneColor(int index, float r, float g, float b)
{
    tkSetOneColor(index, r, g, b);
}

void auxSetFogRamp(int density, int startIndex)
{
    tkSetFogRamp(density, startIndex);
}

void auxSetGreyRamp(void)
{
    tkSetGreyRamp();
}

void auxSetRGBMap(int size, float *rgb)
{
    tkSetRGBMap(size, rgb);
}

int auxGetColorMapSize(void)
{
    return tkGetColorMapSize();
}

void auxGetMouseLoc(int *x, int *y)
{
    tkGetMouseLoc(x, y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\teapot.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <GL/gl.h>
#include <gl/glaux.h>
#include "teapot.h"

#define static

long GRD;

#define TEAPOTSOLID 0
#define TEAPOTWIRE 1

static GLuint teapots[2] = {0, 0};

static float tex[2][2][2] = {{{0, 0},{1, 0}},{{0, 1},{1, 1}}};

static void solidTeapot(long grid, GLdouble scale)
{
    float p[4][4][3], q[4][4][3], r[4][4][3], s[4][4][3];
    long i, j, k, l;

    if (grid < 2) grid = 7;
    GRD = grid;
    teapots[TEAPOTSOLID] = glGenLists (1);
    glNewList(teapots[TEAPOTSOLID], GL_COMPILE);
    glPushMatrix ();
    glRotatef ((GLfloat)270.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0);
    glScalef ((GLdouble)0.5*scale, (GLdouble)0.5*scale, (GLdouble)0.5*scale);
    glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.5);
    for (i = 0; i < 10; i++) {
	for (j = 0; j < 4; j++)
	    for (k = 0; k < 4; k++) 
		for (l = 0; l < 3; l++) {
		    p[j][k][l] = cpdata[patchdata[i][j*4+k]][l];
		    q[j][k][l] = cpdata[patchdata[i][j*4+(3-k)]][l];
		    if (l == 1) q[j][k][l] *= (float)-1.0;
		    if (i < 6) {
			r[j][k][l] = cpdata[patchdata[i][j*4+(3-k)]][l];
			if (l == 0) r[j][k][l] *= (float)-1.0;
			s[j][k][l] = cpdata[patchdata[i][j*4+k]][l];
			if (l == 0) s[j][k][l] *= (float)-1.0;
			if (l == 1) s[j][k][l] *= (float)-1.0;
		    }
		}
	glMap2f(GL_MAP2_TEXTURE_COORD_2, 0, 1, 2, 2, 0, 1, 4, 2, &tex[0][0][0]);
	glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &p[0][0][0]);
	glEnable(GL_MAP2_VERTEX_3); glEnable(GL_MAP2_TEXTURE_COORD_2);
	glMapGrid2f(GRD, (GLfloat)0.0, (GLfloat)1.0, GRD, (GLfloat)0.0, (GLfloat)1.0);
	glEvalMesh2(GL_FILL, 0, GRD, 0, GRD);
	glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &q[0][0][0]);
	glEvalMesh2(GL_FILL, 0, GRD, 0, GRD);
	if (i < 6) {
	    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &r[0][0][0]);
	    glEvalMesh2(GL_FILL, 0, GRD, 0, GRD);
	    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &s[0][0][0]);
	    glEvalMesh2(GL_FILL, 0, GRD, 0, GRD);
	}
    }
    glDisable(GL_MAP2_VERTEX_3); glDisable(GL_MAP2_TEXTURE_COORD_2);
    glPopMatrix ();
    glEndList();
}

static void wireTeapot(long grid, GLdouble scale)
{
    float p[4][4][3], q[4][4][3], r[4][4][3], s[4][4][3];
    long i, j, k, l;
    
    if (grid < 2) grid = 7;
    GRD = grid;
    teapots[TEAPOTWIRE] = glGenLists (1);
    glNewList(teapots[TEAPOTWIRE], GL_COMPILE);
    glPushMatrix ();
    glRotatef ((GLfloat)270.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0);
    glScalef ((GLdouble)0.5*scale, (GLdouble)0.5*scale, (GLdouble)0.5*scale);
    glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.5);
    for (i = 0; i < 10; i++) {
	for (j = 0; j < 4; j++)
	    for (k = 0; k < 4; k++) 
		for (l = 0; l < 3; l++) {
		    p[j][k][l] = cpdata[patchdata[i][j*4+k]][l];
		    q[j][k][l] = cpdata[patchdata[i][j*4+(3-k)]][l];
		    if (l == 1) q[j][k][l] *= (float)-1.0;
		    if (i < 6) {
			r[j][k][l] = cpdata[patchdata[i][j*4+(3-k)]][l];
			if (l == 0) r[j][k][l] *= (float)-1.0;
			s[j][k][l] = cpdata[patchdata[i][j*4+k]][l];
			if (l == 0) s[j][k][l] *= (float)-1.0;
			if (l == 1) s[j][k][l] *= (float)-1.0;
		    }
		}
	glMap2f(GL_MAP2_TEXTURE_COORD_2, 0, 1, 2, 2, 0, 1, 4, 2, &tex[0][0][0]);
	glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &p[0][0][0]);
	glEnable(GL_MAP2_VERTEX_3); glEnable(GL_MAP2_TEXTURE_COORD_2);
	glMapGrid2f(GRD, (GLfloat)0.0, (GLfloat)1.0, GRD, (GLfloat)0.0, (GLfloat)1.0);
	glEvalMesh2(GL_LINE, 0, GRD, 0, GRD);
	glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &q[0][0][0]);
	glEvalMesh2(GL_LINE, 0, GRD, 0, GRD);
	if (i < 6) {
	    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &r[0][0][0]);
	    glEvalMesh2(GL_LINE, 0, GRD, 0, GRD);
	    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &s[0][0][0]);
	    glEvalMesh2(GL_LINE, 0, GRD, 0, GRD);
	}
    }
    glDisable(GL_MAP2_VERTEX_3); glDisable(GL_MAP2_TEXTURE_COORD_2);
    glPopMatrix ();
    glEndList();
}

void auxSolidTeapot(GLdouble scale)
{
    if (glIsList(teapots[TEAPOTSOLID]) == 0)
	solidTeapot (14, scale);
    glCallList(teapots[TEAPOTSOLID]);
}

void auxWireTeapot(GLdouble scale)
{
    if (glIsList(teapots[TEAPOTWIRE]) == 0)
	wireTeapot (10, scale);
    glCallList(teapots[TEAPOTWIRE]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\shapes.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <gl/glaux.h>
#include "3d.h"

#define static

#define SPHEREWIRE      0
#define CUBEWIRE        1
#define BOXWIRE         2
#define TORUSWIRE       3
#define CYLINDERWIRE    4
#define ICOSAWIRE       5
#define OCTAWIRE        6
#define TETRAWIRE       7
#define DODECAWIRE      8
#define CONEWIRE        9
#define SPHERESOLID     10
#define CUBESOLID       11
#define BOXSOLID        12
#define TORUSSOLID      13
#define CYLINDERSOLID   14
#define ICOSASOLID      15
#define OCTASOLID       16
#define TETRASOLID      17
#define DODECASOLID     18
#define CONESOLID       19

#define PI ((GLdouble)3.1415926535897)

/*      structure for each geometric object     */
typedef struct model {
    GLuint list;        /*  display list to render object   */
    struct model *ptr;  /*  pointer to next object      */
    int numParam;       /*  # of parameters             */
    GLdouble *params;   /*  array with parameters       */
} MODEL, *MODELPTR;

/*      array of linked lists--used to keep track of display lists
 *      for each different type of geometric object.
 */
static MODELPTR lists[25] = {
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL
};

GLuint findList (int index, GLdouble *paramArray, int size);
int compareParams (GLdouble *oneArray, GLdouble *twoArray, int size);
GLuint makeModelPtr (int index, GLdouble *sizeArray, int count);

static void drawbox(GLdouble, GLdouble, GLdouble,
        GLdouble, GLdouble, GLdouble, GLenum);
static void doughnut(GLdouble, GLdouble, GLint, GLint, GLenum);
static void icosahedron(GLdouble *, GLdouble, GLenum);
static void octahedron(GLdouble *, GLdouble, GLenum);
static void tetrahedron(GLdouble *, GLdouble, GLenum);
static void subdivide(int, GLdouble *, GLdouble *, GLdouble *,
        GLdouble *, GLdouble, GLenum, int);
static void drawtriangle(int, int, int,
        GLdouble *, GLdouble, GLenum, int);
static void recorditem(GLdouble *, GLdouble *, GLdouble *,
        GLdouble *, GLdouble, GLenum, int);
static void initdodec(void);
static void dodecahedron(GLdouble *, GLdouble, GLenum);
static void pentagon(int, int, int, int, int, GLenum);


/*  Render wire frame or solid sphere.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireSphere (GLdouble radius)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (SPHEREWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (SPHEREWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_LINE);
            gluSphere (quadObj, radius, 16, 16);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidSphere (GLdouble radius)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (SPHERESOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (SPHERESOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_FILL);
            gluQuadricNormals (quadObj, GLU_SMOOTH);
            gluSphere (quadObj, radius, 16, 16);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid cube.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireCube (GLdouble size)
{
    GLdouble *sizeArray;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = size;
    displayList = findList (CUBEWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (CUBEWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            drawbox(-size/(GLdouble)2., size/(GLdouble)2., -size/(GLdouble)2., size/(GLdouble)2.,
                -size/(GLdouble)2., size/(GLdouble)2., GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidCube (GLdouble size)
{
    GLdouble *sizeArray;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = size;
    displayList = findList (CUBESOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (CUBESOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            drawbox(-size/(GLdouble)2., size/(GLdouble)2., -size/(GLdouble)2., size/(GLdouble)2.,
                -size/(GLdouble)2., size/(GLdouble)2., GL_QUADS);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid cube.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireBox (GLdouble width, GLdouble height, GLdouble depth)
{
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 3);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = width;
    *tmp++ = height;
    *tmp++ = depth;
    displayList = findList (BOXWIRE, sizeArray, 3);

    if (displayList == 0) {
        glNewList(makeModelPtr (BOXWIRE, sizeArray, 3),
            GL_COMPILE_AND_EXECUTE);
            drawbox(-width/(GLdouble)2., width/(GLdouble)2., -height/(GLdouble)2., height/(GLdouble)2.,
                -depth/(GLdouble)2., depth/(GLdouble)2., GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidBox (GLdouble width, GLdouble height, GLdouble depth)
{
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 3);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = width;
    *tmp++ = height;
    *tmp++ = depth;
    displayList = findList (BOXSOLID, sizeArray, 3);

    if (displayList == 0) {
        glNewList(makeModelPtr (BOXSOLID, sizeArray, 3),
            GL_COMPILE_AND_EXECUTE);
            drawbox(-width/(GLdouble)2., width/(GLdouble)2., -height/(GLdouble)2., height/(GLdouble)2.,
                -depth/(GLdouble)2., depth/(GLdouble)2., GL_QUADS);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid tori.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireTorus (GLdouble innerRadius, GLdouble outerRadius)
{
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = innerRadius;
    *tmp++ = outerRadius;
    displayList = findList (TORUSWIRE, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (TORUSWIRE, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            doughnut(innerRadius, outerRadius, 5, 10, GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidTorus (GLdouble innerRadius, GLdouble outerRadius)
{
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = innerRadius;
    *tmp++ = outerRadius;
    displayList = findList (TORUSSOLID, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (TORUSSOLID, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            doughnut(innerRadius, outerRadius, 8, 15, GL_QUADS);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid cylinders.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireCylinder (GLdouble radius, GLdouble height)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = radius;
    *tmp++ = height;
    displayList = findList (CYLINDERWIRE, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (CYLINDERWIRE, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            glPushMatrix ();
            glRotatef ((GLfloat)90.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0);
            glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.0);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_LINE);
            gluCylinder (quadObj, radius, radius, height, 12, 2);
            glPopMatrix ();
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidCylinder (GLdouble radius, GLdouble height)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = radius;
    *tmp++ = height;
    displayList = findList (CYLINDERWIRE, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (CYLINDERWIRE, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            glPushMatrix ();
            glRotatef ((GLfloat)90.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0);
            glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.0);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_FILL);
            gluQuadricNormals (quadObj, GLU_SMOOTH);
            gluCylinder (quadObj, radius, radius, height, 12, 2);
            glPopMatrix ();
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid icosahedra.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireIcosahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (ICOSAWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (ICOSAWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            icosahedron (center, radius, GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidIcosahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (ICOSASOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (ICOSASOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            icosahedron (center, radius, GL_TRIANGLES);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid octahedra.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireOctahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (OCTAWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (OCTAWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            octahedron (center, radius, GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidOctahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (OCTASOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (OCTASOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            octahedron (center, radius, GL_TRIANGLES);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid tetrahedra.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireTetrahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (TETRAWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (TETRAWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            tetrahedron (center, radius, GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidTetrahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (TETRASOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (TETRASOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            tetrahedron (center, radius, GL_TRIANGLES);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid dodecahedra.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireDodecahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (DODECAWIRE, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (DODECAWIRE, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            dodecahedron (center, radius/(GLdouble)1.73, GL_LINE_LOOP);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidDodecahedron (GLdouble radius)
{
    GLdouble *sizeArray;
    GLuint displayList;
    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0};

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1);
    if (!sizeArray)
        return;
    *sizeArray = radius;
    displayList = findList (DODECASOLID, sizeArray, 1);

    if (displayList == 0) {
        glNewList(makeModelPtr (DODECASOLID, sizeArray, 1),
            GL_COMPILE_AND_EXECUTE);
            dodecahedron (center, radius/(GLdouble)1.73, GL_POLYGON);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/*  Render wire frame or solid cones.  If no display list with
 *  the current model size exists, create a new display list.
 */
void auxWireCone (GLdouble base, GLdouble height)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = base;
    *tmp++ = height;
    displayList = findList (CONEWIRE, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (CONEWIRE, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_LINE);
            gluCylinder (quadObj, base, (GLdouble)0.0, height, 15, 10);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

void auxSolidCone (GLdouble base, GLdouble height)
{
    GLUquadricObj *quadObj;
    GLdouble *sizeArray, *tmp;
    GLuint displayList;

    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2);
    if (!sizeArray)
        return;
    tmp = sizeArray;
    *tmp++ = base;
    *tmp++ = height;
    displayList = findList (CONEWIRE, sizeArray, 2);

    if (displayList == 0) {
        glNewList(makeModelPtr (CONEWIRE, sizeArray, 2),
            GL_COMPILE_AND_EXECUTE);
            quadObj = gluNewQuadric ();
            gluQuadricDrawStyle (quadObj, GLU_FILL);
            gluQuadricNormals (quadObj, GLU_SMOOTH);
            gluCylinder (quadObj, base, (GLdouble)0.0, height, 15, 10);
        glEndList();
    }
    else {
        glCallList(displayList);
        free (sizeArray);
    }
}

/* Routines to build 3 dimensional solids, including:
 *
 * drawbox, doughnut, icosahedron,
 * octahedron, tetrahedron, dodecahedron.
 */

/* drawbox:
 *
 * draws a rectangular box with the given x, y, and z ranges.
 * The box is axis-aligned.
 */
void drawbox(GLdouble x0, GLdouble x1, GLdouble y0, GLdouble y1,
        GLdouble z0, GLdouble z1, GLenum type)
{
    static GLdouble n[6][3] = {
        {-1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {1.0, 0.0, 0.0},
        {0.0, -1.0, 0.0}, {0.0, 0.0, 1.0}, {0.0, 0.0, -1.0}
    };
    static GLint faces[6][4] = {
        { 0, 1, 2, 3 }, { 3, 2, 6, 7 }, { 7, 6, 5, 4 },
        { 4, 5, 1, 0 }, { 5, 6, 2, 1 }, { 7, 4, 0, 3 }
    };
    GLdouble v[8][3], tmp;
    GLint i;

    if (x0 > x1) {
        tmp = x0; x0 = x1; x1 = tmp;
    }
    if (y0 > y1) {
        tmp = y0; y0 = y1; y1 = tmp;
    }
    if (z0 > z1) {
        tmp = z0; z0 = z1; z1 = tmp;
    }
    v[0][0] = v[1][0] = v[2][0] = v[3][0] = x0;
    v[4][0] = v[5][0] = v[6][0] = v[7][0] = x1;
    v[0][1] = v[1][1] = v[4][1] = v[5][1] = y0;
    v[2][1] = v[3][1] = v[6][1] = v[7][1] = y1;
    v[0][2] = v[3][2] = v[4][2] = v[7][2] = z0;
    v[1][2] = v[2][2] = v[5][2] = v[6][2] = z1;

    for (i = 0; i < 6; i++) {
        glBegin(type);
        glNormal3dv(&n[i][0]);
        glVertex3dv(&v[faces[i][0]][0]);
        glNormal3dv(&n[i][0]);
        glVertex3dv(&v[faces[i][1]][0]);
        glNormal3dv(&n[i][0]);
        glVertex3dv(&v[faces[i][2]][0]);
        glNormal3dv(&n[i][0]);
        glVertex3dv(&v[faces[i][3]][0]);
        glEnd();
    }
}

/* doughnut:
 *
 * draws a doughnut, centered at (0, 0, 0) whose axis is aligned with
 * the z-axis.  The doughnut's major radius is R, and minor radius is r.
 */

void doughnut(GLdouble r, GLdouble R, GLint nsides, GLint rings, GLenum type)
{
    int i, j;
    GLdouble    theta, phi, theta1, phi1;
    GLdouble    p0[03], p1[3], p2[3], p3[3];
    GLdouble    n0[3], n1[3], n2[3], n3[3];

    for (i = 0; i < rings; i++) {
        theta = (GLdouble)i*(GLdouble)2.0*PI/rings;
        theta1 = (GLdouble)(i+1)*(GLdouble)2.0*PI/rings;
        for (j = 0; j < nsides; j++) {
            phi = (GLdouble)j*(GLdouble)2.0*PI/nsides;
            phi1 = (GLdouble)(j+1)*(GLdouble)2.0*PI/nsides;

            p0[0] = cos(theta)*(R + r*cos(phi));
            p0[1] = -sin(theta)*(R + r*cos(phi));
            p0[2] = r*sin(phi);

            p1[0] = cos(theta1)*(R + r*cos(phi));
            p1[1] = -sin(theta1)*(R + r*cos(phi));
            p1[2] = r*sin(phi);

            p2[0] = cos(theta1)*(R + r*cos(phi1));
            p2[1] = -sin(theta1)*(R + r*cos(phi1));
            p2[2] = r*sin(phi1);

            p3[0] = cos(theta)*(R + r*cos(phi1));
            p3[1] = -sin(theta)*(R + r*cos(phi1));
            p3[2] = r*sin(phi1);

            n0[0] = cos(theta)*(cos(phi));
            n0[1] = -sin(theta)*(cos(phi));
            n0[2] = sin(phi);

            n1[0] = cos(theta1)*(cos(phi));
            n1[1] = -sin(theta1)*(cos(phi));
            n1[2] = sin(phi);

            n2[0] = cos(theta1)*(cos(phi1));
            n2[1] = -sin(theta1)*(cos(phi1));
            n2[2] = sin(phi1);

            n3[0] = cos(theta)*(cos(phi1));
            n3[1] = -sin(theta)*(cos(phi1));
            n3[2] = sin(phi1);

            m_xformpt(p0, p0, n0, n0);
            m_xformpt(p1, p1, n1, n1);
            m_xformpt(p2, p2, n2, n2);
            m_xformpt(p3, p3, n3, n3);

            glBegin(type);
                glNormal3dv(n3);
                glVertex3dv(p3);
                glNormal3dv(n2);
                glVertex3dv(p2);
                glNormal3dv(n1);
                glVertex3dv(p1);
                glNormal3dv(n0);
                glVertex3dv(p0);
            glEnd();
        }
    }
}

/* octahedron data: The octahedron produced is centered
 * at the origin and has radius 1.0
 */
static GLdouble odata[6][3] = {
  {1.0, 0.0, 0.0},
  {-1.0, 0.0, 0.0},
  {0.0, 1.0, 0.0},
  {0.0, -1.0, 0.0},
  {0.0, 0.0, 1.0},
  {0.0, 0.0, -1.0}
};

static int ondex[8][3] = {
    {0, 4, 2}, {1, 2, 4}, {0, 3, 4}, {1, 4, 3},
    {0, 2, 5}, {1, 5, 2}, {0, 5, 3}, {1, 3, 5}
};

/* tetrahedron data: */

#define T       1.73205080756887729

static GLdouble tdata[4][3] = {
    {T, T, T}, {T, -T, -T}, {-T, T, -T}, {-T, -T, T}
};

static int tndex[4][3] = {
    {0, 1, 3}, {2, 1, 0}, {3, 2, 0}, {1, 2, 3}
};

/* icosahedron data: These numbers are rigged to
 * make an icosahedron of radius 1.0
 */

#define X .525731112119133606
#define Z .850650808352039932

static GLdouble idata[12][3] = {
  {-X, 0, Z},
  {X, 0, Z},
  {-X, 0, -Z},
  {X, 0, -Z},
  {0, Z, X},
  {0, Z, -X},
  {0, -Z, X},
  {0, -Z, -X},
  {Z, X, 0},
  {-Z, X, 0},
  {Z, -X, 0},
  {-Z, -X, 0}
};

static int index[20][3] = {
    {0, 4, 1},    {0, 9, 4},
    {9, 5, 4},    {4, 5, 8},
    {4, 8, 1},    {8, 10, 1},
    {8, 3, 10},    {5, 3, 8},
    {5, 2, 3},    {2, 7, 3},
    {7, 10, 3},    {7, 6, 10},
    {7, 11, 6},    {11, 0, 6},
    {0, 1, 6},    {6, 1, 10},
    {9, 0, 11},    {9, 11, 2},
    {9, 2, 5},    {7, 2, 11},
};

/* icosahedron:
 *
 * Draws an icosahedron with center at p0 having the
 * given radius.
 */

static void icosahedron(GLdouble p0[3], GLdouble radius, GLenum shadeType)
{
    int i;

    for (i = 0; i < 20; i++)
        drawtriangle(i, 0, 1, p0, radius, shadeType, 0);
}

/* octahedron:
 *
 * Draws an octahedron with center at p0 having the
 * given radius.
 */
static void octahedron(GLdouble p0[3], GLdouble radius, GLenum shadeType)
{
    int i;

    for (i = 0; i < 8; i++)
        drawtriangle(i, 1, 1, p0, radius, shadeType, 0);
}

/* tetrahedron:
 *
 * Draws an tetrahedron with center at p0 having the
 * given radius.
 */

static void tetrahedron(GLdouble p0[3], GLdouble radius, GLenum shadeType)
{
    int i;

    for (i = 0; i < 4; i++)
        drawtriangle(i, 2, 1, p0, radius, shadeType, 0);
}

static void subdivide(int depth, GLdouble *v0, GLdouble *v1, GLdouble *v2,
        GLdouble p0[3], GLdouble radius, GLenum shadeType, int avnormal)
{
    GLdouble w0[3], w1[3], w2[3];
    GLdouble l;
    int i, j, k, n;

    for (i = 0; i < depth; i++)
        for (j = 0; i + j < depth; j++) {
            k = depth - i - j;
            for (n = 0; n < 3; n++) {
                w0[n] = (i*v0[n] + j*v1[n] + k*v2[n])/depth;
                w1[n] = ((i+1)*v0[n] + j*v1[n] + (k-1)*v2[n])/depth;
                w2[n] = (i*v0[n] + (j+1)*v1[n] + (k-1)*v2[n])/depth;
            }
            l = sqrt(w0[0]*w0[0] + w0[1]*w0[1] + w0[2]*w0[2]);
            w0[0] /= l; w0[1] /= l; w0[2] /= l;
            l = sqrt(w1[0]*w1[0] + w1[1]*w1[1] + w1[2]*w1[2]);
            w1[0] /= l; w1[1] /= l; w1[2] /= l;
            l = sqrt(w2[0]*w2[0] + w2[1]*w2[1] + w2[2]*w2[2]);
            w2[0] /= l; w2[1] /= l; w2[2] /= l;
            recorditem(w1, w0, w2, p0, radius, shadeType, avnormal);
        }
    for (i = 0; i < depth-1; i++)
        for (j = 0; i + j < depth-1; j++) {
            k = depth - i - j;
            for (n = 0; n < 3; n++) {
                w0[n] = ((i+1)*v0[n] + (j+1)*v1[n] + (k-2)*v2[n])/depth;
                w1[n] = ((i+1)*v0[n] + j*v1[n] + (k-1)*v2[n])/depth;
                w2[n] = (i*v0[n] + (j+1)*v1[n] + (k-1)*v2[n])/depth;
            }
            l = sqrt(w0[0]*w0[0] + w0[1]*w0[1] + w0[2]*w0[2]);
            w0[0] /= l; w0[1] /= l; w0[2] /= l;
            l = sqrt(w1[0]*w1[0] + w1[1]*w1[1] + w1[2]*w1[2]);
            w1[0] /= l; w1[1] /= l; w1[2] /= l;
            l = sqrt(w2[0]*w2[0] + w2[1]*w2[1] + w2[2]*w2[2]);
            w2[0] /= l; w2[1] /= l; w2[2] /= l;
            recorditem(w0, w1, w2, p0, radius, shadeType, avnormal);
        }
}

static void drawtriangle(int i, int geomType, int depth,
        GLdouble p0[3], GLdouble radius, GLenum shadeType, int avnormal)
{
    GLdouble *x0, *x1, *x2;

    switch (geomType) {
        case 0: /* icosahedron */
            x0 = &idata[index[i][0]][0];
            x1 = &idata[index[i][1]][0];
            x2 = &idata[index[i][2]][0];
            break;
        case 1: /* octahedron */
            x0 = &odata[ondex[i][0]][0];
            x1 = &odata[ondex[i][1]][0];
            x2 = &odata[ondex[i][2]][0];
            break;
        case 2: /* tetrahedron */
            x0 = &tdata[tndex[i][0]][0];
            x1 = &tdata[tndex[i][1]][0];
            x2 = &tdata[tndex[i][2]][0];
            break;
    }
    subdivide(depth, x0, x1, x2, p0, radius, shadeType, avnormal);
}

static void recorditem(GLdouble *n1, GLdouble *n2, GLdouble *n3,
        GLdouble center[3], GLdouble radius, GLenum shadeType, int avnormal)
{
    GLdouble p1[3], p2[3], p3[3], q0[3], q1[3], n11[3], n22[3], n33[3];
    int i;

    for (i = 0; i < 3; i++) {
        p1[i] = n1[i]*radius + center[i];
        p2[i] = n2[i]*radius + center[i];
        p3[i] = n3[i]*radius + center[i];
    }
    if (avnormal == 0) {
        diff3(p1, p2, q0);
        diff3(p2, p3, q1);
        crossprod(q0, q1, q1);
        normalize(q1);
        m_xformpt(p1, p1, q1, n11);
        m_xformptonly(p2, p2);
        m_xformptonly(p3, p3);

        glBegin (shadeType);
        glNormal3dv(n11);
        glVertex3dv(p1);
        glVertex3dv(p2);
        glVertex3dv(p3);
        glEnd();
        return;
    }
    m_xformpt(p1, p1, n1, n11);
    m_xformpt(p2, p2, n2, n22);
    m_xformpt(p3, p3, n3, n33);

    glBegin (shadeType);
    glNormal3dv(n11);
    glVertex3dv(p1);
    glNormal3dv(n22);
    glVertex3dv(p2);
    glNormal3dv(n33);
    glVertex3dv(p3);
    glEnd();
}

static GLdouble dodec[20][3];

static void initdodec()
{
    GLdouble alpha, beta;

    alpha = sqrt((double)2.0/((double)3.0 + sqrt((double)5.0)));
    beta = (double)1.0 + sqrt((double)6.0/((double)3.0 + sqrt((double)5.0)) - (double)2.0 + (double)2.0*sqrt((double)2.0/((double)3.0 +
                                                            sqrt((double)5.0))));
    dodec[0][0] = -alpha; dodec[0][1] = 0; dodec[0][2] = beta;
    dodec[1][0] = alpha; dodec[1][1] = 0; dodec[1][2] = beta;
    dodec[2][0] = -1; dodec[2][1] = -1; dodec[2][2] = -1;
    dodec[3][0] = -1; dodec[3][1] = -1; dodec[3][2] = 1;
    dodec[4][0] = -1; dodec[4][1] = 1; dodec[4][2] = -1;
    dodec[5][0] = -1; dodec[5][1] = 1; dodec[5][2] = 1;
    dodec[6][0] = 1; dodec[6][1] = -1; dodec[6][2] = -1;
    dodec[7][0] = 1; dodec[7][1] = -1; dodec[7][2] = 1;
    dodec[8][0] = 1; dodec[8][1] = 1; dodec[8][2] = -1;
    dodec[9][0] = 1; dodec[9][1] = 1; dodec[9][2] = 1;
    dodec[10][0] = beta; dodec[10][1] = alpha; dodec[10][2] = 0;
    dodec[11][0] = beta; dodec[11][1] = -alpha; dodec[11][2] = 0;
    dodec[12][0] = -beta; dodec[12][1] = alpha; dodec[12][2] = 0;
    dodec[13][0] = -beta; dodec[13][1] = -alpha; dodec[13][2] = 0;
    dodec[14][0] = -alpha; dodec[14][1] = 0; dodec[14][2] = -beta;
    dodec[15][0] = alpha; dodec[15][1] = 0; dodec[15][2] = -beta;
    dodec[16][0] = 0; dodec[16][1] = beta; dodec[16][2] = alpha;
    dodec[17][0] = 0; dodec[17][1] = beta; dodec[17][2] = -alpha;
    dodec[18][0] = 0; dodec[18][1] = -beta; dodec[18][2] = alpha;
    dodec[19][0] = 0; dodec[19][1] = -beta; dodec[19][2] = -alpha;
}

/* dodecahedron:
 *
 * Draws an dodecahedron with center at 0.0. The radius
 * is sqrt(3).
 */
static void dodecahedron(GLdouble center[3], GLdouble sc, GLenum type)
{
    static int inited = 0;

    if ( inited == 0) {
        inited = 1;
        initdodec();
    }
    m_pushmatrix();
    m_translate(center[0], center[1], center[2]);
    m_scale(sc, sc, sc);
    pentagon(0, 1, 9, 16, 5, type);
    pentagon(1, 0, 3, 18, 7, type);
    pentagon(1, 7, 11, 10, 9, type);
    pentagon(11, 7, 18, 19, 6, type);
    pentagon(8, 17, 16, 9, 10, type);
    pentagon(2, 14, 15, 6, 19, type);
    pentagon(2, 13, 12, 4, 14, type);
    pentagon(2, 19, 18, 3, 13, type);
    pentagon(3, 0, 5, 12, 13, type);
    pentagon(6, 15, 8, 10, 11, type);
    pentagon(4, 17, 8, 15, 14, type);
    pentagon(4, 12, 5, 16, 17, type);
    m_popmatrix();
}

static void pentagon(int a, int b, int c, int d, int e, GLenum shadeType)
{
    GLdouble n0[3], d1[3], d2[3], d3[3], d4[3], d5[3], nout[3];

    diff3(&dodec[a][0], &dodec[b][0], d1);
    diff3(&dodec[b][0], &dodec[c][0], d2);
    crossprod(d1, d2, n0);
    normalize(n0);
    m_xformpt(&dodec[a][0], d1, n0, nout);
    m_xformptonly(&dodec[b][0], d2);
    m_xformptonly(&dodec[c][0], d3);
    m_xformptonly(&dodec[d][0], d4);
    m_xformptonly(&dodec[e][0], d5);

    glBegin (shadeType);
    glNormal3dv(nout);
    glVertex3dv(d1);
    glVertex3dv(d2);
    glVertex3dv(d3);
    glVertex3dv(d4);
    glVertex3dv(d5);
    glEnd();
}

/*      linked lists--display lists for each different
 *      type of geometric objects.  The linked list is
 *      searched, until an object of the requested
 *      size is found.  If no geometric object of that size
 *      has been previously made, a new one is created.
 */
GLuint findList (int index, GLdouble *paramArray, int size)
{
    MODELPTR endList;
    int found = 0;

    endList = lists[index];
    while (endList != NULL) {
        if (compareParams (endList->params, paramArray, size))
            return (endList->list);
        endList = endList->ptr;
    }
/*  if not found, return 0 and calling routine should
 *  make a new list
 */
    return (0);
}

int compareParams (GLdouble *oneArray, GLdouble *twoArray, int size)
{
    int i;
    int matches = 1;

    for (i = 0; (i < size) && matches; i++) {
        if (*oneArray++ != *twoArray++)
            matches = 0;
    }
    return (matches);
}

GLuint makeModelPtr (int index, GLdouble *sizeArray, int count)
{
    MODELPTR newModel;

    newModel = (MODELPTR) malloc (sizeof (MODEL));
    if (!newModel)
        return 0;
    newModel->list = glGenLists (1);
    newModel->numParam = count;
    newModel->params = sizeArray;
    newModel->ptr = lists[index];
    lists[index] = newModel;

    return (newModel->list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\image.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <gl/glaux.h>
#include "tk.h"

#define static


AUX_RGBImageRec * APIENTRY auxRGBImageLoadA(LPCSTR filename)
{
    return (AUX_RGBImageRec *)tkRGBImageLoadAW((char *)filename, FALSE);
}

AUX_RGBImageRec * APIENTRY auxRGBImageLoadW(LPCWSTR filename)
{
    return (AUX_RGBImageRec *)tkRGBImageLoadAW((char *)filename, TRUE);
}

AUX_RGBImageRec * APIENTRY auxDIBImageLoadA(LPCSTR filename)
{
    return (AUX_RGBImageRec *)tkDIBImageLoadAW((char *)filename, FALSE);
}

AUX_RGBImageRec * APIENTRY auxDIBImageLoadW(LPCWSTR filename)
{
    return (AUX_RGBImageRec *)tkDIBImageLoadAW((char *)filename, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\tk.h ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#ifndef __tk_h__
#define __tk_h__

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** Window Types
*/

#define TK_RGB		0
#define TK_INDEX	1
#define TK_SINGLE	0
#define TK_DOUBLE	2
#define TK_DIRECT	0
#define TK_INDIRECT	4
#define TK_ACCUM	8
#define TK_ALPHA	16
#define TK_DEPTH24      32      /* 24-bit depth buffer */
#define TK_STENCIL      64
#define TK_DEPTH16      256     /* 16-bit depth buffer */
#define TK_FIXED_332_PAL    512
#define TK_DEPTH        TK_DEPTH16 /* default is 16-bit depth buffer */

/*
** Display Mode Selection Criteria
*/

enum {
    TK_USE_ID = 1,
    TK_EXACT_MATCH,
    TK_MINIMUM_CRITERIA
};

/* 
** Window Masks
*/

#define TK_IS_RGB(x)		(((x) & TK_INDEX) == 0)
#define TK_IS_INDEX(x)		(((x) & TK_INDEX) != 0)
#define TK_IS_SINGLE(x)		(((x) & TK_DOUBLE) == 0)
#define TK_IS_DOUBLE(x)		(((x) & TK_DOUBLE) != 0)
#define TK_HAS_ACCUM(x)		(((x) & TK_ACCUM) != 0)
#define TK_HAS_ALPHA(x)		(((x) & TK_ALPHA) != 0)
#define TK_HAS_DEPTH(x)         (((x) & (TK_DEPTH24 | TK_DEPTH16)) != 0)
#define TK_HAS_STENCIL(x)	(((x) & TK_STENCIL) != 0)
#define TK_IS_DIRECT(x)		(((x) & TK_INDIRECT) == 0)
#define TK_IS_INDIRECT(x)       (((x) & TK_INDIRECT) != 0)
#define TK_USE_FIXED_332_PAL(x) (((x) & TK_FIXED_332_PAL) != 0)
#define TK_IS_DEPTH16(x)        (((x) & TK_DEPTH16) != 0)

/*
** Event Status
*/

#define	TK_LEFTBUTTON		1
#define	TK_RIGHTBUTTON		2
#define	TK_MIDDLEBUTTON		4
#define	TK_SHIFT		1
#define	TK_CONTROL		2

/* 
** Key Codes
*/

#define TK_RETURN		0x0D
#define TK_ESCAPE		0x1B
#define TK_SPACE		0x20
#define TK_LEFT			0x25
#define TK_UP			0x26
#define TK_RIGHT		0x27
#define TK_DOWN			0x28
#define TK_A			'A'
#define TK_B			'B'
#define TK_C			'C'
#define TK_D			'D'
#define TK_E			'E'
#define TK_F			'F'
#define TK_G			'G'
#define TK_H			'H'
#define TK_I			'I'
#define TK_J			'J'
#define TK_K			'K'
#define TK_L			'L'
#define TK_M			'M'
#define TK_N			'N'
#define TK_O			'O'
#define TK_P			'P'
#define TK_Q			'Q'
#define TK_R			'R'
#define TK_S			'S'
#define TK_T			'T'
#define TK_U			'U'
#define TK_V			'V'
#define TK_W			'W'
#define TK_X			'X'
#define TK_Y			'Y'
#define TK_Z			'Z'
#define TK_a			'a'
#define TK_b			'b'
#define TK_c			'c'
#define TK_d			'd'
#define TK_e			'e'
#define TK_f			'f'
#define TK_g			'g'
#define TK_h			'h'
#define TK_i			'i'
#define TK_j			'j'
#define TK_k			'k'
#define TK_l			'l'
#define TK_m			'm'
#define TK_n			'n'
#define TK_o			'o'
#define TK_p			'p'
#define TK_q			'q'
#define TK_r			'r'
#define TK_s			's'
#define TK_t			't'
#define TK_u			'u'
#define TK_v			'v'
#define TK_w			'w'
#define TK_x			'x'
#define TK_y			'y'
#define TK_z			'z'
#define TK_0			'0'
#define TK_1			'1'
#define TK_2			'2'
#define TK_3			'3'
#define TK_4			'4'
#define TK_5			'5'
#define TK_6			'6'
#define TK_7			'7'
#define TK_8			'8'
#define TK_9			'9'

/*
** Color Macros - Default Windows Logical palette
*/

enum {
    TK_BLACK = 0,
    TK_RED = 13,
    TK_GREEN,
    TK_YELLOW,
    TK_BLUE,
    TK_MAGENTA,
    TK_CYAN,
    TK_WHITE
};

extern float auxRGBMap[20][3];
#define tkRGBMap auxRGBMap

#define TK_SETCOLOR(x, y) (TK_IS_RGB((x)) ? \
		           glColor3fv(auxRGBMap[(y)]) : glIndexf((y)))

/*
** RGB Image Structure
*/

typedef struct _TK_RGBImageRec {
    GLint sizeX, sizeY;
    unsigned char *data;
} TK_RGBImageRec;

/*
** Prototypes
*/

extern void tkInitDisplayMode(GLenum);
extern void tkInitPosition(int, int, int, int);
extern void tkInitDisplayModePolicy(GLenum);
extern GLenum tkInitDisplayModeID(GLint);
extern GLenum tkInitWindow(char *);
extern GLenum tkInitWindowAW(char *, BOOL);
extern void tkCloseWindow(void);
extern void tkQuit(void);

extern void tkExec(void);
extern void tkExposeFunc(void (*)(int, int));
extern void tkReshapeFunc(void (*)(int, int));
extern void tkDisplayFunc(void (*)(void));
extern void tkKeyDownFunc(GLenum (*)(int, GLenum));
extern void tkMouseDownFunc(GLenum (*)(int, int, GLenum));
extern void tkMouseUpFunc(GLenum (*)(int, int, GLenum));
extern void tkMouseMoveFunc(GLenum (*)(int, int, GLenum));
extern void tkIdleFunc(void (*)(void));

extern void tkSwapBuffers(void);

extern GLint tkGetColorMapSize(void);
extern void tkGetMouseLoc(int *, int *);
extern GLint tkGetDisplayModeID(void);
extern GLenum tkGetDisplayModePolicy(void);
extern GLenum tkGetDisplayMode(void);

extern void tkSetOneColor(int, float, float, float);
extern void tkSetFogRamp(int, int);
extern void tkSetGreyRamp(void);
extern void tkSetRGBMap(int, float *);

extern TK_RGBImageRec *tkRGBImageLoad(char *);
extern TK_RGBImageRec *tkRGBImageLoadAW(char *, BOOL);

extern TK_RGBImageRec *tkDIBImageLoad(char *);
extern TK_RGBImageRec *tkDIBImageLoadAW(char *, BOOL);

extern GLenum tkCreateStrokeFont(GLuint);
extern GLenum tkCreateOutlineFont(GLuint);
extern GLenum tkCreateFilledFont(GLuint);
extern GLenum tkCreateBitmapFont(GLuint);
extern void tkDrawStr(GLuint, char *);

/* Windows specific routines */
extern HWND  tkGetHWND(void);
extern HDC   tkGetHDC(void);
extern HGLRC tkGetHRC(void);

/* Error popup control */
extern void tkErrorPopups(GLboolean);
extern GLboolean tkPopupEnable;
#define MESSAGEBOX(a, b, c, d)  if (tkPopupEnable) MessageBoxA((a), (b), (c), (d))

#ifdef __cplusplus
}
#endif

#endif // __tk_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\tk.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "tk.h"
#include "windows.h"

#if(WINVER < 0x0400)
// Ordinarily not defined for versions before 4.00.
#define COLOR_3DDKSHADOW        21
#define COLOR_3DLIGHT           22
#define COLOR_INFOTEXT          23
#define COLOR_INFOBK            24
#endif

#define static

#if defined(__cplusplus) || defined(c_plusplus)
#define class c_class
#endif

#if DBG
#define TKASSERT(x)                                     \
if ( !(x) ) {                                           \
    PrintMessage("%s(%d) Assertion failed %s\n",        \
        __FILE__, __LINE__, #x);                        \
}
#else
#define TKASSERT(x)
#endif  /* DBG */

/******************************************************************************/

static struct _WINDOWINFO {
    int x, y;
    int width, height;
    GLenum type;
    GLenum dmPolicy;
    int ipfd;
    BOOL bDefPos;
} windInfo = {
    0, 0, 100, 100, TK_INDEX | TK_SINGLE, TK_MINIMUM_CRITERIA, 0, TRUE
};


HWND     tkhwnd     = NULL;
HDC      tkhdc      = NULL;
static HGLRC    tkhrc      = NULL;
HPALETTE tkhpalette = NULL;
static OSVERSIONINFO tkOSVerInfo;
GLboolean tkPopupEnable = TRUE;

// Fixed palette support.

#define BLACK   PALETTERGB(0,0,0)
#define WHITE   PALETTERGB(255,255,255)
#define MAX_STATIC_COLORS   (COLOR_INFOBK - COLOR_SCROLLBAR + 1)
static int tkNumStaticColors = MAX_STATIC_COLORS;

// TRUE if app wants to take over palette
static BOOL tkUseStaticColors = FALSE;

// TRUE if static system color settings have been replaced with B&W settings.
BOOL tkSystemColorsInUse = FALSE;

// TRUE if original static colors saved
static BOOL tkStaticColorsSaved = FALSE;

// saved system static colors (initialize with default colors)
static COLORREF gacrSave[MAX_STATIC_COLORS];

// new B&W system static colors
static COLORREF gacrBlackAndWhite[] = {
    WHITE,  // COLOR_SCROLLBAR
    BLACK,  // COLOR_BACKGROUND
    BLACK,  // COLOR_ACTIVECAPTION
    WHITE,  // COLOR_INACTIVECAPTION
    WHITE,  // COLOR_MENU
    WHITE,  // COLOR_WINDOW
    BLACK,  // COLOR_WINDOWFRAME
    BLACK,  // COLOR_MENUTEXT
    BLACK,  // COLOR_WINDOWTEXT
    WHITE,  // COLOR_CAPTIONTEXT
    WHITE,  // COLOR_ACTIVEBORDER
    WHITE,  // COLOR_INACTIVEBORDER
    WHITE,  // COLOR_APPWORKSPACE
    BLACK,  // COLOR_HIGHLIGHT
    WHITE,  // COLOR_HIGHLIGHTTEXT
    WHITE,  // COLOR_BTNFACE
    BLACK,  // COLOR_BTNSHADOW
    BLACK,  // COLOR_GRAYTEXT
    BLACK,  // COLOR_BTNTEXT
    BLACK,  // COLOR_INACTIVECAPTIONTEXT
    BLACK,  // COLOR_BTNHIGHLIGHT
    BLACK,  // COLOR_3DDKSHADOW
    WHITE,  // COLOR_3DLIGHT
    BLACK,  // COLOR_INFOTEXT
    WHITE   // COLOR_INFOBK
    };
static INT gaiStaticIndex[] = {
    COLOR_SCROLLBAR          ,
    COLOR_BACKGROUND         ,
    COLOR_ACTIVECAPTION      ,
    COLOR_INACTIVECAPTION    ,
    COLOR_MENU               ,
    COLOR_WINDOW             ,
    COLOR_WINDOWFRAME        ,
    COLOR_MENUTEXT           ,
    COLOR_WINDOWTEXT         ,
    COLOR_CAPTIONTEXT        ,
    COLOR_ACTIVEBORDER       ,
    COLOR_INACTIVEBORDER     ,
    COLOR_APPWORKSPACE       ,
    COLOR_HIGHLIGHT          ,
    COLOR_HIGHLIGHTTEXT      ,
    COLOR_BTNFACE            ,
    COLOR_BTNSHADOW          ,
    COLOR_GRAYTEXT           ,
    COLOR_BTNTEXT            ,
    COLOR_INACTIVECAPTIONTEXT,
    COLOR_BTNHIGHLIGHT       ,
    COLOR_3DDKSHADOW         ,
    COLOR_3DLIGHT            ,
    COLOR_INFOTEXT           ,
    COLOR_INFOBK
    };

static BOOL GrabStaticEntries(HDC);
static BOOL ReleaseStaticEntries(HDC);

#define RESTORE_FROM_REGISTRY   1
#if RESTORE_FROM_REGISTRY
// Registry names for the system colors.
CHAR *gaszSysClrNames[] = {
    "Scrollbar",      // COLOR_SCROLLBAR              0
    "Background",     // COLOR_BACKGROUND             1   (also COLOR_DESKTOP)
    "ActiveTitle",    // COLOR_ACTIVECAPTION          2
    "InactiveTitle",  // COLOR_INACTIVECAPTION        3
    "Menu",           // COLOR_MENU                   4
    "Window",         // COLOR_WINDOW                 5
    "WindowFrame",    // COLOR_WINDOWFRAME            6
    "MenuText",       // COLOR_MENUTEXT               7
    "WindowText",     // COLOR_WINDOWTEXT             8
    "TitleText",      // COLOR_CAPTIONTEXT            9
    "ActiveBorder",   // COLOR_ACTIVEBORDER          10
    "InactiveBorder", // COLOR_INACTIVEBORDER        11
    "AppWorkspace",   // COLOR_APPWORKSPACE          12
    "Hilight",        // COLOR_HIGHLIGHT             13
    "HilightText",    // COLOR_HIGHLIGHTTEXT         14
    "ButtonFace",     // COLOR_BTNFACE               15   (also COLOR_3DFACE)
    "ButtonShadow",   // COLOR_BTNSHADOW             16   (also COLOR_3DSHADOW)
    "GrayText",       // COLOR_GRAYTEXT              17
    "ButtonText",     // COLOR_BTNTEXT               18
    "InactiveTitleText", // COLOR_INACTIVECAPTIONTEXT   19
    "ButtonHilight",  // COLOR_BTNHIGHLIGHT          20   (also COLOR_3DHILIGHT)
    "ButtonDkShadow", // COLOR_3DDKSHADOW            21
    "ButtonLight",    // COLOR_3DLIGHT               22
    "InfoText",       // COLOR_INFOTEXT              23
    "InfoWindow"      // COLOR_INFOBK                24
};

static BOOL GetRegistrySysColors(COLORREF *, int);
#endif

static void (*ExposeFunc)(int, int)              = NULL;
static void (*ReshapeFunc)(int, int)             = NULL;
static void (*DisplayFunc)(void)                 = NULL;
static GLenum (*KeyDownFunc)(int, GLenum)        = NULL;
static GLenum (*MouseDownFunc)(int, int, GLenum) = NULL;
static GLenum (*MouseUpFunc)(int, int, GLenum)   = NULL;
static GLenum (*MouseMoveFunc)(int, int, GLenum) = NULL;
static void (*IdleFunc)(void)                    = NULL;

static char     *lpszClassName = "tkLibWClass";
static WCHAR    *lpszClassNameW = L"tkLibWClass";

static LRESULT tkWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
static unsigned char ComponentFromIndex(int i, int nbits, int shift );
static void PrintMessage( const char *Format, ... );
static PALETTEENTRY *FillRgbPaletteEntries( PIXELFORMATDESCRIPTOR *Pfd, PALETTEENTRY *Entries, UINT Count );
static HPALETTE CreateCIPalette( HDC Dc );
static HPALETTE CreateRGBPalette( HDC hdc );
static void DestroyThisWindow( HWND Window );
static void CleanUp( void );
static void DelayPaletteRealization( void );
static long RealizePaletteNow( HDC Dc, HPALETTE Palette, BOOL bForceBackground );
static void ForceRedraw( HWND Window );
static BOOL FindPixelFormat(HDC hdc, GLenum type);
static int FindBestPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd);
static int FindExactPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd);
static BOOL IsPixelFormatValid(HDC hdc, int ipfd, PIXELFORMATDESCRIPTOR *ppfd);
static int PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd );
static void *AllocateMemory( size_t Size );
static void *AllocateZeroedMemory( size_t Size );
static void FreeMemory( void *Chunk );

/*
 *  Prototypes for the debugging functions go here
 */

#define DBGFUNC 0
#if DBGFUNC

static void DbgPrintf( const char *Format, ... );
static void pwi( void );
static void pwr(RECT *pr);
static void ShowPixelFormat(HDC hdc);

#endif

static float colorMaps[] = {
    0.000000F, 1.000000F, 0.000000F, 1.000000F, 0.000000F, 1.000000F,
    0.000000F, 1.000000F, 0.333333F, 0.776471F, 0.443137F, 0.556863F,
    0.443137F, 0.556863F, 0.219608F, 0.666667F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.039216F, 0.078431F, 0.117647F, 0.156863F,
    0.200000F, 0.239216F, 0.278431F, 0.317647F, 0.356863F, 0.400000F,
    0.439216F, 0.478431F, 0.517647F, 0.556863F, 0.600000F, 0.639216F,
    0.678431F, 0.717647F, 0.756863F, 0.800000F, 0.839216F, 0.878431F,
    0.917647F, 0.956863F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 0.000000F, 0.000000F,
    1.000000F, 1.000000F, 0.000000F, 0.000000F, 1.000000F, 1.000000F,
    0.333333F, 0.443137F, 0.776471F, 0.556863F, 0.443137F, 0.219608F,
    0.556863F, 0.666667F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.039216F, 0.078431F, 0.117647F, 0.156863F, 0.200000F, 0.239216F,
    0.278431F, 0.317647F, 0.356863F, 0.400000F, 0.439216F, 0.478431F,
    0.517647F, 0.556863F, 0.600000F, 0.639216F, 0.678431F, 0.717647F,
    0.756863F, 0.800000F, 0.839216F, 0.878431F, 0.917647F, 0.956863F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F,
    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F,
    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F,
    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F,
    0.854902F, 1.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 0.333333F, 0.443137F,
    0.443137F, 0.219608F, 0.776471F, 0.556863F, 0.556863F, 0.666667F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F,
    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.039216F, 0.078431F,
    0.117647F, 0.156863F, 0.200000F, 0.239216F, 0.278431F, 0.317647F,
    0.356863F, 0.400000F, 0.439216F, 0.478431F, 0.517647F, 0.556863F,
    0.600000F, 0.639216F, 0.678431F, 0.717647F, 0.756863F, 0.800000F,
    0.839216F, 0.878431F, 0.917647F, 0.956863F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F,
    0.000000F, 0.000000F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F,
    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F,
    0.749020F, 0.749020F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F,
};

/* Default Palette */
float auxRGBMap[20][3] = {
    { 0.0F, 0.0F, 0.0F },                               /* 0: black */
    { 0x80/255.0F, 0.0F, 0.0F },                        /* 1: Half red */
    { 0.0F, 0x80/255.0F, 0.0F },                        /* 2: Half green */
    { 0x80/255.0F, 0x80/255.0F, 0.0F },                 /* 3: Half yellow */
    { 0.0F, 0.0F, 0x80/255.0F },                        /* 4: Half blue */
    { 0x80/255.0F, 0.0F, 0x80/255.0F },                 /* 5: Half magenta */
    { 0.0F, 0x80/255.0F, 0x80/255.0F },                 /* 6: Half cyan */
    { 0xC0/255.0F, 0xC0/255.0F, 0xC0/255.0F },          /* 7: Light gray */
    { 0xC0/255.0F, 0xDC/255.0F, 0xC0/255.0F },          /* 8: Green gray */
    { 0xA6/255.0F, 0xCA/255.0F, 0xF0/255.0F },          /* 9: Half gray */
    { 1.0F, 0xFB/255.0F, 0xF0/255.0F },                 /* 10: Pale */
    { 0xA0/255.0F, 0xA0/255.0F, 0xA4/255.0F },          /* 11: Med gray */
    { 0x80/255.0F, 0x80/255.0F, 0x80/255.0F },          /* 12: Dark gray */
    { 1.0F, 0.0F, 0.0F },                               /* 13: red */
    { 0.0F, 1.0F, 0.0F },                               /* 14: green */
    { 1.0F, 1.0F, 0.0F },                               /* 15: yellow */
    { 0.0F, 0.0F, 1.0F },                               /* 16: blue */
    { 1.0F, 0.0F, 1.0F },                               /* 17: magenta */
    { 0.0F, 1.0F, 1.0F },                               /* 18: cyan */
    { 1.0F, 1.0F, 1.0F },                               /* 19: white */
};

/***************************************************************
 *                                                             *
 *  Exported Functions go here                                 *
 *                                                             *
 ***************************************************************/

void tkErrorPopups(GLboolean bEnable)
{
    tkPopupEnable = bEnable;
}

void tkCloseWindow(void)
{
    DestroyThisWindow(tkhwnd);
}


void tkExec(void)
{
    MSG Message;

    /*
     *  WM_SIZE gets delivered before we get here!
     */

    if (ReshapeFunc)
    {
        RECT ClientRect;

        GetClientRect(tkhwnd, &ClientRect);
        (*ReshapeFunc)(ClientRect.right, ClientRect.bottom);
    }

    while (GL_TRUE)
    {
        /*
         *  Process all pending messages
         */

        if (IdleFunc) {
            while (PeekMessage(&Message, NULL, 0, 0, PM_NOREMOVE) == TRUE) {
                if (GetMessage(&Message, NULL, 0, 0) ) {
                    TranslateMessage(&Message);
                    DispatchMessage(&Message);
                } else {
                    /*
                     *  Nothing else to do here, just return
                     */

                    return;
                }
            }

            /*
             *  If an idle function was defined, call it
             */

            if (IdleFunc) {
                (*IdleFunc)();
            }
        } else {
            if (GetMessage(&Message, NULL, 0, 0)) {
                TranslateMessage(&Message);
                DispatchMessage(&Message);
            } else {
                return;
            }
        }
    }
}

void tkExposeFunc(void (*Func)(int, int))
{
    ExposeFunc = Func;
}

void tkReshapeFunc(void (*Func)(int, int))
{
    ReshapeFunc = Func;
}

void tkDisplayFunc(void (*Func)(void))
{
    DisplayFunc = Func;
}

void tkKeyDownFunc(GLenum (*Func)(int, GLenum))
{
    KeyDownFunc = Func;
}

void tkMouseDownFunc(GLenum (*Func)(int, int, GLenum))
{
    MouseDownFunc = Func;
}

void tkMouseUpFunc(GLenum (*Func)(int, int, GLenum))
{
    MouseUpFunc = Func;
}

void tkMouseMoveFunc(GLenum (*Func)(int, int, GLenum))
{
    MouseMoveFunc = Func;
}

void tkIdleFunc(void (*Func)(void))
{
    IdleFunc = Func;
}

void tkInitPosition(int x, int y, int width, int height)
{
    if (x == CW_USEDEFAULT)
    {
        x = 0;
        y = 0;
        windInfo.bDefPos = TRUE;
    }
    else
        windInfo.bDefPos = FALSE;

    windInfo.x = x + GetSystemMetrics(SM_CXFRAME);
    windInfo.y = y + GetSystemMetrics(SM_CYCAPTION)
                 - GetSystemMetrics(SM_CYBORDER)
                 + GetSystemMetrics(SM_CYFRAME);
    windInfo.width = width;
    windInfo.height = height;
}

void tkInitDisplayMode(GLenum type)
{
    windInfo.type = type;
}

void tkInitDisplayModePolicy(GLenum type)
{
    windInfo.dmPolicy = type;
}

GLenum tkInitDisplayModeID(GLint ipfd)
{
    windInfo.ipfd = ipfd;
    return GL_TRUE;
}

// Initialize a window, create a rendering context for that window
GLenum tkInitWindow(char *title)
{
    TKASSERT( NULL==tkhwnd      );
    TKASSERT( NULL==tkhdc       );
    TKASSERT( NULL==tkhrc       );
    TKASSERT( NULL==tkhpalette  );

    return tkInitWindowAW(title, FALSE);
}

GLenum tkInitWindowAW(char *title, BOOL bUnicode)
{
    WNDCLASS wndclass;
    RECT     WinRect;
    HANDLE   hInstance;
    ATOM     aRegister;
    GLenum   Result = GL_FALSE;
    BOOL     bGetVersionExRet;

    hInstance = GetModuleHandle(NULL);

    tkOSVerInfo.dwOSVersionInfoSize = sizeof(tkOSVerInfo);
    bGetVersionExRet = GetVersionEx(&tkOSVerInfo);
    TKASSERT(bGetVersionExRet);
    if ( tkOSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
         tkOSVerInfo.dwMajorVersion == 3 &&
         (tkOSVerInfo.dwMinorVersion == 5 || tkOSVerInfo.dwMinorVersion == 51) )
        tkNumStaticColors = COLOR_BTNHIGHLIGHT - COLOR_SCROLLBAR + 1;
    else
        tkNumStaticColors = COLOR_INFOBK - COLOR_SCROLLBAR + 1;

    // Must not define CS_PARENTDC style.
    wndclass.style         = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc   = tkWndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = hInstance;
    wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = GetStockObject(BLACK_BRUSH);
    wndclass.lpszMenuName  = NULL;

    if (bUnicode)
        wndclass.lpszClassName = (LPCSTR)lpszClassNameW;
    else
        wndclass.lpszClassName = (LPCSTR)lpszClassName;

    if (bUnicode)
    {
        aRegister = RegisterClassW((CONST WNDCLASSW *)&wndclass);
    }
    else
    {
        aRegister = RegisterClass(&wndclass);
    }


    /*
     *  If the window failed to register, then there's no
     *  need to continue further.
     */

    if(0 == aRegister)
    {
        PrintMessage("Failed to register window class\n");
        return(Result);
    }


    /*
     *  Make window large enough to hold a client area as large as windInfo
     */

    WinRect.left   = windInfo.x;
    WinRect.right  = windInfo.x + windInfo.width;
    WinRect.top    = windInfo.y;
    WinRect.bottom = windInfo.y + windInfo.height;

    AdjustWindowRect(&WinRect, WS_OVERLAPPEDWINDOW, FALSE);

    /*
     *  Must use WS_CLIPCHILDREN and WS_CLIPSIBLINGS styles.
     */

    if (bUnicode)
    {
        tkhwnd = CreateWindowW(
                    (LPCWSTR)lpszClassNameW,
                    (LPCWSTR)title,
                    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.left,
                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.top,
                    WinRect.right - WinRect.left,
                    WinRect.bottom - WinRect.top,
                    NULL,
                    NULL,
                    hInstance,
                    NULL);
    }
    else
    {
        tkhwnd = CreateWindow(
                    lpszClassName,
                    title,
                    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.left,
                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.top,
                    WinRect.right - WinRect.left,
                    WinRect.bottom - WinRect.top,
                    NULL,
                    NULL,
                    hInstance,
                    NULL);
    }

    if ( NULL != tkhwnd )
    {
        // If default window positioning used, find out window position and fix
        // up the windInfo position info.

        if (windInfo.bDefPos)
        {
            GetWindowRect(tkhwnd, &WinRect);
            windInfo.x = WinRect.left + GetSystemMetrics(SM_CXFRAME);
            windInfo.y = WinRect.top  + GetSystemMetrics(SM_CYCAPTION)
                         - GetSystemMetrics(SM_CYBORDER)
                         + GetSystemMetrics(SM_CYFRAME);
        }

        tkhdc = GetDC(tkhwnd);

        if ( NULL != tkhdc )
        {
            ShowWindow(tkhwnd, SW_SHOWDEFAULT);

            if ( FindPixelFormat(tkhdc, windInfo.type) )
            {
                /*
                 *  Create a Rendering Context
                 */

                tkhrc = wglCreateContext(tkhdc);

                if ( NULL != tkhrc )
                {
                    /*
                     *  Make it Current
                     */

                    if ( wglMakeCurrent(tkhdc, tkhrc) )
                    {
                        Result = GL_TRUE;
                    }
                    else
                    {
                        PrintMessage("wglMakeCurrent Failed\n");
                    }
                }
                else
                {
                    PrintMessage("wglCreateContext Failed\n");
                }
            }
        }
        else
        {
            PrintMessage("Could not get an HDC for window 0x%08lX\n", tkhwnd );
        }
    }
    else
    {
        PrintMessage("create window failed\n");
    }

    if ( GL_FALSE == Result )
    {
        DestroyThisWindow(tkhwnd);  // Something Failed, Destroy this window
    }
    return( Result );
}

/******************************************************************************/

/*
 * You cannot just call DestroyWindow() here.  The programs do not expect
 * tkQuit() to return;  DestroyWindow() just sends a WM_DESTROY message
 */

void tkQuit(void)
{
    DestroyThisWindow(tkhwnd);
    ExitProcess(0);
}

/******************************************************************************/

void tkSetOneColor(int index, float r, float g, float b)
{
    PALETTEENTRY PalEntry;
    HPALETTE Palette;

    if ( NULL != (Palette = CreateCIPalette( tkhdc )) )
    {
        if ( tkUseStaticColors && ( index == 0 || index == 255 ) )
            return;

        PalEntry.peRed   = (BYTE)(r*(float)255.0 + (float)0.5);
        PalEntry.peGreen = (BYTE)(g*(float)255.0 + (float)0.5);
        PalEntry.peBlue  = (BYTE)(b*(float)255.0 + (float)0.5);
        PalEntry.peFlags = ( tkUseStaticColors ) ? PC_NOCOLLAPSE : 0;

        // This is a workaround for a GDI palette "feature".  If any of
        // the static colors are repeated in the palette, those colors
        // will map to the first occurance.  So, for our case where there
        // are only two static colors (black and white), if a white
        // color appears anywhere in the palette other than in the last
        // entry, the static white will remap to the first white.  This
        // destroys the nice one-to-one mapping we are trying to achieve.
        //
        // There are two ways to workaround this.  The first is to
        // simply not allow a pure white anywhere but in the last entry.
        // Such requests are replaced with an attenuated white of
        // (0xFE, 0xFE, 0xFE).
        //
        // The other way is to mark these extra whites with PC_RESERVED
        // which will cause GDI to skip these entries when mapping colors.
        // This way the app gets the actual colors requested, but can
        // have side effects on other apps.
        //
        // Both solutions are included below.  The PC_RESERVED solution is
        // the one currently enabled.  It may have side effects, but taking
        // over the static colors as we are is a really big side effect that
        // should swamp out the effects of using PC_RESERVED.

        if ( tkUseStaticColors )
        {
            if ( PalEntry.peRed   == 0xFF &&
                 PalEntry.peGreen == 0xFF &&
                 PalEntry.peBlue  == 0xFF )
            {
            #define USE_PC_RESERVED_WORKAROUND  1
            #if USE_PC_RESERVED_WORKAROUND
                PalEntry.peFlags |= PC_RESERVED;
            #else
                PalEntry.peRed   =
                PalEntry.peGreen =
                PalEntry.peBlue  = 0xFE;
            #endif
            }
        }

        SetPaletteEntries( Palette, index, 1, &PalEntry);

        DelayPaletteRealization();
    }
}

void tkSetFogRamp(int density, int startIndex)
{
    HPALETTE CurrentPal;
    PALETTEENTRY *pPalEntry;
    UINT n, i, j, k, intensity, fogValues, colorValues;

    if ( NULL != (CurrentPal = CreateCIPalette(tkhdc)) )
    {
        n = GetPaletteEntries( CurrentPal, 0, 0, NULL );

        pPalEntry = AllocateMemory( n * sizeof(PALETTEENTRY) );

        if ( NULL != pPalEntry)
        {
            fogValues = 1 << density;
            colorValues = 1 << startIndex;
            for (i = 0; i < colorValues; i++) {
                for (j = 0; j < fogValues; j++) {
                    k = i * fogValues + j;

                    intensity = i * fogValues + j * colorValues;
                    //mf: not sure what they're trying to do here
                    //intensity = (intensity << 8) | intensity; ???

                // This is a workaround for a GDI palette "feature".  If any of
                // the static colors are repeated in the palette, those colors
                // will map to the first occurance.  So, for our case where there
                // are only two static colors (black and white), if a white
                // color appears anywhere in the palette other than in the last
                // entry, the static white will remap to the first white.  This
                // destroys the nice one-to-one mapping we are trying to achieve.
                //
                // There are two ways to workaround this.  The first is to
                // simply not allow a pure white anywhere but in the last entry.
                // Such requests are replaced with an attenuated white of
                // (0xFE, 0xFE, 0xFE).
                //
                // The other way is to mark these extra whites with PC_RESERVED
                // which will cause GDI to skip these entries when mapping colors.
                // This way the app gets the actual colors requested, but can
                // have side effects on other apps.
                //
                // Both solutions are included below.  The PC_RESERVED solution is
                // the one currently enabled.  It may have side effects, but taking
                // over the static colors as we are is a really big side effect that
                // should swamp out the effects of using PC_RESERVED.

                #if USE_PC_RESERVED_WORKAROUND
                    if (intensity > 0xFF)
                        intensity = 0xFF;
                #else
                    if (intensity >= 0xFF)
                        intensity = ( tkUseStaticColors && k != 255) ? 0xFE : 0xFF;
                #endif

                    pPalEntry[k].peRed =
                    pPalEntry[k].peGreen =
                    pPalEntry[k].peBlue = (BYTE) intensity;
                    pPalEntry[k].peFlags = ( tkUseStaticColors && k != 0 && k != 255 )
                                           ? PC_NOCOLLAPSE : 0;

                #if USE_PC_RESERVED_WORKAROUND
                    if (tkUseStaticColors && intensity == 0xFF
                        && k != 0 && k!= 255)
                        pPalEntry[k].peFlags |= PC_RESERVED;
                #endif
                }
            }

            SetPaletteEntries(CurrentPal, 0, n, pPalEntry);
            FreeMemory( pPalEntry );

            DelayPaletteRealization();
        }
    }
}

void tkSetGreyRamp(void)
{
    HPALETTE CurrentPal;
    PALETTEENTRY *Entries;
    UINT Count, i;
    float intensity;

    if ( NULL != (CurrentPal = CreateCIPalette( tkhdc )) )
    {
        Count   = GetPaletteEntries( CurrentPal, 0, 0, NULL );
        Entries = AllocateMemory( Count * sizeof(PALETTEENTRY) );

        if ( NULL != Entries )
        {
            for (i = 0; i < Count; i++)
            {
                intensity = (float)(((double)i / (double)(Count-1)) * (double)255.0 + (double)0.5);
                Entries[i].peRed =
                Entries[i].peGreen =
                Entries[i].peBlue = (BYTE) intensity;
                Entries[i].peFlags = ( tkUseStaticColors && i != 0 && i != 255 )
                                     ? PC_NOCOLLAPSE : 0;
            }
            SetPaletteEntries( CurrentPal, 0, Count, Entries );
            FreeMemory( Entries );

            DelayPaletteRealization();
        }
    }
}

void tkSetRGBMap( int Size, float *Values )
{
    HPALETTE CurrentPal;
    PIXELFORMATDESCRIPTOR Pfd, *pPfd;
    PALETTEENTRY *Entries;
    UINT Count;

    if ( NULL != (CurrentPal = CreateCIPalette( tkhdc )) )
    {
        pPfd = &Pfd;

        if ( PixelFormatDescriptorFromDc( tkhdc, pPfd ) )
        {
            Count    = 1 << pPfd->cColorBits;
            Entries  = AllocateMemory( Count * sizeof(PALETTEENTRY) );

            if ( NULL != Entries )
            {
                FillRgbPaletteEntries( pPfd, Entries, Count );
                SetPaletteEntries( CurrentPal, 0, Count, Entries );
                FreeMemory(Entries);

                RealizePaletteNow( tkhdc, tkhpalette, FALSE );
            }
        }
    }
}

/******************************************************************************/

void tkSwapBuffers(void)
{
    SwapBuffers(tkhdc);
}

/******************************************************************************/

GLint tkGetColorMapSize(void)
{
    CreateCIPalette( tkhdc );

    if ( NULL == tkhpalette )
        return( 0 );

    return( GetPaletteEntries( tkhpalette, 0, 0, NULL ) );
}

void tkGetMouseLoc(int *x, int *y)
{
    POINT Point;

    *x = 0;
    *y = 0;

    GetCursorPos(&Point);

    /*
     *  GetCursorPos returns screen coordinates,
     *  we want window coordinates
     */

    *x = Point.x - windInfo.x;
    *y = Point.y - windInfo.y;
}

HWND tkGetHWND(void)
{
    return tkhwnd;
}

HDC tkGetHDC(void)
{
    return tkhdc;
}

HGLRC tkGetHRC(void)
{
    return tkhrc;
}

GLenum tkGetDisplayModePolicy(void)
{
    return windInfo.dmPolicy;
}

GLint tkGetDisplayModeID(void)
{
    return windInfo.ipfd;
}

GLenum tkGetDisplayMode(void)
{
    return windInfo.type;
}


/***********************************************************************
 *                                                                     *
 *  The Following functions are for our own use only. (ie static)      *
 *                                                                     *
 ***********************************************************************/

static LRESULT
tkWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int key;
    PAINTSTRUCT paint;
    HDC hdc;
    PIXELFORMATDESCRIPTOR pfd;

    switch (message) {

    case WM_USER:
        if ( RealizePaletteNow( tkhdc, tkhpalette, FALSE ) > 0 )
        {
            ForceRedraw( hWnd );
        }
        return(0);

    case WM_SIZE:
        windInfo.width  = LOWORD(lParam);
        windInfo.height = HIWORD(lParam);

        if (ReshapeFunc)
        {
            (*ReshapeFunc)(windInfo.width, windInfo.height);

            ForceRedraw( hWnd );
        }
        return (0);

    case WM_MOVE:
        windInfo.x = LOWORD(lParam);
        windInfo.y = HIWORD(lParam);
        return (0);

    case WM_PAINT:
        /*
         *  Validate the region even if there are no DisplayFunc.
         *  Otherwise, USER will not stop sending WM_PAINT messages.
         */

        hdc = BeginPaint(tkhwnd, &paint);

        if (DisplayFunc)
        {
            (*DisplayFunc)();
        }

        EndPaint(tkhwnd, &paint);
        return (0);

    case WM_QUERYNEWPALETTE:

    // We don't actually realize the palette here (we do it at WM_ACTIVATE
    // time), but we need the system to think that we have so that a
    // WM_PALETTECHANGED message is generated.

        return (1);

    case WM_PALETTECHANGED:

    // Respond to this message only if the window that changed the palette
    // is not this app's window.

    // We are not the foreground window, so realize palette in the
    // background.  We cannot call RealizePaletteNow to do this because
    // we should not do any of the tkUseStaticColors processing while
    // in background.

        if ( hWnd != (HWND) wParam )
        {
            if ( !tkSystemColorsInUse &&
                 NULL != tkhpalette &&
                 NULL != SelectPalette( tkhdc, tkhpalette, TRUE ) )
                RealizePalette( tkhdc );
        }

        return (0);

    case WM_SYSCOLORCHANGE:

    // If the system colors have changed and we have a palette
    // for an RGB surface then we need to recompute the static
    // color mapping because they might have been changed in
    // the process of changing the system colors.

        if (tkhdc != NULL && tkhpalette != NULL &&
            PixelFormatDescriptorFromDc(tkhdc, &pfd) &&
            (pfd.dwFlags & PFD_NEED_PALETTE) &&
            pfd.iPixelType == PFD_TYPE_RGBA)
        {
            HPALETTE hpalTmp;

            hpalTmp = tkhpalette;
            tkhpalette = NULL;
            if (CreateRGBPalette(tkhdc) != NULL)
            {
                DeleteObject(hpalTmp);
                ForceRedraw(hWnd);
            }
            else
            {
                tkhpalette = hpalTmp;
            }
        }
        break;
            
    case WM_ACTIVATE:

    // If the window is going inactive, the palette must be realized to
    // the background.  Cannot depend on WM_PALETTECHANGED to be sent since
    // the window that comes to the foreground may or may not be palette
    // managed.

        if ( LOWORD(wParam) == WA_INACTIVE )
        {
            if ( NULL != tkhpalette )
            {
            // Realize as a background palette.  Need to call
            // RealizePaletteNow rather than RealizePalette directly to
            // because it may be necessary to release usage of the static
            // system colors.

                if ( RealizePaletteNow( tkhdc, tkhpalette, TRUE ) > 0 )
                    ForceRedraw( hWnd );
            }
        }

    // Window is going active.  If we are not iconized, realize palette
    // to the foreground.  If management of the system static colors is
    // needed, RealizePaletteNow will take care of it.

        else if ( HIWORD(wParam) == 0 )
        {
            if ( NULL != tkhpalette )
            {
                if ( RealizePaletteNow( tkhdc, tkhpalette, FALSE ) > 0 )
                    ForceRedraw( hWnd );

                return (1);
            }
        }

    // Allow DefWindowProc() to finish the default processing (which includes
    // changing the keyboard focus).

        break;

    case WM_MOUSEMOVE:

        if (MouseMoveFunc)
        {
            GLenum mask;

            mask = 0;
            if (wParam & MK_LBUTTON) {
                mask |= TK_LEFTBUTTON;
            }
            if (wParam & MK_MBUTTON) {
                mask |= TK_MIDDLEBUTTON;
            }
            if (wParam & MK_RBUTTON) {
                mask |= TK_RIGHTBUTTON;
            }

            if ((*MouseMoveFunc)( LOWORD(lParam), HIWORD(lParam), mask ))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_LBUTTONDOWN:

        SetCapture(hWnd);

        if (MouseDownFunc)
        {
            if ( (*MouseDownFunc)(LOWORD(lParam), HIWORD(lParam),
                 TK_LEFTBUTTON) )
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_LBUTTONUP:

        ReleaseCapture();

        if (MouseUpFunc)
        {
            if ((*MouseUpFunc)(LOWORD(lParam), HIWORD(lParam), TK_LEFTBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_MBUTTONDOWN:

        SetCapture(hWnd);

        if (MouseDownFunc)
        {
            if ((*MouseDownFunc)(LOWORD(lParam), HIWORD(lParam),
                    TK_MIDDLEBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_MBUTTONUP:

        ReleaseCapture();

        if (MouseUpFunc)
        {
            if ((*MouseUpFunc)(LOWORD(lParam), HIWORD(lParam),
                TK_MIDDLEBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_RBUTTONDOWN:

        SetCapture(hWnd);

        if (MouseDownFunc)
        {
            if ((*MouseDownFunc)(LOWORD(lParam), HIWORD(lParam),
                TK_RIGHTBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_RBUTTONUP:

        ReleaseCapture();

        if (MouseUpFunc)
        {
            if ((*MouseUpFunc)(LOWORD(lParam), HIWORD(lParam),
                TK_RIGHTBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_SPACE:          key = TK_SPACE;         break;
        case VK_RETURN:         key = TK_RETURN;        break;
        case VK_ESCAPE:         key = TK_ESCAPE;        break;
        case VK_LEFT:           key = TK_LEFT;          break;
        case VK_UP:             key = TK_UP;            break;
        case VK_RIGHT:          key = TK_RIGHT;         break;
        case VK_DOWN:           key = TK_DOWN;          break;
        default:                key = GL_FALSE;         break;
        }

        if (key && KeyDownFunc)
        {
            GLenum mask;

            mask = 0;
            if (GetKeyState(VK_CONTROL)) {
                mask |= TK_CONTROL;
            }

            if (GetKeyState(VK_SHIFT)) {

                mask |= TK_SHIFT;
            }

            if ( (*KeyDownFunc)(key, mask) )
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_CHAR:
        if (('0' <= wParam && wParam <= '9') ||
            ('a' <= wParam && wParam <= 'z') ||
            ('A' <= wParam && wParam <= 'Z')) {

            key = (int)wParam;
        } else {
            key = GL_FALSE;
        }

        if (key && KeyDownFunc) {
            GLenum mask;

            mask = 0;

            if (GetKeyState(VK_CONTROL)) {
                mask |= TK_CONTROL;
            }

            if (GetKeyState(VK_SHIFT)) {
                mask |= TK_SHIFT;
            }

            if ( (*KeyDownFunc)(key, mask) )
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_CLOSE:
        DestroyWindow(tkhwnd);
        return(0);

    case WM_DESTROY:
        CleanUp();
        PostQuitMessage(TRUE);
        return 0;
    }
    return(DefWindowProc( hWnd, message, wParam, lParam));
}

#if RESTORE_FROM_REGISTRY
/******************************Public*Routine******************************\
* GetRegistrySysColors
*
* Reads the Control Panel's color settings from the registry and stores
* those values in pcr.  If we fail to get any value, then the corresponding
* entry in pcr is not modified.
*
* History:
*  12-Apr-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL GetRegistrySysColors(COLORREF *pcr, int nColors)
{
    BOOL bRet = FALSE;
    long lRet;
    HKEY hkSysColors = (HKEY) NULL;
    int i;
    DWORD dwDataType;
    char achColor[64];
    DWORD cjColor;

    TKASSERT(nColors <= tkNumStaticColors);

// Open the key for the system color settings.

    lRet = RegOpenKeyExA(HKEY_CURRENT_USER,
                         "Control Panel\\Colors",
                         0,
                         KEY_QUERY_VALUE,
                         &hkSysColors);

    if ( lRet != ERROR_SUCCESS )
    {
        goto GetRegistrySysColors_exit;
    }

// Read each system color value.  The names are stored in the global
// array of char *, gaszSysClrNames.

    for (i = 0; i < nColors; i++)
    {
        cjColor = sizeof(achColor);
        lRet = RegQueryValueExA(hkSysColors,
                                (LPSTR) gaszSysClrNames[i],
                                (LPDWORD) NULL,
                                &dwDataType,
                                (LPBYTE) achColor,
                                &cjColor);

        TKASSERT(lRet != ERROR_MORE_DATA);

        if ( lRet == ERROR_SUCCESS && dwDataType == REG_SZ )
        {
            DWORD r, g, b;

            sscanf(achColor, "%ld %ld %ld", &r, &g, &b);
            pcr[i] = RGB(r, g, b);
        }
    }

    bRet = TRUE;

GetRegistrySysColors_exit:
    if (hkSysColors)
        RegCloseKey(hkSysColors);

    return bRet;
}
#endif

/******************************Public*Routine******************************\
* GrabStaticEntries
*
* Support routine for RealizePaletteNow to manage the static system color
* usage.
*
* This function will save the current static system color usage state.
* It will fail if:
*
*   1.  TK is not in "sys color in use state but system palette is in
*       SYSPAL_NOSTATIC mode.  This means that another app still possesses
*       the static system colors.  This this happens, GrabStaticEntries
*       will post a message to cause TK to try again (by calling
*       DelayPaletteRealization).
*
* Side effect:
*   If system colors are changed, then WM_SYSCOLORCHANGE message is
*   broadcast to all top level windows.
*
*   DelayPaletteRealization may be called in case 2 above, resulting in
*   a WM_USER message being posted to our message queue.
*
* Returns:
*   TRUE if successful, FALSE otherwise (see above).
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL GrabStaticEntries(HDC hdc)
{
    int i;
    BOOL bRet = FALSE;

// Do nothing if sys colors already in use.

    if ( !tkSystemColorsInUse )
    {
    // Take possession only if no other app has the static colors.
    // How can we tell?  If the return from SetSystemPaletteUse is
    // SYSPAL_STATIC, then no other app has the statics.  If it is
    // SYSPAL_NOSTATIC, someone else has them and we must fail.
    //
    // SetSystemPaletteUse is properly synchronized internally
    // so that it is atomic.
    //
    // Because we are relying on SetSystemPaletteUse to synchronize TK,
    // it is important to observe the following order for grabbing and
    // releasing:
    //
    //      Grab        call SetSystemPaletteUse and check for SYSPAL_STATIC
    //                  save sys color settings
    //                  set new sys color settings
    //
    //      Release     restore sys color settings
    //                  call SetSystemPaletteUse

        if ( SetSystemPaletteUse( hdc, SYSPAL_NOSTATIC ) == SYSPAL_STATIC )
        {
        // Save current sys color settings.

            for (i = COLOR_SCROLLBAR; i <= COLOR_BTNHIGHLIGHT; i++)
                gacrSave[i - COLOR_SCROLLBAR] = GetSysColor(i);

        // Set b&w sys color settings.  Put TK in "sys colors in use" state.

            SetSysColors(tkNumStaticColors, gaiStaticIndex, gacrBlackAndWhite);
            tkSystemColorsInUse = TRUE;

        // Inform all other top-level windows of the system color change.

            PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);

            bRet = TRUE;
        }

    // Sleep a little and then post message to try palette realization again
    // later.

        else
        {
            Sleep(0L);
            DelayPaletteRealization();
        }
    }
    else
        bRet = TRUE;

    return bRet;
}

/******************************Public*Routine******************************\
* ReleaseStaticEntries
*
* Support routine for RealizePaletteNow to manage the static system color
* usage.
*
* This function will reset the current static system color usage state.
* It will fail if:
*
*   1.  TK is not in a "sys colors in use" state.  If we are in this case,
*       then the static system colors do not need to be released.
*
* Side effect:
*   If system colors are changed, then WM_SYSCOLORCHANGE message is
*   broadcast to all top level windows.
*
* Returns:
*   TRUE if successful, FALSE otherwise (see above).
*
* History:
*  21-Jul-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL ReleaseStaticEntries(HDC hdc)
{
    BOOL bRet = FALSE;

// Do nothing if sys colors not in use.

    if ( tkSystemColorsInUse )
    {
#if RESTORE_FROM_REGISTRY
    // Replace saved system colors with registry values.  We do it now
    // rather than earlier because someone may have changed registry while
    // TK app was running in the foreground (very unlikely, but it could
    // happen).
    //
    // Also, we still try to save current setting in GrabStaticEntries so
    // that if for some reason we fail to grab one or more of the colors
    // from the registry, we can still fall back on what we grabbed via
    // GetSysColors (even though there is a chance its the wrong color).

        GetRegistrySysColors(gacrSave, tkNumStaticColors);
#endif

    // Restore the saved system color settings.

        SetSysColors(tkNumStaticColors, gaiStaticIndex, gacrSave);

    // Return the system palette to SYSPAL_STATIC.

        SetSystemPaletteUse( hdc, SYSPAL_STATIC );

    // Inform all other top-level windows of the system color change.

        PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);

    // Reset the "sys colors in use" state and return success.

        tkSystemColorsInUse = FALSE;
        bRet = TRUE;
    }

    return bRet;
}

// Default palette entry flags
#define PALETTE_FLAGS PC_NOCOLLAPSE

// Gamma correction factor * 10
#define GAMMA_CORRECTION 14

// Maximum color distance with 8-bit components
#define MAX_COL_DIST (3*256*256L)

// Number of static colors
#define STATIC_COLORS 20

// Flags used when matching colors
#define EXACT_MATCH 1
#define COLOR_USED 1

// Conversion tables for n bits to eight bits

#if GAMMA_CORRECTION == 10
// These tables are corrected for a gamma of 1.0
static unsigned char abThreeToEight[8] =
{
    0, 0111 >> 1, 0222 >> 1, 0333 >> 1, 0444 >> 1, 0555 >> 1, 0666 >> 1, 0377
};
static unsigned char abTwoToEight[4] =
{
    0, 0x55, 0xaa, 0xff
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#else
// These tables are corrected for a gamma of 1.4
static unsigned char abThreeToEight[8] =
{
    0, 63, 104, 139, 171, 200, 229, 255
};
static unsigned char abTwoToEight[4] =
{
    0, 116, 191, 255
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#endif

// Table which indicates which colors in a 3-3-2 palette should be
// replaced with the system default colors
#if GAMMA_CORRECTION == 10
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 4, 32, 36, 128, 132, 160, 173, 181, 245,
    247, 164, 156, 7, 56, 63, 192, 199, 248, 255
};
#else
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 3, 24, 27, 64, 67, 88, 173, 181, 236,
    247, 164, 91, 7, 56, 63, 192, 199, 248, 255
};
#endif

static unsigned char
ComponentFromIndex(int i, int nbits, int shift)
{
    unsigned char val;

    TKASSERT(nbits >= 1 && nbits <= 3);
    
    val = i >> shift;
    switch (nbits)
    {
    case 1:
        return abOneToEight[val & 1];

    case 2:
        return abTwoToEight[val & 3];

    case 3:
        return abThreeToEight[val & 7];
    }
    return 0;
}

// System default colors
static PALETTEENTRY apeDefaultPalEntry[STATIC_COLORS] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },

    { 192, 220, 192,  0 },
    { 166, 202, 240,  0 },
    { 255, 251, 240,  0 },
    { 160, 160, 164,  0 },

    { 0x80,0x80,0x80, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

/******************************Public*Routine******************************\
*
* UpdateStaticMapping
*
* Computes the best match between the current system static colors
* and a 3-3-2 palette
*
* History:
*  Tue Aug 01 18:18:12 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static void
UpdateStaticMapping(PALETTEENTRY *pe332Palette)
{
    HPALETTE hpalStock;
    int iStatic, i332;
    int iMinDist, iDist;
    int iDelta;
    int iMinEntry;
    PALETTEENTRY *peStatic, *pe332;

    hpalStock = GetStockObject(DEFAULT_PALETTE);

    // The system should always have one of these
    TKASSERT(hpalStock != NULL);
    // Make sure there's the correct number of entries
    TKASSERT(GetPaletteEntries(hpalStock, 0, 0, NULL) == STATIC_COLORS);

    // Get the current static colors
    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry);

    // Zero the flags in the static colors because they are used later
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Zero the flags in the incoming palette because they are used later
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = 0;
        pe332++;
    }

    // Try to match each static color exactly
    // This saves time by avoiding the least-squares match for each
    // exact match
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            if (peStatic->peRed == pe332->peRed &&
                peStatic->peGreen == pe332->peGreen &&
                peStatic->peBlue == pe332->peBlue)
            {
                TKASSERT(pe332->peFlags != COLOR_USED);
                
                peStatic->peFlags = EXACT_MATCH;
                pe332->peFlags = COLOR_USED;
                aiDefaultOverride[iStatic] = i332;
                
                break;
            }

            pe332++;
        }

        peStatic++;
    }
    
    // Match each static color as closely as possible to an entry
    // in the 332 palette by minimized the square of the distance
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        // Skip colors already matched exactly
        if (peStatic->peFlags == EXACT_MATCH)
        {
            peStatic++;
            continue;
        }
        
        iMinDist = MAX_COL_DIST+1;
#if DBG
        iMinEntry = -1;
#endif

        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            // Skip colors already used
            if (pe332->peFlags == COLOR_USED)
            {
                pe332++;
                continue;
            }
            
            // Compute Euclidean distance squared
            iDelta = pe332->peRed-peStatic->peRed;
            iDist = iDelta*iDelta;
            iDelta = pe332->peGreen-peStatic->peGreen;
            iDist += iDelta*iDelta;
            iDelta = pe332->peBlue-peStatic->peBlue;
            iDist += iDelta*iDelta;

            if (iDist < iMinDist)
            {
                iMinDist = iDist;
                iMinEntry = i332;
            }

            pe332++;
        }

        TKASSERT(iMinEntry != -1);

        // Remember the best match
        aiDefaultOverride[iStatic] = iMinEntry;
        pe332Palette[iMinEntry].peFlags = COLOR_USED;
        
        peStatic++;
    }

    // Zero the flags in the static colors because they may have been
    // set.  We want them to be zero so the colors can be remapped
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Reset the 332 flags because we may have set them
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = PALETTE_FLAGS;
        pe332++;
    }

#if 0
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        PrintMessage("Static color %2d maps to %d\n",
                     iStatic, aiDefaultOverride[iStatic]);
    }
#endif
}

/******************************Public*Routine******************************\
* FillRgbPaletteEntries
*
* Fills a PALETTEENTRY array with values required for a logical rgb palette.
* If tkSetStaticColorUsage has been called with TRUE, the static system
* colors will be overridden.  Otherwise, the PALETTEENTRY array will be
* fixed up to contain the default static system colors.
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY *
FillRgbPaletteEntries(  PIXELFORMATDESCRIPTOR *Pfd,
                        PALETTEENTRY *Entries,
                        UINT Count
                     )
{
    PALETTEENTRY *Entry;
    UINT i;

    if ( NULL != Entries )
    {
        for ( i = 0, Entry = Entries ; i < Count ; i++, Entry++ )
        {
            Entry->peRed   = ComponentFromIndex(i, Pfd->cRedBits,
                                    Pfd->cRedShift);
            Entry->peGreen = ComponentFromIndex(i, Pfd->cGreenBits,
                                    Pfd->cGreenShift);
            Entry->peBlue  = ComponentFromIndex(i, Pfd->cBlueBits,
                                    Pfd->cBlueShift);
            Entry->peFlags = PALETTE_FLAGS;
        }

        if ( 256 == Count)
        {
        // If app set static system color usage for fixed palette support,
        // setup to take over the static colors.  Otherwise, fixup the
        // static system colors.

            if ( tkUseStaticColors )
            {
            // Black and white already exist as the only remaining static
            // colors.  Let those remap.  All others should be put into
            // the palette (i.e., set PC_NOCOLLAPSE).

                Entries[0].peFlags = 0;
                Entries[255].peFlags = 0;
            }
            else
            {
            // The defaultOverride array is computed assuming a 332
            // palette where red has zero shift, etc.

                if ( (3 == Pfd->cRedBits)   && (0 == Pfd->cRedShift)   &&
                     (3 == Pfd->cGreenBits) && (3 == Pfd->cGreenShift) &&
                     (2 == Pfd->cBlueBits)  && (6 == Pfd->cBlueShift) )
                {
                    UpdateStaticMapping(Entries);
                    
                    for ( i = 0 ; i < STATIC_COLORS ; i++)
                    {
                        Entries[aiDefaultOverride[i]] = apeDefaultPalEntry[i];
                    }
                }
            }
        }
    }
    return( Entries );
}

/******************************Public*Routine******************************\
* FlushPalette
*
* Because of Win 3.1 compatibility, GDI palette mapping always starts
* at zero and stops at the first exact match.  So if there are duplicates,
* the higher colors aren't mapped to--which is often a problem if we
* are trying to make to any of the upper 10 static colors.  To work around
* this, we flush the palette to all black.
*
* This only needs to be done for the 8BPP (256 color) case.
*
\**************************************************************************/

static void
FlushPalette(HDC hdc, int nColors)
{
    LOGPALETTE *pPal;
    HPALETTE hpal, hpalOld;
    int i;

    if (nColors == 256)
    {
        pPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,
                                         sizeof(LOGPALETTE) + nColors * sizeof(PALETTEENTRY));

        if (pPal)
        {
	    pPal->palVersion = 0x300;
	    pPal->palNumEntries = (WORD)nColors;

        // Mark everything PC_NOCOLLAPSE and PC_RESERVED to force every thing
        // into the palette.  Colors are already black because we zero initialized
        // during memory allocation.

            for (i = 0; i < nColors; i++)
            {
                pPal->palPalEntry[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
            }

            hpal = CreatePalette(pPal);
            LocalFree(pPal);

            hpalOld = SelectPalette(hdc, hpal, FALSE);
            RealizePalette(hdc);

            SelectPalette(hdc, hpalOld, FALSE);
            DeleteObject(hpal);
        }
    }
}

static HPALETTE
CreateRGBPalette( HDC Dc )
{
    PIXELFORMATDESCRIPTOR Pfd, *pPfd;
    LOGPALETTE *LogPalette;
    UINT Count;

    if ( NULL == tkhpalette )
    {
        pPfd = &Pfd;

        if ( PixelFormatDescriptorFromDc( Dc, pPfd ) )
        {
            /*
             *  Make sure we need a palette
             */

            if ( (pPfd->iPixelType == PFD_TYPE_RGBA) &&
                 (pPfd->dwFlags & PFD_NEED_PALETTE) )
            {
                /*
                 *  Note how palette is to be realized.  Take over the
                 *  system colors if either the pixel format requires it
                 *  or the app wants it.
                 */
                tkUseStaticColors = ( pPfd->dwFlags & PFD_NEED_SYSTEM_PALETTE )
                                    || TK_USE_FIXED_332_PAL(windInfo.type);

                Count       = 1 << pPfd->cColorBits;
                LogPalette  = AllocateMemory( sizeof(LOGPALETTE) +
                                Count * sizeof(PALETTEENTRY));

                if ( NULL != LogPalette )
                {
                    LogPalette->palVersion    = 0x300;
                    LogPalette->palNumEntries = (WORD)Count;

                    FillRgbPaletteEntries( pPfd,
                                           &LogPalette->palPalEntry[0],
                                           Count );

                    tkhpalette = CreatePalette(LogPalette);
                    FreeMemory(LogPalette);

                    FlushPalette(Dc, Count);
                    
                    RealizePaletteNow( Dc, tkhpalette, FALSE );
                }
            }
        }
    }
    return( tkhpalette );
}

static HPALETTE
CreateCIPalette( HDC Dc )
{
    PIXELFORMATDESCRIPTOR Pfd;
    LOGPALETTE *LogicalPalette;
    HPALETTE StockPalette;
    UINT PaletteSize, StockPaletteSize, EntriesToCopy;

    if ( (Dc != NULL) && (NULL == tkhpalette) )
    {
        if ( PixelFormatDescriptorFromDc( Dc, &Pfd ) )
        {
            if ( Pfd.iPixelType == PFD_TYPE_COLORINDEX )
            {
                /*
                 *  Note how palette is to be realized (Is this the correct place to do this?)
                 */
                tkUseStaticColors = ( Pfd.dwFlags & PFD_NEED_SYSTEM_PALETTE )
                                    || TK_USE_FIXED_332_PAL(windInfo.type);

                /*
                 *  Limit the size of the palette to 256 colors.
                 *  Why? Because this is what was decided.
                 */

                PaletteSize = (Pfd.cColorBits >= 8) ? 256 : (1 << Pfd.cColorBits);

                LogicalPalette = AllocateZeroedMemory( sizeof(LOGPALETTE) +
                                        (PaletteSize * sizeof(PALETTEENTRY)) );

                if ( NULL != LogicalPalette )
                {
                    LogicalPalette->palVersion    = 0x300;
                    LogicalPalette->palNumEntries = (WORD)PaletteSize;

                    StockPalette     = GetStockObject(DEFAULT_PALETTE);
                    StockPaletteSize = GetPaletteEntries( StockPalette, 0, 0, NULL );

                    /*
                     *  start by copying default palette into new one
                     */

                    EntriesToCopy = StockPaletteSize < PaletteSize ?
                                        StockPaletteSize : PaletteSize;

                    GetPaletteEntries( StockPalette, 0, EntriesToCopy,
                                        LogicalPalette->palPalEntry );

                    /*
                     *  If we are taking possession of the system colors,
                     *  must guarantee that 0 and 255 are black and white
                     *  (respectively).
                     */

                    if ( tkUseStaticColors && PaletteSize == 256 )
                    {
                        int i;

                        LogicalPalette->palPalEntry[0].peRed =
                        LogicalPalette->palPalEntry[0].peGreen =
                        LogicalPalette->palPalEntry[0].peBlue = 0x00;

                        LogicalPalette->palPalEntry[255].peRed =
                        LogicalPalette->palPalEntry[255].peGreen =
                        LogicalPalette->palPalEntry[255].peBlue = 0xFF;

                        LogicalPalette->palPalEntry[0].peFlags =
                        LogicalPalette->palPalEntry[255].peFlags = 0;

                        /*
                         *  All other entries should be remappable,
                         *  so mark them as PC_NOCOLLAPSE.
                         */
                        for ( i = 1; i < 255; i++ )
                            LogicalPalette->palPalEntry[i].peFlags = PC_NOCOLLAPSE;
                    }

                    tkhpalette = CreatePalette(LogicalPalette);

                    FreeMemory(LogicalPalette);

                    RealizePaletteNow( Dc, tkhpalette, FALSE );
                }
            }
        }
    }
    return( tkhpalette );
}

static BOOL
FindPixelFormat(HDC hdc, GLenum type)
{
    PIXELFORMATDESCRIPTOR pfd;
    int PfdIndex;
    BOOL Result = FALSE;

    if ( TK_MINIMUM_CRITERIA == windInfo.dmPolicy )
        PfdIndex = FindBestPixelFormat(hdc, type, &pfd);
    else if ( TK_EXACT_MATCH == windInfo.dmPolicy )
        PfdIndex = FindExactPixelFormat(hdc, type, &pfd);
    else if ( IsPixelFormatValid(hdc, windInfo.ipfd, &pfd) )
        PfdIndex = windInfo.ipfd;
    else
        PfdIndex = 0;

    if ( PfdIndex )
    {
        if ( SetPixelFormat(hdc, PfdIndex, &pfd) )
        {
            /*
             *  If this pixel format requires a palette do it now.
             *  In colorindex mode, create a logical palette only
             *  if the application needs to modify it.
             */

            CreateRGBPalette( hdc );
            Result = TRUE;
        }
        else
        {
            PrintMessage("SetPixelFormat failed\n");
        }
    }
    else
    {
        PrintMessage("Selecting a pixel format failed\n");
    }
    return(Result);
}

static int
FindBestPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd)
{
    PIXELFORMATDESCRIPTOR pfd;

    pfd.nSize       = sizeof(pfd);
    pfd.nVersion    = 1;
    pfd.dwFlags     = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;

    if (TK_IS_DOUBLE(type))
        pfd.dwFlags |= PFD_DOUBLEBUFFER;

    if (TK_IS_INDEX(type)) {
        pfd.iPixelType = PFD_TYPE_COLORINDEX;
        pfd.cColorBits = 8;
    } else {
        pfd.iPixelType = PFD_TYPE_RGBA;
        pfd.cColorBits = 24;
    }

    if (TK_HAS_ALPHA(type))
        pfd.cAlphaBits = 8;
    else
        pfd.cAlphaBits = 0;

    if (TK_HAS_ACCUM(type))
        pfd.cAccumBits = pfd.cColorBits + pfd.cAlphaBits;
    else
        pfd.cAccumBits = 0;

    if (TK_HAS_DEPTH(type)) {
        if (TK_IS_DEPTH16(type))
            pfd.cDepthBits = 16;
        else
            pfd.cDepthBits = 24;
    } else {
        pfd.cDepthBits = 0;
    }

    if (TK_HAS_STENCIL(type))
        pfd.cStencilBits = 4;
    else
        pfd.cStencilBits = 0;

    pfd.cAuxBuffers = 0;
    pfd.iLayerType  = PFD_MAIN_PLANE;
    *ppfd = pfd;

    return ( ChoosePixelFormat(hdc, &pfd) );
}

static int
FindExactPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd)
{
    int i, MaxPFDs, Score, BestScore, BestPFD;
    PIXELFORMATDESCRIPTOR pfd;

    i = 1;
    BestPFD = BestScore = 0;
    do
    {
        MaxPFDs = DescribePixelFormat(hdc, i, sizeof(pfd), &pfd);
        if ( MaxPFDs <= 0 )
            return ( 0 );

        Score = 0;
        if ( !( ( pfd.dwFlags & PFD_DRAW_TO_WINDOW ) &&
                ( pfd.dwFlags & PFD_SUPPORT_OPENGL ) ) )
            continue;
        if ( pfd.iLayerType != PFD_MAIN_PLANE )
            continue;
        if ( ( pfd.iPixelType == PFD_TYPE_RGBA ) && ( TK_IS_INDEX(type) ) )
            continue;
        if ( ( pfd.iPixelType == PFD_TYPE_COLORINDEX ) && ( TK_IS_RGB(type) ) )
            continue;
        if ( ( pfd.dwFlags & PFD_DOUBLEBUFFER ) && ( TK_IS_SINGLE(type) ) )
            continue;
        if ( !( pfd.dwFlags & PFD_DOUBLEBUFFER ) && ( TK_IS_DOUBLE(type) ) )
            continue;

/* If accum requested then accum rgb size must be > 0 */
/* If alpha requested then alpha size must be > 0 */
/* if accum & alpha requested then accum alpha size must be > 0 */
        if ( TK_IS_RGB(type) )
        {
            if ( TK_HAS_ACCUM(type) )
            {
                if (  pfd.cAccumBits <= 0 )
                    continue;
            }
            else
            {
                if ( pfd.cAccumBits > 0 )
                    continue;
            }

            if ( TK_HAS_ALPHA(type) )
            {
                if ( pfd.cAlphaBits <= 0 )
                    continue;
                if ( TK_HAS_ACCUM(type) && pfd.cAccumAlphaBits <= 0 )
                    continue;
            }
            else
            {
                if ( pfd.cAlphaBits > 0 )
                    continue;
            }
        }

        if ( TK_HAS_DEPTH(type) )
        {
            if ( pfd.cDepthBits <= 0 )
                continue;
        }
        else
        {
            if ( pfd.cDepthBits > 0 )
                continue;
        }

        if ( TK_HAS_STENCIL(type) )
        {
            if ( pfd.cStencilBits <= 0 )
                continue;
        }
        else
        {
            if ( pfd.cStencilBits > 0 )
                continue;
        }

        Score = pfd.cColorBits;

        if (Score > BestScore)
        {
            BestScore = Score;
            BestPFD = i;
            *ppfd = pfd;
        }
    } while (++i <= MaxPFDs);

    return ( BestPFD );
}

static BOOL IsPixelFormatValid(HDC hdc, int ipfd, PIXELFORMATDESCRIPTOR *ppfd)
{
    if ( ipfd > 0 )
    {
        if ( ipfd <= DescribePixelFormat(hdc, ipfd, sizeof(*ppfd), ppfd) )
        {
            if ( ( ppfd->dwFlags & PFD_DRAW_TO_WINDOW ) &&
                 ( ppfd->dwFlags & PFD_SUPPORT_OPENGL ) )
            {
                return ( TRUE );
            }
        }
    }
    return ( FALSE );
}


static void
PrintMessage( const char *Format, ... )
{
    va_list ArgList;
    char Buffer[256];

    va_start(ArgList, Format);
    vsprintf(Buffer, Format, ArgList);
    va_end(ArgList);

    MESSAGEBOX(GetFocus(), Buffer, "Error", MB_OK);
}

static void
DelayPaletteRealization( void )
{
    MSG Message;

    TKASSERT(NULL!=tkhwnd);

    /*
     *  Add a WM_USER message to the queue, if there isn't one there already.
     */

    if (!PeekMessage(&Message, tkhwnd, WM_USER, WM_USER, PM_NOREMOVE) )
    {
        PostMessage( tkhwnd, WM_USER, 0, 0);
    }
}

/******************************Public*Routine******************************\
* RealizePaletteNow
*
* Select the given palette in background or foreground mode (as specified
* by the bForceBackground flag), and realize the palette.
*
* If static system color usage is set, the system colors are replaced.
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

long
RealizePaletteNow( HDC Dc, HPALETTE Palette, BOOL bForceBackground )
{
    long Result = -1;
    BOOL bHaveSysPal = TRUE;

    TKASSERT( NULL!=Dc      );
    TKASSERT( NULL!=Palette );

// If static system color usage is set, prepare to take over the
// system palette.

    if ( tkUseStaticColors )
    {
    // If foreground, take over the static colors.  If background, release
    // the static colors.

        if ( !bForceBackground )
        {
        // If GrabStaticEntries succeeds, then it is OK to take over the
        // static colors.  If not, then GrabStaticEntries will have
        // posted a WM_USER message for us to try again later.

            bHaveSysPal = GrabStaticEntries( Dc );
        }
        else
        {
        // If we are currently using the system colors (tkSystemColorsInUse)
        // and RealizePaletteNow was called with bForceBackground set, we
        // are being deactivated and must release the static system colors.

            ReleaseStaticEntries( Dc );
        }

    // Rerealize the palette.
    //
    // If set to TRUE, bForceBackground will force the palette to be realized
    // as a background palette, regardless of focus.  This will happen anyway
    // if the TK window does not have the keyboard focus.

        if ( (bForceBackground || bHaveSysPal) &&
             UnrealizeObject( Palette ) &&
             NULL != SelectPalette( Dc, Palette, bForceBackground ) )
        {
            Result = RealizePalette( Dc );
        }
    }
    else
    {
        if ( NULL != SelectPalette( Dc, Palette, FALSE ) )
        {
            Result = RealizePalette( Dc );
        }
    }

    return( Result );
}

static void
ForceRedraw( HWND Window )
{
    MSG Message;

    if (!PeekMessage(&Message, Window, WM_PAINT, WM_PAINT, PM_NOREMOVE) )
    {
        InvalidateRect( Window, NULL, FALSE );
    }
}

static int
PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd )
{
    int PfdIndex;

    if ( 0 < (PfdIndex = GetPixelFormat( Dc )) )
    {
        if ( 0 < DescribePixelFormat( Dc, PfdIndex, sizeof(*Pfd), Pfd ) )
        {
            return(PfdIndex);
        }
        else
        {
            PrintMessage("Could not get a description of pixel format %d\n",
                PfdIndex );
        }
    }
    else
    {
        PrintMessage("Could not get pixel format for Dc 0x%08lX\n", Dc );
    }
    return( 0 );
}

static void
DestroyThisWindow( HWND Window )
{
    if ( NULL != Window )
    {
        DestroyWindow( Window );
    }
}

/*
 *  This Should be called in response to a WM_DESTROY message
 */

static void
CleanUp( void )
{
    HPALETTE hStock;

// Cleanup the palette.

    if ( NULL != tkhpalette )
    {
    // If static system color usage is set, restore the system colors.

        if ( tkUseStaticColors )
        {
            RealizePaletteNow( tkhdc, GetStockObject(DEFAULT_PALETTE), TRUE );
        }
        else
        {
            if ( hStock = GetStockObject( DEFAULT_PALETTE ) )
                SelectPalette( tkhdc, hStock, FALSE );
        }

        DeleteObject( tkhpalette );
    }

// Cleanup the RC.

    if ( NULL != tkhrc )
    {
        wglMakeCurrent( tkhdc, NULL );  // Release first...
        wglDeleteContext( tkhrc );      // then delete.
    }

// Cleanup the DC.

    if ( NULL != tkhdc )
    {
        ReleaseDC( tkhwnd, tkhdc );
    }

// Be really nice and reset global values.

    tkhwnd        = NULL;
    tkhdc         = NULL;
    tkhrc         = NULL;
    tkhpalette    = NULL;

    ExposeFunc    = NULL;
    ReshapeFunc   = NULL;
    IdleFunc      = NULL;
    DisplayFunc   = NULL;
    KeyDownFunc   = NULL;
    MouseDownFunc = NULL;
    MouseUpFunc   = NULL;
    MouseMoveFunc = NULL;
}

static void *
AllocateMemory( size_t Size )
{
    return( LocalAlloc( LMEM_FIXED, Size ) );
}

static void *
AllocateZeroedMemory( size_t Size )
{
    return( LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size ) );
}


static void
FreeMemory( void *Chunk )
{
    TKASSERT( NULL!=Chunk );

    LocalFree( Chunk );
}


/*******************************************************************
 *                                                                 *
 *  Debugging functions go here                                    *
 *                                                                 *
 *******************************************************************/

#if DBGFUNC

static void
DbgPrintf( const char *Format, ... )
{
    va_list ArgList;
    char Buffer[256];

    va_start(ArgList, Format);
    vsprintf(Buffer, Format, ArgList);
    va_end(ArgList);

    printf("%s", Buffer );
    fflush(stdout);
}

static void
pwi( void )
{
    DbgPrintf("windInfo: x %d, y %d, w %d, h %d\n", windInfo.x, windInfo.y, windInfo.width, windInfo.height);
}

static void
pwr(RECT *pr)
{
    DbgPrintf("Rect: left %d, top %d, right %d, bottom %d\n", pr->left, pr->top, pr->right, pr->bottom);
}

static void
ShowPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    int format;

    ppfd   = &pfd;
    format = PixelFormatDescriptorFromDc( hdc, ppfd );

    DbgPrintf("Pixel format %d\n", format);
    DbgPrintf("  dwFlags - 0x%x", ppfd->dwFlags);
        if (ppfd->dwFlags & PFD_DOUBLEBUFFER) DbgPrintf("PFD_DOUBLEBUFFER ");
        if (ppfd->dwFlags & PFD_STEREO) DbgPrintf("PFD_STEREO ");
        if (ppfd->dwFlags & PFD_DRAW_TO_WINDOW) DbgPrintf("PFD_DRAW_TO_WINDOW ");
        if (ppfd->dwFlags & PFD_DRAW_TO_BITMAP) DbgPrintf("PFD_DRAW_TO_BITMAP ");
        if (ppfd->dwFlags & PFD_SUPPORT_GDI) DbgPrintf("PFD_SUPPORT_GDI ");
        if (ppfd->dwFlags & PFD_SUPPORT_OPENGL) DbgPrintf("PFD_SUPPORT_OPENGL ");
        if (ppfd->dwFlags & PFD_GENERIC_FORMAT) DbgPrintf("PFD_GENERIC_FORMAT ");
        if (ppfd->dwFlags & PFD_NEED_PALETTE) DbgPrintf("PFD_NEED_PALETTE ");
        if (ppfd->dwFlags & PFD_NEED_SYSTEM_PALETTE) DbgPrintf("PFD_NEED_SYSTEM_PALETTE ");
        DbgPrintf("\n");
    DbgPrintf("  iPixelType - %d", ppfd->iPixelType);
        if (ppfd->iPixelType == PFD_TYPE_RGBA) DbgPrintf("PGD_TYPE_RGBA\n");
        if (ppfd->iPixelType == PFD_TYPE_COLORINDEX) DbgPrintf("PGD_TYPE_COLORINDEX\n");
    DbgPrintf("  cColorBits - %d\n", ppfd->cColorBits);
    DbgPrintf("  cRedBits - %d\n", ppfd->cRedBits);
    DbgPrintf("  cRedShift - %d\n", ppfd->cRedShift);
    DbgPrintf("  cGreenBits - %d\n", ppfd->cGreenBits);
    DbgPrintf("  cGreenShift - %d\n", ppfd->cGreenShift);
    DbgPrintf("  cBlueBits - %d\n", ppfd->cBlueBits);
    DbgPrintf("  cBlueShift - %d\n", ppfd->cBlueShift);
    DbgPrintf("  cAlphaBits - %d\n", ppfd->cAlphaBits);
    DbgPrintf("  cAlphaShift - 0x%x\n", ppfd->cAlphaShift);
    DbgPrintf("  cAccumBits - %d\n", ppfd->cAccumBits);
    DbgPrintf("  cAccumRedBits - %d\n", ppfd->cAccumRedBits);
    DbgPrintf("  cAccumGreenBits - %d\n", ppfd->cAccumGreenBits);
    DbgPrintf("  cAccumBlueBits - %d\n", ppfd->cAccumBlueBits);
    DbgPrintf("  cAccumAlphaBits - %d\n", ppfd->cAccumAlphaBits);
    DbgPrintf("  cDepthBits - %d\n", ppfd->cDepthBits);
    DbgPrintf("  cStencilBits - %d\n", ppfd->cStencilBits);
    DbgPrintf("  cAuxBuffers - %d\n", ppfd->cAuxBuffers);
    DbgPrintf("  iLayerType - %d\n", ppfd->iLayerType);
    DbgPrintf("  bReserved - %d\n", ppfd->bReserved);
    DbgPrintf("  dwLayerMask - 0x%x\n", ppfd->dwLayerMask);
    DbgPrintf("  dwVisibleMask - 0x%x\n", ppfd->dwVisibleMask);
    DbgPrintf("  dwDamageMask - 0x%x\n", ppfd->dwDamageMask);

}

#endif  /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\teapot.h ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/* Rim, body, lid, and bottom data must be reflected in x and y; 
 * handle and spout data across the y axis only.
 */

long patchdata[][16] = {
    {102,103,104,105,4,5,6,7,8,9,10,11,12,13,14,15},		   /* rim */
    {12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27},		   /* body */
    {24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40},		   /* body */
    {96,96,96,96,97,98,99,100,101,101,101,101,0,1,2,3,},	   /* lid */
    {0,1,2,3,106,107,108,109,110,111,112,113,114,115,116,117},	   /* lid */
    {118,118,118,118,124,122,119,121,123,126,125,120,40,39,38,37}, /* bottom */
    {41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56},		   /* handle */
    {53,54,55,56,57,58,59,60,61,62,63,64,28,65,66,67},		   /* handle */
    {68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83},		   /* spout */
    {80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95}		   /* spout */
};

#pragma warning (disable:4244)
#pragma warning (disable:4305)

float cpdata[][3] = {
{0.2,0,2.7},{0.2,-0.112,2.7},{0.112,-0.2,2.7},{0,-0.2,2.7},{1.3375,0,2.53125},
{1.3375,-0.749,2.53125},{0.749,-1.3375,2.53125},{0,-1.3375,2.53125},
{1.4375,0,2.53125},{1.4375,-0.805,2.53125},{0.805,-1.4375,2.53125},
{0,-1.4375,2.53125},{1.5,0,2.4},{1.5,-0.84,2.4},{0.84,-1.5,2.4},{0,-1.5,2.4},
{1.75,0,1.875},{1.75,-0.98,1.875},{0.98,-1.75,1.875},{0,-1.75,1.875},{2,0,1.35},
{2,-1.12,1.35},{1.12,-2,1.35},{0,-2,1.35},{2,0,0.9},{2,-1.12,0.9},{1.12,-2,0.9},
{0,-2,0.9},{-2,0,0.9},{2,0,0.45},{2,-1.12,0.45},{1.12,-2,0.45},{0,-2,0.45},
{1.5,0,0.225},{1.5,-0.84,0.225},{0.84,-1.5,0.225},{0,-1.5,0.225},{1.5,0,0.15},
{1.5,-0.84,0.15},{0.84,-1.5,0.15},{0,-1.5,0.15},{-1.6,0,2.025},{-1.6,-0.3,2.025},
{-1.5,-0.3,2.25},{-1.5,0,2.25},{-2.3,0,2.025},{-2.3,-0.3,2.025},{-2.5,-0.3,2.25},
{-2.5,0,2.25},{-2.7,0,2.025},{-2.7,-0.3,2.025},{-3,-0.3,2.25},{-3,0,2.25},
{-2.7,0,1.8},{-2.7,-0.3,1.8},{-3,-0.3,1.8},{-3,0,1.8},{-2.7,0,1.575},
{-2.7,-0.3,1.575},{-3,-0.3,1.35},{-3,0,1.35},{-2.5,0,1.125},{-2.5,-0.3,1.125},
{-2.65,-0.3,0.9375},{-2.65,0,0.9375},{-2,-0.3,0.9},{-1.9,-0.3,0.6},{-1.9,0,0.6},
{1.7,0,1.425},{1.7,-0.66,1.425},{1.7,-0.66,0.6},{1.7,0,0.6},{2.6,0,1.425},
{2.6,-0.66,1.425},{3.1,-0.66,0.825},{3.1,0,0.825},{2.3,0,2.1},{2.3,-0.25,2.1},
{2.4,-0.25,2.025},{2.4,0,2.025},{2.7,0,2.4},{2.7,-0.25,2.4},{3.3,-0.25,2.4},
{3.3,0,2.4},{2.8,0,2.475},{2.8,-0.25,2.475},{3.525,-0.25,2.49375},
{3.525,0,2.49375},{2.9,0,2.475},{2.9,-0.15,2.475},{3.45,-0.15,2.5125},
{3.45,0,2.5125},{2.8,0,2.4},{2.8,-0.15,2.4},{3.2,-0.15,2.4},{3.2,0,2.4},
{0,0,3.15},{0.8,0,3.15},{0.8,-0.45,3.15},{0.45,-0.8,3.15},{0,-0.8,3.15},
{0,0,2.85},{1.4,0,2.4},{1.4,-0.784,2.4},{0.784,-1.4,2.4},{0,-1.4,2.4},
{0.4,0,2.55},{0.4,-0.224,2.55},{0.224,-0.4,2.55},{0,-0.4,2.55},{1.3,0,2.55},
{1.3,-0.728,2.55},{0.728,-1.3,2.55},{0,-1.3,2.55},{1.3,0,2.4},{1.3,-0.728,2.4},
{0.728,-1.3,2.4},{0,-1.3,2.4},{0,0,0},{1.425,-0.798,0},{1.5,0,0.075},{1.425,0,0},
{0.798,-1.425,0},{0,-1.5,0.075},{0,-1.425,0},{1.5,-0.84,0.075},{0.84,-1.5,0.075}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\tkdib.c ===
/******************************Module*Header*******************************\
* Module Name: dib.c
*
* (Brief description)
*
* Created: 21-Feb-1994 23:12:58
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
*   (#defines)
*   (#includes)
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> 
#include "tk.h"

#define static

#define BFT_BITMAP  0x4d42  // 'BM' -- indicates structure is BITMAPFILEHEADER

// struct BITMAPFILEHEADER {
//      WORD  bfType
//      DWORD bfSize
//      WORD  bfReserved1
//      WORD  bfReserved2
//      DWORD bfOffBits
// }
#define OFFSET_bfType       0
#define OFFSET_bfSize       2
#define OFFSET_bfReserved1  6
#define OFFSET_bfReserved2  8
#define OFFSET_bfOffBits    10
#define SIZEOF_BITMAPFILEHEADER 14

// Read a WORD-aligned DWORD.  Needed because BITMAPFILEHEADER has
// WORD-alignment.
#define READDWORD(pv)   ( (DWORD)((PWORD)(pv))[0]               \
                          | ((DWORD)((PWORD)(pv))[1] << 16) )   \

// Computes the number of BYTES needed to contain n number of bits.
#define BITS2BYTES(n)   ( ((n) + 7) >> 3 )

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DibNumColors(VOID FAR * pv)                                *
 *                                                                          *
 *  PURPOSE    : Determines the number of colors in the DIB by looking at   *
 *               the BitCount filed in the info block.                      *
 *                                                                          *
 *  RETURNS    : The number of colors in the DIB.                           *
 *                                                                          *
 * Stolen from SDK ShowDIB example.                                         *
 ****************************************************************************/

WORD DibNumColors(VOID FAR * pv)
{
    WORD                bits;
    BITMAPINFOHEADER UNALIGNED *lpbi;
    BITMAPCOREHEADER UNALIGNED *lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     *
     *  Because of the way we use this call, BITMAPINFOHEADER may be out
     *  of alignment if it follows a BITMAPFILEHEADER.  So use the macro
     *  to safely access DWORD fields.
     */
    if (READDWORD(&lpbi->biSize) != sizeof(BITMAPCOREHEADER)){
        if (READDWORD(&lpbi->biClrUsed) != 0)
        {
            return (WORD) READDWORD(&lpbi->biClrUsed);
        }
        bits = lpbi->biBitCount;
    }
    else
        bits = lpbc->bcBitCount;

    switch (bits){
        case 1:
            return 2;
        case 4:
            return 16;
        case 8:
            return 256;
        default:
            /* A 24 bitcount DIB has no color table */
            return 0;
    }
}

/******************************Public*Routine******************************\
* tkDIBImageLoad
*
* ANSI version stub.  Only here for orthogonality with tkRGBImageLoad.
*
* History:
*  22-Feb-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

TK_RGBImageRec *tkDIBImageLoadAW(char *fileName, BOOL bUnicode);

TK_RGBImageRec *tkDIBImageLoad(char *fileName)
{
    return tkDIBImageLoadAW(fileName, FALSE);
}

/******************************Public*Routine******************************\
* tkDIBImageLoadAW
*
* Loads a DIB file (specified as either an ANSI or Unicode filename,
* depending on the bUnicode flag) and converts it into a TK image format.
*
* The technique used is based on CreateDIBSection and SetDIBits.
* CreateDIBSection is used to create a DIB with a format easily converted
* into the TK image format (packed 24BPP RGB).  The only conversion 
* required is swapping R and B in each RGB triplet (see history below)
* The resulting bitmap is selected into a memory DC.
*
* The DIB file is mapped into memory and SetDIBits called to initialize
* the memory DC bitmap.  It is during this step that GDI converts the
* arbitrary DIB file format to RGB format.
*
* Finally, the RGB data in the DIB section is read out and repacked
* as 24BPP 'BGR'.
*
* Returns:
*   Pointer to TK_RGBImageRec.  If an error occurs, a diagnostic error
*   message is put into the error stream and tkQuit() is called,
*   terminating the app.
*
* History:
*  - 22-Feb-1994 -by- Gilman Wong [gilmanw]
*    Wrote it.
*
*  - 01-May-1995 : [marcfo]
*    Don't quit if can't open DIB file - return NULL.
*
*  - 27-Jul-1995 : [marcfo]
*    Changed CreateDIBSection to create an RGB mapping, so this would work
*    on win95.  Swapping of R and B required, to generate BGR (R=low byte)
*    for GL.  If the GL 'BGR' (R=high byte) extension becomes part of api
*    in OpenGL 2.0, then we can avoid swap and do a memcpy to grab the bits.
*
\**************************************************************************/

TK_RGBImageRec *tkDIBImageLoadAW(char *fileName, BOOL bUnicode)
{
    TK_RGBImageRec *final = (TK_RGBImageRec *) NULL; // Ptr to TK image struct
                                                     // to return.  Non-NULL
                                                     // only for success.

    WORD             wNumColors;    // Number of colors in color table
    BITMAPFILEHEADER *pbmf;         // Ptr to file header
    BITMAPINFOHEADER UNALIGNED *pbmihFile;
    BITMAPCOREHEADER UNALIGNED *pbmchFile; // Ptr to file's core header (if it exists)
    PVOID            pvBitsFile;    // Ptr to bitmap bits in file
    PBYTE            pjBitsRGB;     // Ptr to 24BPP RGB image in DIB section
    PBYTE            pjTKBits = (PBYTE) NULL;   // Ptr to final TK image bits
    PBYTE            pjSrc;         // Ptr to image file used for conversion
    PBYTE            pjDst;         // Ptr to TK image used for conversion

    // These need to be cleaned up when we exit:
    HANDLE     hFile = INVALID_HANDLE_VALUE;        // File handle
    HANDLE     hMap = (HANDLE) NULL;                // Mapping object handle
    PVOID      pvFile = (PVOID) NULL;               // Ptr to mapped file
    HDC        hdcMem = (HDC) NULL;                 // 24BPP mem DC
    HBITMAP    hbmRGB = (HBITMAP) NULL;             // 24BPP RGB bitmap
    BITMAPINFO *pbmiSource = (BITMAPINFO *) NULL;   // Ptr to source BITMAPINFO
    BITMAPINFO *pbmiRGB = (BITMAPINFO *) NULL;      // Ptr to file's BITMAPINFO

    int i, j;
    int padBytes;

// Map the DIB file into memory.

    hFile = bUnicode ? 
            CreateFileW((LPWSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, 0, 0) :
            CreateFileA((LPSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, 0, 0);

    if (hFile == INVALID_HANDLE_VALUE)
        goto tkDIBLoadImage_cleanup;

    hMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!hMap)
        goto tkDIBLoadImage_cleanup;

    pvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (!pvFile)
        goto tkDIBLoadImage_cleanup;

// Check the file header.  If the BFT_BITMAP magic number is there,
// then the file format is a BITMAPFILEHEADER followed immediately
// by either a BITMAPINFOHEADER or a BITMAPCOREHEADER.  The bitmap
// bits, in this case, are located at the offset bfOffBits from the
// BITMAPFILEHEADER.
//
// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER
// followed immediately with the color table and the bitmap bits.

    pbmf = (BITMAPFILEHEADER *) pvFile;

    if ( pbmf->bfType == BFT_BITMAP )
    {
        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER);

    // BITMAPFILEHEADER is WORD aligned, so use safe macro to read DWORD
    // bfOffBits field.

        pvBitsFile = (PVOID *) ((PBYTE) pbmf
                                + READDWORD((PBYTE) pbmf + OFFSET_bfOffBits));
    }
    else
    {
        pbmihFile = (BITMAPINFOHEADER *) pvFile;

    // Determination of where the bitmaps bits are needs to wait until we
    // know for sure whether we have a BITMAPINFOHEADER or a BITMAPCOREHEADER.
    }

// Determine the number of colors in the DIB palette.  This is non-zero
// only for 8BPP or less.

    wNumColors = DibNumColors(pbmihFile);

// Create a BITMAPINFO (with color table) for the DIB file.  Because the
// file may not have one (BITMAPCORE case) and potential alignment problems,
// we will create a new one in memory we allocate.
//
// We distinguish between BITMAPINFO and BITMAPCORE cases based upon
// BITMAPINFOHEADER.biSize.

    pbmiSource = (BITMAPINFO *)
        LocalAlloc(LMEM_FIXED, sizeof(BITMAPINFO)
                               + wNumColors * sizeof(RGBQUAD));
    if (!pbmiSource)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    // Note: need to use safe READDWORD macro because pbmihFile may
    // have only WORD alignment if it follows a BITMAPFILEHEADER.

    switch (READDWORD(&pbmihFile->biSize))
    {
    case sizeof(BITMAPINFOHEADER):

    // Convert WORD-aligned BITMAPINFOHEADER to aligned BITMAPINFO.

        pbmiSource->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmiSource->bmiHeader.biWidth         = READDWORD(&pbmihFile->biWidth);
        pbmiSource->bmiHeader.biHeight        = READDWORD(&pbmihFile->biHeight);
        pbmiSource->bmiHeader.biPlanes        = pbmihFile->biPlanes;
        pbmiSource->bmiHeader.biBitCount      = pbmihFile->biBitCount;
        pbmiSource->bmiHeader.biCompression   = 
                                        READDWORD(&pbmihFile->biCompression);
        pbmiSource->bmiHeader.biSizeImage     = 
                                        READDWORD(&pbmihFile->biSizeImage);
        pbmiSource->bmiHeader.biXPelsPerMeter = 
                                        READDWORD(&pbmihFile->biXPelsPerMeter);
        pbmiSource->bmiHeader.biYPelsPerMeter = 
                                        READDWORD(&pbmihFile->biYPelsPerMeter);
        pbmiSource->bmiHeader.biClrUsed       = 
                                        READDWORD(&pbmihFile->biClrUsed);
        pbmiSource->bmiHeader.biClrImportant  = 
                                        READDWORD(&pbmihFile->biClrImportant);

    // Copy color table.  It immediately follows the BITMAPINFOHEADER.

        memcpy((PVOID) &pbmiSource->bmiColors[0], (PVOID) (pbmihFile + 1),
               wNumColors * sizeof(RGBQUAD));

    // If we haven't already determined the position of the image bits,
    // we may now assume that they immediately follow the color table.

        if (!pvBitsFile)
            pvBitsFile = (PVOID) ((PBYTE) (pbmihFile + 1)
                         + wNumColors * sizeof(RGBQUAD));
        break;

    case sizeof(BITMAPCOREHEADER):
        pbmchFile = (BITMAPCOREHEADER *) pbmihFile;

    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER.

        pbmiSource->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmiSource->bmiHeader.biWidth         = (DWORD) pbmchFile->bcWidth;
        pbmiSource->bmiHeader.biHeight        = (DWORD) pbmchFile->bcHeight;
        pbmiSource->bmiHeader.biPlanes        = pbmchFile->bcPlanes;
        pbmiSource->bmiHeader.biBitCount      = pbmchFile->bcBitCount;
        pbmiSource->bmiHeader.biCompression   = BI_RGB;
        pbmiSource->bmiHeader.biSizeImage     = 0;
        pbmiSource->bmiHeader.biXPelsPerMeter = 0;
        pbmiSource->bmiHeader.biYPelsPerMeter = 0;
        pbmiSource->bmiHeader.biClrUsed       = wNumColors;
        pbmiSource->bmiHeader.biClrImportant  = wNumColors;

    // Convert RGBTRIPLE color table into RGBQUAD color table.

        {
            RGBQUAD *rgb4 = pbmiSource->bmiColors;
            RGBTRIPLE *rgb3 = (RGBTRIPLE *) (pbmchFile + 1);

            for (i = 0; i < wNumColors; i++)
            {
                rgb4->rgbRed   = rgb3->rgbtRed  ;
                rgb4->rgbGreen = rgb3->rgbtGreen;
                rgb4->rgbBlue  = rgb3->rgbtBlue ;
                rgb4->rgbReserved = 0;

                rgb4++;
                rgb3++;
            }
        }

    // If we haven't already determined the position of the image bits,
    // we may now assume that they immediately follow the color table.

        if (!pvBitsFile)
            pvBitsFile = (PVOID) ((PBYTE) (pbmihFile + 1)
                         + wNumColors * sizeof(RGBTRIPLE));
        break;

    default:
        MESSAGEBOX(GetFocus(), "Unknown DIB file format.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Fill in default values (for fields that can have defaults).

    if (pbmiSource->bmiHeader.biSizeImage == 0)
        pbmiSource->bmiHeader.biSizeImage = 
            BITS2BYTES( (DWORD) pbmiSource->bmiHeader.biWidth * 
                                pbmiSource->bmiHeader.biBitCount ) * 
                                pbmiSource->bmiHeader.biHeight;
    if (pbmiSource->bmiHeader.biClrUsed == 0)
        pbmiSource->bmiHeader.biClrUsed = wNumColors;

// Create memory DC.

    hdcMem = CreateCompatibleDC(NULL);
    if (!hdcMem) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Create a 24BPP RGB DIB section and select it into the memory DC.

    pbmiRGB = (BITMAPINFO *)
              LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(BITMAPINFO) );
    if (!pbmiRGB)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    pbmiRGB->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmiRGB->bmiHeader.biWidth         = pbmiSource->bmiHeader.biWidth;
    pbmiRGB->bmiHeader.biHeight        = pbmiSource->bmiHeader.biHeight;
    pbmiRGB->bmiHeader.biPlanes        = 1;
    pbmiRGB->bmiHeader.biBitCount      = 24;
    pbmiRGB->bmiHeader.biCompression   = BI_RGB;
    pbmiRGB->bmiHeader.biSizeImage     = pbmiRGB->bmiHeader.biWidth
                                         * abs(pbmiRGB->bmiHeader.biHeight) * 3;

    hbmRGB = CreateDIBSection(hdcMem, pbmiRGB, DIB_RGB_COLORS, 
                              (PVOID *) &pjBitsRGB, NULL, 0);

    if (!hbmRGB)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); 
        goto tkDIBLoadImage_cleanup;
    }

    if (!SelectObject(hdcMem, hbmRGB))
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Slam the DIB file image into the memory DC.  GDI will do the work of
// translating whatever format the DIB file has into RGB format.

    if (!SetDIBits(hdcMem, hbmRGB, 0, pbmiSource->bmiHeader.biHeight, 
                   pvBitsFile, pbmiSource, DIB_RGB_COLORS))
    {
        MESSAGEBOX(GetFocus(), "Image file conversion error.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }
    GdiFlush();     // make sure that SetDIBits executes

// Convert to TK image format (packed RGB format).
// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app
// can deallocate with free()).

    pjTKBits = (PBYTE) malloc(pbmiRGB->bmiHeader.biSizeImage);
    if (!pjTKBits)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    pjSrc = pjBitsRGB;
    pjDst = pjTKBits;
    // src lines end on LONG boundary - so need to skip over any padding bytes
    padBytes = pbmiSource->bmiHeader.biWidth % sizeof(LONG);
    for (i = 0; i < pbmiSource->bmiHeader.biHeight; i++)
    {
        for (j = 0; j < pbmiSource->bmiHeader.biWidth; j++)
        {
            // swap R and B
            *pjDst++ = pjSrc[2];
            *pjDst++ = pjSrc[1];
            *pjDst++ = pjSrc[0];
            pjSrc += 3;
        }
        pjSrc += padBytes;
    }

// Allocate and initialize the TK_RGBImageRec.
// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app
// can deallocate with free()).

    final = (TK_RGBImageRec *)malloc(sizeof(TK_RGBImageRec));
    if (final == NULL) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }
    // If we get to here, we have suceeded!
    final->sizeX = pbmiSource->bmiHeader.biWidth;
    final->sizeY = pbmiSource->bmiHeader.biHeight;
    final->data = pjTKBits;

// Cleanup objects.

tkDIBLoadImage_cleanup:
    {
        if (hdcMem)
            DeleteDC(hdcMem);

        if (hbmRGB)
            DeleteObject(hbmRGB);

        if (pbmiRGB)
            LocalFree(pbmiRGB);

        if (pbmiSource)
            LocalFree(pbmiSource);

        if (pvFile)
            UnmapViewOfFile(pvFile);

        if (hMap)
            CloseHandle(hMap);

        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
    }

// Check for error.

    if (!final)
    {
        if (pjTKBits)
            free(pjTKBits);

        if ( (hFile == INVALID_HANDLE_VALUE) || !hMap || !pvFile )
        {
            CHAR ach[256];

            bUnicode ? wsprintf(ach, "Failed to open DIB file %ws.\n", fileName) :
                       wsprintf(ach, "Failed to open DIB file %s.\n", fileName);

            MESSAGEBOX(GetFocus(), ach, "Error", MB_OK);
        }
    }

    return final;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\vect3d.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/* Routines to manipulate 3 dimensional vectors.  All these routines
 * should work even if the input and output vectors are the same.
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <GL/gl.h>
#include "3d.h"
#include "tk.h"

#define static

void (*errfunc)(char *) = 0;

void seterrorfunc(void (*func)(char *))
{
    errfunc = func;
}

void error(char *s)
{
    if (errfunc)
        (*errfunc)(s);
    else {
        MESSAGEBOX(GetFocus(), s, "Error", MB_OK);
        exit(1);
    }
}

void diff3(GLdouble p[3], GLdouble q[3], GLdouble diff[3])
{
    diff[0] = p[0] - q[0];
    diff[1] = p[1] - q[1];
    diff[2] = p[2] - q[2];
}

void add3(GLdouble p[3], GLdouble q[3], GLdouble sum[3])
{
    sum[0] = p[0] + q[0];
    sum[1] = p[1] + q[1];
    sum[2] = p[2] + q[2];
}

void scalarmult(GLdouble s, GLdouble v[3], GLdouble vout[3])
{
    vout[0] = v[0]*s;
    vout[1] = v[1]*s;
    vout[2] = v[2]*s;
}

GLdouble dot3(GLdouble p[3], GLdouble q[3])
{
    return p[0]*q[0] + p[1]*q[1] + p[2]*q[2];
}

GLdouble length3(GLdouble v[3])
{
    return sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
}

GLdouble dist3(GLdouble p[3], GLdouble q[3])
{
    GLdouble d[3];

    diff3(p, q, d);
    return length3(d);
}

void copy3(GLdouble old[3], GLdouble new[3])
{
    new[0] = old[0], new[1] = old[1], new[2] = old[2];
}

void crossprod(GLdouble v1[3], GLdouble v2[3], GLdouble prod[3])
{
    GLdouble p[3];      /* in case prod == v1 or v2 */

    p[0] = v1[1]*v2[2] - v2[1]*v1[2];
    p[1] = v1[2]*v2[0] - v2[2]*v1[0];
    p[2] = v1[0]*v2[1] - v2[0]*v1[1];
    prod[0] = p[0]; prod[1] = p[1]; prod[2] = p[2];
}

void normalize(GLdouble v[3])
{
    GLdouble d;

    d = sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
    if (d == (GLdouble)0.0) {
        error("normalize: zero length vector");
        v[0] = d = (GLdouble)1.0;
    }
    d = (GLdouble)1/d;
    v[0] *= d; v[1] *= d; v[2] *= d;
}

void identifymat3(GLdouble m[3][3])
{
    int i, j;

    for (i=0; i<3; i++)
        for (j=0; j<3; j++)
            m[i][j] = (i == j) ? (GLdouble)1.0 : (GLdouble)0.0;
}

void copymat3(GLdouble *to, GLdouble *from)
{
    int i;

    for (i=0; i<9; i++) {
        *to++ = *from++;
    }
}

void xformvec3(GLdouble v[3], GLdouble m[3][3], GLdouble vm[3])
{
    GLdouble result[3]; /* in case v == vm */
    int i;

    for (i=0; i<3; i++) {
        result[i] = v[0]*m[0][i] + v[1]*m[1][i] + v[2]*m[2][i];
    }
    for (i=0; i<3; i++) {
        vm[i] = result[i];
    }
}

long samepoint(GLdouble p1[3], GLdouble p2[3])
{
    if (p1[0] == p2[0] && p1[1] == p2[1] && p1[2] == p2[2])
        return 1;
    return 0;
}

void perpnorm(GLdouble p1[3], GLdouble p2[3], GLdouble p3[3], GLdouble n[3])
{
    GLdouble d1[3], d2[3];

    diff3(p2, p1, d1);
    diff3(p2, p3, d2);
    crossprod(d1, d2, n);
    normalize(n);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\xform.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <math.h>
#include <stdio.h>
#include <GL/gl.h>
#include "3d.h"

#define static

#define STACKDEPTH 10

typedef struct {
    GLdouble	mat[4][4];
    GLdouble	norm[3][3];
} mat_t;

static mat_t matstack[STACKDEPTH] = {
    {{{1.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 1.0}},
    {{1.0, 0.0, 0.0},
    {0.0, 1.0, 0.0},
    {0.0, 0.0, 1.0}}}
};
static int identitymat = 1;

static int mattop = 0;

void m_xformpt(GLdouble pin[3], GLdouble pout[3], 
    GLdouble nin[3], GLdouble nout[3])
{
    int	i;
    GLdouble	ptemp[3], ntemp[3];
    mat_t	*m = &matstack[mattop];

    if (identitymat) {
	for (i = 0; i < 3; i++) {
	    pout[i] = pin[i];
	    nout[i] = nin[i];
	}
	return;
    }
    for (i = 0; i < 3; i++) {
	ptemp[i] = pin[0]*m->mat[0][i] +
		   pin[1]*m->mat[1][i] +
		   pin[2]*m->mat[2][i] +
		   m->mat[3][i];
	ntemp[i] = nin[0]*m->norm[0][i] +
		   nin[1]*m->norm[1][i] +
		   nin[2]*m->norm[2][i];
    }
    for (i = 0; i < 3; i++) {
	pout[i] = ptemp[i];
	nout[i] = ntemp[i];
    }
    normalize(nout);
}

void m_xformptonly(GLdouble pin[3], GLdouble pout[3])
{
    int	i;
    GLdouble	ptemp[3];
    mat_t	*m = &matstack[mattop];

    if (identitymat) {
	for (i = 0; i < 3; i++) {
	    pout[i] = pin[i];
	}
	return;
    }
     for (i = 0; i < 3; i++) {
	ptemp[i] = pin[0]*m->mat[0][i] +
		   pin[1]*m->mat[1][i] +
		   pin[2]*m->mat[2][i] +
		   m->mat[3][i];
    }
    for (i = 0; i < 3; i++) {
	pout[i] = ptemp[i];
    }
}

void m_pushmatrix(void)
{
    if (mattop < STACKDEPTH-1) {
	matstack[mattop+1] = matstack[mattop];
	mattop++;
    } else
	error("m_pushmatrix: stack overflow\n");
}

void m_popmatrix(void)
{
    if (mattop > 0)
	mattop--;
    else
	error("m_popmatrix: stack underflow\n");
}

void m_translate(GLdouble x, GLdouble y, GLdouble z)
{
    int	i;
    mat_t	*m = &matstack[mattop];

    identitymat = 0;
    for (i = 0; i < 4; i++)
	m->mat[3][i] = x*m->mat[0][i] +
				 y*m->mat[1][i] +
				 z*m->mat[2][i] +
				 m->mat[3][i];
}

void m_scale(GLdouble x, GLdouble y, GLdouble z)
{
    int	i;
    mat_t	*m = &matstack[mattop];

    identitymat = 0;
    for (i = 0; i < 3; i++) {
	m->mat[0][i] *= x;
	m->mat[1][i] *= y;
	m->mat[2][i] *= z;
    }
    for (i = 0; i < 3; i++) {
	m->norm[0][i] /= x;
	m->norm[1][i] /= y;
	m->norm[2][i] /= z;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\tkfont.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include "tk.h"

#define static

enum {
    FONT_BEGIN = 1,
    FONT_NEXT,
    FONT_END,
    FONT_ADVANCE
};
#define MAX_STROKES        256
#define END_OF_LIST        256
#define BITMAP_END_OF_LIST 0

#define STROKE_SCALE ((GLfloat) 1.71)
#define OUTLINE_SCALE ((GLfloat) 0.023)
#define FILLED_SCALE ((GLfloat) 0.023)


GLint strokeFont[][1+MAX_STROKES*3] = {
    {
	1,
	FONT_BEGIN, 0, 4,
	FONT_NEXT, 2, 2,
	FONT_END, 4, 4,
	FONT_BEGIN, 2, 8,
	FONT_END, 2, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	2,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 3, 5,
	FONT_END, 4, 6,
	FONT_BEGIN, 3, 5,
	FONT_NEXT, 3, 3,
	FONT_END, 4, 2,
	FONT_BEGIN, 3, 3,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	3,
	FONT_BEGIN, 0, 0,
	FONT_NEXT, 1, 1,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 5, 5,
	FONT_NEXT, 4, 4,
	FONT_END, 1, 4,
	FONT_BEGIN, 4, 4,
	FONT_NEXT, 5, 3,
	FONT_NEXT, 4, 2,
	FONT_END, 1, 2,
	FONT_ADVANCE, 7, 0
    },
    {
	4,
	FONT_BEGIN, 0, 4,
	FONT_NEXT, 2, 6,
	FONT_END, 4, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	5,
	FONT_BEGIN, 0, 5,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	6,
	FONT_BEGIN, 1, 4,
	FONT_END, 3, 4,
	FONT_BEGIN, 3, 6,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 1, 3,
	FONT_NEXT, 2, 2,
	FONT_END, 3, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	7,
	FONT_BEGIN, 1, 2,
	FONT_END, 1, 6,
	FONT_BEGIN, 0, 6,
	FONT_END, 4, 6,
	FONT_BEGIN, 3, 6,
	FONT_END, 3, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	8,
	FONT_BEGIN, 0, 2,
	FONT_END, 2, 4,
	FONT_BEGIN, 0, 7,
	FONT_NEXT, 0, 6,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	10,
	FONT_ADVANCE, 0, -9
    },
    {
	11,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 1, 1,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 2, 7,
	FONT_NEXT, 3, 8,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	12,
	FONT_BEGIN, 0, 3,
	FONT_END, 4, 3,
	FONT_BEGIN, 4, 6,
	FONT_END, 0, 6,
	FONT_BEGIN, 2, 8,
	FONT_END, 2, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	14,
	FONT_BEGIN, 1, 3,
	FONT_NEXT, 2, 4,
	FONT_NEXT, 2, 5,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 3,
	FONT_END, 2, 4,
	FONT_BEGIN, 2, 5,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 0, 4,
	FONT_END, 1, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	15,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 0, 4,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 3, 5,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 2, 8,
	FONT_END, 1, 8,
	FONT_BEGIN, 4, 4,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	16,
	FONT_BEGIN, 4, 7,
	FONT_NEXT, 1, 7,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 0, 4,
	FONT_NEXT, 1, 3,
	FONT_END, 4, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	17,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 3, 3,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 3, 7,
	FONT_END, 0, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	18,
	FONT_BEGIN, 0, 4,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 7,
	FONT_NEXT, 3, 7,
	FONT_NEXT, 4, 6,
	FONT_END, 4, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	19,
	FONT_BEGIN, 0, 7,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 4,
	FONT_NEXT, 3, 4,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	20,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 2, 2,
	FONT_END, 4, 8,
	FONT_BEGIN, 3, 6,
	FONT_END, 1, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	21,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 4, 2,
	FONT_NEXT, 4, 5,
	FONT_END, 1, 5,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 4, 8,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	22,
	FONT_BEGIN, 0, 4,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 7,
	FONT_NEXT, 3, 7,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 3,
	FONT_NEXT, 1, 3,
	FONT_END, 0, 4,
	FONT_BEGIN, 1, 4,
	FONT_END, 3, 6,
	FONT_BEGIN, 1, 6,
	FONT_END, 3, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	23,
	FONT_BEGIN, 2, 0,
	FONT_NEXT, 0, 2,
	FONT_NEXT, 4, 6,
	FONT_END, 2, 8,
	FONT_BEGIN, 0, 6,
	FONT_END, 4, 6,
	FONT_BEGIN, 0, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	24,
	FONT_BEGIN, 0, 0,
	FONT_END, 4, 0,
	FONT_ADVANCE, 6, 0
    },
    {
	25,
	FONT_BEGIN, 2, 3,
	FONT_NEXT, 4, 5,
	FONT_END, 2, 7,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	26,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 1, 9,
	FONT_NEXT, 2, 9,
	FONT_NEXT, 2, 8,
	FONT_NEXT, 3, 8,
	FONT_END, 4, 9,
	FONT_ADVANCE, 6, 0
    },
    {
	27,
	FONT_BEGIN, 0, 1,
	FONT_END, 4, 7,
	FONT_BEGIN, 4, 5,
	FONT_END, 0, 5,
	FONT_BEGIN, 0, 3,
	FONT_END, 4, 3,
	FONT_ADVANCE, 6, 1
    },
    {
	28,
	FONT_BEGIN, 1, 2,
	FONT_END, 3, 2,
	FONT_BEGIN, 3, 4,
	FONT_NEXT, 1, 6,
	FONT_END, 3, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	29,
	FONT_BEGIN, 1, 2,
	FONT_END, 3, 2,
	FONT_BEGIN, 1, 4,
	FONT_NEXT, 3, 6,
	FONT_END, 1, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	30,
	FONT_BEGIN, 0, 3,
	FONT_END, 4, 3,
	FONT_BEGIN, 4, 5,
	FONT_END, 0, 5,
	FONT_BEGIN, 0, 7,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	31,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 2, 4,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	32,
	FONT_ADVANCE, 6, 0
    },
    {
	33,
	FONT_BEGIN, 2, 1,
	FONT_END, 2, 2,
	FONT_BEGIN, 2, 4,
	FONT_END, 2, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	34,
	FONT_BEGIN, 1, 7,
	FONT_END, 1, 9,
	FONT_BEGIN, 3, 9,
	FONT_END, 3, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	35,
	FONT_BEGIN, 1, 2,
	FONT_END, 1, 7,
	FONT_BEGIN, 3, 7,
	FONT_END, 3, 2,
	FONT_BEGIN, 4, 3,
	FONT_END, 0, 3,
	FONT_BEGIN, 0, 6,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	36,
	FONT_BEGIN, 2, 1,
	FONT_END, 2, 9,
	FONT_BEGIN, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 3, 5,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 2,
	FONT_NEXT, 3, 1,
	FONT_NEXT, 1, 1,
	FONT_END, 0, 2,
	FONT_ADVANCE, 6, -1
    },
    {
	37,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 4, 7,
	FONT_END, 4, 8,
	FONT_BEGIN, 1, 8,
	FONT_NEXT, 0, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 7,
	FONT_END, 1, 8,
	FONT_BEGIN, 4, 3,
	FONT_NEXT, 5, 3,
	FONT_NEXT, 5, 2,
	FONT_NEXT, 4, 2,
	FONT_END, 5, 2,
	FONT_ADVANCE, 8, 1
    },
    {
	38,
	FONT_BEGIN, 4, 4,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 4,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 2, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 6,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	39,
	FONT_BEGIN, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 1, 9,
	FONT_NEXT, 2, 9,
	FONT_NEXT, 2, 8,
	FONT_END, 1, 8,
	FONT_ADVANCE, 6, 1
    },
    {
	40,
	FONT_BEGIN, 4, 2,
	FONT_NEXT, 2, 4,
	FONT_NEXT, 2, 6,
	FONT_END, 4, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	41,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 2, 4,
	FONT_NEXT, 2, 6,
	FONT_END, 0, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	42,
	FONT_BEGIN, 2, 2,
	FONT_END, 2, 8,
	FONT_BEGIN, 0, 7,
	FONT_END, 4, 3,
	FONT_BEGIN, 4, 5,
	FONT_END, 0, 5,
	FONT_BEGIN, 0, 3,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	43,
	FONT_BEGIN, 2, 3,
	FONT_END, 2, 7,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	44,
	FONT_BEGIN, 0, 1,
	FONT_NEXT, 1, 2,
	FONT_END, 1, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	45,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	46,
	FONT_BEGIN, 1, 2,
	FONT_END, 2, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	47,
	FONT_BEGIN, 0, 3,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	48,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	49,
	FONT_BEGIN, 1, 2,
	FONT_END, 3, 2,
	FONT_BEGIN, 2, 2,
	FONT_NEXT, 2, 8,
	FONT_END, 1, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	50,
	FONT_BEGIN, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 0, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	51,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 5,
	FONT_END, 2, 5,
	FONT_BEGIN, 3, 5,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_END, 0, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	52,
	FONT_BEGIN, 3, 2,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 0, 4,
	FONT_END, 4, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	53,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 0, 8,
	FONT_END, 4, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	54,
	FONT_BEGIN, 0, 5,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 5,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 2, 8,
	FONT_END, 3, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	55,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 4, 8,
	FONT_NEXT, 2, 4,
	FONT_END, 2, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	56,
	FONT_BEGIN, 1, 5,
	FONT_NEXT, 0, 4,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 5,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 6,
	FONT_END, 3, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	57,
	FONT_BEGIN, 1, 2,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	58,
	FONT_BEGIN, 0, 3,
	FONT_END, 1, 3,
	FONT_BEGIN, 1, 6,
	FONT_END, 0, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	59,
	FONT_BEGIN, 0, 1,
	FONT_NEXT, 1, 2,
	FONT_END, 1, 3,
	FONT_BEGIN, 1, 6,
	FONT_END, 0, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	60,
	FONT_BEGIN, 3, 3,
	FONT_NEXT, 1, 5,
	FONT_END, 3, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	61,
	FONT_BEGIN, 0, 4,
	FONT_END, 4, 4,
	FONT_BEGIN, 4, 6,
	FONT_END, 0, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	62,
	FONT_BEGIN, 1, 7,
	FONT_NEXT, 3, 5,
	FONT_END, 1, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	63,
	FONT_BEGIN, 1, 2,
	FONT_END, 2, 2,
	FONT_BEGIN, 2, 4,
	FONT_NEXT, 2, 5,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_END, 0, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	64,
	FONT_BEGIN, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 2, 4,
	FONT_NEXT, 2, 6,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	65,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_END, 4, 2,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	66,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 3, 5,
	FONT_END, 0, 5,
	FONT_BEGIN, 3, 5,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 0, 8,
	FONT_END, 0, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	67,
	FONT_BEGIN, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_END, 4, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	68,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_END, 0, 8,
	FONT_BEGIN, 1, 8,
	FONT_END, 1, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	69,
	FONT_BEGIN, 4, 2,
	FONT_NEXT, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_END, 4, 8,
	FONT_BEGIN, 3, 5,
	FONT_END, 0, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	70,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_END, 4, 8,
	FONT_BEGIN, 3, 5,
	FONT_END, 0, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	71,
	FONT_BEGIN, 3, 4,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	72,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 8,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_BEGIN, 4, 8,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	73,
	FONT_BEGIN, 1, 2,
	FONT_END, 3, 2,
	FONT_BEGIN, 2, 2,
	FONT_END, 2, 8,
	FONT_BEGIN, 1, 8,
	FONT_END, 3, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	74,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_END, 4, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	75,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 8,
	FONT_BEGIN, 4, 8,
	FONT_NEXT, 1, 5,
	FONT_END, 4, 2,
	FONT_ADVANCE, 8, 0
    },
    {
	76,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 0, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	77,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 4, 8,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	78,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_NEXT, 4, 2,
	FONT_END, 4, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	79,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	80,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 3, 5,
	FONT_END, 0, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	81,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_BEGIN, 2, 5,
	FONT_END, 4, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	82,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 8,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 4, 7,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 3, 5,
	FONT_END, 0, 5,
	FONT_BEGIN, 1, 5,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	83,
	FONT_BEGIN, 4, 7,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 0, 7,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 3, 5,
	FONT_NEXT, 4, 4,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	84,
	FONT_BEGIN, 0, 8,
	FONT_END, 4, 8,
	FONT_BEGIN, 2, 8,
	FONT_END, 2, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	85,
	FONT_BEGIN, 0, 3,
	FONT_END, 0, 8,
	FONT_BEGIN, 4, 8,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	86,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	87,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 8,
	FONT_BEGIN, 4, 8,
	FONT_NEXT, 4, 2,
	FONT_NEXT, 2, 4,
	FONT_END, 0, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	88,
	FONT_BEGIN, 0, 2,
	FONT_END, 4, 8,
	FONT_BEGIN, 0, 8,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	89,
	FONT_BEGIN, 2, 2,
	FONT_NEXT, 2, 5,
	FONT_END, 0, 8,
	FONT_BEGIN, 4, 8,
	FONT_END, 2, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	90,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 4, 8,
	FONT_NEXT, 0, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	91,
	FONT_BEGIN, 3, 1,
	FONT_NEXT, 1, 1,
	FONT_NEXT, 1, 9,
	FONT_END, 3, 9,
	FONT_ADVANCE, 6, 0
    },
    {
	92,
	FONT_BEGIN, 0, 7,
	FONT_END, 4, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	93,
	FONT_BEGIN, 1, 9,
	FONT_NEXT, 3, 9,
	FONT_NEXT, 3, 1,
	FONT_END, 1, 1,
	FONT_ADVANCE, 6, 0
    },
    {
	94,
	FONT_BEGIN, 2, 2,
	FONT_END, 2, 8,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 2, 8,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	95,
	FONT_BEGIN, 2, 3,
	FONT_NEXT, 0, 5,
	FONT_END, 2, 7,
	FONT_BEGIN, 0, 5,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	96,
	FONT_BEGIN, 3, 8,
	FONT_NEXT, 2, 8,
	FONT_NEXT, 2, 9,
	FONT_NEXT, 3, 9,
	FONT_NEXT, 3, 8,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	97,
	FONT_BEGIN, 1, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 4, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 4,
	FONT_END, 4, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	98,
	FONT_BEGIN, 0, 8,
	FONT_NEXT, 0, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 3, 6,
	FONT_END, 0, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	99,
	FONT_BEGIN, 4, 5,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	100,
	FONT_BEGIN, 4, 8,
	FONT_NEXT, 4, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	101,
	FONT_BEGIN, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 3, 4,
	FONT_END, 0, 4,
	FONT_ADVANCE, 6, 0
    },
    {
	102,
	FONT_BEGIN, 1, 2,
	FONT_NEXT, 1, 7,
	FONT_NEXT, 2, 8,
	FONT_NEXT, 3, 8,
	FONT_END, 4, 7,
	FONT_BEGIN, 2, 5,
	FONT_END, 0, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	103,
	FONT_BEGIN, 1, 0,
	FONT_NEXT, 3, 0,
	FONT_NEXT, 4, 1,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	104,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 8,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	105,
	FONT_BEGIN, 2, 2,
	FONT_END, 2, 5,
	FONT_BEGIN, 2, 6,
	FONT_END, 2, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	106,
	FONT_BEGIN, 0, 1,
	FONT_NEXT, 1, 0,
	FONT_NEXT, 3, 0,
	FONT_NEXT, 4, 1,
	FONT_END, 4, 5,
	FONT_BEGIN, 4, 6,
	FONT_END, 4, 7,
	FONT_ADVANCE, 6, 0
    },
    {
	107,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 8,
	FONT_BEGIN, 4, 6,
	FONT_NEXT, 2, 4,
	FONT_END, 0, 4,
	FONT_BEGIN, 2, 4,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	108,
	FONT_BEGIN, 1, 2,
	FONT_END, 1, 8,
	FONT_ADVANCE, 6, 0
    },
    {
	109,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 2, 5,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 2,
	FONT_BEGIN, 2, 2,
	FONT_END, 2, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	110,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 1, 5,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	111,
	FONT_BEGIN, 0, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	112,
	FONT_BEGIN, 0, 0,
	FONT_NEXT, 0, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 2,
	FONT_END, 0, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	113,
	FONT_BEGIN, 4, 2,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 4, 5,
	FONT_END, 4, 0,
	FONT_ADVANCE, 6, 0
    },
    {
	114,
	FONT_BEGIN, 0, 2,
	FONT_END, 0, 6,
	FONT_BEGIN, 0, 4,
	FONT_NEXT, 2, 6,
	FONT_NEXT, 3, 6,
	FONT_END, 4, 5,
	FONT_ADVANCE, 6, 0
    },
    {
	115,
	FONT_BEGIN, 0, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_NEXT, 3, 4,
	FONT_NEXT, 1, 4,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 1, 6,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	116,
	FONT_BEGIN, 0, 6,
	FONT_END, 4, 6,
	FONT_BEGIN, 2, 8,
	FONT_NEXT, 2, 3,
	FONT_NEXT, 3, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	117,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	118,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 0, 4,
	FONT_NEXT, 2, 2,
	FONT_NEXT, 4, 4,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	119,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 0, 3,
	FONT_NEXT, 1, 2,
	FONT_NEXT, 2, 3,
	FONT_NEXT, 3, 2,
	FONT_NEXT, 4, 3,
	FONT_END, 4, 6,
	FONT_ADVANCE, 6, 0
    },
    {
	120,
	FONT_BEGIN, 0, 2,
	FONT_END, 4, 6,
	FONT_BEGIN, 0, 6,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	121,
	FONT_BEGIN, 0, 0,
	FONT_NEXT, 4, 4,
	FONT_END, 4, 6,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 0, 4,
	FONT_END, 2, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	122,
	FONT_BEGIN, 0, 6,
	FONT_NEXT, 4, 6,
	FONT_NEXT, 0, 2,
	FONT_END, 4, 2,
	FONT_ADVANCE, 6, 0
    },
    {
	123,
	FONT_BEGIN, 4, 9,
	FONT_NEXT, 3, 8,
	FONT_NEXT, 3, 6,
	FONT_NEXT, 2, 5,
	FONT_NEXT, 3, 4,
	FONT_NEXT, 3, 2,
	FONT_END, 4, 1,
	FONT_ADVANCE, 6, 0
    },
    {
	124,
	FONT_BEGIN, 2, 9,
	FONT_END, 2, 0,
	FONT_ADVANCE, 6, 0
    },
    {
	125,
	FONT_BEGIN, 2, 2,
	FONT_NEXT, 2, 3,
	FONT_NEXT, 0, 5,
	FONT_NEXT, 2, 7,
	FONT_END, 2, 8,
	FONT_BEGIN, 2, 7,
	FONT_NEXT, 4, 5,
	FONT_END, 2, 3,
	FONT_ADVANCE, 6, 0
    },
    {
	126,
	FONT_BEGIN, 0, 9,
	FONT_NEXT, 1, 8,
	FONT_NEXT, 1, 6,
	FONT_NEXT, 2, 5,
	FONT_NEXT, 1, 4,
	FONT_NEXT, 1, 2,
	FONT_END, 0, 1,
	FONT_ADVANCE, 6, 0
    },
    {
	END_OF_LIST
    }
};

GLint outlineFont[][1+MAX_STROKES*3] = {
    {
	32,
	FONT_ADVANCE, 250, 0
    },
    {
	33,
	FONT_BEGIN, 234, 559,
	FONT_NEXT, 236, 605,
	FONT_NEXT, 229, 642,
	FONT_NEXT, 211, 667,
	FONT_NEXT, 182, 676,
	FONT_NEXT, 156, 668,
	FONT_NEXT, 140, 648,
	FONT_NEXT, 130, 592,
	FONT_NEXT, 131, 568,
	FONT_NEXT, 134, 534,
	FONT_NEXT, 146, 447,
	FONT_NEXT, 158, 355,
	FONT_NEXT, 163, 315,
	FONT_NEXT, 167, 284,
	FONT_NEXT, 176, 176,
	FONT_END, 189, 176,
	FONT_BEGIN, 219, 3,
	FONT_NEXT, 232, 18,
	FONT_NEXT, 238, 42,
	FONT_NEXT, 233, 62,
	FONT_NEXT, 222, 79,
	FONT_NEXT, 204, 91,
	FONT_NEXT, 183, 96,
	FONT_NEXT, 162, 91,
	FONT_NEXT, 145, 80,
	FONT_NEXT, 134, 63,
	FONT_NEXT, 130, 42,
	FONT_NEXT, 135, 18,
	FONT_NEXT, 148, 2,
	FONT_END, 183, -9,
	FONT_ADVANCE, 333, 0
    },
    {
	34,
	FONT_BEGIN, 308, 482,
	FONT_NEXT, 318, 543,
	FONT_NEXT, 327, 599,
	FONT_NEXT, 331, 635,
	FONT_NEXT, 317, 665,
	FONT_NEXT, 289, 676,
	FONT_NEXT, 260, 665,
	FONT_NEXT, 246, 635,
	FONT_NEXT, 249, 599,
	FONT_NEXT, 258, 543,
	FONT_NEXT, 268, 482,
	FONT_NEXT, 278, 431,
	FONT_END, 299, 431,
	FONT_BEGIN, 139, 482,
	FONT_NEXT, 149, 543,
	FONT_NEXT, 158, 599,
	FONT_NEXT, 162, 635,
	FONT_NEXT, 148, 665,
	FONT_NEXT, 120, 676,
	FONT_NEXT, 91, 665,
	FONT_NEXT, 77, 635,
	FONT_NEXT, 80, 599,
	FONT_NEXT, 89, 543,
	FONT_NEXT, 99, 482,
	FONT_NEXT, 109, 431,
	FONT_END, 130, 431,
	FONT_ADVANCE, 408, 0
    },
    {
	35,
	FONT_BEGIN, 371, 271,
	FONT_NEXT, 391, 405,
	FONT_NEXT, 496, 405,
	FONT_NEXT, 496, 460,
	FONT_NEXT, 399, 460,
	FONT_NEXT, 429, 662,
	FONT_NEXT, 371, 662,
	FONT_NEXT, 341, 460,
	FONT_NEXT, 208, 460,
	FONT_NEXT, 239, 662,
	FONT_NEXT, 181, 662,
	FONT_NEXT, 150, 460,
	FONT_NEXT, 32, 460,
	FONT_NEXT, 32, 405,
	FONT_NEXT, 142, 405,
	FONT_NEXT, 121, 271,
	FONT_NEXT, 5, 271,
	FONT_NEXT, 5, 216,
	FONT_NEXT, 112, 216,
	FONT_NEXT, 79, 0,
	FONT_NEXT, 137, 0,
	FONT_NEXT, 170, 216,
	FONT_NEXT, 304, 216,
	FONT_NEXT, 273, 0,
	FONT_NEXT, 331, 0,
	FONT_NEXT, 362, 216,
	FONT_NEXT, 471, 216,
	FONT_END, 471, 271,
	FONT_BEGIN, 313, 271,
	FONT_NEXT, 179, 271,
	FONT_NEXT, 200, 405,
	FONT_END, 333, 405,
	FONT_ADVANCE, 500, 0
    },
    {
	36,
	FONT_BEGIN, 425, 611,
	FONT_NEXT, 387, 634,
	FONT_NEXT, 345, 649,
	FONT_NEXT, 264, 664,
	FONT_NEXT, 264, 727,
	FONT_NEXT, 230, 727,
	FONT_NEXT, 230, 664,
	FONT_NEXT, 185, 658,
	FONT_NEXT, 148, 646,
	FONT_NEXT, 93, 611,
	FONT_NEXT, 61, 563,
	FONT_NEXT, 52, 511,
	FONT_NEXT, 55, 476,
	FONT_NEXT, 67, 445,
	FONT_NEXT, 106, 392,
	FONT_NEXT, 163, 349,
	FONT_NEXT, 230, 310,
	FONT_NEXT, 230, 28,
	FONT_NEXT, 166, 37,
	FONT_NEXT, 117, 66,
	FONT_NEXT, 81, 114,
	FONT_NEXT, 59, 181,
	FONT_NEXT, 44, 181,
	FONT_NEXT, 44, 51,
	FONT_NEXT, 70, 35,
	FONT_NEXT, 110, 19,
	FONT_NEXT, 162, 5,
	FONT_NEXT, 230, 0,
	FONT_NEXT, 230, -87,
	FONT_NEXT, 264, -87,
	FONT_NEXT, 264, 0,
	FONT_NEXT, 338, 16,
	FONT_NEXT, 399, 49,
	FONT_NEXT, 441, 100,
	FONT_NEXT, 453, 134,
	FONT_NEXT, 457, 174,
	FONT_NEXT, 453, 211,
	FONT_NEXT, 444, 243,
	FONT_NEXT, 408, 295,
	FONT_NEXT, 348, 341,
	FONT_NEXT, 264, 391,
	FONT_NEXT, 264, 637,
	FONT_NEXT, 305, 628,
	FONT_NEXT, 348, 607,
	FONT_NEXT, 385, 566,
	FONT_NEXT, 399, 537,
	FONT_NEXT, 410, 500,
	FONT_END, 425, 500,
	FONT_BEGIN, 187, 435,
	FONT_NEXT, 155, 464,
	FONT_NEXT, 133, 495,
	FONT_NEXT, 126, 532,
	FONT_NEXT, 128, 555,
	FONT_NEXT, 141, 586,
	FONT_NEXT, 171, 616,
	FONT_NEXT, 196, 628,
	FONT_NEXT, 229, 637,
	FONT_END, 229, 407,
	FONT_BEGIN, 308, 264,
	FONT_NEXT, 344, 234,
	FONT_NEXT, 369, 197,
	FONT_NEXT, 378, 151,
	FONT_NEXT, 374, 116,
	FONT_NEXT, 364, 89,
	FONT_NEXT, 333, 53,
	FONT_NEXT, 295, 35,
	FONT_NEXT, 264, 28,
	FONT_END, 264, 293,
	FONT_ADVANCE, 500, 0
    },
    {
	37,
	FONT_BEGIN, 622, 365,
	FONT_NEXT, 583, 349,
	FONT_NEXT, 514, 293,
	FONT_NEXT, 466, 218,
	FONT_NEXT, 453, 177,
	FONT_NEXT, 449, 137,
	FONT_NEXT, 455, 86,
	FONT_NEXT, 475, 42,
	FONT_NEXT, 513, 11,
	FONT_NEXT, 572, 0,
	FONT_NEXT, 615, 6,
	FONT_NEXT, 654, 25,
	FONT_NEXT, 688, 53,
	FONT_NEXT, 717, 88,
	FONT_NEXT, 757, 173,
	FONT_NEXT, 772, 261,
	FONT_NEXT, 768, 295,
	FONT_NEXT, 760, 321,
	FONT_NEXT, 731, 354,
	FONT_NEXT, 695, 368,
	FONT_END, 663, 371,
	FONT_BEGIN, 703, 332,
	FONT_NEXT, 726, 314,
	FONT_NEXT, 740, 287,
	FONT_NEXT, 746, 254,
	FONT_NEXT, 733, 183,
	FONT_NEXT, 700, 110,
	FONT_NEXT, 650, 53,
	FONT_NEXT, 620, 36,
	FONT_NEXT, 589, 30,
	FONT_NEXT, 552, 39,
	FONT_NEXT, 533, 60,
	FONT_NEXT, 525, 106,
	FONT_NEXT, 527, 128,
	FONT_NEXT, 534, 160,
	FONT_NEXT, 564, 238,
	FONT_NEXT, 611, 308,
	FONT_NEXT, 641, 330,
	FONT_END, 676, 339,
	FONT_BEGIN, 595, 676,
	FONT_NEXT, 536, 630,
	FONT_NEXT, 493, 614,
	FONT_NEXT, 438, 608,
	FONT_NEXT, 404, 610,
	FONT_NEXT, 381, 616,
	FONT_NEXT, 352, 635,
	FONT_NEXT, 325, 653,
	FONT_NEXT, 305, 659,
	FONT_NEXT, 276, 662,
	FONT_NEXT, 232, 655,
	FONT_NEXT, 192, 639,
	FONT_NEXT, 156, 613,
	FONT_NEXT, 124, 581,
	FONT_NEXT, 78, 504,
	FONT_NEXT, 65, 463,
	FONT_NEXT, 61, 425,
	FONT_NEXT, 64, 390,
	FONT_NEXT, 72, 361,
	FONT_NEXT, 102, 319,
	FONT_NEXT, 140, 296,
	FONT_NEXT, 178, 289,
	FONT_NEXT, 223, 295,
	FONT_NEXT, 264, 314,
	FONT_NEXT, 299, 343,
	FONT_NEXT, 329, 379,
	FONT_NEXT, 369, 463,
	FONT_NEXT, 384, 548,
	FONT_NEXT, 377, 593,
	FONT_NEXT, 401, 585,
	FONT_NEXT, 443, 583,
	FONT_NEXT, 478, 585,
	FONT_NEXT, 507, 592,
	FONT_NEXT, 548, 611,
	FONT_NEXT, 550, 609,
	FONT_NEXT, 201, -13,
	FONT_NEXT, 249, -13,
	FONT_END, 634, 676,
	FONT_BEGIN, 172, 326,
	FONT_NEXT, 153, 339,
	FONT_NEXT, 141, 362,
	FONT_NEXT, 137, 397,
	FONT_NEXT, 150, 468,
	FONT_NEXT, 184, 545,
	FONT_NEXT, 230, 606,
	FONT_NEXT, 255, 625,
	FONT_NEXT, 281, 632,
	FONT_NEXT, 299, 622,
	FONT_NEXT, 315, 611,
	FONT_NEXT, 350, 600,
	FONT_NEXT, 359, 553,
	FONT_NEXT, 345, 469,
	FONT_NEXT, 309, 396,
	FONT_NEXT, 257, 343,
	FONT_NEXT, 228, 328,
	FONT_END, 199, 323,
	FONT_ADVANCE, 833, 0
    },
    {
	38,
	FONT_BEGIN, 287, 596,
	FONT_NEXT, 304, 623,
	FONT_NEXT, 329, 639,
	FONT_NEXT, 359, 644,
	FONT_NEXT, 389, 637,
	FONT_NEXT, 414, 620,
	FONT_NEXT, 431, 594,
	FONT_NEXT, 438, 560,
	FONT_NEXT, 423, 504,
	FONT_NEXT, 389, 462,
	FONT_NEXT, 350, 432,
	FONT_NEXT, 321, 416,
	FONT_NEXT, 293, 483,
	FONT_END, 281, 557,
	FONT_BEGIN, 495, 426,
	FONT_NEXT, 495, 405,
	FONT_NEXT, 540, 395,
	FONT_NEXT, 554, 381,
	FONT_NEXT, 559, 359,
	FONT_NEXT, 548, 310,
	FONT_NEXT, 524, 259,
	FONT_NEXT, 494, 213,
	FONT_NEXT, 468, 178,
	FONT_NEXT, 396, 277,
	FONT_NEXT, 336, 384,
	FONT_NEXT, 387, 409,
	FONT_NEXT, 437, 444,
	FONT_NEXT, 475, 492,
	FONT_NEXT, 486, 521,
	FONT_NEXT, 491, 556,
	FONT_NEXT, 480, 606,
	FONT_NEXT, 450, 644,
	FONT_NEXT, 407, 667,
	FONT_NEXT, 355, 676,
	FONT_NEXT, 319, 672,
	FONT_NEXT, 288, 661,
	FONT_NEXT, 240, 624,
	FONT_NEXT, 211, 573,
	FONT_NEXT, 202, 519,
	FONT_NEXT, 211, 452,
	FONT_NEXT, 237, 377,
	FONT_NEXT, 199, 355,
	FONT_NEXT, 146, 320,
	FONT_NEXT, 95, 274,
	FONT_NEXT, 57, 215,
	FONT_NEXT, 42, 144,
	FONT_NEXT, 46, 99,
	FONT_NEXT, 59, 64,
	FONT_NEXT, 78, 36,
	FONT_NEXT, 101, 16,
	FONT_NEXT, 155, -7,
	FONT_NEXT, 207, -13,
	FONT_NEXT, 286, -4,
	FONT_NEXT, 347, 19,
	FONT_NEXT, 394, 49,
	FONT_NEXT, 429, 78,
	FONT_NEXT, 456, 51,
	FONT_NEXT, 494, 21,
	FONT_NEXT, 542, -3,
	FONT_NEXT, 599, -13,
	FONT_NEXT, 635, -9,
	FONT_NEXT, 667, 4,
	FONT_NEXT, 713, 42,
	FONT_NEXT, 740, 80,
	FONT_NEXT, 747, 93,
	FONT_NEXT, 750, 100,
	FONT_NEXT, 735, 111,
	FONT_NEXT, 697, 73,
	FONT_NEXT, 672, 62,
	FONT_NEXT, 639, 58,
	FONT_NEXT, 585, 70,
	FONT_NEXT, 540, 98,
	FONT_NEXT, 507, 129,
	FONT_NEXT, 491, 150,
	FONT_NEXT, 528, 200,
	FONT_NEXT, 550, 232,
	FONT_NEXT, 568, 261,
	FONT_NEXT, 591, 300,
	FONT_NEXT, 617, 346,
	FONT_NEXT, 638, 375,
	FONT_NEXT, 661, 392,
	FONT_NEXT, 711, 405,
	FONT_END, 711, 426,
	FONT_BEGIN, 146, 238,
	FONT_NEXT, 176, 283,
	FONT_NEXT, 214, 317,
	FONT_NEXT, 252, 343,
	FONT_NEXT, 322, 219,
	FONT_NEXT, 404, 104,
	FONT_NEXT, 356, 69,
	FONT_NEXT, 316, 49,
	FONT_NEXT, 285, 41,
	FONT_NEXT, 263, 39,
	FONT_NEXT, 212, 50,
	FONT_NEXT, 171, 80,
	FONT_NEXT, 144, 125,
	FONT_END, 134, 180,
	FONT_ADVANCE, 778, 0
    },
    {
	39,
	FONT_BEGIN, 136, 450,
	FONT_NEXT, 173, 483,
	FONT_NEXT, 204, 528,
	FONT_NEXT, 218, 580,
	FONT_NEXT, 208, 630,
	FONT_NEXT, 186, 659,
	FONT_NEXT, 159, 672,
	FONT_NEXT, 137, 676,
	FONT_NEXT, 98, 663,
	FONT_NEXT, 84, 645,
	FONT_NEXT, 79, 618,
	FONT_NEXT, 85, 593,
	FONT_NEXT, 100, 578,
	FONT_NEXT, 141, 568,
	FONT_NEXT, 156, 570,
	FONT_NEXT, 165, 572,
	FONT_NEXT, 174, 568,
	FONT_NEXT, 179, 558,
	FONT_NEXT, 175, 539,
	FONT_NEXT, 162, 513,
	FONT_NEXT, 137, 483,
	FONT_NEXT, 97, 452,
	FONT_END, 106, 433,
	FONT_ADVANCE, 333, 0
    },
    {
	40,
	FONT_BEGIN, 239, 638,
	FONT_NEXT, 191, 596,
	FONT_NEXT, 148, 549,
	FONT_NEXT, 113, 499,
	FONT_NEXT, 85, 444,
	FONT_NEXT, 64, 386,
	FONT_NEXT, 52, 325,
	FONT_NEXT, 48, 262,
	FONT_NEXT, 53, 169,
	FONT_NEXT, 70, 96,
	FONT_NEXT, 96, 35,
	FONT_NEXT, 130, -20,
	FONT_NEXT, 203, -108,
	FONT_NEXT, 247, -148,
	FONT_NEXT, 292, -177,
	FONT_NEXT, 304, -161,
	FONT_NEXT, 247, -116,
	FONT_NEXT, 205, -63,
	FONT_NEXT, 175, -4,
	FONT_NEXT, 155, 56,
	FONT_NEXT, 136, 174,
	FONT_NEXT, 134, 225,
	FONT_NEXT, 134, 269,
	FONT_NEXT, 138, 356,
	FONT_NEXT, 150, 428,
	FONT_NEXT, 168, 488,
	FONT_NEXT, 191, 537,
	FONT_NEXT, 246, 609,
	FONT_NEXT, 304, 660,
	FONT_END, 295, 676,
	FONT_ADVANCE, 333, 0
    },
    {
	41,
	FONT_BEGIN, 93, -140,
	FONT_NEXT, 141, -98,
	FONT_NEXT, 184, -51,
	FONT_NEXT, 219, 0,
	FONT_NEXT, 247, 54,
	FONT_NEXT, 268, 112,
	FONT_NEXT, 280, 173,
	FONT_NEXT, 285, 237,
	FONT_NEXT, 279, 329,
	FONT_NEXT, 262, 402,
	FONT_NEXT, 236, 463,
	FONT_NEXT, 203, 519,
	FONT_NEXT, 129, 606,
	FONT_NEXT, 85, 646,
	FONT_NEXT, 41, 676,
	FONT_NEXT, 29, 660,
	FONT_NEXT, 85, 614,
	FONT_NEXT, 127, 561,
	FONT_NEXT, 157, 502,
	FONT_NEXT, 177, 442,
	FONT_NEXT, 196, 324,
	FONT_NEXT, 198, 273,
	FONT_NEXT, 199, 230,
	FONT_NEXT, 194, 142,
	FONT_NEXT, 182, 70,
	FONT_NEXT, 164, 10,
	FONT_NEXT, 141, -39,
	FONT_NEXT, 86, -111,
	FONT_NEXT, 29, -161,
	FONT_END, 38, -177,
	FONT_ADVANCE, 333, 0
    },
    {
	42,
	FONT_BEGIN, 76, 362,
	FONT_NEXT, 103, 351,
	FONT_NEXT, 129, 358,
	FONT_NEXT, 143, 371,
	FONT_NEXT, 164, 394,
	FONT_NEXT, 192, 422,
	FONT_NEXT, 210, 435,
	FONT_NEXT, 240, 456,
	FONT_NEXT, 241, 449,
	FONT_NEXT, 240, 405,
	FONT_NEXT, 230, 365,
	FONT_NEXT, 219, 331,
	FONT_NEXT, 214, 304,
	FONT_NEXT, 225, 275,
	FONT_NEXT, 249, 265,
	FONT_NEXT, 277, 278,
	FONT_NEXT, 288, 307,
	FONT_NEXT, 274, 352,
	FONT_NEXT, 264, 389,
	FONT_NEXT, 260, 449,
	FONT_NEXT, 260, 456,
	FONT_NEXT, 267, 453,
	FONT_NEXT, 307, 425,
	FONT_NEXT, 338, 391,
	FONT_NEXT, 366, 362,
	FONT_NEXT, 396, 350,
	FONT_NEXT, 421, 359,
	FONT_NEXT, 432, 386,
	FONT_NEXT, 428, 404,
	FONT_NEXT, 419, 416,
	FONT_NEXT, 384, 428,
	FONT_NEXT, 334, 439,
	FONT_NEXT, 276, 465,
	FONT_NEXT, 268, 470,
	FONT_NEXT, 304, 489,
	FONT_NEXT, 336, 502,
	FONT_NEXT, 388, 513,
	FONT_NEXT, 420, 525,
	FONT_NEXT, 428, 537,
	FONT_NEXT, 431, 557,
	FONT_NEXT, 427, 574,
	FONT_NEXT, 417, 585,
	FONT_NEXT, 395, 593,
	FONT_NEXT, 368, 581,
	FONT_NEXT, 341, 554,
	FONT_NEXT, 309, 520,
	FONT_NEXT, 267, 488,
	FONT_NEXT, 260, 484,
	FONT_NEXT, 260, 510,
	FONT_NEXT, 273, 582,
	FONT_NEXT, 282, 613,
	FONT_NEXT, 287, 637,
	FONT_NEXT, 279, 661,
	FONT_NEXT, 269, 671,
	FONT_NEXT, 253, 676,
	FONT_NEXT, 231, 671,
	FONT_NEXT, 220, 659,
	FONT_NEXT, 216, 637,
	FONT_NEXT, 228, 581,
	FONT_NEXT, 237, 548,
	FONT_NEXT, 241, 499,
	FONT_NEXT, 241, 486,
	FONT_NEXT, 185, 523,
	FONT_NEXT, 152, 557,
	FONT_NEXT, 129, 581,
	FONT_NEXT, 102, 591,
	FONT_NEXT, 85, 586,
	FONT_NEXT, 75, 576,
	FONT_NEXT, 69, 557,
	FONT_NEXT, 72, 538,
	FONT_NEXT, 83, 526,
	FONT_NEXT, 120, 511,
	FONT_NEXT, 170, 500,
	FONT_NEXT, 223, 478,
	FONT_NEXT, 234, 471,
	FONT_NEXT, 172, 441,
	FONT_NEXT, 120, 428,
	FONT_NEXT, 82, 415,
	FONT_NEXT, 72, 402,
	FONT_END, 69, 383,
	FONT_ADVANCE, 500, 0
    },
    {
	43,
	FONT_BEGIN, 30, 286,
	FONT_NEXT, 30, 220,
	FONT_NEXT, 249, 220,
	FONT_NEXT, 249, 0,
	FONT_NEXT, 315, 0,
	FONT_NEXT, 315, 220,
	FONT_NEXT, 534, 220,
	FONT_NEXT, 534, 286,
	FONT_NEXT, 315, 286,
	FONT_NEXT, 315, 506,
	FONT_NEXT, 249, 506,
	FONT_END, 249, 286,
	FONT_ADVANCE, 564, 0
    },
    {
	44,
	FONT_BEGIN, 113, -124,
	FONT_NEXT, 150, -91,
	FONT_NEXT, 181, -46,
	FONT_NEXT, 195, 6,
	FONT_NEXT, 185, 56,
	FONT_NEXT, 163, 85,
	FONT_NEXT, 136, 98,
	FONT_NEXT, 114, 102,
	FONT_NEXT, 75, 89,
	FONT_NEXT, 61, 71,
	FONT_NEXT, 56, 44,
	FONT_NEXT, 62, 19,
	FONT_NEXT, 77, 4,
	FONT_NEXT, 118, -6,
	FONT_NEXT, 133, -4,
	FONT_NEXT, 142, -2,
	FONT_NEXT, 151, -6,
	FONT_NEXT, 156, -16,
	FONT_NEXT, 152, -35,
	FONT_NEXT, 139, -61,
	FONT_NEXT, 114, -91,
	FONT_NEXT, 74, -122,
	FONT_END, 83, -141,
	FONT_ADVANCE, 250, 0
    },
    {
	45,
	FONT_BEGIN, 39, 194,
	FONT_NEXT, 285, 194,
	FONT_NEXT, 285, 257,
	FONT_END, 39, 257,
	FONT_ADVANCE, 333, 0
    },
    {
	46,
	FONT_BEGIN, 160, 2,
	FONT_NEXT, 175, 18,
	FONT_NEXT, 181, 43,
	FONT_NEXT, 176, 64,
	FONT_NEXT, 164, 83,
	FONT_NEXT, 146, 95,
	FONT_NEXT, 125, 100,
	FONT_NEXT, 103, 95,
	FONT_NEXT, 86, 83,
	FONT_NEXT, 74, 65,
	FONT_NEXT, 70, 43,
	FONT_NEXT, 75, 18,
	FONT_NEXT, 89, 1,
	FONT_END, 125, -11,
	FONT_ADVANCE, 250, 0
    },
    {
	47,
	FONT_BEGIN, 220, 676,
	FONT_NEXT, -9, -14,
	FONT_NEXT, 59, -14,
	FONT_END, 287, 676,
	FONT_ADVANCE, 278, 0
    },
    {
	48,
	FONT_BEGIN, 292, 639,
	FONT_NEXT, 324, 609,
	FONT_NEXT, 347, 566,
	FONT_NEXT, 363, 516,
	FONT_NEXT, 377, 409,
	FONT_NEXT, 379, 364,
	FONT_NEXT, 380, 331,
	FONT_NEXT, 379, 294,
	FONT_NEXT, 377, 247,
	FONT_NEXT, 363, 141,
	FONT_NEXT, 347, 92,
	FONT_NEXT, 324, 50,
	FONT_NEXT, 292, 22,
	FONT_NEXT, 250, 12,
	FONT_NEXT, 207, 22,
	FONT_NEXT, 175, 50,
	FONT_NEXT, 152, 91,
	FONT_NEXT, 137, 141,
	FONT_NEXT, 122, 246,
	FONT_NEXT, 120, 294,
	FONT_NEXT, 120, 331,
	FONT_NEXT, 120, 364,
	FONT_NEXT, 122, 409,
	FONT_NEXT, 137, 516,
	FONT_NEXT, 152, 566,
	FONT_NEXT, 175, 609,
	FONT_NEXT, 207, 639,
	FONT_END, 250, 650,
	FONT_BEGIN, 187, 666,
	FONT_NEXT, 137, 638,
	FONT_NEXT, 97, 597,
	FONT_NEXT, 68, 547,
	FONT_NEXT, 33, 434,
	FONT_NEXT, 26, 379,
	FONT_NEXT, 24, 331,
	FONT_NEXT, 33, 226,
	FONT_NEXT, 68, 113,
	FONT_NEXT, 97, 63,
	FONT_NEXT, 137, 22,
	FONT_NEXT, 187, -5,
	FONT_NEXT, 250, -14,
	FONT_NEXT, 312, -5,
	FONT_NEXT, 362, 22,
	FONT_NEXT, 402, 63,
	FONT_NEXT, 432, 113,
	FONT_NEXT, 466, 226,
	FONT_NEXT, 476, 331,
	FONT_NEXT, 473, 379,
	FONT_NEXT, 466, 434,
	FONT_NEXT, 432, 547,
	FONT_NEXT, 402, 597,
	FONT_NEXT, 362, 638,
	FONT_NEXT, 312, 666,
	FONT_END, 250, 676,
	FONT_ADVANCE, 500, 0
    },
    {
	49,
	FONT_BEGIN, 394, 0,
	FONT_NEXT, 394, 15,
	FONT_NEXT, 347, 17,
	FONT_NEXT, 318, 26,
	FONT_NEXT, 303, 44,
	FONT_NEXT, 299, 74,
	FONT_NEXT, 299, 674,
	FONT_NEXT, 291, 676,
	FONT_NEXT, 111, 585,
	FONT_NEXT, 111, 571,
	FONT_NEXT, 143, 583,
	FONT_NEXT, 161, 590,
	FONT_NEXT, 179, 593,
	FONT_NEXT, 198, 588,
	FONT_NEXT, 208, 577,
	FONT_NEXT, 213, 546,
	FONT_NEXT, 213, 93,
	FONT_NEXT, 206, 49,
	FONT_NEXT, 187, 27,
	FONT_NEXT, 157, 17,
	FONT_NEXT, 118, 15,
	FONT_END, 118, 0,
	FONT_ADVANCE, 500, 0
    },
    {
	50,
	FONT_BEGIN, 462, 142,
	FONT_NEXT, 435, 105,
	FONT_NEXT, 413, 85,
	FONT_NEXT, 367, 76,
	FONT_NEXT, 128, 76,
	FONT_NEXT, 296, 252,
	FONT_NEXT, 334, 295,
	FONT_NEXT, 376, 351,
	FONT_NEXT, 410, 419,
	FONT_NEXT, 424, 496,
	FONT_NEXT, 419, 535,
	FONT_NEXT, 408, 571,
	FONT_NEXT, 367, 628,
	FONT_NEXT, 309, 663,
	FONT_NEXT, 243, 676,
	FONT_NEXT, 176, 666,
	FONT_NEXT, 115, 633,
	FONT_NEXT, 88, 606,
	FONT_NEXT, 64, 571,
	FONT_NEXT, 45, 528,
	FONT_NEXT, 31, 477,
	FONT_NEXT, 52, 472,
	FONT_NEXT, 70, 515,
	FONT_NEXT, 97, 557,
	FONT_NEXT, 137, 589,
	FONT_NEXT, 195, 602,
	FONT_NEXT, 235, 597,
	FONT_NEXT, 267, 586,
	FONT_NEXT, 310, 549,
	FONT_NEXT, 332, 502,
	FONT_NEXT, 338, 459,
	FONT_NEXT, 329, 400,
	FONT_NEXT, 305, 336,
	FONT_NEXT, 265, 270,
	FONT_NEXT, 208, 201,
	FONT_NEXT, 30, 12,
	FONT_NEXT, 30, 0,
	FONT_NEXT, 420, 0,
	FONT_END, 475, 137,
	FONT_ADVANCE, 500, 0
    },
    {
	51,
	FONT_BEGIN, 197, 330,
	FONT_NEXT, 230, 326,
	FONT_NEXT, 283, 308,
	FONT_NEXT, 321, 276,
	FONT_NEXT, 345, 239,
	FONT_NEXT, 356, 202,
	FONT_NEXT, 359, 176,
	FONT_NEXT, 351, 120,
	FONT_NEXT, 326, 70,
	FONT_NEXT, 285, 35,
	FONT_NEXT, 225, 22,
	FONT_NEXT, 184, 30,
	FONT_NEXT, 148, 50,
	FONT_NEXT, 115, 69,
	FONT_NEXT, 82, 78,
	FONT_NEXT, 56, 71,
	FONT_NEXT, 46, 60,
	FONT_NEXT, 43, 43,
	FONT_NEXT, 56, 12,
	FONT_NEXT, 89, -5,
	FONT_NEXT, 126, -13,
	FONT_NEXT, 154, -14,
	FONT_NEXT, 210, -10,
	FONT_NEXT, 263, 1,
	FONT_NEXT, 310, 21,
	FONT_NEXT, 351, 47,
	FONT_NEXT, 384, 80,
	FONT_NEXT, 409, 120,
	FONT_NEXT, 425, 165,
	FONT_NEXT, 431, 216,
	FONT_NEXT, 427, 261,
	FONT_NEXT, 417, 298,
	FONT_NEXT, 383, 351,
	FONT_NEXT, 341, 383,
	FONT_NEXT, 304, 401,
	FONT_NEXT, 346, 433,
	FONT_NEXT, 375, 466,
	FONT_NEXT, 391, 502,
	FONT_NEXT, 397, 541,
	FONT_NEXT, 390, 579,
	FONT_NEXT, 367, 623,
	FONT_NEXT, 319, 660,
	FONT_NEXT, 284, 671,
	FONT_NEXT, 241, 676,
	FONT_NEXT, 187, 669,
	FONT_NEXT, 132, 644,
	FONT_NEXT, 83, 594,
	FONT_NEXT, 62, 558,
	FONT_NEXT, 45, 514,
	FONT_NEXT, 60, 510,
	FONT_NEXT, 76, 538,
	FONT_NEXT, 105, 573,
	FONT_NEXT, 148, 603,
	FONT_NEXT, 208, 616,
	FONT_NEXT, 256, 606,
	FONT_NEXT, 290, 583,
	FONT_NEXT, 311, 549,
	FONT_NEXT, 318, 512,
	FONT_NEXT, 304, 450,
	FONT_NEXT, 269, 403,
	FONT_NEXT, 216, 368,
	FONT_NEXT, 152, 343,
	FONT_END, 153, 330,
	FONT_ADVANCE, 500, 0
    },
    {
	52,
	FONT_BEGIN, 370, 231,
	FONT_NEXT, 370, 676,
	FONT_NEXT, 326, 676,
	FONT_NEXT, 12, 231,
	FONT_NEXT, 12, 167,
	FONT_NEXT, 293, 167,
	FONT_NEXT, 293, 0,
	FONT_NEXT, 370, 0,
	FONT_NEXT, 370, 167,
	FONT_NEXT, 472, 167,
	FONT_END, 472, 231,
	FONT_BEGIN, 52, 231,
	FONT_NEXT, 290, 571,
	FONT_NEXT, 292, 571,
	FONT_END, 292, 231,
	FONT_ADVANCE, 500, 0
    },
    {
	53,
	FONT_BEGIN, 377, 583,
	FONT_NEXT, 391, 584,
	FONT_NEXT, 400, 592,
	FONT_NEXT, 438, 681,
	FONT_NEXT, 429, 688,
	FONT_NEXT, 411, 669,
	FONT_NEXT, 383, 662,
	FONT_NEXT, 174, 662,
	FONT_NEXT, 65, 425,
	FONT_NEXT, 64, 415,
	FONT_NEXT, 71, 412,
	FONT_NEXT, 161, 399,
	FONT_NEXT, 254, 365,
	FONT_NEXT, 294, 337,
	FONT_NEXT, 326, 300,
	FONT_NEXT, 348, 255,
	FONT_NEXT, 356, 201,
	FONT_NEXT, 352, 158,
	FONT_NEXT, 343, 121,
	FONT_NEXT, 310, 66,
	FONT_NEXT, 266, 33,
	FONT_NEXT, 217, 23,
	FONT_NEXT, 72, 85,
	FONT_NEXT, 48, 80,
	FONT_NEXT, 37, 69,
	FONT_NEXT, 32, 46,
	FONT_NEXT, 40, 21,
	FONT_NEXT, 65, 2,
	FONT_NEXT, 104, -10,
	FONT_NEXT, 158, -14,
	FONT_NEXT, 214, -10,
	FONT_NEXT, 266, 4,
	FONT_NEXT, 312, 26,
	FONT_NEXT, 351, 55,
	FONT_NEXT, 382, 90,
	FONT_NEXT, 406, 131,
	FONT_NEXT, 420, 176,
	FONT_NEXT, 426, 225,
	FONT_NEXT, 423, 281,
	FONT_NEXT, 415, 323,
	FONT_NEXT, 398, 359,
	FONT_NEXT, 372, 395,
	FONT_NEXT, 321, 439,
	FONT_NEXT, 263, 468,
	FONT_NEXT, 139, 498,
	FONT_END, 181, 583,
	FONT_ADVANCE, 500, 0
    },
    {
	54,
	FONT_BEGIN, 358, 673,
	FONT_NEXT, 279, 647,
	FONT_NEXT, 209, 609,
	FONT_NEXT, 149, 560,
	FONT_NEXT, 100, 502,
	FONT_NEXT, 64, 436,
	FONT_NEXT, 41, 365,
	FONT_NEXT, 34, 291,
	FONT_NEXT, 38, 217,
	FONT_NEXT, 51, 154,
	FONT_NEXT, 72, 102,
	FONT_NEXT, 99, 59,
	FONT_NEXT, 132, 27,
	FONT_NEXT, 169, 4,
	FONT_NEXT, 210, -10,
	FONT_NEXT, 254, -14,
	FONT_NEXT, 314, -8,
	FONT_NEXT, 362, 11,
	FONT_NEXT, 399, 40,
	FONT_NEXT, 427, 74,
	FONT_NEXT, 459, 150,
	FONT_NEXT, 468, 218,
	FONT_NEXT, 464, 265,
	FONT_NEXT, 454, 307,
	FONT_NEXT, 437, 343,
	FONT_NEXT, 415, 373,
	FONT_NEXT, 357, 414,
	FONT_NEXT, 284, 428,
	FONT_NEXT, 247, 425,
	FONT_NEXT, 217, 417,
	FONT_NEXT, 187, 403,
	FONT_NEXT, 152, 383,
	FONT_NEXT, 181, 475,
	FONT_NEXT, 207, 519,
	FONT_NEXT, 240, 560,
	FONT_NEXT, 281, 597,
	FONT_NEXT, 329, 628,
	FONT_NEXT, 384, 652,
	FONT_NEXT, 448, 668,
	FONT_END, 446, 684,
	FONT_BEGIN, 278, 377,
	FONT_NEXT, 307, 364,
	FONT_NEXT, 331, 344,
	FONT_NEXT, 349, 319,
	FONT_NEXT, 371, 254,
	FONT_NEXT, 378, 179,
	FONT_NEXT, 369, 105,
	FONT_NEXT, 347, 54,
	FONT_NEXT, 312, 23,
	FONT_NEXT, 269, 14,
	FONT_NEXT, 215, 28,
	FONT_NEXT, 191, 46,
	FONT_NEXT, 169, 72,
	FONT_NEXT, 152, 105,
	FONT_NEXT, 138, 147,
	FONT_NEXT, 130, 197,
	FONT_NEXT, 127, 256,
	FONT_NEXT, 128, 294,
	FONT_NEXT, 133, 321,
	FONT_NEXT, 147, 350,
	FONT_NEXT, 191, 375,
	FONT_END, 242, 382,
	FONT_ADVANCE, 500, 0
    },
    {
	55,
	FONT_BEGIN, 79, 662,
	FONT_NEXT, 63, 618,
	FONT_NEXT, 20, 515,
	FONT_NEXT, 37, 507,
	FONT_NEXT, 59, 541,
	FONT_NEXT, 83, 567,
	FONT_NEXT, 112, 582,
	FONT_NEXT, 153, 588,
	FONT_NEXT, 370, 588,
	FONT_NEXT, 172, -8,
	FONT_NEXT, 237, -8,
	FONT_NEXT, 449, 646,
	FONT_END, 449, 662,
	FONT_ADVANCE, 500, 0
    },
    {
	56,
	FONT_BEGIN, 285, 258,
	FONT_NEXT, 333, 216,
	FONT_NEXT, 360, 174,
	FONT_NEXT, 369, 126,
	FONT_NEXT, 360, 78,
	FONT_NEXT, 337, 43,
	FONT_NEXT, 302, 21,
	FONT_NEXT, 259, 14,
	FONT_NEXT, 204, 25,
	FONT_NEXT, 165, 56,
	FONT_NEXT, 140, 101,
	FONT_NEXT, 132, 156,
	FONT_NEXT, 140, 215,
	FONT_NEXT, 160, 258,
	FONT_NEXT, 186, 289,
	FONT_END, 212, 312,
	FONT_BEGIN, 68, 88,
	FONT_NEXT, 104, 36,
	FONT_NEXT, 164, 0,
	FONT_NEXT, 202, -11,
	FONT_NEXT, 246, -14,
	FONT_NEXT, 302, -10,
	FONT_NEXT, 347, 4,
	FONT_NEXT, 381, 24,
	FONT_NEXT, 407, 48,
	FONT_NEXT, 437, 102,
	FONT_NEXT, 445, 150,
	FONT_NEXT, 439, 199,
	FONT_NEXT, 417, 249,
	FONT_NEXT, 370, 305,
	FONT_NEXT, 335, 336,
	FONT_NEXT, 290, 371,
	FONT_NEXT, 333, 395,
	FONT_NEXT, 377, 428,
	FONT_NEXT, 410, 473,
	FONT_NEXT, 424, 534,
	FONT_NEXT, 412, 588,
	FONT_NEXT, 378, 633,
	FONT_NEXT, 324, 664,
	FONT_NEXT, 249, 676,
	FONT_NEXT, 183, 665,
	FONT_NEXT, 123, 636,
	FONT_NEXT, 79, 587,
	FONT_NEXT, 66, 556,
	FONT_NEXT, 62, 521,
	FONT_NEXT, 69, 467,
	FONT_NEXT, 92, 423,
	FONT_NEXT, 131, 381,
	FONT_NEXT, 186, 332,
	FONT_NEXT, 128, 286,
	FONT_NEXT, 87, 246,
	FONT_NEXT, 63, 202,
	FONT_END, 56, 146,
	FONT_BEGIN, 142, 583,
	FONT_NEXT, 161, 615,
	FONT_NEXT, 194, 638,
	FONT_NEXT, 243, 648,
	FONT_NEXT, 292, 638,
	FONT_NEXT, 327, 614,
	FONT_NEXT, 348, 579,
	FONT_NEXT, 355, 539,
	FONT_NEXT, 345, 481,
	FONT_NEXT, 322, 440,
	FONT_NEXT, 291, 410,
	FONT_NEXT, 261, 389,
	FONT_NEXT, 226, 412,
	FONT_NEXT, 185, 447,
	FONT_NEXT, 150, 492,
	FONT_END, 136, 547,
	FONT_ADVANCE, 500, 0
    },
    {
	57,
	FONT_BEGIN, 149, -9,
	FONT_NEXT, 228, 20,
	FONT_NEXT, 297, 61,
	FONT_NEXT, 354, 113,
	FONT_NEXT, 399, 174,
	FONT_NEXT, 432, 243,
	FONT_NEXT, 452, 317,
	FONT_NEXT, 459, 396,
	FONT_NEXT, 454, 455,
	FONT_NEXT, 442, 510,
	FONT_NEXT, 422, 557,
	FONT_NEXT, 395, 598,
	FONT_NEXT, 363, 631,
	FONT_NEXT, 326, 655,
	FONT_NEXT, 284, 670,
	FONT_NEXT, 240, 676,
	FONT_NEXT, 193, 671,
	FONT_NEXT, 152, 657,
	FONT_NEXT, 116, 634,
	FONT_NEXT, 86, 605,
	FONT_NEXT, 62, 569,
	FONT_NEXT, 44, 528,
	FONT_NEXT, 30, 435,
	FONT_NEXT, 39, 369,
	FONT_NEXT, 69, 305,
	FONT_NEXT, 94, 278,
	FONT_NEXT, 125, 256,
	FONT_NEXT, 163, 242,
	FONT_NEXT, 210, 237,
	FONT_NEXT, 285, 250,
	FONT_NEXT, 357, 292,
	FONT_NEXT, 359, 290,
	FONT_NEXT, 354, 271,
	FONT_NEXT, 343, 239,
	FONT_NEXT, 324, 197,
	FONT_NEXT, 296, 149,
	FONT_NEXT, 256, 101,
	FONT_NEXT, 204, 56,
	FONT_NEXT, 138, 21,
	FONT_NEXT, 56, -2,
	FONT_END, 59, -22,
	FONT_BEGIN, 358, 332,
	FONT_NEXT, 346, 315,
	FONT_NEXT, 302, 291,
	FONT_NEXT, 250, 280,
	FONT_NEXT, 214, 285,
	FONT_NEXT, 185, 299,
	FONT_NEXT, 146, 348,
	FONT_NEXT, 127, 410,
	FONT_NEXT, 122, 473,
	FONT_NEXT, 126, 534,
	FONT_NEXT, 144, 591,
	FONT_NEXT, 176, 632,
	FONT_NEXT, 200, 643,
	FONT_NEXT, 229, 648,
	FONT_NEXT, 272, 639,
	FONT_NEXT, 305, 616,
	FONT_NEXT, 329, 583,
	FONT_NEXT, 345, 543,
	FONT_NEXT, 359, 458,
	FONT_NEXT, 361, 421,
	FONT_NEXT, 362, 394,
	FONT_END, 362, 355,
	FONT_ADVANCE, 500, 0
    },
    {
	58,
	FONT_BEGIN, 171, 361,
	FONT_NEXT, 186, 377,
	FONT_NEXT, 192, 402,
	FONT_NEXT, 187, 423,
	FONT_NEXT, 175, 442,
	FONT_NEXT, 157, 454,
	FONT_NEXT, 136, 459,
	FONT_NEXT, 114, 454,
	FONT_NEXT, 97, 442,
	FONT_NEXT, 85, 424,
	FONT_NEXT, 81, 402,
	FONT_NEXT, 86, 377,
	FONT_NEXT, 100, 360,
	FONT_END, 136, 348,
	FONT_BEGIN, 171, 2,
	FONT_NEXT, 186, 18,
	FONT_NEXT, 192, 43,
	FONT_NEXT, 187, 64,
	FONT_NEXT, 175, 83,
	FONT_NEXT, 157, 95,
	FONT_NEXT, 136, 100,
	FONT_NEXT, 114, 95,
	FONT_NEXT, 97, 83,
	FONT_NEXT, 85, 65,
	FONT_NEXT, 81, 43,
	FONT_NEXT, 86, 18,
	FONT_NEXT, 100, 1,
	FONT_END, 136, -11,
	FONT_ADVANCE, 278, 0
    },
    {
	59,
	FONT_BEGIN, 138, -123,
	FONT_NEXT, 175, -90,
	FONT_NEXT, 206, -45,
	FONT_NEXT, 219, 6,
	FONT_NEXT, 209, 56,
	FONT_NEXT, 186, 85,
	FONT_NEXT, 160, 98,
	FONT_NEXT, 139, 102,
	FONT_NEXT, 125, 100,
	FONT_NEXT, 105, 93,
	FONT_NEXT, 87, 76,
	FONT_NEXT, 80, 44,
	FONT_NEXT, 85, 20,
	FONT_NEXT, 99, 5,
	FONT_NEXT, 142, -6,
	FONT_NEXT, 157, -4,
	FONT_NEXT, 166, -2,
	FONT_NEXT, 175, -6,
	FONT_NEXT, 180, -16,
	FONT_NEXT, 176, -35,
	FONT_NEXT, 163, -61,
	FONT_NEXT, 138, -91,
	FONT_NEXT, 98, -122,
	FONT_END, 107, -141,
	FONT_BEGIN, 171, 361,
	FONT_NEXT, 186, 377,
	FONT_NEXT, 192, 402,
	FONT_NEXT, 187, 423,
	FONT_NEXT, 175, 442,
	FONT_NEXT, 157, 454,
	FONT_NEXT, 136, 459,
	FONT_NEXT, 114, 454,
	FONT_NEXT, 97, 442,
	FONT_NEXT, 85, 424,
	FONT_NEXT, 81, 402,
	FONT_NEXT, 86, 377,
	FONT_NEXT, 100, 360,
	FONT_END, 136, 348,
	FONT_ADVANCE, 278, 0
    },
    {
	60,
	FONT_BEGIN, 111, 253,
	FONT_NEXT, 536, 446,
	FONT_NEXT, 536, 514,
	FONT_NEXT, 28, 284,
	FONT_NEXT, 28, 222,
	FONT_NEXT, 536, -8,
	FONT_END, 536, 60,
	FONT_ADVANCE, 564, 0
    },
    {
	61,
	FONT_BEGIN, 30, 386,
	FONT_NEXT, 30, 320,
	FONT_NEXT, 534, 320,
	FONT_END, 534, 386,
	FONT_BEGIN, 30, 186,
	FONT_NEXT, 30, 120,
	FONT_NEXT, 534, 120,
	FONT_END, 534, 186,
	FONT_ADVANCE, 564, 0
    },
    {
	62,
	FONT_BEGIN, 28, -8,
	FONT_NEXT, 536, 222,
	FONT_NEXT, 536, 284,
	FONT_NEXT, 28, 514,
	FONT_NEXT, 28, 446,
	FONT_NEXT, 453, 253,
	FONT_END, 28, 60,
	FONT_ADVANCE, 564, 0
    },
    {
	63,
	FONT_BEGIN, 257, 220,
	FONT_NEXT, 276, 267,
	FONT_NEXT, 302, 309,
	FONT_NEXT, 339, 354,
	FONT_NEXT, 363, 385,
	FONT_NEXT, 387, 426,
	FONT_NEXT, 406, 469,
	FONT_NEXT, 414, 510,
	FONT_NEXT, 412, 544,
	FONT_NEXT, 406, 571,
	FONT_NEXT, 378, 618,
	FONT_NEXT, 352, 639,
	FONT_NEXT, 316, 657,
	FONT_NEXT, 274, 671,
	FONT_NEXT, 231, 676,
	FONT_NEXT, 176, 667,
	FONT_NEXT, 123, 641,
	FONT_NEXT, 83, 597,
	FONT_NEXT, 72, 567,
	FONT_NEXT, 68, 532,
	FONT_NEXT, 78, 487,
	FONT_NEXT, 93, 474,
	FONT_NEXT, 118, 469,
	FONT_NEXT, 135, 473,
	FONT_NEXT, 148, 483,
	FONT_NEXT, 157, 510,
	FONT_NEXT, 119, 585,
	FONT_NEXT, 127, 608,
	FONT_NEXT, 149, 627,
	FONT_NEXT, 179, 641,
	FONT_NEXT, 212, 646,
	FONT_NEXT, 261, 634,
	FONT_NEXT, 295, 605,
	FONT_NEXT, 315, 564,
	FONT_NEXT, 322, 519,
	FONT_NEXT, 310, 444,
	FONT_NEXT, 285, 370,
	FONT_NEXT, 257, 306,
	FONT_NEXT, 249, 286,
	FONT_NEXT, 239, 251,
	FONT_NEXT, 227, 164,
	FONT_END, 244, 164,
	FONT_BEGIN, 273, 4,
	FONT_NEXT, 286, 19,
	FONT_NEXT, 292, 43,
	FONT_NEXT, 287, 63,
	FONT_NEXT, 276, 80,
	FONT_NEXT, 258, 92,
	FONT_NEXT, 237, 97,
	FONT_NEXT, 216, 92,
	FONT_NEXT, 199, 81,
	FONT_NEXT, 188, 64,
	FONT_NEXT, 184, 43,
	FONT_NEXT, 189, 19,
	FONT_NEXT, 202, 3,
	FONT_END, 237, -8,
	FONT_ADVANCE, 444, 0
    },
    {
	64,
	FONT_BEGIN, 554, 306,
	FONT_NEXT, 524, 240,
	FONT_NEXT, 489, 200,
	FONT_NEXT, 455, 187,
	FONT_NEXT, 430, 191,
	FONT_NEXT, 410, 206,
	FONT_NEXT, 396, 232,
	FONT_NEXT, 392, 271,
	FONT_NEXT, 395, 314,
	FONT_NEXT, 406, 352,
	FONT_NEXT, 442, 412,
	FONT_NEXT, 487, 450,
	FONT_NEXT, 529, 464,
	FONT_NEXT, 548, 459,
	FONT_NEXT, 561, 447,
	FONT_NEXT, 569, 426,
	FONT_END, 572, 399,
	FONT_BEGIN, 601, 39,
	FONT_NEXT, 550, 28,
	FONT_NEXT, 490, 25,
	FONT_NEXT, 427, 31,
	FONT_NEXT, 371, 48,
	FONT_NEXT, 321, 75,
	FONT_NEXT, 279, 111,
	FONT_NEXT, 245, 153,
	FONT_NEXT, 220, 200,
	FONT_NEXT, 205, 251,
	FONT_NEXT, 200, 305,
	FONT_NEXT, 205, 383,
	FONT_NEXT, 222, 451,
	FONT_NEXT, 248, 510,
	FONT_NEXT, 283, 558,
	FONT_NEXT, 324, 595,
	FONT_NEXT, 372, 623,
	FONT_NEXT, 424, 639,
	FONT_NEXT, 481, 645,
	FONT_NEXT, 545, 638,
	FONT_NEXT, 603, 619,
	FONT_NEXT, 652, 591,
	FONT_NEXT, 693, 555,
	FONT_NEXT, 726, 513,
	FONT_NEXT, 749, 469,
	FONT_NEXT, 764, 424,
	FONT_NEXT, 769, 380,
	FONT_NEXT, 760, 311,
	FONT_NEXT, 734, 245,
	FONT_NEXT, 693, 195,
	FONT_NEXT, 667, 181,
	FONT_NEXT, 639, 176,
	FONT_NEXT, 613, 183,
	FONT_NEXT, 603, 202,
	FONT_NEXT, 603, 240,
	FONT_NEXT, 668, 494,
	FONT_NEXT, 599, 494,
	FONT_NEXT, 589, 456,
	FONT_NEXT, 565, 491,
	FONT_NEXT, 546, 503,
	FONT_NEXT, 518, 508,
	FONT_NEXT, 470, 500,
	FONT_NEXT, 430, 480,
	FONT_NEXT, 396, 450,
	FONT_NEXT, 368, 414,
	FONT_NEXT, 332, 335,
	FONT_NEXT, 323, 298,
	FONT_NEXT, 321, 268,
	FONT_NEXT, 323, 230,
	FONT_NEXT, 332, 200,
	FONT_NEXT, 358, 163,
	FONT_NEXT, 390, 147,
	FONT_NEXT, 417, 144,
	FONT_NEXT, 457, 154,
	FONT_NEXT, 492, 174,
	FONT_NEXT, 517, 196,
	FONT_NEXT, 532, 214,
	FONT_NEXT, 534, 214,
	FONT_NEXT, 538, 197,
	FONT_NEXT, 553, 173,
	FONT_NEXT, 581, 152,
	FONT_NEXT, 623, 143,
	FONT_NEXT, 665, 149,
	FONT_NEXT, 702, 165,
	FONT_NEXT, 734, 191,
	FONT_NEXT, 760, 223,
	FONT_NEXT, 796, 300,
	FONT_NEXT, 809, 381,
	FONT_NEXT, 802, 442,
	FONT_NEXT, 783, 498,
	FONT_NEXT, 753, 548,
	FONT_NEXT, 714, 591,
	FONT_NEXT, 665, 627,
	FONT_NEXT, 609, 653,
	FONT_NEXT, 547, 670,
	FONT_NEXT, 481, 676,
	FONT_NEXT, 408, 669,
	FONT_NEXT, 340, 649,
	FONT_NEXT, 278, 618,
	FONT_NEXT, 224, 576,
	FONT_NEXT, 179, 524,
	FONT_NEXT, 145, 462,
	FONT_NEXT, 123, 392,
	FONT_NEXT, 116, 315,
	FONT_NEXT, 121, 262,
	FONT_NEXT, 137, 207,
	FONT_NEXT, 165, 152,
	FONT_NEXT, 205, 100,
	FONT_NEXT, 257, 54,
	FONT_NEXT, 322, 18,
	FONT_NEXT, 399, -6,
	FONT_NEXT, 491, -14,
	FONT_NEXT, 547, -10,
	FONT_NEXT, 601, 3,
	FONT_NEXT, 700, 43,
	FONT_END, 688, 73,
	FONT_ADVANCE, 921, 0
    },
    {
	65,
	FONT_BEGIN, 677, 23,
	FONT_NEXT, 656, 36,
	FONT_NEXT, 637, 62,
	FONT_NEXT, 616, 106,
	FONT_NEXT, 367, 674,
	FONT_NEXT, 347, 674,
	FONT_NEXT, 139, 183,
	FONT_NEXT, 104, 104,
	FONT_NEXT, 84, 67,
	FONT_NEXT, 66, 41,
	FONT_NEXT, 39, 23,
	FONT_NEXT, 15, 19,
	FONT_NEXT, 15, 0,
	FONT_NEXT, 213, 0,
	FONT_NEXT, 213, 19,
	FONT_NEXT, 171, 24,
	FONT_NEXT, 152, 36,
	FONT_NEXT, 145, 61,
	FONT_NEXT, 153, 99,
	FONT_NEXT, 199, 216,
	FONT_NEXT, 461, 216,
	FONT_NEXT, 502, 120,
	FONT_NEXT, 521, 57,
	FONT_NEXT, 515, 35,
	FONT_NEXT, 499, 24,
	FONT_NEXT, 451, 19,
	FONT_NEXT, 451, 0,
	FONT_NEXT, 706, 0,
	FONT_END, 706, 19,
	FONT_BEGIN, 331, 532,
	FONT_NEXT, 447, 257,
	FONT_END, 216, 257,
	FONT_ADVANCE, 722, 0
    },
    {
	66,
	FONT_BEGIN, 66, 637,
	FONT_NEXT, 95, 624,
	FONT_NEXT, 109, 597,
	FONT_NEXT, 113, 553,
	FONT_NEXT, 113, 109,
	FONT_NEXT, 109, 65,
	FONT_NEXT, 96, 38,
	FONT_NEXT, 67, 23,
	FONT_NEXT, 17, 19,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 351, 0,
	FONT_NEXT, 425, 6,
	FONT_NEXT, 482, 22,
	FONT_NEXT, 525, 45,
	FONT_NEXT, 555, 73,
	FONT_NEXT, 574, 103,
	FONT_NEXT, 586, 132,
	FONT_NEXT, 593, 176,
	FONT_NEXT, 589, 212,
	FONT_NEXT, 579, 244,
	FONT_NEXT, 542, 294,
	FONT_NEXT, 488, 327,
	FONT_NEXT, 426, 347,
	FONT_NEXT, 426, 349,
	FONT_NEXT, 465, 360,
	FONT_NEXT, 509, 383,
	FONT_NEXT, 544, 425,
	FONT_NEXT, 555, 455,
	FONT_NEXT, 559, 493,
	FONT_NEXT, 551, 544,
	FONT_NEXT, 530, 584,
	FONT_NEXT, 499, 614,
	FONT_NEXT, 460, 635,
	FONT_NEXT, 374, 657,
	FONT_NEXT, 297, 662,
	FONT_NEXT, 17, 662,
	FONT_END, 17, 643,
	FONT_BEGIN, 276, 325,
	FONT_NEXT, 319, 322,
	FONT_NEXT, 377, 311,
	FONT_NEXT, 414, 295,
	FONT_NEXT, 447, 270,
	FONT_NEXT, 469, 232,
	FONT_NEXT, 478, 180,
	FONT_NEXT, 472, 135,
	FONT_NEXT, 458, 101,
	FONT_NEXT, 436, 75,
	FONT_NEXT, 409, 58,
	FONT_NEXT, 348, 40,
	FONT_NEXT, 291, 37,
	FONT_NEXT, 254, 38,
	FONT_NEXT, 231, 43,
	FONT_NEXT, 218, 55,
	FONT_NEXT, 215, 78,
	FONT_END, 215, 326,
	FONT_BEGIN, 218, 615,
	FONT_NEXT, 237, 624,
	FONT_NEXT, 255, 624,
	FONT_NEXT, 282, 625,
	FONT_NEXT, 339, 620,
	FONT_NEXT, 396, 600,
	FONT_NEXT, 420, 582,
	FONT_NEXT, 439, 558,
	FONT_NEXT, 452, 527,
	FONT_NEXT, 457, 487,
	FONT_NEXT, 451, 447,
	FONT_NEXT, 437, 417,
	FONT_NEXT, 394, 381,
	FONT_NEXT, 344, 368,
	FONT_NEXT, 310, 366,
	FONT_NEXT, 215, 365,
	FONT_END, 215, 595,
	FONT_ADVANCE, 667, 0
    },
    {
	67,
	FONT_BEGIN, 611, 676,
	FONT_NEXT, 590, 676,
	FONT_NEXT, 580, 656,
	FONT_NEXT, 565, 647,
	FONT_NEXT, 544, 643,
	FONT_NEXT, 519, 648,
	FONT_NEXT, 481, 659,
	FONT_NEXT, 429, 670,
	FONT_NEXT, 368, 676,
	FONT_NEXT, 304, 670,
	FONT_NEXT, 242, 653,
	FONT_NEXT, 184, 625,
	FONT_NEXT, 133, 587,
	FONT_NEXT, 90, 538,
	FONT_NEXT, 56, 479,
	FONT_NEXT, 35, 410,
	FONT_NEXT, 28, 331,
	FONT_NEXT, 35, 244,
	FONT_NEXT, 57, 172,
	FONT_NEXT, 91, 112,
	FONT_NEXT, 134, 65,
	FONT_NEXT, 185, 29,
	FONT_NEXT, 241, 4,
	FONT_NEXT, 301, -10,
	FONT_NEXT, 362, -14,
	FONT_NEXT, 426, -9,
	FONT_NEXT, 481, 5,
	FONT_NEXT, 528, 25,
	FONT_NEXT, 566, 48,
	FONT_NEXT, 595, 71,
	FONT_NEXT, 616, 92,
	FONT_NEXT, 628, 106,
	FONT_NEXT, 633, 113,
	FONT_NEXT, 615, 131,
	FONT_NEXT, 583, 102,
	FONT_NEXT, 536, 69,
	FONT_NEXT, 471, 41,
	FONT_NEXT, 389, 30,
	FONT_NEXT, 342, 34,
	FONT_NEXT, 297, 46,
	FONT_NEXT, 256, 68,
	FONT_NEXT, 219, 100,
	FONT_NEXT, 188, 141,
	FONT_NEXT, 164, 192,
	FONT_NEXT, 149, 255,
	FONT_NEXT, 144, 329,
	FONT_NEXT, 151, 422,
	FONT_NEXT, 170, 491,
	FONT_NEXT, 197, 540,
	FONT_NEXT, 227, 575,
	FONT_NEXT, 261, 601,
	FONT_NEXT, 299, 620,
	FONT_NEXT, 377, 636,
	FONT_NEXT, 420, 632,
	FONT_NEXT, 459, 621,
	FONT_NEXT, 523, 582,
	FONT_NEXT, 569, 524,
	FONT_NEXT, 597, 451,
	FONT_END, 620, 451,
	FONT_ADVANCE, 667, 0
    },
    {
	68,
	FONT_BEGIN, 300, 0,
	FONT_NEXT, 404, 8,
	FONT_NEXT, 489, 32,
	FONT_NEXT, 556, 69,
	FONT_NEXT, 607, 114,
	FONT_NEXT, 643, 166,
	FONT_NEXT, 667, 221,
	FONT_NEXT, 681, 276,
	FONT_NEXT, 685, 329,
	FONT_NEXT, 677, 407,
	FONT_NEXT, 656, 475,
	FONT_NEXT, 622, 532,
	FONT_NEXT, 575, 579,
	FONT_NEXT, 517, 615,
	FONT_NEXT, 449, 641,
	FONT_NEXT, 372, 656,
	FONT_NEXT, 286, 662,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 16, 643,
	FONT_NEXT, 62, 636,
	FONT_NEXT, 88, 623,
	FONT_NEXT, 101, 597,
	FONT_NEXT, 104, 553,
	FONT_NEXT, 104, 109,
	FONT_NEXT, 100, 65,
	FONT_NEXT, 88, 39,
	FONT_NEXT, 61, 24,
	FONT_NEXT, 16, 19,
	FONT_END, 16, 0,
	FONT_BEGIN, 211, 613,
	FONT_NEXT, 225, 621,
	FONT_NEXT, 253, 625,
	FONT_NEXT, 335, 620,
	FONT_NEXT, 397, 606,
	FONT_NEXT, 444, 584,
	FONT_NEXT, 483, 555,
	FONT_NEXT, 526, 505,
	FONT_NEXT, 555, 449,
	FONT_NEXT, 571, 390,
	FONT_NEXT, 576, 328,
	FONT_NEXT, 573, 276,
	FONT_NEXT, 565, 231,
	FONT_NEXT, 536, 159,
	FONT_NEXT, 494, 108,
	FONT_NEXT, 445, 73,
	FONT_NEXT, 392, 52,
	FONT_NEXT, 341, 41,
	FONT_NEXT, 297, 37,
	FONT_NEXT, 266, 37,
	FONT_NEXT, 236, 38,
	FONT_NEXT, 218, 44,
	FONT_NEXT, 208, 57,
	FONT_NEXT, 206, 78,
	FONT_END, 206, 586,
	FONT_ADVANCE, 722, 0
    },
    {
	69,
	FONT_BEGIN, 569, 169,
	FONT_NEXT, 533, 105,
	FONT_NEXT, 489, 65,
	FONT_NEXT, 430, 44,
	FONT_NEXT, 350, 38,
	FONT_NEXT, 300, 38,
	FONT_NEXT, 263, 38,
	FONT_NEXT, 237, 40,
	FONT_NEXT, 219, 43,
	FONT_NEXT, 203, 56,
	FONT_NEXT, 201, 80,
	FONT_NEXT, 201, 328,
	FONT_NEXT, 355, 326,
	FONT_NEXT, 405, 321,
	FONT_NEXT, 436, 308,
	FONT_NEXT, 454, 279,
	FONT_NEXT, 465, 231,
	FONT_NEXT, 488, 231,
	FONT_NEXT, 488, 463,
	FONT_NEXT, 465, 463,
	FONT_NEXT, 455, 418,
	FONT_NEXT, 439, 388,
	FONT_NEXT, 408, 372,
	FONT_NEXT, 355, 368,
	FONT_NEXT, 201, 368,
	FONT_NEXT, 201, 590,
	FONT_NEXT, 203, 609,
	FONT_NEXT, 209, 619,
	FONT_NEXT, 234, 624,
	FONT_NEXT, 369, 624,
	FONT_NEXT, 437, 620,
	FONT_NEXT, 481, 604,
	FONT_NEXT, 506, 572,
	FONT_NEXT, 521, 519,
	FONT_NEXT, 546, 519,
	FONT_NEXT, 543, 662,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 12, 643,
	FONT_NEXT, 52, 637,
	FONT_NEXT, 79, 625,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 99, 553,
	FONT_NEXT, 99, 109,
	FONT_NEXT, 94, 63,
	FONT_NEXT, 79, 36,
	FONT_NEXT, 52, 23,
	FONT_NEXT, 12, 19,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 552, 0,
	FONT_END, 597, 169,
	FONT_ADVANCE, 611, 0
    },
    {
	70,
	FONT_BEGIN, 479, 463,
	FONT_NEXT, 456, 463,
	FONT_NEXT, 446, 416,
	FONT_NEXT, 428, 387,
	FONT_NEXT, 396, 372,
	FONT_NEXT, 346, 368,
	FONT_NEXT, 201, 368,
	FONT_NEXT, 201, 590,
	FONT_NEXT, 202, 607,
	FONT_NEXT, 207, 618,
	FONT_NEXT, 233, 624,
	FONT_NEXT, 369, 624,
	FONT_NEXT, 437, 620,
	FONT_NEXT, 481, 604,
	FONT_NEXT, 506, 572,
	FONT_NEXT, 521, 519,
	FONT_NEXT, 546, 519,
	FONT_NEXT, 543, 662,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 12, 643,
	FONT_NEXT, 52, 637,
	FONT_NEXT, 79, 625,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 99, 553,
	FONT_NEXT, 99, 120,
	FONT_NEXT, 95, 70,
	FONT_NEXT, 83, 40,
	FONT_NEXT, 57, 24,
	FONT_NEXT, 12, 19,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 292, 0,
	FONT_NEXT, 292, 19,
	FONT_NEXT, 247, 23,
	FONT_NEXT, 219, 37,
	FONT_NEXT, 205, 63,
	FONT_NEXT, 201, 109,
	FONT_NEXT, 201, 328,
	FONT_NEXT, 346, 326,
	FONT_NEXT, 393, 322,
	FONT_NEXT, 425, 309,
	FONT_NEXT, 444, 281,
	FONT_NEXT, 456, 231,
	FONT_END, 479, 231,
	FONT_ADVANCE, 556, 0
    },
    {
	71,
	FONT_BEGIN, 454, 354,
	FONT_NEXT, 454, 336,
	FONT_NEXT, 496, 331,
	FONT_NEXT, 523, 320,
	FONT_NEXT, 537, 295,
	FONT_NEXT, 542, 247,
	FONT_NEXT, 542, 85,
	FONT_NEXT, 530, 60,
	FONT_NEXT, 499, 42,
	FONT_NEXT, 455, 30,
	FONT_NEXT, 405, 26,
	FONT_NEXT, 349, 31,
	FONT_NEXT, 299, 46,
	FONT_NEXT, 254, 71,
	FONT_NEXT, 217, 105,
	FONT_NEXT, 187, 147,
	FONT_NEXT, 164, 197,
	FONT_NEXT, 150, 255,
	FONT_NEXT, 146, 320,
	FONT_NEXT, 152, 406,
	FONT_NEXT, 170, 476,
	FONT_NEXT, 197, 531,
	FONT_NEXT, 231, 572,
	FONT_NEXT, 269, 602,
	FONT_NEXT, 310, 622,
	FONT_NEXT, 388, 636,
	FONT_NEXT, 436, 631,
	FONT_NEXT, 477, 619,
	FONT_NEXT, 539, 577,
	FONT_NEXT, 581, 522,
	FONT_NEXT, 607, 465,
	FONT_NEXT, 630, 465,
	FONT_NEXT, 622, 676,
	FONT_NEXT, 600, 676,
	FONT_NEXT, 591, 659,
	FONT_NEXT, 577, 649,
	FONT_NEXT, 553, 643,
	FONT_NEXT, 525, 648,
	FONT_NEXT, 489, 659,
	FONT_NEXT, 440, 670,
	FONT_NEXT, 374, 676,
	FONT_NEXT, 298, 668,
	FONT_NEXT, 231, 647,
	FONT_NEXT, 172, 614,
	FONT_NEXT, 123, 571,
	FONT_NEXT, 84, 520,
	FONT_NEXT, 55, 464,
	FONT_NEXT, 38, 403,
	FONT_NEXT, 32, 341,
	FONT_NEXT, 37, 255,
	FONT_NEXT, 53, 189,
	FONT_NEXT, 79, 137,
	FONT_NEXT, 115, 93,
	FONT_NEXT, 174, 43,
	FONT_NEXT, 245, 10,
	FONT_NEXT, 320, -9,
	FONT_NEXT, 396, -14,
	FONT_NEXT, 480, -5,
	FONT_NEXT, 558, 16,
	FONT_NEXT, 616, 40,
	FONT_NEXT, 633, 50,
	FONT_NEXT, 639, 58,
	FONT_NEXT, 639, 259,
	FONT_NEXT, 643, 300,
	FONT_NEXT, 657, 322,
	FONT_NEXT, 679, 332,
	FONT_NEXT, 709, 336,
	FONT_END, 709, 354,
	FONT_ADVANCE, 722, 0
    },
    {
	72,
	FONT_BEGIN, 297, 0,
	FONT_NEXT, 297, 19,
	FONT_NEXT, 250, 25,
	FONT_NEXT, 223, 41,
	FONT_NEXT, 211, 67,
	FONT_NEXT, 209, 109,
	FONT_NEXT, 209, 315,
	FONT_NEXT, 512, 315,
	FONT_NEXT, 512, 120,
	FONT_NEXT, 510, 73,
	FONT_NEXT, 499, 42,
	FONT_NEXT, 473, 25,
	FONT_NEXT, 424, 19,
	FONT_NEXT, 424, 0,
	FONT_NEXT, 702, 0,
	FONT_NEXT, 702, 19,
	FONT_NEXT, 655, 25,
	FONT_NEXT, 628, 41,
	FONT_NEXT, 616, 67,
	FONT_NEXT, 614, 109,
	FONT_NEXT, 614, 553,
	FONT_NEXT, 617, 596,
	FONT_NEXT, 629, 622,
	FONT_NEXT, 656, 636,
	FONT_NEXT, 702, 643,
	FONT_NEXT, 702, 662,
	FONT_NEXT, 424, 662,
	FONT_NEXT, 424, 643,
	FONT_NEXT, 468, 636,
	FONT_NEXT, 495, 623,
	FONT_NEXT, 508, 597,
	FONT_NEXT, 512, 553,
	FONT_NEXT, 512, 359,
	FONT_NEXT, 209, 359,
	FONT_NEXT, 209, 553,
	FONT_NEXT, 212, 596,
	FONT_NEXT, 224, 622,
	FONT_NEXT, 251, 636,
	FONT_NEXT, 297, 643,
	FONT_NEXT, 297, 662,
	FONT_NEXT, 19, 662,
	FONT_NEXT, 19, 643,
	FONT_NEXT, 63, 636,
	FONT_NEXT, 90, 623,
	FONT_NEXT, 103, 597,
	FONT_NEXT, 107, 553,
	FONT_NEXT, 107, 120,
	FONT_NEXT, 105, 73,
	FONT_NEXT, 94, 42,
	FONT_NEXT, 68, 25,
	FONT_NEXT, 19, 19,
	FONT_END, 19, 0,
	FONT_ADVANCE, 722, 0
    },
    {
	73,
	FONT_BEGIN, 315, 0,
	FONT_NEXT, 315, 19,
	FONT_NEXT, 268, 22,
	FONT_NEXT, 238, 35,
	FONT_NEXT, 221, 62,
	FONT_NEXT, 217, 109,
	FONT_NEXT, 217, 553,
	FONT_NEXT, 222, 600,
	FONT_NEXT, 238, 626,
	FONT_NEXT, 268, 638,
	FONT_NEXT, 315, 643,
	FONT_NEXT, 315, 662,
	FONT_NEXT, 18, 662,
	FONT_NEXT, 18, 643,
	FONT_NEXT, 68, 637,
	FONT_NEXT, 97, 624,
	FONT_NEXT, 111, 597,
	FONT_NEXT, 115, 553,
	FONT_NEXT, 115, 109,
	FONT_NEXT, 111, 65,
	FONT_NEXT, 98, 38,
	FONT_NEXT, 69, 23,
	FONT_NEXT, 18, 19,
	FONT_END, 18, 0,
	FONT_ADVANCE, 333, 0
    },
    {
	74,
	FONT_BEGIN, 281, 597,
	FONT_NEXT, 294, 623,
	FONT_NEXT, 322, 637,
	FONT_NEXT, 370, 643,
	FONT_NEXT, 370, 662,
	FONT_NEXT, 83, 662,
	FONT_NEXT, 83, 643,
	FONT_NEXT, 131, 636,
	FONT_NEXT, 159, 622,
	FONT_NEXT, 172, 596,
	FONT_NEXT, 176, 553,
	FONT_NEXT, 176, 90,
	FONT_NEXT, 173, 57,
	FONT_NEXT, 165, 37,
	FONT_NEXT, 153, 27,
	FONT_NEXT, 137, 24,
	FONT_NEXT, 117, 37,
	FONT_NEXT, 107, 66,
	FONT_NEXT, 92, 94,
	FONT_NEXT, 77, 104,
	FONT_NEXT, 56, 108,
	FONT_NEXT, 36, 103,
	FONT_NEXT, 22, 90,
	FONT_NEXT, 10, 59,
	FONT_NEXT, 15, 36,
	FONT_NEXT, 32, 11,
	FONT_NEXT, 59, -6,
	FONT_NEXT, 110, -14,
	FONT_NEXT, 124, -14,
	FONT_NEXT, 147, -11,
	FONT_NEXT, 204, 11,
	FONT_NEXT, 231, 35,
	FONT_NEXT, 255, 70,
	FONT_NEXT, 271, 118,
	FONT_NEXT, 278, 183,
	FONT_END, 278, 553,
	FONT_ADVANCE, 389, 0
    },
    {
	75,
	FONT_BEGIN, 444, 641,
	FONT_NEXT, 465, 636,
	FONT_NEXT, 477, 627,
	FONT_NEXT, 481, 612,
	FONT_NEXT, 472, 584,
	FONT_NEXT, 459, 567,
	FONT_NEXT, 438, 543,
	FONT_NEXT, 406, 511,
	FONT_NEXT, 361, 470,
	FONT_NEXT, 301, 416,
	FONT_NEXT, 226, 348,
	FONT_NEXT, 226, 553,
	FONT_NEXT, 229, 597,
	FONT_NEXT, 242, 623,
	FONT_NEXT, 270, 637,
	FONT_NEXT, 318, 643,
	FONT_NEXT, 318, 662,
	FONT_NEXT, 34, 662,
	FONT_NEXT, 34, 643,
	FONT_NEXT, 76, 637,
	FONT_NEXT, 104, 625,
	FONT_NEXT, 119, 599,
	FONT_NEXT, 124, 553,
	FONT_NEXT, 124, 120,
	FONT_NEXT, 120, 70,
	FONT_NEXT, 108, 40,
	FONT_NEXT, 80, 24,
	FONT_NEXT, 34, 19,
	FONT_NEXT, 34, 0,
	FONT_NEXT, 316, 0,
	FONT_NEXT, 316, 19,
	FONT_NEXT, 269, 24,
	FONT_NEXT, 241, 39,
	FONT_NEXT, 229, 65,
	FONT_NEXT, 226, 109,
	FONT_NEXT, 226, 296,
	FONT_NEXT, 252, 317,
	FONT_NEXT, 358, 212,
	FONT_NEXT, 392, 175,
	FONT_NEXT, 435, 126,
	FONT_NEXT, 472, 78,
	FONT_NEXT, 483, 58,
	FONT_NEXT, 488, 44,
	FONT_NEXT, 484, 31,
	FONT_NEXT, 472, 24,
	FONT_NEXT, 451, 20,
	FONT_NEXT, 418, 19,
	FONT_NEXT, 418, 0,
	FONT_NEXT, 723, 0,
	FONT_NEXT, 723, 19,
	FONT_NEXT, 683, 24,
	FONT_NEXT, 647, 45,
	FONT_NEXT, 609, 79,
	FONT_NEXT, 566, 127,
	FONT_NEXT, 333, 377,
	FONT_NEXT, 523, 565,
	FONT_NEXT, 568, 606,
	FONT_NEXT, 603, 628,
	FONT_NEXT, 635, 638,
	FONT_NEXT, 675, 643,
	FONT_NEXT, 675, 662,
	FONT_NEXT, 413, 662,
	FONT_END, 413, 643,
	FONT_ADVANCE, 722, 0
    },
    {
	76,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 12, 643,
	FONT_NEXT, 52, 637,
	FONT_NEXT, 79, 625,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 99, 553,
	FONT_NEXT, 99, 109,
	FONT_NEXT, 94, 63,
	FONT_NEXT, 79, 36,
	FONT_NEXT, 52, 23,
	FONT_NEXT, 12, 19,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 550, 0,
	FONT_NEXT, 598, 174,
	FONT_NEXT, 573, 174,
	FONT_NEXT, 551, 130,
	FONT_NEXT, 527, 97,
	FONT_NEXT, 501, 73,
	FONT_NEXT, 472, 57,
	FONT_NEXT, 399, 41,
	FONT_NEXT, 302, 39,
	FONT_NEXT, 251, 39,
	FONT_NEXT, 220, 44,
	FONT_NEXT, 205, 56,
	FONT_NEXT, 201, 80,
	FONT_NEXT, 201, 553,
	FONT_NEXT, 205, 599,
	FONT_NEXT, 222, 626,
	FONT_NEXT, 250, 638,
	FONT_NEXT, 294, 643,
	FONT_END, 294, 662,
	FONT_ADVANCE, 611, 0
    },
    {
	77,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 443, 157,
	FONT_NEXT, 212, 662,
	FONT_NEXT, 14, 662,
	FONT_NEXT, 14, 643,
	FONT_NEXT, 60, 638,
	FONT_NEXT, 89, 625,
	FONT_NEXT, 104, 599,
	FONT_NEXT, 109, 553,
	FONT_NEXT, 109, 147,
	FONT_NEXT, 107, 110,
	FONT_NEXT, 104, 82,
	FONT_NEXT, 89, 44,
	FONT_NEXT, 59, 25,
	FONT_NEXT, 12, 19,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 247, 0,
	FONT_NEXT, 247, 19,
	FONT_NEXT, 201, 25,
	FONT_NEXT, 172, 45,
	FONT_NEXT, 157, 83,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 153, 546,
	FONT_NEXT, 155, 546,
	FONT_NEXT, 404, 0,
	FONT_NEXT, 418, 0,
	FONT_NEXT, 672, 569,
	FONT_NEXT, 674, 569,
	FONT_NEXT, 674, 120,
	FONT_NEXT, 670, 70,
	FONT_NEXT, 657, 40,
	FONT_NEXT, 630, 24,
	FONT_NEXT, 583, 19,
	FONT_NEXT, 583, 0,
	FONT_NEXT, 863, 0,
	FONT_NEXT, 863, 19,
	FONT_NEXT, 822, 23,
	FONT_NEXT, 795, 36,
	FONT_NEXT, 780, 63,
	FONT_NEXT, 776, 109,
	FONT_NEXT, 776, 553,
	FONT_NEXT, 780, 599,
	FONT_NEXT, 795, 625,
	FONT_NEXT, 822, 637,
	FONT_NEXT, 863, 643,
	FONT_END, 863, 662,
	FONT_ADVANCE, 889, 0
    },
    {
	78,
	FONT_BEGIN, 472, 662,
	FONT_NEXT, 472, 643,
	FONT_NEXT, 515, 637,
	FONT_NEXT, 545, 620,
	FONT_NEXT, 562, 582,
	FONT_NEXT, 566, 553,
	FONT_NEXT, 568, 515,
	FONT_NEXT, 568, 181,
	FONT_NEXT, 566, 181,
	FONT_NEXT, 183, 662,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 12, 643,
	FONT_NEXT, 60, 634,
	FONT_NEXT, 82, 617,
	FONT_NEXT, 109, 588,
	FONT_NEXT, 109, 147,
	FONT_NEXT, 107, 110,
	FONT_NEXT, 104, 82,
	FONT_NEXT, 89, 44,
	FONT_NEXT, 59, 25,
	FONT_NEXT, 12, 19,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 247, 0,
	FONT_NEXT, 247, 19,
	FONT_NEXT, 201, 25,
	FONT_NEXT, 172, 45,
	FONT_NEXT, 157, 83,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 153, 537,
	FONT_NEXT, 155, 537,
	FONT_NEXT, 595, -11,
	FONT_NEXT, 612, -11,
	FONT_NEXT, 612, 515,
	FONT_NEXT, 613, 553,
	FONT_NEXT, 617, 583,
	FONT_NEXT, 635, 620,
	FONT_NEXT, 665, 636,
	FONT_NEXT, 707, 643,
	FONT_END, 707, 662,
	FONT_ADVANCE, 722, 0
    },
    {
	79,
	FONT_BEGIN, 427, -8,
	FONT_NEXT, 488, 9,
	FONT_NEXT, 544, 38,
	FONT_NEXT, 592, 78,
	FONT_NEXT, 632, 127,
	FONT_NEXT, 662, 186,
	FONT_NEXT, 681, 254,
	FONT_NEXT, 688, 330,
	FONT_NEXT, 680, 410,
	FONT_NEXT, 659, 481,
	FONT_NEXT, 627, 540,
	FONT_NEXT, 586, 589,
	FONT_NEXT, 536, 627,
	FONT_NEXT, 481, 654,
	FONT_NEXT, 422, 670,
	FONT_NEXT, 361, 676,
	FONT_NEXT, 299, 670,
	FONT_NEXT, 240, 654,
	FONT_NEXT, 185, 627,
	FONT_NEXT, 136, 589,
	FONT_NEXT, 94, 540,
	FONT_NEXT, 62, 481,
	FONT_NEXT, 41, 410,
	FONT_NEXT, 34, 330,
	FONT_NEXT, 40, 254,
	FONT_NEXT, 59, 186,
	FONT_NEXT, 89, 127,
	FONT_NEXT, 129, 78,
	FONT_NEXT, 177, 38,
	FONT_NEXT, 233, 9,
	FONT_NEXT, 294, -8,
	FONT_END, 361, -14,
	FONT_BEGIN, 319, 26,
	FONT_NEXT, 280, 39,
	FONT_NEXT, 244, 61,
	FONT_NEXT, 212, 94,
	FONT_NEXT, 186, 136,
	FONT_NEXT, 165, 189,
	FONT_NEXT, 152, 254,
	FONT_NEXT, 148, 331,
	FONT_NEXT, 152, 409,
	FONT_NEXT, 166, 475,
	FONT_NEXT, 188, 528,
	FONT_NEXT, 216, 571,
	FONT_NEXT, 248, 602,
	FONT_NEXT, 284, 623,
	FONT_NEXT, 322, 636,
	FONT_NEXT, 361, 640,
	FONT_NEXT, 399, 636,
	FONT_NEXT, 437, 623,
	FONT_NEXT, 473, 602,
	FONT_NEXT, 505, 571,
	FONT_NEXT, 533, 528,
	FONT_NEXT, 555, 475,
	FONT_NEXT, 569, 409,
	FONT_NEXT, 574, 331,
	FONT_NEXT, 569, 254,
	FONT_NEXT, 556, 189,
	FONT_NEXT, 535, 136,
	FONT_NEXT, 509, 94,
	FONT_NEXT, 477, 61,
	FONT_NEXT, 441, 39,
	FONT_NEXT, 402, 26,
	FONT_END, 361, 22,
	FONT_ADVANCE, 722, 0
    },
    {
	80,
	FONT_BEGIN, 59, 635,
	FONT_NEXT, 85, 622,
	FONT_NEXT, 97, 596,
	FONT_NEXT, 100, 553,
	FONT_NEXT, 100, 120,
	FONT_NEXT, 98, 74,
	FONT_NEXT, 89, 44,
	FONT_NEXT, 64, 27,
	FONT_NEXT, 16, 19,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 296, 0,
	FONT_NEXT, 296, 19,
	FONT_NEXT, 248, 23,
	FONT_NEXT, 220, 37,
	FONT_NEXT, 205, 64,
	FONT_NEXT, 202, 109,
	FONT_NEXT, 202, 291,
	FONT_NEXT, 269, 288,
	FONT_NEXT, 340, 291,
	FONT_NEXT, 398, 302,
	FONT_NEXT, 444, 320,
	FONT_NEXT, 481, 347,
	FONT_NEXT, 497, 363,
	FONT_NEXT, 517, 391,
	FONT_NEXT, 534, 430,
	FONT_NEXT, 542, 482,
	FONT_NEXT, 536, 526,
	FONT_NEXT, 520, 563,
	FONT_NEXT, 495, 594,
	FONT_NEXT, 462, 619,
	FONT_NEXT, 379, 651,
	FONT_NEXT, 280, 662,
	FONT_NEXT, 16, 662,
	FONT_END, 16, 643,
	FONT_BEGIN, 204, 610,
	FONT_NEXT, 211, 620,
	FONT_NEXT, 243, 625,
	FONT_NEXT, 291, 622,
	FONT_NEXT, 354, 606,
	FONT_NEXT, 384, 588,
	FONT_NEXT, 409, 562,
	FONT_NEXT, 426, 527,
	FONT_NEXT, 433, 480,
	FONT_NEXT, 427, 429,
	FONT_NEXT, 411, 392,
	FONT_NEXT, 388, 365,
	FONT_NEXT, 361, 347,
	FONT_NEXT, 304, 330,
	FONT_NEXT, 262, 328,
	FONT_NEXT, 202, 331,
	FONT_END, 202, 591,
	FONT_ADVANCE, 556, 0
    },
    {
	81,
	FONT_BEGIN, 638, -153,
	FONT_NEXT, 586, -138,
	FONT_NEXT, 505, -90,
	FONT_NEXT, 426, -7,
	FONT_NEXT, 468, 2,
	FONT_NEXT, 512, 20,
	FONT_NEXT, 556, 47,
	FONT_NEXT, 597, 83,
	FONT_NEXT, 633, 130,
	FONT_NEXT, 662, 186,
	FONT_NEXT, 681, 252,
	FONT_NEXT, 688, 330,
	FONT_NEXT, 680, 410,
	FONT_NEXT, 659, 481,
	FONT_NEXT, 627, 540,
	FONT_NEXT, 586, 589,
	FONT_NEXT, 536, 627,
	FONT_NEXT, 481, 654,
	FONT_NEXT, 422, 670,
	FONT_NEXT, 361, 676,
	FONT_NEXT, 299, 670,
	FONT_NEXT, 240, 654,
	FONT_NEXT, 185, 626,
	FONT_NEXT, 136, 588,
	FONT_NEXT, 94, 540,
	FONT_NEXT, 62, 480,
	FONT_NEXT, 41, 410,
	FONT_NEXT, 34, 330,
	FONT_NEXT, 40, 255,
	FONT_NEXT, 57, 191,
	FONT_NEXT, 82, 138,
	FONT_NEXT, 114, 94,
	FONT_NEXT, 151, 58,
	FONT_NEXT, 189, 31,
	FONT_NEXT, 265, -1,
	FONT_NEXT, 312, -56,
	FONT_NEXT, 379, -113,
	FONT_NEXT, 462, -151,
	FONT_NEXT, 555, -172,
	FONT_NEXT, 654, -178,
	FONT_NEXT, 701, -177,
	FONT_END, 701, -159,
	FONT_BEGIN, 399, 636,
	FONT_NEXT, 437, 623,
	FONT_NEXT, 473, 602,
	FONT_NEXT, 505, 570,
	FONT_NEXT, 533, 528,
	FONT_NEXT, 555, 475,
	FONT_NEXT, 569, 409,
	FONT_NEXT, 574, 330,
	FONT_NEXT, 569, 253,
	FONT_NEXT, 556, 189,
	FONT_NEXT, 535, 136,
	FONT_NEXT, 509, 93,
	FONT_NEXT, 477, 61,
	FONT_NEXT, 441, 39,
	FONT_NEXT, 402, 26,
	FONT_NEXT, 361, 22,
	FONT_NEXT, 319, 26,
	FONT_NEXT, 280, 39,
	FONT_NEXT, 244, 61,
	FONT_NEXT, 212, 93,
	FONT_NEXT, 186, 136,
	FONT_NEXT, 165, 189,
	FONT_NEXT, 152, 253,
	FONT_NEXT, 148, 330,
	FONT_NEXT, 152, 409,
	FONT_NEXT, 166, 475,
	FONT_NEXT, 188, 528,
	FONT_NEXT, 216, 570,
	FONT_NEXT, 248, 602,
	FONT_NEXT, 284, 623,
	FONT_NEXT, 322, 636,
	FONT_END, 361, 640,
	FONT_ADVANCE, 722, 0
    },
    {
	82,
	FONT_BEGIN, 608, 33,
	FONT_NEXT, 572, 66,
	FONT_NEXT, 366, 319,
	FONT_NEXT, 415, 330,
	FONT_NEXT, 475, 356,
	FONT_NEXT, 503, 377,
	FONT_NEXT, 525, 405,
	FONT_NEXT, 541, 441,
	FONT_NEXT, 547, 487,
	FONT_NEXT, 539, 538,
	FONT_NEXT, 519, 579,
	FONT_NEXT, 490, 610,
	FONT_NEXT, 453, 632,
	FONT_NEXT, 370, 656,
	FONT_NEXT, 293, 662,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 17, 643,
	FONT_NEXT, 59, 636,
	FONT_NEXT, 85, 623,
	FONT_NEXT, 98, 597,
	FONT_NEXT, 102, 553,
	FONT_NEXT, 102, 120,
	FONT_NEXT, 100, 73,
	FONT_NEXT, 89, 43,
	FONT_NEXT, 64, 26,
	FONT_NEXT, 17, 19,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 294, 0,
	FONT_NEXT, 294, 19,
	FONT_NEXT, 246, 25,
	FONT_NEXT, 219, 40,
	FONT_NEXT, 206, 67,
	FONT_NEXT, 204, 109,
	FONT_NEXT, 204, 306,
	FONT_NEXT, 260, 308,
	FONT_NEXT, 498, 0,
	FONT_NEXT, 659, 0,
	FONT_END, 659, 19,
	FONT_BEGIN, 206, 606,
	FONT_NEXT, 215, 617,
	FONT_NEXT, 233, 623,
	FONT_NEXT, 266, 625,
	FONT_NEXT, 310, 622,
	FONT_NEXT, 367, 606,
	FONT_NEXT, 394, 590,
	FONT_NEXT, 416, 566,
	FONT_NEXT, 432, 533,
	FONT_NEXT, 438, 489,
	FONT_NEXT, 431, 441,
	FONT_NEXT, 413, 406,
	FONT_NEXT, 386, 380,
	FONT_NEXT, 352, 362,
	FONT_NEXT, 276, 346,
	FONT_NEXT, 204, 343,
	FONT_END, 204, 589,
	FONT_ADVANCE, 667, 0
    },
    {
	83,
	FONT_BEGIN, 426, 676,
	FONT_NEXT, 418, 654,
	FONT_NEXT, 408, 645,
	FONT_NEXT, 391, 642,
	FONT_NEXT, 367, 647,
	FONT_NEXT, 334, 659,
	FONT_NEXT, 252, 676,
	FONT_NEXT, 185, 665,
	FONT_NEXT, 127, 633,
	FONT_NEXT, 86, 580,
	FONT_NEXT, 75, 546,
	FONT_NEXT, 71, 506,
	FONT_NEXT, 82, 441,
	FONT_NEXT, 114, 390,
	FONT_NEXT, 163, 349,
	FONT_NEXT, 227, 310,
	FONT_NEXT, 276, 280,
	FONT_NEXT, 314, 254,
	FONT_NEXT, 343, 231,
	FONT_NEXT, 363, 210,
	FONT_NEXT, 385, 172,
	FONT_NEXT, 390, 133,
	FONT_NEXT, 382, 92,
	FONT_NEXT, 360, 57,
	FONT_NEXT, 322, 31,
	FONT_NEXT, 270, 22,
	FONT_NEXT, 223, 27,
	FONT_NEXT, 183, 43,
	FONT_NEXT, 124, 92,
	FONT_NEXT, 86, 151,
	FONT_NEXT, 65, 199,
	FONT_NEXT, 42, 199,
	FONT_NEXT, 72, -13,
	FONT_NEXT, 94, -13,
	FONT_NEXT, 101, 9,
	FONT_NEXT, 125, 20,
	FONT_NEXT, 151, 14,
	FONT_NEXT, 185, 3,
	FONT_NEXT, 227, -9,
	FONT_NEXT, 280, -14,
	FONT_NEXT, 330, -10,
	FONT_NEXT, 373, 2,
	FONT_NEXT, 409, 20,
	FONT_NEXT, 439, 44,
	FONT_NEXT, 478, 102,
	FONT_NEXT, 491, 167,
	FONT_NEXT, 476, 235,
	FONT_NEXT, 438, 290,
	FONT_NEXT, 385, 336,
	FONT_NEXT, 324, 375,
	FONT_NEXT, 209, 448,
	FONT_NEXT, 171, 491,
	FONT_NEXT, 157, 542,
	FONT_NEXT, 165, 582,
	FONT_NEXT, 188, 611,
	FONT_NEXT, 221, 629,
	FONT_NEXT, 258, 635,
	FONT_NEXT, 295, 630,
	FONT_NEXT, 328, 619,
	FONT_NEXT, 384, 579,
	FONT_NEXT, 422, 524,
	FONT_NEXT, 444, 463,
	FONT_NEXT, 469, 463,
	FONT_END, 447, 676,
	FONT_ADVANCE, 556, 0
    },
    {
	84,
	FONT_BEGIN, 401, 24,
	FONT_NEXT, 372, 39,
	FONT_NEXT, 359, 66,
	FONT_NEXT, 356, 109,
	FONT_NEXT, 356, 620,
	FONT_NEXT, 410, 620,
	FONT_NEXT, 478, 615,
	FONT_NEXT, 522, 597,
	FONT_NEXT, 550, 558,
	FONT_NEXT, 569, 492,
	FONT_NEXT, 593, 492,
	FONT_NEXT, 587, 662,
	FONT_NEXT, 23, 662,
	FONT_NEXT, 17, 492,
	FONT_NEXT, 41, 492,
	FONT_NEXT, 59, 557,
	FONT_NEXT, 87, 596,
	FONT_NEXT, 131, 615,
	FONT_NEXT, 200, 620,
	FONT_NEXT, 254, 620,
	FONT_NEXT, 254, 120,
	FONT_NEXT, 252, 73,
	FONT_NEXT, 241, 43,
	FONT_NEXT, 213, 26,
	FONT_NEXT, 160, 19,
	FONT_NEXT, 160, 0,
	FONT_NEXT, 452, 0,
	FONT_END, 452, 19,
	FONT_ADVANCE, 611, 0
    },
    {
	85,
	FONT_BEGIN, 473, 662,
	FONT_NEXT, 473, 643,
	FONT_NEXT, 517, 636,
	FONT_NEXT, 546, 617,
	FONT_NEXT, 562, 579,
	FONT_NEXT, 567, 515,
	FONT_NEXT, 567, 245,
	FONT_NEXT, 565, 192,
	FONT_NEXT, 560, 154,
	FONT_NEXT, 544, 109,
	FONT_NEXT, 517, 76,
	FONT_NEXT, 480, 51,
	FONT_NEXT, 434, 35,
	FONT_NEXT, 380, 30,
	FONT_NEXT, 322, 36,
	FONT_NEXT, 279, 52,
	FONT_NEXT, 248, 77,
	FONT_NEXT, 227, 107,
	FONT_NEXT, 208, 174,
	FONT_NEXT, 206, 233,
	FONT_NEXT, 206, 553,
	FONT_NEXT, 209, 596,
	FONT_NEXT, 221, 622,
	FONT_NEXT, 249, 636,
	FONT_NEXT, 297, 643,
	FONT_NEXT, 297, 662,
	FONT_NEXT, 14, 662,
	FONT_NEXT, 14, 643,
	FONT_NEXT, 60, 637,
	FONT_NEXT, 87, 623,
	FONT_NEXT, 100, 597,
	FONT_NEXT, 104, 553,
	FONT_NEXT, 104, 241,
	FONT_NEXT, 104, 212,
	FONT_NEXT, 107, 175,
	FONT_NEXT, 117, 133,
	FONT_NEXT, 135, 91,
	FONT_NEXT, 164, 50,
	FONT_NEXT, 208, 17,
	FONT_NEXT, 270, -6,
	FONT_NEXT, 352, -14,
	FONT_NEXT, 437, -6,
	FONT_NEXT, 501, 16,
	FONT_NEXT, 547, 49,
	FONT_NEXT, 578, 90,
	FONT_NEXT, 597, 134,
	FONT_NEXT, 606, 178,
	FONT_NEXT, 611, 254,
	FONT_NEXT, 611, 515,
	FONT_NEXT, 614, 578,
	FONT_NEXT, 629, 615,
	FONT_NEXT, 657, 634,
	FONT_NEXT, 705, 643,
	FONT_END, 705, 662,
	FONT_ADVANCE, 722, 0
    },
    {
	86,
	FONT_BEGIN, 492, 662,
	FONT_NEXT, 492, 643,
	FONT_NEXT, 542, 634,
	FONT_NEXT, 558, 621,
	FONT_NEXT, 565, 597,
	FONT_NEXT, 556, 556,
	FONT_NEXT, 549, 538,
	FONT_NEXT, 546, 528,
	FONT_NEXT, 399, 161,
	FONT_NEXT, 248, 499,
	FONT_NEXT, 218, 566,
	FONT_NEXT, 210, 590,
	FONT_NEXT, 207, 606,
	FONT_NEXT, 210, 624,
	FONT_NEXT, 223, 635,
	FONT_NEXT, 246, 640,
	FONT_NEXT, 282, 643,
	FONT_NEXT, 282, 662,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 16, 643,
	FONT_NEXT, 46, 638,
	FONT_NEXT, 71, 623,
	FONT_NEXT, 94, 592,
	FONT_NEXT, 122, 538,
	FONT_NEXT, 368, -11,
	FONT_NEXT, 383, -11,
	FONT_NEXT, 605, 550,
	FONT_NEXT, 625, 596,
	FONT_NEXT, 644, 623,
	FONT_NEXT, 666, 637,
	FONT_NEXT, 697, 643,
	FONT_END, 697, 662,
	FONT_ADVANCE, 722, 0
    },
    {
	87,
	FONT_BEGIN, 734, 662,
	FONT_NEXT, 734, 643,
	FONT_NEXT, 781, 633,
	FONT_NEXT, 797, 620,
	FONT_NEXT, 803, 597,
	FONT_NEXT, 787, 525,
	FONT_NEXT, 662, 186,
	FONT_NEXT, 530, 527,
	FONT_NEXT, 510, 574,
	FONT_NEXT, 503, 605,
	FONT_NEXT, 510, 626,
	FONT_NEXT, 529, 637,
	FONT_NEXT, 580, 643,
	FONT_NEXT, 580, 662,
	FONT_NEXT, 313, 662,
	FONT_NEXT, 313, 643,
	FONT_NEXT, 346, 640,
	FONT_NEXT, 371, 628,
	FONT_NEXT, 391, 601,
	FONT_NEXT, 414, 553,
	FONT_NEXT, 447, 471,
	FONT_NEXT, 340, 189,
	FONT_NEXT, 196, 565,
	FONT_NEXT, 185, 609,
	FONT_NEXT, 188, 625,
	FONT_NEXT, 200, 635,
	FONT_NEXT, 220, 640,
	FONT_NEXT, 250, 643,
	FONT_NEXT, 250, 662,
	FONT_NEXT, 5, 662,
	FONT_NEXT, 5, 643,
	FONT_NEXT, 40, 634,
	FONT_NEXT, 65, 613,
	FONT_NEXT, 86, 578,
	FONT_NEXT, 108, 526,
	FONT_NEXT, 125, 480,
	FONT_NEXT, 147, 421,
	FONT_NEXT, 199, 277,
	FONT_NEXT, 254, 123,
	FONT_NEXT, 279, 51,
	FONT_NEXT, 301, -11,
	FONT_NEXT, 316, -11,
	FONT_NEXT, 470, 412,
	FONT_NEXT, 630, -11,
	FONT_NEXT, 645, -11,
	FONT_NEXT, 745, 288,
	FONT_NEXT, 853, 582,
	FONT_NEXT, 864, 606,
	FONT_NEXT, 879, 624,
	FONT_NEXT, 900, 635,
	FONT_NEXT, 932, 643,
	FONT_END, 932, 662,
	FONT_ADVANCE, 944, 0
    },
    {
	88,
	FONT_BEGIN, 458, 662,
	FONT_NEXT, 458, 643,
	FONT_NEXT, 505, 637,
	FONT_NEXT, 521, 628,
	FONT_NEXT, 528, 610,
	FONT_NEXT, 516, 579,
	FONT_NEXT, 488, 542,
	FONT_NEXT, 375, 404,
	FONT_NEXT, 333, 463,
	FONT_NEXT, 291, 523,
	FONT_NEXT, 265, 565,
	FONT_NEXT, 251, 592,
	FONT_NEXT, 248, 611,
	FONT_NEXT, 252, 628,
	FONT_NEXT, 266, 637,
	FONT_NEXT, 290, 641,
	FONT_NEXT, 324, 643,
	FONT_NEXT, 324, 662,
	FONT_NEXT, 22, 662,
	FONT_NEXT, 22, 643,
	FONT_NEXT, 60, 637,
	FONT_NEXT, 96, 618,
	FONT_NEXT, 116, 600,
	FONT_NEXT, 139, 573,
	FONT_NEXT, 168, 535,
	FONT_NEXT, 203, 486,
	FONT_NEXT, 312, 326,
	FONT_NEXT, 155, 133,
	FONT_NEXT, 128, 100,
	FONT_NEXT, 106, 74,
	FONT_NEXT, 73, 41,
	FONT_NEXT, 44, 24,
	FONT_NEXT, 10, 19,
	FONT_NEXT, 10, 0,
	FONT_NEXT, 243, 0,
	FONT_NEXT, 243, 19,
	FONT_NEXT, 190, 26,
	FONT_NEXT, 173, 37,
	FONT_NEXT, 167, 56,
	FONT_NEXT, 172, 73,
	FONT_NEXT, 185, 95,
	FONT_NEXT, 219, 140,
	FONT_NEXT, 338, 288,
	FONT_NEXT, 433, 148,
	FONT_NEXT, 464, 98,
	FONT_NEXT, 478, 72,
	FONT_NEXT, 484, 53,
	FONT_NEXT, 479, 35,
	FONT_NEXT, 464, 25,
	FONT_NEXT, 440, 21,
	FONT_NEXT, 407, 19,
	FONT_NEXT, 407, 0,
	FONT_NEXT, 704, 0,
	FONT_NEXT, 704, 19,
	FONT_NEXT, 670, 24,
	FONT_NEXT, 643, 37,
	FONT_NEXT, 619, 58,
	FONT_NEXT, 593, 93,
	FONT_NEXT, 401, 367,
	FONT_NEXT, 547, 549,
	FONT_NEXT, 592, 599,
	FONT_NEXT, 627, 627,
	FONT_NEXT, 660, 638,
	FONT_NEXT, 696, 643,
	FONT_END, 696, 662,
	FONT_ADVANCE, 722, 0
    },
    {
	89,
	FONT_BEGIN, 484, 662,
	FONT_NEXT, 484, 643,
	FONT_NEXT, 530, 638,
	FONT_NEXT, 546, 628,
	FONT_NEXT, 553, 610,
	FONT_NEXT, 539, 573,
	FONT_NEXT, 396, 347,
	FONT_NEXT, 248, 569,
	FONT_NEXT, 231, 612,
	FONT_NEXT, 235, 628,
	FONT_NEXT, 249, 637,
	FONT_NEXT, 271, 641,
	FONT_NEXT, 302, 643,
	FONT_NEXT, 302, 662,
	FONT_NEXT, 22, 662,
	FONT_NEXT, 22, 643,
	FONT_NEXT, 51, 637,
	FONT_NEXT, 81, 619,
	FONT_NEXT, 99, 600,
	FONT_NEXT, 121, 573,
	FONT_NEXT, 149, 535,
	FONT_NEXT, 184, 486,
	FONT_NEXT, 315, 294,
	FONT_NEXT, 315, 120,
	FONT_NEXT, 313, 72,
	FONT_NEXT, 301, 41,
	FONT_NEXT, 271, 24,
	FONT_NEXT, 246, 20,
	FONT_NEXT, 214, 19,
	FONT_NEXT, 214, 0,
	FONT_NEXT, 520, 0,
	FONT_NEXT, 520, 19,
	FONT_NEXT, 465, 23,
	FONT_NEXT, 434, 37,
	FONT_NEXT, 420, 64,
	FONT_NEXT, 417, 109,
	FONT_NEXT, 417, 303,
	FONT_NEXT, 565, 529,
	FONT_NEXT, 589, 564,
	FONT_NEXT, 610, 590,
	FONT_NEXT, 646, 624,
	FONT_NEXT, 675, 638,
	FONT_NEXT, 703, 643,
	FONT_END, 703, 662,
	FONT_ADVANCE, 722, 0
    },
    {
	90,
	FONT_BEGIN, 556, 123,
	FONT_NEXT, 528, 79,
	FONT_NEXT, 481, 49,
	FONT_NEXT, 446, 40,
	FONT_NEXT, 402, 38,
	FONT_NEXT, 145, 38,
	FONT_NEXT, 577, 647,
	FONT_NEXT, 577, 662,
	FONT_NEXT, 51, 662,
	FONT_NEXT, 31, 491,
	FONT_NEXT, 57, 491,
	FONT_NEXT, 68, 540,
	FONT_NEXT, 92, 582,
	FONT_NEXT, 112, 599,
	FONT_NEXT, 140, 612,
	FONT_NEXT, 177, 621,
	FONT_NEXT, 225, 624,
	FONT_NEXT, 446, 624,
	FONT_NEXT, 9, 15,
	FONT_NEXT, 9, 0,
	FONT_NEXT, 573, 0,
	FONT_NEXT, 597, 176,
	FONT_END, 574, 176,
	FONT_ADVANCE, 611, 0
    },
    {
	91,
	FONT_BEGIN, 299, 662,
	FONT_NEXT, 88, 662,
	FONT_NEXT, 88, -156,
	FONT_NEXT, 299, -156,
	FONT_NEXT, 299, -131,
	FONT_NEXT, 213, -131,
	FONT_NEXT, 184, -125,
	FONT_NEXT, 170, -110,
	FONT_NEXT, 164, -79,
	FONT_NEXT, 164, 593,
	FONT_NEXT, 169, 620,
	FONT_NEXT, 182, 632,
	FONT_NEXT, 209, 637,
	FONT_END, 299, 637,
	FONT_ADVANCE, 333, 0
    },
    {
	92,
	FONT_BEGIN, 219, -14,
	FONT_NEXT, 287, -14,
	FONT_NEXT, 58, 676,
	FONT_END, -9, 676,
	FONT_ADVANCE, 278, 0
    },
    {
	93,
	FONT_BEGIN, 34, -156,
	FONT_NEXT, 245, -156,
	FONT_NEXT, 245, 662,
	FONT_NEXT, 34, 662,
	FONT_NEXT, 34, 637,
	FONT_NEXT, 120, 637,
	FONT_NEXT, 148, 630,
	FONT_NEXT, 162, 615,
	FONT_NEXT, 169, 585,
	FONT_NEXT, 169, -87,
	FONT_NEXT, 163, -115,
	FONT_NEXT, 150, -127,
	FONT_NEXT, 124, -131,
	FONT_END, 34, -131,
	FONT_ADVANCE, 333, 0
    },
    {
	94,
	FONT_BEGIN, 235, 586,
	FONT_NEXT, 378, 297,
	FONT_NEXT, 446, 297,
	FONT_NEXT, 265, 662,
	FONT_NEXT, 205, 662,
	FONT_NEXT, 24, 297,
	FONT_END, 92, 297,
	FONT_ADVANCE, 469, 0
    },
    {
	95,
	FONT_BEGIN, 500, -75,
	FONT_NEXT, 0, -75,
	FONT_NEXT, 0, -125,
	FONT_END, 500, -125,
	FONT_ADVANCE, 500, 0
    },
    {
	96,
	FONT_BEGIN, 196, 658,
	FONT_NEXT, 159, 625,
	FONT_NEXT, 128, 580,
	FONT_NEXT, 115, 529,
	FONT_NEXT, 124, 478,
	FONT_NEXT, 146, 449,
	FONT_NEXT, 173, 436,
	FONT_NEXT, 196, 433,
	FONT_NEXT, 234, 445,
	FONT_NEXT, 248, 463,
	FONT_NEXT, 254, 491,
	FONT_NEXT, 247, 515,
	FONT_NEXT, 232, 531,
	FONT_NEXT, 192, 541,
	FONT_NEXT, 177, 539,
	FONT_NEXT, 168, 537,
	FONT_NEXT, 158, 540,
	FONT_NEXT, 154, 551,
	FONT_NEXT, 157, 569,
	FONT_NEXT, 170, 595,
	FONT_NEXT, 195, 625,
	FONT_NEXT, 236, 657,
	FONT_END, 227, 676,
	FONT_ADVANCE, 333, 0
    },
    {
	97,
	FONT_BEGIN, 281, 88,
	FONT_NEXT, 271, 77,
	FONT_NEXT, 253, 66,
	FONT_NEXT, 226, 55,
	FONT_NEXT, 191, 48,
	FONT_NEXT, 165, 53,
	FONT_NEXT, 144, 69,
	FONT_NEXT, 130, 93,
	FONT_NEXT, 125, 126,
	FONT_NEXT, 125, 128,
	FONT_NEXT, 129, 157,
	FONT_NEXT, 149, 192,
	FONT_NEXT, 169, 210,
	FONT_NEXT, 197, 229,
	FONT_NEXT, 236, 249,
	FONT_NEXT, 287, 268,
	FONT_END, 287, 123,
	FONT_BEGIN, 423, 53,
	FONT_NEXT, 397, 47,
	FONT_NEXT, 380, 51,
	FONT_NEXT, 371, 65,
	FONT_NEXT, 368, 105,
	FONT_NEXT, 368, 300,
	FONT_NEXT, 365, 350,
	FONT_NEXT, 349, 402,
	FONT_NEXT, 331, 425,
	FONT_NEXT, 305, 443,
	FONT_NEXT, 268, 455,
	FONT_NEXT, 219, 460,
	FONT_NEXT, 178, 456,
	FONT_NEXT, 144, 448,
	FONT_NEXT, 94, 419,
	FONT_NEXT, 65, 383,
	FONT_NEXT, 56, 349,
	FONT_NEXT, 65, 321,
	FONT_NEXT, 79, 309,
	FONT_NEXT, 99, 305,
	FONT_NEXT, 131, 318,
	FONT_NEXT, 144, 348,
	FONT_NEXT, 139, 387,
	FONT_NEXT, 145, 407,
	FONT_NEXT, 162, 423,
	FONT_NEXT, 210, 436,
	FONT_NEXT, 234, 433,
	FONT_NEXT, 259, 421,
	FONT_NEXT, 279, 396,
	FONT_NEXT, 287, 353,
	FONT_NEXT, 287, 292,
	FONT_NEXT, 179, 248,
	FONT_NEXT, 100, 206,
	FONT_NEXT, 73, 183,
	FONT_NEXT, 53, 158,
	FONT_NEXT, 41, 128,
	FONT_NEXT, 37, 94,
	FONT_NEXT, 45, 49,
	FONT_NEXT, 69, 16,
	FONT_NEXT, 103, -4,
	FONT_NEXT, 143, -10,
	FONT_NEXT, 183, -4,
	FONT_NEXT, 222, 14,
	FONT_NEXT, 288, 63,
	FONT_NEXT, 297, 21,
	FONT_NEXT, 315, -1,
	FONT_NEXT, 353, -10,
	FONT_NEXT, 387, -4,
	FONT_NEXT, 412, 11,
	FONT_NEXT, 442, 40,
	FONT_END, 442, 66,
	FONT_ADVANCE, 444, 0
    },
    {
	98,
	FONT_BEGIN, 165, 357,
	FONT_NEXT, 192, 380,
	FONT_NEXT, 224, 393,
	FONT_NEXT, 253, 397,
	FONT_NEXT, 284, 392,
	FONT_NEXT, 311, 379,
	FONT_NEXT, 350, 333,
	FONT_NEXT, 372, 270,
	FONT_NEXT, 380, 201,
	FONT_NEXT, 375, 145,
	FONT_NEXT, 357, 86,
	FONT_NEXT, 340, 61,
	FONT_NEXT, 317, 40,
	FONT_NEXT, 287, 26,
	FONT_NEXT, 249, 22,
	FONT_NEXT, 223, 24,
	FONT_NEXT, 191, 32,
	FONT_NEXT, 164, 47,
	FONT_NEXT, 153, 70,
	FONT_END, 153, 322,
	FONT_BEGIN, 73, 40,
	FONT_NEXT, 86, 28,
	FONT_NEXT, 127, 8,
	FONT_NEXT, 178, -6,
	FONT_NEXT, 224, -10,
	FONT_NEXT, 287, -4,
	FONT_NEXT, 340, 16,
	FONT_NEXT, 382, 44,
	FONT_NEXT, 415, 80,
	FONT_NEXT, 439, 119,
	FONT_NEXT, 455, 161,
	FONT_NEXT, 468, 238,
	FONT_NEXT, 457, 317,
	FONT_NEXT, 424, 389,
	FONT_NEXT, 399, 417,
	FONT_NEXT, 368, 440,
	FONT_NEXT, 332, 454,
	FONT_NEXT, 290, 460,
	FONT_NEXT, 237, 450,
	FONT_NEXT, 196, 428,
	FONT_NEXT, 167, 401,
	FONT_NEXT, 155, 379,
	FONT_NEXT, 153, 379,
	FONT_NEXT, 153, 681,
	FONT_NEXT, 148, 683,
	FONT_NEXT, 3, 639,
	FONT_NEXT, 3, 623,
	FONT_NEXT, 25, 624,
	FONT_NEXT, 50, 620,
	FONT_NEXT, 63, 609,
	FONT_NEXT, 69, 573,
	FONT_END, 69, 54,
	FONT_ADVANCE, 500, 0
    },
    {
	99,
	FONT_BEGIN, 340, 89,
	FONT_NEXT, 302, 69,
	FONT_NEXT, 255, 62,
	FONT_NEXT, 195, 75,
	FONT_NEXT, 147, 114,
	FONT_NEXT, 114, 174,
	FONT_NEXT, 102, 253,
	FONT_NEXT, 106, 302,
	FONT_NEXT, 116, 342,
	FONT_NEXT, 133, 373,
	FONT_NEXT, 152, 397,
	FONT_NEXT, 195, 423,
	FONT_NEXT, 231, 431,
	FONT_NEXT, 262, 427,
	FONT_NEXT, 280, 418,
	FONT_NEXT, 297, 383,
	FONT_NEXT, 303, 361,
	FONT_NEXT, 320, 329,
	FONT_NEXT, 334, 318,
	FONT_NEXT, 352, 315,
	FONT_NEXT, 386, 329,
	FONT_NEXT, 398, 359,
	FONT_NEXT, 387, 392,
	FONT_NEXT, 355, 429,
	FONT_NEXT, 306, 450,
	FONT_NEXT, 249, 460,
	FONT_NEXT, 168, 444,
	FONT_NEXT, 130, 425,
	FONT_NEXT, 96, 398,
	FONT_NEXT, 67, 363,
	FONT_NEXT, 44, 320,
	FONT_NEXT, 30, 270,
	FONT_NEXT, 25, 213,
	FONT_NEXT, 29, 158,
	FONT_NEXT, 42, 111,
	FONT_NEXT, 63, 73,
	FONT_NEXT, 88, 42,
	FONT_NEXT, 149, 2,
	FONT_NEXT, 212, -10,
	FONT_NEXT, 269, -2,
	FONT_NEXT, 322, 25,
	FONT_NEXT, 369, 74,
	FONT_NEXT, 412, 147,
	FONT_END, 398, 156,
	FONT_ADVANCE, 444, 0
    },
    {
	100,
	FONT_BEGIN, 328, 77,
	FONT_NEXT, 308, 58,
	FONT_NEXT, 281, 46,
	FONT_NEXT, 251, 42,
	FONT_NEXT, 201, 53,
	FONT_NEXT, 157, 88,
	FONT_NEXT, 139, 116,
	FONT_NEXT, 125, 152,
	FONT_NEXT, 116, 195,
	FONT_NEXT, 113, 247,
	FONT_NEXT, 116, 293,
	FONT_NEXT, 124, 333,
	FONT_NEXT, 154, 390,
	FONT_NEXT, 194, 422,
	FONT_NEXT, 237, 432,
	FONT_NEXT, 271, 425,
	FONT_NEXT, 303, 407,
	FONT_NEXT, 327, 376,
	FONT_NEXT, 340, 332,
	FONT_END, 340, 102,
	FONT_BEGIN, 452, 58,
	FONT_NEXT, 432, 68,
	FONT_NEXT, 425, 87,
	FONT_NEXT, 424, 114,
	FONT_NEXT, 424, 681,
	FONT_NEXT, 419, 683,
	FONT_NEXT, 272, 639,
	FONT_NEXT, 272, 623,
	FONT_NEXT, 296, 624,
	FONT_NEXT, 321, 620,
	FONT_NEXT, 334, 609,
	FONT_NEXT, 340, 573,
	FONT_NEXT, 340, 417,
	FONT_NEXT, 290, 449,
	FONT_NEXT, 234, 460,
	FONT_NEXT, 192, 454,
	FONT_NEXT, 154, 439,
	FONT_NEXT, 119, 416,
	FONT_NEXT, 88, 386,
	FONT_NEXT, 43, 307,
	FONT_NEXT, 31, 262,
	FONT_NEXT, 27, 214,
	FONT_NEXT, 33, 145,
	FONT_NEXT, 49, 92,
	FONT_NEXT, 74, 53,
	FONT_NEXT, 103, 25,
	FONT_NEXT, 164, -4,
	FONT_NEXT, 209, -10,
	FONT_NEXT, 257, -4,
	FONT_NEXT, 294, 11,
	FONT_NEXT, 320, 32,
	FONT_NEXT, 338, 54,
	FONT_NEXT, 340, 54,
	FONT_NEXT, 340, -7,
	FONT_NEXT, 344, -10,
	FONT_NEXT, 491, 42,
	FONT_END, 491, 58,
	FONT_ADVANCE, 500, 0
    },
    {
	101,
	FONT_BEGIN, 386, 131,
	FONT_NEXT, 355, 97,
	FONT_NEXT, 311, 70,
	FONT_NEXT, 253, 59,
	FONT_NEXT, 202, 68,
	FONT_NEXT, 153, 101,
	FONT_NEXT, 132, 130,
	FONT_NEXT, 114, 168,
	FONT_NEXT, 101, 216,
	FONT_NEXT, 94, 277,
	FONT_NEXT, 405, 277,
	FONT_NEXT, 398, 322,
	FONT_NEXT, 386, 360,
	FONT_NEXT, 348, 417,
	FONT_NEXT, 294, 449,
	FONT_NEXT, 229, 460,
	FONT_NEXT, 163, 447,
	FONT_NEXT, 129, 430,
	FONT_NEXT, 97, 406,
	FONT_NEXT, 68, 373,
	FONT_NEXT, 45, 330,
	FONT_NEXT, 30, 277,
	FONT_NEXT, 25, 214,
	FONT_NEXT, 28, 163,
	FONT_NEXT, 38, 119,
	FONT_NEXT, 54, 80,
	FONT_NEXT, 76, 48,
	FONT_NEXT, 104, 23,
	FONT_NEXT, 135, 5,
	FONT_NEXT, 172, -7,
	FONT_NEXT, 212, -10,
	FONT_NEXT, 262, -5,
	FONT_NEXT, 304, 11,
	FONT_NEXT, 368, 61,
	FONT_NEXT, 406, 117,
	FONT_NEXT, 417, 140,
	FONT_NEXT, 424, 157,
	FONT_END, 408, 164,
	FONT_BEGIN, 113, 364,
	FONT_NEXT, 137, 399,
	FONT_NEXT, 168, 418,
	FONT_NEXT, 207, 424,
	FONT_NEXT, 254, 412,
	FONT_NEXT, 282, 384,
	FONT_NEXT, 303, 309,
	FONT_END, 97, 309,
	FONT_ADVANCE, 444, 0
    },
    {
	102,
	FONT_BEGIN, 186, 450,
	FONT_NEXT, 186, 566,
	FONT_NEXT, 195, 624,
	FONT_NEXT, 213, 646,
	FONT_NEXT, 246, 655,
	FONT_NEXT, 340, 580,
	FONT_NEXT, 369, 590,
	FONT_NEXT, 379, 603,
	FONT_NEXT, 383, 622,
	FONT_NEXT, 375, 645,
	FONT_NEXT, 354, 665,
	FONT_NEXT, 322, 678,
	FONT_NEXT, 283, 683,
	FONT_NEXT, 223, 675,
	FONT_NEXT, 178, 654,
	FONT_NEXT, 146, 624,
	FONT_NEXT, 125, 587,
	FONT_NEXT, 105, 510,
	FONT_NEXT, 103, 476,
	FONT_NEXT, 103, 450,
	FONT_NEXT, 21, 450,
	FONT_NEXT, 21, 418,
	FONT_NEXT, 103, 418,
	FONT_NEXT, 103, 104,
	FONT_NEXT, 99, 58,
	FONT_NEXT, 86, 31,
	FONT_NEXT, 60, 19,
	FONT_NEXT, 20, 15,
	FONT_NEXT, 20, 0,
	FONT_NEXT, 280, 0,
	FONT_NEXT, 280, 15,
	FONT_NEXT, 226, 21,
	FONT_NEXT, 199, 37,
	FONT_NEXT, 188, 64,
	FONT_NEXT, 187, 104,
	FONT_NEXT, 187, 418,
	FONT_NEXT, 309, 418,
	FONT_END, 309, 450,
	FONT_ADVANCE, 333, 0
    },
    {
	103,
	FONT_BEGIN, 110, -49,
	FONT_NEXT, 147, -2,
	FONT_NEXT, 210, -12,
	FONT_NEXT, 251, -14,
	FONT_NEXT, 310, -15,
	FONT_NEXT, 360, -18,
	FONT_NEXT, 399, -24,
	FONT_NEXT, 424, -38,
	FONT_NEXT, 433, -64,
	FONT_NEXT, 420, -102,
	FONT_NEXT, 384, -133,
	FONT_NEXT, 326, -154,
	FONT_NEXT, 248, -161,
	FONT_NEXT, 176, -155,
	FONT_NEXT, 130, -138,
	FONT_NEXT, 105, -115,
	FONT_END, 98, -90,
	FONT_BEGIN, 158, 384,
	FONT_NEXT, 176, 412,
	FONT_NEXT, 200, 427,
	FONT_NEXT, 227, 432,
	FONT_NEXT, 256, 426,
	FONT_NEXT, 279, 410,
	FONT_NEXT, 310, 361,
	FONT_NEXT, 325, 307,
	FONT_NEXT, 329, 270,
	FONT_NEXT, 327, 245,
	FONT_NEXT, 318, 213,
	FONT_NEXT, 296, 185,
	FONT_NEXT, 256, 174,
	FONT_NEXT, 229, 177,
	FONT_NEXT, 206, 189,
	FONT_NEXT, 174, 228,
	FONT_NEXT, 157, 282,
	FONT_END, 152, 342,
	FONT_BEGIN, 470, 427,
	FONT_NEXT, 393, 427,
	FONT_NEXT, 338, 437,
	FONT_NEXT, 287, 454,
	FONT_NEXT, 241, 460,
	FONT_NEXT, 182, 450,
	FONT_NEXT, 126, 421,
	FONT_NEXT, 85, 369,
	FONT_NEXT, 73, 334,
	FONT_NEXT, 69, 293,
	FONT_NEXT, 75, 251,
	FONT_NEXT, 93, 216,
	FONT_NEXT, 122, 186,
	FONT_NEXT, 162, 163,
	FONT_NEXT, 132, 136,
	FONT_NEXT, 110, 115,
	FONT_NEXT, 84, 85,
	FONT_NEXT, 74, 67,
	FONT_NEXT, 73, 54,
	FONT_NEXT, 77, 35,
	FONT_NEXT, 89, 21,
	FONT_NEXT, 126, 1,
	FONT_NEXT, 57, -57,
	FONT_NEXT, 36, -89,
	FONT_NEXT, 28, -121,
	FONT_NEXT, 41, -159,
	FONT_NEXT, 78, -190,
	FONT_NEXT, 134, -211,
	FONT_NEXT, 205, -218,
	FONT_NEXT, 282, -208,
	FONT_NEXT, 366, -176,
	FONT_NEXT, 403, -153,
	FONT_NEXT, 433, -124,
	FONT_NEXT, 453, -89,
	FONT_NEXT, 461, -49,
	FONT_NEXT, 457, -22,
	FONT_NEXT, 440, 13,
	FONT_NEXT, 404, 43,
	FONT_NEXT, 375, 53,
	FONT_NEXT, 340, 58,
	FONT_NEXT, 211, 64,
	FONT_NEXT, 160, 69,
	FONT_NEXT, 140, 77,
	FONT_NEXT, 133, 91,
	FONT_NEXT, 139, 109,
	FONT_NEXT, 155, 129,
	FONT_NEXT, 175, 146,
	FONT_NEXT, 193, 154,
	FONT_NEXT, 247, 149,
	FONT_NEXT, 295, 156,
	FONT_NEXT, 347, 182,
	FONT_NEXT, 389, 227,
	FONT_NEXT, 401, 258,
	FONT_NEXT, 406, 296,
	FONT_NEXT, 404, 328,
	FONT_NEXT, 400, 352,
	FONT_NEXT, 387, 388,
	FONT_END, 470, 388,
	FONT_ADVANCE, 500, 0
    },
    {
	104,
	FONT_BEGIN, 456, 22,
	FONT_NEXT, 438, 34,
	FONT_NEXT, 429, 58,
	FONT_NEXT, 427, 102,
	FONT_NEXT, 427, 301,
	FONT_NEXT, 424, 342,
	FONT_NEXT, 411, 395,
	FONT_NEXT, 396, 420,
	FONT_NEXT, 374, 440,
	FONT_NEXT, 343, 454,
	FONT_NEXT, 303, 460,
	FONT_NEXT, 260, 454,
	FONT_NEXT, 221, 437,
	FONT_NEXT, 187, 411,
	FONT_NEXT, 159, 378,
	FONT_NEXT, 157, 378,
	FONT_NEXT, 157, 680,
	FONT_NEXT, 152, 683,
	FONT_NEXT, 10, 639,
	FONT_NEXT, 10, 623,
	FONT_NEXT, 29, 624,
	FONT_NEXT, 54, 620,
	FONT_NEXT, 67, 609,
	FONT_NEXT, 73, 573,
	FONT_NEXT, 73, 102,
	FONT_NEXT, 70, 58,
	FONT_NEXT, 61, 33,
	FONT_NEXT, 41, 21,
	FONT_NEXT, 9, 15,
	FONT_NEXT, 9, 0,
	FONT_NEXT, 225, 0,
	FONT_NEXT, 225, 15,
	FONT_NEXT, 193, 19,
	FONT_NEXT, 172, 31,
	FONT_NEXT, 160, 56,
	FONT_NEXT, 157, 102,
	FONT_NEXT, 157, 343,
	FONT_NEXT, 187, 373,
	FONT_NEXT, 216, 392,
	FONT_NEXT, 266, 406,
	FONT_NEXT, 301, 398,
	FONT_NEXT, 325, 378,
	FONT_NEXT, 338, 344,
	FONT_NEXT, 343, 300,
	FONT_NEXT, 343, 102,
	FONT_NEXT, 339, 56,
	FONT_NEXT, 327, 31,
	FONT_NEXT, 306, 19,
	FONT_NEXT, 275, 15,
	FONT_NEXT, 275, 0,
	FONT_NEXT, 487, 0,
	FONT_END, 487, 15,
	FONT_ADVANCE, 500, 0
    },
    {
	105,
	FONT_BEGIN, 253, 0,
	FONT_NEXT, 253, 15,
	FONT_NEXT, 212, 21,
	FONT_NEXT, 190, 35,
	FONT_NEXT, 180, 61,
	FONT_NEXT, 179, 102,
	FONT_NEXT, 179, 457,
	FONT_NEXT, 175, 460,
	FONT_NEXT, 20, 405,
	FONT_NEXT, 20, 390,
	FONT_NEXT, 60, 394,
	FONT_NEXT, 83, 386,
	FONT_NEXT, 91, 368,
	FONT_NEXT, 95, 334,
	FONT_NEXT, 95, 102,
	FONT_NEXT, 91, 55,
	FONT_NEXT, 78, 30,
	FONT_NEXT, 54, 18,
	FONT_NEXT, 16, 15,
	FONT_END, 16, 0,
	FONT_BEGIN, 89, 599,
	FONT_NEXT, 105, 586,
	FONT_NEXT, 128, 581,
	FONT_NEXT, 148, 584,
	FONT_NEXT, 165, 595,
	FONT_NEXT, 176, 611,
	FONT_NEXT, 180, 632,
	FONT_NEXT, 165, 668,
	FONT_NEXT, 148, 678,
	FONT_NEXT, 128, 683,
	FONT_NEXT, 105, 677,
	FONT_NEXT, 89, 664,
	FONT_END, 78, 632,
	FONT_ADVANCE, 278, 0
    },
    {
	106,
	FONT_BEGIN, 108, -102,
	FONT_NEXT, 102, -146,
	FONT_NEXT, 87, -174,
	FONT_NEXT, 59, -184,
	FONT_NEXT, -30, -124,
	FONT_NEXT, -58, -135,
	FONT_NEXT, -70, -162,
	FONT_NEXT, -63, -187,
	FONT_NEXT, -42, -204,
	FONT_NEXT, -12, -215,
	FONT_NEXT, 23, -218,
	FONT_NEXT, 67, -214,
	FONT_NEXT, 103, -201,
	FONT_NEXT, 133, -180,
	FONT_NEXT, 156, -153,
	FONT_NEXT, 184, -84,
	FONT_NEXT, 193, 0,
	FONT_NEXT, 193, 457,
	FONT_NEXT, 188, 460,
	FONT_NEXT, 32, 406,
	FONT_NEXT, 32, 390,
	FONT_NEXT, 74, 394,
	FONT_NEXT, 97, 386,
	FONT_NEXT, 105, 368,
	FONT_NEXT, 109, 334,
	FONT_END, 109, -45,
	FONT_BEGIN, 103, 599,
	FONT_NEXT, 119, 586,
	FONT_NEXT, 142, 581,
	FONT_NEXT, 162, 584,
	FONT_NEXT, 179, 595,
	FONT_NEXT, 190, 611,
	FONT_NEXT, 194, 632,
	FONT_NEXT, 179, 668,
	FONT_NEXT, 162, 678,
	FONT_NEXT, 142, 683,
	FONT_NEXT, 119, 677,
	FONT_NEXT, 103, 664,
	FONT_END, 92, 632,
	FONT_ADVANCE, 278, 0
    },
    {
	107,
	FONT_BEGIN, 241, 0,
	FONT_NEXT, 241, 15,
	FONT_NEXT, 221, 16,
	FONT_NEXT, 181, 26,
	FONT_NEXT, 169, 42,
	FONT_NEXT, 166, 67,
	FONT_NEXT, 166, 248,
	FONT_NEXT, 168, 248,
	FONT_NEXT, 306, 64,
	FONT_NEXT, 321, 43,
	FONT_NEXT, 327, 31,
	FONT_NEXT, 319, 18,
	FONT_NEXT, 306, 15,
	FONT_NEXT, 287, 15,
	FONT_NEXT, 287, 0,
	FONT_NEXT, 505, 0,
	FONT_NEXT, 505, 15,
	FONT_NEXT, 482, 18,
	FONT_NEXT, 455, 28,
	FONT_NEXT, 424, 49,
	FONT_NEXT, 388, 88,
	FONT_NEXT, 235, 282,
	FONT_NEXT, 264, 309,
	FONT_NEXT, 309, 350,
	FONT_NEXT, 347, 381,
	FONT_NEXT, 377, 404,
	FONT_NEXT, 402, 419,
	FONT_NEXT, 442, 433,
	FONT_NEXT, 480, 435,
	FONT_NEXT, 480, 450,
	FONT_NEXT, 276, 450,
	FONT_NEXT, 276, 436,
	FONT_NEXT, 301, 434,
	FONT_NEXT, 316, 430,
	FONT_NEXT, 326, 417,
	FONT_NEXT, 320, 401,
	FONT_NEXT, 303, 383,
	FONT_NEXT, 168, 263,
	FONT_NEXT, 166, 265,
	FONT_NEXT, 166, 681,
	FONT_NEXT, 162, 683,
	FONT_NEXT, 7, 639,
	FONT_NEXT, 7, 623,
	FONT_NEXT, 37, 625,
	FONT_NEXT, 60, 621,
	FONT_NEXT, 74, 611,
	FONT_NEXT, 80, 592,
	FONT_NEXT, 82, 564,
	FONT_NEXT, 82, 82,
	FONT_NEXT, 79, 50,
	FONT_NEXT, 69, 32,
	FONT_NEXT, 46, 22,
	FONT_NEXT, 7, 15,
	FONT_END, 7, 0,
	FONT_ADVANCE, 500, 0
    },
    {
	108,
	FONT_BEGIN, 257, 0,
	FONT_NEXT, 257, 15,
	FONT_NEXT, 220, 18,
	FONT_NEXT, 197, 28,
	FONT_NEXT, 185, 49,
	FONT_NEXT, 182, 84,
	FONT_NEXT, 182, 681,
	FONT_NEXT, 178, 683,
	FONT_NEXT, 19, 639,
	FONT_NEXT, 19, 623,
	FONT_NEXT, 53, 625,
	FONT_NEXT, 76, 621,
	FONT_NEXT, 90, 611,
	FONT_NEXT, 96, 592,
	FONT_NEXT, 98, 564,
	FONT_NEXT, 98, 87,
	FONT_NEXT, 94, 53,
	FONT_NEXT, 81, 31,
	FONT_NEXT, 57, 20,
	FONT_NEXT, 21, 15,
	FONT_END, 21, 0,
	FONT_ADVANCE, 278, 0
    },
    {
	109,
	FONT_BEGIN, 80, 45,
	FONT_NEXT, 66, 25,
	FONT_NEXT, 43, 16,
	FONT_NEXT, 16, 15,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 238, 0,
	FONT_NEXT, 238, 15,
	FONT_NEXT, 190, 23,
	FONT_NEXT, 175, 38,
	FONT_NEXT, 170, 67,
	FONT_NEXT, 170, 349,
	FONT_NEXT, 178, 360,
	FONT_NEXT, 201, 380,
	FONT_NEXT, 237, 399,
	FONT_NEXT, 285, 408,
	FONT_NEXT, 317, 400,
	FONT_NEXT, 339, 380,
	FONT_NEXT, 350, 347,
	FONT_NEXT, 354, 303,
	FONT_NEXT, 354, 86,
	FONT_NEXT, 349, 47,
	FONT_NEXT, 336, 27,
	FONT_NEXT, 315, 18,
	FONT_NEXT, 286, 15,
	FONT_NEXT, 286, 0,
	FONT_NEXT, 510, 0,
	FONT_NEXT, 510, 15,
	FONT_NEXT, 481, 17,
	FONT_NEXT, 458, 26,
	FONT_NEXT, 443, 50,
	FONT_NEXT, 438, 95,
	FONT_NEXT, 438, 347,
	FONT_NEXT, 481, 390,
	FONT_NEXT, 511, 403,
	FONT_NEXT, 549, 408,
	FONT_NEXT, 590, 397,
	FONT_NEXT, 612, 372,
	FONT_NEXT, 622, 298,
	FONT_NEXT, 622, 87,
	FONT_NEXT, 618, 49,
	FONT_NEXT, 607, 29,
	FONT_NEXT, 587, 19,
	FONT_NEXT, 556, 15,
	FONT_NEXT, 556, 0,
	FONT_NEXT, 775, 0,
	FONT_NEXT, 775, 15,
	FONT_NEXT, 749, 17,
	FONT_NEXT, 723, 26,
	FONT_NEXT, 711, 40,
	FONT_NEXT, 706, 76,
	FONT_NEXT, 706, 282,
	FONT_NEXT, 702, 341,
	FONT_NEXT, 686, 398,
	FONT_NEXT, 650, 442,
	FONT_NEXT, 622, 455,
	FONT_NEXT, 588, 460,
	FONT_NEXT, 532, 450,
	FONT_NEXT, 485, 427,
	FONT_NEXT, 449, 399,
	FONT_NEXT, 427, 376,
	FONT_NEXT, 414, 406,
	FONT_NEXT, 393, 433,
	FONT_NEXT, 362, 452,
	FONT_NEXT, 320, 460,
	FONT_NEXT, 281, 454,
	FONT_NEXT, 244, 438,
	FONT_NEXT, 166, 383,
	FONT_NEXT, 166, 458,
	FONT_NEXT, 159, 460,
	FONT_NEXT, 19, 415,
	FONT_NEXT, 19, 398,
	FONT_NEXT, 51, 402,
	FONT_NEXT, 74, 393,
	FONT_NEXT, 82, 374,
	FONT_NEXT, 86, 338,
	FONT_END, 86, 85,
	FONT_ADVANCE, 778, 0
    },
    {
	110,
	FONT_BEGIN, 76, 53,
	FONT_NEXT, 66, 31,
	FONT_NEXT, 47, 19,
	FONT_NEXT, 18, 15,
	FONT_NEXT, 18, 0,
	FONT_NEXT, 230, 0,
	FONT_NEXT, 230, 15,
	FONT_NEXT, 197, 19,
	FONT_NEXT, 177, 29,
	FONT_NEXT, 167, 45,
	FONT_NEXT, 164, 67,
	FONT_NEXT, 164, 348,
	FONT_NEXT, 216, 390,
	FONT_NEXT, 263, 405,
	FONT_NEXT, 299, 398,
	FONT_NEXT, 323, 379,
	FONT_NEXT, 336, 348,
	FONT_NEXT, 340, 308,
	FONT_NEXT, 340, 99,
	FONT_NEXT, 335, 54,
	FONT_NEXT, 322, 29,
	FONT_NEXT, 302, 18,
	FONT_NEXT, 277, 15,
	FONT_NEXT, 277, 0,
	FONT_NEXT, 485, 0,
	FONT_NEXT, 485, 15,
	FONT_NEXT, 454, 20,
	FONT_NEXT, 436, 31,
	FONT_NEXT, 426, 51,
	FONT_NEXT, 424, 81,
	FONT_NEXT, 424, 310,
	FONT_NEXT, 420, 351,
	FONT_NEXT, 412, 385,
	FONT_NEXT, 382, 431,
	FONT_NEXT, 344, 453,
	FONT_NEXT, 307, 460,
	FONT_NEXT, 266, 453,
	FONT_NEXT, 230, 436,
	FONT_NEXT, 161, 379,
	FONT_NEXT, 161, 458,
	FONT_NEXT, 154, 460,
	FONT_NEXT, 16, 415,
	FONT_NEXT, 16, 398,
	FONT_NEXT, 45, 402,
	FONT_NEXT, 68, 393,
	FONT_NEXT, 76, 374,
	FONT_NEXT, 80, 338,
	FONT_END, 80, 90,
	FONT_ADVANCE, 500, 0
    },
    {
	111,
	FONT_BEGIN, 197, 455,
	FONT_NEXT, 154, 441,
	FONT_NEXT, 117, 419,
	FONT_NEXT, 86, 390,
	FONT_NEXT, 62, 355,
	FONT_NEXT, 43, 316,
	FONT_NEXT, 29, 228,
	FONT_NEXT, 33, 179,
	FONT_NEXT, 45, 133,
	FONT_NEXT, 64, 93,
	FONT_NEXT, 90, 58,
	FONT_NEXT, 122, 29,
	FONT_NEXT, 159, 8,
	FONT_NEXT, 201, -6,
	FONT_NEXT, 248, -10,
	FONT_NEXT, 301, -4,
	FONT_NEXT, 346, 13,
	FONT_NEXT, 385, 39,
	FONT_NEXT, 416, 71,
	FONT_NEXT, 456, 149,
	FONT_NEXT, 470, 228,
	FONT_NEXT, 465, 279,
	FONT_NEXT, 453, 325,
	FONT_NEXT, 433, 365,
	FONT_NEXT, 406, 398,
	FONT_NEXT, 373, 424,
	FONT_NEXT, 335, 444,
	FONT_NEXT, 292, 455,
	FONT_END, 245, 460,
	FONT_BEGIN, 221, 26,
	FONT_NEXT, 189, 47,
	FONT_NEXT, 164, 80,
	FONT_NEXT, 145, 119,
	FONT_NEXT, 124, 204,
	FONT_NEXT, 119, 276,
	FONT_NEXT, 128, 344,
	FONT_NEXT, 154, 393,
	FONT_NEXT, 191, 422,
	FONT_NEXT, 237, 432,
	FONT_NEXT, 269, 427,
	FONT_NEXT, 298, 413,
	FONT_NEXT, 322, 390,
	FONT_NEXT, 343, 362,
	FONT_NEXT, 370, 287,
	FONT_NEXT, 380, 199,
	FONT_NEXT, 377, 150,
	FONT_NEXT, 368, 110,
	FONT_NEXT, 356, 78,
	FONT_NEXT, 340, 54,
	FONT_NEXT, 301, 26,
	FONT_END, 262, 18,
	FONT_ADVANCE, 500, 0
    },
    {
	112,
	FONT_BEGIN, 73, -160,
	FONT_NEXT, 64, -180,
	FONT_NEXT, 43, -194,
	FONT_NEXT, 5, -200,
	FONT_NEXT, 5, -217,
	FONT_NEXT, 247, -217,
	FONT_NEXT, 247, -199,
	FONT_NEXT, 202, -197,
	FONT_NEXT, 176, -186,
	FONT_NEXT, 162, -163,
	FONT_NEXT, 159, -124,
	FONT_NEXT, 159, 33,
	FONT_NEXT, 206, -1,
	FONT_NEXT, 260, -10,
	FONT_NEXT, 308, -4,
	FONT_NEXT, 351, 13,
	FONT_NEXT, 387, 40,
	FONT_NEXT, 417, 74,
	FONT_NEXT, 456, 156,
	FONT_NEXT, 470, 245,
	FONT_NEXT, 466, 292,
	FONT_NEXT, 456, 334,
	FONT_NEXT, 420, 402,
	FONT_NEXT, 368, 445,
	FONT_NEXT, 305, 460,
	FONT_NEXT, 252, 451,
	FONT_NEXT, 212, 432,
	FONT_NEXT, 181, 406,
	FONT_NEXT, 161, 383,
	FONT_NEXT, 159, 385,
	FONT_NEXT, 159, 458,
	FONT_NEXT, 153, 460,
	FONT_NEXT, 9, 409,
	FONT_NEXT, 9, 393,
	FONT_NEXT, 37, 394,
	FONT_NEXT, 57, 390,
	FONT_NEXT, 69, 380,
	FONT_NEXT, 73, 362,
	FONT_NEXT, 75, 337,
	FONT_END, 75, -131,
	FONT_BEGIN, 171, 360,
	FONT_NEXT, 196, 381,
	FONT_NEXT, 227, 395,
	FONT_NEXT, 257, 400,
	FONT_NEXT, 297, 392,
	FONT_NEXT, 328, 374,
	FONT_NEXT, 350, 347,
	FONT_NEXT, 366, 316,
	FONT_NEXT, 381, 253,
	FONT_NEXT, 383, 229,
	FONT_NEXT, 384, 215,
	FONT_NEXT, 380, 156,
	FONT_NEXT, 369, 111,
	FONT_NEXT, 353, 77,
	FONT_NEXT, 334, 53,
	FONT_NEXT, 294, 27,
	FONT_NEXT, 261, 22,
	FONT_NEXT, 221, 29,
	FONT_NEXT, 189, 46,
	FONT_NEXT, 167, 67,
	FONT_NEXT, 159, 88,
	FONT_END, 159, 334,
	FONT_ADVANCE, 500, 0
    },
    {
	113,
	FONT_BEGIN, 308, 450,
	FONT_NEXT, 247, 460,
	FONT_NEXT, 201, 455,
	FONT_NEXT, 159, 440,
	FONT_NEXT, 121, 417,
	FONT_NEXT, 88, 387,
	FONT_NEXT, 61, 351,
	FONT_NEXT, 41, 308,
	FONT_NEXT, 28, 262,
	FONT_NEXT, 24, 212,
	FONT_NEXT, 27, 159,
	FONT_NEXT, 37, 113,
	FONT_NEXT, 52, 75,
	FONT_NEXT, 72, 44,
	FONT_NEXT, 124, 3,
	FONT_NEXT, 188, -10,
	FONT_NEXT, 234, -3,
	FONT_NEXT, 278, 14,
	FONT_NEXT, 314, 38,
	FONT_NEXT, 336, 62,
	FONT_NEXT, 341, 62,
	FONT_NEXT, 341, -124,
	FONT_NEXT, 337, -157,
	FONT_NEXT, 324, -180,
	FONT_NEXT, 297, -194,
	FONT_NEXT, 252, -200,
	FONT_NEXT, 252, -217,
	FONT_NEXT, 488, -217,
	FONT_NEXT, 488, -203,
	FONT_NEXT, 459, -196,
	FONT_NEXT, 439, -187,
	FONT_NEXT, 428, -170,
	FONT_NEXT, 425, -141,
	FONT_NEXT, 425, 456,
	FONT_NEXT, 421, 460,
	FONT_NEXT, 414, 457,
	FONT_END, 360, 425,
	FONT_BEGIN, 333, 88,
	FONT_NEXT, 318, 73,
	FONT_NEXT, 288, 60,
	FONT_NEXT, 238, 51,
	FONT_NEXT, 206, 55,
	FONT_NEXT, 180, 67,
	FONT_NEXT, 140, 110,
	FONT_NEXT, 117, 169,
	FONT_NEXT, 110, 238,
	FONT_NEXT, 119, 319,
	FONT_NEXT, 147, 380,
	FONT_NEXT, 189, 418,
	FONT_NEXT, 245, 432,
	FONT_NEXT, 276, 428,
	FONT_NEXT, 300, 420,
	FONT_NEXT, 328, 393,
	FONT_NEXT, 339, 360,
	FONT_NEXT, 341, 333,
	FONT_END, 341, 127,
	FONT_ADVANCE, 500, 0
    },
    {
	114,
	FONT_BEGIN, 72, 51,
	FONT_NEXT, 61, 32,
	FONT_NEXT, 39, 22,
	FONT_NEXT, 5, 15,
	FONT_NEXT, 5, 0,
	FONT_NEXT, 245, 0,
	FONT_NEXT, 245, 15,
	FONT_NEXT, 210, 17,
	FONT_NEXT, 183, 27,
	FONT_NEXT, 166, 49,
	FONT_NEXT, 160, 90,
	FONT_NEXT, 160, 315,
	FONT_NEXT, 167, 341,
	FONT_NEXT, 185, 368,
	FONT_NEXT, 207, 388,
	FONT_NEXT, 228, 397,
	FONT_NEXT, 258, 379,
	FONT_NEXT, 274, 367,
	FONT_NEXT, 297, 362,
	FONT_NEXT, 325, 374,
	FONT_NEXT, 335, 406,
	FONT_NEXT, 331, 428,
	FONT_NEXT, 320, 445,
	FONT_NEXT, 303, 456,
	FONT_NEXT, 281, 460,
	FONT_NEXT, 252, 455,
	FONT_NEXT, 224, 441,
	FONT_NEXT, 195, 413,
	FONT_NEXT, 162, 369,
	FONT_NEXT, 160, 369,
	FONT_NEXT, 160, 458,
	FONT_NEXT, 155, 460,
	FONT_NEXT, 7, 406,
	FONT_NEXT, 7, 390,
	FONT_NEXT, 41, 394,
	FONT_NEXT, 64, 386,
	FONT_NEXT, 72, 368,
	FONT_NEXT, 76, 334,
	FONT_END, 76, 84,
	FONT_ADVANCE, 333, 0
    },
    {
	115,
	FONT_BEGIN, 311, 451,
	FONT_NEXT, 300, 451,
	FONT_NEXT, 283, 440,
	FONT_NEXT, 247, 450,
	FONT_NEXT, 191, 460,
	FONT_NEXT, 128, 448,
	FONT_NEXT, 84, 420,
	FONT_NEXT, 59, 380,
	FONT_NEXT, 51, 338,
	FONT_NEXT, 60, 288,
	FONT_NEXT, 86, 250,
	FONT_NEXT, 123, 219,
	FONT_NEXT, 168, 192,
	FONT_NEXT, 226, 159,
	FONT_NEXT, 264, 127,
	FONT_NEXT, 278, 85,
	FONT_NEXT, 270, 49,
	FONT_NEXT, 250, 27,
	FONT_NEXT, 224, 15,
	FONT_NEXT, 197, 12,
	FONT_NEXT, 163, 15,
	FONT_NEXT, 137, 26,
	FONT_NEXT, 100, 62,
	FONT_NEXT, 79, 107,
	FONT_NEXT, 68, 152,
	FONT_NEXT, 52, 152,
	FONT_NEXT, 52, -4,
	FONT_NEXT, 65, -4,
	FONT_NEXT, 73, 5,
	FONT_NEXT, 87, 8,
	FONT_NEXT, 138, -1,
	FONT_NEXT, 203, -10,
	FONT_NEXT, 252, -3,
	FONT_NEXT, 299, 21,
	FONT_NEXT, 334, 62,
	FONT_NEXT, 348, 119,
	FONT_NEXT, 341, 158,
	FONT_NEXT, 324, 189,
	FONT_NEXT, 264, 237,
	FONT_NEXT, 156, 301,
	FONT_NEXT, 133, 318,
	FONT_NEXT, 120, 337,
	FONT_NEXT, 113, 372,
	FONT_NEXT, 117, 393,
	FONT_NEXT, 130, 414,
	FONT_NEXT, 153, 430,
	FONT_NEXT, 189, 437,
	FONT_NEXT, 221, 432,
	FONT_NEXT, 252, 413,
	FONT_NEXT, 279, 376,
	FONT_NEXT, 300, 314,
	FONT_END, 315, 314,
	FONT_ADVANCE, 389, 0
    },
    {
	116,
	FONT_BEGIN, 154, 450,
	FONT_NEXT, 154, 566,
	FONT_NEXT, 147, 579,
	FONT_NEXT, 122, 544,
	FONT_NEXT, 102, 516,
	FONT_NEXT, 57, 465,
	FONT_NEXT, 26, 441,
	FONT_NEXT, 13, 425,
	FONT_NEXT, 17, 418,
	FONT_NEXT, 70, 418,
	FONT_NEXT, 70, 117,
	FONT_NEXT, 77, 54,
	FONT_NEXT, 96, 16,
	FONT_NEXT, 126, -5,
	FONT_NEXT, 162, -10,
	FONT_NEXT, 196, -5,
	FONT_NEXT, 228, 11,
	FONT_NEXT, 257, 35,
	FONT_NEXT, 279, 66,
	FONT_NEXT, 266, 77,
	FONT_NEXT, 243, 54,
	FONT_NEXT, 205, 42,
	FONT_NEXT, 175, 51,
	FONT_NEXT, 160, 75,
	FONT_NEXT, 154, 132,
	FONT_NEXT, 154, 418,
	FONT_NEXT, 255, 418,
	FONT_END, 255, 450,
	FONT_ADVANCE, 278, 0
    },
    {
	117,
	FONT_BEGIN, 444, 53,
	FONT_NEXT, 425, 64,
	FONT_NEXT, 418, 82,
	FONT_NEXT, 417, 107,
	FONT_NEXT, 417, 450,
	FONT_NEXT, 259, 450,
	FONT_NEXT, 259, 433,
	FONT_NEXT, 300, 427,
	FONT_NEXT, 322, 415,
	FONT_NEXT, 331, 396,
	FONT_NEXT, 333, 370,
	FONT_NEXT, 333, 135,
	FONT_NEXT, 328, 100,
	FONT_NEXT, 317, 84,
	FONT_NEXT, 274, 57,
	FONT_NEXT, 230, 48,
	FONT_NEXT, 190, 57,
	FONT_NEXT, 167, 80,
	FONT_NEXT, 157, 106,
	FONT_NEXT, 155, 124,
	FONT_NEXT, 155, 450,
	FONT_NEXT, 9, 450,
	FONT_NEXT, 9, 436,
	FONT_NEXT, 51, 425,
	FONT_NEXT, 65, 407,
	FONT_NEXT, 71, 372,
	FONT_NEXT, 71, 120,
	FONT_NEXT, 74, 83,
	FONT_NEXT, 83, 54,
	FONT_NEXT, 115, 15,
	FONT_NEXT, 154, -5,
	FONT_NEXT, 190, -10,
	FONT_NEXT, 208, -9,
	FONT_NEXT, 234, -4,
	FONT_NEXT, 264, 9,
	FONT_NEXT, 295, 33,
	FONT_NEXT, 338, 76,
	FONT_NEXT, 338, -7,
	FONT_NEXT, 340, -9,
	FONT_NEXT, 479, 36,
	FONT_END, 479, 50,
	FONT_ADVANCE, 500, 0
    },
    {
	118,
	FONT_BEGIN, 338, 450,
	FONT_NEXT, 338, 435,
	FONT_NEXT, 370, 426,
	FONT_NEXT, 385, 402,
	FONT_NEXT, 381, 383,
	FONT_NEXT, 373, 355,
	FONT_NEXT, 345, 280,
	FONT_NEXT, 280, 114,
	FONT_NEXT, 178, 370,
	FONT_NEXT, 169, 405,
	FONT_NEXT, 172, 419,
	FONT_NEXT, 183, 428,
	FONT_NEXT, 215, 435,
	FONT_NEXT, 215, 450,
	FONT_NEXT, 19, 450,
	FONT_NEXT, 19, 435,
	FONT_NEXT, 48, 427,
	FONT_NEXT, 74, 398,
	FONT_NEXT, 90, 364,
	FONT_NEXT, 110, 319,
	FONT_NEXT, 156, 212,
	FONT_NEXT, 200, 106,
	FONT_NEXT, 217, 63,
	FONT_NEXT, 230, 33,
	FONT_NEXT, 239, 7,
	FONT_NEXT, 246, -7,
	FONT_NEXT, 257, -14,
	FONT_NEXT, 269, 0,
	FONT_NEXT, 284, 36,
	FONT_NEXT, 412, 357,
	FONT_NEXT, 427, 393,
	FONT_NEXT, 440, 417,
	FONT_NEXT, 455, 429,
	FONT_NEXT, 477, 435,
	FONT_END, 477, 450,
	FONT_ADVANCE, 500, 0
    },
    {
	119,
	FONT_BEGIN, 571, 435,
	FONT_NEXT, 602, 425,
	FONT_NEXT, 611, 416,
	FONT_NEXT, 615, 402,
	FONT_NEXT, 610, 374,
	FONT_NEXT, 598, 338,
	FONT_NEXT, 508, 116,
	FONT_NEXT, 428, 330,
	FONT_NEXT, 411, 371,
	FONT_NEXT, 407, 398,
	FONT_NEXT, 411, 415,
	FONT_NEXT, 423, 425,
	FONT_NEXT, 465, 435,
	FONT_NEXT, 465, 450,
	FONT_NEXT, 262, 450,
	FONT_NEXT, 262, 435,
	FONT_NEXT, 288, 429,
	FONT_NEXT, 308, 413,
	FONT_NEXT, 327, 376,
	FONT_NEXT, 338, 347,
	FONT_NEXT, 351, 310,
	FONT_NEXT, 260, 111,
	FONT_NEXT, 224, 205,
	FONT_NEXT, 190, 290,
	FONT_NEXT, 164, 358,
	FONT_NEXT, 157, 383,
	FONT_NEXT, 155, 401,
	FONT_NEXT, 158, 417,
	FONT_NEXT, 169, 427,
	FONT_NEXT, 201, 435,
	FONT_NEXT, 201, 450,
	FONT_NEXT, 21, 450,
	FONT_NEXT, 21, 435,
	FONT_NEXT, 49, 420,
	FONT_NEXT, 60, 401,
	FONT_NEXT, 74, 372,
	FONT_NEXT, 209, 30,
	FONT_NEXT, 217, 8,
	FONT_NEXT, 224, -5,
	FONT_NEXT, 235, -14,
	FONT_NEXT, 244, -5,
	FONT_NEXT, 260, 25,
	FONT_NEXT, 372, 265,
	FONT_NEXT, 463, 29,
	FONT_NEXT, 471, 7,
	FONT_NEXT, 477, -6,
	FONT_NEXT, 487, -14,
	FONT_NEXT, 498, -5,
	FONT_NEXT, 505, 10,
	FONT_NEXT, 515, 35,
	FONT_NEXT, 653, 381,
	FONT_NEXT, 671, 419,
	FONT_NEXT, 694, 435,
	FONT_NEXT, 694, 450,
	FONT_END, 571, 450,
	FONT_ADVANCE, 722, 0
    },
    {
	120,
	FONT_BEGIN, 311, 60,
	FONT_NEXT, 318, 41,
	FONT_NEXT, 309, 20,
	FONT_NEXT, 278, 15,
	FONT_NEXT, 278, 0,
	FONT_NEXT, 479, 0,
	FONT_NEXT, 479, 15,
	FONT_NEXT, 445, 23,
	FONT_NEXT, 423, 41,
	FONT_NEXT, 397, 75,
	FONT_NEXT, 269, 271,
	FONT_NEXT, 352, 391,
	FONT_NEXT, 379, 417,
	FONT_NEXT, 403, 429,
	FONT_NEXT, 433, 435,
	FONT_NEXT, 433, 450,
	FONT_NEXT, 275, 450,
	FONT_NEXT, 275, 435,
	FONT_NEXT, 301, 431,
	FONT_NEXT, 311, 424,
	FONT_NEXT, 315, 412,
	FONT_NEXT, 313, 402,
	FONT_NEXT, 304, 386,
	FONT_NEXT, 284, 356,
	FONT_NEXT, 248, 304,
	FONT_NEXT, 210, 362,
	FONT_NEXT, 194, 391,
	FONT_NEXT, 188, 412,
	FONT_NEXT, 192, 424,
	FONT_NEXT, 202, 431,
	FONT_NEXT, 231, 435,
	FONT_NEXT, 231, 450,
	FONT_NEXT, 24, 450,
	FONT_NEXT, 24, 435,
	FONT_NEXT, 64, 428,
	FONT_NEXT, 83, 410,
	FONT_NEXT, 110, 375,
	FONT_NEXT, 204, 231,
	FONT_NEXT, 90, 66,
	FONT_NEXT, 68, 39,
	FONT_NEXT, 51, 24,
	FONT_NEXT, 17, 15,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 162, 0,
	FONT_NEXT, 162, 15,
	FONT_NEXT, 136, 17,
	FONT_NEXT, 122, 33,
	FONT_NEXT, 142, 74,
	FONT_NEXT, 221, 197,
	FONT_END, 302, 73,
	FONT_ADVANCE, 500, 0
    },
    {
	121,
	FONT_BEGIN, 340, 450,
	FONT_NEXT, 340, 435,
	FONT_NEXT, 376, 428,
	FONT_NEXT, 388, 407,
	FONT_NEXT, 380, 379,
	FONT_NEXT, 365, 339,
	FONT_NEXT, 287, 117,
	FONT_NEXT, 172, 370,
	FONT_NEXT, 162, 406,
	FONT_NEXT, 167, 421,
	FONT_NEXT, 182, 430,
	FONT_NEXT, 220, 435,
	FONT_NEXT, 220, 450,
	FONT_NEXT, 14, 450,
	FONT_NEXT, 14, 436,
	FONT_NEXT, 39, 428,
	FONT_NEXT, 65, 404,
	FONT_NEXT, 179, 158,
	FONT_NEXT, 194, 125,
	FONT_NEXT, 215, 83,
	FONT_NEXT, 233, 43,
	FONT_NEXT, 241, 20,
	FONT_NEXT, 239, 8,
	FONT_NEXT, 233, -11,
	FONT_NEXT, 214, -63,
	FONT_NEXT, 185, -113,
	FONT_NEXT, 167, -129,
	FONT_NEXT, 149, -134,
	FONT_NEXT, 118, -125,
	FONT_NEXT, 78, -116,
	FONT_NEXT, 51, -123,
	FONT_NEXT, 36, -136,
	FONT_NEXT, 30, -160,
	FONT_NEXT, 34, -181,
	FONT_NEXT, 47, -199,
	FONT_NEXT, 70, -213,
	FONT_NEXT, 103, -218,
	FONT_NEXT, 154, -206,
	FONT_NEXT, 197, -169,
	FONT_NEXT, 235, -106,
	FONT_NEXT, 273, -18,
	FONT_NEXT, 427, 390,
	FONT_NEXT, 439, 414,
	FONT_NEXT, 451, 427,
	FONT_NEXT, 475, 435,
	FONT_END, 475, 450,
	FONT_ADVANCE, 500, 0
    },
    {
	122,
	FONT_BEGIN, 400, 139,
	FONT_NEXT, 388, 89,
	FONT_NEXT, 369, 55,
	FONT_NEXT, 334, 36,
	FONT_NEXT, 307, 31,
	FONT_NEXT, 272, 30,
	FONT_NEXT, 134, 30,
	FONT_NEXT, 403, 435,
	FONT_NEXT, 403, 450,
	FONT_NEXT, 56, 450,
	FONT_NEXT, 53, 332,
	FONT_NEXT, 71, 332,
	FONT_NEXT, 76, 368,
	FONT_NEXT, 88, 396,
	FONT_NEXT, 112, 413,
	FONT_NEXT, 155, 420,
	FONT_NEXT, 293, 420,
	FONT_NEXT, 27, 15,
	FONT_NEXT, 27, 0,
	FONT_NEXT, 404, 0,
	FONT_END, 418, 135,
	FONT_ADVANCE, 444, 0
    },
    {
	123,
	FONT_BEGIN, 187, -82,
	FONT_NEXT, 196, -114,
	FONT_NEXT, 210, -139,
	FONT_NEXT, 228, -156,
	FONT_NEXT, 280, -176,
	FONT_NEXT, 350, -181,
	FONT_NEXT, 350, -170,
	FONT_NEXT, 305, -154,
	FONT_NEXT, 277, -129,
	FONT_NEXT, 263, -94,
	FONT_NEXT, 259, -47,
	FONT_NEXT, 259, 121,
	FONT_NEXT, 255, 168,
	FONT_NEXT, 242, 204,
	FONT_NEXT, 215, 230,
	FONT_NEXT, 168, 248,
	FONT_NEXT, 168, 250,
	FONT_NEXT, 215, 267,
	FONT_NEXT, 242, 294,
	FONT_NEXT, 255, 330,
	FONT_NEXT, 259, 378,
	FONT_NEXT, 259, 546,
	FONT_NEXT, 263, 592,
	FONT_NEXT, 277, 627,
	FONT_NEXT, 305, 652,
	FONT_NEXT, 350, 669,
	FONT_NEXT, 350, 680,
	FONT_NEXT, 280, 675,
	FONT_NEXT, 228, 655,
	FONT_NEXT, 210, 637,
	FONT_NEXT, 196, 612,
	FONT_NEXT, 187, 581,
	FONT_NEXT, 185, 541,
	FONT_NEXT, 185, 363,
	FONT_NEXT, 181, 320,
	FONT_NEXT, 168, 289,
	FONT_NEXT, 142, 266,
	FONT_NEXT, 100, 250,
	FONT_NEXT, 142, 233,
	FONT_NEXT, 168, 209,
	FONT_NEXT, 181, 178,
	FONT_NEXT, 185, 136,
	FONT_END, 185, -41,
	FONT_ADVANCE, 480, 0
    },
    {
	124,
	FONT_BEGIN, 133, -14,
	FONT_NEXT, 133, 676,
	FONT_NEXT, 67, 676,
	FONT_END, 67, -14,
	FONT_ADVANCE, 200, 0
    },
    {
	125,
	FONT_BEGIN, 292, 580,
	FONT_NEXT, 283, 612,
	FONT_NEXT, 269, 637,
	FONT_NEXT, 251, 655,
	FONT_NEXT, 199, 675,
	FONT_NEXT, 130, 680,
	FONT_NEXT, 130, 669,
	FONT_NEXT, 174, 652,
	FONT_NEXT, 202, 627,
	FONT_NEXT, 216, 592,
	FONT_NEXT, 221, 546,
	FONT_NEXT, 221, 378,
	FONT_NEXT, 224, 330,
	FONT_NEXT, 237, 294,
	FONT_NEXT, 264, 268,
	FONT_NEXT, 312, 251,
	FONT_NEXT, 312, 249,
	FONT_NEXT, 264, 231,
	FONT_NEXT, 237, 204,
	FONT_NEXT, 224, 168,
	FONT_NEXT, 221, 121,
	FONT_NEXT, 221, -47,
	FONT_NEXT, 216, -94,
	FONT_NEXT, 202, -129,
	FONT_NEXT, 174, -154,
	FONT_NEXT, 130, -170,
	FONT_NEXT, 130, -181,
	FONT_NEXT, 199, -177,
	FONT_NEXT, 251, -157,
	FONT_NEXT, 269, -139,
	FONT_NEXT, 283, -114,
	FONT_NEXT, 292, -83,
	FONT_NEXT, 295, -42,
	FONT_NEXT, 295, 136,
	FONT_NEXT, 298, 178,
	FONT_NEXT, 311, 209,
	FONT_NEXT, 337, 233,
	FONT_NEXT, 380, 250,
	FONT_NEXT, 337, 266,
	FONT_NEXT, 311, 289,
	FONT_NEXT, 298, 320,
	FONT_NEXT, 295, 363,
	FONT_END, 295, 540,
	FONT_ADVANCE, 480, 0
    },
    {
	126,
	FONT_BEGIN, 428, 273,
	FONT_NEXT, 405, 257,
	FONT_NEXT, 378, 251,
	FONT_NEXT, 330, 263,
	FONT_NEXT, 276, 287,
	FONT_NEXT, 219, 309,
	FONT_NEXT, 165, 319,
	FONT_NEXT, 120, 311,
	FONT_NEXT, 85, 291,
	FONT_NEXT, 40, 233,
	FONT_NEXT, 76, 183,
	FONT_NEXT, 107, 232,
	FONT_NEXT, 130, 248,
	FONT_NEXT, 160, 255,
	FONT_NEXT, 222, 244,
	FONT_NEXT, 275, 220,
	FONT_NEXT, 324, 196,
	FONT_NEXT, 377, 187,
	FONT_NEXT, 418, 194,
	FONT_NEXT, 451, 214,
	FONT_NEXT, 502, 273,
	FONT_END, 466, 323,
	FONT_ADVANCE, 541, 0
    },
    {
	END_OF_LIST
    }
};

GLint filledFont[][1+MAX_STROKES*3] = {
    {
	32,
	FONT_ADVANCE, 250, 0
    },
    {
	33,
	FONT_BEGIN, 236, 605,
	FONT_NEXT, 234, 559,
	FONT_NEXT, 229, 642,
	FONT_NEXT, 189, 176,
	FONT_NEXT, 211, 667,
	FONT_END, 182, 676,
	FONT_BEGIN, 182, 676,
	FONT_NEXT, 189, 176,
	FONT_END, 176, 176,
	FONT_BEGIN, 182, 676,
	FONT_NEXT, 176, 176,
	FONT_NEXT, 156, 668,
	FONT_NEXT, 167, 284,
	FONT_END, 163, 315,
	FONT_BEGIN, 156, 668,
	FONT_NEXT, 163, 315,
	FONT_END, 158, 355,
	FONT_BEGIN, 156, 668,
	FONT_NEXT, 158, 355,
	FONT_END, 146, 447,
	FONT_BEGIN, 156, 668,
	FONT_NEXT, 146, 447,
	FONT_NEXT, 140, 648,
	FONT_NEXT, 134, 534,
	FONT_NEXT, 130, 592,
	FONT_END, 131, 568,
	FONT_BEGIN, 238, 42,
	FONT_NEXT, 232, 18,
	FONT_NEXT, 233, 62,
	FONT_END, 222, 79,
	FONT_BEGIN, 222, 79,
	FONT_NEXT, 232, 18,
	FONT_END, 219, 3,
	FONT_BEGIN, 222, 79,
	FONT_NEXT, 219, 3,
	FONT_NEXT, 204, 91,
	FONT_NEXT, 183, -9,
	FONT_NEXT, 183, 96,
	FONT_END, 162, 91,
	FONT_BEGIN, 162, 91,
	FONT_NEXT, 183, -9,
	FONT_END, 148, 2,
	FONT_BEGIN, 162, 91,
	FONT_NEXT, 148, 2,
	FONT_NEXT, 145, 80,
	FONT_NEXT, 135, 18,
	FONT_NEXT, 134, 63,
	FONT_END, 130, 42,
	FONT_ADVANCE, 333, 0
    },
    {
	34,
	FONT_BEGIN, 162, 635,
	FONT_NEXT, 158, 599,
	FONT_NEXT, 148, 665,
	FONT_NEXT, 149, 543,
	FONT_END, 139, 482,
	FONT_BEGIN, 148, 665,
	FONT_NEXT, 139, 482,
	FONT_NEXT, 120, 676,
	FONT_NEXT, 130, 431,
	FONT_END, 109, 431,
	FONT_BEGIN, 120, 676,
	FONT_NEXT, 109, 431,
	FONT_NEXT, 91, 665,
	FONT_NEXT, 99, 482,
	FONT_END, 89, 543,
	FONT_BEGIN, 91, 665,
	FONT_NEXT, 89, 543,
	FONT_NEXT, 77, 635,
	FONT_END, 80, 599,
	FONT_BEGIN, 331, 635,
	FONT_NEXT, 327, 599,
	FONT_NEXT, 317, 665,
	FONT_NEXT, 318, 543,
	FONT_END, 308, 482,
	FONT_BEGIN, 317, 665,
	FONT_NEXT, 308, 482,
	FONT_NEXT, 289, 676,
	FONT_NEXT, 299, 431,
	FONT_END, 278, 431,
	FONT_BEGIN, 289, 676,
	FONT_NEXT, 278, 431,
	FONT_NEXT, 260, 665,
	FONT_NEXT, 268, 482,
	FONT_END, 258, 543,
	FONT_BEGIN, 260, 665,
	FONT_NEXT, 258, 543,
	FONT_NEXT, 246, 635,
	FONT_END, 249, 599,
	FONT_ADVANCE, 408, 0
    },
    {
	35,
	FONT_BEGIN, 32, 405,
	FONT_NEXT, 32, 460,
	FONT_NEXT, 142, 405,
	FONT_NEXT, 150, 460,
	FONT_END, 137, 0,
	FONT_BEGIN, 142, 405,
	FONT_NEXT, 137, 0,
	FONT_NEXT, 121, 271,
	FONT_NEXT, 79, 0,
	FONT_END, 112, 216,
	FONT_BEGIN, 121, 271,
	FONT_NEXT, 112, 216,
	FONT_NEXT, 5, 271,
	FONT_END, 5, 216,
	FONT_BEGIN, 239, 662,
	FONT_NEXT, 208, 460,
	FONT_NEXT, 181, 662,
	FONT_NEXT, 200, 405,
	FONT_END, 179, 271,
	FONT_BEGIN, 181, 662,
	FONT_NEXT, 179, 271,
	FONT_NEXT, 150, 460,
	FONT_NEXT, 170, 216,
	FONT_END, 137, 0,
	FONT_BEGIN, 170, 216,
	FONT_NEXT, 179, 271,
	FONT_NEXT, 304, 216,
	FONT_NEXT, 313, 271,
	FONT_NEXT, 273, 0,
	FONT_END, 331, 0,
	FONT_BEGIN, 331, 0,
	FONT_NEXT, 313, 271,
	FONT_END, 333, 405,
	FONT_BEGIN, 331, 0,
	FONT_NEXT, 333, 405,
	FONT_NEXT, 341, 460,
	FONT_END, 208, 460,
	FONT_BEGIN, 208, 460,
	FONT_NEXT, 333, 405,
	FONT_END, 200, 405,
	FONT_BEGIN, 208, 460,
	FONT_END, 200, 405,
	FONT_BEGIN, 429, 662,
	FONT_NEXT, 399, 460,
	FONT_NEXT, 371, 662,
	FONT_NEXT, 391, 405,
	FONT_END, 371, 271,
	FONT_BEGIN, 371, 662,
	FONT_NEXT, 371, 271,
	FONT_NEXT, 341, 460,
	FONT_NEXT, 362, 216,
	FONT_END, 331, 0,
	FONT_BEGIN, 496, 460,
	FONT_NEXT, 496, 405,
	FONT_NEXT, 399, 460,
	FONT_END, 391, 405,
	FONT_BEGIN, 471, 271,
	FONT_NEXT, 471, 216,
	FONT_NEXT, 371, 271,
	FONT_END, 362, 216,
	FONT_ADVANCE, 500, 0
    },
    {
	36,
	FONT_BEGIN, 264, 727,
	FONT_NEXT, 264, 664,
	FONT_NEXT, 230, 727,
	FONT_NEXT, 264, 637,
	FONT_END, 264, 391,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 264, 391,
	FONT_END, 264, 293,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 264, 293,
	FONT_END, 264, 28,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 264, 28,
	FONT_END, 264, 0,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 264, 0,
	FONT_END, 264, -87,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 264, -87,
	FONT_END, 230, -87,
	FONT_BEGIN, 230, 727,
	FONT_NEXT, 230, -87,
	FONT_NEXT, 230, 664,
	FONT_END, 230, 310,
	FONT_BEGIN, 230, 310,
	FONT_NEXT, 230, -87,
	FONT_NEXT, 230, 28,
	FONT_NEXT, 230, 0,
	FONT_NEXT, 166, 37,
	FONT_NEXT, 162, 5,
	FONT_NEXT, 117, 66,
	FONT_NEXT, 110, 19,
	FONT_NEXT, 81, 114,
	FONT_NEXT, 70, 35,
	FONT_NEXT, 59, 181,
	FONT_NEXT, 44, 51,
	FONT_END, 44, 181,
	FONT_BEGIN, 425, 611,
	FONT_NEXT, 425, 500,
	FONT_NEXT, 387, 634,
	FONT_NEXT, 410, 500,
	FONT_END, 399, 537,
	FONT_BEGIN, 387, 634,
	FONT_NEXT, 399, 537,
	FONT_END, 385, 566,
	FONT_BEGIN, 387, 634,
	FONT_NEXT, 385, 566,
	FONT_NEXT, 345, 649,
	FONT_NEXT, 348, 607,
	FONT_END, 305, 628,
	FONT_BEGIN, 345, 649,
	FONT_NEXT, 305, 628,
	FONT_NEXT, 264, 664,
	FONT_END, 264, 637,
	FONT_BEGIN, 457, 174,
	FONT_NEXT, 453, 134,
	FONT_NEXT, 453, 211,
	FONT_END, 444, 243,
	FONT_BEGIN, 444, 243,
	FONT_NEXT, 453, 134,
	FONT_END, 441, 100,
	FONT_BEGIN, 444, 243,
	FONT_NEXT, 441, 100,
	FONT_NEXT, 408, 295,
	FONT_NEXT, 399, 49,
	FONT_NEXT, 348, 341,
	FONT_NEXT, 378, 151,
	FONT_END, 369, 197,
	FONT_BEGIN, 348, 341,
	FONT_NEXT, 369, 197,
	FONT_END, 344, 234,
	FONT_BEGIN, 348, 341,
	FONT_NEXT, 344, 234,
	FONT_NEXT, 264, 391,
	FONT_NEXT, 308, 264,
	FONT_END, 264, 293,
	FONT_BEGIN, 264, 28,
	FONT_NEXT, 295, 35,
	FONT_NEXT, 264, 0,
	FONT_NEXT, 333, 53,
	FONT_NEXT, 338, 16,
	FONT_NEXT, 364, 89,
	FONT_END, 374, 116,
	FONT_BEGIN, 338, 16,
	FONT_NEXT, 374, 116,
	FONT_NEXT, 399, 49,
	FONT_END, 378, 151,
	FONT_BEGIN, 126, 532,
	FONT_NEXT, 133, 495,
	FONT_NEXT, 106, 392,
	FONT_NEXT, 155, 464,
	FONT_NEXT, 163, 349,
	FONT_NEXT, 187, 435,
	FONT_END, 229, 407,
	FONT_BEGIN, 163, 349,
	FONT_NEXT, 229, 407,
	FONT_NEXT, 230, 310,
	FONT_NEXT, 229, 637,
	FONT_NEXT, 230, 664,
	FONT_END, 185, 658,
	FONT_BEGIN, 185, 658,
	FONT_NEXT, 229, 637,
	FONT_END, 196, 628,
	FONT_BEGIN, 185, 658,
	FONT_NEXT, 196, 628,
	FONT_END, 171, 616,
	FONT_BEGIN, 185, 658,
	FONT_NEXT, 171, 616,
	FONT_NEXT, 148, 646,
	FONT_NEXT, 141, 586,
	FONT_NEXT, 93, 611,
	FONT_NEXT, 128, 555,
	FONT_END, 126, 532,
	FONT_BEGIN, 93, 611,
	FONT_NEXT, 126, 532,
	FONT_END, 106, 392,
	FONT_BEGIN, 93, 611,
	FONT_NEXT, 106, 392,
	FONT_END, 67, 445,
	FONT_BEGIN, 93, 611,
	FONT_NEXT, 67, 445,
	FONT_NEXT, 61, 563,
	FONT_NEXT, 55, 476,
	FONT_END, 52, 511,
	FONT_ADVANCE, 500, 0
    },
    {
	37,
	FONT_BEGIN, 102, 319,
	FONT_NEXT, 137, 397,
	FONT_NEXT, 140, 296,
	FONT_NEXT, 141, 362,
	FONT_END, 153, 339,
	FONT_BEGIN, 140, 296,
	FONT_NEXT, 153, 339,
	FONT_END, 172, 326,
	FONT_BEGIN, 140, 296,
	FONT_NEXT, 172, 326,
	FONT_NEXT, 178, 289,
	FONT_NEXT, 199, 323,
	FONT_NEXT, 223, 295,
	FONT_NEXT, 228, 328,
	FONT_END, 257, 343,
	FONT_BEGIN, 223, 295,
	FONT_NEXT, 257, 343,
	FONT_NEXT, 264, 314,
	FONT_END, 299, 343,
	FONT_BEGIN, 299, 343,
	FONT_NEXT, 257, 343,
	FONT_END, 309, 396,
	FONT_BEGIN, 299, 343,
	FONT_NEXT, 309, 396,
	FONT_NEXT, 329, 379,
	FONT_NEXT, 345, 469,
	FONT_NEXT, 369, 463,
	FONT_NEXT, 359, 553,
	FONT_NEXT, 352, 635,
	FONT_NEXT, 350, 600,
	FONT_NEXT, 325, 653,
	FONT_NEXT, 315, 611,
	FONT_NEXT, 305, 659,
	FONT_NEXT, 299, 622,
	FONT_NEXT, 276, 662,
	FONT_NEXT, 281, 632,
	FONT_END, 255, 625,
	FONT_BEGIN, 276, 662,
	FONT_NEXT, 255, 625,
	FONT_NEXT, 232, 655,
	FONT_NEXT, 230, 606,
	FONT_NEXT, 192, 639,
	FONT_NEXT, 184, 545,
	FONT_NEXT, 156, 613,
	FONT_NEXT, 150, 468,
	FONT_NEXT, 124, 581,
	FONT_NEXT, 137, 397,
	FONT_END, 102, 319,
	FONT_BEGIN, 124, 581,
	FONT_NEXT, 102, 319,
	FONT_NEXT, 78, 504,
	FONT_NEXT, 72, 361,
	FONT_NEXT, 65, 463,
	FONT_NEXT, 64, 390,
	FONT_END, 61, 425,
	FONT_BEGIN, 201, -13,
	FONT_NEXT, 550, 609,
	FONT_NEXT, 249, -13,
	FONT_END, 595, 676,
	FONT_BEGIN, 595, 676,
	FONT_NEXT, 550, 609,
	FONT_NEXT, 536, 630,
	FONT_NEXT, 548, 611,
	FONT_END, 507, 592,
	FONT_BEGIN, 536, 630,
	FONT_NEXT, 507, 592,
	FONT_NEXT, 493, 614,
	FONT_NEXT, 478, 585,
	FONT_NEXT, 438, 608,
	FONT_NEXT, 443, 583,
	FONT_END, 401, 585,
	FONT_BEGIN, 438, 608,
	FONT_NEXT, 401, 585,
	FONT_NEXT, 404, 610,
	FONT_END, 381, 616,
	FONT_BEGIN, 381, 616,
	FONT_NEXT, 401, 585,
	FONT_END, 377, 593,
	FONT_BEGIN, 381, 616,
	FONT_NEXT, 377, 593,
	FONT_NEXT, 352, 635,
	FONT_END, 369, 463,
	FONT_BEGIN, 369, 463,
	FONT_NEXT, 377, 593,
	FONT_END, 384, 548,
	FONT_BEGIN, 369, 463,
	FONT_END, 384, 548,
	FONT_BEGIN, 249, -13,
	FONT_NEXT, 595, 676,
	FONT_END, 634, 676,
	FONT_BEGIN, 772, 261,
	FONT_NEXT, 757, 173,
	FONT_NEXT, 768, 295,
	FONT_END, 760, 321,
	FONT_BEGIN, 760, 321,
	FONT_NEXT, 757, 173,
	FONT_END, 746, 254,
	FONT_BEGIN, 760, 321,
	FONT_NEXT, 746, 254,
	FONT_NEXT, 731, 354,
	FONT_NEXT, 740, 287,
	FONT_END, 726, 314,
	FONT_BEGIN, 731, 354,
	FONT_NEXT, 726, 314,
	FONT_NEXT, 695, 368,
	FONT_NEXT, 703, 332,
	FONT_END, 676, 339,
	FONT_BEGIN, 695, 368,
	FONT_NEXT, 676, 339,
	FONT_NEXT, 663, 371,
	FONT_NEXT, 641, 330,
	FONT_NEXT, 622, 365,
	FONT_NEXT, 611, 308,
	FONT_NEXT, 583, 349,
	FONT_NEXT, 564, 238,
	FONT_NEXT, 514, 293,
	FONT_NEXT, 534, 160,
	FONT_END, 527, 128,
	FONT_BEGIN, 514, 293,
	FONT_NEXT, 527, 128,
	FONT_END, 525, 106,
	FONT_BEGIN, 514, 293,
	FONT_NEXT, 525, 106,
	FONT_END, 513, 11,
	FONT_BEGIN, 514, 293,
	FONT_NEXT, 513, 11,
	FONT_NEXT, 466, 218,
	FONT_NEXT, 475, 42,
	FONT_END, 455, 86,
	FONT_BEGIN, 466, 218,
	FONT_NEXT, 455, 86,
	FONT_NEXT, 453, 177,
	FONT_END, 449, 137,
	FONT_BEGIN, 525, 106,
	FONT_NEXT, 533, 60,
	FONT_NEXT, 513, 11,
	FONT_NEXT, 552, 39,
	FONT_NEXT, 572, 0,
	FONT_NEXT, 589, 30,
	FONT_NEXT, 615, 6,
	FONT_NEXT, 620, 36,
	FONT_END, 650, 53,
	FONT_BEGIN, 615, 6,
	FONT_NEXT, 650, 53,
	FONT_NEXT, 654, 25,
	FONT_END, 688, 53,
	FONT_BEGIN, 688, 53,
	FONT_NEXT, 650, 53,
	FONT_END, 700, 110,
	FONT_BEGIN, 688, 53,
	FONT_NEXT, 700, 110,
	FONT_NEXT, 717, 88,
	FONT_NEXT, 733, 183,
	FONT_END, 746, 254,
	FONT_BEGIN, 717, 88,
	FONT_NEXT, 746, 254,
	FONT_END, 757, 173,
	FONT_ADVANCE, 833, 0
    },
    {
	38,
	FONT_BEGIN, 42, 144,
	FONT_NEXT, 57, 215,
	FONT_NEXT, 46, 99,
	FONT_END, 59, 64,
	FONT_BEGIN, 59, 64,
	FONT_NEXT, 57, 215,
	FONT_NEXT, 78, 36,
	FONT_NEXT, 95, 274,
	FONT_NEXT, 101, 16,
	FONT_END, 134, 180,
	FONT_BEGIN, 134, 180,
	FONT_NEXT, 95, 274,
	FONT_NEXT, 146, 238,
	FONT_NEXT, 146, 320,
	FONT_NEXT, 176, 283,
	FONT_NEXT, 199, 355,
	FONT_NEXT, 214, 317,
	FONT_NEXT, 237, 377,
	FONT_NEXT, 252, 343,
	FONT_END, 240, 624,
	FONT_BEGIN, 240, 624,
	FONT_NEXT, 237, 377,
	FONT_NEXT, 211, 573,
	FONT_NEXT, 211, 452,
	FONT_END, 202, 519,
	FONT_BEGIN, 321, 416,
	FONT_NEXT, 350, 432,
	FONT_NEXT, 336, 384,
	FONT_END, 387, 409,
	FONT_BEGIN, 387, 409,
	FONT_NEXT, 350, 432,
	FONT_END, 389, 462,
	FONT_BEGIN, 387, 409,
	FONT_NEXT, 389, 462,
	FONT_END, 423, 504,
	FONT_BEGIN, 387, 409,
	FONT_NEXT, 423, 504,
	FONT_NEXT, 437, 444,
	FONT_NEXT, 438, 560,
	FONT_NEXT, 450, 644,
	FONT_NEXT, 431, 594,
	FONT_NEXT, 407, 667,
	FONT_NEXT, 414, 620,
	FONT_END, 389, 637,
	FONT_BEGIN, 407, 667,
	FONT_NEXT, 389, 637,
	FONT_NEXT, 355, 676,
	FONT_NEXT, 359, 644,
	FONT_END, 329, 639,
	FONT_BEGIN, 355, 676,
	FONT_NEXT, 329, 639,
	FONT_NEXT, 319, 672,
	FONT_NEXT, 304, 623,
	FONT_NEXT, 288, 661,
	FONT_NEXT, 287, 596,
	FONT_NEXT, 240, 624,
	FONT_NEXT, 281, 557,
	FONT_NEXT, 252, 343,
	FONT_NEXT, 293, 483,
	FONT_END, 321, 416,
	FONT_BEGIN, 252, 343,
	FONT_NEXT, 321, 416,
	FONT_NEXT, 322, 219,
	FONT_NEXT, 336, 384,
	FONT_END, 396, 277,
	FONT_BEGIN, 322, 219,
	FONT_NEXT, 396, 277,
	FONT_NEXT, 404, 104,
	FONT_NEXT, 429, 78,
	FONT_END, 394, 49,
	FONT_BEGIN, 404, 104,
	FONT_NEXT, 394, 49,
	FONT_NEXT, 356, 69,
	FONT_NEXT, 347, 19,
	FONT_NEXT, 316, 49,
	FONT_NEXT, 286, -4,
	FONT_NEXT, 285, 41,
	FONT_NEXT, 207, -13,
	FONT_NEXT, 263, 39,
	FONT_END, 212, 50,
	FONT_BEGIN, 212, 50,
	FONT_NEXT, 207, -13,
	FONT_NEXT, 171, 80,
	FONT_NEXT, 155, -7,
	FONT_NEXT, 144, 125,
	FONT_NEXT, 101, 16,
	FONT_END, 134, 180,
	FONT_BEGIN, 491, 556,
	FONT_NEXT, 486, 521,
	FONT_NEXT, 480, 606,
	FONT_NEXT, 475, 492,
	FONT_NEXT, 450, 644,
	FONT_END, 437, 444,
	FONT_BEGIN, 495, 405,
	FONT_NEXT, 495, 426,
	FONT_NEXT, 540, 395,
	FONT_NEXT, 617, 346,
	FONT_NEXT, 554, 381,
	FONT_NEXT, 591, 300,
	FONT_NEXT, 559, 359,
	FONT_NEXT, 568, 261,
	FONT_END, 550, 232,
	FONT_BEGIN, 559, 359,
	FONT_NEXT, 550, 232,
	FONT_NEXT, 548, 310,
	FONT_NEXT, 528, 200,
	FONT_NEXT, 524, 259,
	FONT_NEXT, 491, 150,
	FONT_NEXT, 494, 213,
	FONT_END, 468, 178,
	FONT_BEGIN, 468, 178,
	FONT_NEXT, 491, 150,
	FONT_END, 456, 51,
	FONT_BEGIN, 468, 178,
	FONT_NEXT, 456, 51,
	FONT_NEXT, 396, 277,
	FONT_END, 429, 78,
	FONT_BEGIN, 711, 426,
	FONT_NEXT, 711, 405,
	FONT_NEXT, 495, 426,
	FONT_NEXT, 661, 392,
	FONT_END, 638, 375,
	FONT_BEGIN, 495, 426,
	FONT_NEXT, 638, 375,
	FONT_END, 617, 346,
	FONT_BEGIN, 750, 100,
	FONT_NEXT, 747, 93,
	FONT_NEXT, 735, 111,
	FONT_NEXT, 740, 80,
	FONT_END, 713, 42,
	FONT_BEGIN, 735, 111,
	FONT_NEXT, 713, 42,
	FONT_NEXT, 697, 73,
	FONT_NEXT, 667, 4,
	FONT_NEXT, 672, 62,
	FONT_END, 639, 58,
	FONT_BEGIN, 639, 58,
	FONT_NEXT, 667, 4,
	FONT_END, 635, -9,
	FONT_BEGIN, 639, 58,
	FONT_NEXT, 635, -9,
	FONT_NEXT, 585, 70,
	FONT_NEXT, 599, -13,
	FONT_END, 542, -3,
	FONT_BEGIN, 585, 70,
	FONT_NEXT, 542, -3,
	FONT_NEXT, 540, 98,
	FONT_NEXT, 494, 21,
	FONT_NEXT, 507, 129,
	FONT_END, 491, 150,
	FONT_BEGIN, 491, 150,
	FONT_NEXT, 494, 21,
	FONT_END, 456, 51,
	FONT_BEGIN, 491, 150,
	FONT_END, 456, 51,
	FONT_ADVANCE, 778, 0
    },
    {
	39,
	FONT_BEGIN, 106, 433,
	FONT_NEXT, 97, 452,
	FONT_NEXT, 136, 450,
	FONT_NEXT, 137, 483,
	FONT_END, 162, 513,
	FONT_BEGIN, 136, 450,
	FONT_NEXT, 162, 513,
	FONT_NEXT, 173, 483,
	FONT_NEXT, 175, 539,
	FONT_END, 179, 558,
	FONT_BEGIN, 173, 483,
	FONT_NEXT, 179, 558,
	FONT_NEXT, 204, 528,
	FONT_END, 186, 659,
	FONT_BEGIN, 186, 659,
	FONT_NEXT, 179, 558,
	FONT_NEXT, 159, 672,
	FONT_NEXT, 174, 568,
	FONT_END, 165, 572,
	FONT_BEGIN, 159, 672,
	FONT_NEXT, 165, 572,
	FONT_END, 156, 570,
	FONT_BEGIN, 159, 672,
	FONT_NEXT, 156, 570,
	FONT_NEXT, 137, 676,
	FONT_NEXT, 141, 568,
	FONT_END, 100, 578,
	FONT_BEGIN, 137, 676,
	FONT_NEXT, 100, 578,
	FONT_NEXT, 98, 663,
	FONT_NEXT, 85, 593,
	FONT_NEXT, 84, 645,
	FONT_END, 79, 618,
	FONT_BEGIN, 218, 580,
	FONT_NEXT, 204, 528,
	FONT_NEXT, 208, 630,
	FONT_END, 186, 659,
	FONT_ADVANCE, 333, 0
    },
    {
	40,
	FONT_BEGIN, 48, 262,
	FONT_NEXT, 52, 325,
	FONT_NEXT, 53, 169,
	FONT_NEXT, 64, 386,
	FONT_NEXT, 70, 96,
	FONT_NEXT, 85, 444,
	FONT_NEXT, 96, 35,
	FONT_NEXT, 113, 499,
	FONT_NEXT, 130, -20,
	FONT_NEXT, 134, 225,
	FONT_END, 136, 174,
	FONT_BEGIN, 130, -20,
	FONT_NEXT, 136, 174,
	FONT_END, 155, 56,
	FONT_BEGIN, 130, -20,
	FONT_NEXT, 155, 56,
	FONT_END, 175, -4,
	FONT_BEGIN, 130, -20,
	FONT_NEXT, 175, -4,
	FONT_NEXT, 203, -108,
	FONT_NEXT, 205, -63,
	FONT_NEXT, 247, -148,
	FONT_NEXT, 247, -116,
	FONT_NEXT, 292, -177,
	FONT_END, 304, -161,
	FONT_BEGIN, 304, 660,
	FONT_NEXT, 246, 609,
	FONT_NEXT, 295, 676,
	FONT_END, 239, 638,
	FONT_BEGIN, 239, 638,
	FONT_NEXT, 246, 609,
	FONT_END, 191, 537,
	FONT_BEGIN, 239, 638,
	FONT_NEXT, 191, 537,
	FONT_NEXT, 191, 596,
	FONT_END, 148, 549,
	FONT_BEGIN, 148, 549,
	FONT_NEXT, 191, 537,
	FONT_END, 168, 488,
	FONT_BEGIN, 148, 549,
	FONT_NEXT, 168, 488,
	FONT_END, 150, 428,
	FONT_BEGIN, 148, 549,
	FONT_NEXT, 150, 428,
	FONT_END, 138, 356,
	FONT_BEGIN, 148, 549,
	FONT_NEXT, 138, 356,
	FONT_NEXT, 113, 499,
	FONT_NEXT, 134, 269,
	FONT_END, 134, 225,
	FONT_ADVANCE, 333, 0
    },
    {
	41,
	FONT_BEGIN, 29, -161,
	FONT_NEXT, 86, -111,
	FONT_NEXT, 38, -177,
	FONT_END, 93, -140,
	FONT_BEGIN, 93, -140,
	FONT_NEXT, 86, -111,
	FONT_NEXT, 141, -98,
	FONT_NEXT, 141, -39,
	FONT_END, 164, 10,
	FONT_BEGIN, 141, -98,
	FONT_NEXT, 164, 10,
	FONT_END, 182, 70,
	FONT_BEGIN, 141, -98,
	FONT_NEXT, 182, 70,
	FONT_NEXT, 184, -51,
	FONT_NEXT, 194, 142,
	FONT_END, 199, 230,
	FONT_BEGIN, 184, -51,
	FONT_NEXT, 199, 230,
	FONT_NEXT, 219, 0,
	FONT_END, 203, 519,
	FONT_BEGIN, 203, 519,
	FONT_NEXT, 199, 230,
	FONT_END, 198, 273,
	FONT_BEGIN, 203, 519,
	FONT_NEXT, 198, 273,
	FONT_END, 196, 324,
	FONT_BEGIN, 203, 519,
	FONT_NEXT, 196, 324,
	FONT_END, 177, 442,
	FONT_BEGIN, 203, 519,
	FONT_NEXT, 177, 442,
	FONT_NEXT, 129, 606,
	FONT_NEXT, 157, 502,
	FONT_END, 127, 561,
	FONT_BEGIN, 129, 606,
	FONT_NEXT, 127, 561,
	FONT_NEXT, 85, 646,
	FONT_NEXT, 85, 614,
	FONT_NEXT, 41, 676,
	FONT_END, 29, 660,
	FONT_BEGIN, 285, 237,
	FONT_NEXT, 280, 173,
	FONT_NEXT, 279, 329,
	FONT_NEXT, 268, 112,
	FONT_NEXT, 262, 402,
	FONT_NEXT, 247, 54,
	FONT_NEXT, 236, 463,
	FONT_NEXT, 219, 0,
	FONT_END, 203, 519,
	FONT_ADVANCE, 333, 0
    },
    {
	42,
	FONT_BEGIN, 69, 557,
	FONT_NEXT, 75, 576,
	FONT_NEXT, 72, 538,
	FONT_END, 83, 526,
	FONT_BEGIN, 83, 526,
	FONT_NEXT, 75, 576,
	FONT_END, 85, 586,
	FONT_BEGIN, 83, 526,
	FONT_NEXT, 85, 586,
	FONT_END, 102, 591,
	FONT_BEGIN, 83, 526,
	FONT_NEXT, 102, 591,
	FONT_NEXT, 120, 511,
	FONT_NEXT, 129, 581,
	FONT_END, 152, 557,
	FONT_BEGIN, 120, 511,
	FONT_NEXT, 152, 557,
	FONT_NEXT, 170, 500,
	FONT_NEXT, 185, 523,
	FONT_NEXT, 223, 478,
	FONT_END, 234, 471,
	FONT_BEGIN, 234, 471,
	FONT_NEXT, 185, 523,
	FONT_END, 241, 486,
	FONT_BEGIN, 234, 471,
	FONT_NEXT, 241, 486,
	FONT_END, 240, 456,
	FONT_BEGIN, 234, 471,
	FONT_NEXT, 240, 456,
	FONT_END, 210, 435,
	FONT_BEGIN, 234, 471,
	FONT_NEXT, 210, 435,
	FONT_NEXT, 172, 441,
	FONT_NEXT, 192, 422,
	FONT_END, 164, 394,
	FONT_BEGIN, 172, 441,
	FONT_NEXT, 164, 394,
	FONT_NEXT, 120, 428,
	FONT_NEXT, 143, 371,
	FONT_END, 129, 358,
	FONT_BEGIN, 120, 428,
	FONT_NEXT, 129, 358,
	FONT_END, 103, 351,
	FONT_BEGIN, 120, 428,
	FONT_NEXT, 103, 351,
	FONT_NEXT, 82, 415,
	FONT_NEXT, 76, 362,
	FONT_NEXT, 72, 402,
	FONT_END, 69, 383,
	FONT_BEGIN, 214, 304,
	FONT_NEXT, 219, 331,
	FONT_NEXT, 225, 275,
	FONT_NEXT, 230, 365,
	FONT_END, 240, 405,
	FONT_BEGIN, 225, 275,
	FONT_NEXT, 240, 405,
	FONT_NEXT, 249, 265,
	FONT_NEXT, 241, 449,
	FONT_NEXT, 241, 499,
	FONT_END, 241, 486,
	FONT_BEGIN, 241, 486,
	FONT_NEXT, 241, 449,
	FONT_END, 240, 456,
	FONT_BEGIN, 241, 486,
	FONT_END, 240, 456,
	FONT_BEGIN, 216, 637,
	FONT_NEXT, 220, 659,
	FONT_NEXT, 228, 581,
	FONT_NEXT, 231, 671,
	FONT_NEXT, 237, 548,
	FONT_END, 241, 499,
	FONT_BEGIN, 241, 499,
	FONT_NEXT, 231, 671,
	FONT_END, 253, 676,
	FONT_BEGIN, 241, 499,
	FONT_NEXT, 253, 676,
	FONT_NEXT, 249, 265,
	FONT_END, 260, 449,
	FONT_BEGIN, 260, 449,
	FONT_NEXT, 253, 676,
	FONT_NEXT, 260, 456,
	FONT_END, 260, 484,
	FONT_BEGIN, 260, 484,
	FONT_NEXT, 253, 676,
	FONT_NEXT, 260, 510,
	FONT_NEXT, 269, 671,
	FONT_NEXT, 273, 582,
	FONT_NEXT, 279, 661,
	FONT_NEXT, 282, 613,
	FONT_END, 287, 637,
	FONT_BEGIN, 288, 307,
	FONT_NEXT, 277, 278,
	FONT_NEXT, 274, 352,
	FONT_NEXT, 249, 265,
	FONT_NEXT, 264, 389,
	FONT_END, 260, 449,
	FONT_BEGIN, 431, 557,
	FONT_NEXT, 428, 537,
	FONT_NEXT, 427, 574,
	FONT_NEXT, 420, 525,
	FONT_NEXT, 417, 585,
	FONT_NEXT, 388, 513,
	FONT_NEXT, 395, 593,
	FONT_END, 368, 581,
	FONT_BEGIN, 368, 581,
	FONT_NEXT, 388, 513,
	FONT_END, 336, 502,
	FONT_BEGIN, 368, 581,
	FONT_NEXT, 336, 502,
	FONT_NEXT, 341, 554,
	FONT_END, 309, 520,
	FONT_BEGIN, 309, 520,
	FONT_NEXT, 336, 502,
	FONT_END, 304, 489,
	FONT_BEGIN, 309, 520,
	FONT_NEXT, 304, 489,
	FONT_NEXT, 267, 488,
	FONT_NEXT, 268, 470,
	FONT_END, 267, 453,
	FONT_BEGIN, 267, 488,
	FONT_NEXT, 267, 453,
	FONT_NEXT, 260, 484,
	FONT_END, 260, 456,
	FONT_BEGIN, 432, 386,
	FONT_NEXT, 421, 359,
	FONT_NEXT, 428, 404,
	FONT_END, 419, 416,
	FONT_BEGIN, 419, 416,
	FONT_NEXT, 421, 359,
	FONT_END, 396, 350,
	FONT_BEGIN, 419, 416,
	FONT_NEXT, 396, 350,
	FONT_NEXT, 384, 428,
	FONT_NEXT, 366, 362,
	FONT_NEXT, 334, 439,
	FONT_NEXT, 338, 391,
	FONT_END, 307, 425,
	FONT_BEGIN, 334, 439,
	FONT_NEXT, 307, 425,
	FONT_NEXT, 276, 465,
	FONT_NEXT, 267, 453,
	FONT_END, 268, 470,
	FONT_ADVANCE, 500, 0
    },
    {
	43,
	FONT_BEGIN, 315, 506,
	FONT_NEXT, 315, 286,
	FONT_NEXT, 249, 506,
	FONT_NEXT, 315, 220,
	FONT_END, 315, 0,
	FONT_BEGIN, 249, 506,
	FONT_NEXT, 315, 0,
	FONT_END, 249, 0,
	FONT_BEGIN, 249, 506,
	FONT_NEXT, 249, 0,
	FONT_NEXT, 249, 286,
	FONT_NEXT, 249, 220,
	FONT_NEXT, 30, 286,
	FONT_END, 30, 220,
	FONT_BEGIN, 534, 286,
	FONT_NEXT, 534, 220,
	FONT_NEXT, 315, 286,
	FONT_END, 315, 220,
	FONT_ADVANCE, 564, 0
    },
    {
	44,
	FONT_BEGIN, 83, -141,
	FONT_NEXT, 74, -122,
	FONT_NEXT, 113, -124,
	FONT_NEXT, 114, -91,
	FONT_END, 139, -61,
	FONT_BEGIN, 113, -124,
	FONT_NEXT, 139, -61,
	FONT_NEXT, 150, -91,
	FONT_NEXT, 152, -35,
	FONT_END, 156, -16,
	FONT_BEGIN, 150, -91,
	FONT_NEXT, 156, -16,
	FONT_NEXT, 181, -46,
	FONT_END, 163, 85,
	FONT_BEGIN, 163, 85,
	FONT_NEXT, 156, -16,
	FONT_NEXT, 136, 98,
	FONT_NEXT, 151, -6,
	FONT_END, 142, -2,
	FONT_BEGIN, 136, 98,
	FONT_NEXT, 142, -2,
	FONT_END, 133, -4,
	FONT_BEGIN, 136, 98,
	FONT_NEXT, 133, -4,
	FONT_NEXT, 114, 102,
	FONT_NEXT, 118, -6,
	FONT_END, 77, 4,
	FONT_BEGIN, 114, 102,
	FONT_NEXT, 77, 4,
	FONT_NEXT, 75, 89,
	FONT_NEXT, 62, 19,
	FONT_NEXT, 61, 71,
	FONT_END, 56, 44,
	FONT_BEGIN, 195, 6,
	FONT_NEXT, 181, -46,
	FONT_NEXT, 185, 56,
	FONT_END, 163, 85,
	FONT_ADVANCE, 250, 0
    },
    {
	45,
	FONT_BEGIN, 285, 257,
	FONT_NEXT, 285, 194,
	FONT_NEXT, 39, 257,
	FONT_END, 39, 194,
	FONT_ADVANCE, 333, 0
    },
    {
	46,
	FONT_BEGIN, 181, 43,
	FONT_NEXT, 175, 18,
	FONT_NEXT, 176, 64,
	FONT_END, 164, 83,
	FONT_BEGIN, 164, 83,
	FONT_NEXT, 175, 18,
	FONT_END, 160, 2,
	FONT_BEGIN, 164, 83,
	FONT_NEXT, 160, 2,
	FONT_NEXT, 146, 95,
	FONT_NEXT, 125, -11,
	FONT_NEXT, 125, 100,
	FONT_END, 103, 95,
	FONT_BEGIN, 103, 95,
	FONT_NEXT, 125, -11,
	FONT_END, 89, 1,
	FONT_BEGIN, 103, 95,
	FONT_NEXT, 89, 1,
	FONT_NEXT, 86, 83,
	FONT_NEXT, 75, 18,
	FONT_NEXT, 74, 65,
	FONT_END, 70, 43,
	FONT_ADVANCE, 250, 0
    },
    {
	47,
	FONT_BEGIN, 287, 676,
	FONT_NEXT, 59, -14,
	FONT_NEXT, 220, 676,
	FONT_END, -9, -14,
	FONT_ADVANCE, 278, 0
    },
    {
	48,
	FONT_BEGIN, 476, 331,
	FONT_NEXT, 466, 226,
	FONT_NEXT, 473, 379,
	FONT_END, 466, 434,
	FONT_BEGIN, 466, 434,
	FONT_NEXT, 466, 226,
	FONT_NEXT, 432, 547,
	FONT_NEXT, 432, 113,
	FONT_NEXT, 402, 597,
	FONT_NEXT, 402, 63,
	FONT_NEXT, 362, 638,
	FONT_NEXT, 377, 409,
	FONT_END, 363, 516,
	FONT_BEGIN, 362, 638,
	FONT_NEXT, 363, 516,
	FONT_END, 347, 566,
	FONT_BEGIN, 362, 638,
	FONT_NEXT, 347, 566,
	FONT_NEXT, 312, 666,
	FONT_NEXT, 324, 609,
	FONT_END, 292, 639,
	FONT_BEGIN, 312, 666,
	FONT_NEXT, 292, 639,
	FONT_NEXT, 250, 676,
	FONT_NEXT, 250, 650,
	FONT_NEXT, 187, 666,
	FONT_NEXT, 207, 639,
	FONT_END, 175, 609,
	FONT_BEGIN, 187, 666,
	FONT_NEXT, 175, 609,
	FONT_NEXT, 137, 638,
	FONT_NEXT, 152, 566,
	FONT_END, 137, 516,
	FONT_BEGIN, 137, 638,
	FONT_NEXT, 137, 516,
	FONT_NEXT, 97, 597,
	FONT_NEXT, 122, 409,
	FONT_END, 120, 364,
	FONT_BEGIN, 97, 597,
	FONT_NEXT, 120, 364,
	FONT_END, 120, 331,
	FONT_BEGIN, 97, 597,
	FONT_NEXT, 120, 331,
	FONT_END, 120, 294,
	FONT_BEGIN, 97, 597,
	FONT_NEXT, 120, 294,
	FONT_END, 97, 63,
	FONT_BEGIN, 97, 597,
	FONT_NEXT, 97, 63,
	FONT_NEXT, 68, 547,
	FONT_NEXT, 68, 113,
	FONT_NEXT, 33, 434,
	FONT_NEXT, 33, 226,
	FONT_NEXT, 26, 379,
	FONT_END, 24, 331,
	FONT_BEGIN, 120, 294,
	FONT_NEXT, 122, 246,
	FONT_NEXT, 97, 63,
	FONT_END, 137, 22,
	FONT_BEGIN, 137, 22,
	FONT_NEXT, 122, 246,
	FONT_END, 137, 141,
	FONT_BEGIN, 137, 22,
	FONT_NEXT, 137, 141,
	FONT_END, 152, 91,
	FONT_BEGIN, 137, 22,
	FONT_NEXT, 152, 91,
	FONT_END, 175, 50,
	FONT_BEGIN, 137, 22,
	FONT_NEXT, 175, 50,
	FONT_NEXT, 187, -5,
	FONT_NEXT, 207, 22,
	FONT_NEXT, 250, -14,
	FONT_NEXT, 250, 12,
	FONT_END, 292, 22,
	FONT_BEGIN, 250, -14,
	FONT_NEXT, 292, 22,
	FONT_NEXT, 312, -5,
	FONT_NEXT, 324, 50,
	FONT_END, 347, 92,
	FONT_BEGIN, 312, -5,
	FONT_NEXT, 347, 92,
	FONT_NEXT, 362, 22,
	FONT_NEXT, 363, 141,
	FONT_END, 377, 247,
	FONT_BEGIN, 362, 22,
	FONT_NEXT, 377, 247,
	FONT_NEXT, 402, 63,
	FONT_NEXT, 379, 294,
	FONT_END, 380, 331,
	FONT_BEGIN, 402, 63,
	FONT_NEXT, 380, 331,
	FONT_END, 379, 364,
	FONT_BEGIN, 402, 63,
	FONT_NEXT, 379, 364,
	FONT_END, 377, 409,
	FONT_ADVANCE, 500, 0
    },
    {
	49,
	FONT_BEGIN, 299, 674,
	FONT_NEXT, 299, 74,
	FONT_NEXT, 291, 676,
	FONT_NEXT, 213, 93,
	FONT_END, 213, 546,
	FONT_BEGIN, 291, 676,
	FONT_NEXT, 213, 546,
	FONT_END, 208, 577,
	FONT_BEGIN, 291, 676,
	FONT_NEXT, 208, 577,
	FONT_END, 198, 588,
	FONT_BEGIN, 291, 676,
	FONT_NEXT, 198, 588,
	FONT_END, 179, 593,
	FONT_BEGIN, 291, 676,
	FONT_NEXT, 179, 593,
	FONT_NEXT, 111, 585,
	FONT_NEXT, 161, 590,
	FONT_END, 143, 583,
	FONT_BEGIN, 111, 585,
	FONT_NEXT, 143, 583,
	FONT_END, 111, 571,
	FONT_BEGIN, 394, 15,
	FONT_NEXT, 394, 0,
	FONT_NEXT, 347, 17,
	FONT_NEXT, 118, 0,
	FONT_NEXT, 318, 26,
	FONT_END, 303, 44,
	FONT_BEGIN, 303, 44,
	FONT_NEXT, 118, 0,
	FONT_END, 187, 27,
	FONT_BEGIN, 303, 44,
	FONT_NEXT, 187, 27,
	FONT_NEXT, 299, 74,
	FONT_NEXT, 206, 49,
	FONT_END, 213, 93,
	FONT_BEGIN, 118, 15,
	FONT_NEXT, 157, 17,
	FONT_NEXT, 118, 0,
	FONT_END, 187, 27,
	FONT_ADVANCE, 500, 0
    },
    {
	50,
	FONT_BEGIN, 475, 137,
	FONT_NEXT, 420, 0,
	FONT_NEXT, 462, 142,
	FONT_END, 435, 105,
	FONT_BEGIN, 435, 105,
	FONT_NEXT, 420, 0,
	FONT_NEXT, 413, 85,
	FONT_NEXT, 30, 0,
	FONT_NEXT, 367, 76,
	FONT_END, 128, 76,
	FONT_BEGIN, 128, 76,
	FONT_NEXT, 30, 0,
	FONT_END, 30, 12,
	FONT_BEGIN, 128, 76,
	FONT_NEXT, 30, 12,
	FONT_END, 208, 201,
	FONT_BEGIN, 128, 76,
	FONT_NEXT, 208, 201,
	FONT_END, 265, 270,
	FONT_BEGIN, 128, 76,
	FONT_NEXT, 265, 270,
	FONT_NEXT, 296, 252,
	FONT_NEXT, 305, 336,
	FONT_END, 329, 400,
	FONT_BEGIN, 296, 252,
	FONT_NEXT, 329, 400,
	FONT_NEXT, 334, 295,
	FONT_NEXT, 338, 459,
	FONT_NEXT, 367, 628,
	FONT_NEXT, 332, 502,
	FONT_NEXT, 309, 663,
	FONT_NEXT, 310, 549,
	FONT_END, 267, 586,
	FONT_BEGIN, 309, 663,
	FONT_NEXT, 267, 586,
	FONT_NEXT, 243, 676,
	FONT_NEXT, 235, 597,
	FONT_NEXT, 176, 666,
	FONT_NEXT, 195, 602,
	FONT_END, 137, 589,
	FONT_BEGIN, 176, 666,
	FONT_NEXT, 137, 589,
	FONT_NEXT, 115, 633,
	FONT_NEXT, 97, 557,
	FONT_NEXT, 88, 606,
	FONT_NEXT, 70, 515,
	FONT_NEXT, 64, 571,
	FONT_NEXT, 52, 472,
	FONT_NEXT, 45, 528,
	FONT_END, 31, 477,
	FONT_BEGIN, 424, 496,
	FONT_NEXT, 410, 419,
	FONT_NEXT, 419, 535,
	FONT_END, 408, 571,
	FONT_BEGIN, 408, 571,
	FONT_NEXT, 410, 419,
	FONT_END, 376, 351,
	FONT_BEGIN, 408, 571,
	FONT_NEXT, 376, 351,
	FONT_NEXT, 367, 628,
	FONT_END, 334, 295,
	FONT_ADVANCE, 500, 0
    },
    {
	51,
	FONT_BEGIN, 153, 330,
	FONT_NEXT, 152, 343,
	FONT_NEXT, 197, 330,
	FONT_NEXT, 216, 368,
	FONT_NEXT, 230, 326,
	FONT_NEXT, 269, 403,
	FONT_NEXT, 283, 308,
	FONT_END, 304, 401,
	FONT_BEGIN, 304, 401,
	FONT_NEXT, 269, 403,
	FONT_END, 304, 450,
	FONT_BEGIN, 304, 401,
	FONT_NEXT, 304, 450,
	FONT_END, 318, 512,
	FONT_BEGIN, 304, 401,
	FONT_NEXT, 318, 512,
	FONT_NEXT, 346, 433,
	FONT_END, 319, 660,
	FONT_BEGIN, 319, 660,
	FONT_NEXT, 318, 512,
	FONT_END, 311, 549,
	FONT_BEGIN, 319, 660,
	FONT_NEXT, 311, 549,
	FONT_NEXT, 284, 671,
	FONT_NEXT, 290, 583,
	FONT_END, 256, 606,
	FONT_BEGIN, 284, 671,
	FONT_NEXT, 256, 606,
	FONT_NEXT, 241, 676,
	FONT_NEXT, 208, 616,
	FONT_NEXT, 187, 669,
	FONT_NEXT, 148, 603,
	FONT_NEXT, 132, 644,
	FONT_NEXT, 105, 573,
	FONT_NEXT, 83, 594,
	FONT_NEXT, 76, 538,
	FONT_NEXT, 62, 558,
	FONT_NEXT, 60, 510,
	FONT_END, 45, 514,
	FONT_BEGIN, 43, 43,
	FONT_NEXT, 46, 60,
	FONT_NEXT, 56, 12,
	FONT_NEXT, 56, 71,
	FONT_END, 82, 78,
	FONT_BEGIN, 56, 12,
	FONT_NEXT, 82, 78,
	FONT_NEXT, 89, -5,
	FONT_NEXT, 115, 69,
	FONT_NEXT, 126, -13,
	FONT_NEXT, 148, 50,
	FONT_NEXT, 154, -14,
	FONT_NEXT, 184, 30,
	FONT_NEXT, 210, -10,
	FONT_NEXT, 225, 22,
	FONT_NEXT, 263, 1,
	FONT_NEXT, 285, 35,
	FONT_NEXT, 310, 21,
	FONT_NEXT, 326, 70,
	FONT_NEXT, 351, 47,
	FONT_NEXT, 351, 120,
	FONT_END, 359, 176,
	FONT_BEGIN, 351, 47,
	FONT_NEXT, 359, 176,
	FONT_NEXT, 383, 351,
	FONT_END, 341, 383,
	FONT_BEGIN, 341, 383,
	FONT_NEXT, 359, 176,
	FONT_END, 356, 202,
	FONT_BEGIN, 341, 383,
	FONT_NEXT, 356, 202,
	FONT_END, 345, 239,
	FONT_BEGIN, 341, 383,
	FONT_NEXT, 345, 239,
	FONT_END, 321, 276,
	FONT_BEGIN, 341, 383,
	FONT_NEXT, 321, 276,
	FONT_NEXT, 304, 401,
	FONT_END, 283, 308,
	FONT_BEGIN, 431, 216,
	FONT_NEXT, 425, 165,
	FONT_NEXT, 427, 261,
	FONT_END, 417, 298,
	FONT_BEGIN, 417, 298,
	FONT_NEXT, 425, 165,
	FONT_END, 409, 120,
	FONT_BEGIN, 417, 298,
	FONT_NEXT, 409, 120,
	FONT_NEXT, 383, 351,
	FONT_NEXT, 384, 80,
	FONT_END, 351, 47,
	FONT_BEGIN, 397, 541,
	FONT_NEXT, 391, 502,
	FONT_NEXT, 390, 579,
	FONT_NEXT, 375, 466,
	FONT_NEXT, 367, 623,
	FONT_NEXT, 346, 433,
	FONT_END, 319, 660,
	FONT_ADVANCE, 500, 0
    },
    {
	52,
	FONT_BEGIN, 292, 571,
	FONT_NEXT, 293, 167,
	FONT_NEXT, 292, 231,
	FONT_NEXT, 12, 167,
	FONT_NEXT, 52, 231,
	FONT_NEXT, 12, 231,
	FONT_NEXT, 290, 571,
	FONT_NEXT, 326, 676,
	FONT_NEXT, 292, 571,
	FONT_END, 293, 167,
	FONT_BEGIN, 293, 167,
	FONT_NEXT, 326, 676,
	FONT_NEXT, 293, 0,
	FONT_END, 370, 0,
	FONT_BEGIN, 370, 0,
	FONT_NEXT, 326, 676,
	FONT_NEXT, 370, 167,
	FONT_END, 370, 231,
	FONT_BEGIN, 370, 231,
	FONT_NEXT, 326, 676,
	FONT_END, 370, 676,
	FONT_BEGIN, 370, 231,
	FONT_END, 370, 676,
	FONT_BEGIN, 472, 231,
	FONT_NEXT, 472, 167,
	FONT_NEXT, 370, 231,
	FONT_END, 370, 167,
	FONT_ADVANCE, 500, 0
    },
    {
	53,
	FONT_BEGIN, 64, 415,
	FONT_NEXT, 65, 425,
	FONT_NEXT, 71, 412,
	FONT_NEXT, 139, 498,
	FONT_NEXT, 161, 399,
	FONT_END, 254, 365,
	FONT_BEGIN, 254, 365,
	FONT_NEXT, 139, 498,
	FONT_END, 263, 468,
	FONT_BEGIN, 254, 365,
	FONT_NEXT, 263, 468,
	FONT_NEXT, 294, 337,
	FONT_NEXT, 321, 439,
	FONT_NEXT, 326, 300,
	FONT_END, 348, 255,
	FONT_BEGIN, 348, 255,
	FONT_NEXT, 321, 439,
	FONT_NEXT, 356, 201,
	FONT_NEXT, 372, 395,
	FONT_END, 351, 55,
	FONT_BEGIN, 356, 201,
	FONT_NEXT, 351, 55,
	FONT_NEXT, 352, 158,
	FONT_END, 343, 121,
	FONT_BEGIN, 343, 121,
	FONT_NEXT, 351, 55,
	FONT_END, 312, 26,
	FONT_BEGIN, 343, 121,
	FONT_NEXT, 312, 26,
	FONT_NEXT, 310, 66,
	FONT_NEXT, 266, 4,
	FONT_NEXT, 266, 33,
	FONT_END, 217, 23,
	FONT_BEGIN, 217, 23,
	FONT_NEXT, 266, 4,
	FONT_END, 214, -10,
	FONT_BEGIN, 217, 23,
	FONT_NEXT, 214, -10,
	FONT_NEXT, 72, 85,
	FONT_NEXT, 158, -14,
	FONT_END, 104, -10,
	FONT_BEGIN, 72, 85,
	FONT_NEXT, 104, -10,
	FONT_END, 65, 2,
	FONT_BEGIN, 72, 85,
	FONT_NEXT, 65, 2,
	FONT_NEXT, 48, 80,
	FONT_NEXT, 40, 21,
	FONT_NEXT, 37, 69,
	FONT_END, 32, 46,
	FONT_BEGIN, 438, 681,
	FONT_NEXT, 400, 592,
	FONT_NEXT, 429, 688,
	FONT_END, 411, 669,
	FONT_BEGIN, 411, 669,
	FONT_NEXT, 400, 592,
	FONT_NEXT, 383, 662,
	FONT_NEXT, 391, 584,
	FONT_END, 377, 583,
	FONT_BEGIN, 383, 662,
	FONT_NEXT, 377, 583,
	FONT_NEXT, 174, 662,
	FONT_NEXT, 181, 583,
	FONT_END, 139, 498,
	FONT_BEGIN, 174, 662,
	FONT_NEXT, 139, 498,
	FONT_END, 65, 425,
	FONT_BEGIN, 426, 225,
	FONT_NEXT, 420, 176,
	FONT_NEXT, 423, 281,
	FONT_END, 415, 323,
	FONT_BEGIN, 415, 323,
	FONT_NEXT, 420, 176,
	FONT_END, 406, 131,
	FONT_BEGIN, 415, 323,
	FONT_NEXT, 406, 131,
	FONT_NEXT, 398, 359,
	FONT_NEXT, 382, 90,
	FONT_NEXT, 372, 395,
	FONT_END, 351, 55,
	FONT_ADVANCE, 500, 0
    },
    {
	54,
	FONT_BEGIN, 448, 668,
	FONT_NEXT, 384, 652,
	FONT_NEXT, 446, 684,
	FONT_END, 358, 673,
	FONT_BEGIN, 358, 673,
	FONT_NEXT, 384, 652,
	FONT_END, 329, 628,
	FONT_BEGIN, 358, 673,
	FONT_NEXT, 329, 628,
	FONT_NEXT, 279, 647,
	FONT_NEXT, 281, 597,
	FONT_END, 240, 560,
	FONT_BEGIN, 279, 647,
	FONT_NEXT, 240, 560,
	FONT_NEXT, 209, 609,
	FONT_NEXT, 207, 519,
	FONT_NEXT, 149, 560,
	FONT_NEXT, 181, 475,
	FONT_END, 152, 383,
	FONT_BEGIN, 149, 560,
	FONT_NEXT, 152, 383,
	FONT_END, 147, 350,
	FONT_BEGIN, 149, 560,
	FONT_NEXT, 147, 350,
	FONT_NEXT, 100, 502,
	FONT_NEXT, 133, 321,
	FONT_END, 128, 294,
	FONT_BEGIN, 100, 502,
	FONT_NEXT, 128, 294,
	FONT_END, 127, 256,
	FONT_BEGIN, 100, 502,
	FONT_NEXT, 127, 256,
	FONT_END, 99, 59,
	FONT_BEGIN, 100, 502,
	FONT_NEXT, 99, 59,
	FONT_NEXT, 64, 436,
	FONT_NEXT, 72, 102,
	FONT_END, 51, 154,
	FONT_BEGIN, 64, 436,
	FONT_NEXT, 51, 154,
	FONT_NEXT, 41, 365,
	FONT_NEXT, 38, 217,
	FONT_END, 34, 291,
	FONT_BEGIN, 468, 218,
	FONT_NEXT, 459, 150,
	FONT_NEXT, 464, 265,
	FONT_END, 454, 307,
	FONT_BEGIN, 454, 307,
	FONT_NEXT, 459, 150,
	FONT_END, 427, 74,
	FONT_BEGIN, 454, 307,
	FONT_NEXT, 427, 74,
	FONT_NEXT, 437, 343,
	FONT_END, 415, 373,
	FONT_BEGIN, 415, 373,
	FONT_NEXT, 427, 74,
	FONT_END, 399, 40,
	FONT_BEGIN, 415, 373,
	FONT_NEXT, 399, 40,
	FONT_NEXT, 357, 414,
	FONT_NEXT, 378, 179,
	FONT_END, 371, 254,
	FONT_BEGIN, 357, 414,
	FONT_NEXT, 371, 254,
	FONT_END, 349, 319,
	FONT_BEGIN, 357, 414,
	FONT_NEXT, 349, 319,
	FONT_NEXT, 284, 428,
	FONT_NEXT, 331, 344,
	FONT_END, 307, 364,
	FONT_BEGIN, 284, 428,
	FONT_NEXT, 307, 364,
	FONT_END, 278, 377,
	FONT_BEGIN, 284, 428,
	FONT_NEXT, 278, 377,
	FONT_NEXT, 247, 425,
	FONT_NEXT, 242, 382,
	FONT_NEXT, 217, 417,
	FONT_NEXT, 191, 375,
	FONT_NEXT, 187, 403,
	FONT_NEXT, 147, 350,
	FONT_END, 152, 383,
	FONT_BEGIN, 127, 256,
	FONT_NEXT, 130, 197,
	FONT_NEXT, 99, 59,
	FONT_END, 132, 27,
	FONT_BEGIN, 132, 27,
	FONT_NEXT, 130, 197,
	FONT_END, 138, 147,
	FONT_BEGIN, 132, 27,
	FONT_NEXT, 138, 147,
	FONT_END, 152, 105,
	FONT_BEGIN, 132, 27,
	FONT_NEXT, 152, 105,
	FONT_NEXT, 169, 4,
	FONT_NEXT, 169, 72,
	FONT_END, 191, 46,
	FONT_BEGIN, 169, 4,
	FONT_NEXT, 191, 46,
	FONT_NEXT, 210, -10,
	FONT_NEXT, 215, 28,
	FONT_NEXT, 254, -14,
	FONT_NEXT, 269, 14,
	FONT_END, 312, 23,
	FONT_BEGIN, 254, -14,
	FONT_NEXT, 312, 23,
	FONT_NEXT, 314, -8,
	FONT_NEXT, 347, 54,
	FONT_NEXT, 362, 11,
	FONT_NEXT, 369, 105,
	FONT_END, 378, 179,
	FONT_BEGIN, 362, 11,
	FONT_NEXT, 378, 179,
	FONT_END, 399, 40,
	FONT_ADVANCE, 500, 0
    },
    {
	55,
	FONT_BEGIN, 449, 662,
	FONT_NEXT, 449, 646,
	FONT_NEXT, 79, 662,
	FONT_END, 370, 588,
	FONT_BEGIN, 370, 588,
	FONT_NEXT, 449, 646,
	FONT_END, 237, -8,
	FONT_BEGIN, 370, 588,
	FONT_NEXT, 237, -8,
	FONT_END, 172, -8,
	FONT_BEGIN, 37, 507,
	FONT_NEXT, 20, 515,
	FONT_NEXT, 59, 541,
	FONT_NEXT, 63, 618,
	FONT_END, 79, 662,
	FONT_BEGIN, 59, 541,
	FONT_NEXT, 79, 662,
	FONT_NEXT, 83, 567,
	FONT_END, 112, 582,
	FONT_BEGIN, 112, 582,
	FONT_NEXT, 79, 662,
	FONT_NEXT, 153, 588,
	FONT_END, 370, 588,
	FONT_ADVANCE, 500, 0
    },
    {
	56,
	FONT_BEGIN, 136, 547,
	FONT_NEXT, 150, 492,
	FONT_NEXT, 131, 381,
	FONT_NEXT, 185, 447,
	FONT_NEXT, 186, 332,
	FONT_END, 212, 312,
	FONT_BEGIN, 212, 312,
	FONT_NEXT, 185, 447,
	FONT_END, 226, 412,
	FONT_BEGIN, 212, 312,
	FONT_NEXT, 226, 412,
	FONT_END, 261, 389,
	FONT_BEGIN, 212, 312,
	FONT_NEXT, 261, 389,
	FONT_NEXT, 285, 258,
	FONT_END, 290, 371,
	FONT_BEGIN, 290, 371,
	FONT_NEXT, 261, 389,
	FONT_END, 291, 410,
	FONT_BEGIN, 290, 371,
	FONT_NEXT, 291, 410,
	FONT_END, 322, 440,
	FONT_BEGIN, 290, 371,
	FONT_NEXT, 322, 440,
	FONT_NEXT, 333, 395,
	FONT_NEXT, 345, 481,
	FONT_END, 355, 539,
	FONT_BEGIN, 333, 395,
	FONT_NEXT, 355, 539,
	FONT_NEXT, 377, 428,
	FONT_NEXT, 348, 579,
	FONT_NEXT, 378, 633,
	FONT_END, 324, 664,
	FONT_BEGIN, 324, 664,
	FONT_NEXT, 348, 579,
	FONT_END, 327, 614,
	FONT_BEGIN, 324, 664,
	FONT_NEXT, 327, 614,
	FONT_END, 292, 638,
	FONT_BEGIN, 324, 664,
	FONT_NEXT, 292, 638,
	FONT_NEXT, 249, 676,
	FONT_NEXT, 243, 648,
	FONT_NEXT, 183, 665,
	FONT_NEXT, 194, 638,
	FONT_END, 161, 615,
	FONT_BEGIN, 183, 665,
	FONT_NEXT, 161, 615,
	FONT_NEXT, 123, 636,
	FONT_NEXT, 142, 583,
	FONT_END, 136, 547,
	FONT_BEGIN, 123, 636,
	FONT_NEXT, 136, 547,
	FONT_END, 131, 381,
	FONT_BEGIN, 123, 636,
	FONT_NEXT, 131, 381,
	FONT_END, 92, 423,
	FONT_BEGIN, 123, 636,
	FONT_NEXT, 92, 423,
	FONT_NEXT, 79, 587,
	FONT_NEXT, 69, 467,
	FONT_NEXT, 66, 556,
	FONT_END, 62, 521,
	FONT_BEGIN, 56, 146,
	FONT_NEXT, 63, 202,
	FONT_NEXT, 68, 88,
	FONT_NEXT, 87, 246,
	FONT_NEXT, 104, 36,
	FONT_NEXT, 128, 286,
	FONT_NEXT, 132, 156,
	FONT_END, 140, 215,
	FONT_BEGIN, 140, 215,
	FONT_NEXT, 128, 286,
	FONT_NEXT, 160, 258,
	FONT_END, 186, 289,
	FONT_BEGIN, 186, 289,
	FONT_NEXT, 128, 286,
	FONT_END, 186, 332,
	FONT_BEGIN, 186, 289,
	FONT_NEXT, 186, 332,
	FONT_END, 212, 312,
	FONT_BEGIN, 285, 258,
	FONT_NEXT, 290, 371,
	FONT_NEXT, 333, 216,
	FONT_NEXT, 335, 336,
	FONT_NEXT, 360, 174,
	FONT_END, 369, 126,
	FONT_BEGIN, 369, 126,
	FONT_NEXT, 335, 336,
	FONT_END, 370, 305,
	FONT_BEGIN, 369, 126,
	FONT_NEXT, 370, 305,
	FONT_END, 381, 24,
	FONT_BEGIN, 369, 126,
	FONT_NEXT, 381, 24,
	FONT_END, 347, 4,
	FONT_BEGIN, 369, 126,
	FONT_NEXT, 347, 4,
	FONT_NEXT, 360, 78,
	FONT_END, 337, 43,
	FONT_BEGIN, 337, 43,
	FONT_NEXT, 347, 4,
	FONT_END, 302, -10,
	FONT_BEGIN, 337, 43,
	FONT_NEXT, 302, -10,
	FONT_NEXT, 302, 21,
	FONT_END, 259, 14,
	FONT_BEGIN, 259, 14,
	FONT_NEXT, 302, -10,
	FONT_END, 246, -14,
	FONT_BEGIN, 259, 14,
	FONT_NEXT, 246, -14,
	FONT_NEXT, 204, 25,
	FONT_NEXT, 202, -11,
	FONT_NEXT, 165, 56,
	FONT_NEXT, 164, 0,
	FONT_NEXT, 140, 101,
	FONT_NEXT, 104, 36,
	FONT_END, 132, 156,
	FONT_BEGIN, 445, 150,
	FONT_NEXT, 437, 102,
	FONT_NEXT, 439, 199,
	FONT_END, 417, 249,
	FONT_BEGIN, 417, 249,
	FONT_NEXT, 437, 102,
	FONT_END, 407, 48,
	FONT_BEGIN, 417, 249,
	FONT_NEXT, 407, 48,
	FONT_NEXT, 370, 305,
	FONT_END, 381, 24,
	FONT_BEGIN, 424, 534,
	FONT_NEXT, 410, 473,
	FONT_NEXT, 412, 588,
	FONT_END, 378, 633,
	FONT_BEGIN, 378, 633,
	FONT_NEXT, 410, 473,
	FONT_END, 377, 428,
	FONT_BEGIN, 378, 633,
	FONT_END, 377, 428,
	FONT_ADVANCE, 500, 0
    },
    {
	57,
	FONT_BEGIN, 459, 396,
	FONT_NEXT, 452, 317,
	FONT_NEXT, 454, 455,
	FONT_END, 442, 510,
	FONT_BEGIN, 442, 510,
	FONT_NEXT, 452, 317,
	FONT_END, 432, 243,
	FONT_BEGIN, 442, 510,
	FONT_NEXT, 432, 243,
	FONT_NEXT, 422, 557,
	FONT_NEXT, 399, 174,
	FONT_NEXT, 395, 598,
	FONT_NEXT, 354, 113,
	FONT_END, 362, 355,
	FONT_BEGIN, 395, 598,
	FONT_NEXT, 362, 355,
	FONT_NEXT, 363, 631,
	FONT_NEXT, 362, 394,
	FONT_END, 361, 421,
	FONT_BEGIN, 363, 631,
	FONT_NEXT, 361, 421,
	FONT_END, 359, 458,
	FONT_BEGIN, 363, 631,
	FONT_NEXT, 359, 458,
	FONT_END, 345, 543,
	FONT_BEGIN, 363, 631,
	FONT_NEXT, 345, 543,
	FONT_NEXT, 326, 655,
	FONT_NEXT, 329, 583,
	FONT_END, 305, 616,
	FONT_BEGIN, 326, 655,
	FONT_NEXT, 305, 616,
	FONT_NEXT, 284, 670,
	FONT_NEXT, 272, 639,
	FONT_NEXT, 240, 676,
	FONT_NEXT, 229, 648,
	FONT_NEXT, 193, 671,
	FONT_NEXT, 200, 643,
	FONT_END, 176, 632,
	FONT_BEGIN, 193, 671,
	FONT_NEXT, 176, 632,
	FONT_NEXT, 152, 657,
	FONT_NEXT, 144, 591,
	FONT_NEXT, 116, 634,
	FONT_NEXT, 126, 534,
	FONT_END, 122, 473,
	FONT_BEGIN, 116, 634,
	FONT_NEXT, 122, 473,
	FONT_END, 94, 278,
	FONT_BEGIN, 116, 634,
	FONT_NEXT, 94, 278,
	FONT_NEXT, 86, 605,
	FONT_NEXT, 69, 305,
	FONT_NEXT, 62, 569,
	FONT_NEXT, 39, 369,
	FONT_NEXT, 44, 528,
	FONT_END, 30, 435,
	FONT_BEGIN, 56, -2,
	FONT_NEXT, 138, 21,
	FONT_NEXT, 59, -22,
	FONT_END, 149, -9,
	FONT_BEGIN, 149, -9,
	FONT_NEXT, 138, 21,
	FONT_END, 204, 56,
	FONT_BEGIN, 149, -9,
	FONT_NEXT, 204, 56,
	FONT_NEXT, 228, 20,
	FONT_NEXT, 256, 101,
	FONT_END, 296, 149,
	FONT_BEGIN, 228, 20,
	FONT_NEXT, 296, 149,
	FONT_NEXT, 297, 61,
	FONT_NEXT, 324, 197,
	FONT_END, 343, 239,
	FONT_BEGIN, 297, 61,
	FONT_NEXT, 343, 239,
	FONT_NEXT, 354, 113,
	FONT_NEXT, 354, 271,
	FONT_END, 359, 290,
	FONT_BEGIN, 354, 113,
	FONT_NEXT, 359, 290,
	FONT_NEXT, 362, 355,
	FONT_END, 358, 332,
	FONT_BEGIN, 358, 332,
	FONT_NEXT, 359, 290,
	FONT_END, 357, 292,
	FONT_BEGIN, 358, 332,
	FONT_NEXT, 357, 292,
	FONT_NEXT, 346, 315,
	FONT_NEXT, 285, 250,
	FONT_NEXT, 302, 291,
	FONT_END, 250, 280,
	FONT_BEGIN, 250, 280,
	FONT_NEXT, 285, 250,
	FONT_END, 210, 237,
	FONT_BEGIN, 250, 280,
	FONT_NEXT, 210, 237,
	FONT_NEXT, 214, 285,
	FONT_END, 185, 299,
	FONT_BEGIN, 185, 299,
	FONT_NEXT, 210, 237,
	FONT_END, 163, 242,
	FONT_BEGIN, 185, 299,
	FONT_NEXT, 163, 242,
	FONT_NEXT, 146, 348,
	FONT_NEXT, 125, 256,
	FONT_NEXT, 127, 410,
	FONT_END, 122, 473,
	FONT_BEGIN, 122, 473,
	FONT_NEXT, 125, 256,
	FONT_END, 94, 278,
	FONT_BEGIN, 122, 473,
	FONT_END, 94, 278,
	FONT_ADVANCE, 500, 0
    },
    {
	58,
	FONT_BEGIN, 192, 43,
	FONT_NEXT, 186, 18,
	FONT_NEXT, 187, 64,
	FONT_END, 175, 83,
	FONT_BEGIN, 175, 83,
	FONT_NEXT, 186, 18,
	FONT_END, 171, 2,
	FONT_BEGIN, 175, 83,
	FONT_NEXT, 171, 2,
	FONT_NEXT, 157, 95,
	FONT_NEXT, 136, -11,
	FONT_NEXT, 136, 100,
	FONT_END, 114, 95,
	FONT_BEGIN, 114, 95,
	FONT_NEXT, 136, -11,
	FONT_END, 100, 1,
	FONT_BEGIN, 114, 95,
	FONT_NEXT, 100, 1,
	FONT_NEXT, 97, 83,
	FONT_NEXT, 86, 18,
	FONT_NEXT, 85, 65,
	FONT_END, 81, 43,
	FONT_BEGIN, 192, 402,
	FONT_NEXT, 186, 377,
	FONT_NEXT, 187, 423,
	FONT_END, 175, 442,
	FONT_BEGIN, 175, 442,
	FONT_NEXT, 186, 377,
	FONT_END, 171, 361,
	FONT_BEGIN, 175, 442,
	FONT_NEXT, 171, 361,
	FONT_NEXT, 157, 454,
	FONT_NEXT, 136, 348,
	FONT_NEXT, 136, 459,
	FONT_END, 114, 454,
	FONT_BEGIN, 114, 454,
	FONT_NEXT, 136, 348,
	FONT_END, 100, 360,
	FONT_BEGIN, 114, 454,
	FONT_NEXT, 100, 360,
	FONT_NEXT, 97, 442,
	FONT_NEXT, 86, 377,
	FONT_NEXT, 85, 424,
	FONT_END, 81, 402,
	FONT_ADVANCE, 278, 0
    },
    {
	59,
	FONT_BEGIN, 107, -141,
	FONT_NEXT, 98, -122,
	FONT_NEXT, 138, -123,
	FONT_NEXT, 138, -91,
	FONT_END, 163, -61,
	FONT_BEGIN, 138, -123,
	FONT_NEXT, 163, -61,
	FONT_NEXT, 175, -90,
	FONT_NEXT, 176, -35,
	FONT_END, 180, -16,
	FONT_BEGIN, 175, -90,
	FONT_NEXT, 180, -16,
	FONT_NEXT, 206, -45,
	FONT_END, 186, 85,
	FONT_BEGIN, 186, 85,
	FONT_NEXT, 180, -16,
	FONT_NEXT, 160, 98,
	FONT_NEXT, 175, -6,
	FONT_END, 166, -2,
	FONT_BEGIN, 160, 98,
	FONT_NEXT, 166, -2,
	FONT_END, 157, -4,
	FONT_BEGIN, 160, 98,
	FONT_NEXT, 157, -4,
	FONT_NEXT, 139, 102,
	FONT_NEXT, 142, -6,
	FONT_END, 99, 5,
	FONT_BEGIN, 139, 102,
	FONT_NEXT, 99, 5,
	FONT_NEXT, 125, 100,
	FONT_END, 105, 93,
	FONT_BEGIN, 105, 93,
	FONT_NEXT, 99, 5,
	FONT_NEXT, 87, 76,
	FONT_NEXT, 85, 20,
	FONT_END, 80, 44,
	FONT_BEGIN, 219, 6,
	FONT_NEXT, 206, -45,
	FONT_NEXT, 209, 56,
	FONT_END, 186, 85,
	FONT_BEGIN, 192, 402,
	FONT_NEXT, 186, 377,
	FONT_NEXT, 187, 423,
	FONT_END, 175, 442,
	FONT_BEGIN, 175, 442,
	FONT_NEXT, 186, 377,
	FONT_END, 171, 361,
	FONT_BEGIN, 175, 442,
	FONT_NEXT, 171, 361,
	FONT_NEXT, 157, 454,
	FONT_NEXT, 136, 348,
	FONT_NEXT, 136, 459,
	FONT_END, 114, 454,
	FONT_BEGIN, 114, 454,
	FONT_NEXT, 136, 348,
	FONT_END, 100, 360,
	FONT_BEGIN, 114, 454,
	FONT_NEXT, 100, 360,
	FONT_NEXT, 97, 442,
	FONT_NEXT, 86, 377,
	FONT_NEXT, 85, 424,
	FONT_END, 81, 402,
	FONT_ADVANCE, 278, 0
    },
    {
	60,
	FONT_BEGIN, 536, 514,
	FONT_NEXT, 536, 446,
	FONT_NEXT, 28, 284,
	FONT_NEXT, 111, 253,
	FONT_NEXT, 28, 222,
	FONT_END, 536, -8,
	FONT_BEGIN, 536, -8,
	FONT_NEXT, 111, 253,
	FONT_END, 536, 60,
	FONT_BEGIN, 536, -8,
	FONT_END, 536, 60,
	FONT_ADVANCE, 564, 0
    },
    {
	61,
	FONT_BEGIN, 534, 186,
	FONT_NEXT, 534, 120,
	FONT_NEXT, 30, 186,
	FONT_END, 30, 120,
	FONT_BEGIN, 534, 386,
	FONT_NEXT, 534, 320,
	FONT_NEXT, 30, 386,
	FONT_END, 30, 320,
	FONT_ADVANCE, 564, 0
    },
    {
	62,
	FONT_BEGIN, 28, 446,
	FONT_NEXT, 28, 514,
	FONT_NEXT, 453, 253,
	FONT_NEXT, 536, 222,
	FONT_END, 28, -8,
	FONT_BEGIN, 453, 253,
	FONT_NEXT, 28, -8,
	FONT_END, 28, 60,
	FONT_BEGIN, 536, 222,
	FONT_NEXT, 28, 514,
	FONT_END, 536, 284,
	FONT_ADVANCE, 564, 0
    },
    {
	63,
	FONT_BEGIN, 68, 532,
	FONT_NEXT, 72, 567,
	FONT_NEXT, 78, 487,
	FONT_NEXT, 83, 597,
	FONT_NEXT, 93, 474,
	FONT_END, 118, 469,
	FONT_BEGIN, 118, 469,
	FONT_NEXT, 83, 597,
	FONT_END, 119, 585,
	FONT_BEGIN, 118, 469,
	FONT_NEXT, 119, 585,
	FONT_NEXT, 135, 473,
	FONT_END, 148, 483,
	FONT_BEGIN, 148, 483,
	FONT_NEXT, 119, 585,
	FONT_END, 157, 510,
	FONT_BEGIN, 148, 483,
	FONT_END, 157, 510,
	FONT_BEGIN, 414, 510,
	FONT_NEXT, 406, 469,
	FONT_NEXT, 412, 544,
	FONT_END, 406, 571,
	FONT_BEGIN, 406, 571,
	FONT_NEXT, 406, 469,
	FONT_NEXT, 378, 618,
	FONT_NEXT, 387, 426,
	FONT_END, 363, 385,
	FONT_BEGIN, 378, 618,
	FONT_NEXT, 363, 385,
	FONT_NEXT, 352, 639,
	FONT_NEXT, 339, 354,
	FONT_NEXT, 316, 657,
	FONT_NEXT, 322, 519,
	FONT_END, 315, 564,
	FONT_BEGIN, 316, 657,
	FONT_NEXT, 315, 564,
	FONT_NEXT, 274, 671,
	FONT_NEXT, 295, 605,
	FONT_END, 261, 634,
	FONT_BEGIN, 274, 671,
	FONT_NEXT, 261, 634,
	FONT_NEXT, 231, 676,
	FONT_NEXT, 212, 646,
	FONT_NEXT, 176, 667,
	FONT_NEXT, 179, 641,
	FONT_END, 149, 627,
	FONT_BEGIN, 176, 667,
	FONT_NEXT, 149, 627,
	FONT_NEXT, 123, 641,
	FONT_NEXT, 127, 608,
	FONT_END, 119, 585,
	FONT_BEGIN, 123, 641,
	FONT_NEXT, 119, 585,
	FONT_END, 83, 597,
	FONT_BEGIN, 227, 164,
	FONT_NEXT, 239, 251,
	FONT_NEXT, 244, 164,
	FONT_NEXT, 249, 286,
	FONT_NEXT, 257, 220,
	FONT_NEXT, 257, 306,
	FONT_NEXT, 276, 267,
	FONT_NEXT, 285, 370,
	FONT_NEXT, 302, 309,
	FONT_NEXT, 310, 444,
	FONT_END, 322, 519,
	FONT_BEGIN, 302, 309,
	FONT_NEXT, 322, 519,
	FONT_END, 339, 354,
	FONT_BEGIN, 292, 43,
	FONT_NEXT, 286, 19,
	FONT_NEXT, 287, 63,
	FONT_END, 276, 80,
	FONT_BEGIN, 276, 80,
	FONT_NEXT, 286, 19,
	FONT_END, 273, 4,
	FONT_BEGIN, 276, 80,
	FONT_NEXT, 273, 4,
	FONT_NEXT, 258, 92,
	FONT_NEXT, 237, -8,
	FONT_NEXT, 237, 97,
	FONT_END, 216, 92,
	FONT_BEGIN, 216, 92,
	FONT_NEXT, 237, -8,
	FONT_END, 202, 3,
	FONT_BEGIN, 216, 92,
	FONT_NEXT, 202, 3,
	FONT_NEXT, 199, 81,
	FONT_NEXT, 189, 19,
	FONT_NEXT, 188, 64,
	FONT_END, 184, 43,
	FONT_ADVANCE, 444, 0
    },
    {
	64,
	FONT_BEGIN, 321, 268,
	FONT_NEXT, 323, 298,
	FONT_NEXT, 323, 230,
	FONT_END, 332, 200,
	FONT_BEGIN, 332, 200,
	FONT_NEXT, 323, 298,
	FONT_END, 332, 335,
	FONT_BEGIN, 332, 200,
	FONT_NEXT, 332, 335,
	FONT_NEXT, 358, 163,
	FONT_NEXT, 368, 414,
	FONT_NEXT, 390, 147,
	FONT_NEXT, 392, 271,
	FONT_END, 396, 232,
	FONT_BEGIN, 390, 147,
	FONT_NEXT, 396, 232,
	FONT_END, 410, 206,
	FONT_BEGIN, 390, 147,
	FONT_NEXT, 410, 206,
	FONT_NEXT, 417, 144,
	FONT_NEXT, 430, 191,
	FONT_END, 455, 187,
	FONT_BEGIN, 417, 144,
	FONT_NEXT, 455, 187,
	FONT_NEXT, 457, 154,
	FONT_NEXT, 489, 200,
	FONT_NEXT, 492, 174,
	FONT_END, 517, 196,
	FONT_BEGIN, 517, 196,
	FONT_NEXT, 489, 200,
	FONT_END, 524, 240,
	FONT_BEGIN, 517, 196,
	FONT_NEXT, 524, 240,
	FONT_NEXT, 532, 214,
	FONT_END, 534, 214,
	FONT_BEGIN, 534, 214,
	FONT_NEXT, 524, 240,
	FONT_END, 553, 173,
	FONT_BEGIN, 534, 214,
	FONT_NEXT, 553, 173,
	FONT_END, 538, 197,
	FONT_BEGIN, 668, 494,
	FONT_NEXT, 603, 240,
	FONT_NEXT, 599, 494,
	FONT_NEXT, 603, 202,
	FONT_END, 581, 152,
	FONT_BEGIN, 599, 494,
	FONT_NEXT, 581, 152,
	FONT_NEXT, 589, 456,
	FONT_NEXT, 572, 399,
	FONT_NEXT, 565, 491,
	FONT_NEXT, 569, 426,
	FONT_END, 561, 447,
	FONT_BEGIN, 565, 491,
	FONT_NEXT, 561, 447,
	FONT_NEXT, 546, 503,
	FONT_NEXT, 548, 459,
	FONT_END, 529, 464,
	FONT_BEGIN, 546, 503,
	FONT_NEXT, 529, 464,
	FONT_NEXT, 518, 508,
	FONT_NEXT, 487, 450,
	FONT_NEXT, 470, 500,
	FONT_NEXT, 442, 412,
	FONT_NEXT, 430, 480,
	FONT_NEXT, 406, 352,
	FONT_NEXT, 396, 450,
	FONT_NEXT, 395, 314,
	FONT_NEXT, 368, 414,
	FONT_END, 392, 271,
	FONT_BEGIN, 116, 315,
	FONT_NEXT, 123, 392,
	FONT_NEXT, 121, 262,
	FONT_END, 137, 207,
	FONT_BEGIN, 137, 207,
	FONT_NEXT, 123, 392,
	FONT_END, 145, 462,
	FONT_BEGIN, 137, 207,
	FONT_NEXT, 145, 462,
	FONT_NEXT, 165, 152,
	FONT_NEXT, 179, 524,
	FONT_NEXT, 200, 305,
	FONT_END, 205, 383,
	FONT_BEGIN, 205, 383,
	FONT_NEXT, 179, 524,
	FONT_NEXT, 222, 451,
	FONT_NEXT, 224, 576,
	FONT_NEXT, 248, 510,
	FONT_NEXT, 278, 618,
	FONT_NEXT, 283, 558,
	FONT_END, 324, 595,
	FONT_BEGIN, 324, 595,
	FONT_NEXT, 278, 618,
	FONT_END, 340, 649,
	FONT_BEGIN, 324, 595,
	FONT_NEXT, 340, 649,
	FONT_NEXT, 372, 623,
	FONT_NEXT, 408, 669,
	FONT_NEXT, 424, 639,
	FONT_END, 481, 645,
	FONT_BEGIN, 481, 645,
	FONT_NEXT, 408, 669,
	FONT_END, 481, 676,
	FONT_BEGIN, 481, 645,
	FONT_NEXT, 481, 676,
	FONT_NEXT, 545, 638,
	FONT_NEXT, 547, 670,
	FONT_NEXT, 603, 619,
	FONT_NEXT, 609, 653,
	FONT_NEXT, 652, 591,
	FONT_NEXT, 665, 627,
	FONT_NEXT, 693, 555,
	FONT_NEXT, 714, 591,
	FONT_NEXT, 726, 513,
	FONT_END, 749, 469,
	FONT_BEGIN, 749, 469,
	FONT_NEXT, 714, 591,
	FONT_END, 753, 548,
	FONT_BEGIN, 749, 469,
	FONT_NEXT, 753, 548,
	FONT_NEXT, 764, 424,
	FONT_END, 769, 380,
	FONT_BEGIN, 769, 380,
	FONT_NEXT, 753, 548,
	FONT_END, 783, 498,
	FONT_BEGIN, 769, 380,
	FONT_NEXT, 783, 498,
	FONT_END, 760, 223,
	FONT_BEGIN, 769, 380,
	FONT_NEXT, 760, 223,
	FONT_NEXT, 760, 311,
	FONT_END, 734, 245,
	FONT_BEGIN, 734, 245,
	FONT_NEXT, 760, 223,
	FONT_END, 734, 191,
	FONT_BEGIN, 734, 245,
	FONT_NEXT, 734, 191,
	FONT_NEXT, 693, 195,
	FONT_NEXT, 702, 165,
	FONT_END, 665, 149,
	FONT_BEGIN, 693, 195,
	FONT_NEXT, 665, 149,
	FONT_NEXT, 667, 181,
	FONT_END, 639, 176,
	FONT_BEGIN, 639, 176,
	FONT_NEXT, 665, 149,
	FONT_END, 623, 143,
	FONT_BEGIN, 639, 176,
	FONT_NEXT, 623, 143,
	FONT_NEXT, 613, 183,
	FONT_NEXT, 581, 152,
	FONT_END, 603, 202,
	FONT_BEGIN, 700, 43,
	FONT_NEXT, 601, 3,
	FONT_NEXT, 688, 73,
	FONT_END, 601, 39,
	FONT_BEGIN, 601, 39,
	FONT_NEXT, 601, 3,
	FONT_NEXT, 550, 28,
	FONT_NEXT, 547, -10,
	FONT_NEXT, 490, 25,
	FONT_NEXT, 491, -14,
	FONT_END, 399, -6,
	FONT_BEGIN, 490, 25,
	FONT_NEXT, 399, -6,
	FONT_NEXT, 427, 31,
	FONT_END, 371, 48,
	FONT_BEGIN, 371, 48,
	FONT_NEXT, 399, -6,
	FONT_END, 322, 18,
	FONT_BEGIN, 371, 48,
	FONT_NEXT, 322, 18,
	FONT_NEXT, 321, 75,
	FONT_NEXT, 257, 54,
	FONT_NEXT, 279, 111,
	FONT_END, 245, 153,
	FONT_BEGIN, 245, 153,
	FONT_NEXT, 257, 54,
	FONT_END, 205, 100,
	FONT_BEGIN, 245, 153,
	FONT_NEXT, 205, 100,
	FONT_NEXT, 220, 200,
	FONT_END, 205, 251,
	FONT_BEGIN, 205, 251,
	FONT_NEXT, 205, 100,
	FONT_NEXT, 200, 305,
	FONT_END, 165, 152,
	FONT_BEGIN, 809, 381,
	FONT_NEXT, 796, 300,
	FONT_NEXT, 802, 442,
	FONT_END, 783, 498,
	FONT_BEGIN, 783, 498,
	FONT_NEXT, 796, 300,
	FONT_END, 760, 223,
	FONT_BEGIN, 783, 498,
	FONT_END, 760, 223,
	FONT_BEGIN, 524, 240,
	FONT_NEXT, 554, 306,
	FONT_NEXT, 553, 173,
	FONT_NEXT, 572, 399,
	FONT_END, 581, 152,
	FONT_ADVANCE, 921, 0
    },
    {
	65,
	FONT_BEGIN, 451, 19,
	FONT_NEXT, 499, 24,
	FONT_NEXT, 451, 0,
	FONT_END, 637, 62,
	FONT_BEGIN, 637, 62,
	FONT_NEXT, 499, 24,
	FONT_END, 515, 35,
	FONT_BEGIN, 637, 62,
	FONT_NEXT, 515, 35,
	FONT_NEXT, 616, 106,
	FONT_NEXT, 521, 57,
	FONT_NEXT, 367, 674,
	FONT_NEXT, 502, 120,
	FONT_END, 461, 216,
	FONT_BEGIN, 367, 674,
	FONT_NEXT, 461, 216,
	FONT_END, 447, 257,
	FONT_BEGIN, 367, 674,
	FONT_NEXT, 447, 257,
	FONT_END, 331, 532,
	FONT_BEGIN, 367, 674,
	FONT_NEXT, 331, 532,
	FONT_NEXT, 347, 674,
	FONT_END, 139, 183,
	FONT_BEGIN, 139, 183,
	FONT_NEXT, 331, 532,
	FONT_END, 216, 257,
	FONT_BEGIN, 139, 183,
	FONT_NEXT, 216, 257,
	FONT_END, 199, 216,
	FONT_BEGIN, 139, 183,
	FONT_NEXT, 199, 216,
	FONT_END, 153, 99,
	FONT_BEGIN, 139, 183,
	FONT_NEXT, 153, 99,
	FONT_END, 145, 61,
	FONT_BEGIN, 139, 183,
	FONT_NEXT, 145, 61,
	FONT_NEXT, 104, 104,
	FONT_END, 84, 67,
	FONT_BEGIN, 84, 67,
	FONT_NEXT, 145, 61,
	FONT_NEXT, 66, 41,
	FONT_NEXT, 15, 0,
	FONT_NEXT, 39, 23,
	FONT_END, 15, 19,
	FONT_BEGIN, 706, 19,
	FONT_NEXT, 706, 0,
	FONT_NEXT, 677, 23,
	FONT_NEXT, 451, 0,
	FONT_NEXT, 656, 36,
	FONT_END, 637, 62,
	FONT_BEGIN, 216, 257,
	FONT_NEXT, 447, 257,
	FONT_NEXT, 199, 216,
	FONT_END, 461, 216,
	FONT_BEGIN, 213, 19,
	FONT_NEXT, 213, 0,
	FONT_NEXT, 171, 24,
	FONT_NEXT, 15, 0,
	FONT_NEXT, 152, 36,
	FONT_END, 145, 61,
	FONT_ADVANCE, 722, 0
    },
    {
	66,
	FONT_BEGIN, 17, 19,
	FONT_NEXT, 67, 23,
	FONT_NEXT, 17, 0,
	FONT_END, 215, 78,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 67, 23,
	FONT_END, 96, 38,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 96, 38,
	FONT_END, 109, 65,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 109, 65,
	FONT_END, 113, 109,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 113, 109,
	FONT_END, 113, 553,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 113, 553,
	FONT_END, 109, 597,
	FONT_BEGIN, 215, 78,
	FONT_NEXT, 109, 597,
	FONT_NEXT, 215, 326,
	FONT_END, 215, 365,
	FONT_BEGIN, 215, 365,
	FONT_NEXT, 109, 597,
	FONT_NEXT, 215, 595,
	FONT_NEXT, 95, 624,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 66, 637,
	FONT_END, 17, 643,
	FONT_BEGIN, 215, 326,
	FONT_NEXT, 215, 365,
	FONT_NEXT, 276, 325,
	FONT_NEXT, 310, 366,
	FONT_NEXT, 319, 322,
	FONT_NEXT, 344, 368,
	FONT_NEXT, 377, 311,
	FONT_NEXT, 394, 381,
	FONT_NEXT, 414, 295,
	FONT_NEXT, 426, 347,
	FONT_NEXT, 447, 270,
	FONT_END, 469, 232,
	FONT_BEGIN, 469, 232,
	FONT_NEXT, 426, 347,
	FONT_END, 488, 327,
	FONT_BEGIN, 469, 232,
	FONT_NEXT, 488, 327,
	FONT_NEXT, 478, 180,
	FONT_NEXT, 482, 22,
	FONT_NEXT, 472, 135,
	FONT_NEXT, 425, 6,
	FONT_NEXT, 458, 101,
	FONT_END, 436, 75,
	FONT_BEGIN, 436, 75,
	FONT_NEXT, 425, 6,
	FONT_NEXT, 409, 58,
	FONT_NEXT, 351, 0,
	FONT_NEXT, 348, 40,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 291, 37,
	FONT_END, 254, 38,
	FONT_BEGIN, 254, 38,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 231, 43,
	FONT_END, 218, 55,
	FONT_BEGIN, 218, 55,
	FONT_NEXT, 17, 0,
	FONT_END, 215, 78,
	FONT_BEGIN, 218, 55,
	FONT_END, 215, 78,
	FONT_BEGIN, 215, 595,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 218, 615,
	FONT_END, 237, 624,
	FONT_BEGIN, 237, 624,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 255, 624,
	FONT_END, 282, 625,
	FONT_BEGIN, 282, 625,
	FONT_NEXT, 17, 662,
	FONT_END, 297, 662,
	FONT_BEGIN, 282, 625,
	FONT_NEXT, 297, 662,
	FONT_NEXT, 339, 620,
	FONT_NEXT, 374, 657,
	FONT_NEXT, 396, 600,
	FONT_END, 420, 582,
	FONT_BEGIN, 420, 582,
	FONT_NEXT, 374, 657,
	FONT_NEXT, 439, 558,
	FONT_NEXT, 460, 635,
	FONT_NEXT, 452, 527,
	FONT_END, 457, 487,
	FONT_BEGIN, 457, 487,
	FONT_NEXT, 460, 635,
	FONT_END, 465, 360,
	FONT_BEGIN, 457, 487,
	FONT_NEXT, 465, 360,
	FONT_NEXT, 451, 447,
	FONT_NEXT, 426, 349,
	FONT_NEXT, 437, 417,
	FONT_END, 394, 381,
	FONT_BEGIN, 394, 381,
	FONT_NEXT, 426, 349,
	FONT_END, 426, 347,
	FONT_BEGIN, 394, 381,
	FONT_END, 426, 347,
	FONT_BEGIN, 559, 493,
	FONT_NEXT, 555, 455,
	FONT_NEXT, 551, 544,
	FONT_NEXT, 544, 425,
	FONT_NEXT, 530, 584,
	FONT_NEXT, 509, 383,
	FONT_NEXT, 499, 614,
	FONT_NEXT, 465, 360,
	FONT_END, 460, 635,
	FONT_BEGIN, 593, 176,
	FONT_NEXT, 586, 132,
	FONT_NEXT, 589, 212,
	FONT_END, 579, 244,
	FONT_BEGIN, 579, 244,
	FONT_NEXT, 586, 132,
	FONT_END, 574, 103,
	FONT_BEGIN, 579, 244,
	FONT_NEXT, 574, 103,
	FONT_NEXT, 542, 294,
	FONT_NEXT, 555, 73,
	FONT_END, 525, 45,
	FONT_BEGIN, 542, 294,
	FONT_NEXT, 525, 45,
	FONT_NEXT, 488, 327,
	FONT_END, 482, 22,
	FONT_ADVANCE, 667, 0
    },
    {
	67,
	FONT_BEGIN, 620, 451,
	FONT_NEXT, 597, 451,
	FONT_NEXT, 611, 676,
	FONT_END, 590, 676,
	FONT_BEGIN, 590, 676,
	FONT_NEXT, 597, 451,
	FONT_END, 569, 524,
	FONT_BEGIN, 590, 676,
	FONT_NEXT, 569, 524,
	FONT_NEXT, 580, 656,
	FONT_END, 565, 647,
	FONT_BEGIN, 565, 647,
	FONT_NEXT, 569, 524,
	FONT_END, 523, 582,
	FONT_BEGIN, 565, 647,
	FONT_NEXT, 523, 582,
	FONT_NEXT, 544, 643,
	FONT_END, 519, 648,
	FONT_BEGIN, 519, 648,
	FONT_NEXT, 523, 582,
	FONT_END, 459, 621,
	FONT_BEGIN, 519, 648,
	FONT_NEXT, 459, 621,
	FONT_NEXT, 481, 659,
	FONT_END, 429, 670,
	FONT_BEGIN, 429, 670,
	FONT_NEXT, 459, 621,
	FONT_END, 420, 632,
	FONT_BEGIN, 429, 670,
	FONT_NEXT, 420, 632,
	FONT_NEXT, 368, 676,
	FONT_NEXT, 377, 636,
	FONT_END, 299, 620,
	FONT_BEGIN, 368, 676,
	FONT_NEXT, 299, 620,
	FONT_NEXT, 304, 670,
	FONT_END, 242, 653,
	FONT_BEGIN, 242, 653,
	FONT_NEXT, 299, 620,
	FONT_END, 261, 601,
	FONT_BEGIN, 242, 653,
	FONT_NEXT, 261, 601,
	FONT_END, 227, 575,
	FONT_BEGIN, 242, 653,
	FONT_NEXT, 227, 575,
	FONT_NEXT, 184, 625,
	FONT_NEXT, 197, 540,
	FONT_END, 170, 491,
	FONT_BEGIN, 184, 625,
	FONT_NEXT, 170, 491,
	FONT_NEXT, 133, 587,
	FONT_NEXT, 151, 422,
	FONT_END, 144, 329,
	FONT_BEGIN, 133, 587,
	FONT_NEXT, 144, 329,
	FONT_END, 134, 65,
	FONT_BEGIN, 133, 587,
	FONT_NEXT, 134, 65,
	FONT_END, 91, 112,
	FONT_BEGIN, 133, 587,
	FONT_NEXT, 91, 112,
	FONT_NEXT, 90, 538,
	FONT_NEXT, 57, 172,
	FONT_NEXT, 56, 479,
	FONT_NEXT, 35, 244,
	FONT_NEXT, 35, 410,
	FONT_END, 28, 331,
	FONT_BEGIN, 633, 113,
	FONT_NEXT, 628, 106,
	FONT_NEXT, 615, 131,
	FONT_NEXT, 616, 92,
	FONT_END, 595, 71,
	FONT_BEGIN, 615, 131,
	FONT_NEXT, 595, 71,
	FONT_NEXT, 583, 102,
	FONT_NEXT, 566, 48,
	FONT_NEXT, 536, 69,
	FONT_NEXT, 528, 25,
	FONT_NEXT, 471, 41,
	FONT_NEXT, 481, 5,
	FONT_END, 426, -9,
	FONT_BEGIN, 471, 41,
	FONT_NEXT, 426, -9,
	FONT_NEXT, 389, 30,
	FONT_NEXT, 362, -14,
	FONT_NEXT, 342, 34,
	FONT_NEXT, 301, -10,
	FONT_NEXT, 297, 46,
	FONT_NEXT, 241, 4,
	FONT_NEXT, 256, 68,
	FONT_END, 219, 100,
	FONT_BEGIN, 219, 100,
	FONT_NEXT, 241, 4,
	FONT_END, 185, 29,
	FONT_BEGIN, 219, 100,
	FONT_NEXT, 185, 29,
	FONT_NEXT, 188, 141,
	FONT_END, 164, 192,
	FONT_BEGIN, 164, 192,
	FONT_NEXT, 185, 29,
	FONT_END, 134, 65,
	FONT_BEGIN, 164, 192,
	FONT_NEXT, 134, 65,
	FONT_NEXT, 149, 255,
	FONT_END, 144, 329,
	FONT_ADVANCE, 667, 0
    },
    {
	68,
	FONT_BEGIN, 16, 643,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 62, 636,
	FONT_END, 88, 623,
	FONT_BEGIN, 88, 623,
	FONT_NEXT, 16, 662,
	FONT_END, 206, 586,
	FONT_BEGIN, 88, 623,
	FONT_NEXT, 206, 586,
	FONT_NEXT, 101, 597,
	FONT_NEXT, 206, 78,
	FONT_NEXT, 104, 553,
	FONT_END, 104, 109,
	FONT_BEGIN, 104, 109,
	FONT_NEXT, 206, 78,
	FONT_NEXT, 100, 65,
	FONT_END, 88, 39,
	FONT_BEGIN, 88, 39,
	FONT_NEXT, 206, 78,
	FONT_NEXT, 61, 24,
	FONT_NEXT, 16, 0,
	FONT_END, 16, 19,
	FONT_BEGIN, 685, 329,
	FONT_NEXT, 681, 276,
	FONT_NEXT, 677, 407,
	FONT_NEXT, 667, 221,
	FONT_NEXT, 656, 475,
	FONT_NEXT, 643, 166,
	FONT_NEXT, 622, 532,
	FONT_NEXT, 607, 114,
	FONT_NEXT, 575, 579,
	FONT_NEXT, 576, 328,
	FONT_END, 571, 390,
	FONT_BEGIN, 575, 579,
	FONT_NEXT, 571, 390,
	FONT_NEXT, 517, 615,
	FONT_NEXT, 555, 449,
	FONT_END, 526, 505,
	FONT_BEGIN, 517, 615,
	FONT_NEXT, 526, 505,
	FONT_END, 483, 555,
	FONT_BEGIN, 517, 615,
	FONT_NEXT, 483, 555,
	FONT_NEXT, 449, 641,
	FONT_NEXT, 444, 584,
	FONT_NEXT, 372, 656,
	FONT_NEXT, 397, 606,
	FONT_END, 335, 620,
	FONT_BEGIN, 372, 656,
	FONT_NEXT, 335, 620,
	FONT_NEXT, 286, 662,
	FONT_NEXT, 253, 625,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 225, 621,
	FONT_END, 211, 613,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 211, 613,
	FONT_END, 206, 586,
	FONT_BEGIN, 206, 78,
	FONT_NEXT, 208, 57,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 218, 44,
	FONT_END, 236, 38,
	FONT_BEGIN, 16, 0,
	FONT_NEXT, 236, 38,
	FONT_END, 266, 37,
	FONT_BEGIN, 16, 0,
	FONT_NEXT, 266, 37,
	FONT_END, 297, 37,
	FONT_BEGIN, 16, 0,
	FONT_NEXT, 297, 37,
	FONT_NEXT, 300, 0,
	FONT_NEXT, 341, 41,
	FONT_END, 392, 52,
	FONT_BEGIN, 300, 0,
	FONT_NEXT, 392, 52,
	FONT_NEXT, 404, 8,
	FONT_NEXT, 445, 73,
	FONT_NEXT, 489, 32,
	FONT_NEXT, 494, 108,
	FONT_END, 536, 159,
	FONT_BEGIN, 489, 32,
	FONT_NEXT, 536, 159,
	FONT_NEXT, 556, 69,
	FONT_NEXT, 565, 231,
	FONT_END, 573, 276,
	FONT_BEGIN, 556, 69,
	FONT_NEXT, 573, 276,
	FONT_NEXT, 607, 114,
	FONT_END, 576, 328,
	FONT_ADVANCE, 722, 0
    },
    {
	69,
	FONT_BEGIN, 12, 19,
	FONT_NEXT, 52, 23,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 79, 36,
	FONT_NEXT, 201, 80,
	FONT_NEXT, 94, 63,
	FONT_END, 99, 109,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 99, 109,
	FONT_END, 99, 553,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 99, 553,
	FONT_END, 94, 599,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 201, 328,
	FONT_NEXT, 201, 368,
	FONT_NEXT, 355, 326,
	FONT_NEXT, 355, 368,
	FONT_NEXT, 405, 321,
	FONT_NEXT, 408, 372,
	FONT_NEXT, 436, 308,
	FONT_NEXT, 439, 388,
	FONT_NEXT, 454, 279,
	FONT_NEXT, 455, 418,
	FONT_NEXT, 465, 231,
	FONT_NEXT, 465, 463,
	FONT_NEXT, 488, 231,
	FONT_END, 488, 463,
	FONT_BEGIN, 597, 169,
	FONT_NEXT, 552, 0,
	FONT_NEXT, 569, 169,
	FONT_END, 533, 105,
	FONT_BEGIN, 533, 105,
	FONT_NEXT, 552, 0,
	FONT_NEXT, 489, 65,
	FONT_END, 430, 44,
	FONT_BEGIN, 430, 44,
	FONT_NEXT, 552, 0,
	FONT_END, 12, 0,
	FONT_BEGIN, 430, 44,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 350, 38,
	FONT_END, 300, 38,
	FONT_BEGIN, 300, 38,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 263, 38,
	FONT_END, 237, 40,
	FONT_BEGIN, 237, 40,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 219, 43,
	FONT_END, 203, 56,
	FONT_BEGIN, 203, 56,
	FONT_NEXT, 12, 0,
	FONT_END, 201, 80,
	FONT_BEGIN, 203, 56,
	FONT_END, 201, 80,
	FONT_BEGIN, 12, 643,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 52, 637,
	FONT_END, 79, 625,
	FONT_BEGIN, 79, 625,
	FONT_NEXT, 12, 662,
	FONT_END, 201, 590,
	FONT_BEGIN, 79, 625,
	FONT_NEXT, 201, 590,
	FONT_NEXT, 94, 599,
	FONT_END, 201, 368,
	FONT_BEGIN, 546, 519,
	FONT_NEXT, 521, 519,
	FONT_NEXT, 543, 662,
	FONT_NEXT, 506, 572,
	FONT_END, 481, 604,
	FONT_BEGIN, 543, 662,
	FONT_NEXT, 481, 604,
	FONT_END, 437, 620,
	FONT_BEGIN, 543, 662,
	FONT_NEXT, 437, 620,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 369, 624,
	FONT_END, 234, 624,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 234, 624,
	FONT_END, 209, 619,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 209, 619,
	FONT_END, 203, 609,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 203, 609,
	FONT_END, 201, 590,
	FONT_ADVANCE, 611, 0
    },
    {
	70,
	FONT_BEGIN, 12, 643,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 52, 637,
	FONT_END, 79, 625,
	FONT_BEGIN, 79, 625,
	FONT_NEXT, 12, 662,
	FONT_END, 201, 590,
	FONT_BEGIN, 79, 625,
	FONT_NEXT, 201, 590,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 201, 368,
	FONT_END, 201, 328,
	FONT_BEGIN, 94, 599,
	FONT_NEXT, 201, 328,
	FONT_END, 201, 109,
	FONT_BEGIN, 94, 599,
	FONT_NEXT, 201, 109,
	FONT_NEXT, 99, 553,
	FONT_END, 99, 120,
	FONT_BEGIN, 99, 120,
	FONT_NEXT, 201, 109,
	FONT_NEXT, 95, 70,
	FONT_END, 83, 40,
	FONT_BEGIN, 83, 40,
	FONT_NEXT, 201, 109,
	FONT_NEXT, 57, 24,
	FONT_NEXT, 205, 63,
	FONT_END, 12, 0,
	FONT_BEGIN, 57, 24,
	FONT_NEXT, 12, 0,
	FONT_END, 12, 19,
	FONT_BEGIN, 546, 519,
	FONT_NEXT, 521, 519,
	FONT_NEXT, 543, 662,
	FONT_NEXT, 506, 572,
	FONT_END, 481, 604,
	FONT_BEGIN, 543, 662,
	FONT_NEXT, 481, 604,
	FONT_END, 437, 620,
	FONT_BEGIN, 543, 662,
	FONT_NEXT, 437, 620,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 369, 624,
	FONT_END, 233, 624,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 233, 624,
	FONT_END, 207, 618,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 207, 618,
	FONT_END, 202, 607,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 202, 607,
	FONT_END, 201, 590,
	FONT_BEGIN, 479, 463,
	FONT_NEXT, 479, 231,
	FONT_NEXT, 456, 463,
	FONT_NEXT, 456, 231,
	FONT_NEXT, 446, 416,
	FONT_NEXT, 444, 281,
	FONT_NEXT, 428, 387,
	FONT_NEXT, 425, 309,
	FONT_NEXT, 396, 372,
	FONT_NEXT, 393, 322,
	FONT_NEXT, 346, 368,
	FONT_NEXT, 346, 326,
	FONT_NEXT, 201, 368,
	FONT_END, 201, 328,
	FONT_BEGIN, 292, 19,
	FONT_NEXT, 292, 0,
	FONT_NEXT, 247, 23,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 219, 37,
	FONT_END, 205, 63,
	FONT_ADVANCE, 556, 0
    },
    {
	71,
	FONT_BEGIN, 630, 465,
	FONT_NEXT, 607, 465,
	FONT_NEXT, 622, 676,
	FONT_END, 600, 676,
	FONT_BEGIN, 600, 676,
	FONT_NEXT, 607, 465,
	FONT_END, 581, 522,
	FONT_BEGIN, 600, 676,
	FONT_NEXT, 581, 522,
	FONT_NEXT, 591, 659,
	FONT_END, 577, 649,
	FONT_BEGIN, 577, 649,
	FONT_NEXT, 581, 522,
	FONT_END, 539, 577,
	FONT_BEGIN, 577, 649,
	FONT_NEXT, 539, 577,
	FONT_NEXT, 553, 643,
	FONT_END, 525, 648,
	FONT_BEGIN, 525, 648,
	FONT_NEXT, 539, 577,
	FONT_END, 477, 619,
	FONT_BEGIN, 525, 648,
	FONT_NEXT, 477, 619,
	FONT_NEXT, 489, 659,
	FONT_END, 440, 670,
	FONT_BEGIN, 440, 670,
	FONT_NEXT, 477, 619,
	FONT_END, 436, 631,
	FONT_BEGIN, 440, 670,
	FONT_NEXT, 436, 631,
	FONT_NEXT, 374, 676,
	FONT_NEXT, 388, 636,
	FONT_END, 310, 622,
	FONT_BEGIN, 374, 676,
	FONT_NEXT, 310, 622,
	FONT_NEXT, 298, 668,
	FONT_NEXT, 269, 602,
	FONT_NEXT, 231, 647,
	FONT_NEXT, 231, 572,
	FONT_NEXT, 172, 614,
	FONT_NEXT, 197, 531,
	FONT_END, 170, 476,
	FONT_BEGIN, 172, 614,
	FONT_NEXT, 170, 476,
	FONT_NEXT, 123, 571,
	FONT_NEXT, 152, 406,
	FONT_END, 146, 320,
	FONT_BEGIN, 123, 571,
	FONT_NEXT, 146, 320,
	FONT_END, 115, 93,
	FONT_BEGIN, 123, 571,
	FONT_NEXT, 115, 93,
	FONT_NEXT, 84, 520,
	FONT_NEXT, 79, 137,
	FONT_NEXT, 55, 464,
	FONT_NEXT, 53, 189,
	FONT_NEXT, 38, 403,
	FONT_NEXT, 37, 255,
	FONT_END, 32, 341,
	FONT_BEGIN, 454, 336,
	FONT_NEXT, 454, 354,
	FONT_NEXT, 496, 331,
	FONT_END, 523, 320,
	FONT_BEGIN, 523, 320,
	FONT_NEXT, 454, 354,
	FONT_END, 643, 300,
	FONT_BEGIN, 523, 320,
	FONT_NEXT, 643, 300,
	FONT_END, 639, 259,
	FONT_BEGIN, 523, 320,
	FONT_NEXT, 639, 259,
	FONT_NEXT, 537, 295,
	FONT_NEXT, 639, 58,
	FONT_END, 633, 50,
	FONT_BEGIN, 537, 295,
	FONT_NEXT, 633, 50,
	FONT_END, 616, 40,
	FONT_BEGIN, 537, 295,
	FONT_NEXT, 616, 40,
	FONT_NEXT, 542, 247,
	FONT_NEXT, 558, 16,
	FONT_NEXT, 542, 85,
	FONT_END, 530, 60,
	FONT_BEGIN, 530, 60,
	FONT_NEXT, 558, 16,
	FONT_END, 480, -5,
	FONT_BEGIN, 530, 60,
	FONT_NEXT, 480, -5,
	FONT_NEXT, 499, 42,
	FONT_END, 455, 30,
	FONT_BEGIN, 455, 30,
	FONT_NEXT, 480, -5,
	FONT_END, 396, -14,
	FONT_BEGIN, 455, 30,
	FONT_NEXT, 396, -14,
	FONT_NEXT, 405, 26,
	FONT_END, 349, 31,
	FONT_BEGIN, 349, 31,
	FONT_NEXT, 396, -14,
	FONT_END, 320, -9,
	FONT_BEGIN, 349, 31,
	FONT_NEXT, 320, -9,
	FONT_NEXT, 299, 46,
	FONT_NEXT, 245, 10,
	FONT_NEXT, 254, 71,
	FONT_END, 217, 105,
	FONT_BEGIN, 217, 105,
	FONT_NEXT, 245, 10,
	FONT_END, 174, 43,
	FONT_BEGIN, 217, 105,
	FONT_NEXT, 174, 43,
	FONT_NEXT, 187, 147,
	FONT_END, 164, 197,
	FONT_BEGIN, 164, 197,
	FONT_NEXT, 174, 43,
	FONT_END, 115, 93,
	FONT_BEGIN, 164, 197,
	FONT_NEXT, 115, 93,
	FONT_NEXT, 150, 255,
	FONT_END, 146, 320,
	FONT_BEGIN, 709, 354,
	FONT_NEXT, 709, 336,
	FONT_NEXT, 454, 354,
	FONT_NEXT, 679, 332,
	FONT_END, 657, 322,
	FONT_BEGIN, 454, 354,
	FONT_NEXT, 657, 322,
	FONT_END, 643, 300,
	FONT_ADVANCE, 722, 0
    },
    {
	72,
	FONT_BEGIN, 19, 643,
	FONT_NEXT, 19, 662,
	FONT_NEXT, 63, 636,
	FONT_END, 90, 623,
	FONT_BEGIN, 90, 623,
	FONT_NEXT, 19, 662,
	FONT_END, 212, 596,
	FONT_BEGIN, 90, 623,
	FONT_NEXT, 212, 596,
	FONT_END, 209, 553,
	FONT_BEGIN, 90, 623,
	FONT_NEXT, 209, 553,
	FONT_NEXT, 103, 597,
	FONT_NEXT, 209, 359,
	FONT_END, 209, 315,
	FONT_BEGIN, 103, 597,
	FONT_NEXT, 209, 315,
	FONT_END, 209, 109,
	FONT_BEGIN, 103, 597,
	FONT_NEXT, 209, 109,
	FONT_NEXT, 107, 553,
	FONT_END, 107, 120,
	FONT_BEGIN, 107, 120,
	FONT_NEXT, 209, 109,
	FONT_NEXT, 105, 73,
	FONT_END, 94, 42,
	FONT_BEGIN, 94, 42,
	FONT_NEXT, 209, 109,
	FONT_NEXT, 68, 25,
	FONT_NEXT, 211, 67,
	FONT_END, 19, 0,
	FONT_BEGIN, 68, 25,
	FONT_NEXT, 19, 0,
	FONT_END, 19, 19,
	FONT_BEGIN, 297, 662,
	FONT_NEXT, 297, 643,
	FONT_NEXT, 19, 662,
	FONT_NEXT, 251, 636,
	FONT_END, 224, 622,
	FONT_BEGIN, 19, 662,
	FONT_NEXT, 224, 622,
	FONT_END, 212, 596,
	FONT_BEGIN, 424, 643,
	FONT_NEXT, 424, 662,
	FONT_NEXT, 468, 636,
	FONT_END, 495, 623,
	FONT_BEGIN, 495, 623,
	FONT_NEXT, 424, 662,
	FONT_END, 617, 596,
	FONT_BEGIN, 495, 623,
	FONT_NEXT, 617, 596,
	FONT_END, 614, 553,
	FONT_BEGIN, 495, 623,
	FONT_NEXT, 614, 553,
	FONT_NEXT, 508, 597,
	FONT_NEXT, 614, 109,
	FONT_NEXT, 512, 553,
	FONT_NEXT, 512, 120,
	FONT_NEXT, 512, 359,
	FONT_NEXT, 512, 315,
	FONT_NEXT, 209, 359,
	FONT_END, 209, 315,
	FONT_BEGIN, 702, 662,
	FONT_NEXT, 702, 643,
	FONT_NEXT, 424, 662,
	FONT_NEXT, 656, 636,
	FONT_END, 629, 622,
	FONT_BEGIN, 424, 662,
	FONT_NEXT, 629, 622,
	FONT_END, 617, 596,
	FONT_BEGIN, 424, 19,
	FONT_NEXT, 473, 25,
	FONT_NEXT, 424, 0,
	FONT_END, 616, 67,
	FONT_BEGIN, 616, 67,
	FONT_NEXT, 473, 25,
	FONT_NEXT, 614, 109,
	FONT_NEXT, 499, 42,
	FONT_END, 510, 73,
	FONT_BEGIN, 614, 109,
	FONT_NEXT, 510, 73,
	FONT_END, 512, 120,
	FONT_BEGIN, 702, 19,
	FONT_NEXT, 702, 0,
	FONT_NEXT, 655, 25,
	FONT_NEXT, 424, 0,
	FONT_NEXT, 628, 41,
	FONT_END, 616, 67,
	FONT_BEGIN, 297, 19,
	FONT_NEXT, 297, 0,
	FONT_NEXT, 250, 25,
	FONT_NEXT, 19, 0,
	FONT_NEXT, 223, 41,
	FONT_END, 211, 67,
	FONT_ADVANCE, 722, 0
    },
    {
	73,
	FONT_BEGIN, 18, 643,
	FONT_NEXT, 18, 662,
	FONT_NEXT, 68, 637,
	FONT_END, 97, 624,
	FONT_BEGIN, 97, 624,
	FONT_NEXT, 18, 662,
	FONT_END, 222, 600,
	FONT_BEGIN, 97, 624,
	FONT_NEXT, 222, 600,
	FONT_END, 217, 553,
	FONT_BEGIN, 97, 624,
	FONT_NEXT, 217, 553,
	FONT_NEXT, 111, 597,
	FONT_NEXT, 217, 109,
	FONT_NEXT, 115, 553,
	FONT_END, 115, 109,
	FONT_BEGIN, 115, 109,
	FONT_NEXT, 217, 109,
	FONT_NEXT, 111, 65,
	FONT_END, 98, 38,
	FONT_BEGIN, 98, 38,
	FONT_NEXT, 217, 109,
	FONT_END, 221, 62,
	FONT_BEGIN, 98, 38,
	FONT_NEXT, 221, 62,
	FONT_NEXT, 69, 23,
	FONT_NEXT, 18, 0,
	FONT_END, 18, 19,
	FONT_BEGIN, 315, 662,
	FONT_NEXT, 315, 643,
	FONT_NEXT, 18, 662,
	FONT_NEXT, 268, 638,
	FONT_END, 238, 626,
	FONT_BEGIN, 18, 662,
	FONT_NEXT, 238, 626,
	FONT_END, 222, 600,
	FONT_BEGIN, 315, 19,
	FONT_NEXT, 315, 0,
	FONT_NEXT, 268, 22,
	FONT_NEXT, 18, 0,
	FONT_NEXT, 238, 35,
	FONT_END, 221, 62,
	FONT_ADVANCE, 333, 0
    },
    {
	74,
	FONT_BEGIN, 83, 643,
	FONT_NEXT, 83, 662,
	FONT_NEXT, 131, 636,
	FONT_END, 159, 622,
	FONT_BEGIN, 159, 622,
	FONT_NEXT, 83, 662,
	FONT_END, 281, 597,
	FONT_BEGIN, 159, 622,
	FONT_NEXT, 281, 597,
	FONT_END, 278, 553,
	FONT_BEGIN, 159, 622,
	FONT_NEXT, 278, 553,
	FONT_NEXT, 172, 596,
	FONT_NEXT, 278, 183,
	FONT_END, 271, 118,
	FONT_BEGIN, 172, 596,
	FONT_NEXT, 271, 118,
	FONT_END, 255, 70,
	FONT_BEGIN, 172, 596,
	FONT_NEXT, 255, 70,
	FONT_END, 231, 35,
	FONT_BEGIN, 172, 596,
	FONT_NEXT, 231, 35,
	FONT_NEXT, 176, 553,
	FONT_NEXT, 204, 11,
	FONT_NEXT, 176, 90,
	FONT_END, 173, 57,
	FONT_BEGIN, 173, 57,
	FONT_NEXT, 204, 11,
	FONT_END, 147, -11,
	FONT_BEGIN, 173, 57,
	FONT_NEXT, 147, -11,
	FONT_NEXT, 165, 37,
	FONT_END, 153, 27,
	FONT_BEGIN, 153, 27,
	FONT_NEXT, 147, -11,
	FONT_NEXT, 137, 24,
	FONT_NEXT, 124, -14,
	FONT_NEXT, 117, 37,
	FONT_NEXT, 110, -14,
	FONT_NEXT, 107, 66,
	FONT_NEXT, 59, -6,
	FONT_NEXT, 92, 94,
	FONT_END, 77, 104,
	FONT_BEGIN, 77, 104,
	FONT_NEXT, 59, -6,
	FONT_NEXT, 56, 108,
	FONT_NEXT, 32, 11,
	FONT_NEXT, 36, 103,
	FONT_END, 22, 90,
	FONT_BEGIN, 22, 90,
	FONT_NEXT, 32, 11,
	FONT_END, 15, 36,
	FONT_BEGIN, 22, 90,
	FONT_NEXT, 15, 36,
	FONT_END, 10, 59,
	FONT_BEGIN, 370, 662,
	FONT_NEXT, 370, 643,
	FONT_NEXT, 83, 662,
	FONT_NEXT, 322, 637,
	FONT_END, 294, 623,
	FONT_BEGIN, 83, 662,
	FONT_NEXT, 294, 623,
	FONT_END, 281, 597,
	FONT_ADVANCE, 389, 0
    },
    {
	75,
	FONT_BEGIN, 34, 643,
	FONT_NEXT, 34, 662,
	FONT_NEXT, 76, 637,
	FONT_END, 104, 625,
	FONT_BEGIN, 104, 625,
	FONT_NEXT, 34, 662,
	FONT_END, 229, 597,
	FONT_BEGIN, 104, 625,
	FONT_NEXT, 229, 597,
	FONT_END, 226, 553,
	FONT_BEGIN, 104, 625,
	FONT_NEXT, 226, 553,
	FONT_NEXT, 119, 599,
	FONT_NEXT, 226, 348,
	FONT_END, 226, 296,
	FONT_BEGIN, 119, 599,
	FONT_NEXT, 226, 296,
	FONT_END, 226, 109,
	FONT_BEGIN, 119, 599,
	FONT_NEXT, 226, 109,
	FONT_NEXT, 124, 553,
	FONT_END, 124, 120,
	FONT_BEGIN, 124, 120,
	FONT_NEXT, 226, 109,
	FONT_NEXT, 120, 70,
	FONT_END, 108, 40,
	FONT_BEGIN, 108, 40,
	FONT_NEXT, 226, 109,
	FONT_END, 229, 65,
	FONT_BEGIN, 108, 40,
	FONT_NEXT, 229, 65,
	FONT_NEXT, 80, 24,
	FONT_NEXT, 34, 0,
	FONT_END, 34, 19,
	FONT_BEGIN, 318, 662,
	FONT_NEXT, 318, 643,
	FONT_NEXT, 34, 662,
	FONT_NEXT, 270, 637,
	FONT_END, 242, 623,
	FONT_BEGIN, 34, 662,
	FONT_NEXT, 242, 623,
	FONT_END, 229, 597,
	FONT_BEGIN, 413, 643,
	FONT_NEXT, 413, 662,
	FONT_NEXT, 444, 641,
	FONT_END, 465, 636,
	FONT_BEGIN, 465, 636,
	FONT_NEXT, 413, 662,
	FONT_END, 568, 606,
	FONT_BEGIN, 465, 636,
	FONT_NEXT, 568, 606,
	FONT_NEXT, 477, 627,
	FONT_NEXT, 523, 565,
	FONT_NEXT, 481, 612,
	FONT_END, 472, 584,
	FONT_BEGIN, 472, 584,
	FONT_NEXT, 523, 565,
	FONT_END, 333, 377,
	FONT_BEGIN, 472, 584,
	FONT_NEXT, 333, 377,
	FONT_NEXT, 459, 567,
	FONT_END, 438, 543,
	FONT_BEGIN, 438, 543,
	FONT_NEXT, 333, 377,
	FONT_NEXT, 406, 511,
	FONT_END, 361, 470,
	FONT_BEGIN, 361, 470,
	FONT_NEXT, 333, 377,
	FONT_NEXT, 301, 416,
	FONT_NEXT, 252, 317,
	FONT_NEXT, 226, 348,
	FONT_END, 226, 296,
	FONT_BEGIN, 675, 662,
	FONT_NEXT, 675, 643,
	FONT_NEXT, 413, 662,
	FONT_NEXT, 635, 638,
	FONT_END, 603, 628,
	FONT_BEGIN, 413, 662,
	FONT_NEXT, 603, 628,
	FONT_END, 568, 606,
	FONT_BEGIN, 723, 19,
	FONT_NEXT, 723, 0,
	FONT_NEXT, 683, 24,
	FONT_NEXT, 418, 0,
	FONT_NEXT, 647, 45,
	FONT_END, 609, 79,
	FONT_BEGIN, 609, 79,
	FONT_NEXT, 418, 0,
	FONT_END, 472, 24,
	FONT_BEGIN, 609, 79,
	FONT_NEXT, 472, 24,
	FONT_END, 484, 31,
	FONT_BEGIN, 609, 79,
	FONT_NEXT, 484, 31,
	FONT_NEXT, 566, 127,
	FONT_NEXT, 488, 44,
	FONT_END, 483, 58,
	FONT_BEGIN, 566, 127,
	FONT_NEXT, 483, 58,
	FONT_NEXT, 333, 377,
	FONT_NEXT, 472, 78,
	FONT_END, 435, 126,
	FONT_BEGIN, 333, 377,
	FONT_NEXT, 435, 126,
	FONT_END, 392, 175,
	FONT_BEGIN, 333, 377,
	FONT_NEXT, 392, 175,
	FONT_END, 358, 212,
	FONT_BEGIN, 333, 377,
	FONT_NEXT, 358, 212,
	FONT_END, 252, 317,
	FONT_BEGIN, 418, 19,
	FONT_NEXT, 451, 20,
	FONT_NEXT, 418, 0,
	FONT_END, 472, 24,
	FONT_BEGIN, 316, 19,
	FONT_NEXT, 316, 0,
	FONT_NEXT, 269, 24,
	FONT_NEXT, 34, 0,
	FONT_NEXT, 241, 39,
	FONT_END, 229, 65,
	FONT_ADVANCE, 722, 0
    },
    {
	76,
	FONT_BEGIN, 12, 19,
	FONT_NEXT, 52, 23,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 79, 36,
	FONT_NEXT, 201, 80,
	FONT_NEXT, 94, 63,
	FONT_END, 99, 109,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 99, 109,
	FONT_END, 99, 553,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 99, 553,
	FONT_END, 94, 599,
	FONT_BEGIN, 201, 80,
	FONT_NEXT, 94, 599,
	FONT_NEXT, 201, 553,
	FONT_NEXT, 79, 625,
	FONT_NEXT, 205, 599,
	FONT_END, 12, 662,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 79, 625,
	FONT_END, 52, 637,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 52, 637,
	FONT_END, 12, 643,
	FONT_BEGIN, 598, 174,
	FONT_NEXT, 550, 0,
	FONT_NEXT, 573, 174,
	FONT_END, 551, 130,
	FONT_BEGIN, 551, 130,
	FONT_NEXT, 550, 0,
	FONT_NEXT, 527, 97,
	FONT_END, 501, 73,
	FONT_BEGIN, 501, 73,
	FONT_NEXT, 550, 0,
	FONT_NEXT, 472, 57,
	FONT_END, 399, 41,
	FONT_BEGIN, 399, 41,
	FONT_NEXT, 550, 0,
	FONT_END, 12, 0,
	FONT_BEGIN, 399, 41,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 302, 39,
	FONT_END, 251, 39,
	FONT_BEGIN, 251, 39,
	FONT_NEXT, 12, 0,
	FONT_NEXT, 220, 44,
	FONT_END, 205, 56,
	FONT_BEGIN, 205, 56,
	FONT_NEXT, 12, 0,
	FONT_END, 201, 80,
	FONT_BEGIN, 205, 56,
	FONT_END, 201, 80,
	FONT_BEGIN, 294, 662,
	FONT_NEXT, 294, 643,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 250, 638,
	FONT_END, 222, 626,
	FONT_BEGIN, 12, 662,
	FONT_NEXT, 222, 626,
	FONT_END, 205, 599,
	FONT_ADVANCE, 611, 0
    },
    {
	77,
	FONT_BEGIN, 14, 643,
	FONT_NEXT, 14, 662,
	FONT_NEXT, 60, 638,
	FONT_END, 89, 625,
	FONT_BEGIN, 89, 625,
	FONT_NEXT, 14, 662,
	FONT_END, 212, 662,
	FONT_BEGIN, 89, 625,
	FONT_NEXT, 212, 662,
	FONT_END, 155, 546,
	FONT_BEGIN, 89, 625,
	FONT_NEXT, 155, 546,
	FONT_END, 153, 546,
	FONT_BEGIN, 89, 625,
	FONT_NEXT, 153, 546,
	FONT_NEXT, 104, 599,
	FONT_END, 109, 553,
	FONT_BEGIN, 109, 553,
	FONT_NEXT, 153, 546,
	FONT_END, 153, 147,
	FONT_BEGIN, 109, 553,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 109, 147,
	FONT_END, 107, 110,
	FONT_BEGIN, 107, 110,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 104, 82,
	FONT_END, 89, 44,
	FONT_BEGIN, 89, 44,
	FONT_NEXT, 153, 147,
	FONT_END, 157, 83,
	FONT_BEGIN, 89, 44,
	FONT_NEXT, 157, 83,
	FONT_NEXT, 59, 25,
	FONT_NEXT, 172, 45,
	FONT_END, 12, 0,
	FONT_BEGIN, 59, 25,
	FONT_NEXT, 12, 0,
	FONT_END, 12, 19,
	FONT_BEGIN, 863, 662,
	FONT_NEXT, 863, 643,
	FONT_NEXT, 664, 662,
	FONT_NEXT, 822, 637,
	FONT_END, 795, 625,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 795, 625,
	FONT_END, 780, 599,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 780, 599,
	FONT_END, 776, 553,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 776, 553,
	FONT_END, 776, 109,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 776, 109,
	FONT_END, 674, 569,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 674, 569,
	FONT_END, 672, 569,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 672, 569,
	FONT_END, 418, 0,
	FONT_BEGIN, 664, 662,
	FONT_NEXT, 418, 0,
	FONT_NEXT, 443, 157,
	FONT_END, 212, 662,
	FONT_BEGIN, 212, 662,
	FONT_NEXT, 418, 0,
	FONT_END, 404, 0,
	FONT_BEGIN, 212, 662,
	FONT_NEXT, 404, 0,
	FONT_END, 155, 546,
	FONT_BEGIN, 583, 19,
	FONT_NEXT, 630, 24,
	FONT_NEXT, 583, 0,
	FONT_END, 780, 63,
	FONT_BEGIN, 780, 63,
	FONT_NEXT, 630, 24,
	FONT_NEXT, 776, 109,
	FONT_NEXT, 657, 40,
	FONT_END, 670, 70,
	FONT_BEGIN, 776, 109,
	FONT_NEXT, 670, 70,
	FONT_END, 674, 120,
	FONT_BEGIN, 776, 109,
	FONT_NEXT, 674, 120,
	FONT_END, 674, 569,
	FONT_BEGIN, 863, 19,
	FONT_NEXT, 863, 0,
	FONT_NEXT, 822, 23,
	FONT_NEXT, 583, 0,
	FONT_NEXT, 795, 36,
	FONT_END, 780, 63,
	FONT_BEGIN, 247, 19,
	FONT_NEXT, 247, 0,
	FONT_NEXT, 201, 25,
	FONT_NEXT, 12, 0,
	FONT_END, 172, 45,
	FONT_ADVANCE, 889, 0
    },
    {
	78,
	FONT_BEGIN, 12, 643,
	FONT_NEXT, 12, 662,
	FONT_NEXT, 60, 634,
	FONT_NEXT, 183, 662,
	FONT_NEXT, 82, 617,
	FONT_END, 109, 588,
	FONT_BEGIN, 109, 588,
	FONT_NEXT, 183, 662,
	FONT_END, 155, 537,
	FONT_BEGIN, 109, 588,
	FONT_NEXT, 155, 537,
	FONT_END, 153, 537,
	FONT_BEGIN, 109, 588,
	FONT_NEXT, 153, 537,
	FONT_END, 153, 147,
	FONT_BEGIN, 109, 588,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 109, 147,
	FONT_END, 107, 110,
	FONT_BEGIN, 107, 110,
	FONT_NEXT, 153, 147,
	FONT_NEXT, 104, 82,
	FONT_END, 89, 44,
	FONT_BEGIN, 89, 44,
	FONT_NEXT, 153, 147,
	FONT_END, 157, 83,
	FONT_BEGIN, 89, 44,
	FONT_NEXT, 157, 83,
	FONT_NEXT, 59, 25,
	FONT_NEXT, 172, 45,
	FONT_END, 12, 0,
	FONT_BEGIN, 59, 25,
	FONT_NEXT, 12, 0,
	FONT_END, 12, 19,
	FONT_BEGIN, 472, 643,
	FONT_NEXT, 472, 662,
	FONT_NEXT, 515, 637,
	FONT_END, 545, 620,
	FONT_BEGIN, 545, 620,
	FONT_NEXT, 472, 662,
	FONT_END, 617, 583,
	FONT_BEGIN, 545, 620,
	FONT_NEXT, 617, 583,
	FONT_END, 613, 553,
	FONT_BEGIN, 545, 620,
	FONT_NEXT, 613, 553,
	FONT_END, 612, 515,
	FONT_BEGIN, 545, 620,
	FONT_NEXT, 612, 515,
	FONT_NEXT, 562, 582,
	FONT_END, 566, 553,
	FONT_BEGIN, 566, 553,
	FONT_NEXT, 612, 515,
	FONT_END, 612, -11,
	FONT_BEGIN, 566, 553,
	FONT_NEXT, 612, -11,
	FONT_NEXT, 568, 515,
	FONT_NEXT, 595, -11,
	FONT_NEXT, 568, 181,
	FONT_END, 566, 181,
	FONT_BEGIN, 566, 181,
	FONT_NEXT, 595, -11,
	FONT_END, 155, 537,
	FONT_BEGIN, 566, 181,
	FONT_NEXT, 155, 537,
	FONT_END, 183, 662,
	FONT_BEGIN, 707, 662,
	FONT_NEXT, 707, 643,
	FONT_NEXT, 472, 662,
	FONT_NEXT, 665, 636,
	FONT_END, 635, 620,
	FONT_BEGIN, 472, 662,
	FONT_NEXT, 635, 620,
	FONT_END, 617, 583,
	FONT_BEGIN, 247, 19,
	FONT_NEXT, 247, 0,
	FONT_NEXT, 201, 25,
	FONT_NEXT, 12, 0,
	FONT_END, 172, 45,
	FONT_ADVANCE, 722, 0
    },
    {
	79,
	FONT_BEGIN, 148, 331,
	FONT_NEXT, 152, 254,
	FONT_NEXT, 129, 78,
	FONT_NEXT, 165, 189,
	FONT_NEXT, 177, 38,
	FONT_NEXT, 186, 136,
	FONT_END, 212, 94,
	FONT_BEGIN, 177, 38,
	FONT_NEXT, 212, 94,
	FONT_NEXT, 233, 9,
	FONT_NEXT, 244, 61,
	FONT_END, 280, 39,
	FONT_BEGIN, 233, 9,
	FONT_NEXT, 280, 39,
	FONT_NEXT, 294, -8,
	FONT_NEXT, 319, 26,
	FONT_NEXT, 361, -14,
	FONT_NEXT, 361, 22,
	FONT_END, 402, 26,
	FONT_BEGIN, 361, -14,
	FONT_NEXT, 402, 26,
	FONT_NEXT, 427, -8,
	FONT_NEXT, 441, 39,
	FONT_END, 477, 61,
	FONT_BEGIN, 427, -8,
	FONT_NEXT, 477, 61,
	FONT_NEXT, 488, 9,
	FONT_NEXT, 509, 94,
	FONT_END, 535, 136,
	FONT_BEGIN, 488, 9,
	FONT_NEXT, 535, 136,
	FONT_NEXT, 544, 38,
	FONT_NEXT, 556, 189,
	FONT_END, 569, 254,
	FONT_BEGIN, 544, 38,
	FONT_NEXT, 569, 254,
	FONT_NEXT, 592, 78,
	FONT_NEXT, 574, 331,
	FONT_NEXT, 586, 589,
	FONT_NEXT, 569, 409,
	FONT_NEXT, 536, 627,
	FONT_NEXT, 555, 475,
	FONT_END, 533, 528,
	FONT_BEGIN, 536, 627,
	FONT_NEXT, 533, 528,
	FONT_NEXT, 481, 654,
	FONT_NEXT, 505, 571,
	FONT_END, 473, 602,
	FONT_BEGIN, 481, 654,
	FONT_NEXT, 473, 602,
	FONT_NEXT, 422, 670,
	FONT_NEXT, 437, 623,
	FONT_END, 399, 636,
	FONT_BEGIN, 422, 670,
	FONT_NEXT, 399, 636,
	FONT_NEXT, 361, 676,
	FONT_NEXT, 361, 640,
	FONT_NEXT, 299, 670,
	FONT_NEXT, 322, 636,
	FONT_END, 284, 623,
	FONT_BEGIN, 299, 670,
	FONT_NEXT, 284, 623,
	FONT_NEXT, 240, 654,
	FONT_NEXT, 248, 602,
	FONT_END, 216, 571,
	FONT_BEGIN, 240, 654,
	FONT_NEXT, 216, 571,
	FONT_NEXT, 185, 627,
	FONT_NEXT, 188, 528,
	FONT_END, 166, 475,
	FONT_BEGIN, 185, 627,
	FONT_NEXT, 166, 475,
	FONT_NEXT, 136, 589,
	FONT_NEXT, 152, 409,
	FONT_END, 148, 331,
	FONT_BEGIN, 136, 589,
	FONT_NEXT, 148, 331,
	FONT_END, 129, 78,
	FONT_BEGIN, 136, 589,
	FONT_NEXT, 129, 78,
	FONT_NEXT, 94, 540,
	FONT_NEXT, 89, 127,
	FONT_NEXT, 62, 481,
	FONT_NEXT, 59, 186,
	FONT_NEXT, 41, 410,
	FONT_NEXT, 40, 254,
	FONT_END, 34, 330,
	FONT_BEGIN, 688, 330,
	FONT_NEXT, 681, 254,
	FONT_NEXT, 680, 410,
	FONT_NEXT, 662, 186,
	FONT_NEXT, 659, 481,
	FONT_NEXT, 632, 127,
	FONT_NEXT, 627, 540,
	FONT_NEXT, 592, 78,
	FONT_END, 586, 589,
	FONT_ADVANCE, 722, 0
    },
    {
	80,
	FONT_BEGIN, 16, 643,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 59, 635,
	FONT_END, 85, 622,
	FONT_BEGIN, 85, 622,
	FONT_NEXT, 16, 662,
	FONT_END, 202, 591,
	FONT_BEGIN, 85, 622,
	FONT_NEXT, 202, 591,
	FONT_NEXT, 97, 596,
	FONT_NEXT, 202, 331,
	FONT_END, 202, 291,
	FONT_BEGIN, 97, 596,
	FONT_NEXT, 202, 291,
	FONT_END, 202, 109,
	FONT_BEGIN, 97, 596,
	FONT_NEXT, 202, 109,
	FONT_NEXT, 100, 553,
	FONT_END, 100, 120,
	FONT_BEGIN, 100, 120,
	FONT_NEXT, 202, 109,
	FONT_NEXT, 98, 74,
	FONT_END, 89, 44,
	FONT_BEGIN, 89, 44,
	FONT_NEXT, 202, 109,
	FONT_NEXT, 64, 27,
	FONT_NEXT, 205, 64,
	FONT_END, 16, 0,
	FONT_BEGIN, 64, 27,
	FONT_NEXT, 16, 0,
	FONT_END, 16, 19,
	FONT_BEGIN, 542, 482,
	FONT_NEXT, 534, 430,
	FONT_NEXT, 536, 526,
	FONT_END, 520, 563,
	FONT_BEGIN, 520, 563,
	FONT_NEXT, 534, 430,
	FONT_END, 517, 391,
	FONT_BEGIN, 520, 563,
	FONT_NEXT, 517, 391,
	FONT_NEXT, 495, 594,
	FONT_NEXT, 497, 363,
	FONT_END, 481, 347,
	FONT_BEGIN, 495, 594,
	FONT_NEXT, 481, 347,
	FONT_NEXT, 462, 619,
	FONT_NEXT, 444, 320,
	FONT_END, 433, 480,
	FONT_BEGIN, 462, 619,
	FONT_NEXT, 433, 480,
	FONT_END, 426, 527,
	FONT_BEGIN, 462, 619,
	FONT_NEXT, 426, 527,
	FONT_NEXT, 379, 651,
	FONT_NEXT, 409, 562,
	FONT_END, 384, 588,
	FONT_BEGIN, 379, 651,
	FONT_NEXT, 384, 588,
	FONT_END, 354, 606,
	FONT_BEGIN, 379, 651,
	FONT_NEXT, 354, 606,
	FONT_NEXT, 280, 662,
	FONT_NEXT, 291, 622,
	FONT_END, 243, 625,
	FONT_BEGIN, 280, 662,
	FONT_NEXT, 243, 625,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 211, 620,
	FONT_END, 204, 610,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 204, 610,
	FONT_END, 202, 591,
	FONT_BEGIN, 202, 331,
	FONT_NEXT, 262, 328,
	FONT_NEXT, 202, 291,
	FONT_END, 269, 288,
	FONT_BEGIN, 269, 288,
	FONT_NEXT, 262, 328,
	FONT_END, 304, 330,
	FONT_BEGIN, 269, 288,
	FONT_NEXT, 304, 330,
	FONT_NEXT, 340, 291,
	FONT_NEXT, 361, 347,
	FONT_END, 388, 365,
	FONT_BEGIN, 340, 291,
	FONT_NEXT, 388, 365,
	FONT_NEXT, 398, 302,
	FONT_NEXT, 411, 392,
	FONT_END, 427, 429,
	FONT_BEGIN, 398, 302,
	FONT_NEXT, 427, 429,
	FONT_NEXT, 444, 320,
	FONT_END, 433, 480,
	FONT_BEGIN, 296, 19,
	FONT_NEXT, 296, 0,
	FONT_NEXT, 248, 23,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 220, 37,
	FONT_END, 205, 64,
	FONT_ADVANCE, 556, 0
    },
    {
	81,
	FONT_BEGIN, 34, 330,
	FONT_NEXT, 41, 410,
	FONT_NEXT, 40, 255,
	FONT_END, 57, 191,
	FONT_BEGIN, 57, 191,
	FONT_NEXT, 41, 410,
	FONT_END, 62, 480,
	FONT_BEGIN, 57, 191,
	FONT_NEXT, 62, 480,
	FONT_NEXT, 82, 138,
	FONT_NEXT, 94, 540,
	FONT_NEXT, 114, 94,
	FONT_NEXT, 136, 588,
	FONT_END, 148, 330,
	FONT_BEGIN, 114, 94,
	FONT_NEXT, 148, 330,
	FONT_NEXT, 151, 58,
	FONT_NEXT, 152, 253,
	FONT_END, 165, 189,
	FONT_BEGIN, 151, 58,
	FONT_NEXT, 165, 189,
	FONT_END, 186, 136,
	FONT_BEGIN, 151, 58,
	FONT_NEXT, 186, 136,
	FONT_NEXT, 189, 31,
	FONT_NEXT, 212, 93,
	FONT_END, 244, 61,
	FONT_BEGIN, 189, 31,
	FONT_NEXT, 244, 61,
	FONT_NEXT, 265, -1,
	FONT_NEXT, 280, 39,
	FONT_NEXT, 312, -56,
	FONT_NEXT, 319, 26,
	FONT_END, 361, 22,
	FONT_BEGIN, 312, -56,
	FONT_NEXT, 361, 22,
	FONT_NEXT, 379, -113,
	FONT_NEXT, 402, 26,
	FONT_NEXT, 426, -7,
	FONT_NEXT, 441, 39,
	FONT_NEXT, 468, 2,
	FONT_NEXT, 477, 61,
	FONT_END, 509, 93,
	FONT_BEGIN, 468, 2,
	FONT_NEXT, 509, 93,
	FONT_NEXT, 512, 20,
	FONT_NEXT, 535, 136,
	FONT_NEXT, 556, 47,
	FONT_NEXT, 556, 189,
	FONT_END, 569, 253,
	FONT_BEGIN, 556, 47,
	FONT_NEXT, 569, 253,
	FONT_END, 574, 330,
	FONT_BEGIN, 556, 47,
	FONT_NEXT, 574, 330,
	FONT_NEXT, 597, 83,
	FONT_NEXT, 586, 589,
	FONT_END, 627, 540,
	FONT_BEGIN, 597, 83,
	FONT_NEXT, 627, 540,
	FONT_NEXT, 633, 130,
	FONT_NEXT, 659, 481,
	FONT_NEXT, 662, 186,
	FONT_NEXT, 680, 410,
	FONT_NEXT, 681, 252,
	FONT_END, 688, 330,
	FONT_BEGIN, 574, 330,
	FONT_NEXT, 569, 409,
	FONT_NEXT, 586, 589,
	FONT_END, 536, 627,
	FONT_BEGIN, 536, 627,
	FONT_NEXT, 569, 409,
	FONT_END, 555, 475,
	FONT_BEGIN, 536, 627,
	FONT_NEXT, 555, 475,
	FONT_END, 533, 528,
	FONT_BEGIN, 536, 627,
	FONT_NEXT, 533, 528,
	FONT_NEXT, 481, 654,
	FONT_NEXT, 505, 570,
	FONT_END, 473, 602,
	FONT_BEGIN, 481, 654,
	FONT_NEXT, 473, 602,
	FONT_NEXT, 422, 670,
	FONT_NEXT, 437, 623,
	FONT_END, 399, 636,
	FONT_BEGIN, 422, 670,
	FONT_NEXT, 399, 636,
	FONT_NEXT, 361, 676,
	FONT_NEXT, 361, 640,
	FONT_NEXT, 299, 670,
	FONT_NEXT, 322, 636,
	FONT_END, 284, 623,
	FONT_BEGIN, 299, 670,
	FONT_NEXT, 284, 623,
	FONT_NEXT, 240, 654,
	FONT_NEXT, 248, 602,
	FONT_END, 216, 570,
	FONT_BEGIN, 240, 654,
	FONT_NEXT, 216, 570,
	FONT_NEXT, 185, 626,
	FONT_NEXT, 188, 528,
	FONT_END, 166, 475,
	FONT_BEGIN, 185, 626,
	FONT_NEXT, 166, 475,
	FONT_NEXT, 136, 588,
	FONT_NEXT, 152, 409,
	FONT_END, 148, 330,
	FONT_BEGIN, 701, -159,
	FONT_NEXT, 701, -177,
	FONT_NEXT, 638, -153,
	FONT_NEXT, 654, -178,
	FONT_END, 555, -172,
	FONT_BEGIN, 638, -153,
	FONT_NEXT, 555, -172,
	FONT_NEXT, 586, -138,
	FONT_END, 505, -90,
	FONT_BEGIN, 505, -90,
	FONT_NEXT, 555, -172,
	FONT_END, 462, -151,
	FONT_BEGIN, 505, -90,
	FONT_NEXT, 462, -151,
	FONT_NEXT, 426, -7,
	FONT_END, 379, -113,
	FONT_ADVANCE, 722, 0
    },
    {
	82,
	FONT_BEGIN, 17, 643,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 59, 636,
	FONT_END, 85, 623,
	FONT_BEGIN, 85, 623,
	FONT_NEXT, 17, 662,
	FONT_END, 204, 589,
	FONT_BEGIN, 85, 623,
	FONT_NEXT, 204, 589,
	FONT_NEXT, 98, 597,
	FONT_NEXT, 204, 343,
	FONT_END, 204, 306,
	FONT_BEGIN, 98, 597,
	FONT_NEXT, 204, 306,
	FONT_END, 204, 109,
	FONT_BEGIN, 98, 597,
	FONT_NEXT, 204, 109,
	FONT_NEXT, 102, 553,
	FONT_END, 102, 120,
	FONT_BEGIN, 102, 120,
	FONT_NEXT, 204, 109,
	FONT_NEXT, 100, 73,
	FONT_END, 89, 43,
	FONT_BEGIN, 89, 43,
	FONT_NEXT, 204, 109,
	FONT_NEXT, 64, 26,
	FONT_NEXT, 206, 67,
	FONT_END, 17, 0,
	FONT_BEGIN, 64, 26,
	FONT_NEXT, 17, 0,
	FONT_END, 17, 19,
	FONT_BEGIN, 204, 306,
	FONT_NEXT, 204, 343,
	FONT_NEXT, 260, 308,
	FONT_NEXT, 276, 346,
	FONT_END, 352, 362,
	FONT_BEGIN, 260, 308,
	FONT_NEXT, 352, 362,
	FONT_NEXT, 366, 319,
	FONT_NEXT, 386, 380,
	FONT_END, 413, 406,
	FONT_BEGIN, 366, 319,
	FONT_NEXT, 413, 406,
	FONT_NEXT, 415, 330,
	FONT_NEXT, 431, 441,
	FONT_END, 438, 489,
	FONT_BEGIN, 415, 330,
	FONT_NEXT, 438, 489,
	FONT_NEXT, 475, 356,
	FONT_END, 453, 632,
	FONT_BEGIN, 453, 632,
	FONT_NEXT, 438, 489,
	FONT_END, 432, 533,
	FONT_BEGIN, 453, 632,
	FONT_NEXT, 432, 533,
	FONT_END, 416, 566,
	FONT_BEGIN, 453, 632,
	FONT_NEXT, 416, 566,
	FONT_NEXT, 370, 656,
	FONT_NEXT, 394, 590,
	FONT_END, 367, 606,
	FONT_BEGIN, 370, 656,
	FONT_NEXT, 367, 606,
	FONT_NEXT, 293, 662,
	FONT_NEXT, 310, 622,
	FONT_END, 266, 625,
	FONT_BEGIN, 293, 662,
	FONT_NEXT, 266, 625,
	FONT_NEXT, 17, 662,
	FONT_NEXT, 233, 623,
	FONT_END, 215, 617,
	FONT_BEGIN, 17, 662,
	FONT_NEXT, 215, 617,
	FONT_END, 206, 606,
	FONT_BEGIN, 17, 662,
	FONT_NEXT, 206, 606,
	FONT_END, 204, 589,
	FONT_BEGIN, 659, 19,
	FONT_NEXT, 659, 0,
	FONT_NEXT, 608, 33,
	FONT_NEXT, 498, 0,
	FONT_NEXT, 572, 66,
	FONT_END, 366, 319,
	FONT_BEGIN, 366, 319,
	FONT_NEXT, 498, 0,
	FONT_END, 260, 308,
	FONT_BEGIN, 366, 319,
	FONT_END, 260, 308,
	FONT_BEGIN, 547, 487,
	FONT_NEXT, 541, 441,
	FONT_NEXT, 539, 538,
	FONT_NEXT, 525, 405,
	FONT_NEXT, 519, 579,
	FONT_NEXT, 503, 377,
	FONT_NEXT, 490, 610,
	FONT_NEXT, 475, 356,
	FONT_END, 453, 632,
	FONT_BEGIN, 294, 19,
	FONT_NEXT, 294, 0,
	FONT_NEXT, 246, 25,
	FONT_NEXT, 17, 0,
	FONT_NEXT, 219, 40,
	FONT_END, 206, 67,
	FONT_ADVANCE, 667, 0
    },
    {
	83,
	FONT_BEGIN, 71, 506,
	FONT_NEXT, 75, 546,
	FONT_NEXT, 82, 441,
	FONT_NEXT, 86, 580,
	FONT_NEXT, 114, 390,
	FONT_NEXT, 127, 633,
	FONT_END, 157, 542,
	FONT_BEGIN, 114, 390,
	FONT_NEXT, 157, 542,
	FONT_NEXT, 163, 349,
	FONT_NEXT, 171, 491,
	FONT_END, 209, 448,
	FONT_BEGIN, 163, 349,
	FONT_NEXT, 209, 448,
	FONT_NEXT, 227, 310,
	FONT_END, 276, 280,
	FONT_BEGIN, 276, 280,
	FONT_NEXT, 209, 448,
	FONT_NEXT, 314, 254,
	FONT_NEXT, 324, 375,
	FONT_NEXT, 343, 231,
	FONT_END, 363, 210,
	FONT_BEGIN, 363, 210,
	FONT_NEXT, 324, 375,
	FONT_NEXT, 385, 172,
	FONT_NEXT, 385, 336,
	FONT_NEXT, 390, 133,
	FONT_NEXT, 409, 20,
	FONT_END, 373, 2,
	FONT_BEGIN, 390, 133,
	FONT_NEXT, 373, 2,
	FONT_NEXT, 382, 92,
	FONT_END, 360, 57,
	FONT_BEGIN, 360, 57,
	FONT_NEXT, 373, 2,
	FONT_END, 330, -10,
	FONT_BEGIN, 360, 57,
	FONT_NEXT, 330, -10,
	FONT_NEXT, 322, 31,
	FONT_NEXT, 280, -14,
	FONT_NEXT, 270, 22,
	FONT_NEXT, 227, -9,
	FONT_NEXT, 223, 27,
	FONT_NEXT, 185, 3,
	FONT_NEXT, 183, 43,
	FONT_NEXT, 151, 14,
	FONT_NEXT, 124, 92,
	FONT_NEXT, 125, 20,
	FONT_END, 101, 9,
	FONT_BEGIN, 124, 92,
	FONT_NEXT, 101, 9,
	FONT_NEXT, 86, 151,
	FONT_NEXT, 94, -13,
	FONT_END, 72, -13,
	FONT_BEGIN, 86, 151,
	FONT_NEXT, 72, -13,
	FONT_NEXT, 65, 199,
	FONT_END, 42, 199,
	FONT_BEGIN, 469, 463,
	FONT_NEXT, 444, 463,
	FONT_NEXT, 447, 676,
	FONT_END, 426, 676,
	FONT_BEGIN, 426, 676,
	FONT_NEXT, 444, 463,
	FONT_END, 422, 524,
	FONT_BEGIN, 426, 676,
	FONT_NEXT, 422, 524,
	FONT_NEXT, 418, 654,
	FONT_NEXT, 384, 579,
	FONT_NEXT, 408, 645,
	FONT_END, 391, 642,
	FONT_BEGIN, 391, 642,
	FONT_NEXT, 384, 579,
	FONT_NEXT, 367, 647,
	FONT_NEXT, 328, 619,
	FONT_NEXT, 334, 659,
	FONT_END, 252, 676,
	FONT_BEGIN, 252, 676,
	FONT_NEXT, 328, 619,
	FONT_END, 295, 630,
	FONT_BEGIN, 252, 676,
	FONT_NEXT, 295, 630,
	FONT_END, 258, 635,
	FONT_BEGIN, 252, 676,
	FONT_NEXT, 258, 635,
	FONT_END, 221, 629,
	FONT_BEGIN, 252, 676,
	FONT_NEXT, 221, 629,
	FONT_NEXT, 185, 665,
	FONT_NEXT, 188, 611,
	FONT_END, 165, 582,
	FONT_BEGIN, 185, 665,
	FONT_NEXT, 165, 582,
	FONT_NEXT, 127, 633,
	FONT_END, 157, 542,
	FONT_BEGIN, 491, 167,
	FONT_NEXT, 478, 102,
	FONT_NEXT, 476, 235,
	FONT_NEXT, 439, 44,
	FONT_NEXT, 438, 290,
	FONT_NEXT, 409, 20,
	FONT_END, 385, 336,
	FONT_ADVANCE, 556, 0
    },
    {
	84,
	FONT_BEGIN, 17, 492,
	FONT_NEXT, 23, 662,
	FONT_NEXT, 41, 492,
	FONT_END, 59, 557,
	FONT_BEGIN, 59, 557,
	FONT_NEXT, 23, 662,
	FONT_NEXT, 87, 596,
	FONT_END, 131, 615,
	FONT_BEGIN, 131, 615,
	FONT_NEXT, 23, 662,
	FONT_NEXT, 200, 620,
	FONT_END, 254, 620,
	FONT_BEGIN, 254, 620,
	FONT_NEXT, 23, 662,
	FONT_END, 356, 620,
	FONT_BEGIN, 254, 620,
	FONT_NEXT, 356, 620,
	FONT_END, 356, 109,
	FONT_BEGIN, 254, 620,
	FONT_NEXT, 356, 109,
	FONT_NEXT, 254, 120,
	FONT_END, 252, 73,
	FONT_BEGIN, 252, 73,
	FONT_NEXT, 356, 109,
	FONT_NEXT, 241, 43,
	FONT_END, 213, 26,
	FONT_BEGIN, 213, 26,
	FONT_NEXT, 356, 109,
	FONT_END, 359, 66,
	FONT_BEGIN, 213, 26,
	FONT_NEXT, 359, 66,
	FONT_END, 160, 0,
	FONT_BEGIN, 213, 26,
	FONT_NEXT, 160, 0,
	FONT_END, 160, 19,
	FONT_BEGIN, 593, 492,
	FONT_NEXT, 569, 492,
	FONT_NEXT, 587, 662,
	FONT_NEXT, 550, 558,
	FONT_END, 522, 597,
	FONT_BEGIN, 587, 662,
	FONT_NEXT, 522, 597,
	FONT_END, 478, 615,
	FONT_BEGIN, 587, 662,
	FONT_NEXT, 478, 615,
	FONT_NEXT, 23, 662,
	FONT_NEXT, 410, 620,
	FONT_END, 356, 620,
	FONT_BEGIN, 452, 19,
	FONT_NEXT, 452, 0,
	FONT_NEXT, 401, 24,
	FONT_NEXT, 160, 0,
	FONT_NEXT, 372, 39,
	FONT_END, 359, 66,
	FONT_ADVANCE, 611, 0
    },
    {
	85,
	FONT_BEGIN, 14, 643,
	FONT_NEXT, 14, 662,
	FONT_NEXT, 60, 637,
	FONT_END, 87, 623,
	FONT_BEGIN, 87, 623,
	FONT_NEXT, 14, 662,
	FONT_END, 209, 596,
	FONT_BEGIN, 87, 623,
	FONT_NEXT, 209, 596,
	FONT_END, 206, 553,
	FONT_BEGIN, 87, 623,
	FONT_NEXT, 206, 553,
	FONT_NEXT, 100, 597,
	FONT_NEXT, 206, 233,
	FONT_END, 164, 50,
	FONT_BEGIN, 100, 597,
	FONT_NEXT, 164, 50,
	FONT_NEXT, 104, 553,
	FONT_NEXT, 135, 91,
	FONT_END, 117, 133,
	FONT_BEGIN, 104, 553,
	FONT_NEXT, 117, 133,
	FONT_END, 107, 175,
	FONT_BEGIN, 104, 553,
	FONT_NEXT, 107, 175,
	FONT_END, 104, 212,
	FONT_BEGIN, 104, 553,
	FONT_NEXT, 104, 212,
	FONT_END, 104, 241,
	FONT_BEGIN, 297, 662,
	FONT_NEXT, 297, 643,
	FONT_NEXT, 14, 662,
	FONT_NEXT, 249, 636,
	FONT_END, 221, 622,
	FONT_BEGIN, 14, 662,
	FONT_NEXT, 221, 622,
	FONT_END, 209, 596,
	FONT_BEGIN, 473, 643,
	FONT_NEXT, 473, 662,
	FONT_NEXT, 517, 636,
	FONT_NEXT, 629, 615,
	FONT_END, 614, 578,
	FONT_BEGIN, 517, 636,
	FONT_NEXT, 614, 578,
	FONT_NEXT, 546, 617,
	FONT_NEXT, 611, 515,
	FONT_NEXT, 562, 579,
	FONT_NEXT, 611, 254,
	FONT_END, 606, 178,
	FONT_BEGIN, 562, 579,
	FONT_NEXT, 606, 178,
	FONT_END, 597, 134,
	FONT_BEGIN, 562, 579,
	FONT_NEXT, 597, 134,
	FONT_NEXT, 567, 515,
	FONT_NEXT, 578, 90,
	FONT_NEXT, 567, 245,
	FONT_END, 565, 192,
	FONT_BEGIN, 565, 192,
	FONT_NEXT, 578, 90,
	FONT_END, 547, 49,
	FONT_BEGIN, 565, 192,
	FONT_NEXT, 547, 49,
	FONT_NEXT, 560, 154,
	FONT_END, 544, 109,
	FONT_BEGIN, 544, 109,
	FONT_NEXT, 547, 49,
	FONT_END, 501, 16,
	FONT_BEGIN, 544, 109,
	FONT_NEXT, 501, 16,
	FONT_NEXT, 517, 76,
	FONT_END, 480, 51,
	FONT_BEGIN, 480, 51,
	FONT_NEXT, 501, 16,
	FONT_END, 437, -6,
	FONT_BEGIN, 480, 51,
	FONT_NEXT, 437, -6,
	FONT_NEXT, 434, 35,
	FONT_NEXT, 352, -14,
	FONT_NEXT, 380, 30,
	FONT_END, 322, 36,
	FONT_BEGIN, 322, 36,
	FONT_NEXT, 352, -14,
	FONT_END, 270, -6,
	FONT_BEGIN, 322, 36,
	FONT_NEXT, 270, -6,
	FONT_NEXT, 279, 52,
	FONT_END, 248, 77,
	FONT_BEGIN, 248, 77,
	FONT_NEXT, 270, -6,
	FONT_END, 208, 17,
	FONT_BEGIN, 248, 77,
	FONT_NEXT, 208, 17,
	FONT_NEXT, 227, 107,
	FONT_END, 208, 174,
	FONT_BEGIN, 208, 174,
	FONT_NEXT, 208, 17,
	FONT_NEXT, 206, 233,
	FONT_END, 164, 50,
	FONT_BEGIN, 705, 662,
	FONT_NEXT, 705, 643,
	FONT_NEXT, 473, 662,
	FONT_NEXT, 657, 634,
	FONT_END, 629, 615,
	FONT_ADVANCE, 722, 0
    },
    {
	86,
	FONT_BEGIN, 282, 662,
	FONT_NEXT, 282, 643,
	FONT_NEXT, 16, 662,
	FONT_NEXT, 246, 640,
	FONT_END, 223, 635,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 223, 635,
	FONT_END, 210, 624,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 210, 624,
	FONT_END, 207, 606,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 207, 606,
	FONT_END, 71, 623,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 71, 623,
	FONT_END, 46, 638,
	FONT_BEGIN, 16, 662,
	FONT_NEXT, 46, 638,
	FONT_END, 16, 643,
	FONT_BEGIN, 549, 538,
	FONT_NEXT, 556, 556,
	FONT_NEXT, 546, 528,
	FONT_NEXT, 383, -11,
	FONT_NEXT, 399, 161,
	FONT_END, 248, 499,
	FONT_BEGIN, 248, 499,
	FONT_NEXT, 383, -11,
	FONT_END, 368, -11,
	FONT_BEGIN, 248, 499,
	FONT_NEXT, 368, -11,
	FONT_END, 122, 538,
	FONT_BEGIN, 248, 499,
	FONT_NEXT, 122, 538,
	FONT_NEXT, 218, 566,
	FONT_END, 210, 590,
	FONT_BEGIN, 210, 590,
	FONT_NEXT, 122, 538,
	FONT_NEXT, 207, 606,
	FONT_NEXT, 94, 592,
	FONT_END, 71, 623,
	FONT_BEGIN, 492, 643,
	FONT_NEXT, 492, 662,
	FONT_NEXT, 542, 634,
	FONT_NEXT, 625, 596,
	FONT_NEXT, 558, 621,
	FONT_NEXT, 605, 550,
	FONT_NEXT, 565, 597,
	FONT_END, 556, 556,
	FONT_BEGIN, 556, 556,
	FONT_NEXT, 605, 550,
	FONT_END, 383, -11,
	FONT_BEGIN, 556, 556,
	FONT_END, 383, -11,
	FONT_BEGIN, 697, 662,
	FONT_NEXT, 697, 643,
	FONT_NEXT, 492, 662,
	FONT_NEXT, 666, 637,
	FONT_END, 644, 623,
	FONT_BEGIN, 492, 662,
	FONT_NEXT, 644, 623,
	FONT_END, 625, 596,
	FONT_ADVANCE, 722, 0
    },
    {
	87,
	FONT_BEGIN, 125, 480,
	FONT_NEXT, 108, 526,
	FONT_NEXT, 147, 421,
	FONT_END, 185, 609,
	FONT_BEGIN, 185, 609,
	FONT_NEXT, 108, 526,
	FONT_END, 86, 578,
	FONT_BEGIN, 185, 609,
	FONT_NEXT, 86, 578,
	FONT_END, 65, 613,
	FONT_BEGIN, 185, 609,
	FONT_NEXT, 65, 613,
	FONT_END, 40, 634,
	FONT_BEGIN, 185, 609,
	FONT_NEXT, 40, 634,
	FONT_NEXT, 5, 662,
	FONT_END, 5, 643,
	FONT_BEGIN, 313, 643,
	FONT_NEXT, 313, 662,
	FONT_NEXT, 346, 640,
	FONT_END, 371, 628,
	FONT_BEGIN, 371, 628,
	FONT_NEXT, 313, 662,
	FONT_END, 503, 605,
	FONT_BEGIN, 371, 628,
	FONT_NEXT, 503, 605,
	FONT_NEXT, 391, 601,
	FONT_END, 414, 553,
	FONT_BEGIN, 414, 553,
	FONT_NEXT, 503, 605,
	FONT_NEXT, 447, 471,
	FONT_NEXT, 470, 412,
	FONT_END, 316, -11,
	FONT_BEGIN, 447, 471,
	FONT_NEXT, 316, -11,
	FONT_NEXT, 340, 189,
	FONT_END, 196, 565,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 316, -11,
	FONT_END, 301, -11,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 301, -11,
	FONT_END, 279, 51,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 279, 51,
	FONT_END, 254, 123,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 254, 123,
	FONT_END, 199, 277,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 199, 277,
	FONT_END, 147, 421,
	FONT_BEGIN, 196, 565,
	FONT_NEXT, 147, 421,
	FONT_END, 185, 609,
	FONT_BEGIN, 580, 662,
	FONT_NEXT, 580, 643,
	FONT_NEXT, 313, 662,
	FONT_NEXT, 529, 637,
	FONT_END, 510, 626,
	FONT_BEGIN, 313, 662,
	FONT_NEXT, 510, 626,
	FONT_END, 503, 605,
	FONT_BEGIN, 734, 643,
	FONT_NEXT, 734, 662,
	FONT_NEXT, 781, 633,
	FONT_NEXT, 864, 606,
	FONT_END, 853, 582,
	FONT_BEGIN, 781, 633,
	FONT_NEXT, 853, 582,
	FONT_NEXT, 797, 620,
	FONT_END, 803, 597,
	FONT_BEGIN, 803, 597,
	FONT_NEXT, 853, 582,
	FONT_END, 745, 288,
	FONT_BEGIN, 803, 597,
	FONT_NEXT, 745, 288,
	FONT_NEXT, 787, 525,
	FONT_END, 662, 186,
	FONT_BEGIN, 662, 186,
	FONT_NEXT, 745, 288,
	FONT_END, 645, -11,
	FONT_BEGIN, 662, 186,
	FONT_NEXT, 645, -11,
	FONT_NEXT, 530, 527,
	FONT_NEXT, 630, -11,
	FONT_END, 470, 412,
	FONT_BEGIN, 530, 527,
	FONT_NEXT, 470, 412,
	FONT_NEXT, 510, 574,
	FONT_END, 503, 605,
	FONT_BEGIN, 932, 662,
	FONT_NEXT, 932, 643,
	FONT_NEXT, 734, 662,
	FONT_NEXT, 900, 635,
	FONT_END, 879, 624,
	FONT_BEGIN, 734, 662,
	FONT_NEXT, 879, 624,
	FONT_END, 864, 606,
	FONT_BEGIN, 250, 662,
	FONT_NEXT, 250, 643,
	FONT_NEXT, 5, 662,
	FONT_NEXT, 220, 640,
	FONT_END, 200, 635,
	FONT_BEGIN, 5, 662,
	FONT_NEXT, 200, 635,
	FONT_END, 188, 625,
	FONT_BEGIN, 5, 662,
	FONT_NEXT, 188, 625,
	FONT_END, 185, 609,
	FONT_ADVANCE, 944, 0
    },
    {
	88,
	FONT_BEGIN, 22, 643,
	FONT_NEXT, 22, 662,
	FONT_NEXT, 60, 637,
	FONT_END, 96, 618,
	FONT_BEGIN, 96, 618,
	FONT_NEXT, 22, 662,
	FONT_END, 248, 611,
	FONT_BEGIN, 96, 618,
	FONT_NEXT, 248, 611,
	FONT_NEXT, 116, 600,
	FONT_END, 139, 573,
	FONT_BEGIN, 139, 573,
	FONT_NEXT, 248, 611,
	FONT_NEXT, 168, 535,
	FONT_END, 203, 486,
	FONT_BEGIN, 203, 486,
	FONT_NEXT, 248, 611,
	FONT_END, 251, 592,
	FONT_BEGIN, 203, 486,
	FONT_NEXT, 251, 592,
	FONT_END, 265, 565,
	FONT_BEGIN, 203, 486,
	FONT_NEXT, 265, 565,
	FONT_END, 291, 523,
	FONT_BEGIN, 203, 486,
	FONT_NEXT, 291, 523,
	FONT_NEXT, 312, 326,
	FONT_NEXT, 333, 463,
	FONT_END, 338, 288,
	FONT_BEGIN, 312, 326,
	FONT_NEXT, 338, 288,
	FONT_END, 219, 140,
	FONT_BEGIN, 312, 326,
	FONT_NEXT, 219, 140,
	FONT_NEXT, 155, 133,
	FONT_NEXT, 185, 95,
	FONT_END, 172, 73,
	FONT_BEGIN, 155, 133,
	FONT_NEXT, 172, 73,
	FONT_END, 167, 56,
	FONT_BEGIN, 155, 133,
	FONT_NEXT, 167, 56,
	FONT_NEXT, 128, 100,
	FONT_END, 106, 74,
	FONT_BEGIN, 106, 74,
	FONT_NEXT, 167, 56,
	FONT_NEXT, 73, 41,
	FONT_NEXT, 10, 0,
	FONT_NEXT, 44, 24,
	FONT_END, 10, 19,
	FONT_BEGIN, 324, 662,
	FONT_NEXT, 324, 643,
	FONT_NEXT, 22, 662,
	FONT_NEXT, 290, 641,
	FONT_END, 266, 637,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 266, 637,
	FONT_END, 252, 628,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 252, 628,
	FONT_END, 248, 611,
	FONT_BEGIN, 458, 643,
	FONT_NEXT, 458, 662,
	FONT_NEXT, 505, 637,
	FONT_NEXT, 592, 599,
	FONT_NEXT, 521, 628,
	FONT_END, 528, 610,
	FONT_BEGIN, 528, 610,
	FONT_NEXT, 592, 599,
	FONT_END, 547, 549,
	FONT_BEGIN, 528, 610,
	FONT_NEXT, 547, 549,
	FONT_NEXT, 516, 579,
	FONT_NEXT, 401, 367,
	FONT_NEXT, 488, 542,
	FONT_END, 375, 404,
	FONT_BEGIN, 375, 404,
	FONT_NEXT, 401, 367,
	FONT_END, 338, 288,
	FONT_BEGIN, 375, 404,
	FONT_NEXT, 338, 288,
	FONT_END, 333, 463,
	FONT_BEGIN, 696, 662,
	FONT_NEXT, 696, 643,
	FONT_NEXT, 458, 662,
	FONT_NEXT, 660, 638,
	FONT_END, 627, 627,
	FONT_BEGIN, 458, 662,
	FONT_NEXT, 627, 627,
	FONT_END, 592, 599,
	FONT_BEGIN, 704, 19,
	FONT_NEXT, 704, 0,
	FONT_NEXT, 670, 24,
	FONT_NEXT, 407, 0,
	FONT_NEXT, 643, 37,
	FONT_END, 619, 58,
	FONT_BEGIN, 619, 58,
	FONT_NEXT, 407, 0,
	FONT_END, 464, 25,
	FONT_BEGIN, 619, 58,
	FONT_NEXT, 464, 25,
	FONT_NEXT, 593, 93,
	FONT_NEXT, 479, 35,
	FONT_END, 484, 53,
	FONT_BEGIN, 593, 93,
	FONT_NEXT, 484, 53,
	FONT_NEXT, 401, 367,
	FONT_NEXT, 478, 72,
	FONT_END, 464, 98,
	FONT_BEGIN, 401, 367,
	FONT_NEXT, 464, 98,
	FONT_END, 433, 148,
	FONT_BEGIN, 401, 367,
	FONT_NEXT, 433, 148,
	FONT_END, 338, 288,
	FONT_BEGIN, 407, 19,
	FONT_NEXT, 440, 21,
	FONT_NEXT, 407, 0,
	FONT_END, 464, 25,
	FONT_BEGIN, 243, 19,
	FONT_NEXT, 243, 0,
	FONT_NEXT, 190, 26,
	FONT_NEXT, 10, 0,
	FONT_NEXT, 173, 37,
	FONT_END, 167, 56,
	FONT_ADVANCE, 722, 0
    },
    {
	89,
	FONT_BEGIN, 302, 662,
	FONT_NEXT, 302, 643,
	FONT_NEXT, 22, 662,
	FONT_NEXT, 271, 641,
	FONT_END, 249, 637,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 249, 637,
	FONT_END, 235, 628,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 235, 628,
	FONT_END, 231, 612,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 231, 612,
	FONT_END, 81, 619,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 81, 619,
	FONT_END, 51, 637,
	FONT_BEGIN, 22, 662,
	FONT_NEXT, 51, 637,
	FONT_END, 22, 643,
	FONT_BEGIN, 484, 643,
	FONT_NEXT, 484, 662,
	FONT_NEXT, 530, 638,
	FONT_NEXT, 646, 624,
	FONT_END, 610, 590,
	FONT_BEGIN, 530, 638,
	FONT_NEXT, 610, 590,
	FONT_NEXT, 546, 628,
	FONT_NEXT, 589, 564,
	FONT_NEXT, 553, 610,
	FONT_NEXT, 565, 529,
	FONT_NEXT, 539, 573,
	FONT_NEXT, 417, 303,
	FONT_NEXT, 396, 347,
	FONT_NEXT, 417, 109,
	FONT_END, 313, 72,
	FONT_BEGIN, 396, 347,
	FONT_NEXT, 313, 72,
	FONT_END, 315, 120,
	FONT_BEGIN, 396, 347,
	FONT_NEXT, 315, 120,
	FONT_END, 315, 294,
	FONT_BEGIN, 396, 347,
	FONT_NEXT, 315, 294,
	FONT_NEXT, 248, 569,
	FONT_NEXT, 184, 486,
	FONT_NEXT, 231, 612,
	FONT_NEXT, 149, 535,
	FONT_END, 121, 573,
	FONT_BEGIN, 231, 612,
	FONT_NEXT, 121, 573,
	FONT_END, 99, 600,
	FONT_BEGIN, 231, 612,
	FONT_NEXT, 99, 600,
	FONT_END, 81, 619,
	FONT_BEGIN, 703, 662,
	FONT_NEXT, 703, 643,
	FONT_NEXT, 484, 662,
	FONT_NEXT, 675, 638,
	FONT_END, 646, 624,
	FONT_BEGIN, 520, 19,
	FONT_NEXT, 520, 0,
	FONT_NEXT, 465, 23,
	FONT_NEXT, 214, 0,
	FONT_NEXT, 434, 37,
	FONT_END, 420, 64,
	FONT_BEGIN, 420, 64,
	FONT_NEXT, 214, 0,
	FONT_END, 271, 24,
	FONT_BEGIN, 420, 64,
	FONT_NEXT, 271, 24,
	FONT_END, 301, 41,
	FONT_BEGIN, 420, 64,
	FONT_NEXT, 301, 41,
	FONT_NEXT, 417, 109,
	FONT_END, 313, 72,
	FONT_BEGIN, 214, 19,
	FONT_NEXT, 246, 20,
	FONT_NEXT, 214, 0,
	FONT_END, 271, 24,
	FONT_ADVANCE, 722, 0
    },
    {
	90,
	FONT_BEGIN, 577, 662,
	FONT_NEXT, 577, 647,
	FONT_NEXT, 51, 662,
	FONT_NEXT, 446, 624,
	FONT_END, 225, 624,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 225, 624,
	FONT_END, 177, 621,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 177, 621,
	FONT_END, 140, 612,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 140, 612,
	FONT_END, 112, 599,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 112, 599,
	FONT_END, 92, 582,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 92, 582,
	FONT_END, 68, 540,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 68, 540,
	FONT_END, 57, 491,
	FONT_BEGIN, 51, 662,
	FONT_NEXT, 57, 491,
	FONT_END, 31, 491,
	FONT_BEGIN, 597, 176,
	FONT_NEXT, 573, 0,
	FONT_NEXT, 574, 176,
	FONT_END, 556, 123,
	FONT_BEGIN, 556, 123,
	FONT_NEXT, 573, 0,
	FONT_NEXT, 528, 79,
	FONT_END, 481, 49,
	FONT_BEGIN, 481, 49,
	FONT_NEXT, 573, 0,
	FONT_NEXT, 446, 40,
	FONT_NEXT, 9, 0,
	FONT_NEXT, 402, 38,
	FONT_END, 145, 38,
	FONT_BEGIN, 145, 38,
	FONT_NEXT, 9, 0,
	FONT_END, 9, 15,
	FONT_BEGIN, 145, 38,
	FONT_NEXT, 9, 15,
	FONT_END, 446, 624,
	FONT_BEGIN, 145, 38,
	FONT_NEXT, 446, 624,
	FONT_END, 577, 647,
	FONT_ADVANCE, 611, 0
    },
    {
	91,
	FONT_BEGIN, 299, 662,
	FONT_NEXT, 299, 637,
	FONT_NEXT, 88, 662,
	FONT_NEXT, 209, 637,
	FONT_END, 182, 632,
	FONT_BEGIN, 88, 662,
	FONT_NEXT, 182, 632,
	FONT_END, 169, 620,
	FONT_BEGIN, 88, 662,
	FONT_NEXT, 169, 620,
	FONT_END, 164, 593,
	FONT_BEGIN, 88, 662,
	FONT_NEXT, 164, 593,
	FONT_END, 164, -79,
	FONT_BEGIN, 88, 662,
	FONT_NEXT, 164, -79,
	FONT_NEXT, 88, -156,
	FONT_NEXT, 170, -110,
	FONT_END, 184, -125,
	FONT_BEGIN, 88, -156,
	FONT_NEXT, 184, -125,
	FONT_END, 213, -131,
	FONT_BEGIN, 88, -156,
	FONT_NEXT, 213, -131,
	FONT_NEXT, 299, -156,
	FONT_END, 299, -131,
	FONT_ADVANCE, 333, 0
    },
    {
	92,
	FONT_BEGIN, 287, -14,
	FONT_NEXT, 219, -14,
	FONT_NEXT, 58, 676,
	FONT_END, -9, 676,
	FONT_ADVANCE, 278, 0
    },
    {
	93,
	FONT_BEGIN, 34, 637,
	FONT_NEXT, 34, 662,
	FONT_NEXT, 120, 637,
	FONT_END, 148, 630,
	FONT_BEGIN, 148, 630,
	FONT_NEXT, 34, 662,
	FONT_END, 245, 662,
	FONT_BEGIN, 148, 630,
	FONT_NEXT, 245, 662,
	FONT_NEXT, 162, 615,
	FONT_END, 169, 585,
	FONT_BEGIN, 169, 585,
	FONT_NEXT, 245, 662,
	FONT_END, 245, -156,
	FONT_BEGIN, 169, 585,
	FONT_NEXT, 245, -156,
	FONT_NEXT, 169, -87,
	FONT_END, 163, -115,
	FONT_BEGIN, 163, -115,
	FONT_NEXT, 245, -156,
	FONT_NEXT, 150, -127,
	FONT_NEXT, 34, -156,
	FONT_NEXT, 124, -131,
	FONT_END, 34, -131,
	FONT_ADVANCE, 333, 0
    },
    {
	94,
	FONT_BEGIN, 446, 297,
	FONT_NEXT, 378, 297,
	FONT_NEXT, 265, 662,
	FONT_NEXT, 235, 586,
	FONT_NEXT, 205, 662,
	FONT_NEXT, 92, 297,
	FONT_END, 24, 297,
	FONT_ADVANCE, 469, 0
    },
    {
	95,
	FONT_BEGIN, 500, -75,
	FONT_NEXT, 500, -125,
	FONT_NEXT, 0, -75,
	FONT_END, 0, -125,
	FONT_ADVANCE, 500, 0
    },
    {
	96,
	FONT_BEGIN, 236, 657,
	FONT_NEXT, 195, 625,
	FONT_NEXT, 227, 676,
	FONT_END, 196, 658,
	FONT_BEGIN, 196, 658,
	FONT_NEXT, 195, 625,
	FONT_NEXT, 159, 625,
	FONT_NEXT, 170, 595,
	FONT_END, 157, 569,
	FONT_BEGIN, 159, 625,
	FONT_NEXT, 157, 569,
	FONT_NEXT, 128, 580,
	FONT_NEXT, 154, 551,
	FONT_END, 146, 449,
	FONT_BEGIN, 128, 580,
	FONT_NEXT, 146, 449,
	FONT_END, 124, 478,
	FONT_BEGIN, 128, 580,
	FONT_NEXT, 124, 478,
	FONT_END, 115, 529,
	FONT_BEGIN, 254, 491,
	FONT_NEXT, 248, 463,
	FONT_NEXT, 247, 515,
	FONT_NEXT, 234, 445,
	FONT_NEXT, 232, 531,
	FONT_NEXT, 196, 433,
	FONT_NEXT, 192, 541,
	FONT_NEXT, 173, 436,
	FONT_NEXT, 177, 539,
	FONT_END, 168, 537,
	FONT_BEGIN, 168, 537,
	FONT_NEXT, 173, 436,
	FONT_END, 146, 449,
	FONT_BEGIN, 168, 537,
	FONT_NEXT, 146, 449,
	FONT_NEXT, 158, 540,
	FONT_END, 154, 551,
	FONT_ADVANCE, 333, 0
    },
    {
	97,
	FONT_BEGIN, 56, 349,
	FONT_NEXT, 65, 383,
	FONT_NEXT, 65, 321,
	FONT_END, 79, 309,
	FONT_BEGIN, 79, 309,
	FONT_NEXT, 65, 383,
	FONT_END, 94, 419,
	FONT_BEGIN, 79, 309,
	FONT_NEXT, 94, 419,
	FONT_NEXT, 99, 305,
	FONT_END, 131, 318,
	FONT_BEGIN, 131, 318,
	FONT_NEXT, 94, 419,
	FONT_END, 139, 387,
	FONT_BEGIN, 131, 318,
	FONT_NEXT, 139, 387,
	FONT_END, 144, 348,
	FONT_BEGIN, 37, 94,
	FONT_NEXT, 41, 128,
	FONT_NEXT, 45, 49,
	FONT_NEXT, 53, 158,
	FONT_NEXT, 69, 16,
	FONT_NEXT, 73, 183,
	FONT_END, 100, 206,
	FONT_BEGIN, 69, 16,
	FONT_NEXT, 100, 206,
	FONT_NEXT, 103, -4,
	FONT_END, 125, 126,
	FONT_BEGIN, 125, 126,
	FONT_NEXT, 100, 206,
	FONT_NEXT, 125, 128,
	FONT_END, 129, 157,
	FONT_BEGIN, 129, 157,
	FONT_NEXT, 100, 206,
	FONT_NEXT, 149, 192,
	FONT_END, 169, 210,
	FONT_BEGIN, 169, 210,
	FONT_NEXT, 100, 206,
	FONT_END, 179, 248,
	FONT_BEGIN, 169, 210,
	FONT_NEXT, 179, 248,
	FONT_NEXT, 197, 229,
	FONT_END, 236, 249,
	FONT_BEGIN, 236, 249,
	FONT_NEXT, 179, 248,
	FONT_NEXT, 287, 268,
	FONT_NEXT, 287, 292,
	FONT_NEXT, 287, 123,
	FONT_NEXT, 287, 353,
	FONT_NEXT, 288, 63,
	FONT_END, 297, 21,
	FONT_BEGIN, 297, 21,
	FONT_NEXT, 287, 353,
	FONT_NEXT, 305, 443,
	FONT_NEXT, 279, 396,
	FONT_NEXT, 268, 455,
	FONT_NEXT, 259, 421,
	FONT_NEXT, 219, 460,
	FONT_NEXT, 234, 433,
	FONT_END, 210, 436,
	FONT_BEGIN, 219, 460,
	FONT_NEXT, 210, 436,
	FONT_NEXT, 178, 456,
	FONT_NEXT, 162, 423,
	FONT_NEXT, 144, 448,
	FONT_NEXT, 145, 407,
	FONT_END, 139, 387,
	FONT_BEGIN, 144, 448,
	FONT_NEXT, 139, 387,
	FONT_END, 94, 419,
	FONT_BEGIN, 287, 123,
	FONT_NEXT, 288, 63,
	FONT_NEXT, 281, 88,
	FONT_NEXT, 222, 14,
	FONT_NEXT, 271, 77,
	FONT_END, 253, 66,
	FONT_BEGIN, 253, 66,
	FONT_NEXT, 222, 14,
	FONT_NEXT, 226, 55,
	FONT_END, 191, 48,
	FONT_BEGIN, 191, 48,
	FONT_NEXT, 222, 14,
	FONT_END, 183, -4,
	FONT_BEGIN, 191, 48,
	FONT_NEXT, 183, -4,
	FONT_NEXT, 165, 53,
	FONT_NEXT, 143, -10,
	FONT_NEXT, 144, 69,
	FONT_END, 130, 93,
	FONT_BEGIN, 130, 93,
	FONT_NEXT, 143, -10,
	FONT_END, 103, -4,
	FONT_BEGIN, 130, 93,
	FONT_NEXT, 103, -4,
	FONT_END, 125, 126,
	FONT_BEGIN, 368, 300,
	FONT_NEXT, 368, 105,
	FONT_NEXT, 365, 350,
	FONT_NEXT, 353, -10,
	FONT_NEXT, 349, 402,
	FONT_NEXT, 315, -1,
	FONT_NEXT, 331, 425,
	FONT_END, 305, 443,
	FONT_BEGIN, 305, 443,
	FONT_NEXT, 315, -1,
	FONT_END, 297, 21,
	FONT_BEGIN, 305, 443,
	FONT_END, 297, 21,
	FONT_BEGIN, 442, 66,
	FONT_NEXT, 442, 40,
	FONT_NEXT, 423, 53,
	FONT_NEXT, 412, 11,
	FONT_NEXT, 397, 47,
	FONT_NEXT, 387, -4,
	FONT_NEXT, 380, 51,
	FONT_NEXT, 353, -10,
	FONT_NEXT, 371, 65,
	FONT_END, 368, 105,
	FONT_ADVANCE, 444, 0
    },
    {
	98,
	FONT_BEGIN, 3, 623,
	FONT_NEXT, 3, 639,
	FONT_NEXT, 25, 624,
	FONT_END, 50, 620,
	FONT_BEGIN, 50, 620,
	FONT_NEXT, 3, 639,
	FONT_END, 148, 683,
	FONT_BEGIN, 50, 620,
	FONT_NEXT, 148, 683,
	FONT_NEXT, 63, 609,
	FONT_END, 69, 573,
	FONT_BEGIN, 69, 573,
	FONT_NEXT, 148, 683,
	FONT_END, 127, 8,
	FONT_BEGIN, 69, 573,
	FONT_NEXT, 127, 8,
	FONT_END, 86, 28,
	FONT_BEGIN, 69, 573,
	FONT_NEXT, 86, 28,
	FONT_END, 73, 40,
	FONT_BEGIN, 69, 573,
	FONT_NEXT, 73, 40,
	FONT_END, 69, 54,
	FONT_BEGIN, 153, 379,
	FONT_NEXT, 155, 379,
	FONT_NEXT, 153, 322,
	FONT_END, 165, 357,
	FONT_BEGIN, 165, 357,
	FONT_NEXT, 155, 379,
	FONT_END, 167, 401,
	FONT_BEGIN, 165, 357,
	FONT_NEXT, 167, 401,
	FONT_NEXT, 192, 380,
	FONT_NEXT, 196, 428,
	FONT_NEXT, 224, 393,
	FONT_NEXT, 237, 450,
	FONT_NEXT, 253, 397,
	FONT_END, 284, 392,
	FONT_BEGIN, 284, 392,
	FONT_NEXT, 237, 450,
	FONT_END, 290, 460,
	FONT_BEGIN, 284, 392,
	FONT_NEXT, 290, 460,
	FONT_NEXT, 311, 379,
	FONT_NEXT, 332, 454,
	FONT_NEXT, 350, 333,
	FONT_NEXT, 368, 440,
	FONT_NEXT, 372, 270,
	FONT_END, 380, 201,
	FONT_BEGIN, 380, 201,
	FONT_NEXT, 368, 440,
	FONT_END, 399, 417,
	FONT_BEGIN, 380, 201,
	FONT_NEXT, 399, 417,
	FONT_END, 382, 44,
	FONT_BEGIN, 380, 201,
	FONT_NEXT, 382, 44,
	FONT_NEXT, 375, 145,
	FONT_NEXT, 340, 16,
	FONT_NEXT, 357, 86,
	FONT_END, 340, 61,
	FONT_BEGIN, 340, 61,
	FONT_NEXT, 340, 16,
	FONT_NEXT, 317, 40,
	FONT_NEXT, 287, -4,
	FONT_NEXT, 287, 26,
	FONT_END, 249, 22,
	FONT_BEGIN, 249, 22,
	FONT_NEXT, 287, -4,
	FONT_END, 224, -10,
	FONT_BEGIN, 249, 22,
	FONT_NEXT, 224, -10,
	FONT_NEXT, 223, 24,
	FONT_NEXT, 178, -6,
	FONT_NEXT, 191, 32,
	FONT_END, 164, 47,
	FONT_BEGIN, 164, 47,
	FONT_NEXT, 178, -6,
	FONT_END, 127, 8,
	FONT_BEGIN, 164, 47,
	FONT_NEXT, 127, 8,
	FONT_NEXT, 153, 70,
	FONT_NEXT, 148, 683,
	FONT_NEXT, 153, 322,
	FONT_END, 153, 379,
	FONT_BEGIN, 153, 379,
	FONT_NEXT, 148, 683,
	FONT_END, 153, 681,
	FONT_BEGIN, 153, 379,
	FONT_END, 153, 681,
	FONT_BEGIN, 468, 238,
	FONT_NEXT, 455, 161,
	FONT_NEXT, 457, 317,
	FONT_END, 424, 389,
	FONT_BEGIN, 424, 389,
	FONT_NEXT, 455, 161,
	FONT_END, 439, 119,
	FONT_BEGIN, 424, 389,
	FONT_NEXT, 439, 119,
	FONT_END, 415, 80,
	FONT_BEGIN, 424, 389,
	FONT_NEXT, 415, 80,
	FONT_NEXT, 399, 417,
	FONT_END, 382, 44,
	FONT_ADVANCE, 500, 0
    },
    {
	99,
	FONT_BEGIN, 25, 213,
	FONT_NEXT, 30, 270,
	FONT_NEXT, 29, 158,
	FONT_END, 42, 111,
	FONT_BEGIN, 42, 111,
	FONT_NEXT, 30, 270,
	FONT_END, 44, 320,
	FONT_BEGIN, 42, 111,
	FONT_NEXT, 44, 320,
	FONT_NEXT, 63, 73,
	FONT_NEXT, 67, 363,
	FONT_NEXT, 88, 42,
	FONT_NEXT, 96, 398,
	FONT_NEXT, 102, 253,
	FONT_END, 106, 302,
	FONT_BEGIN, 106, 302,
	FONT_NEXT, 96, 398,
	FONT_NEXT, 116, 342,
	FONT_NEXT, 130, 425,
	FONT_NEXT, 133, 373,
	FONT_END, 152, 397,
	FONT_BEGIN, 152, 397,
	FONT_NEXT, 130, 425,
	FONT_END, 168, 444,
	FONT_BEGIN, 152, 397,
	FONT_NEXT, 168, 444,
	FONT_NEXT, 195, 423,
	FONT_END, 231, 431,
	FONT_BEGIN, 231, 431,
	FONT_NEXT, 168, 444,
	FONT_END, 249, 460,
	FONT_BEGIN, 231, 431,
	FONT_NEXT, 249, 460,
	FONT_NEXT, 262, 427,
	FONT_END, 280, 418,
	FONT_BEGIN, 280, 418,
	FONT_NEXT, 249, 460,
	FONT_END, 306, 450,
	FONT_BEGIN, 280, 418,
	FONT_NEXT, 306, 450,
	FONT_NEXT, 297, 383,
	FONT_END, 303, 361,
	FONT_BEGIN, 303, 361,
	FONT_NEXT, 306, 450,
	FONT_NEXT, 320, 329,
	FONT_END, 334, 318,
	FONT_BEGIN, 334, 318,
	FONT_NEXT, 306, 450,
	FONT_NEXT, 352, 315,
	FONT_NEXT, 355, 429,
	FONT_NEXT, 386, 329,
	FONT_NEXT, 387, 392,
	FONT_END, 398, 359,
	FONT_BEGIN, 412, 147,
	FONT_NEXT, 369, 74,
	FONT_NEXT, 398, 156,
	FONT_END, 340, 89,
	FONT_BEGIN, 340, 89,
	FONT_NEXT, 369, 74,
	FONT_END, 322, 25,
	FONT_BEGIN, 340, 89,
	FONT_NEXT, 322, 25,
	FONT_NEXT, 302, 69,
	FONT_NEXT, 269, -2,
	FONT_NEXT, 255, 62,
	FONT_NEXT, 212, -10,
	FONT_NEXT, 195, 75,
	FONT_NEXT, 149, 2,
	FONT_NEXT, 147, 114,
	FONT_NEXT, 88, 42,
	FONT_NEXT, 114, 174,
	FONT_END, 102, 253,
	FONT_ADVANCE, 444, 0
    },
    {
	100,
	FONT_BEGIN, 113, 247,
	FONT_NEXT, 116, 195,
	FONT_NEXT, 103, 25,
	FONT_NEXT, 125, 152,
	FONT_END, 139, 116,
	FONT_BEGIN, 103, 25,
	FONT_NEXT, 139, 116,
	FONT_END, 157, 88,
	FONT_BEGIN, 103, 25,
	FONT_NEXT, 157, 88,
	FONT_NEXT, 164, -4,
	FONT_NEXT, 201, 53,
	FONT_NEXT, 209, -10,
	FONT_NEXT, 251, 42,
	FONT_NEXT, 257, -4,
	FONT_NEXT, 281, 46,
	FONT_NEXT, 294, 11,
	FONT_NEXT, 308, 58,
	FONT_NEXT, 320, 32,
	FONT_NEXT, 328, 77,
	FONT_NEXT, 338, 54,
	FONT_END, 340, 54,
	FONT_BEGIN, 340, 54,
	FONT_NEXT, 328, 77,
	FONT_END, 340, 102,
	FONT_BEGIN, 340, 54,
	FONT_NEXT, 340, 102,
	FONT_NEXT, 340, -7,
	FONT_NEXT, 340, 332,
	FONT_NEXT, 340, 417,
	FONT_NEXT, 327, 376,
	FONT_NEXT, 290, 449,
	FONT_NEXT, 303, 407,
	FONT_END, 271, 425,
	FONT_BEGIN, 290, 449,
	FONT_NEXT, 271, 425,
	FONT_NEXT, 234, 460,
	FONT_NEXT, 237, 432,
	FONT_END, 194, 422,
	FONT_BEGIN, 234, 460,
	FONT_NEXT, 194, 422,
	FONT_NEXT, 192, 454,
	FONT_NEXT, 154, 390,
	FONT_NEXT, 154, 439,
	FONT_END, 119, 416,
	FONT_BEGIN, 119, 416,
	FONT_NEXT, 154, 390,
	FONT_END, 124, 333,
	FONT_BEGIN, 119, 416,
	FONT_NEXT, 124, 333,
	FONT_END, 116, 293,
	FONT_BEGIN, 119, 416,
	FONT_NEXT, 116, 293,
	FONT_NEXT, 88, 386,
	FONT_NEXT, 113, 247,
	FONT_END, 103, 25,
	FONT_BEGIN, 88, 386,
	FONT_NEXT, 103, 25,
	FONT_END, 74, 53,
	FONT_BEGIN, 88, 386,
	FONT_NEXT, 74, 53,
	FONT_NEXT, 43, 307,
	FONT_NEXT, 49, 92,
	FONT_END, 33, 145,
	FONT_BEGIN, 43, 307,
	FONT_NEXT, 33, 145,
	FONT_NEXT, 31, 262,
	FONT_END, 27, 214,
	FONT_BEGIN, 272, 623,
	FONT_NEXT, 272, 639,
	FONT_NEXT, 296, 624,
	FONT_END, 321, 620,
	FONT_BEGIN, 321, 620,
	FONT_NEXT, 272, 639,
	FONT_END, 419, 683,
	FONT_BEGIN, 321, 620,
	FONT_NEXT, 419, 683,
	FONT_NEXT, 334, 609,
	FONT_END, 340, 573,
	FONT_BEGIN, 340, 573,
	FONT_NEXT, 419, 683,
	FONT_END, 344, -10,
	FONT_BEGIN, 340, 573,
	FONT_NEXT, 344, -10,
	FONT_END, 340, -7,
	FONT_BEGIN, 340, 573,
	FONT_NEXT, 340, -7,
	FONT_END, 340, 417,
	FONT_BEGIN, 491, 58,
	FONT_NEXT, 491, 42,
	FONT_NEXT, 452, 58,
	FONT_NEXT, 344, -10,
	FONT_NEXT, 432, 68,
	FONT_END, 425, 87,
	FONT_BEGIN, 425, 87,
	FONT_NEXT, 344, -10,
	FONT_NEXT, 424, 114,
	FONT_NEXT, 419, 683,
	FONT_END, 424, 681,
	FONT_ADVANCE, 500, 0
    },
    {
	101,
	FONT_BEGIN, 424, 157,
	FONT_NEXT, 417, 140,
	FONT_NEXT, 408, 164,
	FONT_NEXT, 406, 117,
	FONT_NEXT, 386, 131,
	FONT_NEXT, 368, 61,
	FONT_NEXT, 355, 97,
	FONT_NEXT, 304, 11,
	FONT_NEXT, 311, 70,
	FONT_END, 253, 59,
	FONT_BEGIN, 253, 59,
	FONT_NEXT, 304, 11,
	FONT_END, 262, -5,
	FONT_BEGIN, 253, 59,
	FONT_NEXT, 262, -5,
	FONT_END, 212, -10,
	FONT_BEGIN, 253, 59,
	FONT_NEXT, 212, -10,
	FONT_NEXT, 202, 68,
	FONT_NEXT, 172, -7,
	FONT_NEXT, 153, 101,
	FONT_NEXT, 135, 5,
	FONT_NEXT, 132, 130,
	FONT_NEXT, 104, 23,
	FONT_NEXT, 114, 168,
	FONT_END, 101, 216,
	FONT_BEGIN, 101, 216,
	FONT_NEXT, 104, 23,
	FONT_END, 76, 48,
	FONT_BEGIN, 101, 216,
	FONT_NEXT, 76, 48,
	FONT_NEXT, 94, 277,
	FONT_END, 68, 373,
	FONT_BEGIN, 68, 373,
	FONT_NEXT, 76, 48,
	FONT_END, 54, 80,
	FONT_BEGIN, 68, 373,
	FONT_NEXT, 54, 80,
	FONT_NEXT, 45, 330,
	FONT_NEXT, 38, 119,
	FONT_NEXT, 30, 277,
	FONT_NEXT, 28, 163,
	FONT_END, 25, 214,
	FONT_BEGIN, 303, 309,
	FONT_NEXT, 94, 277,
	FONT_NEXT, 97, 309,
	FONT_NEXT, 68, 373,
	FONT_END, 97, 406,
	FONT_BEGIN, 97, 309,
	FONT_NEXT, 97, 406,
	FONT_NEXT, 113, 364,
	FONT_NEXT, 129, 430,
	FONT_NEXT, 137, 399,
	FONT_NEXT, 163, 447,
	FONT_NEXT, 168, 418,
	FONT_END, 207, 424,
	FONT_BEGIN, 207, 424,
	FONT_NEXT, 163, 447,
	FONT_END, 229, 460,
	FONT_BEGIN, 207, 424,
	FONT_NEXT, 229, 460,
	FONT_NEXT, 254, 412,
	FONT_END, 282, 384,
	FONT_BEGIN, 282, 384,
	FONT_NEXT, 229, 460,
	FONT_END, 294, 449,
	FONT_BEGIN, 282, 384,
	FONT_NEXT, 294, 449,
	FONT_NEXT, 303, 309,
	FONT_NEXT, 348, 417,
	FONT_END, 386, 360,
	FONT_BEGIN, 303, 309,
	FONT_NEXT, 386, 360,
	FONT_END, 398, 322,
	FONT_BEGIN, 303, 309,
	FONT_NEXT, 398, 322,
	FONT_NEXT, 94, 277,
	FONT_END, 405, 277,
	FONT_ADVANCE, 444, 0
    },
    {
	102,
	FONT_BEGIN, 383, 622,
	FONT_NEXT, 379, 603,
	FONT_NEXT, 375, 645,
	FONT_NEXT, 369, 590,
	FONT_NEXT, 354, 665,
	FONT_NEXT, 340, 580,
	FONT_NEXT, 322, 678,
	FONT_NEXT, 246, 655,
	FONT_NEXT, 283, 683,
	FONT_END, 223, 675,
	FONT_BEGIN, 223, 675,
	FONT_NEXT, 246, 655,
	FONT_END, 213, 646,
	FONT_BEGIN, 223, 675,
	FONT_NEXT, 213, 646,
	FONT_NEXT, 178, 654,
	FONT_NEXT, 195, 624,
	FONT_END, 186, 566,
	FONT_BEGIN, 178, 654,
	FONT_NEXT, 186, 566,
	FONT_END, 186, 450,
	FONT_BEGIN, 178, 654,
	FONT_NEXT, 186, 450,
	FONT_END, 99, 58,
	FONT_BEGIN, 178, 654,
	FONT_NEXT, 99, 58,
	FONT_END, 103, 104,
	FONT_BEGIN, 178, 654,
	FONT_NEXT, 103, 104,
	FONT_NEXT, 146, 624,
	FONT_END, 125, 587,
	FONT_BEGIN, 125, 587,
	FONT_NEXT, 103, 104,
	FONT_NEXT, 105, 510,
	FONT_END, 103, 476,
	FONT_BEGIN, 103, 476,
	FONT_NEXT, 103, 104,
	FONT_NEXT, 103, 450,
	FONT_NEXT, 103, 418,
	FONT_NEXT, 21, 450,
	FONT_END, 21, 418,
	FONT_BEGIN, 309, 450,
	FONT_NEXT, 309, 418,
	FONT_NEXT, 186, 450,
	FONT_NEXT, 187, 418,
	FONT_END, 187, 104,
	FONT_BEGIN, 186, 450,
	FONT_NEXT, 187, 104,
	FONT_NEXT, 99, 58,
	FONT_END, 86, 31,
	FONT_BEGIN, 86, 31,
	FONT_NEXT, 187, 104,
	FONT_END, 188, 64,
	FONT_BEGIN, 86, 31,
	FONT_NEXT, 188, 64,
	FONT_END, 20, 0,
	FONT_BEGIN, 86, 31,
	FONT_NEXT, 20, 0,
	FONT_NEXT, 60, 19,
	FONT_END, 20, 15,
	FONT_BEGIN, 280, 15,
	FONT_NEXT, 280, 0,
	FONT_NEXT, 226, 21,
	FONT_NEXT, 20, 0,
	FONT_NEXT, 199, 37,
	FONT_END, 188, 64,
	FONT_ADVANCE, 333, 0
    },
    {
	103,
	FONT_BEGIN, 69, 293,
	FONT_NEXT, 73, 334,
	FONT_NEXT, 75, 251,
	FONT_NEXT, 85, 369,
	FONT_NEXT, 93, 216,
	FONT_END, 122, 186,
	FONT_BEGIN, 122, 186,
	FONT_NEXT, 85, 369,
	FONT_END, 126, 421,
	FONT_BEGIN, 122, 186,
	FONT_NEXT, 126, 421,
	FONT_END, 152, 342,
	FONT_BEGIN, 122, 186,
	FONT_NEXT, 152, 342,
	FONT_END, 157, 282,
	FONT_BEGIN, 122, 186,
	FONT_NEXT, 157, 282,
	FONT_NEXT, 162, 163,
	FONT_NEXT, 174, 228,
	FONT_END, 175, 146,
	FONT_BEGIN, 162, 163,
	FONT_NEXT, 175, 146,
	FONT_END, 155, 129,
	FONT_BEGIN, 162, 163,
	FONT_NEXT, 155, 129,
	FONT_NEXT, 132, 136,
	FONT_NEXT, 139, 109,
	FONT_END, 133, 91,
	FONT_BEGIN, 132, 136,
	FONT_NEXT, 133, 91,
	FONT_END, 126, 1,
	FONT_BEGIN, 132, 136,
	FONT_NEXT, 126, 1,
	FONT_NEXT, 110, 115,
	FONT_NEXT, 89, 21,
	FONT_NEXT, 84, 85,
	FONT_NEXT, 77, 35,
	FONT_NEXT, 74, 67,
	FONT_END, 73, 54,
	FONT_BEGIN, 175, 146,
	FONT_NEXT, 174, 228,
	FONT_NEXT, 193, 154,
	FONT_NEXT, 206, 189,
	FONT_END, 229, 177,
	FONT_BEGIN, 193, 154,
	FONT_NEXT, 229, 177,
	FONT_NEXT, 247, 149,
	FONT_NEXT, 256, 174,
	FONT_NEXT, 295, 156,
	FONT_NEXT, 296, 185,
	FONT_END, 318, 213,
	FONT_BEGIN, 295, 156,
	FONT_NEXT, 318, 213,
	FONT_NEXT, 347, 182,
	FONT_NEXT, 327, 245,
	FONT_END, 329, 270,
	FONT_BEGIN, 347, 182,
	FONT_NEXT, 329, 270,
	FONT_NEXT, 338, 437,
	FONT_NEXT, 325, 307,
	FONT_NEXT, 287, 454,
	FONT_NEXT, 310, 361,
	FONT_END, 279, 410,
	FONT_BEGIN, 287, 454,
	FONT_NEXT, 279, 410,
	FONT_NEXT, 241, 460,
	FONT_NEXT, 256, 426,
	FONT_END, 227, 432,
	FONT_BEGIN, 241, 460,
	FONT_NEXT, 227, 432,
	FONT_NEXT, 182, 450,
	FONT_NEXT, 200, 427,
	FONT_END, 176, 412,
	FONT_BEGIN, 182, 450,
	FONT_NEXT, 176, 412,
	FONT_NEXT, 126, 421,
	FONT_NEXT, 158, 384,
	FONT_END, 152, 342,
	FONT_BEGIN, 28, -121,
	FONT_NEXT, 36, -89,
	FONT_NEXT, 41, -159,
	FONT_NEXT, 57, -57,
	FONT_NEXT, 78, -190,
	FONT_NEXT, 98, -90,
	FONT_END, 105, -115,
	FONT_BEGIN, 78, -190,
	FONT_NEXT, 105, -115,
	FONT_END, 130, -138,
	FONT_BEGIN, 78, -190,
	FONT_NEXT, 130, -138,
	FONT_NEXT, 134, -211,
	FONT_NEXT, 176, -155,
	FONT_NEXT, 205, -218,
	FONT_NEXT, 248, -161,
	FONT_NEXT, 282, -208,
	FONT_NEXT, 326, -154,
	FONT_NEXT, 366, -176,
	FONT_NEXT, 384, -133,
	FONT_NEXT, 403, -153,
	FONT_NEXT, 420, -102,
	FONT_NEXT, 433, -124,
	FONT_NEXT, 433, -64,
	FONT_NEXT, 440, 13,
	FONT_END, 404, 43,
	FONT_BEGIN, 404, 43,
	FONT_NEXT, 433, -64,
	FONT_END, 424, -38,
	FONT_BEGIN, 404, 43,
	FONT_NEXT, 424, -38,
	FONT_END, 399, -24,
	FONT_BEGIN, 404, 43,
	FONT_NEXT, 399, -24,
	FONT_NEXT, 375, 53,
	FONT_NEXT, 360, -18,
	FONT_NEXT, 340, 58,
	FONT_NEXT, 310, -15,
	FONT_NEXT, 211, 64,
	FONT_NEXT, 251, -14,
	FONT_END, 210, -12,
	FONT_BEGIN, 211, 64,
	FONT_NEXT, 210, -12,
	FONT_NEXT, 160, 69,
	FONT_NEXT, 147, -2,
	FONT_NEXT, 140, 77,
	FONT_NEXT, 126, 1,
	FONT_END, 133, 91,
	FONT_BEGIN, 147, -2,
	FONT_NEXT, 110, -49,
	FONT_NEXT, 126, 1,
	FONT_END, 57, -57,
	FONT_BEGIN, 57, -57,
	FONT_NEXT, 110, -49,
	FONT_END, 98, -90,
	FONT_BEGIN, 57, -57,
	FONT_END, 98, -90,
	FONT_BEGIN, 461, -49,
	FONT_NEXT, 453, -89,
	FONT_NEXT, 457, -22,
	FONT_END, 440, 13,
	FONT_BEGIN, 440, 13,
	FONT_NEXT, 453, -89,
	FONT_END, 433, -124,
	FONT_BEGIN, 440, 13,
	FONT_END, 433, -124,
	FONT_BEGIN, 470, 427,
	FONT_NEXT, 470, 388,
	FONT_NEXT, 393, 427,
	FONT_NEXT, 387, 388,
	FONT_NEXT, 338, 437,
	FONT_END, 347, 182,
	FONT_BEGIN, 347, 182,
	FONT_NEXT, 387, 388,
	FONT_NEXT, 389, 227,
	FONT_NEXT, 400, 352,
	FONT_NEXT, 401, 258,
	FONT_NEXT, 404, 328,
	FONT_END, 406, 296,
	FONT_ADVANCE, 500, 0
    },
    {
	104,
	FONT_BEGIN, 157, 680,
	FONT_NEXT, 157, 378,
	FONT_NEXT, 152, 683,
	FONT_NEXT, 157, 343,
	FONT_END, 157, 102,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 157, 102,
	FONT_END, 70, 58,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 70, 58,
	FONT_END, 73, 102,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 73, 102,
	FONT_END, 73, 573,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 73, 573,
	FONT_END, 67, 609,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 67, 609,
	FONT_END, 54, 620,
	FONT_BEGIN, 152, 683,
	FONT_NEXT, 54, 620,
	FONT_NEXT, 10, 639,
	FONT_NEXT, 29, 624,
	FONT_END, 10, 623,
	FONT_BEGIN, 427, 301,
	FONT_NEXT, 427, 102,
	FONT_NEXT, 424, 342,
	FONT_NEXT, 339, 56,
	FONT_NEXT, 411, 395,
	FONT_END, 396, 420,
	FONT_BEGIN, 396, 420,
	FONT_NEXT, 339, 56,
	FONT_NEXT, 374, 440,
	FONT_NEXT, 343, 102,
	FONT_NEXT, 343, 454,
	FONT_NEXT, 343, 300,
	FONT_END, 338, 344,
	FONT_BEGIN, 343, 454,
	FONT_NEXT, 338, 344,
	FONT_NEXT, 303, 460,
	FONT_NEXT, 325, 378,
	FONT_END, 301, 398,
	FONT_BEGIN, 303, 460,
	FONT_NEXT, 301, 398,
	FONT_NEXT, 260, 454,
	FONT_NEXT, 266, 406,
	FONT_END, 216, 392,
	FONT_BEGIN, 260, 454,
	FONT_NEXT, 216, 392,
	FONT_NEXT, 221, 437,
	FONT_END, 187, 411,
	FONT_BEGIN, 187, 411,
	FONT_NEXT, 216, 392,
	FONT_END, 187, 373,
	FONT_BEGIN, 187, 411,
	FONT_NEXT, 187, 373,
	FONT_NEXT, 159, 378,
	FONT_NEXT, 157, 343,
	FONT_END, 157, 378,
	FONT_BEGIN, 487, 15,
	FONT_NEXT, 487, 0,
	FONT_NEXT, 456, 22,
	FONT_NEXT, 275, 0,
	FONT_NEXT, 438, 34,
	FONT_END, 429, 58,
	FONT_BEGIN, 429, 58,
	FONT_NEXT, 275, 0,
	FONT_END, 327, 31,
	FONT_BEGIN, 429, 58,
	FONT_NEXT, 327, 31,
	FONT_NEXT, 427, 102,
	FONT_END, 339, 56,
	FONT_BEGIN, 275, 15,
	FONT_NEXT, 306, 19,
	FONT_NEXT, 275, 0,
	FONT_END, 327, 31,
	FONT_BEGIN, 225, 15,
	FONT_NEXT, 225, 0,
	FONT_NEXT, 193, 19,
	FONT_NEXT, 9, 0,
	FONT_NEXT, 172, 31,
	FONT_END, 160, 56,
	FONT_BEGIN, 160, 56,
	FONT_NEXT, 9, 0,
	FONT_END, 61, 33,
	FONT_BEGIN, 160, 56,
	FONT_NEXT, 61, 33,
	FONT_NEXT, 157, 102,
	FONT_END, 70, 58,
	FONT_BEGIN, 9, 15,
	FONT_NEXT, 41, 21,
	FONT_NEXT, 9, 0,
	FONT_END, 61, 33,
	FONT_ADVANCE, 500, 0
    },
    {
	105,
	FONT_BEGIN, 179, 457,
	FONT_NEXT, 179, 102,
	FONT_NEXT, 175, 460,
	FONT_NEXT, 91, 55,
	FONT_END, 95, 102,
	FONT_BEGIN, 175, 460,
	FONT_NEXT, 95, 102,
	FONT_END, 95, 334,
	FONT_BEGIN, 175, 460,
	FONT_NEXT, 95, 334,
	FONT_END, 91, 368,
	FONT_BEGIN, 175, 460,
	FONT_NEXT, 91, 368,
	FONT_END, 83, 386,
	FONT_BEGIN, 175, 460,
	FONT_NEXT, 83, 386,
	FONT_END, 60, 394,
	FONT_BEGIN, 175, 460,
	FONT_NEXT, 60, 394,
	FONT_NEXT, 20, 405,
	FONT_END, 20, 390,
	FONT_BEGIN, 16, 15,
	FONT_NEXT, 54, 18,
	FONT_NEXT, 16, 0,
	FONT_END, 180, 61,
	FONT_BEGIN, 180, 61,
	FONT_NEXT, 54, 18,
	FONT_END, 78, 30,
	FONT_BEGIN, 180, 61,
	FONT_NEXT, 78, 30,
	FONT_NEXT, 179, 102,
	FONT_END, 91, 55,
	FONT_BEGIN, 253, 15,
	FONT_NEXT, 253, 0,
	FONT_NEXT, 212, 21,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 190, 35,
	FONT_END, 180, 61,
	FONT_BEGIN, 180, 632,
	FONT_NEXT, 176, 611,
	FONT_NEXT, 165, 668,
	FONT_NEXT, 165, 595,
	FONT_NEXT, 148, 678,
	FONT_NEXT, 148, 584,
	FONT_NEXT, 128, 683,
	FONT_NEXT, 128, 581,
	FONT_NEXT, 105, 677,
	FONT_NEXT, 105, 586,
	FONT_NEXT, 89, 664,
	FONT_NEXT, 89, 599,
	FONT_END, 78, 632,
	FONT_ADVANCE, 278, 0
    },
    {
	106,
	FONT_BEGIN, 32, 390,
	FONT_NEXT, 32, 406,
	FONT_NEXT, 74, 394,
	FONT_NEXT, 188, 460,
	FONT_NEXT, 97, 386,
	FONT_END, 105, 368,
	FONT_BEGIN, 105, 368,
	FONT_NEXT, 188, 460,
	FONT_END, 184, -84,
	FONT_BEGIN, 105, 368,
	FONT_NEXT, 184, -84,
	FONT_NEXT, 109, 334,
	FONT_NEXT, 156, -153,
	FONT_END, 133, -180,
	FONT_BEGIN, 109, 334,
	FONT_NEXT, 133, -180,
	FONT_NEXT, 109, -45,
	FONT_END, 108, -102,
	FONT_BEGIN, 108, -102,
	FONT_NEXT, 133, -180,
	FONT_END, 103, -201,
	FONT_BEGIN, 108, -102,
	FONT_NEXT, 103, -201,
	FONT_NEXT, 102, -146,
	FONT_NEXT, 67, -214,
	FONT_NEXT, 87, -174,
	FONT_END, 59, -184,
	FONT_BEGIN, 59, -184,
	FONT_NEXT, 67, -214,
	FONT_END, 23, -218,
	FONT_BEGIN, 59, -184,
	FONT_NEXT, 23, -218,
	FONT_NEXT, -30, -124,
	FONT_NEXT, -12, -215,
	FONT_END, -42, -204,
	FONT_BEGIN, -30, -124,
	FONT_NEXT, -42, -204,
	FONT_NEXT, -58, -135,
	FONT_NEXT, -63, -187,
	FONT_END, -70, -162,
	FONT_BEGIN, 193, 457,
	FONT_NEXT, 193, 0,
	FONT_NEXT, 188, 460,
	FONT_END, 184, -84,
	FONT_BEGIN, 194, 632,
	FONT_NEXT, 190, 611,
	FONT_NEXT, 179, 668,
	FONT_NEXT, 179, 595,
	FONT_NEXT, 162, 678,
	FONT_NEXT, 162, 584,
	FONT_NEXT, 142, 683,
	FONT_NEXT, 142, 581,
	FONT_NEXT, 119, 677,
	FONT_NEXT, 119, 586,
	FONT_NEXT, 103, 664,
	FONT_NEXT, 103, 599,
	FONT_END, 92, 632,
	FONT_ADVANCE, 278, 0
    },
    {
	107,
	FONT_BEGIN, 166, 681,
	FONT_NEXT, 166, 265,
	FONT_NEXT, 162, 683,
	FONT_NEXT, 166, 248,
	FONT_END, 166, 67,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 166, 67,
	FONT_END, 79, 50,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 79, 50,
	FONT_END, 82, 82,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 82, 82,
	FONT_END, 82, 564,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 82, 564,
	FONT_END, 80, 592,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 80, 592,
	FONT_END, 74, 611,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 74, 611,
	FONT_END, 60, 621,
	FONT_BEGIN, 162, 683,
	FONT_NEXT, 60, 621,
	FONT_NEXT, 7, 639,
	FONT_NEXT, 37, 625,
	FONT_END, 7, 623,
	FONT_BEGIN, 276, 436,
	FONT_NEXT, 276, 450,
	FONT_NEXT, 301, 434,
	FONT_END, 316, 430,
	FONT_BEGIN, 316, 430,
	FONT_NEXT, 276, 450,
	FONT_END, 377, 404,
	FONT_BEGIN, 316, 430,
	FONT_NEXT, 377, 404,
	FONT_NEXT, 326, 417,
	FONT_NEXT, 347, 381,
	FONT_END, 309, 350,
	FONT_BEGIN, 326, 417,
	FONT_NEXT, 309, 350,
	FONT_NEXT, 320, 401,
	FONT_END, 303, 383,
	FONT_BEGIN, 303, 383,
	FONT_NEXT, 309, 350,
	FONT_END, 264, 309,
	FONT_BEGIN, 303, 383,
	FONT_NEXT, 264, 309,
	FONT_NEXT, 168, 263,
	FONT_NEXT, 235, 282,
	FONT_END, 168, 248,
	FONT_BEGIN, 168, 263,
	FONT_NEXT, 168, 248,
	FONT_NEXT, 166, 265,
	FONT_END, 166, 248,
	FONT_BEGIN, 480, 450,
	FONT_NEXT, 480, 435,
	FONT_NEXT, 276, 450,
	FONT_NEXT, 442, 433,
	FONT_END, 402, 419,
	FONT_BEGIN, 276, 450,
	FONT_NEXT, 402, 419,
	FONT_END, 377, 404,
	FONT_BEGIN, 505, 15,
	FONT_NEXT, 505, 0,
	FONT_NEXT, 482, 18,
	FONT_NEXT, 287, 0,
	FONT_NEXT, 455, 28,
	FONT_END, 424, 49,
	FONT_BEGIN, 424, 49,
	FONT_NEXT, 287, 0,
	FONT_END, 319, 18,
	FONT_BEGIN, 424, 49,
	FONT_NEXT, 319, 18,
	FONT_NEXT, 388, 88,
	FONT_NEXT, 327, 31,
	FONT_NEXT, 235, 282,
	FONT_NEXT, 321, 43,
	FONT_END, 306, 64,
	FONT_BEGIN, 235, 282,
	FONT_NEXT, 306, 64,
	FONT_END, 168, 248,
	FONT_BEGIN, 287, 15,
	FONT_NEXT, 306, 15,
	FONT_NEXT, 287, 0,
	FONT_END, 319, 18,
	FONT_BEGIN, 241, 15,
	FONT_NEXT, 241, 0,
	FONT_NEXT, 221, 16,
	FONT_NEXT, 7, 0,
	FONT_NEXT, 181, 26,
	FONT_END, 169, 42,
	FONT_BEGIN, 169, 42,
	FONT_NEXT, 7, 0,
	FONT_NEXT, 166, 67,
	FONT_NEXT, 69, 32,
	FONT_END, 79, 50,
	FONT_BEGIN, 7, 15,
	FONT_NEXT, 46, 22,
	FONT_NEXT, 7, 0,
	FONT_END, 69, 32,
	FONT_ADVANCE, 500, 0
    },
    {
	108,
	FONT_BEGIN, 182, 681,
	FONT_NEXT, 182, 84,
	FONT_NEXT, 178, 683,
	FONT_NEXT, 94, 53,
	FONT_END, 98, 87,
	FONT_BEGIN, 178, 683,
	FONT_NEXT, 98, 87,
	FONT_END, 98, 564,
	FONT_BEGIN, 178, 683,
	FONT_NEXT, 98, 564,
	FONT_END, 96, 592,
	FONT_BEGIN, 178, 683,
	FONT_NEXT, 96, 592,
	FONT_END, 90, 611,
	FONT_BEGIN, 178, 683,
	FONT_NEXT, 90, 611,
	FONT_END, 76, 621,
	FONT_BEGIN, 178, 683,
	FONT_NEXT, 76, 621,
	FONT_NEXT, 19, 639,
	FONT_NEXT, 53, 625,
	FONT_END, 19, 623,
	FONT_BEGIN, 257, 15,
	FONT_NEXT, 257, 0,
	FONT_NEXT, 220, 18,
	FONT_NEXT, 21, 0,
	FONT_NEXT, 197, 28,
	FONT_END, 185, 49,
	FONT_BEGIN, 185, 49,
	FONT_NEXT, 21, 0,
	FONT_END, 81, 31,
	FONT_BEGIN, 185, 49,
	FONT_NEXT, 81, 31,
	FONT_NEXT, 182, 84,
	FONT_END, 94, 53,
	FONT_BEGIN, 21, 15,
	FONT_NEXT, 57, 20,
	FONT_NEXT, 21, 0,
	FONT_END, 81, 31,
	FONT_ADVANCE, 278, 0
    },
    {
	109,
	FONT_BEGIN, 166, 458,
	FONT_NEXT, 166, 383,
	FONT_NEXT, 159, 460,
	FONT_NEXT, 80, 45,
	FONT_END, 86, 85,
	FONT_BEGIN, 159, 460,
	FONT_NEXT, 86, 85,
	FONT_END, 86, 338,
	FONT_BEGIN, 159, 460,
	FONT_NEXT, 86, 338,
	FONT_END, 82, 374,
	FONT_BEGIN, 159, 460,
	FONT_NEXT, 82, 374,
	FONT_END, 74, 393,
	FONT_BEGIN, 159, 460,
	FONT_NEXT, 74, 393,
	FONT_NEXT, 19, 415,
	FONT_NEXT, 51, 402,
	FONT_END, 19, 398,
	FONT_BEGIN, 706, 282,
	FONT_NEXT, 706, 76,
	FONT_NEXT, 702, 341,
	FONT_NEXT, 618, 49,
	FONT_NEXT, 686, 398,
	FONT_NEXT, 622, 87,
	FONT_NEXT, 650, 442,
	FONT_END, 622, 455,
	FONT_BEGIN, 622, 455,
	FONT_NEXT, 622, 87,
	FONT_END, 622, 298,
	FONT_BEGIN, 622, 455,
	FONT_NEXT, 622, 298,
	FONT_END, 612, 372,
	FONT_BEGIN, 622, 455,
	FONT_NEXT, 612, 372,
	FONT_NEXT, 588, 460,
	FONT_NEXT, 590, 397,
	FONT_END, 549, 408,
	FONT_BEGIN, 588, 460,
	FONT_NEXT, 549, 408,
	FONT_NEXT, 532, 450,
	FONT_NEXT, 511, 403,
	FONT_NEXT, 485, 427,
	FONT_NEXT, 481, 390,
	FONT_NEXT, 449, 399,
	FONT_NEXT, 438, 347,
	FONT_NEXT, 427, 376,
	FONT_NEXT, 438, 95,
	FONT_END, 349, 47,
	FONT_BEGIN, 427, 376,
	FONT_NEXT, 349, 47,
	FONT_NEXT, 414, 406,
	FONT_NEXT, 354, 86,
	FONT_NEXT, 393, 433,
	FONT_END, 362, 452,
	FONT_BEGIN, 362, 452,
	FONT_NEXT, 354, 86,
	FONT_END, 354, 303,
	FONT_BEGIN, 362, 452,
	FONT_NEXT, 354, 303,
	FONT_END, 350, 347,
	FONT_BEGIN, 362, 452,
	FONT_NEXT, 350, 347,
	FONT_NEXT, 320, 460,
	FONT_NEXT, 339, 380,
	FONT_END, 317, 400,
	FONT_BEGIN, 320, 460,
	FONT_NEXT, 317, 400,
	FONT_NEXT, 281, 454,
	FONT_NEXT, 285, 408,
	FONT_END, 237, 399,
	FONT_BEGIN, 281, 454,
	FONT_NEXT, 237, 399,
	FONT_NEXT, 244, 438,
	FONT_END, 166, 383,
	FONT_BEGIN, 166, 383,
	FONT_NEXT, 237, 399,
	FONT_END, 201, 380,
	FONT_BEGIN, 166, 383,
	FONT_NEXT, 201, 380,
	FONT_END, 178, 360,
	FONT_BEGIN, 166, 383,
	FONT_NEXT, 178, 360,
	FONT_END, 170, 349,
	FONT_BEGIN, 166, 383,
	FONT_NEXT, 170, 349,
	FONT_END, 170, 67,
	FONT_BEGIN, 166, 383,
	FONT_NEXT, 170, 67,
	FONT_NEXT, 80, 45,
	FONT_END, 66, 25,
	FONT_BEGIN, 66, 25,
	FONT_NEXT, 170, 67,
	FONT_END, 16, 0,
	FONT_BEGIN, 66, 25,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 43, 16,
	FONT_END, 16, 15,
	FONT_BEGIN, 775, 15,
	FONT_NEXT, 775, 0,
	FONT_NEXT, 749, 17,
	FONT_NEXT, 556, 0,
	FONT_NEXT, 723, 26,
	FONT_END, 711, 40,
	FONT_BEGIN, 711, 40,
	FONT_NEXT, 556, 0,
	FONT_NEXT, 706, 76,
	FONT_NEXT, 607, 29,
	FONT_END, 618, 49,
	FONT_BEGIN, 556, 15,
	FONT_NEXT, 587, 19,
	FONT_NEXT, 556, 0,
	FONT_END, 607, 29,
	FONT_BEGIN, 510, 15,
	FONT_NEXT, 510, 0,
	FONT_NEXT, 481, 17,
	FONT_NEXT, 286, 0,
	FONT_NEXT, 458, 26,
	FONT_END, 443, 50,
	FONT_BEGIN, 443, 50,
	FONT_NEXT, 286, 0,
	FONT_END, 336, 27,
	FONT_BEGIN, 443, 50,
	FONT_NEXT, 336, 27,
	FONT_NEXT, 438, 95,
	FONT_END, 349, 47,
	FONT_BEGIN, 286, 15,
	FONT_NEXT, 315, 18,
	FONT_NEXT, 286, 0,
	FONT_END, 336, 27,
	FONT_BEGIN, 238, 15,
	FONT_NEXT, 238, 0,
	FONT_NEXT, 190, 23,
	FONT_NEXT, 16, 0,
	FONT_NEXT, 175, 38,
	FONT_END, 170, 67,
	FONT_ADVANCE, 778, 0
    },
    {
	110,
	FONT_BEGIN, 161, 458,
	FONT_NEXT, 161, 379,
	FONT_NEXT, 154, 460,
	FONT_NEXT, 76, 53,
	FONT_END, 80, 90,
	FONT_BEGIN, 154, 460,
	FONT_NEXT, 80, 90,
	FONT_END, 80, 338,
	FONT_BEGIN, 154, 460,
	FONT_NEXT, 80, 338,
	FONT_END, 76, 374,
	FONT_BEGIN, 154, 460,
	FONT_NEXT, 76, 374,
	FONT_END, 68, 393,
	FONT_BEGIN, 154, 460,
	FONT_NEXT, 68, 393,
	FONT_NEXT, 16, 415,
	FONT_NEXT, 45, 402,
	FONT_END, 16, 398,
	FONT_BEGIN, 424, 310,
	FONT_NEXT, 424, 81,
	FONT_NEXT, 420, 351,
	FONT_NEXT, 335, 54,
	FONT_NEXT, 412, 385,
	FONT_END, 382, 431,
	FONT_BEGIN, 382, 431,
	FONT_NEXT, 335, 54,
	FONT_END, 340, 99,
	FONT_BEGIN, 382, 431,
	FONT_NEXT, 340, 99,
	FONT_NEXT, 344, 453,
	FONT_NEXT, 340, 308,
	FONT_END, 336, 348,
	FONT_BEGIN, 344, 453,
	FONT_NEXT, 336, 348,
	FONT_NEXT, 307, 460,
	FONT_NEXT, 323, 379,
	FONT_END, 299, 398,
	FONT_BEGIN, 307, 460,
	FONT_NEXT, 299, 398,
	FONT_NEXT, 266, 453,
	FONT_NEXT, 263, 405,
	FONT_NEXT, 230, 436,
	FONT_NEXT, 216, 390,
	FONT_NEXT, 161, 379,
	FONT_NEXT, 164, 348,
	FONT_END, 164, 67,
	FONT_BEGIN, 161, 379,
	FONT_NEXT, 164, 67,
	FONT_NEXT, 76, 53,
	FONT_END, 66, 31,
	FONT_BEGIN, 66, 31,
	FONT_NEXT, 164, 67,
	FONT_END, 18, 0,
	FONT_BEGIN, 66, 31,
	FONT_NEXT, 18, 0,
	FONT_NEXT, 47, 19,
	FONT_END, 18, 15,
	FONT_BEGIN, 485, 15,
	FONT_NEXT, 485, 0,
	FONT_NEXT, 454, 20,
	FONT_NEXT, 277, 0,
	FONT_NEXT, 436, 31,
	FONT_END, 426, 51,
	FONT_BEGIN, 426, 51,
	FONT_NEXT, 277, 0,
	FONT_NEXT, 424, 81,
	FONT_NEXT, 322, 29,
	FONT_END, 335, 54,
	FONT_BEGIN, 277, 15,
	FONT_NEXT, 302, 18,
	FONT_NEXT, 277, 0,
	FONT_END, 322, 29,
	FONT_BEGIN, 230, 15,
	FONT_NEXT, 230, 0,
	FONT_NEXT, 197, 19,
	FONT_NEXT, 18, 0,
	FONT_NEXT, 177, 29,
	FONT_END, 167, 45,
	FONT_BEGIN, 167, 45,
	FONT_NEXT, 18, 0,
	FONT_END, 164, 67,
	FONT_BEGIN, 167, 45,
	FONT_END, 164, 67,
	FONT_ADVANCE, 500, 0
    },
    {
	111,
	FONT_BEGIN, 470, 228,
	FONT_NEXT, 456, 149,
	FONT_NEXT, 465, 279,
	FONT_END, 453, 325,
	FONT_BEGIN, 453, 325,
	FONT_NEXT, 456, 149,
	FONT_END, 416, 71,
	FONT_BEGIN, 453, 325,
	FONT_NEXT, 416, 71,
	FONT_NEXT, 433, 365,
	FONT_END, 406, 398,
	FONT_BEGIN, 406, 398,
	FONT_NEXT, 416, 71,
	FONT_END, 385, 39,
	FONT_BEGIN, 406, 398,
	FONT_NEXT, 385, 39,
	FONT_NEXT, 373, 424,
	FONT_NEXT, 380, 199,
	FONT_END, 370, 287,
	FONT_BEGIN, 373, 424,
	FONT_NEXT, 370, 287,
	FONT_NEXT, 335, 444,
	FONT_NEXT, 343, 362,
	FONT_END, 322, 390,
	FONT_BEGIN, 335, 444,
	FONT_NEXT, 322, 390,
	FONT_NEXT, 292, 455,
	FONT_NEXT, 298, 413,
	FONT_END, 269, 427,
	FONT_BEGIN, 292, 455,
	FONT_NEXT, 269, 427,
	FONT_NEXT, 245, 460,
	FONT_NEXT, 237, 432,
	FONT_NEXT, 197, 455,
	FONT_NEXT, 191, 422,
	FONT_NEXT, 154, 441,
	FONT_NEXT, 154, 393,
	FONT_NEXT, 117, 419,
	FONT_NEXT, 128, 344,
	FONT_END, 119, 276,
	FONT_BEGIN, 117, 419,
	FONT_NEXT, 119, 276,
	FONT_END, 90, 58,
	FONT_BEGIN, 117, 419,
	FONT_NEXT, 90, 58,
	FONT_NEXT, 86, 390,
	FONT_NEXT, 64, 93,
	FONT_NEXT, 62, 355,
	FONT_NEXT, 45, 133,
	FONT_NEXT, 43, 316,
	FONT_NEXT, 33, 179,
	FONT_END, 29, 228,
	FONT_BEGIN, 90, 58,
	FONT_NEXT, 119, 276,
	FONT_NEXT, 122, 29,
	FONT_NEXT, 124, 204,
	FONT_END, 145, 119,
	FONT_BEGIN, 122, 29,
	FONT_NEXT, 145, 119,
	FONT_NEXT, 159, 8,
	FONT_NEXT, 164, 80,
	FONT_END, 189, 47,
	FONT_BEGIN, 159, 8,
	FONT_NEXT, 189, 47,
	FONT_NEXT, 201, -6,
	FONT_NEXT, 221, 26,
	FONT_NEXT, 248, -10,
	FONT_NEXT, 262, 18,
	FONT_NEXT, 301, -4,
	FONT_NEXT, 301, 26,
	FONT_END, 340, 54,
	FONT_BEGIN, 301, -4,
	FONT_NEXT, 340, 54,
	FONT_NEXT, 346, 13,
	FONT_NEXT, 356, 78,
	FONT_END, 368, 110,
	FONT_BEGIN, 346, 13,
	FONT_NEXT, 368, 110,
	FONT_NEXT, 385, 39,
	FONT_NEXT, 377, 150,
	FONT_END, 380, 199,
	FONT_ADVANCE, 500, 0
    },
    {
	112,
	FONT_BEGIN, 159, 458,
	FONT_NEXT, 159, 385,
	FONT_NEXT, 153, 460,
	FONT_NEXT, 159, 334,
	FONT_END, 159, 88,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 159, 88,
	FONT_END, 159, 33,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 159, 33,
	FONT_END, 159, -124,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 159, -124,
	FONT_END, 73, -160,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 73, -160,
	FONT_END, 75, -131,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 75, -131,
	FONT_END, 75, 337,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 75, 337,
	FONT_END, 73, 362,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 73, 362,
	FONT_END, 69, 380,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 69, 380,
	FONT_END, 57, 390,
	FONT_BEGIN, 153, 460,
	FONT_NEXT, 57, 390,
	FONT_NEXT, 9, 409,
	FONT_NEXT, 37, 394,
	FONT_END, 9, 393,
	FONT_BEGIN, 470, 245,
	FONT_NEXT, 456, 156,
	FONT_NEXT, 466, 292,
	FONT_END, 456, 334,
	FONT_BEGIN, 456, 334,
	FONT_NEXT, 456, 156,
	FONT_NEXT, 420, 402,
	FONT_NEXT, 417, 74,
	FONT_NEXT, 368, 445,
	FONT_NEXT, 384, 215,
	FONT_END, 383, 229,
	FONT_BEGIN, 368, 445,
	FONT_NEXT, 383, 229,
	FONT_END, 381, 253,
	FONT_BEGIN, 368, 445,
	FONT_NEXT, 381, 253,
	FONT_END, 366, 316,
	FONT_BEGIN, 368, 445,
	FONT_NEXT, 366, 316,
	FONT_NEXT, 305, 460,
	FONT_NEXT, 350, 347,
	FONT_END, 328, 374,
	FONT_BEGIN, 305, 460,
	FONT_NEXT, 328, 374,
	FONT_END, 297, 392,
	FONT_BEGIN, 305, 460,
	FONT_NEXT, 297, 392,
	FONT_NEXT, 252, 451,
	FONT_NEXT, 257, 400,
	FONT_END, 227, 395,
	FONT_BEGIN, 252, 451,
	FONT_NEXT, 227, 395,
	FONT_NEXT, 212, 432,
	FONT_NEXT, 196, 381,
	FONT_NEXT, 181, 406,
	FONT_NEXT, 171, 360,
	FONT_NEXT, 161, 383,
	FONT_NEXT, 159, 334,
	FONT_END, 159, 385,
	FONT_BEGIN, 159, 88,
	FONT_NEXT, 167, 67,
	FONT_NEXT, 159, 33,
	FONT_NEXT, 189, 46,
	FONT_NEXT, 206, -1,
	FONT_NEXT, 221, 29,
	FONT_NEXT, 260, -10,
	FONT_NEXT, 261, 22,
	FONT_END, 294, 27,
	FONT_BEGIN, 260, -10,
	FONT_NEXT, 294, 27,
	FONT_NEXT, 308, -4,
	FONT_NEXT, 334, 53,
	FONT_NEXT, 351, 13,
	FONT_NEXT, 353, 77,
	FONT_END, 369, 111,
	FONT_BEGIN, 351, 13,
	FONT_NEXT, 369, 111,
	FONT_END, 380, 156,
	FONT_BEGIN, 351, 13,
	FONT_NEXT, 380, 156,
	FONT_NEXT, 387, 40,
	FONT_NEXT, 384, 215,
	FONT_END, 417, 74,
	FONT_BEGIN, 5, -200,
	FONT_NEXT, 43, -194,
	FONT_NEXT, 5, -217,
	FONT_END, 159, -124,
	FONT_BEGIN, 159, -124,
	FONT_NEXT, 43, -194,
	FONT_END, 64, -180,
	FONT_BEGIN, 159, -124,
	FONT_NEXT, 64, -180,
	FONT_END, 73, -160,
	FONT_BEGIN, 247, -199,
	FONT_NEXT, 247, -217,
	FONT_NEXT, 202, -197,
	FONT_NEXT, 5, -217,
	FONT_NEXT, 176, -186,
	FONT_END, 162, -163,
	FONT_BEGIN, 162, -163,
	FONT_NEXT, 5, -217,
	FONT_END, 159, -124,
	FONT_BEGIN, 162, -163,
	FONT_END, 159, -124,
	FONT_ADVANCE, 500, 0
    },
    {
	113,
	FONT_BEGIN, 110, 238,
	FONT_NEXT, 117, 169,
	FONT_NEXT, 72, 44,
	FONT_END, 124, 3,
	FONT_BEGIN, 124, 3,
	FONT_NEXT, 117, 169,
	FONT_END, 140, 110,
	FONT_BEGIN, 124, 3,
	FONT_NEXT, 140, 110,
	FONT_END, 180, 67,
	FONT_BEGIN, 124, 3,
	FONT_NEXT, 180, 67,
	FONT_NEXT, 188, -10,
	FONT_NEXT, 206, 55,
	FONT_NEXT, 234, -3,
	FONT_NEXT, 238, 51,
	FONT_NEXT, 278, 14,
	FONT_NEXT, 288, 60,
	FONT_NEXT, 314, 38,
	FONT_NEXT, 318, 73,
	FONT_END, 333, 88,
	FONT_BEGIN, 314, 38,
	FONT_NEXT, 333, 88,
	FONT_NEXT, 336, 62,
	FONT_END, 341, 62,
	FONT_BEGIN, 341, 62,
	FONT_NEXT, 333, 88,
	FONT_END, 341, 127,
	FONT_BEGIN, 341, 62,
	FONT_NEXT, 341, 127,
	FONT_NEXT, 341, -124,
	FONT_NEXT, 341, 333,
	FONT_NEXT, 360, 425,
	FONT_NEXT, 339, 360,
	FONT_END, 328, 393,
	FONT_BEGIN, 360, 425,
	FONT_NEXT, 328, 393,
	FONT_NEXT, 308, 450,
	FONT_NEXT, 300, 420,
	FONT_NEXT, 247, 460,
	FONT_NEXT, 276, 428,
	FONT_END, 245, 432,
	FONT_BEGIN, 247, 460,
	FONT_NEXT, 245, 432,
	FONT_NEXT, 201, 455,
	FONT_NEXT, 189, 418,
	FONT_NEXT, 159, 440,
	FONT_NEXT, 147, 380,
	FONT_NEXT, 121, 417,
	FONT_NEXT, 119, 319,
	FONT_NEXT, 88, 387,
	FONT_NEXT, 110, 238,
	FONT_END, 72, 44,
	FONT_BEGIN, 88, 387,
	FONT_NEXT, 72, 44,
	FONT_NEXT, 61, 351,
	FONT_NEXT, 52, 75,
	FONT_NEXT, 41, 308,
	FONT_NEXT, 37, 113,
	FONT_NEXT, 28, 262,
	FONT_NEXT, 27, 159,
	FONT_END, 24, 212,
	FONT_BEGIN, 425, 456,
	FONT_NEXT, 425, -141,
	FONT_NEXT, 421, 460,
	FONT_NEXT, 337, -157,
	FONT_NEXT, 414, 457,
	FONT_NEXT, 341, -124,
	FONT_END, 360, 425,
	FONT_BEGIN, 252, -200,
	FONT_NEXT, 297, -194,
	FONT_NEXT, 252, -217,
	FONT_END, 425, -141,
	FONT_BEGIN, 425, -141,
	FONT_NEXT, 297, -194,
	FONT_END, 324, -180,
	FONT_BEGIN, 425, -141,
	FONT_NEXT, 324, -180,
	FONT_END, 337, -157,
	FONT_BEGIN, 488, -203,
	FONT_NEXT, 488, -217,
	FONT_NEXT, 459, -196,
	FONT_NEXT, 252, -217,
	FONT_NEXT, 439, -187,
	FONT_END, 428, -170,
	FONT_BEGIN, 428, -170,
	FONT_NEXT, 252, -217,
	FONT_END, 425, -141,
	FONT_BEGIN, 428, -170,
	FONT_END, 425, -141,
	FONT_ADVANCE, 500, 0
    },
    {
	114,
	FONT_BEGIN, 160, 458,
	FONT_NEXT, 160, 369,
	FONT_NEXT, 155, 460,
	FONT_NEXT, 160, 315,
	FONT_END, 160, 90,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 160, 90,
	FONT_END, 72, 51,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 72, 51,
	FONT_END, 76, 84,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 76, 84,
	FONT_END, 76, 334,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 76, 334,
	FONT_END, 72, 368,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 72, 368,
	FONT_END, 64, 386,
	FONT_BEGIN, 155, 460,
	FONT_NEXT, 64, 386,
	FONT_NEXT, 7, 406,
	FONT_NEXT, 41, 394,
	FONT_END, 7, 390,
	FONT_BEGIN, 335, 406,
	FONT_NEXT, 325, 374,
	FONT_NEXT, 331, 428,
	FONT_END, 320, 445,
	FONT_BEGIN, 320, 445,
	FONT_NEXT, 325, 374,
	FONT_END, 297, 362,
	FONT_BEGIN, 320, 445,
	FONT_NEXT, 297, 362,
	FONT_NEXT, 303, 456,
	FONT_END, 281, 460,
	FONT_BEGIN, 281, 460,
	FONT_NEXT, 297, 362,
	FONT_END, 274, 367,
	FONT_BEGIN, 281, 460,
	FONT_NEXT, 274, 367,
	FONT_NEXT, 252, 455,
	FONT_NEXT, 258, 379,
	FONT_END, 228, 397,
	FONT_BEGIN, 252, 455,
	FONT_NEXT, 228, 397,
	FONT_NEXT, 224, 441,
	FONT_NEXT, 207, 388,
	FONT_NEXT, 195, 413,
	FONT_NEXT, 185, 368,
	FONT_NEXT, 162, 369,
	FONT_NEXT, 167, 341,
	FONT_END, 160, 315,
	FONT_BEGIN, 162, 369,
	FONT_NEXT, 160, 315,
	FONT_END, 160, 369,
	FONT_BEGIN, 245, 15,
	FONT_NEXT, 245, 0,
	FONT_NEXT, 210, 17,
	FONT_NEXT, 5, 0,
	FONT_NEXT, 183, 27,
	FONT_END, 166, 49,
	FONT_BEGIN, 166, 49,
	FONT_NEXT, 5, 0,
	FONT_END, 61, 32,
	FONT_BEGIN, 166, 49,
	FONT_NEXT, 61, 32,
	FONT_NEXT, 160, 90,
	FONT_END, 72, 51,
	FONT_BEGIN, 5, 15,
	FONT_NEXT, 39, 22,
	FONT_NEXT, 5, 0,
	FONT_END, 61, 32,
	FONT_ADVANCE, 333, 0
    },
    {
	115,
	FONT_BEGIN, 51, 338,
	FONT_NEXT, 59, 380,
	FONT_NEXT, 60, 288,
	FONT_NEXT, 84, 420,
	FONT_NEXT, 86, 250,
	FONT_NEXT, 113, 372,
	FONT_END, 120, 337,
	FONT_BEGIN, 86, 250,
	FONT_NEXT, 120, 337,
	FONT_NEXT, 123, 219,
	FONT_NEXT, 133, 318,
	FONT_END, 156, 301,
	FONT_BEGIN, 123, 219,
	FONT_NEXT, 156, 301,
	FONT_NEXT, 168, 192,
	FONT_END, 226, 159,
	FONT_BEGIN, 226, 159,
	FONT_NEXT, 156, 301,
	FONT_NEXT, 264, 127,
	FONT_NEXT, 264, 237,
	FONT_NEXT, 278, 85,
	FONT_NEXT, 299, 21,
	FONT_NEXT, 270, 49,
	FONT_NEXT, 252, -3,
	FONT_NEXT, 250, 27,
	FONT_NEXT, 203, -10,
	FONT_NEXT, 224, 15,
	FONT_END, 197, 12,
	FONT_BEGIN, 197, 12,
	FONT_NEXT, 203, -10,
	FONT_END, 138, -1,
	FONT_BEGIN, 197, 12,
	FONT_NEXT, 138, -1,
	FONT_NEXT, 163, 15,
	FONT_END, 137, 26,
	FONT_BEGIN, 137, 26,
	FONT_NEXT, 138, -1,
	FONT_END, 87, 8,
	FONT_BEGIN, 137, 26,
	FONT_NEXT, 87, 8,
	FONT_NEXT, 100, 62,
	FONT_END, 79, 107,
	FONT_BEGIN, 79, 107,
	FONT_NEXT, 87, 8,
	FONT_END, 73, 5,
	FONT_BEGIN, 79, 107,
	FONT_NEXT, 73, 5,
	FONT_NEXT, 68, 152,
	FONT_NEXT, 65, -4,
	FONT_NEXT, 52, 152,
	FONT_END, 52, -4,
	FONT_BEGIN, 315, 314,
	FONT_NEXT, 300, 314,
	FONT_NEXT, 311, 451,
	FONT_END, 300, 451,
	FONT_BEGIN, 300, 451,
	FONT_NEXT, 300, 314,
	FONT_NEXT, 283, 440,
	FONT_NEXT, 279, 376,
	FONT_NEXT, 247, 450,
	FONT_NEXT, 252, 413,
	FONT_END, 221, 432,
	FONT_BEGIN, 247, 450,
	FONT_NEXT, 221, 432,
	FONT_NEXT, 191, 460,
	FONT_NEXT, 189, 437,
	FONT_NEXT, 128, 448,
	FONT_NEXT, 153, 430,
	FONT_END, 130, 414,
	FONT_BEGIN, 128, 448,
	FONT_NEXT, 130, 414,
	FONT_END, 117, 393,
	FONT_BEGIN, 128, 448,
	FONT_NEXT, 117, 393,
	FONT_NEXT, 84, 420,
	FONT_END, 113, 372,
	FONT_BEGIN, 348, 119,
	FONT_NEXT, 334, 62,
	FONT_NEXT, 341, 158,
	FONT_END, 324, 189,
	FONT_BEGIN, 324, 189,
	FONT_NEXT, 334, 62,
	FONT_END, 299, 21,
	FONT_BEGIN, 324, 189,
	FONT_NEXT, 299, 21,
	FONT_END, 264, 237,
	FONT_ADVANCE, 389, 0
    },
    {
	116,
	FONT_BEGIN, 13, 425,
	FONT_NEXT, 26, 441,
	FONT_NEXT, 17, 418,
	FONT_NEXT, 57, 465,
	FONT_NEXT, 70, 418,
	FONT_NEXT, 102, 516,
	FONT_END, 96, 16,
	FONT_BEGIN, 70, 418,
	FONT_NEXT, 96, 16,
	FONT_END, 77, 54,
	FONT_BEGIN, 70, 418,
	FONT_NEXT, 77, 54,
	FONT_END, 70, 117,
	FONT_BEGIN, 154, 566,
	FONT_NEXT, 154, 450,
	FONT_NEXT, 147, 579,
	FONT_NEXT, 154, 418,
	FONT_END, 154, 132,
	FONT_BEGIN, 147, 579,
	FONT_NEXT, 154, 132,
	FONT_END, 126, -5,
	FONT_BEGIN, 147, 579,
	FONT_NEXT, 126, -5,
	FONT_NEXT, 122, 544,
	FONT_NEXT, 96, 16,
	FONT_END, 102, 516,
	FONT_BEGIN, 255, 450,
	FONT_NEXT, 255, 418,
	FONT_NEXT, 154, 450,
	FONT_END, 154, 418,
	FONT_BEGIN, 279, 66,
	FONT_NEXT, 257, 35,
	FONT_NEXT, 266, 77,
	FONT_END, 243, 54,
	FONT_BEGIN, 243, 54,
	FONT_NEXT, 257, 35,
	FONT_END, 228, 11,
	FONT_BEGIN, 243, 54,
	FONT_NEXT, 228, 11,
	FONT_NEXT, 205, 42,
	FONT_NEXT, 196, -5,
	FONT_NEXT, 175, 51,
	FONT_NEXT, 162, -10,
	FONT_NEXT, 160, 75,
	FONT_NEXT, 126, -5,
	FONT_END, 154, 132,
	FONT_ADVANCE, 278, 0
    },
    {
	117,
	FONT_BEGIN, 9, 436,
	FONT_NEXT, 9, 450,
	FONT_NEXT, 51, 425,
	FONT_NEXT, 155, 450,
	FONT_NEXT, 65, 407,
	FONT_NEXT, 155, 124,
	FONT_END, 154, -5,
	FONT_BEGIN, 65, 407,
	FONT_NEXT, 154, -5,
	FONT_NEXT, 71, 372,
	FONT_NEXT, 115, 15,
	FONT_END, 83, 54,
	FONT_BEGIN, 71, 372,
	FONT_NEXT, 83, 54,
	FONT_END, 74, 83,
	FONT_BEGIN, 71, 372,
	FONT_NEXT, 74, 83,
	FONT_END, 71, 120,
	FONT_BEGIN, 338, -7,
	FONT_NEXT, 338, 76,
	FONT_NEXT, 340, -9,
	FONT_END, 333, 370,
	FONT_BEGIN, 333, 370,
	FONT_NEXT, 338, 76,
	FONT_NEXT, 333, 135,
	FONT_END, 328, 100,
	FONT_BEGIN, 328, 100,
	FONT_NEXT, 338, 76,
	FONT_END, 295, 33,
	FONT_BEGIN, 328, 100,
	FONT_NEXT, 295, 33,
	FONT_NEXT, 317, 84,
	FONT_END, 274, 57,
	FONT_BEGIN, 274, 57,
	FONT_NEXT, 295, 33,
	FONT_END, 264, 9,
	FONT_BEGIN, 274, 57,
	FONT_NEXT, 264, 9,
	FONT_NEXT, 230, 48,
	FONT_NEXT, 234, -4,
	FONT_END, 208, -9,
	FONT_BEGIN, 230, 48,
	FONT_NEXT, 208, -9,
	FONT_NEXT, 190, 57,
	FONT_NEXT, 190, -10,
	FONT_NEXT, 167, 80,
	FONT_NEXT, 154, -5,
	FONT_NEXT, 157, 106,
	FONT_END, 155, 124,
	FONT_BEGIN, 479, 50,
	FONT_NEXT, 479, 36,
	FONT_NEXT, 444, 53,
	FONT_NEXT, 340, -9,
	FONT_NEXT, 425, 64,
	FONT_END, 418, 82,
	FONT_BEGIN, 418, 82,
	FONT_NEXT, 340, -9,
	FONT_NEXT, 417, 107,
	FONT_NEXT, 333, 370,
	FONT_END, 331, 396,
	FONT_BEGIN, 417, 107,
	FONT_NEXT, 331, 396,
	FONT_NEXT, 417, 450,
	FONT_NEXT, 322, 415,
	FONT_NEXT, 259, 450,
	FONT_NEXT, 300, 427,
	FONT_END, 259, 433,
	FONT_ADVANCE, 500, 0
    },
    {
	118,
	FONT_BEGIN, 215, 450,
	FONT_NEXT, 215, 435,
	FONT_NEXT, 19, 450,
	FONT_NEXT, 183, 428,
	FONT_END, 172, 419,
	FONT_BEGIN, 19, 450,
	FONT_NEXT, 172, 419,
	FONT_END, 169, 405,
	FONT_BEGIN, 19, 450,
	FONT_NEXT, 169, 405,
	FONT_END, 48, 427,
	FONT_BEGIN, 19, 450,
	FONT_NEXT, 48, 427,
	FONT_END, 19, 435,
	FONT_BEGIN, 338, 435,
	FONT_NEXT, 338, 450,
	FONT_NEXT, 370, 426,
	FONT_NEXT, 427, 393,
	FONT_NEXT, 385, 402,
	FONT_NEXT, 412, 357,
	FONT_NEXT, 381, 383,
	FONT_NEXT, 284, 36,
	FONT_NEXT, 373, 355,
	FONT_END, 345, 280,
	FONT_BEGIN, 345, 280,
	FONT_NEXT, 284, 36,
	FONT_NEXT, 280, 114,
	FONT_NEXT, 269, 0,
	FONT_NEXT, 178, 370,
	FONT_NEXT, 257, -14,
	FONT_END, 246, -7,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 246, -7,
	FONT_END, 239, 7,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 239, 7,
	FONT_END, 230, 33,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 230, 33,
	FONT_END, 217, 63,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 217, 63,
	FONT_END, 200, 106,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 200, 106,
	FONT_END, 156, 212,
	FONT_BEGIN, 178, 370,
	FONT_NEXT, 156, 212,
	FONT_NEXT, 169, 405,
	FONT_NEXT, 110, 319,
	FONT_END, 90, 364,
	FONT_BEGIN, 169, 405,
	FONT_NEXT, 90, 364,
	FONT_END, 74, 398,
	FONT_BEGIN, 169, 405,
	FONT_NEXT, 74, 398,
	FONT_END, 48, 427,
	FONT_BEGIN, 477, 450,
	FONT_NEXT, 477, 435,
	FONT_NEXT, 338, 450,
	FONT_NEXT, 455, 429,
	FONT_END, 440, 417,
	FONT_BEGIN, 338, 450,
	FONT_NEXT, 440, 417,
	FONT_END, 427, 393,
	FONT_ADVANCE, 500, 0
    },
    {
	119,
	FONT_BEGIN, 201, 450,
	FONT_NEXT, 201, 435,
	FONT_NEXT, 21, 450,
	FONT_NEXT, 169, 427,
	FONT_END, 158, 417,
	FONT_BEGIN, 21, 450,
	FONT_NEXT, 158, 417,
	FONT_END, 155, 401,
	FONT_BEGIN, 21, 450,
	FONT_NEXT, 155, 401,
	FONT_END, 49, 420,
	FONT_BEGIN, 21, 450,
	FONT_NEXT, 49, 420,
	FONT_END, 21, 435,
	FONT_BEGIN, 262, 435,
	FONT_NEXT, 262, 450,
	FONT_NEXT, 288, 429,
	FONT_END, 308, 413,
	FONT_BEGIN, 308, 413,
	FONT_NEXT, 262, 450,
	FONT_END, 407, 398,
	FONT_BEGIN, 308, 413,
	FONT_NEXT, 407, 398,
	FONT_NEXT, 327, 376,
	FONT_NEXT, 372, 265,
	FONT_NEXT, 338, 347,
	FONT_END, 351, 310,
	FONT_BEGIN, 351, 310,
	FONT_NEXT, 372, 265,
	FONT_END, 260, 25,
	FONT_BEGIN, 351, 310,
	FONT_NEXT, 260, 25,
	FONT_NEXT, 260, 111,
	FONT_END, 224, 205,
	FONT_BEGIN, 224, 205,
	FONT_NEXT, 260, 25,
	FONT_END, 244, -5,
	FONT_BEGIN, 224, 205,
	FONT_NEXT, 244, -5,
	FONT_END, 235, -14,
	FONT_BEGIN, 224, 205,
	FONT_NEXT, 235, -14,
	FONT_END, 224, -5,
	FONT_BEGIN, 224, 205,
	FONT_NEXT, 224, -5,
	FONT_NEXT, 190, 290,
	FONT_NEXT, 217, 8,
	FONT_END, 209, 30,
	FONT_BEGIN, 190, 290,
	FONT_NEXT, 209, 30,
	FONT_END, 74, 372,
	FONT_BEGIN, 190, 290,
	FONT_NEXT, 74, 372,
	FONT_NEXT, 164, 358,
	FONT_END, 157, 383,
	FONT_BEGIN, 157, 383,
	FONT_NEXT, 74, 372,
	FONT_NEXT, 155, 401,
	FONT_NEXT, 60, 401,
	FONT_END, 49, 420,
	FONT_BEGIN, 465, 450,
	FONT_NEXT, 465, 435,
	FONT_NEXT, 262, 450,
	FONT_NEXT, 423, 425,
	FONT_END, 411, 415,
	FONT_BEGIN, 262, 450,
	FONT_NEXT, 411, 415,
	FONT_END, 407, 398,
	FONT_BEGIN, 571, 435,
	FONT_NEXT, 571, 450,
	FONT_NEXT, 602, 425,
	FONT_NEXT, 671, 419,
	FONT_END, 653, 381,
	FONT_BEGIN, 602, 425,
	FONT_NEXT, 653, 381,
	FONT_NEXT, 611, 416,
	FONT_END, 615, 402,
	FONT_BEGIN, 615, 402,
	FONT_NEXT, 653, 381,
	FONT_NEXT, 610, 374,
	FONT_NEXT, 515, 35,
	FONT_NEXT, 598, 338,
	FONT_END, 508, 116,
	FONT_BEGIN, 508, 116,
	FONT_NEXT, 515, 35,
	FONT_END, 505, 10,
	FONT_BEGIN, 508, 116,
	FONT_NEXT, 505, 10,
	FONT_NEXT, 428, 330,
	FONT_NEXT, 498, -5,
	FONT_END, 487, -14,
	FONT_BEGIN, 428, 330,
	FONT_NEXT, 487, -14,
	FONT_END, 477, -6,
	FONT_BEGIN, 428, 330,
	FONT_NEXT, 477, -6,
	FONT_END, 471, 7,
	FONT_BEGIN, 428, 330,
	FONT_NEXT, 471, 7,
	FONT_END, 463, 29,
	FONT_BEGIN, 428, 330,
	FONT_NEXT, 463, 29,
	FONT_END, 372, 265,
	FONT_BEGIN, 428, 330,
	FONT_NEXT, 372, 265,
	FONT_NEXT, 411, 371,
	FONT_END, 407, 398,
	FONT_BEGIN, 694, 450,
	FONT_NEXT, 694, 435,
	FONT_NEXT, 571, 450,
	FONT_END, 671, 419,
	FONT_ADVANCE, 722, 0
    },
    {
	120,
	FONT_BEGIN, 24, 435,
	FONT_NEXT, 24, 450,
	FONT_NEXT, 64, 428,
	FONT_NEXT, 188, 412,
	FONT_NEXT, 83, 410,
	FONT_END, 110, 375,
	FONT_BEGIN, 110, 375,
	FONT_NEXT, 188, 412,
	FONT_END, 194, 391,
	FONT_BEGIN, 110, 375,
	FONT_NEXT, 194, 391,
	FONT_NEXT, 204, 231,
	FONT_NEXT, 210, 362,
	FONT_END, 221, 197,
	FONT_BEGIN, 204, 231,
	FONT_NEXT, 221, 197,
	FONT_END, 142, 74,
	FONT_BEGIN, 204, 231,
	FONT_NEXT, 142, 74,
	FONT_NEXT, 90, 66,
	FONT_NEXT, 122, 33,
	FONT_NEXT, 68, 39,
	FONT_END, 51, 24,
	FONT_BEGIN, 51, 24,
	FONT_NEXT, 122, 33,
	FONT_END, 17, 0,
	FONT_BEGIN, 51, 24,
	FONT_NEXT, 17, 0,
	FONT_END, 17, 15,
	FONT_BEGIN, 231, 450,
	FONT_NEXT, 231, 435,
	FONT_NEXT, 24, 450,
	FONT_NEXT, 202, 431,
	FONT_END, 192, 424,
	FONT_BEGIN, 24, 450,
	FONT_NEXT, 192, 424,
	FONT_END, 188, 412,
	FONT_BEGIN, 275, 435,
	FONT_NEXT, 275, 450,
	FONT_NEXT, 301, 431,
	FONT_END, 311, 424,
	FONT_BEGIN, 311, 424,
	FONT_NEXT, 275, 450,
	FONT_END, 379, 417,
	FONT_BEGIN, 311, 424,
	FONT_NEXT, 379, 417,
	FONT_END, 352, 391,
	FONT_BEGIN, 311, 424,
	FONT_NEXT, 352, 391,
	FONT_NEXT, 315, 412,
	FONT_END, 313, 402,
	FONT_BEGIN, 313, 402,
	FONT_NEXT, 352, 391,
	FONT_END, 269, 271,
	FONT_BEGIN, 313, 402,
	FONT_NEXT, 269, 271,
	FONT_NEXT, 304, 386,
	FONT_END, 284, 356,
	FONT_BEGIN, 284, 356,
	FONT_NEXT, 269, 271,
	FONT_NEXT, 248, 304,
	FONT_NEXT, 221, 197,
	FONT_END, 210, 362,
	FONT_BEGIN, 433, 450,
	FONT_NEXT, 433, 435,
	FONT_NEXT, 275, 450,
	FONT_NEXT, 403, 429,
	FONT_END, 379, 417,
	FONT_BEGIN, 278, 15,
	FONT_NEXT, 309, 20,
	FONT_NEXT, 278, 0,
	FONT_END, 397, 75,
	FONT_BEGIN, 397, 75,
	FONT_NEXT, 309, 20,
	FONT_END, 318, 41,
	FONT_BEGIN, 397, 75,
	FONT_NEXT, 318, 41,
	FONT_NEXT, 269, 271,
	FONT_NEXT, 311, 60,
	FONT_END, 302, 73,
	FONT_BEGIN, 269, 271,
	FONT_NEXT, 302, 73,
	FONT_END, 221, 197,
	FONT_BEGIN, 479, 15,
	FONT_NEXT, 479, 0,
	FONT_NEXT, 445, 23,
	FONT_NEXT, 278, 0,
	FONT_NEXT, 423, 41,
	FONT_END, 397, 75,
	FONT_BEGIN, 162, 15,
	FONT_NEXT, 162, 0,
	FONT_NEXT, 136, 17,
	FONT_NEXT, 17, 0,
	FONT_END, 122, 33,
	FONT_ADVANCE, 500, 0
    },
    {
	121,
	FONT_BEGIN, 220, 450,
	FONT_NEXT, 220, 435,
	FONT_NEXT, 14, 450,
	FONT_NEXT, 182, 430,
	FONT_END, 167, 421,
	FONT_BEGIN, 14, 450,
	FONT_NEXT, 167, 421,
	FONT_END, 162, 406,
	FONT_BEGIN, 14, 450,
	FONT_NEXT, 162, 406,
	FONT_END, 39, 428,
	FONT_BEGIN, 14, 450,
	FONT_NEXT, 39, 428,
	FONT_END, 14, 436,
	FONT_BEGIN, 340, 435,
	FONT_NEXT, 340, 450,
	FONT_NEXT, 376, 428,
	FONT_NEXT, 439, 414,
	FONT_END, 427, 390,
	FONT_BEGIN, 376, 428,
	FONT_NEXT, 427, 390,
	FONT_NEXT, 388, 407,
	FONT_NEXT, 273, -18,
	FONT_NEXT, 380, 379,
	FONT_END, 365, 339,
	FONT_BEGIN, 365, 339,
	FONT_NEXT, 273, -18,
	FONT_NEXT, 287, 117,
	FONT_END, 172, 370,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 273, -18,
	FONT_END, 241, 20,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 241, 20,
	FONT_END, 233, 43,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 233, 43,
	FONT_END, 215, 83,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 215, 83,
	FONT_END, 194, 125,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 194, 125,
	FONT_END, 179, 158,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 179, 158,
	FONT_END, 65, 404,
	FONT_BEGIN, 172, 370,
	FONT_NEXT, 65, 404,
	FONT_NEXT, 162, 406,
	FONT_END, 39, 428,
	FONT_BEGIN, 475, 450,
	FONT_NEXT, 475, 435,
	FONT_NEXT, 340, 450,
	FONT_NEXT, 451, 427,
	FONT_END, 439, 414,
	FONT_BEGIN, 30, -160,
	FONT_NEXT, 36, -136,
	FONT_NEXT, 34, -181,
	FONT_END, 47, -199,
	FONT_BEGIN, 47, -199,
	FONT_NEXT, 36, -136,
	FONT_END, 51, -123,
	FONT_BEGIN, 47, -199,
	FONT_NEXT, 51, -123,
	FONT_NEXT, 70, -213,
	FONT_NEXT, 78, -116,
	FONT_NEXT, 103, -218,
	FONT_NEXT, 118, -125,
	FONT_END, 149, -134,
	FONT_BEGIN, 103, -218,
	FONT_NEXT, 149, -134,
	FONT_NEXT, 154, -206,
	FONT_NEXT, 167, -129,
	FONT_END, 185, -113,
	FONT_BEGIN, 154, -206,
	FONT_NEXT, 185, -113,
	FONT_NEXT, 197, -169,
	FONT_NEXT, 214, -63,
	FONT_END, 233, -11,
	FONT_BEGIN, 197, -169,
	FONT_NEXT, 233, -11,
	FONT_NEXT, 235, -106,
	FONT_NEXT, 239, 8,
	FONT_END, 241, 20,
	FONT_BEGIN, 235, -106,
	FONT_NEXT, 241, 20,
	FONT_END, 273, -18,
	FONT_ADVANCE, 500, 0
    },
    {
	122,
	FONT_BEGIN, 403, 450,
	FONT_NEXT, 403, 435,
	FONT_NEXT, 56, 450,
	FONT_NEXT, 293, 420,
	FONT_END, 155, 420,
	FONT_BEGIN, 56, 450,
	FONT_NEXT, 155, 420,
	FONT_END, 112, 413,
	FONT_BEGIN, 56, 450,
	FONT_NEXT, 112, 413,
	FONT_END, 88, 396,
	FONT_BEGIN, 56, 450,
	FONT_NEXT, 88, 396,
	FONT_END, 76, 368,
	FONT_BEGIN, 56, 450,
	FONT_NEXT, 76, 368,
	FONT_END, 71, 332,
	FONT_BEGIN, 56, 450,
	FONT_NEXT, 71, 332,
	FONT_END, 53, 332,
	FONT_BEGIN, 418, 135,
	FONT_NEXT, 404, 0,
	FONT_NEXT, 400, 139,
	FONT_END, 388, 89,
	FONT_BEGIN, 388, 89,
	FONT_NEXT, 404, 0,
	FONT_NEXT, 369, 55,
	FONT_END, 334, 36,
	FONT_BEGIN, 334, 36,
	FONT_NEXT, 404, 0,
	FONT_NEXT, 307, 31,
	FONT_NEXT, 27, 0,
	FONT_NEXT, 272, 30,
	FONT_END, 134, 30,
	FONT_BEGIN, 134, 30,
	FONT_NEXT, 27, 0,
	FONT_END, 27, 15,
	FONT_BEGIN, 134, 30,
	FONT_NEXT, 27, 15,
	FONT_END, 293, 420,
	FONT_BEGIN, 134, 30,
	FONT_NEXT, 293, 420,
	FONT_END, 403, 435,
	FONT_ADVANCE, 444, 0
    },
    {
	123,
	FONT_BEGIN, 100, 250,
	FONT_NEXT, 142, 266,
	FONT_NEXT, 142, 233,
	FONT_END, 168, 209,
	FONT_BEGIN, 168, 209,
	FONT_NEXT, 142, 266,
	FONT_END, 168, 248,
	FONT_BEGIN, 168, 209,
	FONT_NEXT, 168, 248,
	FONT_NEXT, 181, 178,
	FONT_NEXT, 215, 230,
	FONT_NEXT, 185, 136,
	FONT_NEXT, 210, -139,
	FONT_END, 196, -114,
	FONT_BEGIN, 185, 136,
	FONT_NEXT, 196, -114,
	FONT_END, 187, -82,
	FONT_BEGIN, 185, 136,
	FONT_NEXT, 187, -82,
	FONT_END, 185, -41,
	FONT_BEGIN, 185, 541,
	FONT_NEXT, 187, 581,
	FONT_NEXT, 185, 363,
	FONT_NEXT, 196, 612,
	FONT_END, 210, 637,
	FONT_BEGIN, 185, 363,
	FONT_NEXT, 210, 637,
	FONT_END, 215, 267,
	FONT_BEGIN, 185, 363,
	FONT_NEXT, 215, 267,
	FONT_NEXT, 181, 320,
	FONT_NEXT, 168, 250,
	FONT_NEXT, 168, 289,
	FONT_END, 142, 266,
	FONT_BEGIN, 142, 266,
	FONT_NEXT, 168, 250,
	FONT_END, 168, 248,
	FONT_BEGIN, 142, 266,
	FONT_END, 168, 248,
	FONT_BEGIN, 350, 680,
	FONT_NEXT, 350, 669,
	FONT_NEXT, 280, 675,
	FONT_NEXT, 305, 652,
	FONT_END, 277, 627,
	FONT_BEGIN, 280, 675,
	FONT_NEXT, 277, 627,
	FONT_NEXT, 228, 655,
	FONT_NEXT, 263, 592,
	FONT_END, 259, 546,
	FONT_BEGIN, 228, 655,
	FONT_NEXT, 259, 546,
	FONT_END, 259, 378,
	FONT_BEGIN, 228, 655,
	FONT_NEXT, 259, 378,
	FONT_END, 255, 330,
	FONT_BEGIN, 228, 655,
	FONT_NEXT, 255, 330,
	FONT_END, 242, 294,
	FONT_BEGIN, 228, 655,
	FONT_NEXT, 242, 294,
	FONT_END, 215, 267,
	FONT_BEGIN, 228, 655,
	FONT_NEXT, 215, 267,
	FONT_END, 210, 637,
	FONT_BEGIN, 259, 121,
	FONT_NEXT, 259, -47,
	FONT_NEXT, 255, 168,
	FONT_NEXT, 228, -156,
	FONT_NEXT, 242, 204,
	FONT_END, 215, 230,
	FONT_BEGIN, 215, 230,
	FONT_NEXT, 228, -156,
	FONT_END, 210, -139,
	FONT_BEGIN, 215, 230,
	FONT_END, 210, -139,
	FONT_BEGIN, 350, -170,
	FONT_NEXT, 350, -181,
	FONT_NEXT, 305, -154,
	FONT_NEXT, 280, -176,
	FONT_NEXT, 277, -129,
	FONT_NEXT, 228, -156,
	FONT_NEXT, 263, -94,
	FONT_END, 259, -47,
	FONT_ADVANCE, 480, 0
    },
    {
	124,
	FONT_BEGIN, 133, 676,
	FONT_NEXT, 133, -14,
	FONT_NEXT, 67, 676,
	FONT_END, 67, -14,
	FONT_ADVANCE, 200, 0
    },
    {
	125,
	FONT_BEGIN, 130, 669,
	FONT_NEXT, 130, 680,
	FONT_NEXT, 174, 652,
	FONT_NEXT, 199, 675,
	FONT_NEXT, 202, 627,
	FONT_END, 216, 592,
	FONT_BEGIN, 216, 592,
	FONT_NEXT, 199, 675,
	FONT_END, 251, 655,
	FONT_BEGIN, 216, 592,
	FONT_NEXT, 251, 655,
	FONT_NEXT, 221, 546,
	FONT_NEXT, 237, 294,
	FONT_END, 224, 330,
	FONT_BEGIN, 221, 546,
	FONT_NEXT, 224, 330,
	FONT_END, 221, 378,
	FONT_BEGIN, 295, 540,
	FONT_NEXT, 295, 363,
	FONT_NEXT, 292, 580,
	FONT_NEXT, 264, 268,
	FONT_NEXT, 283, 612,
	FONT_END, 269, 637,
	FONT_BEGIN, 269, 637,
	FONT_NEXT, 264, 268,
	FONT_NEXT, 251, 655,
	FONT_END, 237, 294,
	FONT_BEGIN, 380, 250,
	FONT_NEXT, 337, 233,
	FONT_NEXT, 337, 266,
	FONT_END, 311, 289,
	FONT_BEGIN, 311, 289,
	FONT_NEXT, 337, 233,
	FONT_END, 312, 251,
	FONT_BEGIN, 311, 289,
	FONT_NEXT, 312, 251,
	FONT_END, 264, 268,
	FONT_BEGIN, 311, 289,
	FONT_NEXT, 264, 268,
	FONT_NEXT, 298, 320,
	FONT_END, 295, 363,
	FONT_BEGIN, 221, 121,
	FONT_NEXT, 224, 168,
	FONT_NEXT, 221, -47,
	FONT_NEXT, 237, 204,
	FONT_NEXT, 251, -157,
	FONT_NEXT, 264, 231,
	FONT_NEXT, 269, -139,
	FONT_END, 283, -114,
	FONT_BEGIN, 283, -114,
	FONT_NEXT, 264, 231,
	FONT_NEXT, 292, -83,
	FONT_END, 295, -42,
	FONT_BEGIN, 295, -42,
	FONT_NEXT, 264, 231,
	FONT_NEXT, 295, 136,
	FONT_END, 298, 178,
	FONT_BEGIN, 298, 178,
	FONT_NEXT, 264, 231,
	FONT_NEXT, 311, 209,
	FONT_NEXT, 312, 249,
	FONT_NEXT, 337, 233,
	FONT_END, 312, 251,
	FONT_BEGIN, 130, -170,
	FONT_NEXT, 174, -154,
	FONT_NEXT, 130, -181,
	FONT_END, 199, -177,
	FONT_BEGIN, 199, -177,
	FONT_NEXT, 174, -154,
	FONT_END, 202, -129,
	FONT_BEGIN, 199, -177,
	FONT_NEXT, 202, -129,
	FONT_END, 216, -94,
	FONT_BEGIN, 199, -177,
	FONT_NEXT, 216, -94,
	FONT_NEXT, 251, -157,
	FONT_END, 221, -47,
	FONT_ADVANCE, 480, 0
    },
    {
	126,
	FONT_BEGIN, 502, 273,
	FONT_NEXT, 451, 214,
	FONT_NEXT, 466, 323,
	FONT_END, 428, 273,
	FONT_BEGIN, 428, 273,
	FONT_NEXT, 451, 214,
	FONT_END, 418, 194,
	FONT_BEGIN, 428, 273,
	FONT_NEXT, 418, 194,
	FONT_NEXT, 405, 257,
	FONT_NEXT, 377, 187,
	FONT_NEXT, 378, 251,
	FONT_END, 330, 263,
	FONT_BEGIN, 330, 263,
	FONT_NEXT, 377, 187,
	FONT_END, 324, 196,
	FONT_BEGIN, 330, 263,
	FONT_NEXT, 324, 196,
	FONT_NEXT, 276, 287,
	FONT_NEXT, 275, 220,
	FONT_NEXT, 219, 309,
	FONT_NEXT, 222, 244,
	FONT_END, 160, 255,
	FONT_BEGIN, 219, 309,
	FONT_NEXT, 160, 255,
	FONT_NEXT, 165, 319,
	FONT_END, 120, 311,
	FONT_BEGIN, 120, 311,
	FONT_NEXT, 160, 255,
	FONT_END, 130, 248,
	FONT_BEGIN, 120, 311,
	FONT_NEXT, 130, 248,
	FONT_END, 107, 232,
	FONT_BEGIN, 120, 311,
	FONT_NEXT, 107, 232,
	FONT_NEXT, 85, 291,
	FONT_NEXT, 76, 183,
	FONT_END, 40, 233,
	FONT_ADVANCE, 541, 0
    },
    {
	END_OF_LIST
    }
};

// Character 0 may not be defined for the bitmap font because it is used as
// BITMAP_END_OF_LIST.  We could use END_OF_LIST (which is 256), but that
// gets truncated to zero anyway, so lets be clean and use BITMAP_END_OF_LIST.

GLubyte bitmapFont[][1+13] = {
    {
	32,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	33,
	0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18
    }, 
    {
	34,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x36, 0x36, 0x36, 0x36
    }, 
    {
	35,
	0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66,
	0x66, 0xff, 0x66, 0x66, 0x00, 0x00
    }, 
    {
	36,
	0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f,
	0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18
    }, 
    {
	37,
	0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30,
	0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70
    }, 
    {
	38,
	0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70,
	0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38
    }, 
    {
	39,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e
    }, 
    {
	40,
	0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x30, 0x18, 0x0c
    }, 
    {
	41,
	0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c,
	0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30
    }, 
    {
	42,
	0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c,
	0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00
    }, 
    {
	43,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff,
	0xff, 0x18, 0x18, 0x18, 0x00, 0x00
    }, 
    {
	44,
	0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	45,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	46,
	0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	47,
	0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18,
	0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03
    }, 
    {
	48,
	0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3,
	0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c
    }, 
    {
	49,
	0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x78, 0x38, 0x18
    }, 
    {
	50,
	0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30,
	0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e
    }, 
    {
	51,
	0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07,
	0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e
    }, 
    {
	52,
	0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c
    }, 
    {
	53,
	0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07,
	0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff
    }, 
    {
	54,
	0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7,
	0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e
    }, 
    {
	55,
	0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18,
	0x0c, 0x06, 0x03, 0x03, 0x03, 0xff
    }, 
    {
	56,
	0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7,
	0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e
    }, 
    {
	57,
	0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03,
	0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e
    }, 
    {
	58,
	0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00,
	0x38, 0x38, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	59,
	0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00,
	0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00
    }, 
    {
	60,
	0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60,
	0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06
    }, 
    {
	61,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	62,
	0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06,
	0x03, 0x06, 0x0c, 0x18, 0x30, 0x60
    }, 
    {
	63,
	0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18,
	0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e
    }, 
    {
	64,
	0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3,
	0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00
    }, 
    {
	65,
	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff,
	0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18
    }, 
    {
	66,
	0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7,
	0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe
    }, 
    {
	67,
	0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0,
	0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e
    }, 
    {
	68,
	0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3,
	0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc
    }, 
    {
	69,
	0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0,
	0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff
    }, 
    {
	70,
	0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
	0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff
    }, 
    {
	71,
	0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf,
	0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e
    }, 
    {
	72,
	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
	0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3
    }, 
    {
	73,
	0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x7e
    }, 
    {
	74,
	0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06
    }, 
    {
	75,
	0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0,
	0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3
    }, 
    {
	76,
	0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0,
	0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0
    }, 
    {
	77,
	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
	0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3
    }, 
    {
	78,
	0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf,
	0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3
    }, 
    {
	79,
	0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3,
	0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e
    }, 
    {
	80,
	0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
	0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe
    }, 
    {
	81,
	0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3,
	0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c
    }, 
    {
	82,
	0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0,
	0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe
    }, 
    {
	83,
	0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07,
	0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e
    }, 
    {
	84,
	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xff
    }, 
    {
	85,
	0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3,
	0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3
    }, 
    {
	86,
	0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66,
	0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3
    }, 
    {
	87,
	0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb,
	0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3
    }, 
    {
	88,
	0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c,
	0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3
    }, 
    {
	89,
	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3
    }, 
    {
	90,
	0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30,
	0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff
    }, 
    {
	91,
	0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x30, 0x30, 0x3c
    }, 
    {
	92,
	0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c,
	0x18, 0x18, 0x30, 0x30, 0x60, 0x60
    }, 
    {
	93,
	0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c,
	0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c
    }, 
    {
	94,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18
    }, 
    {
	95,
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	96,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x38, 0x30, 0x70
    }, 
    {
	97,
	0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03,
	0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	98,
	0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3,
	0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0
    }, 
    {
	99,
	0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0,
	0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	100,
	0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3,
	0x7f, 0x03, 0x03, 0x03, 0x03, 0x03
    }, 
    {
	101,
	0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3,
	0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	102,
	0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
	0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e
    }, 
    {
	103,
	0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3,
	0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	104,
	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
	0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0
    }, 
    {
	105,
	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x00, 0x00, 0x18, 0x00
    }, 
    {
	106,
	0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00
    }, 
    {
	107,
	0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8,
	0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0
    }, 
    {
	108,
	0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x78
    }, 
    {
	109,
	0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb,
	0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	110,
	0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6,
	0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	111,
	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6,
	0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	112,
	0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3,
	0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	113,
	0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3,
	0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	114,
	0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
	0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	115,
	0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0,
	0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	116,
	0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30,
	0x30, 0xfc, 0x30, 0x30, 0x30, 0x00
    }, 
    {
	117,
	0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6,
	0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	118,
	0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66,
	0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	119,
	0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3,
	0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	120,
	0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c,
	0x66, 0xc3, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	121,
	0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66,
	0x66, 0xc3, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	122,
	0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c,
	0x06, 0xff, 0x00, 0x00, 0x00, 0x00
    }, 
    {
	123,
	0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38,
	0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f
    }, 
    {
	124,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18
    }, 
    {
	125,
	0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c,
	0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0
    }, 
    {
	126,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
	0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00
    },
    {
        BITMAP_END_OF_LIST
    }
};


GLenum tkCreateStrokeFont(GLuint fontBase)
{
    GLint mode, i, j;

    for (i = 0; strokeFont[i][0] != END_OF_LIST; i++) {
	glNewList(fontBase+(unsigned int)strokeFont[i][0], GL_COMPILE);
	for (j = 1; mode = strokeFont[i][j]; j += 3) {
	    if (mode == FONT_BEGIN) {
		glBegin(GL_LINE_STRIP);
		glVertex2f((float)strokeFont[i][j+1]*STROKE_SCALE,
			   (float)strokeFont[i][j+2]*STROKE_SCALE);
	    } else if (mode == FONT_NEXT) {
		glVertex2f((float)strokeFont[i][j+1]*STROKE_SCALE,
			   (float)strokeFont[i][j+2]*STROKE_SCALE);
	    } else if (mode == FONT_END) {
		glVertex2f((float)strokeFont[i][j+1]*STROKE_SCALE,
			   (float)strokeFont[i][j+2]*STROKE_SCALE);
		glEnd();
	    } else if (mode == FONT_ADVANCE) {
		glTranslatef((float)strokeFont[i][j+1]*STROKE_SCALE,
			     (float)strokeFont[i][j+2]*STROKE_SCALE, (GLfloat) 0.0);
		break;
	    }
	}
	glEndList();
    }
    return GL_TRUE;
}

GLenum tkCreateOutlineFont(GLuint fontBase)
{
    GLint mode, i, j;

    for (i = 0; outlineFont[i][0] != END_OF_LIST; i++) {
	glNewList(fontBase+(unsigned int)outlineFont[i][0], GL_COMPILE);
	for (j = 1; mode = outlineFont[i][j]; j += 3) {
	    if (mode == FONT_BEGIN) {
		glBegin(GL_LINE_STRIP);
		glVertex2f((float)outlineFont[i][j+1]*OUTLINE_SCALE,
			   (float)outlineFont[i][j+2]*OUTLINE_SCALE);
	    } else if (mode == FONT_NEXT) {
		glVertex2f((float)outlineFont[i][j+1]*OUTLINE_SCALE,
			   (float)outlineFont[i][j+2]*OUTLINE_SCALE);
	    } else if (mode == FONT_END) {
		glVertex2f((float)outlineFont[i][j+1]*OUTLINE_SCALE,
			   (float)outlineFont[i][j+2]*OUTLINE_SCALE);
		glEnd();
	    } else if (mode == FONT_ADVANCE) {
		glTranslatef((float)outlineFont[i][j+1]*OUTLINE_SCALE,
			     (float)outlineFont[i][j+2]*OUTLINE_SCALE, (GLfloat) 0.0);
		break;
	    }
	}
	glEndList();
    }
    return GL_TRUE;
}

GLenum tkCreateFilledFont(GLuint fontBase)
{
    GLint mode, i, j;

    for (i = 0; filledFont[i][0] != END_OF_LIST; i++) {
	glNewList(fontBase+(unsigned int)filledFont[i][0], GL_COMPILE);
	for (j = 1; mode = filledFont[i][j]; j += 3) {
	    if (mode == FONT_BEGIN) {
		glBegin(GL_TRIANGLE_STRIP);
		glVertex2f((float)filledFont[i][j+1]*FILLED_SCALE,
			   (float)filledFont[i][j+2]*FILLED_SCALE);
	    } else if (mode == FONT_NEXT) {
		glVertex2f((float)filledFont[i][j+1]*FILLED_SCALE,
			   (float)filledFont[i][j+2]*FILLED_SCALE);
	    } else if (mode == FONT_END) {
		glVertex2f((float)filledFont[i][j+1]*FILLED_SCALE,
			   (float)filledFont[i][j+2]*FILLED_SCALE);
		glEnd();
	    } else if (mode == FONT_ADVANCE) {
		glTranslatef((float)filledFont[i][j+1]*FILLED_SCALE,
			     (float)filledFont[i][j+2]*FILLED_SCALE, (GLfloat) 0.0);
		break;
	    }
	}
	glEndList();
    }
    return GL_TRUE;
}

GLenum tkCreateBitmapFont(GLuint fontBase)
{
    GLint i;

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    for (i = 0; bitmapFont[i][0] != BITMAP_END_OF_LIST; i++) {
	glNewList(fontBase+(unsigned int)bitmapFont[i][0], GL_COMPILE);
	glBitmap(8, 13, (GLfloat) 0.0, (GLfloat) 2.0, (GLfloat) 10.0, (GLfloat) 0.0, &bitmapFont[i][1]);
	glEndList();
    }
    return GL_TRUE;
}

void tkDrawStr(GLuint base, char *str)
{

    glPushAttrib(GL_LIST_BIT);
    glListBase(base);
    glCallLists(strlen(str), GL_UNSIGNED_BYTE, (unsigned char *)str);
    glPopAttrib();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\fastdib.c ===
/******************************Module*Header*******************************\
* Module Name: fastdib.c
*
* CreateCompatibleDIB implementation.
*
* Created: 23-Jan-1996 21:08:18
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

#include "mtk.h"

BOOL APIENTRY GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector);
static BOOL bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static BOOL bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static UINT MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                                      LPPALETTEENTRY lppe);
static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal,
                                        BYTE *pajVector);

/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB section with an optimal format w.r.t. the specified hdc.
*
* If DIB <= 8bpp, then the DIB color table is initialized based on the
* specified palette.  If the palette handle is NULL, then the system
* palette is used.
*
* Note: The hdc must be a direct DC (not an info or memory DC).
*
* Note: On palettized displays, if the system palette changes the
*       UpdateDIBColorTable function should be called to maintain
*       the identity palette mapping between the DIB and the display.
*
* Returns:
*   Valid bitmap handle if successful, NULL if error.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//HBITMAP APIENTRY
HBITMAP
SSDIB_CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight,
                    PVOID *ppvBits)
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        SS_DBGPRINT("CreateCompatibleDIB: not OBJ_DC\n");
        return hbmRet;
    }

    memset(aj, 0, sizeof(aj));
    if ( bFillBitmapInfo(hdc, hpal, pbmi) )
    {
        //
        // Change bitmap size to match specified dimensions.
        //

        pbmi->bmiHeader.biWidth = ulWidth;
        pbmi->bmiHeader.biHeight = ulHeight;
        if (pbmi->bmiHeader.biCompression == BI_RGB)
        {
            pbmi->bmiHeader.biSizeImage = 0;
        }
        else
        {
            if ( pbmi->bmiHeader.biBitCount == 16 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
            else if ( pbmi->bmiHeader.biBitCount == 32 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
            else
                pbmi->bmiHeader.biSizeImage = 0;
        }
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biClrImportant = 0;

        //
        // Create the DIB section.  Let Win32 allocate the memory and return
        // a pointer to the bitmap surface.
        //

        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);
        GdiFlush();

        if ( !hbmRet )
        {
            SS_DBGPRINT("CreateCompatibleDIB: CreateDIBSection failed\n");
        }
    }
    else
    {
        SS_DBGPRINT("CreateCompatibleDIB: bFillBitmapInfo failed\n");
    }

    return hbmRet;
}

/******************************Public*Routine******************************\
* UpdateDIBColorTable
*
* Synchronize the DIB color table to the specified palette hpal.
* If hpal is NULL, then use the system palette.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
SSDIB_UpdateColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;
    BYTE aj[(sizeof(RGBQUAD) + sizeof(PALETTEENTRY)) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    LPRGBQUAD prgb = (LPRGBQUAD) (lppe + 256);
    ULONG i, cColors;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        SS_DBGPRINT("UpdateDIBColorTable: not OBJ_DC\n");
        return bRet;
    }
    if ( GetObjectType(hdcMem) != OBJ_MEMDC )
    {
        SS_DBGPRINT("UpdateDIBColorTable: not OBJ_MEMDC\n");
        return bRet;
    }

    //
    // Get the bitmap handle out of the memdc.
    //

    hbm = GetCurrentObject(hdcMem, OBJ_BITMAP);

    //
    // Validate bitmap (must be DIB section).
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds)) &&
         ds.dsBm.bmBits )
    {
        //
        // Get palette entries from specified palette or system palette.
        //

        cColors = 1 << ds.dsBmih.biBitCount;


        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe)
           )
        {
            UINT i;

            //
            // Convert to RGBQUAD.
            //

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            //
            // Set the DIB color table.
            //

            bRet = (BOOL) SetDIBColorTable(hdcMem, 0, cColors, prgb);

            if (!bRet)
            {
                SS_DBGPRINT("UpdateDIBColorTable: SetDIBColorTable failed\n");
            }
        }
        else
        {
            SS_DBGPRINT("UpdateDIBColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }
    else
    {
        SS_DBGPRINT("UpdateDIBColorTable: GetObject failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetCompatibleDIBInfo
*
* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride.
* Win32 DIBs can be created bottom-up (the default) with the origin at the
* lower left corner or top-down with the origin at the upper left corner.
* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride
* us negative.
*
* Also, because of restrictions on the alignment of scan lines the width
* the bitmap is often not the same as the stride (stride is the number of
* bytes between vertically adjacent pixels).
*
* The ppvBase and plStride value returned will allow you to address any
* given pixel (x, y) in the bitmap as follows:
*
* PIXEL *ppix;
*
* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL APIENTRY
GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride)
{
    BOOL bRet = FALSE;
    DIBSECTION ds;

    //
    // Call GetObject to return a DIBSECTION.  If successful, the
    // bitmap is a DIB section and we can retrieve the pointer to
    // the bitmap bits and other parameters.
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && ds.dsBm.bmBits )
    {
        // For backwards compatibility with Get/SetBitmapBits, GDI does
        // not accurately report the bitmap pitch in bmWidthBytes.  It
        // always computes bmWidthBytes assuming WORD-aligned scanlines
        // regardless of the platform.
        //
        // Therefore, if the platform is WinNT, which uses DWORD-aligned
        // scanlines, adjust the bmWidthBytes value.

        {
            OSVERSIONINFO osvi;

            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx(&osvi))
            {
                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }
            }
            else
            {
                SS_DBGPRINT1("GetCompatibleDIBInfo: GetVersionEx failed with %d\n", GetLastError());
                return bRet;
            }
        }

        //
        // If biHeight is positive, then the bitmap is a bottom-up DIB.
        // If biHeight is negative, then the bitmap is a top-down DIB.
        //

        if ( ds.dsBmih.biHeight > 0 )
        {
            *ppvBase  = (PVOID) (((int) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes);
        }
        else
        {
            *ppvBase  = ds.dsBm.bmBits;
            *plStride = ds.dsBm.bmWidthBytes;
        }

        bRet = TRUE;
    }
    else
    {
        SS_DBGPRINT("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetDIBTranslationVector
*
* Copies the translation vector that maps colors in the specified palette,
* hpal, to the DIB selected into the specified DC, hdcMem.
*
* Effects:
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL APIENTRY
GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;

    //
    // Validate parameters.
    //

    if ( GetObjectType(hdcMem) != OBJ_MEMDC ||
         GetObjectType(hpal) != OBJ_PAL ||
         !pbVector )
    {
        SS_DBGPRINT("GetDIBTranslationVector: bad parameter\n");
        return bRet;
    }

    //
    // The function bComputeLogicalToSurfaceMap cannot handle palettes
    // greater than 256 entries.
    //

    if ( GetPaletteEntries(hpal, 0, 1, NULL) > 256 )
    {
        SS_DBGPRINT("GetDIBTranslationVector: palette too big\n");
        return bRet;
    }

    //
    // The DIB must have a color table.
    //

    hbm = GetCurrentObject(hdcMem, OBJ_BITMAP);
    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && (ds.dsBmih.biBitCount <= 8) )
    {
        bRet = bComputeLogicalToSurfaceMap(hdcMem, hpal, pbVector);
    }
    else
    {
        SS_DBGPRINT("GetDIBTranslationVector: not a DIB section\n");
        return bRet;
    }

    return bRet;
}

//////////////////// Below here are internal-only routines ////////////////////

/******************************Public*Routine******************************\
* bFillBitmapInfo
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if ( pbmi->bmiHeader.biBitCount <= 8 )
        {
            bRet = bFillColorTable(hdc, hpal, pbmi);
        }
        else
        {
            if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
            {
                //
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
            }

            bRet = TRUE;
        }

        DeleteObject(hbm);
    }
    else
    {
        SS_DBGPRINT("bFillBitmapInfo: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG i, cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;
    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
        else
        {
            SS_DBGPRINT("bFillColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* MyGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}

/******************************Public*Routine******************************\
* bComputeLogicalToSurfaceMap
*
* Copy logical palette to surface palette translation vector to the buffer
* pointed to by pajVector.  The logical palette is specified by hpal.  The
* surface is specified by hdc.
*
* Note: The hdc may identify either a direct (display) dc or a DIB memory dc.
* If hdc is a display dc, then the surface palette is the system palette.
* If hdc is a memory dc, then the surface palette is the DIB color table.
*
* History:
*  27-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL 
bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal, BYTE *pajVector)
{
    BOOL bRet = FALSE;
    HPALETTE hpalSurf;
    ULONG cEntries, cSysEntries;
    DWORD dwDcType = GetObjectType(hdc);
    LPPALETTEENTRY lppeTmp, lppeEnd;

    BYTE aj[sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 512) + (sizeof(RGBQUAD) * 256)];
    LOGPALETTE *ppal = (LOGPALETTE *) aj;
    LPPALETTEENTRY lppeSurf = &ppal->palPalEntry[0];
    LPPALETTEENTRY lppe = lppeSurf + 256;
    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256);

    //
    // Determine number of colors in each palette.
    //

    cEntries = GetPaletteEntries(hpal, 0, 1, NULL);
    if ( dwDcType == OBJ_DC )
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, 1, NULL);
    else
        cSysEntries = 256;

    //
    // Get the logical palette entries.
    //

    cEntries = GetPaletteEntries(hpal, 0, cEntries, lppe);

    //
    // Get the surface palette entries.
    //

    if ( dwDcType == OBJ_DC )
    {
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, cSysEntries, lppeSurf);

        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        for (; lppeTmp < lppeEnd; lppeTmp++)
            lppeTmp->peFlags = 0;
    }
    else
    {
        RGBQUAD *prgbTmp;

        //
        // First get RGBQUADs from DIB color table...
        //

        cSysEntries = GetDIBColorTable(hdc, 0, cSysEntries, prgb);

        //
        // ...then convert RGBQUADs into PALETTEENTRIES.
        //

        prgbTmp = prgb;
        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        while ( lppeTmp < lppeEnd )
        {
            lppeTmp->peRed   = prgbTmp->rgbRed;
            lppeTmp->peGreen = prgbTmp->rgbGreen;
            lppeTmp->peBlue  = prgbTmp->rgbBlue;
            lppeTmp->peFlags = 0;

            lppeTmp++;
            prgbTmp++;

        }
    }

    //
    // Construct a translation vector by using GetNearestPaletteIndex to
    // map each entry in the logical palette to the surface palette.
    //

    if ( cEntries && cSysEntries )
    {
        //
        // Create a temporary logical palette that matches the surface
        // palette retrieved above.
        //

        ppal->palVersion = 0x300;
        ppal->palNumEntries = (USHORT) cSysEntries;

        if ( hpalSurf = CreatePalette(ppal) )
        {
            //
            // Translate each logical palette entry into a surface palette
            // index.
            //

            lppeTmp = lppe;
            lppeEnd = lppe + cEntries;

            for ( ; lppeTmp < lppeEnd; lppeTmp++, pajVector++)
            {
                *pajVector = (BYTE) GetNearestPaletteIndex(
                                        hpalSurf,
                                        RGB(lppeTmp->peRed,
                                            lppeTmp->peGreen,
                                            lppeTmp->peBlue)
                                        );
            }

            bRet = TRUE;

            DeleteObject(hpalSurf);
        }
        else
        {
            SS_DBGPRINT("bComputeLogicalToSurfaceMap: CreatePalette failed\n");
        }
    }
    else
    {
        SS_DBGPRINT("bComputeLogicalToSurfaceMap: failed to get pal info\n");
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libaux\tkimage.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"

#define static


#define IMAGIC      0x01da
#define IMAGIC_SWAP 0xda01

#define SWAP_SHORT_BYTES(x) ((((x) & 0xff) << 8) | (((x) & 0xff00) >> 8))
#define SWAP_LONG_BYTES(x) (((((x) & 0xff) << 24) | (((x) & 0xff00) << 8)) | \
                            ((((x) & 0xff0000) >> 8) | (((x) & 0xff000000) >> 24)))

typedef struct _rawImageRec {
    unsigned short imagic;
    unsigned short type;
    unsigned short dim;
    unsigned short sizeX, sizeY, sizeZ;
    unsigned long min, max;
    unsigned long wasteBytes;
    char name[80];
    unsigned long colorMap;
    HANDLE file;
    unsigned char *tmp, *tmpR, *tmpG, *tmpB;
    unsigned long rleEnd;
    unsigned long *rowStart;
    long *rowSize;
} rawImageRec;

static void RawImageClose(rawImageRec *raw);

static rawImageRec *RawImageOpenAW(char *fileName, BOOL bUnicode)
{
    rawImageRec *raw;
    unsigned long *rowStart, *rowSize, ulTmp;
    int x;
    DWORD dwBytesRead;

    raw = (rawImageRec *)malloc(sizeof(rawImageRec));
    if (raw == NULL) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        return NULL;
    }

    raw->file = bUnicode ? CreateFileW((LPWSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0) :
                           CreateFileA((LPSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
    if (raw->file == INVALID_HANDLE_VALUE) {
        char ach[256];

        bUnicode ? wsprintf(ach, "Failed to open image file %ws.\n", fileName) :
                   wsprintf(ach, "Failed to open image file %s.\n", fileName);

        MESSAGEBOX(GetFocus(), ach, "Error", MB_OK);

        free( raw );
        return NULL;
    }

    ReadFile(raw->file, (LPVOID) raw, 12, &dwBytesRead, (LPOVERLAPPED) NULL);

    if (raw->imagic == IMAGIC_SWAP) {
        raw->type = SWAP_SHORT_BYTES(raw->type);
        raw->dim = SWAP_SHORT_BYTES(raw->dim);
        raw->sizeX = SWAP_SHORT_BYTES(raw->sizeX);
        raw->sizeY = SWAP_SHORT_BYTES(raw->sizeY);
        raw->sizeZ = SWAP_SHORT_BYTES(raw->sizeZ);
    } else if (raw->imagic != IMAGIC) {
        // magic number is absent - conclude file is invalid (?)
        MESSAGEBOX(GetFocus(), "Invalid rgb file.", "Error", MB_OK);
        RawImageClose( raw );
        return NULL;
    }
        
    raw->tmp = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpR = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpG = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpB = (unsigned char *)malloc(raw->sizeX*256);
    if (raw->tmp == NULL || raw->tmpR == NULL || raw->tmpG == NULL ||
        raw->tmpB == NULL) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        RawImageClose( raw );
        return NULL;
    }

    if ((raw->type & 0xFF00) == 0x0100) {
        x = raw->sizeY * raw->sizeZ * sizeof(long);
        raw->rowStart = (unsigned long *)malloc(x);
        raw->rowSize = (long *)malloc(x);
        if (raw->rowStart == NULL || raw->rowSize == NULL) {
            MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
            RawImageClose( raw );
            return NULL;
        }
        raw->rleEnd = 512 + (2 * x);
        SetFilePointer(raw->file, 512, NULL, FILE_BEGIN);
        ReadFile(raw->file, (LPVOID) raw->rowStart, x, &dwBytesRead,
                 (LPOVERLAPPED) NULL);
        ReadFile(raw->file, (LPVOID) raw->rowSize, x, &dwBytesRead,
                 (LPOVERLAPPED) NULL);
        if (raw->imagic == IMAGIC_SWAP) {
            x /= sizeof(long);
            rowStart = raw->rowStart;
            rowSize = raw->rowSize;
            while (x--) {
                ulTmp = *rowStart;
                *rowStart++ = SWAP_LONG_BYTES(ulTmp);
                ulTmp = *rowSize;
                *rowSize++ = SWAP_LONG_BYTES(ulTmp);
            }
        }
    }
    return raw;
}

static void RawImageClose(rawImageRec *raw)
{
    if( !raw )
        return;
    CloseHandle(raw->file);
    if( raw->tmp ) free(raw->tmp);
    if( raw->tmpR ) free(raw->tmpR);
    if( raw->tmpG ) free(raw->tmpG);
    if( raw->tmpB ) free(raw->tmpB);
    free(raw);
}

static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z)
{
    unsigned char *iPtr, *oPtr, pixel;
    int count;
    DWORD dwBytesRead;

    if ((raw->type & 0xFF00) == 0x0100) {
        SetFilePointer(raw->file, raw->rowStart[y+z*raw->sizeY], NULL, FILE_BEGIN);
        ReadFile(raw->file, (LPVOID) raw->tmp,
                 (unsigned int)raw->rowSize[y+z*raw->sizeY], &dwBytesRead,
                 (LPOVERLAPPED) NULL);

        iPtr = raw->tmp;
        oPtr = buf;
        while (1) {
            pixel = *iPtr++;
            count = (int)(pixel & 0x7F);
            if (!count) {
                return;
            }
            if (pixel & 0x80) {
                while (count--) {
                    *oPtr++ = *iPtr++;
                }
            } else {
                pixel = *iPtr++;
                while (count--) {
                    *oPtr++ = pixel;
                }
            }
        }
    } else {
        SetFilePointer(raw->file, 512+(y*raw->sizeX)+(z*raw->sizeX*raw->sizeY),
                       NULL, FILE_BEGIN);
        ReadFile(raw->file, (LPVOID) buf, raw->sizeX, &dwBytesRead,
                 (LPOVERLAPPED) NULL);
    }
}

static void RawImageGetData(rawImageRec *raw, TK_RGBImageRec *final)
{
    unsigned char *ptr;
    int i, j;

    final->data = (unsigned char *)malloc((raw->sizeX+1)*(raw->sizeY+1)*4);
    if (final->data == NULL) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        return;
    }

    ptr = final->data;
    for (i = 0; i < raw->sizeY; i++) {
        RawImageGetRow(raw, raw->tmpR, i, 0);
        RawImageGetRow(raw, raw->tmpG, i, 1);
        RawImageGetRow(raw, raw->tmpB, i, 2);
        for (j = 0; j < raw->sizeX; j++) {
            *ptr++ = *(raw->tmpR + j);
            *ptr++ = *(raw->tmpG + j);
            *ptr++ = *(raw->tmpB + j);
        }
    }
}

TK_RGBImageRec *tkRGBImageLoad(char *fileName)
{
    return tkRGBImageLoadAW(fileName, FALSE);
}

TK_RGBImageRec *tkRGBImageLoadAW(char *fileName, BOOL bUnicode)
{
    rawImageRec *raw;
    TK_RGBImageRec *final;

    if( !(raw = RawImageOpenAW(fileName, bUnicode)) )
        return NULL;

    final = (TK_RGBImageRec *)malloc(sizeof(TK_RGBImageRec));
    if (final == NULL) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        RawImageClose(raw);
        return NULL;
    }
    final->sizeX = raw->sizeX;
    final->sizeY = raw->sizeY;
    RawImageGetData(raw, final);
    RawImageClose(raw);
    return final;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\clear.cxx ===
/******************************Module*Header*******************************\
* Module Name: clear.cxx
*
* Window clearing functions
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <sys/timeb.h>
#include <GL/gl.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <math.h>

#include "mtk.h"
#include "timer.hxx"
#include "util.hxx"
#include "clear.hxx"

#define SS_CLEAR_BASE_DIV 32
#define SS_CLEAR_BASE_SIZE 16


/******************************Public*Routine******************************\
* ss_RectWipeClear
*
* Clears by drawing top, bottom, left, right rectangles that shrink in size
* towards the center.
*
* Calibration is used to try to maintain an ideal clear time.
*
\**************************************************************************/

int
mtk_RectWipeClear( int width, int height, int repCount )
{
    int i, j, xinc, yinc, numDivs;
    int xmin, xmax, ymin, ymax;
    int w, h;
    BOOL bCalibrate = FALSE;
    float elapsed;
    static float idealTime = 0.7f;
    TIMER timer;

    xinc = 1;
    yinc = 1;
    numDivs = height; // assumes height <= width

    xmin = ymin = 0;
    xmax = width-1;
    ymax = height-1;

    glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );

    glEnable( GL_SCISSOR_TEST );

    if( repCount == 0 ) {
        bCalibrate = TRUE;
        repCount = 1;
        timer.Start();
    }

    for( i = 0; i < (numDivs/2); i ++ ) {
      w = xmax - xmin + 1;
      h = ymax - ymin + 1;

      for( j = 0; j < repCount; j ++ ) {
        // bottom
        glScissor( xmin, ymin, w, 1 );
        glClear( GL_COLOR_BUFFER_BIT );

        // left
        glScissor( xmin, ymin, 1, h );
        glClear( GL_COLOR_BUFFER_BIT );

        // right
        glScissor( xmax, ymin, 1, h );
        glClear( GL_COLOR_BUFFER_BIT );

        // top
        glScissor( xmin, ymax, w, 1 );
        glClear( GL_COLOR_BUFFER_BIT );

        glFlush(); // to eliminate 'bursts'
      }

      xmin += xinc;
      xmax -= xinc;
      ymin += yinc;
      ymax -= yinc;
    }

    if( bCalibrate ) {
        elapsed = timer.Stop();

        // try to maintain ideal clear time
        if( elapsed < idealTime ) {
            // increase repCount to slow down the clear
            if( elapsed == 0.0 )
                repCount = 10;  // just in case
            else
                repCount = (int) ((idealTime / elapsed) + 0.5);
        }
    }

    glDisable( GL_SCISSOR_TEST );

    return repCount;
}

#define SS_CLEAR_BASE_DIV 32

/******************************Public*Routine******************************\
*
* SS_DIGITAL_DISSOLVE_CLEAR constructor
*
\**************************************************************************/

SS_DIGITAL_DISSOLVE_CLEAR::
SS_DIGITAL_DISSOLVE_CLEAR()
{
    rectBuf = NULL;
    rectBufSize = 0;
    rectSize = SS_CLEAR_BASE_SIZE;
}

/******************************Public*Routine******************************\
*
* SS_DIGITAL_DISSOLVE_CLEAR destructor
*
\**************************************************************************/

SS_DIGITAL_DISSOLVE_CLEAR::
~SS_DIGITAL_DISSOLVE_CLEAR()
{
    if( rectBuf )
        LocalFree( rectBuf );
}

/******************************Public*Routine******************************\
* CalibrateClear
*
* Try to calibrate the clear so it takes the specified time
\**************************************************************************/

//#define AUTO_CALIBRATE 1

int SS_DIGITAL_DISSOLVE_CLEAR::
CalibrateClear( int width, int height, float fClearTime )
{
    float factor;
    int idealNRects;
    int nRects;
    int baseSize;
    TIMER timer;
    float elapsed;

    baseSize = (width < height ? width : height) / SS_CLEAR_BASE_DIV;
    if( baseSize == 0 )
        baseSize = 1;

    timer.Start();

#ifdef AUTO_CALIBRATE
    // Clear a small region (quarter-screen) and extrapolate
    Clear( width >> 1, height >> 1, baseSize );
#else
    Clear( width, height, baseSize );
#endif

    elapsed = timer.Stop();
#ifdef AUTO_CALIBRATE
    // extrapolate to full screen time
    // mf: this approximation resulted in clears being somewhat less than ideal
    //  I guess this means more time than I thought was spent in scanning up
    //  or down for uncleared rects
    elapsed *= 4.0f;
#endif

    // Adjust size of rects for ideal clear time

    if( elapsed <= 0.0f ) {
        rectSize = 1;
        return rectSize;
    }

    nRects = RectangleCount( width, height, baseSize );
    factor = fClearTime / elapsed;
    idealNRects = (int) (factor * (float)nRects);
    rectSize = (int) (sqrt( (double)(width*height) / (double)idealNRects ) + 0.5);
    if( rectSize == 0 )
        rectSize = 1;

    return rectSize;
}

/******************************Public*Routine******************************\
* 
* SS_DIGITAL_DISSOLVE_CLEAR::Clear
*
* Clears by drawing random rectangles
*
\**************************************************************************/


BOOL SS_DIGITAL_DISSOLVE_CLEAR::
Clear( int width, int height )
{
    return Clear( width, height, rectSize );
}

BOOL SS_DIGITAL_DISSOLVE_CLEAR::
Clear( int width, int height, int size )
{
    BOOL *pRect;
    BOOL bCalibrate = FALSE;
    int count, nRects;
    int i, xdim, ydim;
    static float idealTime = 2.0f;

    if( (size <= 0) || !width || !height )
        return FALSE;

    // determine xdim, ydim from size
    xdim = SS_ROUND_UP( (float)width / (float)size );
    ydim = SS_ROUND_UP( (float)height / (float) size );

    // figure out how many rects needed
    count = nRects = xdim * ydim;

    // make sure enough room
    if( !ValidateBufSize( nRects ) )
        return FALSE;

    // reset the rect array to uncleared

    pRect = rectBuf;
    for( i = 0; i < count; i ++, pRect++ )
        *pRect = FALSE;

    // Clear random rectangles

    glEnable( GL_SCISSOR_TEST );

    while( count ) {
        // pick a random rect
        i = ss_iRand( nRects );

        if( rectBuf[i] ) {
            // This rect has already been cleared - find an empty one
            // Scan up and down from x,y, looking at the array linearly

            int up, down;
            BOOL searchUp = FALSE;

            up = down = i;

            pRect = rectBuf;
            while( *(pRect + i) ) {
                if( searchUp ) {
                    // search up side
                    if( up < (nRects-1) ) {
                        up++;
                    }
                    i = up;
                } else {
                    // search down side
                    if( down > 0 ) {
                        down--;
                    }
                    i = down;
                }
                searchUp = !searchUp;
            }
        }

        // clear the x,y rect
        glScissor( (i % xdim)*size, (i / xdim)*size, size, size );
        glClear( GL_COLOR_BUFFER_BIT );
        glFlush();

        rectBuf[i] = TRUE; // mark as taken
        count--;
    }

    glDisable( GL_SCISSOR_TEST );

    return TRUE;
}

/******************************Public*Routine******************************\
* RectangleCount
*
\**************************************************************************/

int SS_DIGITAL_DISSOLVE_CLEAR::
RectangleCount( int width, int height, int size )
{
    return  SS_ROUND_UP( (float)width / (float)size ) *
            SS_ROUND_UP( (float)height / (float) size );
}

/******************************Public*Routine******************************\
* ValidateBufSize
*
\**************************************************************************/

BOOL SS_DIGITAL_DISSOLVE_CLEAR::
ValidateBufSize( int nRects )
{
    if( nRects > rectBufSize ) {
        // need a bigger rect buf
        BOOL *r = (BOOL *) LocalAlloc( LMEM_FIXED, sizeof(BOOL) * nRects );
        if( !r )
            return FALSE;
        if( rectBuf )
            LocalFree( rectBuf );
        rectBuf = r;
        rectBufSize = nRects;
    }
    return TRUE;
}

/******************************Public*Routine******************************\
* DrawGdiRect
*
* Clears the rect with the brush
\**************************************************************************/

void
DrawGdiRect( HDC hdc, HBRUSH hbr, RECT *pRect ) 
{
    if( pRect == NULL )
        return;

    FillRect( hdc, pRect, hbr );
    GdiFlush();
}

#ifdef SS_INITIAL_CLEAR
/*-----------------------------------------------------------------------
|                                                                       
|    RectWipeClear(width, height):  
|       - Does a rectangular wipe (or clear) by drawing in a sequence   
|         of rectangles using Gdi                                       
|       MOD: add calibrator capability to adjust speed for different
|            architectures
|       MOD: this can be further optimized by caching the brush
|
-----------------------------------------------------------------------*/
void 
mtk_GdiRectWipeClear( HWND hwnd, int width, int height )
{
    HDC hdc;
    HBRUSH hbr;
    RECT rect;
    int i, j, xinc, yinc, numDivs = 500;
    int xmin, xmax, ymin, ymax;
    int repCount = 10;

    xinc = 1;
    yinc = 1;
    numDivs = height;
    xmin = ymin = 0;
    xmax = width;
    ymax = height;

    hdc = GetDC( hwnd );

    hbr = CreateSolidBrush( RGB( 0, 0, 0 ) );

    for( i = 0; i < (numDivs/2 - 1); i ++ ) {
      for( j = 0; j < repCount; j ++ ) {
        rect.left = xmin; rect.top = ymin;
        rect.right = xmax; rect.bottom = ymin + yinc;
        FillRect( hdc, &rect, hbr );
        rect.top = ymax - yinc;
        rect.bottom = ymax;
        FillRect( hdc, &rect, hbr );
        rect.top = ymin + yinc;
        rect.right = xmin + xinc; rect.bottom = ymax - yinc;
        FillRect( hdc, &rect, hbr );
        rect.left = xmax - xinc; rect.top = ymin + yinc;
        rect.right = xmax; rect.bottom = ymax - yinc;
        FillRect( hdc, &rect, hbr );
      }

      xmin += xinc;
      xmax -= xinc;
      ymin += yinc;
      ymax -= yinc;
    }

    // clear last square in middle

    rect.left = xmin; rect.top = ymin;
    rect.right = xmax; rect.bottom = ymax;
    FillRect( hdc, &rect, hbr );

    DeleteObject( hbr );

    ReleaseDC( hwnd, hdc );

    GdiFlush();
}
#endif // SS_INITIAL_CLEAR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\color.c ===
#include <windows.h>
#include <math.h>
#include <GL/gl.h>
#include "mtk.h"


/******************************Public*Routine******************************\
* HsvToRgb
*
* HSV to RGB color space conversion.  From pg. 593 of Foley & van Dam.
*
\**************************************************************************/

void 
ss_HsvToRgb(float h, float s, float v, RGBA *color )
{
    float i, f, p, q, t;

    // set alpha value, so caller doesn't have to worry about undefined value
    color->a = 1.0f;

    if (s == 0.0f)     // assume h is undefined
        color->r = color->g = color->b = v;
    else {
        if (h >= 360.0f)
            h = 0.0f;
        h = h / 60.0f;
        i = (float) floor(h);
        f = h - i;
        p = v * (1.0f - s);
        q = v * (1.0f - (s * f));
        t = v * (1.0f - (s * (1.0f - f)));
        switch ((int)i) {
        case 0:
            color->r = v;
            color->g = t;
            color->b = p;
            break;
        case 1:
            color->r = q;
            color->g = v;
            color->b = p;
            break;
        case 2:
            color->r = p;
            color->g = v;
            color->b = t;
            break;
        case 3:
            color->r = p;
            color->g = q;
            color->b = v;
            break;
        case 4:
            color->r = t;
            color->g = p;
            color->b = v;
            break;
        case 5:
            color->r = v;
            color->g = p;
            color->b = q;
            break;
        default:
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\glutil.cxx ===
/******************************Module*Header*******************************\
* Module Name: glutil.cxx
*
* Misc. utility functions
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <GL/gl.h>
#include <sys/types.h>
#include <math.h>

#include "mtk.h"
#include "glutil.hxx"

MTK_OS_INFO gOSInfo;
MTK_GL_CAPS gGLCaps; // this should be per context, eventually

void (__stdcall *glAddSwapHintRect)(GLint, GLint, GLint, GLint);

/******************************Public*Routine******************************\
* ss_fOnGL11
*
* True if running on OpenGL v.1.1x
*
\**************************************************************************/

BOOL
mtk_fOnGL11( void )
{
    return gGLCaps.bGLv1_1;
}

/******************************Public*Routine******************************\
* ss_fOnNT35
*
* True if running on NT version 3.51 or less
*
\**************************************************************************/

BOOL 
mtk_fOnNT35( void )
{
    return gOSInfo.fOnNT35;
}

/******************************Public*Routine******************************\
* ss_fOnWin95
*
* True if running on Windows 95
*
\**************************************************************************/

BOOL 
mtk_fOnWin95( void )
{
    return gOSInfo.fOnWin95;
}

/******************************Public*Routine******************************\
* MyAddSwapHintRect
*
\**************************************************************************/

static void _stdcall 
MyAddSwapHintRect(GLint xs, GLint ys, GLint xe, GLint ye)
{
    return;
}

/******************************Public*Routine******************************\
* QueryAddSwapHintRectWIN
*
\**************************************************************************/

//mf: again, per context problem
BOOL
mtk_QueryAddSwapHintRect()
{
    glAddSwapHintRect = (PFNGLADDSWAPHINTRECTWINPROC)
        wglGetProcAddress("glAddSwapHintRectWIN");
    if (glAddSwapHintRect == NULL) {
        glAddSwapHintRect = MyAddSwapHintRect;
        return FALSE;
    }
    return TRUE;
}


/******************************Public*Routine******************************\
* mtk_bAddSwapHintRect()
*
\**************************************************************************/

BOOL 
mtk_bAddSwapHintRect()
{
    return gGLCaps.bAddSwapHintRect;
}

/******************************Public*Routine******************************\
\**************************************************************************/

MTK_OS_INFO::MTK_OS_INFO()
{
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    fOnWin95 = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
    fOnNT35 = 
    ( 
        (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
        (osvi.dwMajorVersion == 3 && osvi.dwMinorVersion <= 51)
    );
}

/******************************Public*Routine******************************\
\**************************************************************************/

MTK_GL_CAPS::MTK_GL_CAPS()
{
    bGLv1_1 = FALSE;
    bTextureObjects = FALSE;
    bAddSwapHintRect = FALSE;
    bPalettedTexture = FALSE;
}

void
MTK_GL_CAPS::Query()
{
    bGLv1_1 = (BOOL) strstr( (char *) glGetString(GL_VERSION), "1.1" );
    if( bGLv1_1 )
        bTextureObjects = TRUE;
    if( !bTextureObjects )
        SS_DBGINFO( "MTK_GL_CAPS: Texture Objects disabled\n" );
    bAddSwapHintRect = mtk_QueryAddSwapHintRect();
    bPalettedTexture = mtk_QueryPalettedTextureEXT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\math.c ===
/******************************Module*Header*******************************\
* Module Name: math.c
*
* Misc. useful math utility functions.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <GL\gl.h>
#include <math.h>
#include "mtk.h"

#define ZERO_EPS    0.00000001

POINT3D ss_ptZero = {0.0f, 0.0f, 0.0f};


void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]) + mat->M[0][3];

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]) + mat->M[1][3];

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]) + mat->M[2][3];

    ptOut->x = (float) x;
    ptOut->y = (float) y;
    ptOut->z = (float) z;
}

void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;
    double len;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]);

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]);

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]);

    len = (x * x) + (y * y) + (z * z);
    if (len >= ZERO_EPS)
        len = 1.0 / sqrt(len);
    else
        len = 1.0;

    ptOut->x = (float) (x * len);
    ptOut->y = (float) (y * len);
    ptOut->z = (float) (z * len);
    return;
}

void ss_matrixIdent(MATRIX *mat)
{
    mat->M[0][0] = 1.0f; mat->M[0][1] = 0.0f;
    mat->M[0][2] = 0.0f; mat->M[0][3] = 0.0f;

    mat->M[1][0] = 0.0f; mat->M[1][1] = 1.0f;
    mat->M[1][2] = 0.0f; mat->M[1][3] = 0.0f;

    mat->M[2][0] = 0.0f; mat->M[2][1] = 0.0f;
    mat->M[2][2] = 1.0f; mat->M[2][3] = 0.0f;

    mat->M[3][0] = 0.0f; mat->M[3][1] = 0.0f;
    mat->M[3][2] = 0.0f; mat->M[3][3] = 1.0f;
}

void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta)
{
    float xScale, yScale, zScale;
    float sinX, cosX;
    float sinY, cosY;
    float sinZ, cosZ;

    xScale = m->M[0][0];
    yScale = m->M[1][1];
    zScale = m->M[2][2];
    sinX = (float) sin(xTheta);
    cosX = (float) cos(xTheta);
    sinY = (float) sin(yTheta);
    cosY = (float) cos(yTheta);
    sinZ = (float) sin(zTheta);
    cosZ = (float) cos(zTheta);

    m->M[0][0] = (float) ((cosZ * cosY) * xScale);
    m->M[0][1] = (float) ((cosZ * -sinY * -sinX + sinZ * cosX) * yScale);
    m->M[0][2] = (float) ((cosZ * -sinY * cosX + sinZ * sinX) * zScale);

    m->M[1][0] = (float) (-sinZ * cosY * xScale);
    m->M[1][1] = (float) ((-sinZ * -sinY * -sinX + cosZ * cosX) * yScale);
    m->M[1][2] = (float) ((-sinZ * -sinY * cosX + cosZ * sinX) * zScale);

    m->M[2][0] = (float) (sinY * xScale);
    m->M[2][1] = (float) (cosY * -sinX * yScale);
    m->M[2][2] = (float) (cosY * cosX * zScale);
}

void ss_matrixTranslate(MATRIX *m, double xTrans, double yTrans,
                     double zTrans)
{
    m->M[0][3] = (float) xTrans;
    m->M[1][3] = (float) yTrans;
    m->M[2][3] = (float) zTrans;
}


void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 )
{
    int i, j;

    for( j = 0; j < 4; j ++ ) {
    	for( i = 0; i < 4; i ++ ) {
	    m1->M[j][i] = m2->M[j][0] * m3->M[0][i] +
			  m2->M[j][1] * m3->M[1][i] +
			  m2->M[j][2] * m3->M[2][i] +
			  m2->M[j][3] * m3->M[3][i];
	}
    }
}

void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3)
{
    float crossX, crossY, crossZ;
    float abX, abY, abZ;
    float acX, acY, acZ;
    float sqrLength;
    float invLength;

    abX = p2->x - p1->x;       // calculate p2 - p1
    abY = p2->y - p1->y;
    abZ = p2->z - p1->z;

    acX = p3->x - p1->x;       // calculate p3 - p1
    acY = p3->y - p1->y;
    acZ = p3->z - p1->z;

    crossX = (abY * acZ) - (abZ * acY);    // get cross product
    crossY = (abZ * acX) - (abX * acZ);    // (p2 - p1) X (p3 - p1)
    crossZ = (abX * acY) - (abY * acX);

    sqrLength = (crossX * crossX) + (crossY * crossY) +
                 (crossZ * crossZ);

    if (sqrLength > ZERO_EPS)
        invLength = (float) (1.0 / sqrt(sqrLength));
    else
        invLength = 1.0f;

    norm->x = crossX * invLength;
    norm->y = crossY * invLength;
    norm->z = crossZ * invLength;
}

void mtk_NormalizePoints(POINT3D *p, ULONG cPts)
{
    float len;
    ULONG i;

    for (i = 0; i < cPts; i++, p++) {
        len = (p->x * p->x) + (p->y * p->y) + (p->z * p->z);
        if (len > ZERO_EPS)
            len = (float) (1.0 / sqrt(len));
        else
            len = 1.0f;

        p->x *= len;
        p->y *= len;
        p->z *= len;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\mtkdebug.h ===
/******************************Module*Header*******************************\
* Module Name: ssdebug.h
*
* Debugging stuff
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#ifndef __ssdebug_h__
#define __ssdebug_h__

ULONG DbgPrint(PCH Format, ...);

#define SS_LEVEL_ERROR 1L
#define SS_LEVEL_INFO  2L
#define SS_LEVEL_ENTRY 8L

#if DBG

extern long ssDebugMsg;
extern long ssDebugLevel;

#define SS_DBGPRINT( str )          DbgPrint("SS: " str )
#define SS_DBGPRINT1( str, a )      DbgPrint("SS: " str, a )
#define SS_DBGPRINT2( str, a, b )   DbgPrint("SS: " str, a, b )
#define SS_DBGPRINT3( str, a, b, c )   DbgPrint("SS: " str, a, b, c )
#define SS_DBGPRINT4( str, a, b, c, d )   DbgPrint("SS: " str, a, b, c, d )

#define SS_WARNING(str)             DbgPrint("SS: " str )
#define SS_WARNING1(str,a)          DbgPrint("SS: " str,a)
#define SS_WARNING2(str,a,b)        DbgPrint("SS: " str,a,b)

#define SS_RIP(str)                 {SS_WARNING(str); DebugBreak();}
#define SS_RIP1(str,a)              {SS_WARNING1(str,a); DebugBreak();}
#define SS_RIP2(str,a,b)            {SS_WARNING2(str,a,b); DebugBreak();}

#define SS_ASSERT(expr,str)            if(!(expr)) SS_RIP(str)
#define SS_ASSERT1(expr,str,a)         if(!(expr)) SS_RIP1(str,a)
#define SS_ASSERT2(expr,str,a,b)       if(!(expr)) SS_RIP2(str,a,b)

#define SS_ALLOC_FAILURE(str) \
    DbgPrint( "%s : Memory allocation failure\n", str );

#define SS_DBGMSG( str )         if( ssDebugMsg ) SS_DBGPRINT( str )
#define SS_DBGMSG1( str, a )     if( ssDebugMsg ) SS_DBGPRINT1( str, a )
#define SS_DBGMSG2( str, a, b )  if( ssDebugMsg ) SS_DBGPRINT2( str, a, b )

//
// Use SS_DBGLEVEL for general purpose debug messages gated by an
// arbitrary warning level.
//
#define SS_DBGLEVEL(n,str)         if (ssDebugLevel >= (n)) SS_DBGPRINT(str)
#define SS_DBGLEVEL1(n,str,a)      if (ssDebugLevel >= (n)) SS_DBGPRINT1(str,a)
#define SS_DBGLEVEL2(n,str,a,b)    if (ssDebugLevel >= (n)) SS_DBGPRINT2(str,a,b)    

#define SS_ERROR(str)              SS_DBGLEVEL( SS_LEVEL_ERROR, str ) 
#define SS_ERROR1(str,a)           SS_DBGLEVEL1( SS_LEVEL_ERROR, str, a ) 
#define SS_ERROR2(str,a)           SS_DBGLEVEL2( SS_LEVEL_ERROR, str, a, b ) 

#define SS_DBGINFO(str)            SS_DBGLEVEL( SS_LEVEL_INFO, str ) 
#define SS_DBGINFO1(str,a)         SS_DBGLEVEL1( SS_LEVEL_INFO, str, a ) 
#define SS_DBGINFO2(str,a,b)       SS_DBGLEVEL2( SS_LEVEL_INFO, str, a, b ) 

#else

#define SS_DBGPRINT( str )
#define SS_DBGPRINT1( str, a )
#define SS_DBGPRINT2( str, a, b )
#define SS_DBGPRINT3( str, a, b, c )
#define SS_DBGPRINT4( str, a, b, c, d )

#define SS_WARNING(str)
#define SS_WARNING1(str,a)
#define SS_WARNING2(str,a,b)

#define SS_RIP(str)
#define SS_RIP1(str,a)
#define SS_RIP2(str,a,b)

#define SS_ASSERT(expr,str)         assert( expr )
#define SS_ASSERT1(expr,str,a)      assert( expr )
#define SS_ASSERT2(expr,str,a,b)    assert( expr )

#define SS_ALLOC_FAILURE(str)

#define SS_DBGMSG( str )
#define SS_DBGMSG1( str, a )
#define SS_DBGMSG2( str, a, b )

#define SS_DBGLEVEL(n,str)
#define SS_DBGLEVEL1(n,str,a)
#define SS_DBGLEVEL2(n,str,a,b)

#define SS_ERROR(str)
#define SS_ERROR1(str,a)
#define SS_ERROR2(str,a,b)

#define SS_DBGINFO(str)
#define SS_DBGINFO1(str,a)
#define SS_DBGINFO2(str,a,b)

#endif // DBG

#endif // __ssdebug_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\mtkbmp.cxx ===
/******************************Module*Header*******************************\
* Module Name: mtkbmp.cxx
*
* mtk bitmap
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include "mtk.hxx"
#include "mtkbmp.hxx"

/******************************Public*Routine******************************\
*
\**************************************************************************/

MTKBMP::MTKBMP( HDC hdcWinArg )
{
    hBitmap = NULL;
    hdcWin = hdcWinArg;
    hdc = CreateCompatibleDC( hdcWin );
    size.width = size.height = 0;
}

MTKBMP::~MTKBMP()
{
    if( hBitmap )
        DeleteObject( hBitmap );
}

BOOL
MTKBMP::Resize( ISIZE *pSize )
{
    if( (pSize->width <= 0) || (pSize->height <= 0) ) {
        SS_ERROR( "MTKBMP::Resize : Invalid size parameters\n" );
        return FALSE;
    }

    if( (pSize->width == size.width) && (pSize->height == size.height) )
        // Same size
        return TRUE;

    size = *pSize;

    PVOID pvBits;  //mf: doesn't seem like we need this
#if 1
    // Use system palette
//mf: don't know why we have to use hdcWin here, but if I use hdc, get 
// error : 'not OBJ_DC'
    HBITMAP hbmNew = 
        SSDIB_CreateCompatibleDIB(hdcWin, NULL, size.width, size.height, &pvBits);
#else
//mf: uhh, this never worked or something, right ?
    // Use log palette
    HBITMAP hbmNew = SSDIB_CreateCompatibleDIB(hdcWin, 
                                    gpssPal ? gpssPal->hPal : NULL, 
                                    size.width, size.height, &pvBits);
#endif
    if (hbmNew)
    {
        if( hBitmap != NULL )
        {
            SelectObject( hdc, hBitmap );
            DeleteObject( hBitmap );
        }

        hBitmap = hbmNew;
        SelectObject( hdc, hBitmap );
    }
    return TRUE;
}

/******************************Public*Routine******************************\
\**************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\mtkanim.cxx ===
/******************************Module*Header*******************************\
* Module Name: mtkanim.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include "mtk.hxx"
#include "mtkanim.hxx"

/**************************************************************************\
* MTKANIMATOR constructors
*
* The object needs to be attached to an hwnd, since it's required for timer
* creation, and msg posting.
\**************************************************************************/

MTKANIMATOR::MTKANIMATOR()
{
    hwnd = NULL;
    Init();
}

MTKANIMATOR::MTKANIMATOR( HWND hwndAttach )
: hwnd( hwndAttach )
{
    Init();
}

/**************************************************************************\
*
\**************************************************************************/

void
MTKANIMATOR::Init()
{
    idTimer =       0;
    nFrames = 0;
    mode = MTK_ANIMATE_CONTINUOUS;
    msUpdateInterval = 0;
    AnimateFunc =   NULL;
}

/**************************************************************************\
* MTKANIMATOR destructor
*
\**************************************************************************/

MTKANIMATOR::~MTKANIMATOR()
{
    Stop();
}

/**************************************************************************\
* SetFunc
*
* Set the animation function callback.  This immediately replaces the previous
* callback, and if a timer is currently running, then the new function gets
* called.  If the new callback is NULL, then the timer is stopped.
*
\**************************************************************************/

void
MTKANIMATOR::SetFunc( MTK_ANIMATEPROC Func )
{
    AnimateFunc = Func;

    if( ! AnimateFunc ) {
        Stop();
    }
}

/**************************************************************************\
* SetMode
*
\**************************************************************************/

void
MTKANIMATOR::SetMode( UINT newMode, float *fParam )
{
    switch( newMode ) {
        case MTK_ANIMATE_CONTINUOUS :
            // First param is animation period ( 1/fps )
         {
            float fUpdateInterval = fParam[0];
            if( fUpdateInterval < 0.0f )
                SS_WARNING( "MTKANIMATOR::SetMode: bad update interval parameter\n" );
                fUpdateInterval = 0.0f;
            msUpdateInterval = (UINT) (fUpdateInterval * 1000.0f);
         }
            break;

        case MTK_ANIMATE_INTERVAL :
            // First param is number of frames,
            // Second param is total desired duration of the animation
         {
            int iFrameCount = (int) fParam[0];
            float fDuration = fParam[1];

            // Check parameters
            // fDuration = 0.0f is valid - it means go as fast as possible...
            if( (fDuration < 0.0f) || (iFrameCount <= 0) )
                SS_ERROR( "MTKANIMATOR::SetMode: bad parameter\n" );
                return;
            nFrames = iFrameCount;
            msUpdateInterval = (UINT) ( (fDuration / (float) nFrames) * 1000.0f);
         }
            break;

        default :
            return;
    }
    mode = newMode;
}

/**************************************************************************\
* Start
*
* Start the animation by creating a new timer, if there is a valid animation
* callback function.
*
\**************************************************************************/

void
MTKANIMATOR::Start( )
{
    // Create new timer
    if( idTimer  || !AnimateFunc )
        return;  // Timer already running, or no animate func

    idTimer = SetTimer( hwnd, MTK_ANIMATE_TIMER_ID, msUpdateInterval, NULL );
    if( ! idTimer )
        SS_WARNING( "MTKANIMATOR::Start: SetTimer failure\n" );
}

/**************************************************************************\
* Stop
*
* Stop the animation by killing the timer.  Remove any WM_TIMER msgs
*
\**************************************************************************/

void
MTKANIMATOR::Stop( )
{
    if( !idTimer )
        return;

    if( ! KillTimer( hwnd, MTK_ANIMATE_TIMER_ID ) )
        SS_WARNING( "MTKANIMATOR::Stop: KillTimer failure\n" );

    // remove any timer messages from queue
    MSG Msg;
    PeekMessage( &Msg, hwnd, WM_TIMER, WM_TIMER, PM_REMOVE );
    idTimer = 0;
}

//mf: need better name for this
/**************************************************************************\
*
* Call the animate function
*
* A return value of FALSE indicates that an interval based animation has
* finished - TRUE otherwise.
*
\**************************************************************************/

BOOL
MTKANIMATOR::Draw( )
{
    if( !AnimateFunc )
        return TRUE;

    (*AnimateFunc)();

    if( mode == MTK_ANIMATE_INTERVAL ) {
        if( --nFrames <= 0 )
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\mtk.h ===
/******************************Module*Header*******************************\
* Module Name: mtk.h
*
* Defines and externals for m toolkit
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#ifndef __mtk_h__
#define __mtk_h__

#include <windows.h>
#include <assert.h>

#include "tk.h"

#ifdef __cplusplus
extern "C" {
#endif

#include "mtkdebug.h"
#include "trackbal.h"

#define FAILURE             0
#define SUCCESS             1

// Maximum texture bitmap dimensions.

#define TEX_WIDTH_MAX   1280
#define TEX_HEIGHT_MAX  1024

#define PI 3.14159265358979323846f
// double version of PI
#define PI_D 3.14159265358979323846264338327950288419716939937510
#define ONE_OVER_PI (1.0f / PI)
#define ROOT_TWO 1.414213562373f

#define GEN_STRING_SIZE 64

// texture quality level
enum {
    TEXQUAL_DEFAULT = 0,
    TEXQUAL_HIGH
};

typedef struct _point2d {
    GLfloat x;
    GLfloat y;
} POINT2D;

typedef struct _ipoint2d {
    int x;
    int y;
} IPOINT2D;

typedef struct _point3d {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} POINT3D;

typedef struct _dpoint3d {
    GLdouble x;
    GLdouble y;
    GLdouble z;
} DPOINT3D;

typedef struct _ipoint3d {
    int x;
    int y;
    int z;
} IPOINT3D;

typedef struct _texpoint2d {
    GLfloat s;
    GLfloat t;
} TEX_POINT2D;

typedef struct _isize {
    int width;
    int height;
} ISIZE;

typedef struct _fsize {
    GLfloat width;
    GLfloat height;
} FSIZE;

typedef struct _glrect {
    float   x, y;
    float   width, height;
} GLRECT;

typedef struct _glirect {
    int x, y;
    int width, height;
} GLIRECT;

#ifndef GL_EXT_paletted_texture
#define GL_COLOR_INDEX1_EXT                   0x80E2
#define GL_COLOR_INDEX2_EXT                   0x80E3
#define GL_COLOR_INDEX4_EXT                   0x80E4
#define GL_COLOR_INDEX8_EXT                   0x80E5
#define GL_COLOR_INDEX12_EXT                  0x80E6
#define GL_COLOR_INDEX16_EXT                  0x80E7
typedef void (APIENTRY * PFNGLCOLORTABLEEXTPROC)
    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLCOLORSUBTABLEEXTPROC)
    (GLenum target, GLsizei start, GLsizei count, GLenum format,
     GLenum type, GLvoid *data);
#endif

// texture resource

#define RT_RGB          99
#define RT_MYBMP        100
#define RT_A8           101

// texture resource types
enum {
    TEX_UNKNOWN = 0,
    TEX_RGB,
    TEX_BMP,
    TEX_A8
};

typedef struct {
    int     type;
    int     name;
} TEX_RES;

typedef struct _MATRIX {
    GLfloat M[4][4];
} MATRIX;

typedef struct strRGBA {
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
} RGBA;

typedef struct {
    BYTE r;
    BYTE g;
    BYTE b;
} RGB8;

typedef struct {
    BYTE r;
    BYTE g;
    BYTE b;
    BYTE a;
} RGBA8;

// Defines for pixel format (internal use)
#define SS_DOUBLEBUF_BIT    (1 << 0)
#define SS_DEPTH16_BIT      (1 << 1)
#define SS_DEPTH32_BIT      (1 << 2)
#define SS_ALPHA_BIT        (1 << 3)
#define SS_BITMAP_BIT       (1 << 4)
#define SS_NO_SYSTEM_PALETTE_BIT       (1 << 5)
#define SS_GENERIC_UNACCELERATED_BIT   (1 << 6)

#define SS_HAS_DOUBLEBUF(x) ((x) & SS_DOUBLEBUF_BIT)
#define SS_HAS_DEPTH16(x)	((x) & SS_DEPTH16_BIT)
#define SS_HAS_DEPTH32(x)	((x) & SS_DEPTH32_BIT)
#define SS_HAS_ALPHA(x)     ((x) & SS_ALPHA_BIT)
#define SS_HAS_BITMAP(x)    ((x) & SS_BITMAP_BIT)

typedef struct _MATERIAL {
    RGBA ka;
    RGBA kd;
    RGBA ks;
    GLfloat specExp;
} MATERIAL;

// texture file info

//mf: !!!, uhhh not yet
#if 1
typedef struct {
    int     nOffset;  // filename offset into pathname
    TCHAR   szPathName[MAX_PATH];  // texture pathname
} TEXFILE;
#else
typedef struct {
    int     nOffset;  // filename offset into pathname
    LPTSTR  szPathName;
} TEXFILE;
#endif

// Useful macros

#define SS_MAX( a, b ) \
    ( a > b ? a : b )

#define SS_MIN( a, b ) \
    ( a < b ? a : b )

// macro to round up floating values
#define SS_ROUND_UP( fval ) \
    ( (((fval) - (FLOAT)(int)(fval)) > 0.0f) ? (int) ((fval)+1.0f) : (int) (fval) )

// macros to clamp a value within a range
#define SS_CLAMP_TO_RANGE( a, lo, hi ) ( (a < lo) ? lo : ((a > hi) ? hi : a) )
#define SS_CLAMP_TO_RANGE2( a, lo, hi ) \
    ( a = (a < lo) ? lo : ((a > hi) ? hi : a) )

// degree<->radian macros
#define ONE_OVER_180 (1.0f / 180.0f)
#define SS_DEG_TO_RAD( a ) ( (a*PI) * ONE_OVER_180 )
#define SS_RAD_TO_DEG( a ) ( (a*180.0f) * ONE_OVER_PI )

// window related

extern void mtkQuit();  // Harsh way to kill the app
//extern int mtk_Exec();  // like tkExec()

// pixel forat

extern BOOL SSU_SetupPixelFormat( HDC hdc, int flags, PIXELFORMATDESCRIPTOR *ppfd );
extern BOOL SSU_bNeedPalette( PIXELFORMATDESCRIPTOR *ppfd );
extern int SSU_PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd );

// material processing

extern void ss_InitTeaMaterials();
extern void ss_InitTexMaterials();
extern void ss_InitMaterials();
extern void ss_SetMaterial( MATERIAL *pMat );
extern void ss_SetMaterialIndex( int index );
extern MATERIAL *ss_RandomTeaMaterial( BOOL bSet );
extern int  ss_RandomTeaMaterialIndex( BOOL bSet );
extern MATERIAL *ss_RandomTexMaterial( BOOL bSet );
extern int  ss_RandomTexMaterialIndex( BOOL bSet );
extern void ss_CreateMaterialGradient( MATERIAL *matInc, MATERIAL *startMat,
                        MATERIAL *endMat, int transCount );
extern void ss_TransitionMaterial( MATERIAL *transMat, MATERIAL *transMatInc );

// color

extern void ss_HsvToRgb(float h, float s, float v, RGBA *color );

// clear

extern int mtk_RectWipeClear( int width, int height, int repCount );
extern int mtk_DigitalDissolveClear( int width, int height, int size );

// utility

extern void ss_RandInit( void );
extern int ss_iRand( int max );
extern int ss_iRand2( int min, int max );
extern FLOAT ss_fRand( FLOAT min, FLOAT max );
extern BOOL mtk_ChangeDisplaySettings( int width, int height, int bitDepth );
extern void mtk_RestoreDisplaySettings();
extern void ss_QueryDisplaySettings( void );
extern void mtk_QueryGLVersion( void );
extern BOOL mtk_fOnWin95( void );
extern BOOL mtk_fOnNT35( void );
extern BOOL mtk_fOnGL11( void );
extern BOOL mtk_bAddSwapHintRect();
extern HBITMAP
SSDIB_CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight,
                    PVOID *ppvBits);
extern BOOL APIENTRY SSDIB_UpdateColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal);


// texture file processing

extern BOOL mtk_VerifyTextureFilePath( TEXFILE *ptf );
extern BOOL mtk_VerifyTextureFileData( TEXFILE *ptf );
extern void mtk_InitAutoTexture( TEX_POINT2D *pTexRep );

// texture objects

extern BOOL mtk_TextureObjectsEnabled( void );

// Paletted texture support
extern BOOL mtk_PalettedTextureEnabled(void);
extern BOOL mtk_QueryPalettedTextureEXT(void);

// math functions

extern POINT3D ss_ptZero;
extern void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void ss_matrixIdent(MATRIX *);
extern void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta);
extern void ss_matrixTranslate(MATRIX *, double xTrans, double yTrans, double zTrans);
extern void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 );
extern void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3);
extern void mtk_NormalizePoints(POINT3D *, ULONG);

#ifdef __cplusplus
}
#endif

#endif // __mtk_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\mtkinit.cxx ===
/******************************Module*Header*******************************\
* Module Name: mtkinit.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>

#include "mtk.hxx"
#include "mtkwin.hxx"
#include "mtkwproc.hxx"
#include "mtkinit.hxx"

SS_PAL  *gpssPal = NULL;
HBRUSH  ghbrbg = (HBRUSH) 0; // global handle to background brush
HCURSOR ghArrowCursor;
BOOL    gbMessageLoopStarted = FALSE;
MTKWIN  *gpMtkwinMain = NULL; // 'main' or root window

// Global strings.
#define GEN_STRING_SIZE 64

// This windows class stuff bites
// These 2 aren't used for now, they might be templates for later
LPCTSTR pszMainWindowClass = TEXT("MtkMainClass");  // main class name
LPCTSTR pszUserWindowClass = TEXT("MtkUserClass");  // user class name

static TCHAR szClassName[5] = TEXT("0001" );
static LPTSTR pszCurClass = szClassName;

// forward declarations of internal fns

/**************************************************************************\
* GLDoScreenSave
*
* Runs the screen saver in the specified mode
*
* GL version of DoScreenSave in scrnsave.c
*
* Does basic init, creates initial set of windows, and starts the message
* loop, which runs until terminated by some event.
*
\**************************************************************************/

// Called by every window on creation

BOOL
mtk_Init( MTKWIN *pMtkwin )
{
    static BOOL bInited = FALSE;

    if( bInited )
        return TRUE;

    // Set root window

// !!! ATTENTION !!! this mechanism will fail when a thread destroys all windows,
// and then creates more
// -> use reference count in sswtable

    gpMtkwinMain = pMtkwin;

    // Initialize randomizer
    ss_RandInit();

    // Various globals
    gpssPal = NULL;

    // Create multi-purpose black bg brush
    ghbrbg = (HBRUSH) GetStockObject( BLACK_BRUSH );

    // For now (no ss) cursor is arrow
    ghArrowCursor = LoadCursor( NULL, IDC_ARROW );

    bInited = TRUE;
    return TRUE;
}

/**************************************************************************\
* mtk_RegisterClass
*
\**************************************************************************/

LPTSTR
mtk_RegisterClass( WNDPROC wndProc, LPTSTR pszClass, HBRUSH hbrBg, HCURSOR hCursor )
{
    WNDCLASS cls;
    LPTSTR pszTheClass;

    // If no class name provided, make one by pre-incrementing the current
    // class name.  (Can't icrement at end of function, since class used must
    // match return value

    if( !pszClass ) {
        pszCurClass[0] += 1;
        pszTheClass = pszCurClass;
    } else {
        pszTheClass = pszClass;
    }

    cls.style = CS_VREDRAW | CS_HREDRAW;
    cls.lpfnWndProc = wndProc;
    cls.cbClsExtra = 0;
    cls.cbWndExtra = 0;
    cls.hInstance = GetModuleHandle( NULL );
    cls.hIcon = LoadIcon( NULL, IDI_APPLICATION );
    cls.hCursor = hCursor;
    cls.hbrBackground = hbrBg;
    cls.lpszMenuName = (LPTSTR)NULL;
    cls.lpszClassName = pszTheClass;

    if( ! RegisterClass(&cls) )
        return NULL;

    return pszTheClass;
}

#if 0
/**************************************************************************\
* CloseWindows
*
* Close down any open windows.
*
* This sends a WM_CLOSE message to the top-level window if it is still open.  If
* the window has any children, they are also closed.  For each window, the
* SSW destructor is called.
\**************************************************************************/

void
SCRNSAVE::CloseWindows()
{
    if( psswMain ) {
        if( psswMain->bOwnWindow )
            DestroyWindow( psswMain->hwnd );
        else
            delete psswMain;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\mtkwin.cxx ===
/******************************Module*Header*******************************\
* Module Name: mtkwin.cxx
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include "mtk.hxx"
#include "glutil.hxx"
#include "mtkwin.hxx"
#include "mtkwproc.hxx"
#include "mtkinit.hxx"

/**************************************************************************\
* MTKWIN constructor
*
\**************************************************************************/

MTKWIN::MTKWIN()
{
    Reset();
}

/**************************************************************************\
* Reset
*
* Reset parameters to default init state
\**************************************************************************/

void
MTKWIN::Reset()
{
    // Basic initialization

    bOwnWindow = FALSE;
    wFlags = 0;
    hwnd = 0;
    hdc = 0;
    hrc = 0;
    pos.x = pos.y = 0;
    size.width = size.height = 0;
    pBackBitmap =   NULL;
    pBackgroundBitmap =   NULL;
    bDoubleBuf =    FALSE;
    bFullScreen =   FALSE;
    execRefCount =  0;

    ReshapeFunc =   NULL;
    RepaintFunc =   NULL;
    DisplayFunc =   NULL;
    MouseMoveFunc = NULL;
    MouseDownFunc = NULL;
    MouseUpFunc =   NULL;
    KeyDownFunc =   NULL;

    FinishFunc =    NULL;
    DataPtr =       NULL;
}

/**************************************************************************\
* MTKWIN destructor
*
* This can be called when a window is closed, or by the ss client
*
\**************************************************************************/

MTKWIN::~MTKWIN()
{
//mf: !!! we're in trouble if user calls this directly, because would then need to
// post a DESTROY msg, here putting us in an endless loop...
// -> could have a flag set so we know if user or internal call

//mf: another potential timing problem here : If user calls MTKWIN::Return(),
// which posts an MTK_WM_RETURN msg to the windows queue, and then calls here
// before the msg is processed, we could delete the MTKWIN here before exiting
// the msg loop.  So here we should make sure the msg loop is exited by
// calling Return() or something.  This should be easy to verify via a
// reference count

    if( execRefCount ) {
        SS_ERROR1( "MTKWIN::~MTKWIN : execRefCount is %d\n", execRefCount );
        // mf: ? can we exit the msg loop here ?
//mf: this din't get through
#if 1
        SendMessage( hwnd, MTK_WM_RETURN, 0, 0l );
#else
        if( ! PostMessage( hwnd, MTK_WM_RETURN, 0, 0l ) )
            SS_ERROR( "MTKWIN dtor : MTK_WM_RETURN msg not posted\n" );
#endif
        
    }

    if( pBackBitmap )
        delete pBackBitmap;

    if( pBackgroundBitmap )
        delete pBackgroundBitmap;

    if( hwnd ) {
        animator.Stop();
        // Remove from SSWTable
        sswTable.Remove( hwnd );
    }

    // Clean up GL

//mf: !!!
//mf: This assumes FinishFunc is only related to gl
    if( hrc ) {
        // FinishFunc still needs gl
        if( FinishFunc )
#if 0
            (*FinishFunc)( DataPtr );
#else
            (*FinishFunc)();
#endif

        wglMakeCurrent( NULL, NULL );
        if( ! (wFlags & SS_HRC_PROXY_BIT) )
            wglDeleteContext( hrc );
    }

    //  Release the dc
    if( hdc ) {
        HWND hwndForHdc = hwnd;
        ReleaseDC(hwndForHdc, hdc);
    }
}

/**************************************************************************\
* Create
*
* Create window.
*
\**************************************************************************/

BOOL
MTKWIN::Create( LPCTSTR pszWindowTitle, ISIZE *pSize, IPOINT2D *pPos,
                UINT winConfig, WNDPROC userWndProc )
{
    HWND    hwndParent;
    UINT    uStyle = 0;
    UINT    uExStyle = 0;
    HINSTANCE  hInstance;
    int     width, height;

    if( ! mtk_Init( this ) )
        return FALSE;
    
    bOwnWindow = TRUE; // We're creating the window, it's not a wrapper

    if( winConfig & MTK_FULLSCREEN ) {
//mf: this really only valid if no border
        bFullScreen = TRUE;
        pos.x = 0;
        pos.y = 0;
        size.width = GetSystemMetrics( SM_CXSCREEN );
        size.height = GetSystemMetrics( SM_CYSCREEN );
        uExStyle |= WS_EX_TOPMOST;
    } else {
        pos = *pPos;
        size = *pSize;
    }

    LPCTSTR pszClass;
    HBRUSH hBrush = ghbrbg;
    HCURSOR hCursor = ghArrowCursor;
    WNDPROC wndProc;

    if( bTransparent = (winConfig & MTK_TRANSPARENT) ) {
        uExStyle |= WS_EX_TRANSPARENT;
        hBrush = NULL;
    }

//mf: if winsize, winpos NULL, pick default size, pos
    if( winConfig & MTK_NOBORDER ) {
        uStyle |= WS_POPUP;
        width = size.width;
        height = size.height;
    } else {
        uStyle |= WS_OVERLAPPEDWINDOW;
        /*
         *  Make window large enough to hold a client area of requested size
         */
        RECT WinRect;

//mf: either of these should work
#if 0
        WinRect.left   = 0;
        WinRect.right  = size.width;
        WinRect.top    = 0;
        WinRect.bottom = size.height;
#else
        WinRect.left   = pos.x;
        WinRect.right  = pos.x + size.width;
        WinRect.top    = pos.y;
        WinRect.bottom = pos.y + size.height;
#endif

        AdjustWindowRectEx(&WinRect, uStyle, FALSE, uExStyle );
        width = WinRect.right - WinRect.left;
        height = WinRect.bottom - WinRect.top;
    }

    if( winConfig & MTK_NOCURSOR )
        hCursor = NULL;

    if( userWndProc )
        wndProc = userWndProc;
    else
        wndProc = mtkWndProc;

    // Register window class
    pszClass = mtk_RegisterClass( wndProc, NULL, hBrush, hCursor );

    hInstance = GetModuleHandle( NULL );
    hwndParent = NULL; // for now
    
    hwnd = CreateWindowEx(
                                 uExStyle,
                                 pszClass,
                                 pszWindowTitle,
                                 uStyle,
                                 pos.x,
                                 pos.y,
                                 width,
                                 height,
                                 hwndParent,
                                 NULL,               // menu
                                 hInstance,
                                 (LPVOID) this
                                );

    if (!hwnd) {
        SS_WARNING( "SSW::CreateSSWindow : CreateWindowEx failure\n" );
        return FALSE;
    }

    if( bTransparent ) {
        // Create a bitmap buffer that tracks the window size.  This will be
        // used to store a window background.
        ConfigureForGdi();
        pBackgroundBitmap = new MTKBMP( hdc );
        if( !pBackgroundBitmap ) {
            SS_WARNING( "MTKWIN::Create: couldn't create background bitmap\n" );
        } else {
            // Set bitmap's size to the window's size
            pBackgroundBitmap->Resize( &size );
        }
    }

    animator.SetHwnd( hwnd );

    ShowWindow(hwnd, SW_SHOW);

    return TRUE;
}

/**************************************************************************\
* ConfigureForGdi
*
* Creates an hdc for the window
*
\**************************************************************************/

BOOL
MTKWIN::ConfigureForGdi()
{
    if( hdc )
        // already configured
        return TRUE;

    // Figure window to get hdc from
#if 0
    HWND hwndForHdc = hwnd ? hwnd : psswParent ? psswParent->hwnd : NULL;
#else
    HWND hwndForHdc = hwnd;
#endif

    if( !hwndForHdc || !(hdc = GetDC(hwndForHdc)) ) {
        SS_WARNING( "SSW::ConfigureForGdi failed\n" );
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************\
* ConfigureForGL
*
* Creates a GL rendering context for the specified window
*
\**************************************************************************/

BOOL
MTKWIN::Config( UINT glConfig )
{
    return Config( glConfig, NULL );
}

BOOL
MTKWIN::Config( UINT glConfig, PVOID pConfigData )
{
    if( hrc )
        // Already configured...
        return TRUE;

    if( ConfigureForGdi() &&
        (hrc = hrcSetupGL( glConfig, pConfigData )) )
        return TRUE;

    SS_WARNING( "SSW::ConfigureForGL failed\n" );
    return FALSE;
}

/**************************************************************************\
* hrcSetupGL
*
* Setup OpenGL.
*
\**************************************************************************/

#define NULL_RC ((HGLRC) 0)

HGLRC 
MTKWIN::hrcSetupGL( UINT glConfig, PVOID pData )
{
    HGLRC hrc;
    HDC hgldc;
    int pfFlags = 0;
    PIXELFORMATDESCRIPTOR pfd = {0};

    // Setup pixel format flags

    // Double buffering can either be done with a double-buffered pixel
    // format, or by using a local back buffer bitmap that tracks the window
    // size.  The latter allows us more control with buffer swaps.

    bDoubleBuf = glConfig & MTK_DOUBLE;
    BOOL bBitmapBackBuf = glConfig & MTK_BITMAP;
    if( bDoubleBuf ) {
        if( bBitmapBackBuf ) 
            pfFlags |= SS_BITMAP_BIT;
        else
            pfFlags |= SS_DOUBLEBUF_BIT;
    }
    if( glConfig & MTK_DEPTH )
        pfFlags |= SS_DEPTH32_BIT;
    if( glConfig & MTK_DEPTH16 )
        pfFlags |= SS_DEPTH16_BIT;
    if( glConfig & MTK_ALPHA )
        pfFlags |= SS_ALPHA_BIT;
    

    // If preview mode or config mode, don't allow pixel formats that need
    // the system palette, as this will create much ugliness.
    if( !bFullScreen )
        pfFlags |= SS_NO_SYSTEM_PALETTE_BIT;

//mf: don't really need pixel format for window if using back bitmap method,
// but if user wants to draw to front buffer, then we'll need it.  So, we'll
// always set it here.
    if( !SSU_SetupPixelFormat( hdc, pfFlags, &pfd ) )
        return NULL_RC;

//mf: ???
    // Update pfFlags based on pfd returned
    // !!! mf: klugey, fix after SUR
    // (for now, the only ones we care about are the generic/accelerated flags)
    if(  (pfd.dwFlags & (PFD_GENERIC_FORMAT|PFD_GENERIC_ACCELERATED))
		 == PFD_GENERIC_FORMAT )
        pfFlags |= SS_GENERIC_UNACCELERATED_BIT;

    if( SSU_bNeedPalette( &pfd ) ) {
        // Note: even if bStretch, need to set up palette here so they match
        if( !gpssPal ) {
            SS_PAL *pssPal;
#if 1
            BOOL bTakeOverPalette = bFullScreen ? TRUE : FALSE;
#else
//mf: For next rev, we don't have to force palette takeover - but it will
// automically be invoked for any case like MCD, etc.
            BOOL bTakeOverPalette = FALSE;
#endif

            // The global palette has not been created yet - do it
            // SS_PAL creation requires pixel format descriptor for color bit
            // information, etc. (the pfd is cached in SS_PAL, since for
            // palette purposes it is the same for all windows)
            pssPal = new SS_PAL( hdc, &pfd, bTakeOverPalette );
            if( !pssPal )
                return NULL_RC;
            // Set approppriate palette manage proc
            if( bFullScreen )
                pssPal->paletteManageProc = FullScreenPaletteManageProc;
            else
                // use regular palette manager proc
                pssPal->paletteManageProc = PaletteManageProc;
            gpssPal = pssPal;
        }
        // Realize the global palette in this window
        //mf: assume we're realizing in foreground
        HWND hwndPal = hwnd;
        if( hwndPal )
            gpssPal->Realize( hwndPal, hdc, FALSE );
    }

    if( bBitmapBackBuf ) {
        pBackBitmap = new MTKBMP( hdc );
        if( !pBackBitmap ) {
            SS_WARNING( "MTKWIN::hrcSetupGL : couldn't create back bitmap\n" );
            return NULL_RC;
        }
        // Set bitmap's size to the window's size
        pBackBitmap->Resize( &size );
        hgldc = pBackBitmap->hdc;
        // Setup pixelformat
        if( !SSU_SetupPixelFormat( hgldc, pfFlags, &pfd ) )
            return NULL_RC;
        // If window needed a palette, so does the bitmap...
        if( gpssPal )
            SSDIB_UpdateColorTable( hgldc, hdc, gpssPal->hPal );
    } else {
        hgldc = hdc;
    }

    // Create a new hrc
    hrc = wglCreateContext(hgldc);

    if( !hrc || !wglMakeCurrent(hgldc, hrc) ) {
        SS_WARNING( "SSW::hrcSetupGL : hrc context failure\n" );
        return NULL_RC;
    }

    SS_DBGLEVEL2( SS_LEVEL_INFO, 
        "SSW::hrcSetupGL: wglMakeCurrent( hrc=0x%x, hwnd=0x%x )\n", hrc, hwnd );

//mf: Note that these queries are based on a single gl window screen saver.  In
// a more complicated scenario, these capabilities could be queried on a
// per-window basis (since support could vary with pixel formats).

    gGLCaps.Query();

    // Send another reshape msg to the app, since the first one on window
    // create would have been sent before we had an rc
    Reshape();

    return hrc;
}

/**************************************************************************\
* MakeCurrent
*
* Call wglMakeCurrent for this window's hrc.  Note: an ss client may have
* more than one hrc (e.g. pipes), in which case it is the client's
* responsibility to make current.
\**************************************************************************/

void
MTKWIN::MakeCurrent()
{
    if( ! wglMakeCurrent( hdc, hrc ) )
        SS_WARNING( "SSW::MakeCurrent : wglMakeCurrent failure\n" );
}

// Callback functions:

/******************************Public*Routine******************************\
* ss_ReshapeFunc
*
\**************************************************************************/

void 
MTKWIN::SetReshapeFunc(MTK_RESHAPEPROC Func)
{
    ReshapeFunc = Func;
}

/******************************Public*Routine******************************\
* ss_RepaintFunc
*
\**************************************************************************/

void 
MTKWIN::SetRepaintFunc(MTK_REPAINTPROC Func)
{
    RepaintFunc = Func;
}

void 
MTKWIN::SetDisplayFunc(MTK_DISPLAYPROC Func)
{
    DisplayFunc = Func;
}

/******************************Public*Routine******************************\
* SetAnimateFunc
*
\**************************************************************************/

void 
MTKWIN::SetAnimateFunc(MTK_ANIMATEPROC Func )
{
    animator.SetFunc( Func );
    // If we are in msg loop and Func is non-NULL, have to make sure 
    // animator starts again... (awkward).  If animator was already started,
    // this will do nothing
    if( execRefCount && Func )
        animator.Start();
}

/******************************Public*Routine******************************\
* Animate
*
* Call the animation function
*
* If animate mode is interval (as opposed to continuous),
* animate the number of supplied frames.  The animation count is decremented
* by the WndProc processing the WM_TIMER messages.  Exits the msg loop when
* the desired number fo frames has been animated.
*
\**************************************************************************/

//mf: had to rename from Animate to mtkAnimate due to name conflicts at link
// time

void
MTKWIN::mtkAnimate()
{
    if( ! animator.Draw() )
        Return();
}


/******************************Public*Routine******************************\
* SetAnimateMode
*
*
\**************************************************************************/

void
MTKWIN::SetAnimateMode( UINT mode, float *fParam )
{
    animator.SetMode( mode, fParam );
}

/******************************Public*Routine******************************\
* Exec
*
* Starts the message loop for the window.
*
* If an animation has been requested prior to this call, then a new animation
* timer is setup.  This msg loop can terminate in the following ways :
*   1) The window is closed
*   2) An interval animation was requested, and the required number of frames
*      have been drawn
*   3) The user calls MTKWIN::Return(), which will cause the MTKWIN::Exec()
*      call to return
*
* For now :
* Returns TRUE on normal termination, FALSE if the window it's animating in
* gets closed.
*
\**************************************************************************/

BOOL
MTKWIN::Exec()
{
    // If user is already in here, get out
    if( execRefCount )
        return TRUE;
    execRefCount++;

    // Stop any existing timer (this will flush WM_TIMER msg's)
    animator.Stop();

    // Start new animation timer (if animator modes are set)
    animator.Start();

    MSG msg;
    BOOL bNotQuitMsg;
    while( bNotQuitMsg = GetMessage( &msg, hwnd, 0, 0 ) )
    {
        if( msg.message == MTK_WM_RETURN ) {
            // User or mtk wants to terminate msg loop and return control
            // (mf: could pick up return parameter here...)
//            SS_DBGPRINT1( "MTKWIN::Exec got WM_RETURN for %p\n", this );
            break;
        }
//mf: ? better way of doing this ?
        else if( ! msg.hwnd ) {
            // Window has been destroyed, get out !
            SS_DBGPRINT( "MTKWIN::Exec : hwnd = 0, forcing msg loop exit\n" );
            return FALSE;
        }
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

    animator.Stop();

    execRefCount--;

    if( bNotQuitMsg )
        return TRUE;
    else {
        SS_DBGPRINT1( "MTKWIN::Exec got WM_QUIT for %p\n", this );
        return FALSE;
    }
}

/******************************Public*Routine******************************\
* Return
*
* Called by the user when they want to return from the Exec() call which
* started the message loop.
*
* mf: could include parameter here
*
\**************************************************************************/

void
MTKWIN::Return() 
{
    animator.Stop();
    PostMessage( hwnd, MTK_WM_RETURN, 0, 0l );
}

void 
MTKWIN::SetMouseMoveFunc(MTK_MOUSEMOVEPROC Func)
{
    MouseMoveFunc = Func;
}

void 
MTKWIN::SetMouseUpFunc(MTK_MOUSEUPPROC Func)
{
    MouseUpFunc = Func;
}

void 
MTKWIN::SetMouseDownFunc(MTK_MOUSEDOWNPROC Func)
{
    MouseDownFunc = Func;
}

void 
MTKWIN::SetKeyDownFunc(MTK_KEYDOWNPROC Func)
{
    KeyDownFunc = Func;
}

void 
MTKWIN::GetMouseLoc( int *x, int *y )
{
    POINT Point;

    *x = 0;
    *y = 0;

    GetCursorPos(&Point);

    /*
     *  GetCursorPos returns screen coordinates,
     *  we want window coordinates
     */

    *x = Point.x - pos.x;
    *y = Point.y - pos.y;
}

void
MTKWIN::Close()
{
    DestroyWindow( hwnd );
}

/******************************Public*Routine******************************\
* ss_FinishFunc
*
\**************************************************************************/

void 
MTKWIN::SetFinishFunc(MTK_FINISHPROC Func)
{
    FinishFunc = Func;
}

/**************************************************************************\
* Resize
*
* Resize wrapper
*
* Called in response to WM_SIZE.
*
\**************************************************************************/

void
MTKWIN::Resize( int width, int height )
{
    size.width  = width;
    size.height = height;

    if( pBackBitmap )
        pBackBitmap->Resize( &size );
    if( pBackgroundBitmap )
        pBackgroundBitmap->Resize( &size );
    Reshape();
}

/**************************************************************************\
* Repaint
*
* Repaint wrapper
*
* Called in response to WM_PAINT.
*
\**************************************************************************/

#define NULL_UPDATE_RECT( pRect ) \
     (  ((pRect)->left == 0) && \
        ((pRect)->right == 0) && \
        ((pRect)->top == 0) && \
        ((pRect)->bottom == 0) )

void
MTKWIN::Repaint( BOOL bCheckUpdateRect )
{
    if( !hwnd )
        return;

    RECT rect, *pRect = NULL;

    if( bCheckUpdateRect ) {
        GetUpdateRect( hwnd, &rect, FALSE );
//mf
    SS_DBGPRINT4( "MTKWIN::Repaint rect: %d - %d, %d - %d\n", rect.left, rect.right,
                   rect.top, rect.bottom );
        // mf: Above supposed to return NULL if rect is all 0's, 
        // but this doesn't happen
        if( NULL_UPDATE_RECT( &rect ) )
            return;
        pRect = &rect;
    }

    // transparent window thing
    if( pBackgroundBitmap ) {
        if( !pRect ) {
            // UpdateBg doesn't handle null rect
            pRect = &rect;
            GetClientRect( hwnd, pRect );
        }
        UpdateBackgroundBitmap( pRect );
    }

#if 0
    if( RepaintFunc )
        (*RepaintFunc)( pRect );
#else
#if 0
    Display();
#else
//mf: test: ? help bg update problem ?? nope, din't seem to...
    MSG Message;
    if (!PeekMessage(&Message, hwnd, MTK_WM_REDRAW, MTK_WM_REDRAW, PM_NOREMOVE) )
    {
        PostMessage( hwnd, MTK_WM_REDRAW, 0, 0l );
    }
#endif
#endif
}

void
MTKWIN::Display()
{
    if( DisplayFunc )
        (*DisplayFunc)();
}

//mf: not using these in current scheme, although might if use 'ss' mode
#if 0
/**************************************************************************\
* UpdateWindow
*
* Update the window
*
* Currently this assumes all windows are being animated (i.e. not showing
*   a static image)
*
* Things *must* happen in the order defined here, so they work on generic as
* well as hardware implementations.
* Note: Move must happen after SwapBuf, and will cause some encroaching on
* the current display, as the parent window repaints after the move.  Therefore
* apps must take care to leave an empty border around their rendered image,
* equal to the maximum window move delta.
*
\**************************************************************************/

void
MTKWIN::UpdateWindow()
{ 
    if( !AnimateFunc )
        return;

    // bDoubleBuf and pStretch should be mutually exclusive...

    if( bDoubleBuf ) {
        UpdateDoubleBufWin();
    } else {
//mf: ? where's the clearing here ?  (true, no one uses this path...)
#if 0
        (*AnimateFunc)( DataPtr );
#else
        (*AnimateFunc)();
#endif
    }
}

/**************************************************************************\
* UpdateDoubleBufWin
*
* This is used when moving a double buffered window around.  It will
* work for all configurations.
*
\**************************************************************************/

void
MTKWIN::UpdateDoubleBufWin()
{ 
    RECT updateRect;

    // Update the back buffer

#if 0
    (*AnimateFunc)( DataPtr );
#else
    (*AnimateFunc)();
#endif

    // Swap to the new window position
    SwapBuffers( hdc );
}
#endif

/**************************************************************************\
* GetSSWindowRect
*
* Return window position and size in supplied RECT structure
*
* - This rect is relative to the parent
\**************************************************************************/

void
MTKWIN::GetSSWindowRect( LPRECT lpRect )
{
    lpRect->left = pos.x;
    lpRect->top = pos.y;
    lpRect->right = pos.x + size.width;
    lpRect->bottom = pos.y + size.height;
}

/**************************************************************************\
* GLPosY
*
* Return y-coord of window position in GL coordinates (a win32 window position
* (starts from top left, while GL starts from bottom left)
*
\**************************************************************************/

int
MTKWIN::GLPosY()
{
//mf: !!!
#if 0
    return psswParent->size.height - size.height - pos.y;
#else
    return 0;
#endif
}


/**************************************************************************\
* SwapBuffers
*
\**************************************************************************/

//mf: name problem...
void
MTKWIN::mtkSwapBuffers()
{
    if( bDoubleBuf ) {
        if( pBackBitmap )
            CopyBackBuffer();
        else
            SwapBuffers( hdc );
    }
}

/**************************************************************************\
*
*
\**************************************************************************/

void
MTKWIN::Flush()
{
    glFlush();
    if( bDoubleBuf ) {
        mtkSwapBuffers();
    }
}

/**************************************************************************\
* CopyBackBuffer
*
* Like SwapBuffers, but copies from local bitmap to front buffer
*
* Also capable of copying over 1 or more rects of the bitmap, rather than the
* whole thing. mf: Might need local implementation of swaphintrect here, to
* collect and reduce the rects
\**************************************************************************/

void
MTKWIN::CopyBackBuffer()
{
    if( !pBackBitmap )
        return;

    // Do a BitBlt from back buffer to the window (may as well put stretch in
    // here ?

    if( (size.width == pBackBitmap->size.width) &&
        (size.height == pBackBitmap->size.height) ) // buffers same size
    {
        BitBlt(hdc, 0, 0, size.width, size.height,
               pBackBitmap->hdc, 0, 0, SRCCOPY);
    }
    else
    {
        SS_WARNING( "MTKWIN::CopyBackBuffer: bitmap size mismatch\n" );
        StretchBlt(hdc, 0, 0, 
                   size.width, size.height,
                   pBackBitmap->hdc, 0, 0, 
                   pBackBitmap->size.width, pBackBitmap->size.height,
                   SRCCOPY);
    }
    GdiFlush();
}


/**************************************************************************\
* UpdateBackgroundBitmap
*
* Updates the background bitmap with screen bits
*
\**************************************************************************/

void
MTKWIN::UpdateBackgroundBitmap( RECT *pRect )
{
    if( !pBackgroundBitmap ) {
        SS_WARNING( "MTKWIN::UpdateBackgroundBitmap : No background bitmap\n" );
        return;
    }

//  mf:!!!  handle update rect parameter
    MTKBMP *pBmpDest = pBackgroundBitmap;

    // Get a screen DC
    HDC hdcScreen = GetDC( NULL );

#if DBG
    if( !hdcScreen ) {
        SS_WARNING( "MTKWIN::UpdateBackgroundBitmap : failed to get screen hdc\n" );
        return;
    }
#endif

//mf
#if 0
    SS_DBGPRINT4( "MTKWIN::UpdateBackgroundBitmap : %d - %d, %d - %d\n", pRect->left, pRect->right,
                   pRect->top, pRect->bottom );
#endif
    // Calc the screen origin of the window
    RECT screenRect = {0, 0 }; // just need left and top points
    MapWindowPoints( hwnd, NULL, (POINT *) &screenRect, 2 );

    // Offset screenRect with the supplied rect
    screenRect.left += pRect->left;
    screenRect.top += pRect->top;
    // Set update size
//mf: thought I should have to add 1 here, but I guess pRect is non-inclusive...
    ISIZE updateSize = { pRect->right - pRect->left,
                         pRect->bottom - pRect->top };

    if( (size.width == pBmpDest->size.width) &&
        (size.height == pBmpDest->size.height) ) // buffers same size
    {
        BitBlt(pBmpDest->hdc, 
               pRect->left, pRect->top, 
               updateSize.width, updateSize.height,
               hdcScreen, 
               screenRect.left, screenRect.top, SRCCOPY);
    }
    else
    {
#if 0
//mf: ignore this for now
        // Shouldn't happen, since BackgroundBitmap tracks window size
        StretchBlt(pBmpDest->hdc, 0, 0, 
                   pBmpDest->size.width, pBmpDest->size.height,
                   hdcScreen, screenRect.left, screenRect.top, 
                   size.width, size.height,
                   SRCCOPY);
#else
        SS_WARNING( "MTKWIN::UpdateBackgroundBitmap : bitmap size mismatch\n" );
#endif
    }
    GdiFlush();
}

/**************************************************************************\
* ClearToBackground
*
* Copy from the background bitmap to the window.  If the window is doublebuf,
* then we copy to the backbuffer instead of the window.
*
\**************************************************************************/

void
MTKWIN::ClearToBackground()
{
    if( !pBackgroundBitmap ) {
        SS_WARNING( "MTKWIN::ClearToBackgournd : No background bitmap\n" );
        return;
    }

    MTKBMP *pBmpSrc = pBackgroundBitmap;

    HDC hdcDest;
    if( bDoubleBuf ) {
        if( !pBackBitmap )
            return;
//mf: assumption here that backbitmap size is same as window
        hdcDest = pBackBitmap->hdc;
    } else
        hdcDest = hdc;

    if( (size.width == pBmpSrc->size.width) &&
        (size.height == pBmpSrc->size.height) ) // buffers same size
    {
        BitBlt(hdcDest, 0, 0, size.width, size.height,
               pBmpSrc->hdc, 0, 0, SRCCOPY);
    }
    else
    {
        StretchBlt(hdcDest, 0, 0, 
                   size.width, size.height,
                   pBmpSrc->hdc, 0, 0, 
                   pBmpSrc->size.width, pBmpSrc->size.height,
                   SRCCOPY);
    }
    GdiFlush();
}


/**************************************************************************\
* Reshape
*
* Reshape wrapper

* Sends reshape msg to screen saver
* This is the size of the surface that gl renders onto, which can be a bitmap.
*
\**************************************************************************/

void
MTKWIN::Reshape()
{
    // Point to size of window, or bitmap if it has one
    ISIZE *pSize = &size;

    // If the window has an hrc, set default viewport
//mf: so app doesn't have to worry about it ?

    if( hrc ) {
        glViewport( 0, 0, pSize->width, pSize->height );
    }

    if( ReshapeFunc ) {
#if 0
        (*ReshapeFunc)( pSize->width, pSize->height, DataPtr );
#else
        (*ReshapeFunc)( pSize->width, pSize->height );
#endif
    }
}

/******************************Public*Routine******************************\
* GdiClear
*
* Clears window using Gdi FillRect
\**************************************************************************/

void
MTKWIN::GdiClear()
{
    if( !hdc )
        return;

    RECT rect;

    GetClientRect( hwnd, &rect );

//mf: rect is exclusive, so shouldn't we have to add 1 ?
    FillRect( hdc, &rect, ghbrbg );
    GdiFlush();
}

//mf: unicode...
void
MTKWIN::SetTitle( char *title )
{
    SetWindowText( hwnd, title );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\texbmp.cxx ===
/******************************Module*Header*******************************\
* Module Name: ssdib.c
*
* Operations on .bmp files
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> 

#include "mtk.h"
#include "texture.hxx"

#define BFT_BITMAP  0x4d42  // 'BM' -- indicates structure is BITMAPFILEHEADER

// struct BITMAPFILEHEADER {
//      WORD  bfType
//      DWORD bfSize
//      WORD  bfReserved1
//      WORD  bfReserved2
//      DWORD bfOffBits
// }
#define OFFSET_bfType       0
#define OFFSET_bfSize       2
#define OFFSET_bfReserved1  6
#define OFFSET_bfReserved2  8
#define OFFSET_bfOffBits    10
#define SIZEOF_BITMAPFILEHEADER 14

// Read a WORD-aligned DWORD.  Needed because BITMAPFILEHEADER has
// WORD-alignment.
#define READDWORD(pv)   ( (DWORD)((PWORD)(pv))[0]               \
                          | ((DWORD)((PWORD)(pv))[1] << 16) )   \

// Computes the number of BYTES needed to contain n number of bits.
#define BITS2BYTES(n)   ( ((n) + 7) >> 3 )

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DibNumColors(VOID FAR * pv)                                *
 *                                                                          *
 *  PURPOSE    : Determines the number of colors in the DIB by looking at   *
 *               the BitCount filed in the info block.                      *
 *                                                                          *
 *  RETURNS    : The number of colors in the DIB.                           *
 *                                                                          *
 * Stolen from SDK ShowDIB example.                                         *
 ****************************************************************************/

static WORD DibNumColors(VOID FAR * pv)
{
    WORD                bits;
    BITMAPINFOHEADER UNALIGNED *lpbi;
    BITMAPCOREHEADER UNALIGNED *lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     *
     *  Because of the way we use this call, BITMAPINFOHEADER may be out
     *  of alignment if it follows a BITMAPFILEHEADER.  So use the macro
     *  to safely access DWORD fields.
     */
    if (READDWORD(&lpbi->biSize) != sizeof(BITMAPCOREHEADER)){
        if (READDWORD(&lpbi->biClrUsed) != 0)
        {
            return (WORD) READDWORD(&lpbi->biClrUsed);
        }
        bits = lpbi->biBitCount;
    }
    else
        bits = lpbc->bcBitCount;

    switch (bits){
        case 1:
            return 2;
        case 4:
            return 16;
        case 8:
            return 256;
        default:
            /* A 24 bitcount DIB has no color table */
            return 0;
    }
}

static PBYTE PackTexImage( BITMAPINFOHEADER *pbmih, PBYTE pjSrc )
{
// Note the malloc used here, for consistency with tk (app may use free() on it)
//mf: can change to overwrite pjSrc, instead of allocating new memomory, once
// no longer using TEX_BMP resource or old way of reading .bmp files
    PBYTE pjTKBits = (PBYTE) malloc(pbmih->biSizeImage);
    if( !pjTKBits )
    {
        return NULL;
    }

    PBYTE pjDst = pjTKBits;

    // src lines end on LONG boundary - so need to skip over any padding bytes

    int padBytes = pbmih->biWidth % sizeof(LONG);
    
    int rowSize = pbmih->biWidth * sizeof(RGB8);
    if( !padBytes ) {
        RtlCopyMemory( pjDst, pjSrc, pbmih->biHeight * rowSize );
    } else {
        for (int i = 0; i < pbmih->biHeight; i++ )
        {
            RtlCopyMemory( pjDst, pjSrc, rowSize );
            pjDst += rowSize;
            pjSrc += (rowSize + padBytes );
        }
    }
    return pjTKBits; // to be free'd by the caller
}

/******************************Public*Routine******************************\
* ss_DIBImageLoad
*
* Hacked form of tk_DIBImageLoad(), for reading a .bmp file from a resource
*
* Loads a DIB file (specified as either an ANSI or Unicode filename,
* depending on the bUnicode flag) and converts it into a TK image format.
*
* The technique used is based on CreateDIBSection and SetDIBits.
* CreateDIBSection is used to create a DIB with a format easily converted
* into the TK image format (packed 24BPP RGB).  The only conversion 
* required is swapping R and B in each RGB triplet (see history below)
* The resulting bitmap is selected into a memory DC.
*
* The DIB file is mapped into memory and SetDIBits called to initialize
* the memory DC bitmap.  It is during this step that GDI converts the
* arbitrary DIB file format to RGB format.
*
* Finally, the RGB data in the DIB section is read out and repacked
* as 24BPP 'BGR'.
*
* Returns:
*   BOOL. 
*
* History:
*   - 11/30/95: [marcfo]
*     Modified from tkDIBImageLoad, to work on resource bmp file.
*     At first I tried accessing the bitmap resource as an RT_BITMAP, where
*     the resource compiler strips out file information, and leaves you simple
*     bitmap data.  But this only worked on the Alpha architecture, x86
*     produced a resource with corrupted image data (?palette :)).  So I ended
*     up just slamming the entire .bmp file in as a resource.
*
\**************************************************************************/

#if 0
//mf: this is no longer needed, since bitmaps are always 'BITMAP' resources now.
BOOL 
TEXTURE::DIBImageLoad(PVOID pv )
{
    BOOL             fSuccess = FALSE;
    WORD             wNumColors;    // Number of colors in color table
    BITMAPFILEHEADER *pbmf;         // Ptr to file header
    BITMAPINFOHEADER UNALIGNED *pbmihFile;
    BITMAPCOREHEADER UNALIGNED *pbmchFile; // Ptr to file's core header (if it exists)
    PVOID            pvBits;    // Ptr to bitmap bits in file
    PBYTE            pjBitsRGB;     // Ptr to 24BPP RGB image in DIB section
    PBYTE            pjTKBits = (PBYTE) NULL;   // Ptr to final TK image bits

    // These need to be cleaned up when we exit:
    HDC        hdcMem = (HDC) NULL;                 // 24BPP mem DC
    HBITMAP    hbmRGB = (HBITMAP) NULL;             // 24BPP RGB bitmap
    BITMAPINFO *pbmiSource = (BITMAPINFO *) NULL;   // Ptr to source BITMAPINFO
    BITMAPINFO *pbmiRGB = (BITMAPINFO *) NULL;      // Ptr to file's BITMAPINFO
    int i;

// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER
// followed immediately with the color table and the bitmap bits.

    pbmf = (BITMAPFILEHEADER *) pv;

    if ( pbmf->bfType == BFT_BITMAP )
    {
        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER);

    // BITMAPFILEHEADER is WORD aligned, so use safe macro to read DWORD
    // bfOffBits field.

        pvBits = (PVOID *) ((PBYTE) pbmf
                                + READDWORD((PBYTE) pbmf + OFFSET_bfOffBits));
    }
    else
    {
        pbmihFile = (BITMAPINFOHEADER *) pv;

    // Determination of where the bitmaps bits are needs to wait until we
    // know for sure whether we have a BITMAPINFOHEADER or a BITMAPCOREHEADER.
    }

// Determine the number of colors in the DIB palette.  This is non-zero
// only for 8BPP or less.

    wNumColors = DibNumColors(pbmihFile);

// Create a BITMAPINFO (with color table) for the DIB file.  Because the
// file may not have one (BITMAPCORE case) and potential alignment problems,
// we will create a new one in memory we allocate.
//
// We distinguish between BITMAPINFO and BITMAPCORE cases based upon
// BITMAPINFOHEADER.biSize.

    pbmiSource = (BITMAPINFO *)
        LocalAlloc(LMEM_FIXED, sizeof(BITMAPINFO)
                               + wNumColors * sizeof(RGBQUAD));
    if (!pbmiSource)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    // Note: need to use safe READDWORD macro because pbmihFile may
    // have only WORD alignment if it follows a BITMAPFILEHEADER.

    switch (READDWORD(&pbmihFile->biSize))
    {
    case sizeof(BITMAPINFOHEADER):

    // Convert WORD-aligned BITMAPINFOHEADER to aligned BITMAPINFO.

        pbmiSource->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmiSource->bmiHeader.biWidth         = READDWORD(&pbmihFile->biWidth);
        pbmiSource->bmiHeader.biHeight        = READDWORD(&pbmihFile->biHeight);
        pbmiSource->bmiHeader.biPlanes        = pbmihFile->biPlanes;
        pbmiSource->bmiHeader.biBitCount      = pbmihFile->biBitCount;
        pbmiSource->bmiHeader.biCompression   = 
                                        READDWORD(&pbmihFile->biCompression);
        pbmiSource->bmiHeader.biSizeImage     = 
                                        READDWORD(&pbmihFile->biSizeImage);
        pbmiSource->bmiHeader.biXPelsPerMeter = 
                                        READDWORD(&pbmihFile->biXPelsPerMeter);
        pbmiSource->bmiHeader.biYPelsPerMeter = 
                                        READDWORD(&pbmihFile->biYPelsPerMeter);
        pbmiSource->bmiHeader.biClrUsed       = 
                                        READDWORD(&pbmihFile->biClrUsed);
        pbmiSource->bmiHeader.biClrImportant  = 
                                        READDWORD(&pbmihFile->biClrImportant);

    // Copy color table.  It immediately follows the BITMAPINFOHEADER.

        memcpy((PVOID) &pbmiSource->bmiColors[0], (PVOID) (pbmihFile + 1),
               wNumColors * sizeof(RGBQUAD));

    // If we haven't already determined the position of the image bits,
    // we may now assume that they immediately follow the color table.

        if (!pvBits)
            pvBits = (PVOID) ((PBYTE) (pbmihFile + 1)
                         + wNumColors * sizeof(RGBQUAD));
        break;

    case sizeof(BITMAPCOREHEADER):
        pbmchFile = (BITMAPCOREHEADER *) pbmihFile;

    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER.

        pbmiSource->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmiSource->bmiHeader.biWidth         = (DWORD) pbmchFile->bcWidth;
        pbmiSource->bmiHeader.biHeight        = (DWORD) pbmchFile->bcHeight;
        pbmiSource->bmiHeader.biPlanes        = pbmchFile->bcPlanes;
        pbmiSource->bmiHeader.biBitCount      = pbmchFile->bcBitCount;
        pbmiSource->bmiHeader.biCompression   = BI_RGB;
        pbmiSource->bmiHeader.biSizeImage     = 0;
        pbmiSource->bmiHeader.biXPelsPerMeter = 0;
        pbmiSource->bmiHeader.biYPelsPerMeter = 0;
        pbmiSource->bmiHeader.biClrUsed       = wNumColors;
        pbmiSource->bmiHeader.biClrImportant  = wNumColors;

    // Convert RGBTRIPLE color table into RGBQUAD color table.

        {
            RGBQUAD *rgb4 = pbmiSource->bmiColors;
            RGBTRIPLE *rgb3 = (RGBTRIPLE *) (pbmchFile + 1);

            for (i = 0; i < wNumColors; i++)
            {
                rgb4->rgbRed   = rgb3->rgbtRed  ;
                rgb4->rgbGreen = rgb3->rgbtGreen;
                rgb4->rgbBlue  = rgb3->rgbtBlue ;
                rgb4->rgbReserved = 0;

                rgb4++;
                rgb3++;
            }
        }

    // If we haven't already determined the position of the image bits,
    // we may now assume that they immediately follow the color table.

        if (!pvBits)
            pvBits = (PVOID) ((PBYTE) (pbmihFile + 1)
                         + wNumColors * sizeof(RGBTRIPLE));
        break;

    default:
        MESSAGEBOX(GetFocus(), "Unknown DIB file format.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Fill in default values (for fields that can have defaults).

    if (pbmiSource->bmiHeader.biSizeImage == 0)
        pbmiSource->bmiHeader.biSizeImage = 
            BITS2BYTES( (DWORD) pbmiSource->bmiHeader.biWidth * 
                                pbmiSource->bmiHeader.biBitCount ) * 
                                pbmiSource->bmiHeader.biHeight;
    if (pbmiSource->bmiHeader.biClrUsed == 0)
        pbmiSource->bmiHeader.biClrUsed = wNumColors;

// Create memory DC.

    hdcMem = CreateCompatibleDC(NULL);
    if (!hdcMem) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Create a 24BPP RGB DIB section and select it into the memory DC.

    pbmiRGB = (BITMAPINFO *)
              LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(BITMAPINFO) );
    if (!pbmiRGB)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    pbmiRGB->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmiRGB->bmiHeader.biWidth         = pbmiSource->bmiHeader.biWidth;
    pbmiRGB->bmiHeader.biHeight        = pbmiSource->bmiHeader.biHeight;
    pbmiRGB->bmiHeader.biPlanes        = 1;
    pbmiRGB->bmiHeader.biBitCount      = 24;
    pbmiRGB->bmiHeader.biCompression   = BI_RGB;
    pbmiRGB->bmiHeader.biSizeImage     = pbmiRGB->bmiHeader.biWidth
                                         * abs(pbmiRGB->bmiHeader.biHeight) * 3;

    hbmRGB = CreateDIBSection(hdcMem, pbmiRGB, DIB_RGB_COLORS, 
                              (PVOID *) &pjBitsRGB, NULL, 0);

    if (!hbmRGB)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); 
        goto tkDIBLoadImage_cleanup;
    }

    if (!SelectObject(hdcMem, hbmRGB))
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Slam the DIB file image into the memory DC.  GDI will do the work of
// translating whatever format the DIB file has into RGB format.

    if (!SetDIBits(hdcMem, hbmRGB, 0, pbmiSource->bmiHeader.biHeight, 
                   pvBits, pbmiSource, DIB_RGB_COLORS))
    {
        MESSAGEBOX(GetFocus(), "Image file conversion error.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }
    GdiFlush();     // make sure that SetDIBits executes

/// *******************************************************************

// Convert to TK image format (packed RGB format).
// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app
// can deallocate with free()).

    pjTKBits = PackTexImage( &pbmiRGB->bmiHeader, pjBitsRGB );
    if( !pjTKBits ) {
        SS_ERROR( "ConvertToOpenGLTexFormat : memory failure\n" );
        goto tkDIBLoadImage_cleanup;
    }

// Initialize the texture structure

    // If we get to here, we have suceeded!
    width = pbmiSource->bmiHeader.biWidth;
    height = pbmiSource->bmiHeader.biHeight;
    format = GL_RGB;
    components = 3;
// do we keep the data around , since it's not needed after the texture is
// downloaded into GL and have texObj's ?
    data = pjTKBits;
    pal_size = 0;
    pal = NULL;

    fSuccess = TRUE;
    
// Cleanup objects.

tkDIBLoadImage_cleanup:
    {
        if (hdcMem)
            DeleteDC(hdcMem);

        if (hbmRGB)
            DeleteObject(hbmRGB);

        if (pbmiRGB)
            LocalFree(pbmiRGB);

        if (pbmiSource)
            LocalFree(pbmiSource);
    }

// Check for error.

    if (!fSuccess)
    {
        if (pjTKBits)
            free(pjTKBits);
    }

    return fSuccess;
}
#endif

BOOL 
TEXTURE::DIBImageLoad( HBITMAP hbmRGB )
{
    BOOL             fSuccess = FALSE;
    PBYTE            pjTKBits = (PBYTE) NULL;   // Ptr to final TK image bits
    BITMAPINFOHEADER *pbmih;

    // These need to be cleaned up when we exit:
    PVOID            pvBits = NULL;    // Ptr to bitmap bits in file
    HDC        hdcMem = (HDC) NULL;                 // 24BPP mem DC
    BITMAPINFO *pbmiRGB = (BITMAPINFO *) NULL;      // Ptr to file's BITMAPINFO

    // Create memory DC.

    hdcMem = CreateCompatibleDC(NULL);
    if (!hdcMem) {
        SS_ERROR( "TEXTURE::DIBImageLoad : CreateCompatibleDC failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }

    // Allocate BITMAPINFO structure

    pbmiRGB = (BITMAPINFO *)
              LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(BITMAPINFO) );
    if (!pbmiRGB)
    {
        SS_ERROR( "TEXTURE::DIBImageLoad : memory failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }
    pbmih = (BITMAPINFOHEADER *) &pbmiRGB->bmiHeader;
    pbmih->biSize = sizeof( BITMAPINFOHEADER );

    // Query bitmap values into pbmih

    if( ! GetDIBits( hdcMem, hbmRGB, 0, 0, NULL, pbmiRGB, 
                     DIB_RGB_COLORS ) )
    {
        SS_ERROR( "TEXTURE::DIBImageLoad : GetDIBits failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }

    // Now pbmiRGB->bmiHeader should've been filled in with stuff

    pbmih->biPlanes        = 1;
    pbmih->biBitCount      = 24;
    pbmih->biCompression   = BI_RGB;
//mf:suppsedly this can be set to 0 for BI_RGB
    pbmih->biSizeImage     = pbmih->biWidth
                                         * abs(pbmih->biHeight) * 3;

    pvBits = (PVOID) LocalAlloc(LMEM_FIXED, pbmih->biSizeImage);
    if (!pvBits)
    {
        SS_ERROR( "TEXTURE::DIBImageLoad : memory failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }

    // Get the image bits

    if( ! GetDIBits( hdcMem, hbmRGB, 0, pbmih->biHeight, pvBits, 
                     pbmiRGB, DIB_RGB_COLORS ) )
    {
        SS_ERROR( "TEXTURE::DIBImageLoad : GetDIBits failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }


// Convert to TK image format (packed RGB format).
// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app
// can deallocate with free()).

    pjTKBits = PackTexImage( pbmih, (PBYTE) pvBits );
    if( !pjTKBits ) {
        SS_ERROR( "ConvertToOpenGLTexFormat : memory failure\n" );
        goto tkDIBLoadImage2_cleanup;
    }

// Initialize the texture structure

    // If we get to here, we have suceeded!
    width = pbmih->biWidth;
    height = pbmih->biHeight;
    format = GL_BGR_EXT; 
    components = 3;
    data = pjTKBits;
    pal_size = 0;
    pal = NULL;

    fSuccess = TRUE;
    
// Cleanup objects.

tkDIBLoadImage2_cleanup:
    {
        if( pvBits )
            LocalFree(pvBits);
        if (hdcMem)
            DeleteDC(hdcMem);
        if (pbmiRGB)
            LocalFree(pbmiRGB);
    }

// Check for error.

    if (!fSuccess)
    {
        if (pjTKBits)
            free(pjTKBits);
    }

    return fSuccess;
}

/******************************Public*Routine******************************\
*
* bVerifyDIB
*
* Stripped down version of tkDIBImageLoadAW that verifies that a bitmap
* file is valid and, if so, returns the bitmap dimensions.
*
* Returns:
*   TRUE if valid bitmap file; otherwise, FALSE.
*
\**************************************************************************/

BOOL 
bVerifyDIB(LPTSTR pszFileName, ISIZE *pSize )
{
    BOOL bRet = FALSE;
    BITMAPFILEHEADER *pbmf;         // Ptr to file header
    BITMAPINFOHEADER *pbmihFile;    // Ptr to file's info header (if it exists)
    BITMAPCOREHEADER *pbmchFile;    // Ptr to file's core header (if it exists)

    // These need to be cleaned up when we exit:
    HANDLE     hFile = INVALID_HANDLE_VALUE;        // File handle
    HANDLE     hMap = (HANDLE) NULL;                // Mapping object handle
    PVOID      pvFile = (PVOID) NULL;               // Ptr to mapped file

// Map the DIB file into memory.

    hFile = CreateFile((LPTSTR) pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
    if (hFile == INVALID_HANDLE_VALUE)
        goto bVerifyDIB_cleanup;

    hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!hMap)
        goto bVerifyDIB_cleanup;

    pvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (!pvFile)
        goto bVerifyDIB_cleanup;

// Check the file header.  If the BFT_BITMAP magic number is there,
// then the file format is a BITMAPFILEHEADER followed immediately
// by either a BITMAPINFOHEADER or a BITMAPCOREHEADER.  The bitmap
// bits, in this case, are located at the offset bfOffBits from the
// BITMAPFILEHEADER.
//
// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER
// followed immediately with the color table and the bitmap bits.

    pbmf = (BITMAPFILEHEADER *) pvFile;

    if ( pbmf->bfType == BFT_BITMAP )
        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER);
    else
        pbmihFile = (BITMAPINFOHEADER *) pvFile;

// Get the width and height from whatever header we have.
//
// We distinguish between BITMAPINFO and BITMAPCORE cases based upon
// BITMAPINFOHEADER.biSize.

    // Note: need to use safe READDWORD macro because pbmihFile may
    // have only WORD alignment if it follows a BITMAPFILEHEADER.

    switch (READDWORD(&pbmihFile->biSize))
    {
    case sizeof(BITMAPINFOHEADER):

        if( pSize != NULL ) {
            pSize->width  = READDWORD(&pbmihFile->biWidth);
            pSize->height = READDWORD(&pbmihFile->biHeight);
        }
        bRet = TRUE;

        break;

    case sizeof(BITMAPCOREHEADER):
        pbmchFile = (BITMAPCOREHEADER *) pbmihFile;

    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER.

        if( pSize != NULL ) {
            pSize->width  = (DWORD) pbmchFile->bcWidth;
            pSize->height = (DWORD) pbmchFile->bcHeight;
        }
        bRet = TRUE;

        break;

    default:
        break;
    }

bVerifyDIB_cleanup:

    if (pvFile)
        UnmapViewOfFile(pvFile);

    if (hMap)
        CloseHandle(hMap);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\texrgb.cxx ===
/******************************Module*Header*******************************\
* Module Name: texrgb.cxx.c
*
* Operations on .rgb files
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "mtk.h"
#include "texture.hxx"

#define IMAGIC      0x01da
#define IMAGIC_SWAP 0xda01

#define SWAP_SHORT_BYTES(x) ((((x) & 0xff) << 8) | (((x) & 0xff00) >> 8))
#define SWAP_LONG_BYTES(x) (((((x) & 0xff) << 24) | (((x) & 0xff00) << 8)) | \
                            ((((x) & 0xff0000) >> 8) | (((x) & 0xff000000) >> 24)))

typedef struct _rawImageRec {
    unsigned short imagic;
    unsigned short type;
    unsigned short dim;
    unsigned short sizeX, sizeY, sizeZ;
    unsigned long min, max;
    unsigned long wasteBytes;
    char name[80];
    unsigned long colorMap;
    HANDLE file;
    unsigned char *tmp, *tmpR, *tmpG, *tmpB;
    unsigned long rleEnd;
    unsigned long *rowStart;
    long *rowSize;
    // !!! Hack to stick in a pointer to the resource data - shouldn't be
    // a problem, since rgb files always have 512 byte header
    unsigned char *data;
} rawImageRec;

static void RawImageClose(rawImageRec *raw);

/**************************************************************************\
*
* Hacked form of tk_RGBImageLoad(), for reading a .rgb file from a resource
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
static rawImageRec *RawImageOpen( PVOID pv )
{
    rawImageRec *raw;
    unsigned long *rowStart, *rowSize, ulTmp;
    int x;
    DWORD dwBytesRead;

    raw = (rawImageRec *)malloc(sizeof(rawImageRec));
    if (raw == NULL) {
        return 0;
    }

    // Make a copy of the resource header, since we may be doing some byte
    // swapping, and resources are read-only
    *raw = *((rawImageRec *) pv);

    if (raw->imagic == IMAGIC_SWAP) {
        raw->type = SWAP_SHORT_BYTES(raw->type);
        raw->dim = SWAP_SHORT_BYTES(raw->dim);
        raw->sizeX = SWAP_SHORT_BYTES(raw->sizeX);
        raw->sizeY = SWAP_SHORT_BYTES(raw->sizeY);
        raw->sizeZ = SWAP_SHORT_BYTES(raw->sizeZ);
    }

    raw->tmp = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpR = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpG = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpB = (unsigned char *)malloc(raw->sizeX*256);
    if (raw->tmp == NULL || raw->tmpR == NULL || raw->tmpG == NULL ||
        raw->tmpB == NULL) {
        RawImageClose(raw);
        return 0;
    }

    if ((raw->type & 0xFF00) == 0x0100) {
        x = raw->sizeY * raw->sizeZ * sizeof(long);
        raw->rowStart = (unsigned long *)malloc(x);
        raw->rowSize = (long *)malloc(x);
        if (raw->rowStart == NULL || raw->rowSize == NULL) {
            RawImageClose(raw);
            return 0;
        }
//mf: not used (?)
        raw->rleEnd = 512 + (2 * x);

        //mf: hack to point to resource data
        raw->data = ((unsigned char *) pv);
        RtlCopyMemory( raw->rowStart, raw->data + 512, x );
        RtlCopyMemory( raw->rowSize, raw->data + 512 + x, x );

        if (raw->imagic == IMAGIC_SWAP) {
            x /= sizeof(long);
            rowStart = raw->rowStart;
            rowSize = (unsigned long *) raw->rowSize;
            while (x--) {
                ulTmp = *rowStart;
                *rowStart++ = SWAP_LONG_BYTES(ulTmp);
                ulTmp = *rowSize;
                *rowSize++ = SWAP_LONG_BYTES(ulTmp);
            }
        }
    }
    return raw;
}

static void RawImageClose(rawImageRec *raw)
{
    if( !raw )
        return;
    if( raw->tmp ) free(raw->tmp);
    if( raw->tmpR ) free(raw->tmpR);
    if( raw->tmpG ) free(raw->tmpG);
    if( raw->tmpB ) free(raw->tmpB);
    free(raw);
}

static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z)
{
    unsigned char *iPtr, *oPtr, pixel;
    int count;
    DWORD dwBytesRead;

    if ((raw->type & 0xFF00) == 0x0100) {
        RtlCopyMemory(raw->tmp, raw->data + raw->rowStart[y+z*raw->sizeY],
                 (unsigned int)raw->rowSize[y+z*raw->sizeY] );
        iPtr = raw->tmp;
        oPtr = buf;
        while (1) {
            pixel = *iPtr++;
            count = (int)(pixel & 0x7F);
            if (!count) {
                return;
            }
            if (pixel & 0x80) {
                while (count--) {
                    *oPtr++ = *iPtr++;
                }
            } else {
                pixel = *iPtr++;
                while (count--) {
                    *oPtr++ = pixel;
                }
            }
        }
    } else {
        iPtr = raw->data + 512 + (y*raw->sizeX)+(z*raw->sizeX*raw->sizeY);
        RtlCopyMemory( buf, iPtr, raw->sizeX );
    }
}

PUCHAR RawImageGetData(rawImageRec *raw )
{
    unsigned char *ptr;
    int i, j;
    PUCHAR pData;

    pData = (unsigned char *)malloc((raw->sizeX+1)*(raw->sizeY+1)*4);
    if (pData == NULL) {
        return 0;
    }

    ptr = pData;
    for (i = 0; i < raw->sizeY; i++) {
        RawImageGetRow(raw, raw->tmpR, i, 0);
        RawImageGetRow(raw, raw->tmpG, i, 1);
        RawImageGetRow(raw, raw->tmpB, i, 2);
        for (j = 0; j < raw->sizeX; j++) {
            *ptr++ = *(raw->tmpR + j);
            *ptr++ = *(raw->tmpG + j);
            *ptr++ = *(raw->tmpB + j);
        }
    }
    return pData;
}

BOOL 
TEXTURE::RGBImageLoad( PVOID pv )
{
    rawImageRec *raw;

    if( !(raw = RawImageOpen( pv )) )
        return FALSE;
    
    width = raw->sizeX;
    height = raw->sizeY;
    format = GL_RGB;
    components = 3;
    pal_size = 0;
    pal = NULL;
    data = RawImageGetData( raw );
    RawImageClose(raw);
    return TRUE;
}

/******************************Public*Routine******************************\
*
* bVerifyRGB
*
* Stripped down version of tkRGBImageLoadAW that verifies that an rgb
* file is valid and, if so, returns the bitmap dimensions.
*
* Returns:
*   TRUE if valid rgb file; otherwise, FALSE.
*
\**************************************************************************/

BOOL 
bVerifyRGB(LPTSTR pszFileName, ISIZE *pSize )
{
    rawImageRec *raw;
    DWORD dwBytesRead;
    BOOL bRet = FALSE;

    raw = (rawImageRec *) 
          LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof(rawImageRec) );

    if (raw == NULL) {
        return FALSE;
    }

    raw->file = CreateFile((LPTSTR) pszFileName, GENERIC_READ, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, 0, 0);

    if (raw->file == INVALID_HANDLE_VALUE) {
        goto bVerifyRGB_cleanup;
    }

    ReadFile(raw->file, (LPVOID) raw, 12, &dwBytesRead, (LPOVERLAPPED) NULL);

    if( raw->imagic == IMAGIC_SWAP ) {
        raw->sizeX = SWAP_SHORT_BYTES(raw->sizeX);
        raw->sizeY = SWAP_SHORT_BYTES(raw->sizeY);
        bRet = TRUE;
    } else if( raw->imagic == IMAGIC)
        bRet = TRUE;

bVerifyRGB_cleanup:

    if( bRet && pSize ) {
        pSize->width = raw->sizeX;
        pSize->height = raw->sizeY;
    }
        
    if( raw->file != INVALID_HANDLE_VALUE )
        CloseHandle( raw->file );

    LocalFree( raw );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\timer.cxx ===
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <assert.h>

#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glaux.h>

#include "mtk.h"
#include "timer.hxx"


/****** TIMER *******************************************************/


TIMER::TIMER()
{
    Reset();
}

void
TIMER::Reset()
{
    dwTotalMillis = 0;
    bRunning = FALSE;
}

void
TIMER::Start()
{
    dwStartMillis = GetTickCount();
    bRunning = TRUE;
}

float
TIMER::Stop()
{
    if( bRunning ) {
        // Need to stop the timer
        
        dwElapsedMillis = GetTickCount() - dwStartMillis;
        dwTotalMillis += dwElapsedMillis;

        bRunning = FALSE;
    }
    return MillisToSeconds( dwTotalMillis );
}

float
TIMER::Elapsed()
{
    if( !bRunning )
        return MillisToSeconds( dwTotalMillis );

    dwElapsedMillis = GetTickCount() - dwStartMillis;

    return MillisToSeconds( dwTotalMillis + dwElapsedMillis );
}

/****** UPDATE_TIMER *******************************************************/

// mf: need to address how dwTotalMillis used here, and in AVG
// Problem is that we effectively reset the timer on every update.  This assumes
// that the number of items is >> # drawn in interval.  But wait, that's the way
// it should be : We're measuring withing a time slice defined by the interval update, and don't want to include any previous slices.  Of course, AVG_UPTDATE_TIMER *could* do this...

UPDATE_TIMER::UPDATE_TIMER( float fUpdateInterval )
: updateInterval( SecondsToMillis(fUpdateInterval) )
{
    Reset();
}

void
UPDATE_TIMER::Reset()
{
    TIMER::Reset();

    nTotalItems = 0;
    fUpdateRate = 0.0f;
}

BOOL    
UPDATE_TIMER::Update( int numItems, float *fRate )
{
    // Elapsed time will be total time plus current interval (if running)
    dwElapsedMillis = dwTotalMillis;
    if( bRunning ) {
        dwElapsedMillis += GetTickCount()-dwStartMillis;
        nTotalItems += numItems;
    }

    // If total elapsed time is greater than the update interval, send back
    // timing information

    if( bRunning && (dwElapsedMillis > updateInterval) )
    {
        int iNewResult;

        fUpdateRate = (float) nTotalItems*1000.0f/dwElapsedMillis;
        *fRate = fUpdateRate; 

        // At the end of each update period, we effectively reset and restart
        // the timer, and set running totals back to 0

        Reset();
        Start();

        return TRUE;
    } else {
        *fRate = fUpdateRate;  // return last calculated value to caller
        return FALSE; // no new information yet
    }
}

/****** AVG_UPDATE_TIMER *****************************************************/


AVG_UPDATE_TIMER::AVG_UPDATE_TIMER( float fUpdateInterval, int numResults )
: UPDATE_TIMER( fUpdateInterval), nMaxResults( numResults )
{
    Reset();
}

void
AVG_UPDATE_TIMER::Reset()
{
    UPDATE_TIMER::Reset();

    nResults = 0;
    SS_CLAMP_TO_RANGE2( nMaxResults, 1, MAX_RESULTS );
    fSummedResults = 0.0f;
    iOldestResult = 0; // index of oldest result
}

BOOL    
AVG_UPDATE_TIMER::Update( int numItems, float *fRate )
{
    dwElapsedMillis = dwTotalMillis;
    if( bRunning ) {
        dwElapsedMillis += GetTickCount()-dwStartMillis;
        nTotalItems += numItems;
    }

    // If total elapsed time is greater than the update interval, send back
    // timing information

    if( bRunning && (dwElapsedMillis > updateInterval) )
    {
        int iNewResult;
        float fItemsPerSecond; 

        fItemsPerSecond = (float) nTotalItems*1000.0f/dwElapsedMillis;

        // Average last n results (they are kept in a circular buffer)
                
        if( nResults < nMaxResults ) {
            // Haven't filled the buffer yet
            iNewResult = nResults;
            nResults++;
        } else {
            // Full buffer : replace oldest entry with new value
            fSummedResults -= fResults[iOldestResult];
            iNewResult = iOldestResult;
            iOldestResult = (iOldestResult == (nMaxResults - 1)) ?
                                0 :
                                (iOldestResult + 1);
                            
        }

        // Add new result, maintain sum to simplify calculations
        fResults[iNewResult] = fItemsPerSecond;
        fSummedResults += fItemsPerSecond;

        // average the result
        fUpdateRate = fSummedResults / (float) nResults;
        *fRate = fUpdateRate;

        // At the end of each update period, we effectively reset and restart
        // the update timer, and set running totals back to 0

        UPDATE_TIMER::Reset();
        UPDATE_TIMER::Start();

        return TRUE;
    } else {
        *fRate = fUpdateRate;  // return last calculated value to caller
        return FALSE; // no new information yet
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\toolkits\libmtk\mtkwproc.cxx ===
/******************************Module*Header*******************************\
* Module Name: sswproc.cxx
*
* Window procedure functions.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "mtk.hxx"
#include "mtkinit.hxx"
#include "palette.hxx"
#include "clear.hxx"
#include "mtkwproc.hxx"

//mf: some of this stuff should be per window-group eventually
SSW_TABLE sswTable;

//mf: this needs to be per window group
static BOOL bInBackground;

// forward declarations of internal functions

LONG SS_ScreenSaverProc( HWND, UINT, WPARAM, LPARAM );
LONG MainPaletteManageProc(HWND, UINT, WPARAM, LPARAM );
static LONG InputManageProc(HWND, UINT, WPARAM, LPARAM );

static void ForceRedraw( HWND Window );

static void ssw_RealizePalette( PMTKWIN pssw, BOOL bBackground );
static void ssw_DeletePalette( PMTKWIN pssw );


/**************************************************************************\
* ScreenSaverProc
*
* Processes messages for the top level screen saver window.
*
* Unhandled msgs are sent to DefScreenSaverProc
\**************************************************************************/

LONG 
mtkWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    MTKWIN *pmtkwin;

    switch (message)
    {
        case WM_CREATE:
        case WM_ERASEBKGND:
            return SS_ScreenSaverProc( hwnd, message, wParam, lParam);

        case WM_ACTIVATE:
            if ( LOWORD(wParam) == WA_INACTIVE ) {
                SS_DBGMSG( "Main_Proc: WM_ACTIVATE inactive\n" );
                bInBackground = TRUE;
            } else {
                SS_DBGMSG( "Main_Proc: WM_ACTIVATE active\n" );
                bInBackground = FALSE;
            }

            // fall thru

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
        case WM_SYSCOLORCHANGE:
        case MTK_WM_PALETTE:
            return( MainPaletteManageProc( hwnd, message, wParam, lParam ) );


        case WM_DESTROY:
            pmtkwin = sswTable.PsswFromHwnd( hwnd );

            if( ! pmtkwin ) {
                SS_WARNING( "WM_DESTROY : pmtkwin is NULL\n" );
                return 0;
            }

//mf: Before deleting this top level window, we need to use its
// still-valid dc to things like restore SystemPaletteUse mode.  Ideally this
// should be done after ~SSW has dumped GL, but ~SSW also releases the DC.
// If this is a problem, we can create a new function SSW::DeleteGL that just
// gets rid of the GL part

            if( sswTable.GetNumWindows() == 1 ) {
                // This is the last window, special considerations

                // Handle any palette stuff
                if( gpssPal )
                    ssw_DeletePalette( pmtkwin );

                delete pmtkwin;

                // All win's have now been deleted - remove global ptr to top of
                // window chain.
                gpMtkwinMain = NULL;
            }

// mf: ! this kills the app !, that's not what we want...
// Doesn't seem to make much of a difference if call it or not
//            PostQuitMessage(0);
            return 0;

        case WM_PAINT:
            SS_DBGMSG( "mtkWndProc: WM_PAINT\n" );

            pmtkwin = sswTable.PsswFromHwnd( hwnd );
            pmtkwin->Repaint( TRUE );

#ifdef SS_DO_PAINT
            // We do the painting rather than letting the system do it
            hdc = BeginPaint(hwnd, &ps);

            // This is case where bg brush is NULL and we have to do repaint
            // We only do it after bInited, as this will avoid the first
            // -> bInited removed 5/1/97
            // WM_PAINT for the entire window.
            DrawGdiRect( hdc, ghbrBg, &ps.rcPaint );
            EndPaint(hwnd, &ps);

            return 0; // painting has been handled by us
#endif // SS_DO_PAINT

            break;

        case MTK_WM_REDRAW:
            SS_DBGMSG( "mtkWndProc: MTK_WM_REDRAW\n" );
            pmtkwin = sswTable.PsswFromHwnd( hwnd );
            pmtkwin->Display();
            return 0;

        case WM_MOVE:
            SS_DBGMSG( "mtkWndProc: WM_MOVE\n" );
            pmtkwin = sswTable.PsswFromHwnd( hwnd );
            pmtkwin->pos.x = LOWORD(lParam);
            pmtkwin->pos.y = HIWORD(lParam);
            break;
//mf
#if 1
// This allows us to pick up under-bits on window moves
        case WM_WINDOWPOSCHANGING:
            {
                LPWINDOWPOS lpwp = (LPWINDOWPOS) lParam;
                SS_DBGMSG1( "mtkWndProc: WM_WINDOWPOSCHANGING, flags = %x\n",
                            lpwp->flags );
                pmtkwin = sswTable.PsswFromHwnd( hwnd );
                if( pmtkwin->pBackgroundBitmap ) {
#if 0
                    // If window moving, don't want to copy old bits...
        //mf: this actually fukin works (sometimes) !
                    if( !(lpwp->flags & SWP_NOMOVE) ) {
                SS_DBGMSG( "mtkWndProc: WM_WINDOWPOSCHANGING, moving\n" );
                        // window moving
                        if( !(lpwp->flags & SWP_NOCOPYBITS) ) {
                            lpwp->flags |= SWP_NOCOPYBITS;
                        }
                    }
                }
#else
// Things seem to work better if we always force this flag, otherwise now
// and then get partial update rects, even if window active and moving (in
// which case update rect should always be entire client area.
                            lpwp->flags |= SWP_NOCOPYBITS;
                }
#endif
            }
            break;
        case WM_WINDOWPOSCHANGED:
            {
                LPWINDOWPOS lpwp = (LPWINDOWPOS) lParam;
                SS_DBGMSG1( "mtkWndProc: WM_WINDOWPOSCHANGED, flags = %x\n",
                            lpwp->flags );
                pmtkwin = sswTable.PsswFromHwnd( hwnd );
                if( pmtkwin->pBackgroundBitmap ) {
                    if( !(lpwp->flags & SWP_NOMOVE) ) {
                        // window moved
//                SS_DBGMSG( "mtkWndProc: WM_WINDOWPOSCHANGED, moved\n" );
                    }
                }
            }
            break;
#endif

        case WM_TIMER:

            SS_DBGMSG( "mtkWndProc: WM_TIMER\n" );

            if( pmtkwin = sswTable.PsswFromHwnd( hwnd ) )
                pmtkwin->mtkAnimate();

            return 0;
    }

//mf: for now...
    return SS_ScreenSaverProc(hwnd, message, wParam, lParam);
}

/**************************************************************************\
* SS_ScreenSaverProc
*
* Wndproc for child windows, and some messages from top-level window
*
* Unhandled msgs are sent to DefWindowProc
\**************************************************************************/

LONG 
SS_ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    int i;
    int retVal;
    MTKWIN *pmtkwin;

    switch (message)
    {
        case WM_CREATE:
            SS_DBGMSG1( "SS_Proc: WM_CREATE for 0x%x\n", hwnd );

            pmtkwin = (PMTKWIN) ( ((LPCREATESTRUCT)lParam)->lpCreateParams ); 
            sswTable.Register( hwnd, pmtkwin );
            pmtkwin->hwnd = hwnd;
            break;

        case MTK_WM_PALETTE:
            return( MainPaletteManageProc( hwnd, message, wParam, lParam ) );

        case WM_DESTROY:
            pmtkwin = sswTable.PsswFromHwnd( hwnd );

            SS_DBGMSG1( "SS_Proc: WM_DESTROY for 0x%x\n", hwnd );

            // Delete the pssw - this does all necessary cleanup

            if( pmtkwin )
                delete pmtkwin;
            else
                SS_WARNING( "WM_DESTROY : pmtkwin is NULL\n" );

            break;

        case WM_PAINT:
            // We get this msg every time window moves, since SWP_NOCOPYBITS is
            // specified with the window move.
            hdc = BeginPaint(hwnd, &ps);
//mf: will need to call DisplayFunc here...
// -> currently being handled in tkWndProc
            EndPaint(hwnd, &ps);
            break;

        case WM_SIZE:
            SS_DBGMSG( "mtkWndProc: WM_SIZE\n" );
            pmtkwin = sswTable.PsswFromHwnd( hwnd );
            // Suspend drawing if minimized
            if( wParam == SIZE_MINIMIZED ) {
                // Stop any animation
                pmtkwin->animator.Stop(); // noop if no timer
                // We can return here, since for now we don't do anything
                // in a minimized window
                return 0;
            }
            else { // either SIZE_RESTORED or SIZE_MAXIMIZED
                // If there is an animation func, restart animation
//mf: potential problem here if timer was not started...
                pmtkwin->animator.Start();
            }

            pmtkwin->Resize( LOWORD(lParam), HIWORD(lParam) );
            break;

        // these msg's are never received by the child window ?
        case WM_ACTIVATE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            return( MainPaletteManageProc( hwnd, message, wParam, lParam ) );


        case WM_MOUSEMOVE:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_MBUTTONUP:
        case WM_RBUTTONUP:
        case WM_KEYDOWN:
        case WM_CHAR:
//mf: this can be fn ptr eventually, so ss's can use it too
            return( InputManageProc( hwnd, message, wParam, lParam ) );

        default: 
            return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}

/**************************************************************************\
* InputManageProc
*
\**************************************************************************/

static LONG 
InputManageProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    MTKWIN *pmtkwin = sswTable.PsswFromHwnd( hWnd );
    int key;

  switch( message ) {

    case WM_MOUSEMOVE:

        if (pmtkwin->MouseMoveFunc)
        {
            GLenum mask;

            mask = 0;
            if (wParam & MK_LBUTTON) {
                mask |= TK_LEFTBUTTON;
            }
            if (wParam & MK_MBUTTON) {
                mask |= TK_MIDDLEBUTTON;
            }
            if (wParam & MK_RBUTTON) {
                mask |= TK_RIGHTBUTTON;
            }

            if ((*pmtkwin->MouseMoveFunc)( LOWORD(lParam), HIWORD(lParam), mask ))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_LBUTTONDOWN:

        SetCapture(hWnd);

        if (pmtkwin->MouseDownFunc)
        {
            if ( (*pmtkwin->MouseDownFunc)(LOWORD(lParam), HIWORD(lParam),
                 TK_LEFTBUTTON) )
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_LBUTTONUP:

        ReleaseCapture();

        if (pmtkwin->MouseUpFunc)
        {
            if ((*pmtkwin->MouseUpFunc)(LOWORD(lParam), HIWORD(lParam), TK_LEFTBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_MBUTTONDOWN:

        SetCapture(hWnd);

        if (pmtkwin->MouseDownFunc)
        {
            if ((*pmtkwin->MouseDownFunc)(LOWORD(lParam), HIWORD(lParam),
                    TK_MIDDLEBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_MBUTTONUP:

        ReleaseCapture();

        if (pmtkwin->MouseUpFunc)
        {
            if ((*pmtkwin->MouseUpFunc)(LOWORD(lParam), HIWORD(lParam),
                TK_MIDDLEBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_RBUTTONDOWN:

        SetCapture(hWnd);

        if (pmtkwin->MouseDownFunc)
        {
            if ((*pmtkwin->MouseDownFunc)(LOWORD(lParam), HIWORD(lParam),
                TK_RIGHTBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_RBUTTONUP:

        ReleaseCapture();

        if (pmtkwin->MouseUpFunc)
        {
            if ((*pmtkwin->MouseUpFunc)(LOWORD(lParam), HIWORD(lParam),
                TK_RIGHTBUTTON))
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_SPACE:          key = TK_SPACE;         break;
        case VK_RETURN:         key = TK_RETURN;        break;
        case VK_ESCAPE:         key = TK_ESCAPE;        break;
        case VK_LEFT:           key = TK_LEFT;          break;
        case VK_UP:             key = TK_UP;            break;
        case VK_RIGHT:          key = TK_RIGHT;         break;
        case VK_DOWN:           key = TK_DOWN;          break;
        default:                key = GL_FALSE;         break;
        }

        if (key && pmtkwin->KeyDownFunc)
        {
            GLenum mask;

            mask = 0;
            if (GetKeyState(VK_CONTROL)) {
                mask |= TK_CONTROL;
            }

            if (GetKeyState(VK_SHIFT)) {

                mask |= TK_SHIFT;
            }

            if ( (*pmtkwin->KeyDownFunc)(key, mask) )
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);

    case WM_CHAR:
        if (('0' <= wParam && wParam <= '9') ||
            ('a' <= wParam && wParam <= 'z') ||
            ('A' <= wParam && wParam <= 'Z')) {

            key = wParam;
        } else {
            key = GL_FALSE;
        }

        if (key && pmtkwin->KeyDownFunc) {
            GLenum mask;

            mask = 0;

            if (GetKeyState(VK_CONTROL)) {
                mask |= TK_CONTROL;
            }

            if (GetKeyState(VK_SHIFT)) {
                mask |= TK_SHIFT;
            }

            if ( (*pmtkwin->KeyDownFunc)(key, mask) )
            {
                ForceRedraw( hWnd );
            }
        }
        return (0);
    }    
    return 0;
}

static void
ForceRedraw( HWND hwnd )
{
    MSG Message;

#if 0
    if (!PeekMessage(&Message, hwnd, WM_PAINT, WM_PAINT, PM_NOREMOVE) )
    {
        InvalidateRect( hwnd, NULL, FALSE );
    }
#else
//mf: There is a problem with doing the redraw via WM_PAINT.  WM_PAINT is sent
// by the system when part of the window needs to be redrawn.  For transparent
// windows, we hook a grab background off of this, so if we use WM_PAINT for
// our redraws, we'll just grab the previous gl image.  Solutions are :
// 1) Call redraw proc immediately here (possible timing problem)
// 2) * Send redraw msg to queue
// Possible side-effect : by not sending a WM_PAINT, the system is less
// informed about what we're doing, but heck, we don't use PAINT for animations
// anyways.
    if (!PeekMessage(&Message, hwnd, MTK_WM_REDRAW, MTK_WM_REDRAW, PM_NOREMOVE) )
    {
        PostMessage( hwnd, MTK_WM_REDRAW, 0, 0l );
    }
#endif
}

/**************************************************************************\
* UpdateDIBColorTable
*
* Wrapper for SSDIB_Up