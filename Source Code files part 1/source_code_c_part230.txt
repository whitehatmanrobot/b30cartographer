rce, int nSourceLen, LPCWSTR pSuffix, int nSuffixLen, DWORD dwFlags) {
    int nMatchEndIndex;
    int result = LastIndexOfString(pSource, pSuffix, nSourceLen - 1, 0, nSuffixLen, dwFlags, &nMatchEndIndex);
    if (result >= 0) { // -1 == not found, -2 == invalid flags
        // The end of the matching string in pSource is at the end of pSource, so
        // return true.
        if (nMatchEndIndex == nSourceLen) {
            return (TRUE);
        }
        // Otherwise, check if the rest of the pSource can be ignored.
        
        int fIgnoreSymbols = (dwFlags & COMPARE_OPTIONS_IGNORESYMBOLS);
        int fIgnoreNonSpace = (dwFlags & COMPARE_OPTIONS_IGNORENONSPACE);

        LPCWSTR pSourceEnd = pSource + nSourceLen;
        pSource += nMatchEndIndex;
        while (pSource < pSourceEnd) {
            DWORD dwWeight = GET_DWORD_WEIGHT(m_pSortKey, *pSource);
            switch (GET_SCRIPT_MEMBER(&dwWeight)) {
                case NONSPACE_MARK:
                    if (!fIgnoreNonSpace) {
                        goto FailToMatch;
                    }
                    // This character in pString2 can not be ignored, we fail
                    // to find a match. Go to next character in pString1.
                    break;
                case PUNCTUATION:
                case SYMBOL_1:
                case SYMBOL_2:
                case SYMBOL_3:
                case SYMBOL_4:
                case SYMBOL_5:
                    if (!fIgnoreSymbols) {
                        goto FailToMatch;
                    }
                    break;
                default:
                    // This character in pString2 can not be ignored, we fail
                    // to find a match. 
                    goto FailToMatch;
            }
            pSource++;
        }        
        return (TRUE);
    }
FailToMatch:    
    return (FALSE);    
}

BOOL NativeCompareInfo::IsPrefix(LPCWSTR pSource, int nSourceLen, LPCWSTR pPrefix, int nPrefixLen, DWORD dwFlags) {
    LPCWSTR pSourceEnd = pSource + nSourceLen;
    int fIgnoreSymbols = (dwFlags & COMPARE_OPTIONS_IGNORESYMBOLS);
    int fIgnoreNonSpace = (dwFlags & COMPARE_OPTIONS_IGNORENONSPACE);

    // Skip the characters according to the options.
    while (pSource < pSourceEnd) {
        DWORD dwWeight = GET_DWORD_WEIGHT(m_pSortKey, *pSource);
        switch (GET_SCRIPT_MEMBER(&dwWeight)) {
            case NONSPACE_MARK:
                if (!fIgnoreNonSpace) {
                    goto StartMatch;
                }
                // This character in pSource can not be ignored, we fail
                // to find a match. Go to next character in pString1.
                break;
            case PUNCTUATION:
            case SYMBOL_1:
            case SYMBOL_2:
            case SYMBOL_3:
            case SYMBOL_4:
            case SYMBOL_5:
                if (!fIgnoreSymbols) {
                    goto StartMatch;
                }
                break;
            default:
                // This character in pSource can not be ignored, we fail
                // to find a match. 
                goto StartMatch;
        }
        pSource++;
        nSourceLen--;
    }        
StartMatch:    
    int result = IndexOfString(pSource, pPrefix, 0, nSourceLen - 1, nPrefixLen, dwFlags, TRUE);
    return (result == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\sortingtablefile.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include <winnls.h>
#include "NLSTable.h"
#include "GlobalizationAssembly.h"
#include "SortingTableFile.h"
#include "SortingTable.h"

#include "excep.h"

//
// NOTENOTE YSLin:
//  This file should be called SortingTable.cpp.  However, SortingTable.cpp now
//  contains the code for NativeCompareInfo (and that file should be called
//  CompareInfo.cpp).
//  I still keep the old file names so that it is easier to do diff.
//  Later we should change the filenames.
//

/** 
 * There are two data table for NativeCompareInfo.  One is sortkey.nlp, which contains the default
 * sortkey information.
 * The other one is sorttbls.nlp, which contains other sorting information for all cultures.
 *
 */

//
// BUGBUG yslin: To see if we need to do a optimized version of IndexOfChar()/LastIndexOfChar(),
// casue we can bypass the diacritic check in the searching character.
//
LPCSTR  SortingTable::m_lpSortKeyFileName       = "sortkey.nlp";
LPCWSTR SortingTable::m_lpSortKeyMappingName    = L"_nlsplus_sortkey_1_0_3627_11_nlp";

LPCSTR  SortingTable::m_lpSortTableFileName     = "sorttbls.nlp";
LPCWSTR SortingTable::m_lpSortTableMappingName  = L"_nlsplus_sorttbls_1_0_3627_11_nlp";

//
// HACKHACK yslin: This table should be put in NLS+ data table, instead of
// being hard-coded here.
//

// NativeCompareInfo is based on the Win32 LCID.  So the number here
// is the number of LCID supported in Win32, not the number of cultures
// supported in NLS+.
int  SortingTable::m_nLangIDCount   = 136;
int  SortingTable::m_nLangArraySize = m_nLangIDCount + 1;

//
// HACKHACK yslin: This table should be put in NLS+ data table, instead of
// being hard-coded here.
//
// This table maps the primary language ID to an offset in the m_ppNativeCompareInfoCache.
// The index is the primary language ID.
// The content is the offset into the slot in m_ppNativeCompareInfoCache which the instances of SortingTable
// have the same primary language ID.
BYTE SortingTable::m_SortingTableOffset[] =
{
      0,  0, 16, 17, 18, 24, 25, 26, 31, 32,
     45, 65, 66, 72, 73, 74, 75, 77, 78, 79,
     81, 83, 84, 86, 86, 87, 88, 91, 92, 93,
     95, 96, 97, 98, 99,100,101,102,103,104,
    105,105,106,107,108,110,111,111,112,112,
    112,112,112,112,112,113,114,115,116,116,
    116,116,116,118,119,120,121,121,123,124,
    124,125,126,126,127,128,129,129,129,130,
    131,132,132,132,132,132,132,133,134,134,
    134,135,135,135,135,135,135,135,135,135,
    135,135,136,136,136,136,136,136,136,136,
    136,136,136,136,136,136,136,136,136,136,
    136,136,136,136,136,136,136,136,
};

//
// This is the cache for NativeCompareInfos.
// It will have m_nLangIDCount items and is organized as the following:
//
// m_ppNativeCompareInfoCache[0]:    Not used.
// Slot for primary language 0x01:
// m_ppNativeCompareInfoCache[1]:    pointer to NativeCompareInfoFile for locale 0x0401.  Null if lcid not used.
// m_ppNativeCompareInfoCache[2]:    pointer to NativeCompareInfoFile for locale 0x0801.  Null if lcid not used.
// m_ppNativeCompareInfoCache[3]:    pointer to NativeCompareInfoFile for locale 0x0c01.  Null if lcid not used.
// ....
// Slot for primary langauge 0x02:
// m_ppNativeCompareInfoCache[16]:   pointer to NativeCompareInfoFile for locale 0x0402.  Null if lcid not used.
//
// Slot for primary language 0x03:
// m_ppNativeCompareInfoCache[17]:   pointer to NativeCompareInfoFile for locale 0x0403.  Null if lcid not used.
//
// ....
// Slot for primary language P (which has n sublanguages)
// m_ppNativeCompareInfoCache[offset]:
// m_ppNativeCompareInfoCache[offset+1]:
// m_ppNativeCompareInfoCache[offset+2]:
// ...
// m_ppNativeCompareInfoCache[offset+n-1]: pointer to SorintTable for locale MAKELANGID(P,n-1).
//                                    Null if lcid not used.
//
// Besides, a NativeCompareInfoFile instance can link to a next SortingTable instance.  For example,
// LCID 0x00030404 (Traditional Chinese, bomopofo order) and 0x00000404 (Traditonal Chinese, stroke order)
// will share the same entry.  So if 0x00000404 is there first, we will create a linked list when
// 0x00030404 is also used.
//

SortingTable::SortingTable(NativeGlobalizationAssembly* pNativeGlobalizationAssembly) :
    m_pNativeGlobalizationAssembly(pNativeGlobalizationAssembly),
    m_pDefaultSortKeyTable(NULL),
    m_ppNativeCompareInfoCache(NULL),
    m_NumReverseDW(0), m_NumDblCompression(0), m_NumIdeographLcid(0), m_NumExpansion(0),
    m_NumCompression(0), m_NumException(0), m_NumMultiWeight(0), 
    m_pReverseDW(NULL),  m_pDblCompression(NULL),  m_pIdeographLcid(NULL), m_pExpansion(NULL), m_pCompressHdr(NULL), m_pCompression(NULL), 
    m_pExceptHdr(NULL), m_pException(NULL), m_pMultiWeight(NULL), 
    m_hSortTable(NULL)
{    
    InitializeSortingCache();
    
    // Get the necessay information that is global to all cultures.
    GetSortInformation();
}

SortingTable::~SortingTable() {
}

/*============================InitializeSortingCache============================
**Action: Creates the static cache of all of the NativeCompareInfos that we know about.
**        This operation must happen at most once per instance of the runtime.  We
**        guarantee this by allocating it in the class initializer of System.CompareInfo.
**Returns: Void.  The side effect is to allocate the cache as a member of SortingTable.
**Arguments:  None
**Exceptions: OutOfMemoryException if we can't allocate PNativeCompareInfo.
==============================================================================*/

void SortingTable::InitializeSortingCache() {
    _ASSERTE(m_ppNativeCompareInfoCache==NULL);

    THROWSCOMPLUSEXCEPTION();

    // The m_ppNativeCompareInfoCache[0] is not used.  So we add one to m_nLangIDCount below.
    m_ppNativeCompareInfoCache = new PNativeCompareInfo[m_nLangArraySize];
    if (m_ppNativeCompareInfoCache==NULL) {
        COMPlusThrowOM();
    }
    ZeroMemory(m_ppNativeCompareInfoCache, m_nLangArraySize * sizeof(*m_ppNativeCompareInfoCache));
}


/*===========================InitializeNativeCompareInfo=============================
**Action: Ensure that the correct sorting table for a given locale has been allocated.
**        This function is called from within a synchronized method from managed, so
**        there should never be more than one thread in here at any one time.  If
**        the table can't be found in the cache, we allocate another one and put it
**        into the cache.
**        The end result is that a NativeCompareInfo instance for a particular culture will not 
**        be created twice.
**Returns: The pointer to the created NativeCompareInfo.  
**        The side effect is to either allocate the table or do nothing if the
**         correct table already exists.
**Arguments:  nLcid -- the lcid for which we're creating the table.
**Exceptions: OutOfMemory if new fails.
**            ExecutionEngineException if we can't find the resource in the SortingTable
**            constructor.
==============================================================================*/
NativeCompareInfo* SortingTable::InitializeNativeCompareInfo(INT32 nLcid) {
    
    _ASSERTE(m_ppNativeCompareInfoCache!=NULL);

    THROWSCOMPLUSEXCEPTION();

    //The cultureID should have been checked when the CompareInfo was created, but
    //we'll double check it here.
    _ASSERTE((m_SortingTableOffset[PRIMARYLANGID(nLcid)] + SUBLANGID(nLcid))<m_nLangArraySize);

    //
    // m_SortingTableOffset[PRIMARYLANGID(nLcid)] points to the slot for a certain primary language.
    // SUBLANGID(nLcid) provides the index within this slot.
    //

    // We access a global variable (m_ppNativeCompareInfoCache), so this is why this method should be
    // synchronized.
    NativeCompareInfo** cacheEntry = &(m_ppNativeCompareInfoCache[
        m_SortingTableOffset[PRIMARYLANGID(nLcid)] + SUBLANGID(nLcid)
    ]);

    NativeCompareInfo* pTable = *cacheEntry;

    if (pTable == NULL) {
        //
        // This entry is empty.  Create a NativeCompareInfo correspondning to the nLcid.
        //
        *cacheEntry = new NativeCompareInfo(nLcid, this);
        
        if (*cacheEntry==NULL) {
            COMPlusThrowOM();
        }
        
        if (!((*cacheEntry)->InitSortingData())) {
            // Fail to initialize sorting data
            return (NULL);
        }

        return (*cacheEntry);
    } else {
        //
        // Search through the list of NativeCompareInfo in this entry until find one matching the nLcid.
        // If one can not be found, create a new one and link it with the previous node in this entry.
        //
        NativeCompareInfo* pPrevTable;
        do {
            if (pTable->m_nLcid == nLcid) {
                //
                // The NativeCompareInfo instance for this nLcid has been created, so our mission
                // is done here.
                //
                return (pTable);
            }
            pPrevTable = pTable;
            pTable = pTable->m_pNext;
        } while (pTable != NULL);

        //
        // The NativeCompareInfo for this nLcid has not been created yet.  Create one and link
        // it with the previous node.
        //
        pTable = new NativeCompareInfo(nLcid, this);
        if (pTable==NULL) {
            COMPlusThrowOM();
        }
        if (!(pTable->InitSortingData())) {
            // Fail to initialize sorting data
            return (NULL);
        }
        pPrevTable->m_pNext = pTable;
        
    }
    return(pTable);
}


/*=============================SortingTableShutdown=============================
**Action: Clean up any statically allocated resources during EE Shutdown.  We need
**        to clean the SortTable (why do we save this anyway?) and then walk our
**        cache cleaning up any SortingTables.
**Returns: True.  Eventually designed for error checking, but we don't do any right now.
**Arguments:  None
**Exceptions: None.
==============================================================================*/
#ifdef SHOULD_WE_CLEANUP
BOOL SortingTable::SortingTableShutdown() {
    #ifdef _USE_MSCORNLP
    //The SortTable is static, so we'll clean up it's data in the NLS shutdown.
    if (m_pSortTable) {
        UnmapViewOfFile((LPCVOID)m_pSortTable);
    }

    if (m_hSortTable) {
        CloseHandle(m_hSortTable);
    }
    #endif
    
    //Clean up any NativeCompareInfo instances that we've allocated.
    if (m_ppNativeCompareInfoCache) {
        for (int i=0; i<m_nLangArraySize; i++) {
            if (m_ppNativeCompareInfoCache[i]) {
                delete m_ppNativeCompareInfoCache[i];
            }
        }
        delete[] m_ppNativeCompareInfoCache;
    }
    
    return TRUE;
}
#endif /* SHOULD_WE_CLEANUP */


/*=====================================Get======================================
**Action:  Returns a cached sorting table.  We maintain the invariant that these
**         tables are always created when a System.CompareInfo is allocated and
**         SortingTable::InitializeNativeCompareInfo should already have been called
**         for the locale specified by nLcid.  Therefore if we can't find the
**         table we throw an ExecutionEngineException.
**Returns:   A pointer to the SortingTable associated with locale nLcid.
**Arguments: nLcid -- The locale for which we need the SortingTable.
**Exceptions: ExecutionEngineException if the table associated with nLcid hasn't
**            been allocated.
**        This indicates a bug that the InitializeNativeCompareInfo() is not called for
**        the desired lcid.
==============================================================================*/

NativeCompareInfo* SortingTable::GetNativeCompareInfo(int nLcid)
{
    //The cultureID should have been checked when the CompareInfo was created, but
    //we'll double check it here.
    _ASSERTE((m_SortingTableOffset[PRIMARYLANGID(nLcid)] + SUBLANGID(nLcid))<m_nLangArraySize);

    THROWSCOMPLUSEXCEPTION();
    NativeCompareInfo* pTable = m_ppNativeCompareInfoCache[
        m_SortingTableOffset[PRIMARYLANGID(nLcid)] + SUBLANGID(nLcid)
    ];

    if (pTable != NULL) {
        do {
            if (pTable->m_nLcid == nLcid) {
                return (pTable);
            }
            pTable = pTable->m_pNext;
        } while (pTable != NULL);
    }
    FATAL_EE_ERROR();

    //We'll never reach here, but the return keeps the compiler happy.
    return (NULL);
}



/*============================GetSortInformation============================
**Action: Get the information that is global to all locales.  The information includes:
**        1. reverse diacritic information: which locales uses diacritic.
**        2. double compression information: which locales uses double compression.
**        3. ideographic locale exception: the mapping of ideographic locales (CJK) to extra sorting files.
**        4. expansion information: expansion characters and their expansion forms.
**        5. compression information:
**        6. exception information: which locales has exception, and their exception entries.
**        7. multiple weight information: what is this?
**        This operation must happen at most once per instance of the runtime.  We
**        guarantee this by allocating it in the class initializer of System.CompareInfo.
**Returns: Void.  The side effect is to allocate the cache as a member of SortingTable.
**Arguments:  None
**Exceptions: None.
==============================================================================*/
void SortingTable::GetSortInformation()
{
    //BUGBUG [YSLIN]: We can optimize this for US English since the only
    //necessary information for US English is the expansion information.
    //However, to do this, we have to relayout sorttabl.nlp by putting a header
    //which points to different information.

    PCOMPRESS_HDR pCompressHdr;   // ptr to compression header
    PEXCEPT_HDR pExceptHdr;       // ptr to exception header
    LPWORD pBaseAddr;             // ptr to the current location in the data file.

    m_pSortTable = pBaseAddr = (LPWORD)m_pNativeGlobalizationAssembly->MapDataFile(m_lpSortTableMappingName, m_lpSortTableFileName, &m_hSortTable);

    //
    //  Get Reverse Diacritic Information.
    //
    m_NumReverseDW   = *((LPDWORD)pBaseAddr);
    _ASSERTE(m_NumReverseDW > 0);
    m_pReverseDW     = (PREVERSE_DW)(pBaseAddr + REV_DW_HEADER);

    pBaseAddr += REV_DW_HEADER + (m_NumReverseDW * (sizeof(REVERSE_DW) / sizeof(WORD)));

    //
    //  Get Double Compression Information.
    //
    m_NumDblCompression = *((LPDWORD)pBaseAddr);
    _ASSERTE(m_NumDblCompression > 0);
    m_pDblCompression   = (PDBL_COMPRESS)(pBaseAddr + DBL_COMP_HEADER);
    pBaseAddr += DBL_COMP_HEADER + (m_NumDblCompression * (sizeof(DBL_COMPRESS) / sizeof(WORD)));

    //
    //  Get Ideograph Lcid Exception Information.
    //
    m_NumIdeographLcid = *((LPDWORD)pBaseAddr);
    _ASSERTE(m_NumIdeographLcid > 0);
    m_pIdeographLcid   = (PIDEOGRAPH_LCID)(pBaseAddr + IDEO_LCID_HEADER);
    pBaseAddr += IDEO_LCID_HEADER + (m_NumIdeographLcid * (sizeof(IDEOGRAPH_LCID) / sizeof(WORD)));

    //
    //  Get Expansion Information.
    //
    m_NumExpansion   = *((LPDWORD)pBaseAddr);
    _ASSERTE(m_NumExpansion > 0);
    m_pExpansion     = (PEXPAND)(pBaseAddr + EXPAND_HEADER);
    pBaseAddr += EXPAND_HEADER + (m_NumExpansion * (sizeof(EXPAND) / sizeof(WORD)));

    //
    //  Get Compression Information.
    //
    m_NumCompression = *((LPDWORD)pBaseAddr);
    _ASSERTE(m_NumCompression > 0);
    m_pCompressHdr   = (PCOMPRESS_HDR)(pBaseAddr + COMPRESS_HDR_OFFSET);
    m_pCompression   = (PCOMPRESS)(pBaseAddr + COMPRESS_HDR_OFFSET +
                                 (m_NumCompression * (sizeof(COMPRESS_HDR) /
                                         sizeof(WORD))));

    pCompressHdr = m_pCompressHdr;
    pBaseAddr = (LPWORD)(m_pCompression) +
                        (pCompressHdr[m_NumCompression - 1]).Offset;

    pBaseAddr += (((pCompressHdr[m_NumCompression - 1]).Num2) *
                  (sizeof(COMPRESS_2) / sizeof(WORD)));

    pBaseAddr += (((pCompressHdr[m_NumCompression - 1]).Num3) *
                  (sizeof(COMPRESS_3) / sizeof(WORD)));

    //
    //  Get Exception Information.
    //
    m_NumException = *((LPDWORD)pBaseAddr);
    _ASSERTE(m_NumException > 0);
    m_pExceptHdr   = (PEXCEPT_HDR)(pBaseAddr + EXCEPT_HDR_OFFSET);
    m_pException   = (PEXCEPT)(pBaseAddr + EXCEPT_HDR_OFFSET +
                               (m_NumException * (sizeof(EXCEPT_HDR) /
                                       sizeof(WORD))));
    pExceptHdr = m_pExceptHdr;
    pBaseAddr = (LPWORD)(m_pException) +
                        (pExceptHdr[m_NumException - 1]).Offset;
    pBaseAddr += (((pExceptHdr[m_NumException - 1]).NumEntries) *
                  (sizeof(EXCEPT) / sizeof(WORD)));

    //
    //  Get Multiple Weights Information.
    //
    m_NumMultiWeight = *pBaseAddr;
    _ASSERTE(m_NumMultiWeight > 0);
    m_pMultiWeight   = (PMULTI_WT)(pBaseAddr + MULTI_WT_HEADER);

    pBaseAddr += (MULTI_WT_HEADER + m_NumMultiWeight * sizeof(MULTI_WT)/sizeof(WORD));

    //
    // Get Jamo Index Table.
    //
    
    m_NumJamoIndex = (DWORD)(*pBaseAddr);   // The Jamo Index table size is (Num) bytes.
    m_pJamoIndex = (PJAMO_TABLE)(pBaseAddr + JAMO_INDEX_HEADER);
    
    pBaseAddr += (m_NumJamoIndex * sizeof(JAMO_TABLE) / sizeof(WORD) + JAMO_INDEX_HEADER);
    
    //
    // Get Jamo Composition state machine table.
    //
    m_NumJamoComposition = (DWORD)(*pBaseAddr);
    m_pJamoComposition = (PJAMO_COMPOSE_STATE)(pBaseAddr + JAMO_COMPOSITION_HEADER);

}



/*============================GetDefaultSortKeyTable============================
**Action: Allocates the default sortkey table if it hasn't already been allocated.
**        This allocates resources, so it needs to be called in a synchronized fasion.
**        We guarantee this by making the managed method that accesses this codepath
**        synchronized.  If you're calling this from someplace besides SortingTable::SortingTable
**        or SortingTable::GetExceptionSortKeyTable, make sure that you haven't broken
**        any invariants.
**Returns:    A pointer to the default sorting table.
**Arguments:  None
**Exceptions: MapDataFile can throw an ExecutionEngineException if the needed data file can't
**            be found.
==============================================================================*/
PSORTKEY SortingTable::GetDefaultSortKeyTable(HANDLE *pMapHandle) {

    _ASSERTE(pMapHandle);

    if (m_pDefaultSortKeyTable == NULL)
    {
        //
        // Skip the first DWORD since it is the semaphore value.
        //
        m_pDefaultSortKeyTable = (PSORTKEY)((LPWORD)m_pNativeGlobalizationAssembly->MapDataFile(
            m_lpSortKeyMappingName, m_lpSortKeyFileName, pMapHandle) + SORTKEY_HEADER);
    }
    return (m_pDefaultSortKeyTable);
}

PSORTKEY SortingTable::GetSortKey(int nLcid, HANDLE* phSortKey) {
    PEXCEPT_HDR pExceptHdr;       // ptr to exception header
    PEXCEPT pExceptTbl;           // ptr to exception table
    PVOID pIdeograph;             // ptr to ideograph exception table

    // If this is not a fast compare locale, try to find if it has exception pointers.
    if (!IS_FAST_COMPARE_LOCALE(nLcid) 
        && FindExceptionPointers(nLcid, &pExceptHdr, &pExceptTbl, &pIdeograph)) {
        // Yes, exceptions exist.  Get the table with exceptions.
        return (GetExceptionSortKeyTable(pExceptHdr, pExceptTbl, pIdeograph, phSortKey));
    }
    
    //
    //  No exceptions for locale, so attach the default sortkey
    //  table pointer to the this locale.
    //
    return (GetDefaultSortKeyTable(phSortKey));
}


PSORTKEY SortingTable::GetExceptionSortKeyTable(
    PEXCEPT_HDR pExceptHdr,        // ptr to exception header
    PEXCEPT     pExceptTbl,        // ptr to exception table
    PVOID       pIdeograph,        // ptr to ideograph exception table
    HANDLE *    pMapHandle        // ptr to the handle for the file mapping.

)
{

    _ASSERTE(pMapHandle);

    HANDLE hDefaultHandle=NULL;

    //
    // BUGBUG yslin: Currently, we will create two tables even some locales has the same exceptions.
    // Should fix this in the future.
    //
    int defaultLen = sizeof(SORTKEY) * (65536 + SORTKEY_HEADER); //This evaluates to 64K Unicode Characters.

    *pMapHandle = WszCreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, defaultLen, NULL);
    if (*pMapHandle == NULL) {
        return (NULL);
    }
    LPWORD pBaseAddr = (LPWORD)MapViewOfFile(*pMapHandle, FILE_MAP_WRITE, 0, 0, defaultLen);
    if (pBaseAddr == NULL) {
        return (NULL);
    }

    CopyMemory((LPVOID)pBaseAddr, (LPVOID)GetDefaultSortKeyTable(&hDefaultHandle), defaultLen);

    //
    //  Copy exception information to the table.
    //
    CopyExceptionInfo( (PSORTKEY)(pBaseAddr),
                       pExceptHdr,
                       pExceptTbl,
                       pIdeograph);
    //
    //Close the handle to our default table.  We don't want to leak this.
    //
    if (hDefaultHandle!=NULL && hDefaultHandle!=INVALID_HANDLE_VALUE) {
        CloseHandle(hDefaultHandle);
    }

    return ((PSORTKEY)pBaseAddr);
}



////////////////////////////////////////////////////////////////////////////
//
//  FindExceptionPointers
//
//  Checks to see if any exceptions exist for the given locale id.  If
//  exceptions exist, then TRUE is returned and the pointer to the exception
//  header and the pointer to the exception table are stored in the given
//  parameters.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SortingTable::FindExceptionPointers(
    LCID nLcid,
    PEXCEPT_HDR *ppExceptHdr,
    PEXCEPT *ppExceptTbl,
    PVOID *ppIdeograph)
{
    DWORD ctr;                         // loop counter
    PEXCEPT_HDR pHdr;                  // ptr to exception header
    BOOL bFound = FALSE;               // if an exception is found

    PIDEOGRAPH_LCID pIdeoLcid;         // ptr to ideograph lcid entry

    THROWSCOMPLUSEXCEPTION();
    //
    //  Initialize pointers.
    //
    *ppExceptHdr = NULL;
    *ppExceptTbl = NULL;
    *ppIdeograph = NULL;

    //
    //  Need to search down the exception header for the given nLcid.
    //
    pHdr = m_pExceptHdr;
    for (ctr = m_NumException; ctr > 0; ctr--, pHdr++)
    {
        if (pHdr->Locale == (DWORD)nLcid)
        {
            //
            //  Found the locale id, so set the pointers.
            //
            *ppExceptHdr = pHdr;
            *ppExceptTbl = (PEXCEPT)(((LPWORD)(m_pException)) +
                                     pHdr->Offset);

            //
            //  Set the return code to show that an exception has been
            //  found.
            //
            bFound = TRUE;
            break;
        }
    }

    //
    //  Need to search down the ideograph lcid exception list for the
    //  given locale.
    //
    pIdeoLcid = m_pIdeographLcid;
    for (ctr = m_NumIdeographLcid; ctr > 0; ctr--, pIdeoLcid++)
    {
        if (pIdeoLcid->Locale == (DWORD)nLcid)
        {
            //
            //  Found the locale id, so create/open and map the section
            //  for the appropriate file.
            //
            HANDLE hFileMapping;
            *ppIdeograph = m_pNativeGlobalizationAssembly->MapDataFile(pIdeoLcid->pFileName, pIdeoLcid->pFileName, &hFileMapping);

            //
            //  Set the return code to show that an exception has been
            //  found.
            //
            bFound = TRUE;
            break;
        }
    }

    //
    //  Return the appropriate value.
    //
    return (bFound);
}


////////////////////////////////////////////////////////////////////////////
//
//  CopyExceptionInfo
//
//  Copies the exception information to the given sortkey table.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void SortingTable::CopyExceptionInfo(
    PSORTKEY pSortkey,
    PEXCEPT_HDR pExceptHdr,
    PEXCEPT pExceptTbl,
    PVOID pIdeograph)
{
    DWORD ctr;                    // loop counter
    PIDEOGRAPH_EXCEPT_HDR pHdrIG; // ptr to ideograph exception header
    PIDEOGRAPH_EXCEPT pEntryIG;   // ptr to ideograph exception entry
    PEXCEPT pEntryIGEx;           // ptr to ideograph exception entry ex


    //
    //  For each entry in the exception table, copy the information to the
    //  sortkey table.
    //
    if (pExceptTbl)
    {
        for (ctr = pExceptHdr->NumEntries; ctr > 0; ctr--, pExceptTbl++)
        {
            (pSortkey[pExceptTbl->UCP]).UW.Unicode = pExceptTbl->Unicode;
            (pSortkey[pExceptTbl->UCP]).Diacritic  = pExceptTbl->Diacritic;
            (pSortkey[pExceptTbl->UCP]).Case       = pExceptTbl->Case;
        }
    }

    //
    //  For each entry in the ideograph exception table, copy the
    //  information to the sortkey table.
    //
    if (pIdeograph)
    {
        pHdrIG = (PIDEOGRAPH_EXCEPT_HDR)pIdeograph;
        ctr = pHdrIG->NumEntries;

        if (pHdrIG->NumColumns == 2)
        {
            pEntryIG = (PIDEOGRAPH_EXCEPT)( ((LPBYTE)pIdeograph) +
                                            sizeof(IDEOGRAPH_EXCEPT_HDR) );
            for (; ctr > 0; ctr--, pEntryIG++)
            {
                (pSortkey[pEntryIG->UCP]).UW.Unicode = pEntryIG->Unicode;
            }
        }
        else
        {
            pEntryIGEx = (PEXCEPT)( ((LPBYTE)pIdeograph) +
                                    sizeof(IDEOGRAPH_EXCEPT_HDR) );
            for (; ctr > 0; ctr--, pEntryIGEx++)
            {
                (pSortkey[pEntryIGEx->UCP]).UW.Unicode = pEntryIGEx->Unicode;
                (pSortkey[pEntryIGEx->UCP]).Diacritic  = pEntryIGEx->Diacritic;
                (pSortkey[pEntryIGEx->UCP]).Case       = pEntryIGEx->Case;
            }
        }

        //
        //  Unmap and Close the ideograph section.
        //
        UnmapViewOfFile(pIdeograph);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\csx\makefile.inc ===
csx_copy:
!if "$(TARGETCOMPLUS)" != ""
    xcopy /fry *.csx* $(TARGETCOMPLUS)\docs\*
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\cordbg\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <windows.h>
#include <crtdbg.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <malloc.h>


#include "DebuggerUtil.h"
#include "dshell.h"
#include "__file__.h"

#ifdef _DEBUG

#define RELEASE(iptr)               \
    {                               \
        _ASSERTE(iptr);             \
        iptr->Release();            \
        iptr = NULL;                \
    }

#define VERIFY(stmt) _ASSERTE((stmt))

#else

#define RELEASE(iptr)               \
    iptr->Release();

#define VERIFY(stmt) (stmt)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\unicodecattable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __UNICODECAT_TABLE_H
#define __UNICODECAT_TABLE_H

////////////////////////////////////////////////////////////////////////////
//
//  Class:    CharacterInfoTable
//
//  Authors:  Yung-Shin Bala Lin (YSLin)
//
//  Purpose:  This is the class to map a view of the Unicode category table and 
//            Unicode numeric value table.  It also provides
//            methods to access the Unicode category information.
//
//  Date: 	  August 31, 1999
//
////////////////////////////////////////////////////////////////////////////

typedef struct tagLevel2Offset {
	WORD offset[16];
} Level2Offset, *PLEVEL2OFFSET;

typedef struct {
	WORD categoryTableOffset;	// Offset to the beginning of category table
	WORD numericTableOffset;	// Offset to the beginning of numeric table.
	WORD numericFloatTableOffset;	// Offset to the beginning of numeric float table. This is the result data that will be returned.
} UNICODE_CATEGORY_HEADER, *PUNICODE_CATEGORY_HEADER;

#define LEVEL1_TABLE_SIZE 256

class CharacterInfoTable : public NLSTable {
    public:
    	static CharacterInfoTable* CreateInstance();
    	static CharacterInfoTable* GetInstance();
#ifdef SHOULD_WE_CLEANUP
		static void ShutDown();
#endif /* SHOULD_WE_CLEANUP */

    	
	    CharacterInfoTable();
	    ~CharacterInfoTable();


    	BYTE GetUnicodeCategory(WCHAR wch);
		LPBYTE GetCategoryDataTable();
		LPWORD GetCategoryLevel2OffsetTable();

		LPBYTE GetNumericDataTable();
		LPWORD GetNumericLevel2OffsetTable();
		double* GetNumericFloatData();
	private:
		void InitDataMembers(LPBYTE pDataTable);
	
	    static CharacterInfoTable* m_pDefaultInstance;	   
	    

		PUNICODE_CATEGORY_HEADER m_pHeader;
		LPBYTE m_pByteData;
		LPBYTE m_pLevel1ByteIndex;
		PLEVEL2OFFSET m_pLevel2WordOffset;

		LPBYTE m_pNumericLevel1ByteIndex;
		LPWORD m_pNumericLevel2WordOffset;
		double* m_pNumericFloatData;

	    static const LPSTR m_lpFileName;
	    static const LPWSTR m_lpMappingName;
	    
    	HANDLE m_pMappingHandle;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\classlibnative\nls\unicodecattable.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "NLSTable.h"       // class NLSTable
#include "UnicodeCatTable.h"     // Class declaraction.

CharacterInfoTable* CharacterInfoTable::m_pDefaultInstance = NULL;

const LPSTR CharacterInfoTable::m_lpFileName        = "charinfo.nlp" ;
const LPWSTR CharacterInfoTable::m_lpMappingName    = L"_nlsplus_charinfo_1_0_3627_11_nlp";

/*
    The structure of unicat.nlp:
        The first 256 bytes is the level 1 index for the highest 8 bits (the 8 part),
            and this is pointed by m_pByteData.  The content is an index (which
            has a value in byte range) points to an item in the level 2 index.
        Followed by the the level 1 index is the level 2 index for the highest 4 bits of 
            the lowest 8 bits (the 4 part).  The content is an offset (which has 
            a value in word range) points to an item in the level 3 value table.
        Every item in the level 3 value table has 16 bytes.
 */

CharacterInfoTable::CharacterInfoTable() :
    NLSTable(SystemDomain::SystemAssembly()) {
    LPBYTE pDataTable = (PBYTE)MapDataFile(m_lpMappingName, m_lpFileName, &m_pMappingHandle);
    InitDataMembers(pDataTable);
}

CharacterInfoTable::~CharacterInfoTable() {
#ifdef _USE_NLS_PLUS_TABLE
    //Clean up any resources that we've allocated.
    UnmapViewOfFile((LPCVOID)m_pByteData);
    CloseHandle(m_pMappingHandle);
#else
    // Do nothing here.
#endif
}

#ifdef SHOULD_WE_CLEANUP
void CharacterInfoTable::ShutDown() {
	if (m_pDefaultInstance) {
		delete m_pDefaultInstance;
		m_pDefaultInstance = NULL;
	}
}
#endif /* SHOULD_WE_CLEANUP */

BYTE CharacterInfoTable::GetUnicodeCategory(WCHAR wch) {
    // Access the 8:4:4 table.  The compiler should be smart enough to remove the redundant locals in the following code.
    // These locals are added so that we can debug this easily from the debug build.
    BYTE index1 = m_pLevel1ByteIndex[GET8(wch)];
    WORD offset = m_pLevel2WordOffset[index1].offset[GETHI4(wch)];
    BYTE result = m_pByteData[offset+GETLO4(wch)];
    return (result);
}

CharacterInfoTable* CharacterInfoTable::CreateInstance() {
    if (m_pDefaultInstance != NULL) {
        return (m_pDefaultInstance);
    }

    CharacterInfoTable *pCharacterInfoTable = new CharacterInfoTable();
    
    // Check if m_pDefaultInstance has been set by another thread before the current thread.
    void* result = FastInterlockCompareExchange((LPVOID*)&m_pDefaultInstance, (LPVOID)pCharacterInfoTable, (LPVOID)NULL);
    if (result != NULL)
    {
        // someone got here first.
        delete pCharacterInfoTable;
    }
    return (m_pDefaultInstance);
}

CharacterInfoTable* CharacterInfoTable::GetInstance() {
    _ASSERTE(m_pDefaultInstance != NULL);
    return (m_pDefaultInstance);
}

void CharacterInfoTable::InitDataMembers(LPBYTE pDataTable)
{
    m_pHeader = (PUNICODE_CATEGORY_HEADER)pDataTable;
    m_pByteData = m_pLevel1ByteIndex = pDataTable + m_pHeader->categoryTableOffset;
    m_pLevel2WordOffset = (PLEVEL2OFFSET)(m_pByteData + LEVEL1_TABLE_SIZE);

    m_pNumericLevel1ByteIndex = pDataTable + m_pHeader->numericTableOffset;
    m_pNumericLevel2WordOffset = (LPWORD)(m_pNumericLevel1ByteIndex + LEVEL1_TABLE_SIZE);
    m_pNumericFloatData = (double*)(pDataTable + m_pHeader->numericFloatTableOffset);
}

LPBYTE CharacterInfoTable::GetCategoryDataTable() {
    return (m_pByteData);
}

LPWORD CharacterInfoTable::GetCategoryLevel2OffsetTable() {
    return (LPWORD)(m_pLevel2WordOffset);
}

LPBYTE CharacterInfoTable::GetNumericDataTable() {
    return (m_pNumericLevel1ByteIndex);
}

LPWORD CharacterInfoTable::GetNumericLevel2OffsetTable() {
    return (m_pNumericLevel2WordOffset);
}

double* CharacterInfoTable::GetNumericFloatData() {
    return (m_pNumericFloatData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\cordbg\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//	stdafx.cpp
//
//	Host for precompiled header.
//
//*****************************************************************************
#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\cordbg\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	  "CorDbg.exe"
#define VER_INTERNALNAME_WSTR	 L"CorDbg.exe"
#define VER_FILEDESCRIPTION_STR   "Microsoft (R) Common Language Runtime Test Debugger Shell\0"
#define VER_FILEDESCRIPTION_WSTR L"Microsoft (R) Common Language Runtime Test Debugger Shell\0"
#define VER_ORIGFILENAME_STR      "cordbg.exe\0"
#define VER_ORIGFILENAME_WSTR    L"cordbg.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\cordbg\cordbg.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "stdafx.h"

#include "dshell.h"

#ifdef _INTERNAL_DEBUG_SUPPORT_
#include "__file__.ver"
#else
#include "__file__.h"
#endif
#include "corver.h"

#define WHITESPACE_W L"\t \n" 

int _cdecl wmain(int argc, WCHAR *argv[])
{
    DebuggerShell *shell;

    // Ensure that cordbg will work with remote. Remote doesn't like
    // buffered output, so we remove the default buffer from stdout
    // with this call.
    setbuf(stdout, NULL);

    // The default "C" locale can't convert true unicode
    // characters into mbcs for printing on the console. So we set the
    // locale to the default ansi code page on the current
    // system. This does the right thing even on non-English systems.
    setlocale(LC_ALL, ".ACP");
    
    shell = new DebuggerShell(stdin, stdout);

    if (shell == NULL)
    {
        fprintf(stderr, "Initialization failed. Reason: out of memory.\n");
        return (-1);
    }

#ifdef _INTERNAL_DEBUG_SUPPORT_
    shell->Write(L"%s Version %s\n", VER_FILEDESCRIPTION_WSTR, VER_FILEVERSION_WSTR);
#else
    shell->Write(L"%s.\n", VER_FILEDESCRIPTION_WSTR);
#endif

    shell->Write(L"%s\n\n", VER_LEGALCOPYRIGHT_DOS_STR);

    HRESULT hr = shell->Init();

    if ((argc > 1) && ((argv[1][0] == '/' || argv[1][0] == '-') && argv[1][1] == '?'))
    {
        shell->Write(L"Usage:  CORDBG [<program name> [<program args>]] [<CorDbg optional args>]\n");   
        shell->Write(L" The optional arguments are !prefixed command that you'd use while in cordbg\n");
        shell->Write(L" You can escape the ! character by prefixing it with \\\n"); 
        shell->Write(L" E.g: cordbg foo.exe a 2 !b FooType.Foo::Main !g !x Foo.exe\\!Something\n");
        shell->Help();
        
        delete shell;
        return (0);
    }
    

    if (SUCCEEDED(hr))
    {
        //
        // Process command line arguments
        //
        if (argc > 1)
        {
            int cmdLen = 1;  // Start at one to handle the null char

            if (argv[1][0] != '!')
            {
                cmdLen += 5;  // Implied "!run " command
            }

            for (int i = 1; i < argc; i++)
            {
                cmdLen += wcslen(argv[i]) + 1;  // Add one to handle space between args

                // If the arg has a space in it, then it must have been quoted
                // when it was given to us, so we want to preserve the quoting so that
                // the debuggee will get the arg as a single, quoted blob, as well.
                if (wcspbrk( argv[i], WHITESPACE_W) != NULL)
                    cmdLen += 2; // we'll have to pre-&post-pend double quotes (")
            }

            // Allocate the string on the stack
            WCHAR *command = (WCHAR *) _alloca(cmdLen * sizeof(WCHAR));
            command[0] = L'\0';

            if (argv[1][0] != L'!')
            {
                wcscpy(command, L"!run ");  // Implied "!run " command
            }

            for (WCHAR **arg = &(argv[1]), 
                 **end = &(argv[0]) + argc,
                 i = 1;
                 arg < end; arg++, i++)
            {
                _ASSERTE(i<argc);
                
                if (wcspbrk( argv[i], WHITESPACE_W) != NULL)
                    wcscat(command, L"\""); // pre-pend double quotes (")
                    
                wcscat(command, *arg);

                if (wcspbrk( argv[i], WHITESPACE_W) != NULL)
                    wcscat(command, L"\""); // post-pend double quotes (")
                    
                if (arg + 1 != end)
                {
                    wcscat(command, L" ");
                }
            }

            //
            // Go through the command line and execute the various commands
            //
            for (WCHAR *cmd = NULL, *ptr = command; *ptr != L'\0'; ptr++)
            {
                // If we see \!, then we've escaped it so we can feed
                // commands like x hello.exe\!something on the command line
                if (*ptr == L'\\' && *(ptr + 1) == L'!')
                {
                    memmove((ptr), ptr+1, (cmdLen - (ptr-command))*sizeof(WCHAR));
                    ptr++;
                }
            
                if (*ptr == L'!' || *(ptr + 1) == L'\0')
                {
                    // Overwrite '!' with null char to terminate current command
                    if (*ptr == L'!')
                    {
                        *ptr = L'\0';

                        // Get rid of trailing spaces on commands
                        if (ptr > command)
                        {
                            *(ptr-1) = L'\0';
                        }
                    }

                    // If we've reached the end of a command, execute it
                    if (cmd != NULL)
                    {
                        shell->Write(shell->GetPrompt());
                        shell->Write(L" %s\n", cmd);
                        shell->DoCommand(cmd);
                    }

                    // Save the beginning of the next command
                    cmd = ptr + 1;
                }
            }
        }

        // Read commands from the user prompt
        while (!shell->m_quit)
            shell->ReadCommand();
    }
    else
    {
        shell->Write(L"Initialization failed. Reason: ");
        shell->ReportError(hr);
    }

    delete shell;

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\breakpoint.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: breakpoint.cpp
//
//*****************************************************************************
#include "stdafx.h"

/* ------------------------------------------------------------------------- *
 * Breakpoint class
 * ------------------------------------------------------------------------- */

CordbBreakpoint::CordbBreakpoint(CordbBreakpointType bpType)
  : CordbBase(0), m_active(false), m_type(bpType)
{
}

// Neutered by CordbAppDomain
void CordbBreakpoint::Neuter()
{
    AddRef();
    {
        CordbBase::Neuter();
    }
    Release();
}

HRESULT CordbBreakpoint::QueryInterface(REFIID id, void **pInterface)
{
	if (id == IID_ICorDebugBreakpoint)
		*pInterface = (ICorDebugBreakpoint*)this;
	else if (id == IID_IUnknown)
		*pInterface = (IUnknown *)(ICorDebugBreakpoint*)this;
	else
		return E_NOINTERFACE;

	AddRef();
	return S_OK;
}

HRESULT CordbBreakpoint::BaseIsActive(BOOL *pbActive)
{
	*pbActive = m_active ? TRUE : FALSE;

	return S_OK;
}

/* ------------------------------------------------------------------------- *
 * Function Breakpoint class
 * ------------------------------------------------------------------------- */

CordbFunctionBreakpoint::CordbFunctionBreakpoint(CordbCode *code,
                                                 SIZE_T offset)
  : CordbBreakpoint(CBT_FUNCTION), m_code(code), m_offset(offset)
{
    // Remember the app domain we came from so that breakpoints can be
    // deactivated from within the ExitAppdomain callback.
    m_pAppDomain = m_code->GetAppDomain();
    _ASSERTE(m_pAppDomain != NULL);
}
	
HRESULT CordbFunctionBreakpoint::QueryInterface(REFIID id, void **pInterface)
{
	if (id == IID_ICorDebugFunctionBreakpoint)
		*pInterface = (ICorDebugFunctionBreakpoint*)this;
	else if (id == IID_IUnknown)
		*pInterface = (IUnknown *)(ICorDebugFunctionBreakpoint*)this;
	else
		return E_NOINTERFACE;

	AddRef();
	return S_OK;
}

HRESULT CordbFunctionBreakpoint::GetFunction(ICorDebugFunction **ppFunction)
{
    VALIDATE_POINTER_TO_OBJECT(ppFunction, ICorDebugFunction **);

	if (m_code == NULL)
		return CORDBG_E_PROCESS_TERMINATED;

	*ppFunction = (ICorDebugFunction*) m_code->m_function;
	(*ppFunction)->AddRef();

	return S_OK;
}

HRESULT CordbFunctionBreakpoint::GetOffset(ULONG32 *pnOffset)
{
    VALIDATE_POINTER_TO_OBJECT(pnOffset, SIZE_T *);
    
	*pnOffset = m_offset;

	return S_OK;
}

HRESULT CordbFunctionBreakpoint::Activate(BOOL bActive)
{
    if (bActive == (m_active == true) )
        return S_OK;

    if (m_code == NULL)
        return CORDBG_E_PROCESS_TERMINATED;

    CORDBLeftSideDeadIsOkay(GetProcess());

    HRESULT hr;

    //
    // @todo: when we implement module and value breakpoints, then
    // we'll want to factor some of this code out.
    //
    CordbProcess *process = GetProcess();
    process->ClearPatchTable(); //if we add something, then the
    //right side view of the patch table is no longer valid
    DebuggerIPCEvent *event = 
      (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);

    CordbAppDomain *pAppDomain = GetAppDomain();
    _ASSERTE (pAppDomain != NULL);
    if (bActive)
    {
        CORDBRequireProcessStateOK(GetProcess());

        CORDBSyncFromWin32StopIfStopped(GetProcess());

        process->InitIPCEvent(event, 
                              DB_IPCE_BREAKPOINT_ADD, 
                              true,
                              (void *)pAppDomain->m_id);
        event->BreakpointData.funcMetadataToken
          = m_code->m_function->m_token;
        event->BreakpointData.funcDebuggerModuleToken
          = (void *) m_code->m_function->m_module->m_debuggerModuleToken;
        event->BreakpointData.isIL = m_code->m_isIL ? true : false;
        event->BreakpointData.offset = m_offset;
        event->BreakpointData.breakpoint = this;

        // Note: we're sending a two-way event, so it blocks here
        // until the breakpoint is really added and the reply event is
        // copied over the event we sent.
        hr = process->SendIPCEvent(event, CorDBIPC_BUFFER_SIZE);
        if (FAILED(hr))
            return hr;

        // If something went wrong, bail.
        if (FAILED(event->hr))
            return event->hr;
            
        m_id = (unsigned long)event->BreakpointData.breakpointToken;

        // If we weren't able to allocate the BP, we should have set the
        // hr on the left side.
        _ASSERTE(m_id != 0);

        pAppDomain->Lock();

        pAppDomain->m_breakpoints.AddBase(this);
        m_active = true;

        pAppDomain->Unlock();
    }
    else
    {
        CordbAppDomain *pAppDomain = GetAppDomain();	
        _ASSERTE (pAppDomain != NULL);

        if (CORDBCheckProcessStateOK(process) && (pAppDomain->m_fAttached == TRUE))
        {
            CORDBSyncFromWin32StopIfStopped(GetProcess());

            process->InitIPCEvent(event, 
                                  DB_IPCE_BREAKPOINT_REMOVE, 
                                  false,
                                  (void *)pAppDomain->m_id);
            event->BreakpointData.breakpointToken = (void *) m_id; 

            hr = process->SendIPCEvent(event, CorDBIPC_BUFFER_SIZE);
        }
        else
            hr = CORDBHRFromProcessState(process, pAppDomain);
        
		pAppDomain->Lock();

		pAppDomain->m_breakpoints.RemoveBase(m_id);
		m_active = false;

		pAppDomain->Unlock();
	
	}

	return hr;
}

void CordbFunctionBreakpoint::Disconnect()
{
	m_code = NULL;
}

/* ------------------------------------------------------------------------- *
 * Stepper class
 * ------------------------------------------------------------------------- */

CordbStepper::CordbStepper(CordbThread *thread, CordbFrame *frame)
  : CordbBase(0), m_thread(thread), m_frame(frame),
    m_stepperToken(0), m_active(false),
	m_rangeIL(TRUE), m_rgfMappingStop(STOP_OTHER_UNMAPPED),
    m_rgfInterceptStop(INTERCEPT_NONE)
{
}

HRESULT CordbStepper::QueryInterface(REFIID id, void **pInterface)
{
	if (id == IID_ICorDebugStepper)
		*pInterface = (ICorDebugStepper *) this;
	else if (id == IID_IUnknown)
		*pInterface = (IUnknown *) (ICorDebugStepper *) this;
	else
		return E_NOINTERFACE;

	AddRef();
	return S_OK;
}

HRESULT CordbStepper::SetRangeIL(BOOL bIL)
{
	m_rangeIL = (bIL != FALSE);

	return S_OK;
}

HRESULT CordbStepper::IsActive(BOOL *pbActive)
{
    VALIDATE_POINTER_TO_OBJECT(pbActive, BOOL *);
    
	*pbActive = m_active;

	return S_OK;
}

HRESULT CordbStepper::Deactivate()
{
	if (!m_active)
		return S_OK;

	if (m_thread == NULL)
		return CORDBG_E_PROCESS_TERMINATED;

    CORDBLeftSideDeadIsOkay(GetProcess());
    CORDBSyncFromWin32StopIfNecessary(GetProcess());
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());

	CordbProcess *process = GetProcess();

	process->Lock();

	if (!m_active) // another thread may be deactivating (e.g. step complete event)
	{
		process->Unlock();
		return S_OK;
	}

	CordbAppDomain *pAppDomain = GetAppDomain();	
	_ASSERTE (pAppDomain != NULL);

	DebuggerIPCEvent event;
    process->InitIPCEvent(&event, 
                          DB_IPCE_STEP_CANCEL, 
                          false,
                          (void *)(pAppDomain->m_id));
	event.StepData.stepperToken = (void *) m_id; 

	HRESULT hr = process->SendIPCEvent(&event, sizeof(DebuggerIPCEvent));

//  pAppDomain->Lock();

	process->m_steppers.RemoveBase(m_id);
	m_active = false;

//  pAppDomain->Unlock();

	process->Unlock();

	return hr;
}

HRESULT CordbStepper::SetInterceptMask(CorDebugIntercept mask)
{
    m_rgfInterceptStop = mask;
    return S_OK;
}

HRESULT CordbStepper::SetUnmappedStopMask(CorDebugUnmappedStop mask)
{
    // You must be Win32 attached to stop in unmanaged code.
    if ((mask & STOP_UNMANAGED) &&
        !(GetProcess()->m_state & CordbProcess::PS_WIN32_ATTACHED))
        return E_INVALIDARG;
    
    m_rgfMappingStop = mask;
    return S_OK;
}

HRESULT CordbStepper::Step(BOOL bStepIn)
{
	if (m_thread == NULL)
		return CORDBG_E_PROCESS_TERMINATED;

    CORDBSyncFromWin32StopIfNecessary(GetProcess());
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());

	return StepRange(bStepIn, NULL, 0);
}

HRESULT CordbStepper::StepRange(BOOL bStepIn, 
								COR_DEBUG_STEP_RANGE ranges[], 
								ULONG32 cRangeCount)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY_OR_NULL(ranges,COR_DEBUG_STEP_RANGE, 
                                   cRangeCount, true, true);

	if (m_thread == NULL)
		return CORDBG_E_PROCESS_TERMINATED;

    CORDBSyncFromWin32StopIfNecessary(GetProcess());
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());

	if (m_active)
	{
		//
		// Deactivate the current stepping. 
		// or return an error???
		//

		HRESULT hr = Deactivate();

        if (FAILED(hr))
            return hr;
	}

	CordbProcess *process = GetProcess();

	//
	// Build step event
	//

	DebuggerIPCEvent *event = 
	  (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);

    process->InitIPCEvent(event, 
                          DB_IPCE_STEP, 
                          true,
                          (void*)(GetAppDomain()->m_id));
	event->StepData.stepper = this;
	event->StepData.threadToken = m_thread->m_debuggerThreadToken;
    event->StepData.rgfMappingStop = m_rgfMappingStop;
    event->StepData.rgfInterceptStop = m_rgfInterceptStop;
    
	if (m_frame == NULL)
		event->StepData.frameToken = NULL;
	else
		event->StepData.frameToken = (void*) m_frame->m_id;

	event->StepData.stepIn = bStepIn != 0;

	event->StepData.totalRangeCount = cRangeCount;
	event->StepData.rangeIL = m_rangeIL;

	//
	// Send ranges.  We may have to send > 1 message.
	//

	COR_DEBUG_STEP_RANGE *rStart = &event->StepData.range;
	COR_DEBUG_STEP_RANGE *rEnd = ((COR_DEBUG_STEP_RANGE *) 
								  (((BYTE *)event) + 
								   CorDBIPC_BUFFER_SIZE)) - 1;
	int n = cRangeCount;
	if (n > 0)
	{
		while (n > 0)
		{
			COR_DEBUG_STEP_RANGE *r = rStart;

			if (n < rEnd - r)
				rEnd = r + n;

			while (r < rEnd)
				*r++ = *ranges++;

			n -= event->StepData.rangeCount = r - rStart;

			//
			// Send step event (two-way event here...)
			//

			HRESULT hr = process->SendIPCEvent(event,
                                               CorDBIPC_BUFFER_SIZE);
            if (FAILED(hr))
                return hr;
		}
	}
	else
	{
		//
		// Send step event without any ranges (two-way event here...)
		//

		HRESULT hr = process->SendIPCEvent(event,
                                           CorDBIPC_BUFFER_SIZE);

        if (FAILED(hr))
            return hr;
	}

	m_id = (unsigned long) event->StepData.stepperToken;

    LOG((LF_CORDB,LL_INFO10000, "CS::SR: m_id:0x%x | 0x%x \n", m_id, 
        event->StepData.stepperToken));

	CordbAppDomain *pAppDomain = GetAppDomain();	
	_ASSERTE (pAppDomain != NULL);

//  pAppDomain->Lock();
    process->Lock();

	process->m_steppers.AddBase(this);
	m_active = true;

//    pAppDomain->Unlock();
    process->Unlock();

	return S_OK;
}

HRESULT CordbStepper::StepOut()
{
	if (m_thread == NULL)
		return CORDBG_E_PROCESS_TERMINATED;

    CORDBSyncFromWin32StopIfNecessary(GetProcess());
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());

	if (m_active)
	{
		//
		// Deactivate the current stepping. 
		// or return an error???
		//

		HRESULT hr = Deactivate();

        if (FAILED(hr))
            return hr;
	}

	CordbProcess *process = GetProcess();

	//
	// Build step event
	//

	DebuggerIPCEvent *event = 
	  (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);

    process->InitIPCEvent(event, 
                          DB_IPCE_STEP_OUT, 
                          true,
                          (void*)(GetAppDomain()->m_id));
	event->StepData.stepper = this;
	event->StepData.threadToken = m_thread->m_debuggerThreadToken;
    event->StepData.rgfMappingStop = m_rgfMappingStop;
    event->StepData.rgfInterceptStop = m_rgfInterceptStop;

	if (m_frame == NULL)
		event->StepData.frameToken = NULL;
	else
		event->StepData.frameToken = (void*) m_frame->m_id;

	event->StepData.totalRangeCount = 0;

    // Note: two-way event here...
	HRESULT hr = process->SendIPCEvent(event, CorDBIPC_BUFFER_SIZE);

    if (FAILED(hr))
        return hr;

	m_id = (unsigned long) event->StepData.stepperToken;

	CordbAppDomain *pAppDomain = GetAppDomain();	
	_ASSERTE (pAppDomain != NULL);

    //AppDomain->Lock(); 
    process->Lock();

	process->m_steppers.AddBase(this);
	m_active = true;

    //pAppDomain->Unlock(); 
    process->Unlock();
	
	return S_OK;
}

void CordbStepper::Disconnect()
{
	m_thread = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\common.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "StdAfx.h"


// Skips past the calling convention, argument count (saving that into
// *pCount), then moves past the return type.
ULONG _skipMethodSignatureHeader(PCCOR_SIGNATURE sig,
                                 ULONG *pCount)
{
    ULONG tmp;
    ULONG cb = 0;

    cb += CorSigUncompressData(&sig[0], &tmp);
    _ASSERTE(tmp != IMAGE_CEE_CS_CALLCONV_FIELD);

    cb += CorSigUncompressData(&sig[cb], pCount);
    cb += _skipTypeInSignature(&sig[cb]);

    return cb;
}

//
// _skipTypeInSignature -- skip past a type in a given signature.
// Returns the number of bytes used by the type in the signature.
//
// @todo: just yanked this from the shell. We really need something in
// utilcode to do this stuff...
//
ULONG _skipTypeInSignature(PCCOR_SIGNATURE sig, bool *pfPassedVarArgSentinel)
{
    ULONG cb = 0;
    ULONG elementType;

    if (pfPassedVarArgSentinel != NULL)
        *pfPassedVarArgSentinel = false;

    cb += _skipFunkyModifiersInSignature(&sig[cb]);

    if (_detectAndSkipVASentinel(&sig[cb]))
    {
        cb += _detectAndSkipVASentinel(&sig[cb]);
        // Recursively deal with the real type.
        cb += _skipTypeInSignature(&sig[cb], pfPassedVarArgSentinel);

        if (pfPassedVarArgSentinel != NULL)
            *pfPassedVarArgSentinel = true;
    }
    else
    {
        cb += CorSigUncompressData(&sig[cb], &elementType);
    
        if ((elementType == ELEMENT_TYPE_CLASS) ||
            (elementType == ELEMENT_TYPE_VALUETYPE))
        {
            // Skip over typeref.
            mdToken typeRef;
            cb += CorSigUncompressToken(&sig[cb], &typeRef);
        }
        else if ((elementType == ELEMENT_TYPE_PTR) ||
                 (elementType == ELEMENT_TYPE_BYREF) ||
                 (elementType == ELEMENT_TYPE_PINNED) ||
                 (elementType == ELEMENT_TYPE_SZARRAY))
        {
            // Skip over extra embedded type.
            cb += _skipTypeInSignature(&sig[cb]);
        }
        else if ((elementType == ELEMENT_TYPE_ARRAY) ||
                 (elementType == ELEMENT_TYPE_ARRAY))
        {
            // Skip over extra embedded type.
            cb += _skipTypeInSignature(&sig[cb]);

        // Skip over rank
            ULONG rank;
            cb += CorSigUncompressData(&sig[cb], &rank);

            if (rank > 0)
            {
                // how many sizes?
                ULONG sizes;
                cb += CorSigUncompressData(&sig[cb], &sizes);

                // read out all the sizes
                unsigned int i;

                for (i = 0; i < sizes; i++)
                {
                    ULONG dimSize;
                    cb += CorSigUncompressData(&sig[cb], &dimSize);
                }

                // how many lower bounds?
                ULONG lowers;
                cb += CorSigUncompressData(&sig[cb], &lowers);

            // read out all the lower bounds.
                for (i = 0; i < lowers; i++)
                {
                    int lowerBound;
                    cb += CorSigUncompressSignedInt(&sig[cb], &lowerBound);
                }
            }
        }  else if ( (elementType == ELEMENT_TYPE_FNPTR) )
        {
            // We've got a method signature within this signature,
            // so traverse it

            // Run past the calling convetion, then get the
            // arg count, and return type   

            ULONG cArgs;
            cb += _skipMethodSignatureHeader(&sig[cb], &cArgs);
            // @TODO an interesting issue is how to detect if this embedded
            // signature has  a 'this' arguments

            ULONG i;
            for(i = 0; i < cArgs; i++)
            {
                cb += _skipTypeInSignature(&sig[cb]);
            }
        }
    }
    
    return (cb);
}


ULONG _detectAndSkipVASentinel(PCCOR_SIGNATURE sig)
{
    ULONG cb = 0;
    ULONG elementType = ELEMENT_TYPE_MAX;

    cb += CorSigUncompressData(sig, &elementType);

    if (CorIsModifierElementType((CorElementType)elementType) &&
               (elementType == ELEMENT_TYPE_SENTINEL))
    {
        return cb;
    }
    else
    {
        return 0;
    }
}
    
// _skipFunkyModifiersInSignature will skip the modifiers that
// we don't care about.  Everything we care about is listed as
// a case in CreateValueByType.  Specifically, we care about:
// @todo This name is bad.  Change it to _skipModifiers, or
// perhaps _skipIgnorableModifiers
ULONG _skipFunkyModifiersInSignature(PCCOR_SIGNATURE sig)
{
    ULONG cb = 0;
    ULONG skippedCB = 0;
    ULONG elementType;

    // Need to skip all funky modifiers in the signature to get us to
    // the first bit of good stuff.
    do
    {
        cb = CorSigUncompressData(&sig[skippedCB], &elementType);

        switch( elementType )
        {
        case ELEMENT_TYPE_CMOD_REQD:
        case ELEMENT_TYPE_CMOD_OPT:
            {    
                mdToken typeRef;
                skippedCB += cb;
                skippedCB += CorSigUncompressToken(&sig[skippedCB], &typeRef);

                break;
            }
        case ELEMENT_TYPE_MAX:
            {
                _ASSERTE( !"_skipFunkyModifiersInSignature:Given an invalid type!" );
                break;
            }
        
        case ELEMENT_TYPE_MODIFIER:
        case ELEMENT_TYPE_PINNED:
            {
                // Since these are all followed by another ELEMENT_TYPE,
                // we're done.
                skippedCB += cb;
                break;
            }
        default:
            {
                // Since we didn't find any modifiers, don't skip 
                // anything.
                cb = 0;
                break;
            }
        }
    } while (cb > 0);

    return skippedCB;
}

ULONG _sizeOfElementInstance(PCCOR_SIGNATURE sig, mdTypeDef *pmdValueClass)
{

    ULONG cb = _skipFunkyModifiersInSignature(sig);
    sig = &sig[cb];
        
    if (pmdValueClass != NULL)
        *pmdValueClass = mdTokenNil;

    switch (*sig)
    {
    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
    case ELEMENT_TYPE_R8:
        return 8;

    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_R4:
#ifdef _X86_
    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:        
#endif // _X86_
        
        return 4;
        break;

    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        return 2;

    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        return 1;

    case ELEMENT_TYPE_STRING:
    case ELEMENT_TYPE_PTR:
    case ELEMENT_TYPE_BYREF:
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_FNPTR:
    case ELEMENT_TYPE_TYPEDBYREF:
    case ELEMENT_TYPE_ARRAY:
    case ELEMENT_TYPE_SZARRAY:
        return sizeof(void *);

    case ELEMENT_TYPE_VOID:
        return 0;

    case ELEMENT_TYPE_END:
    case ELEMENT_TYPE_CMOD_REQD:
    case ELEMENT_TYPE_CMOD_OPT:
        _ASSERTE(!"Asked for the size of an element that doesn't have a size!");
        return 0;

    case ELEMENT_TYPE_VALUETYPE:
        if (pmdValueClass != NULL)
        {
            PCCOR_SIGNATURE sigTemp = &sig[cb];
            ULONG Ignore;
            cb += CorSigUncompressData(sigTemp, &Ignore);
            sigTemp = &sig[cb];
            *pmdValueClass=CorSigUncompressToken(sigTemp);
        }
        return 0;
    default:
        if ( _detectAndSkipVASentinel(sig))
        {
            cb += _detectAndSkipVASentinel(sig);
            return _sizeOfElementInstance(&sig[cb]);
        }
        
        _ASSERTE( !"_sizeOfElementInstance given bogus value to size!" );
        return 0;
    }
}

//
// CopyThreadContext does an intelligent copy from c2 to c1,
// respecting the ContextFlags of both contexts.
//
void _CopyThreadContext(CONTEXT *c1, CONTEXT *c2)
{
#ifdef _X86_ // Reliance on contexts registers
    DWORD c1Flags = c1->ContextFlags;
    DWORD c2Flags = c2->ContextFlags;

    LOG((LF_CORDB, LL_INFO1000000,
         "CP::CTC: c1=0x%08x c1Flags=0x%x, c2=0x%08x c2Flags=0x%x\n",
         c1, c1Flags, c2, c2Flags));

#define CopyContextChunk(_t, _f, _e, _c) {\
        LOG((LF_CORDB, LL_INFO1000000, \
             "CP::CTC: copying " #_c  ": 0x%08x <--- 0x%08x (%d)\n", \
             (_t), (_f), ((UINT_PTR)(_e) - (UINT_PTR)_t))); \
        memcpy((_t), (_f), ((UINT_PTR)(_e) - (UINT_PTR)_t)); \
    }
    
    if ((c1Flags & c2Flags & CONTEXT_CONTROL) == CONTEXT_CONTROL)
        CopyContextChunk(&(c1->Ebp), &(c2->Ebp), c1->ExtendedRegisters,
                         CONTEXT_CONTROL);
    
    if ((c1Flags & c2Flags & CONTEXT_INTEGER) == CONTEXT_INTEGER)
        CopyContextChunk(&(c1->Edi), &(c2->Edi), &(c1->Ebp),
                         CONTEXT_INTEGER);
    
    if ((c1Flags & c2Flags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS)
        CopyContextChunk(&(c1->SegGs), &(c2->SegGs), &(c1->Edi),
                         CONTEXT_SEGMENTS);
    
    if ((c1Flags & c2Flags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT)
        CopyContextChunk(&(c1->FloatSave), &(c2->FloatSave),
                         &(c1->SegGs),
                         CONTEXT_FLOATING_POINT);
    
    if ((c1Flags & c2Flags & CONTEXT_DEBUG_REGISTERS) ==
        CONTEXT_DEBUG_REGISTERS)
        CopyContextChunk(&(c1->Dr0), &(c2->Dr0), &(c1->FloatSave),
                         CONTEXT_DEBUG_REGISTERS);
    
    if ((c1Flags & c2Flags & CONTEXT_EXTENDED_REGISTERS) ==
        CONTEXT_EXTENDED_REGISTERS)
        CopyContextChunk(c1->ExtendedRegisters,
                         c2->ExtendedRegisters,
                         &(c1->ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION]),
                         CONTEXT_EXTENDED_REGISTERS);
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - CopyThreadContext (Process.cpp)");
#endif // _X86_
}


HRESULT FindNativeInfoInILVariableArray(DWORD dwIndex,
                                        SIZE_T ip,
                                        ICorJitInfo::NativeVarInfo **ppNativeInfo,
                                        unsigned int nativeInfoCount,
                                        ICorJitInfo::NativeVarInfo *nativeInfo)
{
    // A few words about this search: it must be linear, and the
    // comparison of startOffset and endOffset to ip must be
    // <=/>. startOffset points to the first instruction that will
    // make the variable's home valid. endOffset points to the first
    // instruction at which the variable's home invalid.
    int lastGoodOne = -1;
    for (unsigned int i = 0; i < nativeInfoCount; i++)
    {
        if (nativeInfo[i].varNumber == dwIndex)
        {
            lastGoodOne = i;
            
            if ((nativeInfo[i].startOffset <= ip) &&
                (nativeInfo[i].endOffset > ip))
            {
                *ppNativeInfo = &nativeInfo[i];

                return S_OK;
            }
        }
    }

    // Hmmm... didn't find it. Was the endOffset of the last range for
    // this variable equal to the current IP? If so, go ahead and
    // report that as the variable's home for now.
    //
    // The rational here is that by being on the first instruction
    // after the last range a variable was alive, we're essentially
    // assuming that since that instruction hasn't been executed yet,
    // and since there isn't a new home for the variable, that the
    // last home is still good. This actually turns out to be true
    // 99.9% of the time, so we'll go with it for now.
    //
    // -- Thu Sep 23 15:38:27 1999

    if ((lastGoodOne > -1) && (nativeInfo[lastGoodOne].endOffset == ip))
    {
        *ppNativeInfo = &nativeInfo[lastGoodOne];
        return S_OK;
    }

    return CORDBG_E_IL_VAR_NOT_AVAILABLE;
}

// The 'internal' version of our IL to Native map (the DebuggerILToNativeMap struct)
// has an extra field - ICorDebugInfo::SourceTypes source.  The 'external/user-visible'
// version (COR_DEBUG_IL_TO_NATIVE_MAP) lacks that field, so we need to translate our
// internal version to the external version.
// "Export" seemed more succinct than "CopyInternalToExternalILToNativeMap" :)
void ExportILToNativeMap(ULONG32 cMap,             // [in] Min size of mapExt, mapInt
             COR_DEBUG_IL_TO_NATIVE_MAP mapExt[],  // [in] Filled in here
             struct DebuggerILToNativeMap mapInt[],// [in] Source of info
             SIZE_T sizeOfCode)                    // [in] Total size of method (bytes)
{
    ULONG32 iMap;
    _ASSERTE(mapExt != NULL);
    _ASSERTE(mapInt != NULL);

    for(iMap=0; iMap < cMap; iMap++)
    {
        mapExt[iMap].ilOffset = mapInt[iMap].ilOffset ;
        mapExt[iMap].nativeStartOffset = mapInt[iMap].nativeStartOffset ;
        mapExt[iMap].nativeEndOffset = mapInt[iMap].nativeEndOffset ;

        // An element that has an end offset of zero, means "till the end of
        // the method".  Pretty this up so that customers don't have to care about
        // this.
        if ((DWORD)mapInt[iMap].source & (DWORD)ICorDebugInfo::NATIVE_END_OFFSET_UNKNOWN)
        {
            mapExt[iMap].nativeEndOffset = sizeOfCode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\classfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ClassFactory.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************
#ifndef __ClassFactory__h__
#define __ClassFactory__h__

#include <cordb.h>						// Public header definitions.


// This typedef is for a function which will create a new instance of an object.
typedef HRESULT (* PFN_CREATE_OBJ)(REFIID riid, void **ppvObject);

//*****************************************************************************
// This structure is used to declare a global list of coclasses.  The class
// factory object is created with a pointer to the correct one of these, so
// that when create instance is called, it can be created.
//*****************************************************************************
struct COCLASS_REGISTER
{
	const GUID *pClsid;					// Class ID of the coclass.
	LPCWSTR		szProgID;				// Prog ID of the class.
	PFN_CREATE_OBJ pfnCreateObject;		// Creation function for an instance.
};



//*****************************************************************************
// One class factory object satifies all of our clsid's, to reduce overall 
// code bloat.
//*****************************************************************************
class CClassFactory :
	public IClassFactory
{
	CClassFactory() { }						// Can't use without data.
	
public:
	CClassFactory(const COCLASS_REGISTER *pCoClass)
		: m_cRef(1), m_pCoClass(pCoClass)
	{ }

	
	//
	// IUnknown methods.
	//

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        REFIID		riid,
        void		**ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return (InterlockedIncrement((long *) &m_cRef));
	}
    
    virtual ULONG STDMETHODCALLTYPE Release()
	{
		long		cRef = InterlockedDecrement((long *) &m_cRef);
		if (cRef <= 0)
			delete this;
		return (cRef);
	}


	//
	// IClassFactory methods.
	//

    virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
        IUnknown	*pUnkOuter,
        REFIID		riid,
        void		**ppvObject);
    
    virtual HRESULT STDMETHODCALLTYPE LockServer( 
        BOOL		fLock);


private:
	DWORD		m_cRef;						// Reference count.
	const COCLASS_REGISTER *m_pCoClass;		// The class we belong to.
};



#endif // __ClassFactory__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\hash.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: hash.cpp
//
//*****************************************************************************
#ifndef RIGHT_SIDE_ONLY
#include "EEConfig.h"
#endif

#include "stdafx.h"

#ifdef UNDEFINE_RIGHT_SIDE_ONLY
#undef RIGHT_SIDE_ONLY
#endif //UNDEFINE_RIGHT_SIDE_ONLY

/* ------------------------------------------------------------------------- *
 * Hash Table class
 * ------------------------------------------------------------------------- */

CordbHashTable::~CordbHashTable()
{
    INPROC_LOCK();

    HASHFIND    find;

    for (CordbHashEntry *entry = (CordbHashEntry *) FindFirstEntry(&find);
         entry != NULL;
         entry = (CordbHashEntry *) FindNextEntry(&find))
        entry->pBase->Release();

    INPROC_UNLOCK();
}

HRESULT CordbHashTable::AddBase(CordbBase *pBase)
{ 
    HRESULT hr = S_OK;

    INPROC_LOCK();

    if (!m_initialized)
    {
        HRESULT res = NewInit(m_iBuckets, sizeof(CordbHashEntry), 0xffff);

        if (res != S_OK)
        {
            INPROC_UNLOCK();
            return res;
        }

        m_initialized = true;
    }

    CordbHashEntry *entry = (CordbHashEntry *) Add(HASH(pBase->m_id));

    if (entry == NULL)
    {
        hr = E_FAIL;
    }
    else
    {
        entry->pBase = pBase;
        m_count++;
        pBase->AddRef();
    }

    INPROC_UNLOCK();

    return hr;
}

#ifndef RIGHT_SIDE_ONLY        
CordbBase *CordbHashTable::GetBase(ULONG id, BOOL fFab, SpecialCasePointers *scp)
#else
CordbBase *CordbHashTable::GetBase(ULONG id, BOOL fFab)
#endif //RIGHT_SIDE_ONLY
{ 
    INPROC_LOCK();

    CordbHashEntry *entry = NULL;

#ifndef RIGHT_SIDE_ONLY
    HRESULT hr = S_OK;
    CordbBase *pRet = NULL;
    

    if (!m_initialized)
    {
        hr = NewInit(m_iBuckets, 
                     sizeof(CordbHashEntry), 0xffff);
        if (hr != S_OK)
            goto LExit;

        m_initialized = true;
    }

#else // RIGHT_SIDE_ONLY

    if (!m_initialized)
        return (NULL);
        
#endif // RIGHT_SIDE_ONLY

    entry = (CordbHashEntry *) Find(HASH(id), KEY(id)); 

#ifdef RIGHT_SIDE_ONLY

    return (entry ? entry->pBase : NULL);

#else

    // If we found something or we're not supposed to fabricate, return the result
    if (entry != NULL || !fFab)
    {
        pRet = entry ? entry->pBase : NULL;
        goto LExit;
    }
        
    // For the in-proc, we'll only ask for stuff if
    // we've, for example, gotten it in a stack trace.
    // If we haven't seen it yet, fabricate something.
    if (m_guid == IID_ICorDebugAppDomainEnum)
    {
        _ASSERTE(&(m_creator.lsAppD.m_proc->m_appDomains) == this);
    
        AppDomain *pAppDomain = (AppDomain *)id;

        if (id == 0)
            goto LExit;
        
        WCHAR *pszName = (WCHAR *)pAppDomain->GetFriendlyName();
        
        WCHAR szName[20];
        if (pszName == NULL)
            wcscpy (szName, L"<UnknownName>");

        CordbAppDomain* pCAppDomain = new CordbAppDomain(
                        m_creator.lsAppD.m_proc,
                        pAppDomain,
                        pAppDomain->GetId(),
                        (pszName!=NULL?pszName:szName));

        if (pCAppDomain != NULL)
        {
            m_creator.lsAppD.m_proc->AddRef();

            hr = m_creator.lsAppD.m_proc
                ->m_appDomains.AddBase(pCAppDomain);
                
            if (FAILED(hr))
                goto LExit;
                
            pRet = (CordbBase *)pCAppDomain;
            goto LExit;
        }
        else
        {
            goto LExit;
        }
    }
    else if (m_guid == IID_ICorDebugThreadEnum)
    {
        _ASSERTE (m_creator.lsThread.m_proc != NULL);
        _ASSERTE( &(m_creator.lsAppD.m_proc->m_userThreads) == this);

        Thread *th = GetThread();

        // There are two cases in which this can be called:
        // 1. We already have the entire runtime suspended, in which case there is no need
        //    to take the thread store lock when searching for the thread.
        // 2. We have inprocess debugging enabled for this thread only, in which case we should
        //    not be looking for any thread other than ourselves and so there is no need to
        //    iterate over the thread store to try and find a match.
        //
        // In other words - there is no reason to take the ThreadStore lock.

        // If the runtime is suspended, we can just search through the threads for a match
        if (g_profControlBlock.fIsSuspended)
        {
            if (th == NULL || th->GetThreadId() != id)
            {
                // This will find the matching thread
                th = NULL;
                while ((th = ThreadStore::GetThreadList(th)) != NULL && th->GetThreadId() != id)
                    ;

                // This means we couldn't find the thread matching the ID
                if (th == NULL)
                    goto LExit;
            }
        }
        _ASSERTE(th != NULL);

        // This should create and add the debugger thread object
        m_creator.lsThread.m_proc->HandleManagedCreateThread(th->GetThreadId(), th->GetThreadHandle());

        // Find what we just added
        CordbHashEntry *entry = (CordbHashEntry *) Find(HASH(id), KEY(id)); 
        _ASSERTE(entry != NULL);

        if (entry != NULL)
        {
            CordbThread *cth = (CordbThread *)entry->pBase;
            cth->m_debuggerThreadToken = (void *)th;

            cth->m_pAppDomain = (CordbAppDomain*)m_creator.lsThread.m_proc
                ->m_appDomains.GetBase((ULONG)th->GetDomain());

            cth->m_stackBase = th->GetCachedStackBase();
            cth->m_stackLimit = th->GetCachedStackLimit();
                
            pRet = entry->pBase;

            goto LExit;
        }
        else
            goto LExit;

        goto LExit;
    } 
    else if (m_guid == IID_ICorDebugAssemblyEnum)
    {
        _ASSERTE(&(m_creator.lsAssem.m_appDomain->m_assemblies) == this);
        _ASSERTE(id != 0);
        Assembly *pA = (Assembly *)id;

        if (pA == NULL)
            goto LExit;
    
        LPCUTF8 szName = NULL;
        HRESULT hr = pA->GetName(&szName);

        LPWSTR  wszName = NULL;
        if (SUCCEEDED(hr))
        {
            MAKE_WIDEPTR_FROMUTF8(wszNameTemp, szName);
            wszName = wszNameTemp;
        }

        CordbAssembly *ca = new CordbAssembly(m_creator.lsAssem.m_appDomain, 
                                              (REMOTE_PTR)pA, 
                                              wszName,
                                              FALSE); 
                                              //@todo RIP system assembly stuff

        hr = m_creator.lsAssem.m_appDomain->m_assemblies.AddBase(ca);
        
        if (FAILED(hr))
            goto LExit;

        pRet = (CordbBase *)ca;
        goto LExit;
    }
    else if (m_guid == IID_ICorDebugModuleEnum)
    {
        _ASSERTE(&(m_creator.lsMod.m_appDomain->m_modules)==this);
        _ASSERTE( id != NULL );
    
        DebuggerModule *dm = (DebuggerModule *)id;

        if (dm == NULL)
            goto LExit;
        
        Assembly *as = dm->m_pRuntimeModule->GetAssembly();
    
        if (as == NULL && scp != NULL) 
        {
            //then we're still loading the assembly...
            as = scp->pAssemblySpecial;
        }

        CordbAssembly *ca = NULL;
        if( as != NULL)
        {
            // We'll get here if the module is made available before
            // the assembly is (eg, ModuleLoadFinished before 
            // AssemblyLoadFinished).
            ca = (CordbAssembly*)m_creator.lsMod.m_appDomain
                    ->m_assemblies.GetBase((ULONG)as);
            _ASSERTE( ca != NULL );
        }
        
        LPCWSTR sz;

        sz = dm->m_pRuntimeModule->GetFileName();

        BOOL fInMemory = FALSE;

        if (*sz == 0)
        {
            fInMemory = TRUE;
            sz = L"<Unknown Module>";
        }

        BOOL fDynamic = dm->m_pRuntimeModule->IsReflection();
        void *pMetadataStart = NULL;
        ULONG nMetadataSize = 0;
        DWORD baseAddress = (DWORD) dm->m_pRuntimeModule->GetILBase();

        // Get the PESize
        ULONG nPESize = 0;
        if (dm->m_pRuntimeModule->IsPEFile())
        {
            // Get the PEFile structure.
            PEFile *pPEFile = dm->m_pRuntimeModule->GetPEFile();

            _ASSERTE(pPEFile->GetNTHeader() != NULL);
            _ASSERTE(pPEFile->GetNTHeader()->OptionalHeader.SizeOfImage != 0);

            nPESize = pPEFile->GetNTHeader()->OptionalHeader.SizeOfImage;
        }

        CordbModule* module = new CordbModule(
            m_creator.lsMod.m_proc,
            ca,
            (REMOTE_PTR)dm,
            pMetadataStart, 
            nMetadataSize, 
            (REMOTE_PTR)baseAddress, 
            nPESize,
            fDynamic,
            fInMemory,
            (const WCHAR *)sz,
            m_creator.lsMod.m_appDomain,
            TRUE);

        if (module == NULL)
        {
            goto LExit;
        }

        //@todo: GetImporter converts the MD from RO into RW mode -
        // Could we use GetMDImport instead?
        module->m_pIMImport = dm->m_pRuntimeModule->GetImporter();
        if (module->m_pIMImport == NULL)
        {
            delete module;
            goto LExit;
        }
        
        hr = m_creator.lsMod.m_appDomain->m_modules.AddBase(module);
        if (FAILED(hr))
        {
            delete module;
            goto LExit;
        }

        pRet = (CordbBase*)module;
        goto LExit;
    }

LExit:
    INPROC_UNLOCK();
    return (pRet);
#endif // !RIGHT_SIDE_ONLY
}

CordbBase *CordbHashTable::RemoveBase(ULONG id)
{
    if (!m_initialized)
        return NULL;

    INPROC_LOCK();

    CordbHashEntry *entry 
      = (CordbHashEntry *) Find(HASH(id), KEY(id));

    if (entry == NULL)
    {
        INPROC_UNLOCK();
        return NULL;
    }

    CordbBase *base = entry->pBase;

    Delete(HASH(id), (HASHENTRY *) entry);
    m_count--;
    base->Release();

    INPROC_UNLOCK();

    return base;
}

CordbBase *CordbHashTable::FindFirst(HASHFIND *find)
{
    INPROC_LOCK();

    CordbHashEntry *entry = (CordbHashEntry *) FindFirstEntry(find);

    INPROC_UNLOCK();

    if (entry == NULL)
        return NULL;
    else
        return entry->pBase;
}

CordbBase *CordbHashTable::FindNext(HASHFIND *find)
{
    INPROC_LOCK();

    CordbHashEntry *entry = (CordbHashEntry *) FindNextEntry(find);

    INPROC_UNLOCK();

    if (entry == NULL)
        return NULL;
    else
        return entry->pBase;
}

/* ------------------------------------------------------------------------- *
 * Hash Table Enumerator class
 * ------------------------------------------------------------------------- */

CordbHashTableEnum::CordbHashTableEnum(CordbHashTable *table, 
                                       REFIID guid)
  : CordbBase(0),
    m_table(table), 
    m_started(false),
    m_done(false),
    m_guid(guid),
    m_iCurElt(0),
    m_count(0),
    m_fCountInit(FALSE),
    m_SkipDeletedAppDomains(TRUE)
{
#ifndef RIGHT_SIDE_ONLY

    INPROC_LOCK();

    _ASSERTE(m_guid != IID_ICorDebugBreakpointEnum);
    _ASSERTE(m_guid != IID_ICorDebugStepperEnum);

    memset(&m_enumerator, 0, sizeof(m_enumerator));

    if (m_guid == IID_ICorDebugAppDomainEnum)
    {
        if (m_iCurElt == 0)
        {
            // Get the process that created the table
            CordbHashTable *pADHash = &(m_table->m_creator.lsAppD.m_proc->m_appDomains);

            // Get the count
            ULONG32 max = pADHash->GetCount();

            if (max > 0)
            {
                // Allocate the array
                m_enumerator.lsAppD.pDomains = new AppDomain* [max];

                if (m_enumerator.lsAppD.pDomains != NULL)
                {
                    m_enumerator.lsAppD.pCurrent = m_enumerator.lsAppD.pDomains;
                    m_enumerator.lsAppD.pMax = m_enumerator.lsAppD.pDomains + max;

                    HASHFIND hf;
                    CordbAppDomain *pCurAD = (CordbAppDomain *)pADHash->FindFirst(&hf);
                    while (pCurAD && m_enumerator.lsAppD.pDomains < m_enumerator.lsAppD.pMax)
                    {
                        AppDomain *pDomain = (AppDomain *)pCurAD->m_id;
                        pDomain->AddRef();
                        *m_enumerator.lsAppD.pCurrent++ = pDomain;

                        pCurAD = (CordbAppDomain *)pADHash->FindNext(&hf);
                    }

                    _ASSERTE(m_enumerator.lsAppD.pMax = m_enumerator.lsAppD.pCurrent);
                    m_enumerator.lsAppD.pCurrent = m_enumerator.lsAppD.pDomains;
                }
            }
            else
            {
                m_done = true;
                m_enumerator.lsAppD.pCurrent = NULL;
                m_enumerator.lsAppD.pMax = NULL;
                m_enumerator.lsAppD.pDomains = NULL;
            }
        }   
    }
    else if (m_guid == IID_ICorDebugThreadEnum)
    {
        _ASSERTE (m_table->m_creator.lsThread.m_proc != NULL);
    
        Thread *th = NULL;

        // You are only allowed to enumerate the threads if the runtime has been suspended
        if (g_profControlBlock.fIsSuspended)
        {
            while ((th = ThreadStore::GetThreadList(th)) != NULL)
            {
                AppDomain *pAppDomain  = th->GetDomain();

                if (pAppDomain == NULL || pAppDomain->GetDebuggerAttached() != AppDomain::DEBUGGER_NOT_ATTACHED)
                {
                    CordbBase *b = (CordbBase *)m_table->GetBase(th->GetThreadId(), FALSE);

                    if (b == NULL)
                    {
                        m_table->m_creator.lsThread.m_proc->HandleManagedCreateThread(
                            th->GetThreadId(), th->GetThreadHandle());

                        CordbBase *base = (CordbBase *)m_table->GetBase(th->GetThreadId()); 

                        if (base != NULL)
                        {
                            CordbThread *cth = (CordbThread *)base;
                            cth->m_debuggerThreadToken = (void *)th;

                            if (pAppDomain == NULL)
                                cth->m_pAppDomain = NULL;
                            else
                                cth->m_pAppDomain = (CordbAppDomain*)m_table
                                                      ->m_creator.lsThread.m_proc
                                                      ->m_appDomains.GetBase((ULONG)pAppDomain);

                            _ASSERTE(cth->m_pAppDomain != NULL);
                        }
                    }                
                }
            }
        }
    }

    INPROC_UNLOCK();
    
#endif //RIGHT_SIDE_ONLY    
}

// Copy constructor makes life easy & fun!
CordbHashTableEnum::CordbHashTableEnum(CordbHashTableEnum *cloneSrc)
  : CordbBase(0),
    m_started(cloneSrc->m_started),
    m_done(cloneSrc->m_done),
    m_iCurElt(cloneSrc->m_iCurElt),
    m_guid(cloneSrc->m_guid),
    m_hashfind(cloneSrc->m_hashfind),
    m_count(cloneSrc->m_count),
    m_fCountInit(cloneSrc->m_fCountInit),
    m_SkipDeletedAppDomains(cloneSrc->m_SkipDeletedAppDomains)
{
    m_table = cloneSrc->m_table;

#ifndef RIGHT_SIDE_ONLY
    INPROC_LOCK();

    if (m_guid == IID_ICorDebugAppDomainEnum)
    {
        DWORD count = cloneSrc->m_enumerator.lsAppD.pMax - cloneSrc->m_enumerator.lsAppD.pDomains;
        m_enumerator.lsAppD.pDomains = new AppDomain* [count];
        if (m_enumerator.lsAppD.pDomains != NULL)
        {
            m_enumerator.lsAppD.pCurrent = m_enumerator.lsAppD.pDomains;
            m_enumerator.lsAppD.pMax = m_enumerator.lsAppD.pDomains + count;

            AppDomain **p = m_enumerator.lsAppD.pDomains;
            AppDomain **pc = cloneSrc->m_enumerator.lsAppD.pDomains;
            AppDomain **pEnd = m_enumerator.lsAppD.pMax;
            while (p < pEnd)
            {
                *p = *pc;

                if (*p != NULL)
                    (*p)->AddRef();

                p++;
                pc++;
            }
        }
    }
    else if (m_guid == IID_ICorDebugAssemblyEnum)
    {
        m_enumerator.lsAssem.m_i = 
            cloneSrc->m_enumerator.lsAssem.m_i;
        m_enumerator.lsAssem.m_fSystem = 
            cloneSrc->m_enumerator.lsAssem.m_fSystem;
    }
    else if (m_guid == IID_ICorDebugModuleEnum)
    {
        m_enumerator.lsMod.m_pMod = cloneSrc->m_enumerator.lsMod.m_pMod; 
        m_enumerator.lsMod.m_i = cloneSrc->m_enumerator.lsMod.m_i; 
        m_enumerator.lsMod.m_meWhich = cloneSrc->m_enumerator.lsMod.m_meWhich; 
        HRESULT hr = cloneSrc->m_enumerator.lsMod.m_enumThreads->Clone(
            (ICorDebugEnum**)&m_enumerator.lsMod.m_enumThreads);
        _ASSERTE(!FAILED(hr));
    }

    INPROC_UNLOCK();

#endif //RIGHT_SIDE_ONLY
}

CordbHashTableEnum::~CordbHashTableEnum()
{
#ifndef RIGHT_SIDE_ONLY
    INPROC_LOCK();

    HRESULT hr = S_OK;
    if (m_guid == IID_ICorDebugAppDomainEnum)
    {
        AppDomain **p = m_enumerator.lsAppD.pDomains;
        AppDomain **pEnd = m_enumerator.lsAppD.pMax;
        while (p < pEnd)
        {
            if (*p != NULL)
                (*p)->Release();
            p++;
        }
        
        delete [] m_enumerator.lsAppD.pDomains;
    }

    INPROC_UNLOCK();
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbHashTableEnum::Reset()
{
    INPROC_LOCK();

    HRESULT hr = S_OK;
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE(m_guid != IID_ICorDebugBreakpointEnum);
    _ASSERTE(m_guid != IID_ICorDebugStepperEnum);

    if (m_guid == IID_ICorDebugBreakpointEnum ||
        m_guid == IID_ICorDebugStepperEnum)
    {   
        hr = CORDBG_E_INPROC_NOT_IMPL;
        goto LExit;
    }
    
    if (m_guid == IID_ICorDebugAppDomainEnum)
    {
        m_enumerator.lsAppD.pCurrent = m_enumerator.lsAppD.pDomains;
    }
    else if (m_guid == IID_ICorDebugAssemblyEnum)
    {
        m_enumerator.lsAssem.m_fSystem = FALSE;
    }
    else if (m_guid == IID_ICorDebugModuleEnum)
    {
        m_enumerator.lsMod.m_pMod = NULL; 
        m_enumerator.lsMod.m_meWhich = ME_SPECIAL; 
    }
#endif //RIGHT_SIDE_ONLY    

    m_started = false;
    m_done = false;
    
#ifndef RIGHT_SIDE_ONLY
    m_iCurElt = 0;

LExit:
#endif // RIGHT_SIDE_ONLY
    INPROC_UNLOCK();

    return hr;
}

HRESULT CordbHashTableEnum::Clone(ICorDebugEnum **ppEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppEnum, ICorDebugEnum **);

    INPROC_LOCK();

    HRESULT hr;
    hr = S_OK;
    
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE(m_guid != IID_ICorDebugBreakpointEnum);
    _ASSERTE(m_guid != IID_ICorDebugStepperEnum);

    if (m_guid == IID_ICorDebugBreakpointEnum ||
        m_guid == IID_ICorDebugStepperEnum)
    {
        hr = CORDBG_E_INPROC_NOT_IMPL;
        goto LExit;
    }
    
#endif //RIGHT_SIDE_ONLY    

    CordbHashTableEnum *e;
    e = new CordbHashTableEnum(this);

    if (e == NULL)
    {
        (*ppEnum) = NULL;
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    e->QueryInterface(m_guid, (void **) ppEnum);

LExit:
    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbHashTableEnum::GetCount(ULONG *pcelt)
{
    VALIDATE_POINTER_TO_OBJECT(pcelt, ULONG *);

    INPROC_LOCK();

    HRESULT hr = S_OK;
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE(m_guid != IID_ICorDebugBreakpointEnum);
    _ASSERTE(m_guid != IID_ICorDebugStepperEnum);

    if (m_guid == IID_ICorDebugBreakpointEnum ||
        m_guid == IID_ICorDebugStepperEnum)
    {
        hr = CORDBG_E_INPROC_NOT_IMPL;
        goto LExit;
    }
    
    if (m_fCountInit)
    {
        *pcelt = m_count;
        hr = S_OK;
        goto LExit;
    }

    if (m_guid == IID_ICorDebugAppDomainEnum)
    {
        *pcelt = m_enumerator.lsAppD.pMax - m_enumerator.lsAppD.pDomains;
    } 
    else if (m_guid == IID_ICorDebugAssemblyEnum)
    {
        ULONG cAssem = 0;

        AppDomain *pDomain = ((AppDomain *)(m_table->m_creator.lsAssem.m_appDomain->m_id));

        cAssem = pDomain->GetAssemblyCount();
        cAssem += SystemDomain::System()->GetAssemblyCount();
        
        (*pcelt) = cAssem;
    }
    else if (m_guid == IID_ICorDebugModuleEnum)
    {
        ULONG cMod = 0;
        AppDomain::AssemblyIterator i;
        
        if (SystemDomain::System() != NULL)
        {
            i = SystemDomain::System()->IterateAssemblies();

            while (i.Next()) 
            {
                Assembly *pAssembly = i.GetAssembly();

                ClassLoader* pLoader = pAssembly->GetLoader();
                
                if (pLoader != NULL)
                {
                    for (Module *pModule = pLoader->m_pHeadModule;
                         pModule != NULL;
                         pModule = pModule->GetNextModule())
                    {
                        cMod++;
                    }
                }
            }
        }
        
        AppDomain *ad;
        ad = (AppDomain *)m_table->m_creator.lsMod.
                          m_appDomain->m_id;
                          
        i = ad->IterateAssemblies();

        while (i.Next())
        {
            Assembly *pAssembly = i.GetAssembly();
            
            ClassLoader* pLoader = pAssembly->GetLoader();

            if (pLoader != NULL)
            {
                for (Module *pModule = pLoader->m_pHeadModule;
                     pModule != NULL;
                     pModule = pModule->GetNextModule())
                {
                    cMod++;
                }
            }
        }
        
        (*pcelt) = cMod;
    }
    else
    {
#endif //RIGHT_SIDE_ONLY    
        if (m_guid == IID_ICorDebugAppDomainEnum)
        {
            *pcelt = m_table->GetCount();

            // subtract the AppDomain entries marked for deletion
            ICorDebugAppDomainEnum *pClone = NULL;

            HRESULT hr = this->Clone ((ICorDebugEnum**)&pClone);

            if (SUCCEEDED(hr))
            {
                pClone->Reset();
                ICorDebugAppDomain *pAppDomain = NULL;
                ULONG ulCountFetched = 0;

                bool fDone = false;
                // We want to also go over the appdomains which have been marked
                // as deleted. So set the flag appropriately.
                CordbHashTableEnum *pEnum = (CordbHashTableEnum *)pClone;

                pEnum->m_SkipDeletedAppDomains = FALSE;
                do
                {
                    hr = pClone->Next (1, &pAppDomain, &ulCountFetched);
                    if (SUCCEEDED(hr) && (ulCountFetched))
                    {
                        CordbAppDomain *pAD = (CordbAppDomain *)pAppDomain;
                        if (pAD && pAD->IsMarkedForDeletion())
                            (*pcelt)--;

                        pAppDomain->Release();
                    }
                    else
                        fDone = true;
                }
                while (!fDone);
                     
                pClone->Release();
            }
        } 
        else
        {
            *pcelt = m_table->GetCount();
        }

#ifndef RIGHT_SIDE_ONLY
    }

    if (!m_fCountInit)
    {
        m_count = *pcelt;
        m_fCountInit = TRUE;
    }
LExit:
#endif //RIGHT_SIDE_ONLY

    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbHashTableEnum::PrepForEnum(CordbBase **pBase)
{
    HRESULT hr = S_OK;

    INPROC_LOCK();

#ifndef RIGHT_SIDE_ONLY
    CordbBase *base;

    if (pBase == NULL)
        pBase = &base;
        
    if (m_guid == IID_ICorDebugAppDomainEnum)
    {
        if (!m_started)
        {
            _ASSERTE(!m_done);
            m_started = true;
        }    
    } 
    else if (m_guid == IID_ICorDebugAssemblyEnum)
    {
        // Prime the pump
        if (!m_started)
        {
            _ASSERTE(!m_done);

            if (SystemDomain::System() == NULL)
            {
                hr = E_FAIL;
                goto exit;
            }

            // if not sharing mscorlib or if are dealing with default domain and it has
            // count 0 and system domain has count 1 then are in init stage so spoof to
            // give defaultdomain the right count.
            AppDomain *pDomain = ((AppDomain *)(m_table->m_creator.lsAssem.m_appDomain->m_id));

            m_enumerator.lsAssem.m_i = SystemDomain::System()->IterateAssemblies();
            m_enumerator.lsAssem.m_fSystem = TRUE;
            m_started = true;
        }
    }
    else if (m_guid == IID_ICorDebugModuleEnum)
    {
        if (!m_started)
        {
            _ASSERTE(!m_done);

            GetNextSpecialModule();
        }

        if (m_enumerator.lsMod.m_pMod != NULL)
        {
            // @todo Inproc will always hear about things after
            // we've gotten the load event, right?
            DebuggerModule *dm = NULL;

            if (g_pDebugger->m_pModules != NULL)
                dm = g_pDebugger->m_pModules->GetModule(m_enumerator.lsMod.m_pMod);

            if( dm == NULL )
            {
#ifdef _DEBUG
                if (m_enumerator.lsMod.m_meWhich != ME_SPECIAL)
                {
                    _ASSERTE( m_enumerator.lsMod.m_appDomain == NULL ||
                              ((AppDomain*)m_enumerator.lsMod.m_pMod->GetDomain() ==
                              (AppDomain*)m_enumerator.lsMod.m_appDomain->m_id) );
                }                              
#endif                
                if (m_enumerator.lsMod.m_meWhich == ME_SPECIAL)
                {
                    dm = g_pDebugger->AddDebuggerModule(m_enumerator.lsMod.m_pMod,
                                    (AppDomain*)m_enumerator.lsMod.m_appDomain->m_id);
                }
                else
                {
                    dm = g_pDebugger->AddDebuggerModule(m_enumerator.lsMod.m_pMod,
                                    (AppDomain*)m_enumerator.lsMod.m_pMod->GetDomain());
                }

                if (dm == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
            }

            _ASSERTE( dm != NULL );
            CordbHashTable::SpecialCasePointers scp;

            CordbThread *t = m_enumerator.lsMod.m_threadCur;
            if (t == NULL)
                scp.pAssemblySpecial = NULL;
            else if (t->m_pAssemblySpecialAlloc == 1)
                scp.pAssemblySpecial = t->m_pAssemblySpecial;
            else 
                scp.pAssemblySpecial = t->m_pAssemblySpecialStack[t->m_pAssemblySpecialCount-1];
            (*pBase) = m_table->GetBase((ULONG)dm, TRUE, &scp);
                    
            m_started = true;
        }
    }
    else if (m_guid == IID_ICorDebugProcessEnum ||
               m_guid == IID_ICorDebugThreadEnum)
    {
        // Process enum has only 1 elt,
        // Thread enum gets loaded in constructor
#endif //RIGHT_SIDE_ONLY
        if (!m_started)
        {
            (*pBase) = m_table->FindFirst(&m_hashfind);
            m_started = true;
        }
        else 
            (*pBase) = m_table->FindNext(&m_hashfind);
#ifndef RIGHT_SIDE_ONLY
    }
    else
    {
        _ASSERTE( !"CordbHashTableEnum::CordbHashTableEnum inproc " 
                "given wrong enum type!" );
        hr = E_NOTIMPL;
        goto exit;
    }
 exit:
#endif //RIGHT_SIDE_ONLY

    INPROC_UNLOCK();

    return hr;
}

HRESULT CordbHashTableEnum::GetNextSpecialModule(void)
{
    HRESULT hr = S_OK;

    INPROC_LOCK();

#ifndef RIGHT_SIDE_ONLY        
    bool fFoundSpecial = false;
    Module *pModule;
    if (m_enumerator.lsMod.m_enumThreads != NULL)
    {
        ICorDebugThread *thread;
        ULONG cElt;
        hr = m_enumerator.lsMod.m_enumThreads->Next(1, &thread,&cElt);
        if (FAILED(hr))
            goto exit;

        while(cElt == 1 && !fFoundSpecial)
        {
            CordbThread *t = (CordbThread *)thread;
            m_enumerator.lsMod.m_threadCur = t;
            
            if ( (pModule = t->m_pModuleSpecial) != NULL)
                fFoundSpecial = true;
            else
            {
                hr = m_enumerator.lsMod.m_enumThreads->Next(1, &thread,&cElt);
                if (FAILED(hr))
                    goto exit;
            }
        }

        // We've run out of threads, so we don't have a current anymore...
        if (cElt ==0)
            m_enumerator.lsMod.m_threadCur = NULL;
    }

    if (fFoundSpecial)
    {
        m_enumerator.lsMod.m_meWhich = ME_SPECIAL;
        m_enumerator.lsMod.m_pMod = pModule;
    }
    else
    {
        if (FAILED(hr = SetupModuleEnumForSystemIteration()))
            goto exit;
    }
exit:    
#endif //RIGHT_SIDE_ONLY
    INPROC_UNLOCK();

    return hr;
}

HRESULT CordbHashTableEnum::SetupModuleEnumForSystemIteration(void)
{
#ifndef RIGHT_SIDE_ONLY        

    if (SystemDomain::System() == NULL)
        return E_FAIL;
    
    m_enumerator.lsMod.m_i = SystemDomain::System()->IterateAssemblies();
    m_enumerator.lsMod.m_meWhich = ME_SYSTEM;

    m_enumerator.lsMod.m_i.Next();
    Assembly *assem = m_enumerator.lsMod.m_i.GetAssembly();
    if (NULL == assem)
        return E_FAIL;
        
    ClassLoader* pLoader = assem->GetLoader();

    if (pLoader != NULL)
    {
        Module *pModule = pLoader->m_pHeadModule;
        m_enumerator.lsMod.m_pMod = pModule;
    }
    else
    {
        return E_FAIL;
    }
#endif //RIGHT_SIDE_ONLY

    return S_OK;
}


HRESULT CordbHashTableEnum::AdvancePreAssign(CordbBase **pBase)
{
    INPROC_LOCK();
#ifndef RIGHT_SIDE_ONLY        
    CordbBase *base;

    if (pBase == NULL)
        pBase = &base;
        
    if (m_guid == IID_ICorDebugAppDomainEnum)
    {
        if (m_enumerator.lsAppD.pCurrent < m_enumerator.lsAppD.pMax)
        {
            AppDomain *pAppDomain = *m_enumerator.lsAppD.pCurrent++;

            (*pBase) = m_table->GetBase((ULONG)pAppDomain);
        }
        else 
        {
            (*pBase) = NULL;
            m_done = true;
        }
    } 
    else if (m_guid == IID_ICorDebugAssemblyEnum)
    {
        BOOL fKeepLooking;
        do
        {
            fKeepLooking = FALSE;
            
            if (m_enumerator.lsAssem.m_i.Next())
            {
                (*pBase) = m_table->GetBase((ULONG)m_enumerator.lsAssem.m_i.GetAssembly());
            }
            else if ( m_enumerator.lsAssem.m_fSystem)
            {
                AppDomain *ad;
                ad = (AppDomain *)m_table->m_creator.lsAssem.
                  m_appDomain->m_id;
                m_enumerator.lsAssem.m_i = ad->IterateAssemblies();
                m_enumerator.lsAssem.m_fSystem = FALSE;
                fKeepLooking = TRUE;
            }
            else 
            {
                (*pBase) = NULL;
                m_done = true;
            }
        } while (fKeepLooking);
    }
#endif //RIGHT_SIDE_ONLY
    INPROC_UNLOCK();
    return S_OK;
}

HRESULT CordbHashTableEnum::AdvancePostAssign(CordbBase **pBase, 
                                              CordbBase     **b,
                                              CordbBase   **bEnd)
{
    INPROC_LOCK();
    CordbBase *base;

    if (pBase == NULL)
        pBase = &base;
        
    // If we're looping like normal, or we're in skip
    if ( ((b < bEnd) || ((b ==bEnd)&&(b==NULL)))
#ifndef RIGHT_SIDE_ONLY
        && (m_guid == IID_ICorDebugProcessEnum ||
            m_guid == IID_ICorDebugThreadEnum)
#endif //RIGHT_SIDE_ONLY
       )
    {
        (*pBase) = m_table->FindNext(&m_hashfind);
        if (*pBase == NULL)
           m_done = true;
    }   
    
#ifndef RIGHT_SIDE_ONLY
    // Also Duplicated below
    if (m_guid == IID_ICorDebugModuleEnum)
    {
        (*pBase) = NULL;
            
        if (m_enumerator.lsMod.m_pMod)
        {
            m_enumerator.lsMod.m_pMod = 
                m_enumerator.lsMod.m_pMod->GetNextModule();

            if (m_enumerator.lsMod.m_pMod == NULL)
            {
                do
                {
                    switch(m_enumerator.lsMod.m_meWhich)
                    {
                        //We've already gotten the special pointer,
                        // so go do the regular stuff.
                        case ME_SPECIAL:
                            GetNextSpecialModule();
                            break;
                            
                        case ME_SYSTEM:
                        case ME_APPDOMAIN:
                            if (m_enumerator.lsMod.m_i.Next())
                            {
                                ClassLoader* pLoader 
                                  = m_enumerator.lsMod.m_i.GetAssembly()->GetLoader();
                                if (pLoader != NULL)
                                {
                                    Module *pModule = pLoader->m_pHeadModule;
                                    m_enumerator.lsMod.m_pMod = pModule;
                                }
                            }
                            else if (m_enumerator.lsMod.m_meWhich == ME_SYSTEM)
                            {
                                AppDomain *ad;
                                ad = (AppDomain *)m_table->m_creator.
                                  lsMod.m_appDomain->m_id;
                                m_enumerator.lsMod.m_i = ad->IterateAssemblies();
                                continue;
                            }
                            break;
                    }
                }
                while (FALSE);
            }

            if (m_enumerator.lsMod.m_pMod != NULL)
            {
                // we've gotten the load event, right?
                DebuggerModule *dm = NULL;

                if (g_pDebugger->m_pModules != NULL)
                    dm = g_pDebugger->m_pModules->GetModule(m_enumerator.lsMod.m_pMod);

                if( dm == NULL )
                {
                    if (m_enumerator.lsMod.m_meWhich == ME_SPECIAL)
                    {
                        dm = g_pDebugger->Debugger::AddDebuggerModule(m_enumerator.lsMod.m_pMod,
                                        (AppDomain*)m_enumerator.lsMod.m_appDomain->m_id);
                    }
                    else
                    {
                        dm = g_pDebugger->Debugger::AddDebuggerModule(m_enumerator.lsMod.m_pMod,
                                        (AppDomain*)m_enumerator.lsMod.m_pMod->GetDomain());
                    }
                    
                    if (dm == NULL)
                    {
                        INPROC_UNLOCK();
                        return E_OUTOFMEMORY;
                    }
                }

                _ASSERTE( dm != NULL );
                (*pBase) = m_table->GetBase((ULONG)dm);
            }
        }

        if (*pBase == NULL)
            m_done = true;
    }
#endif //RIGHT_SIDE_ONLY
    INPROC_UNLOCK();
    return S_OK;
}

HRESULT CordbHashTableEnum::Next(ULONG celt, 
                                 CordbBase *bases[], 
                                 ULONG *pceltFetched)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(bases, CordbBase *, 
        celt, true, true);
    VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

    INPROC_LOCK();

    HRESULT         hr      = S_OK;
    CordbBase      *base    = NULL;
    CordbBase     **b       = bases;
    CordbBase     **bEnd    = bases + celt;

#ifndef RIGHT_SIDE_ONLY
    _ASSERTE(m_guid != IID_ICorDebugBreakpointEnum);
    _ASSERTE(m_guid != IID_ICorDebugStepperEnum);

    if (celt == 0)
        goto LError;
    
    if (m_guid == IID_ICorDebugBreakpointEnum ||
        m_guid == IID_ICorDebugStepperEnum)
    {
        hr = CORDBG_E_INPROC_NOT_IMPL;
        goto LError;
    }
#endif //RIGHT_SIDE_ONLY

    hr = PrepForEnum(&base);
    if (FAILED(hr))
        goto LError;

    while (b < bEnd && !m_done)
    {
        hr = AdvancePreAssign(&base);
        if (FAILED(hr))
            goto LError;
        
        if (base == NULL)
            m_done = true;
        else
        {
            if (m_guid == IID_ICorDebugProcessEnum)
                *b = (CordbBase*)(ICorDebugProcess*)(CordbProcess*)base;
            else if (m_guid == IID_ICorDebugBreakpointEnum)
                *b = (CordbBase*)(ICorDebugBreakpoint*)(CordbBreakpoint*)base;
            else if (m_guid == IID_ICorDebugStepperEnum)
                *b = (CordbBase*)(ICorDebugStepper*)(CordbStepper*)base;
            else if (m_guid == IID_ICorDebugModuleEnum)
                *b = (CordbBase*)(ICorDebugModule*)(CordbModule*)base;
            else if (m_guid == IID_ICorDebugThreadEnum)
                *b = (CordbBase*)(ICorDebugThread*)(CordbThread*)base;
            else if (m_guid == IID_ICorDebugAppDomainEnum)
            {
                BOOL fAssign = TRUE;
                if (m_SkipDeletedAppDomains)
                {
                    CordbAppDomain *pAD = (CordbAppDomain *)base;
                    if (pAD && pAD->IsMarkedForDeletion())
                    {
                        *b = NULL;
                        fAssign = FALSE;
                    }
                }
                if (fAssign)
                    *b = (CordbBase*)(ICorDebugAppDomain*)(CordbAppDomain*)base;
            }
            else if (m_guid == IID_ICorDebugAssemblyEnum)
                *b = (CordbBase*)(ICorDebugAssembly*)(CordbAssembly*)base;
            else
                *b = (CordbBase*)(IUnknown*)base;

            if (*b)
            {
                (*b)->AddRef();
                b++;
            }

            hr = AdvancePostAssign(&base, b, bEnd);      
            if (FAILED(hr))
                goto LError;
        }
    }

LError:
    INPROC_UNLOCK();
    *pceltFetched = b - bases;

    return hr;
}

HRESULT CordbHashTableEnum::Skip(ULONG celt)
{
    INPROC_LOCK();

    HRESULT hr = S_OK;
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE(m_guid != IID_ICorDebugBreakpointEnum);
    _ASSERTE(m_guid != IID_ICorDebugStepperEnum);
    
    if (celt == 0)
    {
        hr = S_OK;
        goto LExit;
    }
    
    if (m_guid == IID_ICorDebugBreakpointEnum ||
        m_guid == IID_ICorDebugStepperEnum)
    {
        hr = CORDBG_E_INPROC_NOT_IMPL;
        goto LExit;
    }
    else if (m_guid == IID_ICorDebugAppDomainEnum)
    {
        m_enumerator.lsAppD.pCurrent += celt;
        if (m_enumerator.lsAppD.pCurrent > m_enumerator.lsAppD.pMax)
            m_enumerator.lsAppD.pCurrent = m_enumerator.lsAppD.pMax;

        m_started = true;
        hr = S_OK;
        goto LExit;
    }
    else if (m_guid == IID_ICorDebugThreadEnum ||
             m_guid == IID_ICorDebugProcessEnum)
    {
#endif //RIGHT_SIDE_ONLY    

        CordbBase   *base;

        if (celt > 0)
        {
            if (!m_started)
            {
                base = m_table->FindFirst(&m_hashfind);

                if (base == NULL)
                    m_done = true;
                else
                    celt--;

                m_started = true;
            }

            while (celt > 0 && !m_done)
            {
                base = m_table->FindNext(&m_hashfind);

                if (base == NULL)
                    m_done = true;
                else
                    celt--;
            }
        }

#ifndef RIGHT_SIDE_ONLY
    }
    else 
    {
        PrepForEnum(NULL);

        while (celt >0 && !m_done)
        {
            AdvancePreAssign(NULL);
            AdvancePostAssign(NULL, NULL, NULL);
        }
    }
LExit:
#endif //RIGHT_SIDE_ONLY

    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbHashTableEnum::QueryInterface(REFIID id, void **pInterface)
{
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE(m_guid != IID_ICorDebugBreakpointEnum);
    _ASSERTE(m_guid != IID_ICorDebugStepperEnum);

    if (m_guid == IID_ICorDebugBreakpointEnum ||
        m_guid == IID_ICorDebugStepperEnum)
        return CORDBG_E_INPROC_NOT_IMPL;
        
#endif //RIGHT_SIDE_ONLY    

    if (id == IID_ICorDebugEnum || id == IID_IUnknown)
    {
        AddRef();
        *pInterface = this;

        return S_OK;
    }

    if (id == m_guid)
    {
        AddRef();
        
        if (id == IID_ICorDebugProcessEnum)
            *pInterface = (ICorDebugProcessEnum *) this;
        else if (id == IID_ICorDebugBreakpointEnum)
            *pInterface = (ICorDebugBreakpointEnum *) this;
        else if (id == IID_ICorDebugStepperEnum)
            *pInterface = (ICorDebugStepperEnum *) this;
        else if (id == IID_ICorDebugModuleEnum)
            *pInterface = (ICorDebugModuleEnum *) this;
        else if (id == IID_ICorDebugThreadEnum)
            *pInterface = (ICorDebugThreadEnum *) this;
        else if (id == IID_ICorDebugAppDomainEnum)
            *pInterface = (ICorDebugAppDomainEnum *) this;
        else if (id == IID_ICorDebugAssemblyEnum)
            *pInterface = (ICorDebugAssemblyEnum *) this;

        return S_OK;
    }

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//	stdafx.cpp
//
//	Host for precompiled header.
//
//*****************************************************************************
#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\cordb.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CorDB.cpp
//
// Dll* routines for entry points, and support for COM framework.  The class
// factory and other routines live in this module.
//
//*****************************************************************************
#include "stdafx.h"
#include "ClassFactory.h"
#include "CorSym.h"

// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();

//********** Globals. *********************************************************
static const LPCWSTR g_szCoclassDesc    = L"Microsoft Common Language Runtime Debugger";
static const LPCWSTR g_szProgIDPrefix   = L"ComPlusDebug";
static const LPCWSTR g_szThreadingModel = L"Both";
const int       g_iVersion = 1;         // Version of coclasses.
HINSTANCE       g_hInst;                // Instance handle to this piece of code.

// This map contains the list of coclasses which are exported from this module.
const COCLASS_REGISTER g_CoClasses[] =
{
//  pClsid              szProgID            pfnCreateObject
    &CLSID_CorDebug,    L"CorDebug",        Cordb::CreateObject,        
    &CLSID_CorpubPublish,  L"CorpubPublish",  CorpubPublish::CreateObject,        
    NULL,               NULL,               NULL
};


//********** Locals. **********************************************************
STDAPI DllUnregisterServer(void);


//********** Code. ************************************************************


//*****************************************************************************
// The main dll entry point for this module.  This routine is called by the
// OS when the dll gets loaded.  Control is simply deferred to the main code.
//*****************************************************************************
BOOL WINAPI DbgDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Save off the instance handle for later use.
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInst = hInstance;

        // Init the Win32 wrappers.
        OnUnicodeSystem();
    
#ifdef LOGGING        
        {
            WCHAR   rcFile[_MAX_PATH];
            WszGetModuleFileName(hInstance, rcFile, NumItems(rcFile));
            LOG((LF_CORDB, LL_INFO10000,
                "DI::DbgDllMain: load right side support from file '%s'\n",
                 rcFile));
        }
#endif
    }
#if 0
#ifdef _DEBUG
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DbgAllocReport();
    }
#endif // _DEBUG
#endif // 0

    return TRUE;
}


//*****************************************************************************
// Register the class factories for the main debug objects in the API.
//*****************************************************************************
STDAPI DllRegisterServer(void)
{
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    WCHAR       rcModule[_MAX_PATH];    // This server's module name.
    HRESULT     hr = S_OK;

    // Erase all doubt from old entries.
    DllUnregisterServer();

    // Get the filename for this module.
    DWORD ret;
    VERIFY(ret = WszGetModuleFileName(GetModuleInst(), rcModule, NumItems(rcModule)));
    if( ret == 0)
    	return E_UNEXPECTED;

    // Get the version of the runtime
    WCHAR       rcVersion[_MAX_PATH];
    DWORD       lgth;
    IfFailGo(GetCORSystemDirectory(rcVersion, NumItems(rcVersion), &lgth));

    // For each item in the coclass list, register it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        // Register the class with default values.
        if (FAILED(hr = REGUTIL::RegisterCOMClass(
                *pCoClass->pClsid, 
                g_szCoclassDesc, 
                g_szProgIDPrefix,
                g_iVersion, 
                pCoClass->szProgID, 
                g_szThreadingModel, 
                rcModule,
                GetModuleInst(),
                NULL,
                rcVersion,
                true,
                false)))
            goto ErrExit;
    }

ErrExit:
    if (FAILED(hr))
        DllUnregisterServer();
    return (hr);
}


//*****************************************************************************
// Remove registration data from the registry.
//*****************************************************************************
STDAPI DllUnregisterServer(void)
{
    const COCLASS_REGISTER *pCoClass;   // Loop control.

    // For each item in the coclass list, unregister it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        REGUTIL::UnregisterCOMClass(*pCoClass->pClsid, g_szProgIDPrefix,
                    g_iVersion, pCoClass->szProgID, true);
    }
    return (S_OK);
}


//*****************************************************************************
// Called by COM to get a class factory for a given CLSID.  If it is one we
// support, instantiate a class factory object and prepare for create instance.
//*****************************************************************************
STDAPI DllGetClassObjectInternal(               // Return code.
    REFCLSID    rclsid,                 // The class to desired.
    REFIID      riid,                   // Interface wanted on class factory.
    LPVOID FAR  *ppv)                   // Return interface pointer here.
{
    CClassFactory *pClassFactory;       // To create class factory object.
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    HRESULT     hr = CLASS_E_CLASSNOTAVAILABLE;

    // Scan for the right one.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        if (*pCoClass->pClsid == rclsid)
        {
            // Allocate the new factory object.
            pClassFactory = new CClassFactory(pCoClass);
            if (!pClassFactory)
                return (E_OUTOFMEMORY);

            // Pick the v-table based on the caller's request.
            hr = pClassFactory->QueryInterface(riid, ppv);

            // Always release the local reference, if QI failed it will be
            // the only one and the object gets freed.
            pClassFactory->Release();
            break;
        }
    }
    return (hr);
}



//*****************************************************************************
//
//********** Class factory code.
//
//*****************************************************************************


//*****************************************************************************
// QueryInterface is called to pick a v-table on the co-class.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::QueryInterface( 
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;

    // Avoid confusion.
    *ppvObject = NULL;

    // Pick the right v-table based on the IID passed in.
    if (riid == IID_IUnknown)
        *ppvObject = (IUnknown *) this;
    else if (riid == IID_IClassFactory)
        *ppvObject = (IClassFactory *) this;

    // If successful, add a reference for out pointer and return.
    if (*ppvObject)
    {
        hr = S_OK;
        AddRef();
    }
    else
        hr = E_NOINTERFACE;
    return (hr);
}


//*****************************************************************************
// CreateInstance is called to create a new instance of the coclass for which
// this class was created in the first place.  The returned pointer is the
// v-table matching the IID if there.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::CreateInstance( 
    IUnknown    *pUnkOuter,
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;

    // Avoid confusion.
    *ppvObject = NULL;
    _ASSERTE(m_pCoClass);

    // Aggregation is not supported by these objects.
    if (pUnkOuter)
        return (CLASS_E_NOAGGREGATION);

    // Ask the object to create an instance of itself, and check the iid.
    hr = (*m_pCoClass->pfnCreateObject)(riid, ppvObject);
    return (hr);
}


HRESULT STDMETHODCALLTYPE CClassFactory::LockServer( 
    BOOL        fLock)
{
//@todo: hook up lock server logic.
    return (S_OK);
}





//*****************************************************************************
// This helper provides access to the instance handle of the loaded image.
//*****************************************************************************
HINSTANCE GetModuleInst()
{
    return g_hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\enc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: EnC.cpp
//
//*****************************************************************************
#include "stdafx.h"

#include "EnC.h"
#include "DbgIPCEvents.h"

HRESULT FindIStreamMetaData(IStream *pIsImage, 
						    BYTE **prgbMetaData, 
						    long *pcbMetaData);

/* ------------------------------------------------------------------------- *
 * CordbEnCSnapshot
 * ------------------------------------------------------------------------- */
 

#define ENC_COPY_SIZE (64 * 4096)

class QSortILMapEntries : public CQuickSort<UnorderedILMap>
{
public:
    QSortILMapEntries(UnorderedILMap *pBase,int iCount) 
        : CQuickSort<UnorderedILMap>(pBase, iCount) {}

    virtual int Compare(UnorderedILMap *psFirst,
                        UnorderedILMap *psSecond)
    {
        if(psFirst->mdMethod == psSecond->mdMethod)
            return 0;
        else if (psFirst->mdMethod < psSecond->mdMethod)
            return -1;
        else // (psFirst->mdMethod > psSecond->mdMethod)
            return 1;
            
    }
} ;

UINT CordbEnCSnapshot::m_sNextID = 0;

/*
 * Ctor
 */
CordbEnCSnapshot:: CordbEnCSnapshot(CordbModule *module) : 
    CordbBase(0), m_roDataRVA(0), m_rwDataRVA(0), 
	m_pIStream(NULL), m_cbPEData(0),
	m_pSymIStream(NULL), m_cbSymData(0),
    m_module(module)
{
    m_ILMaps = new ILMAP_UNORDERED_ARRAY;
}

CordbEnCSnapshot::~CordbEnCSnapshot()
{
    if (m_ILMaps != NULL)
    {
        // Toss all the memory for each IL map, then the whole thing.
        UnorderedILMap *oldEntries = m_ILMaps->Table();
        USHORT cEntries = m_ILMaps->Count();
        
        for(USHORT iEntry = 0; iEntry < cEntries; iEntry++)
        {
            delete oldEntries[iEntry].pMap;
            oldEntries[iEntry].pMap = NULL;
        }
        
        delete m_ILMaps;
    }
    m_ILMaps = NULL;

    if (m_pIStream)
        m_pIStream->Release();
    m_pIStream = NULL;

    if (m_pSymIStream)
        m_pSymIStream->Release();
    m_pSymIStream = NULL;
}


//-----------------------------------------------------------
// IUnknown
//-----------------------------------------------------------

/*
 * QueryInterface
 */
COM_METHOD CordbEnCSnapshot::QueryInterface(REFIID riid, void **ppInterface)
{
#ifdef EDIT_AND_CONTINUE_FEATURE
    if (riid == IID_ICorDebugEditAndContinueSnapshot)
        *ppInterface = (ICorDebugEditAndContinueSnapshot *)this;
    else 
#endif    
    if (riid == IID_IUnknown)
		*ppInterface = (IUnknown *)(ICorDebugEditAndContinueSnapshot *)this;
    else
    {
        *ppInterface = NULL;
        return (E_NOINTERFACE);
    }

    AddRef();
    return (S_OK);
}

//-----------------------------------------------------------
// ICorDebugEditAndContinueSnapshot
//-----------------------------------------------------------


/*
 * CopyMetaData saves a copy of the executing metadata from the debuggee
 * for this snapshot to the output stream.  The stream implementation must
 * be supplied by the caller and will typically either save the copy to
 * memory or to disk.  Only the IStream::Write method will be called by
 * this method.  The MVID value returned is the unique metadata ID for
 * this copy of the metadata.  It may be used on subsequent edit and 
 * continue operations to determine if the client has the most recent
 * version already (performance win to cache).
 */
COM_METHOD CordbEnCSnapshot::CopyMetaData(IStream *pIStream, GUID *pMvid)
{
    VALIDATE_POINTER_TO_OBJECT(pIStream, IStream *);
    VALIDATE_POINTER_TO_OBJECT(pMvid, GUID *);
    
    IMetaDataEmit      *pEmit   = NULL;
    HRESULT             hr      = S_OK;

    hr = m_module->m_pIMImport->QueryInterface(IID_IMetaDataEmit,
            (void**)&pEmit);
    if (FAILED(hr))
        goto LExit;
        
    // Save a full copy the metadata to the input stream given. On success
    // ask for the mvid from the loaded copy and return.
    hr = pEmit->SaveToStream(pIStream, 0);

    if (hr == S_OK && pMvid)
        hr = GetMvid(pMvid);

LExit:
    if (pEmit != NULL)
        pEmit->Release();
        
    return (hr);
}


/*
 * GetMvid will return the currently active metadata ID for the executing
 * process.  This value can be used in conjunction with CopyMetaData to
 * cache the most recent copy of the metadata and avoid expensive copies.
 * So for example, if you call CopyMetaData once and save that copy,
 * then on the next E&C operation you can ask for the current MVID and see
 * if it is already in your cache.  If it is, use your version instead of
 * calling CopyMetaData again.
 */
COM_METHOD CordbEnCSnapshot::GetMvid(GUID *pMvid)
{
    VALIDATE_POINTER_TO_OBJECT(pMvid, GUID *);
    
	IMetaDataImport *pImp = 0;			// Meta data reader api.
	HRESULT		hr;

	//@Todo: do we have to worry about returning the mvid of this snapshot
	// vs the mvid of the current data?

	_ASSERTE(pMvid);

	hr = m_module->GetMetaDataInterface(IID_IMetaDataImport, (IUnknown **) &pImp);
	if (pImp)
	{
		hr = pImp->GetScopeProps(NULL, 0, NULL, pMvid);
		pImp->Release();
	}
	return (hr);
}


COM_METHOD CordbEnCSnapshot::GetDataRVA(ULONG32 *pDataRVA, unsigned int eventType)
{
    if (! pDataRVA)
        return E_POINTER;

    // Create and initialize the event as synchronous
    DebuggerIPCEvent event;
    CordbProcess *pProcess = m_module->m_process;

    pProcess->InitIPCEvent(&event, 
                           DebuggerIPCEventType(eventType), 
                           true,
                           (void *)m_module->GetAppDomain()->m_id);
    event.GetDataRVA.debuggerModuleToken = m_module->m_debuggerModuleToken;
    _ASSERTE(m_module->m_debuggerModuleToken != NULL);

    // Make the request, which is synchronous
    HRESULT hr = pProcess->SendIPCEvent(&event, sizeof(event));
    TESTANDRETURNHR(hr);

    // Return the success of the commit
    *pDataRVA = event.GetDataRVAResult.dataRVA;
    return event.GetDataRVAResult.hr;
}

/*
 * GetRoDataRVA returns the base RVA that should be used when adding new
 * static read only data to an existing image.  The EE will guarantee that
 * any RVA values embedded in the code are valid when the delta PE is
 * applied with new data.  The new data will be added to a page that is
 * marked read only.
 */
COM_METHOD CordbEnCSnapshot::GetRoDataRVA(ULONG32 *pRoDataRVA)
{
    VALIDATE_POINTER_TO_OBJECT(pRoDataRVA, ULONG32 *);
    
    return GetDataRVA(pRoDataRVA, DB_IPCE_GET_RO_DATA_RVA);
}

/*
 * GetRwDataRVA returns the base RVA that should be used when adding new
 * static read/write data to an existing image.  The EE will guarantee that
 * any RVA values embedded in the code are valid when the delta PE is
 * applied with new data.  The ew data will be added to a page that is 
 * marked for both read and write access.
 */
COM_METHOD CordbEnCSnapshot::GetRwDataRVA(ULONG32 *pRwDataRVA)
{
    VALIDATE_POINTER_TO_OBJECT(pRwDataRVA, ULONG32 *);
    
    return GetDataRVA(pRwDataRVA, DB_IPCE_GET_RW_DATA_RVA);
}


/*
 * SetPEBytes gives the snapshot object a reference to the delta PE which was
 * based on the snapshot.  This reference will be AddRef'd and cached until
 * CanCommitChanges and/or CommitChanges are called, at which point the 
 * engine will read the delta PE and remote it into the debugee process where
 * the changes will be checked/applied.
 */
COM_METHOD CordbEnCSnapshot::SetPEBytes(IStream *pIStream)
{
    VALIDATE_POINTER_TO_OBJECT(pIStream, IStream *);
    
	HRESULT		hr = S_OK;

    // Update snapshot version
    m_id = InterlockedIncrement((long *) &m_sNextID);

	// Release any old stream if there.
	if (m_pIStream)
	{
		m_pIStream->Release();
		m_pIStream = NULL;
	}

    // Save the PE
	if (pIStream)
	{
		STATSTG SizeData = {0};

		IfFailGo(pIStream->Stat(&SizeData, STATFLAG_NONAME));
		m_cbPEData = (ULONG) SizeData.cbSize.QuadPart;
		m_pIStream = pIStream;
		pIStream->AddRef();
	}
ErrExit:
    return (hr);
}

/*
 * SetILMap is called once for every method being replace that has
 * active instances on a call stack on a thread in the target process.
 * It is up to the caller of this API to determine this case exists.
 * One should halt the target process before making this check and
 * calling this method.
 *
 * The game plan is this: plunk all this stuff into an unordered array
 * while collecting all this stuff, then (in SendSnapshots) copy the
 * array into the EnC buffer & send it over.  On the other side, we'll 
 * it into a CBinarySearch object & look up IL Maps in ApplyEditAndContinue.
 *
 * @todo Document memory ownership
 */
COM_METHOD CordbEnCSnapshot::SetILMap(mdToken mdFunction, ULONG cMapSize, COR_IL_MAP map[])
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(map, COR_IL_MAP, cMapSize, true, true);

    LOG((LF_CORDB, LL_INFO10000, "CEnCS::SILM: IL map for fnx 0x%x "
        "(0x%x cElt)\n", mdFunction, cMapSize));

    if (m_ILMaps == NULL && (m_ILMaps = new ILMAP_UNORDERED_ARRAY) == NULL)
        return E_OUTOFMEMORY;

    // Don't accept duplicates!
    UnorderedILMap *oldEntries = m_ILMaps->Table();
    USHORT cEntries = m_ILMaps->Count();
    
    for(USHORT iEntry = 0; iEntry < cEntries; iEntry++)
    {
        if (oldEntries[iEntry].mdMethod == mdFunction)
        {
            LOG((LF_CORDB, LL_INFO10000, "CEnCS::SILM: Was given mdTok:0x%x, which "
                "is a dup of entry 0x%x\n", mdFunction, iEntry));
            return E_INVALIDARG;
        }
    }
    
    UnorderedILMap *newEntry = m_ILMaps->Append();
    if (newEntry == NULL)
        return E_OUTOFMEMORY;

    ULONG cbMap = cMapSize*sizeof(COR_IL_MAP);
    newEntry->mdMethod = mdFunction;
    newEntry->cMap = cMapSize;
    newEntry->pMap = (COR_IL_MAP *)new BYTE[cbMap];

    if (newEntry->pMap == NULL)
    {
        UnorderedILMap *first = m_ILMaps->Table();
        USHORT iNewEntry = newEntry-first;
        m_ILMaps->DeleteByIndex(iNewEntry);
        
        return E_OUTOFMEMORY;
    }

    memmove( newEntry->pMap, map, cbMap );

    // Update snapshot version
    m_id = InterlockedIncrement((long *) &m_sNextID);

    return S_OK;
}

COM_METHOD CordbEnCSnapshot::SetPESymbolBytes(IStream *pIStream)
{
    VALIDATE_POINTER_TO_OBJECT(pIStream, IStream *);
    
	HRESULT		hr = S_OK;

    // Update snapshot version
    m_id = InterlockedIncrement((long *) &m_sNextID);

	// Release any old stream if there.
	if (m_pSymIStream)
	{
		m_pSymIStream->Release();
		m_pSymIStream = NULL;
	}

    // Save the PE
	if (pIStream)
	{
		STATSTG SizeData = {0};

		IfFailGo(pIStream->Stat(&SizeData, STATFLAG_NONAME));
		m_cbSymData = (ULONG) SizeData.cbSize.QuadPart;
		m_pSymIStream = pIStream;
		pIStream->AddRef();
	}
ErrExit:
    return (hr);
}

HRESULT CordbEnCSnapshot::UpdateMetadata(void)
{
    HRESULT             hr      = S_OK;
    BYTE               *rgbMetaData = NULL;
    long                cbMetaData;
    IMetaDataImport    *pDelta  = NULL;
    IMetaDataEmit      *pEmit   = NULL;
    IMetaDataDispenser *pDisp   = m_module->m_process->m_cordb->m_pMetaDispenser;

    // Get the metadata
    _ASSERTE(m_pIStream!=NULL);
    hr = FindIStreamMetaData(m_pIStream, 
                            &rgbMetaData, 
                            &cbMetaData);
    if (FAILED(hr))
        goto LExit;

    // Get the ENC data.
    hr = pDisp->OpenScopeOnMemory(rgbMetaData,
                                  cbMetaData,
                                  0,
                                  IID_IMetaDataImport,
                                  (IUnknown**)&pDelta);
    if (FAILED(hr))
        goto LExit;

    // Apply the changes.
    hr = m_module->m_pIMImport->QueryInterface(IID_IMetaDataEmit,
            (void**)&pEmit);
    if (FAILED(hr))
        goto LExit;
        
    hr = pEmit->ApplyEditAndContinue(pDelta);

LExit:
    if (pDelta != NULL)
        pDelta->Release();
    
    if (pEmit != NULL)
        pEmit->Release();

    // Release our copy of the stream.
	LARGE_INTEGER MoveToStart;			// For stream interface.
	MoveToStart.QuadPart = 0;

    ULARGE_INTEGER WhyDoesntAnybodyImplementThisArgCorrectly;
    if (m_pIStream)
    {
        m_pIStream->Seek(MoveToStart, STREAM_SEEK_SET, 
            &WhyDoesntAnybodyImplementThisArgCorrectly);
        m_pIStream->Release();
        m_pIStream = NULL;
    }

    if (m_pSymIStream)
    {
        m_pSymIStream->Release();
        m_pSymIStream = NULL;
    }

    LOG((LF_CORDB,LL_INFO10000, "CP::UM: returning 0x%x\n", hr));
    return hr;
}

/* ------------------------------------------------------------------------- *
 * CordbProcess
 * ------------------------------------------------------------------------- */

/*
 * This is a helper function to both CanCommitChanges and CommitChanges,
 * with the flag checkOnly determining who is the caller.
 */
HRESULT CordbProcess::SendCommitRequest(ULONG cSnapshots,
    ICorDebugEditAndContinueSnapshot *pSnapshots[],
    ICorDebugErrorInfoEnum **pError,
    BOOL checkOnly)
{
    HRESULT hr;

    LOG((LF_CORDB,LL_INFO10000, "CP::SCR: checkonly:0x%x\n",checkOnly));

    // Initialize variable to null in case request fails
    //@TODO: enable once error stuff written
    //*pError = NULL;

    // First of all, check to see that the left and right sides are synched
    hr = SynchSnapshots(cSnapshots, pSnapshots);
    TESTANDRETURNHR(hr);

    // Create and initialize the event as synchronous
    // We'll be sending a NULL appdomain pointer since the individual modules
    // will contains pointers to their respective A.D.s
    DebuggerIPCEvent event;
    InitIPCEvent(&event, DB_IPCE_COMMIT, true, NULL);

    // Point to the commit data, and indicate if it is a check or full commit
    event.Commit.pData = m_pbRemoteBuf;
    event.Commit.checkOnly = checkOnly;

    // Make the request, which is synchronous
    hr = SendIPCEvent(&event, sizeof(event));
    TESTANDRETURNHR(hr);
    _ASSERTE(event.type==DB_IPCE_COMMIT_RESULT);
    _ASSERTE(event.appDomainToken == NULL);
    
    // If there are any errors, read them into this process.
    if(pError)
        (*pError) = NULL;
        
    if (event.CommitResult.cbErrorData != 0)
    {
        hr = S_OK;
        DWORD dwRead = 0;

        UnorderedEnCErrorInfoArray *pErrArray = NULL;
        UnorderedEnCErrorInfoArrayRefCount *rgErr = NULL;
        CordbEnCErrorInfoEnum *pErrorEnum = NULL;
        const BYTE *pbErrs = NULL;

        pbErrs = (const BYTE *)malloc(
            event.CommitResult.cbErrorData * sizeof(BYTE));
        if (pbErrs == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LFail;
        }

    	pErrArray = new UnorderedEnCErrorInfoArray();
        if (pErrArray == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LFail;
        }
        
        rgErr = new UnorderedEnCErrorInfoArrayRefCount();;
        if (rgErr == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LFail;
        }
        rgErr->m_pErrors = pErrArray;

        pErrorEnum = new CordbEnCErrorInfoEnum();
        if (pErrorEnum == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LFail;
        }
        
        if (!ReadProcessMemory(m_handle,
                               event.CommitResult.pErrorArr,
                               rgErr->m_pErrors, 
                               sizeof(UnorderedEnCErrorInfoArray),
                               &dwRead) ||
            dwRead != sizeof(UnorderedEnCErrorInfoArray))
        {
            hr = E_FAIL;
            goto LFail;
        }

        if (!ReadProcessMemory(m_handle,
                               rgErr->m_pErrors->m_pTable,
                               (void *)pbErrs, 
                               event.CommitResult.cbErrorData,
                               &dwRead) ||
            dwRead != event.CommitResult.cbErrorData)
        {
            hr = E_FAIL;
            goto LFail;
        }
        
        rgErr->m_pErrors->m_pTable = (EnCErrorInfo*)pbErrs;

        TranslateLSToRSTokens((EnCErrorInfo*)pbErrs, rgErr->m_pErrors->Count());

        pErrorEnum->Init(rgErr);

        if(pError)
            (*pError) = (ICorDebugErrorInfoEnum *)pErrorEnum;
        
LFail:
        if (FAILED(hr))
        {
            if (pbErrs != NULL)
            {
                free((void*)pbErrs);
                pbErrs = NULL;
            }

            if (rgErr != NULL)
            {
                delete rgErr;
                rgErr = NULL;
            }
            
            if (pErrArray != NULL)
            {
                delete pErrArray;
                pErrArray = NULL;
            }

            if (pErrorEnum != NULL)
            {
                delete pErrorEnum;
                pErrorEnum = NULL;
            }
        }
    }
    //else pError remains NULL

    // Return the success of the commit
    return event.CommitResult.hr;
}


HRESULT CordbProcess::TranslateLSToRSTokens(EnCErrorInfo*rgErrs, USHORT cErrs)
{
    USHORT i = 0;
    EnCErrorInfo *pErrCur = rgErrs;

    while(i<cErrs)
    {
        CordbAppDomain *pAppDomain =(CordbAppDomain*) m_appDomains.GetBase(
            (ULONG)pErrCur->m_appDomain);
        _ASSERTE(pAppDomain != NULL);
        
        pErrCur->m_appDomain = (void *)pAppDomain;                

        CordbModule *module = (CordbModule*) pAppDomain->LookupModule (
            pErrCur->m_module);
            
        _ASSERTE(module != NULL);
        pErrCur->m_module = module;

        pErrCur++;
        i++;
    }

    return S_OK;
}

/*
 * CanCommitChanges is called to see if the delta PE's can be applied to
 * the running process.  If there are any known problems with the changes,
 * then an error information is returned.
 */
COM_METHOD CordbProcess::CanCommitChanges(ULONG cSnapshots, 
                ICorDebugEditAndContinueSnapshot *pSnapshots[], 
                ICorDebugErrorInfoEnum **pError)
{
#ifdef EDIT_AND_CONTINUE_FEATURE
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pSnapshots,
                                   ICorDebugEditAndContinueSnapshot *, 
                                   cSnapshots, 
                                   true, 
                                   true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pError,ICorDebugErrorInfoEnum **);
    
    return CanCommitChangesInternal(cSnapshots, 
                            pSnapshots, 
                            pError, 
                            NULL);
#else
    return E_NOTIMPL;
#endif
}

HRESULT CordbProcess::CanCommitChangesInternal(ULONG cSnapshots, 
                ICorDebugEditAndContinueSnapshot *pSnapshots[], 
                ICorDebugErrorInfoEnum **pError,
                UINT_PTR pAppDomainToken)
{
#ifdef EDIT_AND_CONTINUE_FEATURE
    return SendCommitRequest(cSnapshots, 
                             pSnapshots, 
                             pError, 
                             true);
#else
    return E_NOTIMPL;
#endif
}

/*
 * CommitChanges is called to apply the delta PE's to the running process.
 * Any failures return detailed error information.  There are no rollback 
 * guarantees when a failure occurs.  Applying delta PE's to a running
 * process must be done in the order the snapshots are retrieved and may
 * not be interleaved (ie: there is no merging of multiple snapshots applied
 * out of order or with the same root).
 */
COM_METHOD CordbProcess::CommitChanges(ULONG cSnapshots, 
    ICorDebugEditAndContinueSnapshot *pSnapshots[], 
    ICorDebugErrorInfoEnum **pError)
{
#ifdef EDIT_AND_CONTINUE_FEATURE
    LOG((LF_CORDB,LL_INFO10000, "CP::CC: given 0x%x snapshots "
        "to commit\n", cSnapshots));

    VALIDATE_POINTER_TO_OBJECT_ARRAY(pSnapshots,
                                   ICorDebugEditAndContinueSnapshot *, 
                                   cSnapshots, 
                                   true, 
                                   true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pError,ICorDebugErrorInfoEnum **);
    
    return CommitChangesInternal(cSnapshots, 
                         pSnapshots, 
                         pError, 
                         NULL);
#else
    return E_NOTIMPL;
#endif
}

HRESULT CordbProcess::CommitChangesInternal(ULONG cSnapshots, 
    ICorDebugEditAndContinueSnapshot *pSnapshots[], 
    ICorDebugErrorInfoEnum **pError,
    UINT_PTR pAppDomainToken)
{
#ifdef EDIT_AND_CONTINUE_FEATURE
    HRESULT hr =  SendCommitRequest(cSnapshots,
                                    pSnapshots, 
                                    pError, 
                                    false);
    if (FAILED(hr))
        return hr;

    //Merge the right side metadata
    for (ULONG i = 0; i < cSnapshots;i++)
    {
        LOG((LF_CORDB,LL_INFO10000, "CP::SS: About to UpdateMetadata "
            "for snapshot 0x%x\n", i));

        // @todo Once multiple errors have been done, don't
        // merge EnC changes for anything that's already failed.
        ((CordbEnCSnapshot*)pSnapshots[i])->UpdateMetadata();
   }

    return hr;
#else
    return E_NOTIMPL;
#endif
}

/*
 * This is used to synchronize the snapshots with the left side.
 */
HRESULT CordbProcess::SynchSnapshots(ULONG cSnapshots,
                                     ICorDebugEditAndContinueSnapshot *pSnapshots[])
{
    // Check to see if the provided data is the same as the cached data
    // on the left side
    EnCSnapshotInfo *pInfo = m_pSnapshotInfos->Table();
    ULONG cSynchedSnapshots = (ULONG)m_pSnapshotInfos->Count();
    
    if(m_pbRemoteBuf && 
       cSynchedSnapshots == cSnapshots)
    {
        for (ULONG i = 0; i < cSnapshots; i++)
        {
            if (pInfo->m_nSnapshotCounter != ((CordbEnCSnapshot *)pSnapshots[i])->m_id)
            {
                // Something doesn't match, so send over a completely 
                // new set of snapshots.  The left side will handle freeing the memory
                // @ shutdown.

                // @todo
                // This will 'leak' static variable space - we'll still free it, but
                // there's potentially some static variable space we won't be able
                // to use.
            
                return SendSnapshots(cSnapshots, pSnapshots);;
            }
			pInfo++;
        }
	    return S_OK;        
    }
    else
        return SendSnapshots(cSnapshots, pSnapshots);
}

/*
 * This is used to write a stream into the remote process.
 */
HRESULT CordbProcess::WriteStreamIntoProcess(IStream *pIStream,
                                             void *pBuffer,
                                             BYTE *pRemoteBuffer,
                                             ULONG cbOffset)
{
    HRESULT hr = S_OK;
    
    for (;;)
    {
        ULONG cbReadPid;
        ULONG cbRead = 0;
        hr = pIStream->Read(pBuffer, ENC_COPY_SIZE, &cbRead);
			
        if (hr == S_OK && cbRead)
        {
            BOOL succ = WriteProcessMemory(m_handle,
                                           (void *)(pRemoteBuffer + cbOffset),
                                           pBuffer,
                                           cbRead,
                                           &cbReadPid);
            if (!succ)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }

            cbOffset += cbRead;
        }
        else
        {
            if (hr == S_FALSE)
                hr = S_OK;

            break;
        }
    }

    return hr;
}

#define WSIF_BUFFER_SIZE 300
#include "Windows.H"
HRESULT CordbProcess::WriteStreamIntoFile(IStream *pIStream,
                                          LPCWSTR name)
{
    HRESULT hr = S_OK;
    BYTE rgb[WSIF_BUFFER_SIZE];
    STATSTG statstg;
    ULARGE_INTEGER  icb;
    icb.QuadPart = 0; 
    ULONG cbRead;
    DWORD dwNumberOfBytesWritten;
    HANDLE hFile = WszCreateFile(name,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return E_FAIL;
    }

    hr = pIStream->Stat(&statstg, STATFLAG_NONAME);

    if (FAILED(hr))
        return hr;

    while (icb.QuadPart < statstg.cbSize.QuadPart)
    {
        hr = pIStream->Read((void *)rgb,
                  WSIF_BUFFER_SIZE,
                  &cbRead);
        if (FAILED(hr))
            return hr;

        if (!WriteFile(hFile,rgb, WSIF_BUFFER_SIZE, &dwNumberOfBytesWritten,NULL))
        {
            hr = E_FAIL;
            goto LExit;
        }

        icb.QuadPart += cbRead;
    }
    
LExit:
    CloseHandle(hFile);
    return hr;
}

/*
 * This is used to send the snapshots to the left side.
 */
HRESULT CordbProcess::SendSnapshots(ULONG cSnapshots,
                                    ICorDebugEditAndContinueSnapshot *pSnapshots[])
{
    HRESULT		hr = S_OK;
    ULONG		cbData;					// size of buffer required
    ULONG		cbHeader;				// size of header required
    ULONG		i;
	void		*pBuffer = NULL;		// Working buffer for copy.
	LARGE_INTEGER MoveToStart;			// For stream interface.
	ULARGE_INTEGER Pad;					// Wasted space for seek.
    BOOL		succ;
    ULONG       cbWritten;

    m_EnCCounter++;

    LOG((LF_CORDB,LL_INFO10000, "CP::SS\n"));

    // Figure out the size of the header
    cbHeader = ENC_GET_HEADER_SIZE(cSnapshots);

    // Create a copy of the header locally
    EnCInfo *header = (EnCInfo *)_alloca(cbHeader);
    EnCEntry *entries = (EnCEntry *)((BYTE *)header + sizeof(header));
    
    // Fill in the header, as well as calculate the total buffer size required
    cbData = cbHeader;
    header->count = cSnapshots;

    // Keep track of which snapshots & which versions we're looking at.
    m_pSnapshotInfos->Clear();

    // Calculate the buffer size required, and fill in the header
    for (i = 0; i < cSnapshots; i++)
    {
        LOG((LF_CORDB,LL_INFO10000, "CP::SS:calculating snapshot 0x%x\n", i));

        CordbEnCSnapshot *curSnapshot = (CordbEnCSnapshot *)pSnapshots[i];

        // Fill out the entry
        entries[i].offset = cbData;
        entries[i].peSize = curSnapshot->GetImageSize();
        entries[i].symSize = curSnapshot->GetSymSize();
        entries[i].mdbgtoken = curSnapshot->GetModule()->m_debuggerModuleToken;
        _ASSERTE(entries[i].mdbgtoken != NULL);

        // Keep track of the required buffer size
        cbData += entries[i].peSize + entries[i].symSize;
        
        // Figure out how much space the IL Maps 'directory' will occupy.
        // Immediately after the stream is written in to memory, the
        // int sized count of (soon-to-be) ordered array of IL Map entries 
        // will be written.  The array itself will follow 
        // immediately after the count, and following that will be the 
        // IL Maps themselves, in the same order as the entries.  
        // What arrives
        // at the left side will be a easy to use a CBinarySearch on, so
        // that we can get at the ILmap for a given function quickly

        // We'll always need the count, even if there are no maps
        ULONG cbILMaps = sizeof(int); 
        
        if (curSnapshot->m_ILMaps != NULL && curSnapshot->m_ILMaps->Count()>0)
        {
            // We want the entries sorted by methodDef so that the left side can
            // find them reasonably quickly. Now is a good time to sort the 
            // previously unordered array
            QSortILMapEntries *pQS = new QSortILMapEntries(
                                                  curSnapshot->m_ILMaps->Table(),
                                                  curSnapshot->m_ILMaps->Count());

            pQS->Sort();

            // How much space for the IL Map directory?
            USHORT cILMaps = curSnapshot->m_ILMaps->Count();
            cbILMaps += sizeof(UnorderedILMap)*cILMaps;

            // How much space for each of the IL maps themselves?
            UnorderedILMap *rgILMap = curSnapshot->m_ILMaps->Table();
            _ASSERTE( rgILMap != NULL);
            
            for(int iILMap = 0; iILMap < cILMaps;iILMap++)
            {
                cbILMaps += sizeof(COR_IL_MAP) * rgILMap[iILMap].cMap;
            }
        }        

        // We're going to send the IL Maps across too, budget space for them.
        // The IL Maps will occur immediately after the stream.
        cbData += cbILMaps;
    }

    LOG((LF_CORDB,LL_INFO10000, "CP::SS:Need 0x%x bytes, already have 0x%x\n",
        cbData, m_cbRemoteBuf));

    // This is wacked - we don't completely get all the info we need out of
    // the image when we commit the EnC, and so we'll end up overwriting
    // whatever's there the next time we do an EnC.  So we should always get
    // a new buffer.
    // Get a newly allocated remote buffer
    IfFailGo(GetRemoteBuffer(cbData, &m_pbRemoteBuf));

    // Succeeded, so keep track of the size of the remote buffer
    m_cbRemoteBuf = cbData;

    LOG((LF_CORDB,LL_INFO10000, "CP::SS:obtained 0x%x bytes in the "
        "left side\n", m_cbRemoteBuf));
    _ASSERTE(cbData == m_cbRemoteBuf);

    // Perform WriteProcessMemory for the header
    succ = WriteProcessMemory(m_handle, m_pbRemoteBuf, header,
                              cbHeader, NULL);
	if (!succ) 
		IfFailGo(HRESULT_FROM_WIN32(GetLastError()));

    LOG((LF_CORDB,LL_INFO10000, "CP::SS: Wrote memory into LHS!\n"));
        
	// Malloc a chunk of memory we can use to copy the PE's to the target
	// process.  Must have a buffer in order to copy from a Stream.
	pBuffer = malloc(ENC_COPY_SIZE);
	if (!pBuffer)
		IfFailGo(E_OUTOFMEMORY);

    LOG((LF_CORDB,LL_INFO10000, "CP::SS: Malloced a local buffer\n"));

	// Init stream items.
	MoveToStart.QuadPart = 0;

    // Now perform a WriteProcessMemory for each PE
    for (i = 0; i < cSnapshots; i++)
    {
        LOG((LF_CORDB,LL_INFO10000, "CP::SS: Sending snapshot 0x%x\n", i));
        
        CordbEnCSnapshot *curSnapshot = (CordbEnCSnapshot *)pSnapshots[i];

		// Get a pointer to the stream object we can use to read from.
		// Make sure the stream pointer is at the front of the stream.
		IStream *pIStream = curSnapshot->GetStream();
        IStream *pSymIStream = NULL;
		if (!pIStream)
			continue;
		pIStream->Seek(MoveToStart, STREAM_SEEK_SET, &Pad);

		// Read and write chunks of the stream to the target process.
        IfFailGo(WriteStreamIntoProcess(pIStream,
                                        pBuffer,
                                        (BYTE*)m_pbRemoteBuf,
                                        entries[i].offset));

        LOG((LF_CORDB,LL_INFO10000, "CP::SS: Wrote stream into process\n"));
        
        // Write the symbol stream into the process after the image
        // stream.
		pSymIStream = curSnapshot->GetSymStream();

        if (pSymIStream && (curSnapshot->GetSymSize() > 0))
        {
            LOG((LF_CORDB,LL_INFO10000, "CP::SS: There exist symbols - "
                "about to write\n"));
            
            pSymIStream->Seek(MoveToStart, STREAM_SEEK_SET, &Pad);
        
            IfFailGo(WriteStreamIntoProcess(pSymIStream,
                                            pBuffer,
                                            (BYTE*)m_pbRemoteBuf,
                                            entries[i].offset +
                                            entries[i].peSize));

            // Uncomment this if you want to spit the .pdb stream into the given file.
//            WriteStreamIntoFile(pSymIStream,
//                               (LPCWSTR)L"EnCSymbols.pdb");
            LOG((LF_CORDB,LL_INFO10000, "CP::SS: Symbols written\n"));
        }

        ULONG cbOffset = entries[i].offset +
            entries[i].peSize +
            entries[i].symSize;
        
        // Now sluice over the IL Maps.
        if (curSnapshot->m_ILMaps == NULL || 
            curSnapshot->m_ILMaps->Count() == 0)
        {
            LOG((LF_CORDB,LL_INFO10000, "CP::SS: No IL maps for this snapshot!\n"));
                
            int temp = 0;
        
            succ = WriteProcessMemory(
            			m_handle,
            			(void *)((BYTE *)m_pbRemoteBuf + cbOffset),
            			&temp,
            			sizeof(int),
            			&cbWritten);
            if (!succ)
            {
            	hr = HRESULT_FROM_WIN32(GetLastError());
            	break;
            }
            _ASSERTE( cbWritten == sizeof(int) );
            
            cbOffset += sizeof(int);
        }
        else
        {
            int cILMaps = (int)(curSnapshot->m_ILMaps->Count());

            LOG((LF_CORDB,LL_INFO10000, "CP::SS: 0x%x IL maps for this "
                "snapshot!\n", cILMaps));
                
            succ = WriteProcessMemory(
            			m_handle,
            			(void *)((BYTE *)m_pbRemoteBuf + cbOffset),
            			&cILMaps,
            			sizeof(int),
            			&cbWritten);
            if (!succ)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                
                LOG((LF_CORDB,LL_INFO10000, "CP::SS: Failed to write IL "
                    "map count!\n"));
                    
                break;
            }

            _ASSERTE( cbWritten == sizeof(int));
            cbOffset += sizeof(int);
            
            // Write the IL Maps array
            // NOTE that we're not fixing up any of the pointers in any
            // of the entries (yet - the left side will do this)
            ULONG cbILMapsDir = sizeof(UnorderedILMap) * cILMaps;
            
            succ = WriteProcessMemory(
            			m_handle,
            			(void *)((BYTE *)m_pbRemoteBuf + cbOffset),
            			curSnapshot->m_ILMaps->Table(),
            			cbILMapsDir,
            			&cbWritten);
            if (!succ)
            {
            	hr = HRESULT_FROM_WIN32(GetLastError());
            	
                LOG((LF_CORDB,LL_INFO10000, "CP::SS: Failed to write IL "
                    "map directory!\n"));
            	break;
            }

            _ASSERTE( cbWritten == cbILMapsDir);
            cbOffset += cbWritten;
            
            // Write the IL maps themselves
            UnorderedILMap *rgILMap = curSnapshot->m_ILMaps->Table();
            _ASSERTE( rgILMap != NULL);
            
            for(int iILMap = 0; iILMap < cILMaps;iILMap++)
            {
                LOG((LF_CORDB,LL_INFO10000, "CP::SS: About to write map "
                    "0x%x\n", iILMap));
                    
                ULONG cbILMap = sizeof(COR_IL_MAP) * rgILMap[iILMap].cMap;
                
                succ = WriteProcessMemory(
                			m_handle,
                			(void *)((BYTE *)m_pbRemoteBuf + cbOffset),
                			rgILMap[iILMap].pMap,
                			cbILMap,
                			&cbWritten);
                if (!succ)
                {
                	hr = HRESULT_FROM_WIN32(GetLastError());

                    LOG((LF_CORDB,LL_INFO10000, "CP::SS: Failed to write IL "
                        "map 0x%x!\n", iILMap));
                        
                	break;
                }

                _ASSERTE( cbWritten == cbILMap);
                cbOffset += cbWritten;
            }

            // NOTE: There are a lot of pointers that will need fixing up
            // (the pMap pointers).  We'll leave that for the left side since
            // it's much easier for them to twiddle things (no 
            // WriteProcessMemory()s required over there).
        }   // End of "nonNULL IL maps"

		// GetStream() AddRef'd the stream, so Release it now.  It'll still be
        // there for metadata update, later.
        pIStream->Release();

        if (pSymIStream)
            pSymIStream->Release();

		// If there was a fatal error, then leave now.
		IfFailGo(hr);

		EnCSnapshotInfo *pInfo = m_pSnapshotInfos->Append();
	    pInfo->m_nSnapshotCounter = curSnapshot->m_id;
    } // go to the next snapshot

    

ErrExit:
    LOG((LF_CORDB,LL_INFO10000, "CP::SS: Finished, return 0x%x!\n", hr));

	// Cleanup pointers we've allocated.
	if (pBuffer)
		free(pBuffer);
	return (hr);
}


/*
 * This will request a buffer of size cbBuffer to be allocated
 * on the left side.
 *
 * If successful, returns S_OK.  If unsuccessful, returns E_OUTOFMEMORY.
 */
HRESULT CordbProcess::GetRemoteBuffer(ULONG cbBuffer, void **ppBuffer)
{
    // Initialize variable to null in case request fails
    *ppBuffer = NULL;

    // Create and initialize the event as synchronous
    DebuggerIPCEvent event;
    InitIPCEvent(&event, 
                 DB_IPCE_GET_BUFFER, 
                 true,
                 NULL);

    // Indicate the buffer size wanted
    event.GetBuffer.bufSize = cbBuffer;

    // Make the request, which is synchronous
    HRESULT hr = SendIPCEvent(&event, sizeof(event));
    TESTANDRETURNHR(hr);

    // Save the result
    *ppBuffer = event.GetBufferResult.pBuffer;

    // Indicate success
    return event.GetBufferResult.hr;
}

/*
 * This will release a previously allocated left side buffer.
 */
HRESULT CordbProcess::ReleaseRemoteBuffer(void **ppBuffer)
{
    // Create and initialize the event as synchronous
    DebuggerIPCEvent event;
    InitIPCEvent(&event, 
                 DB_IPCE_RELEASE_BUFFER, 
                 true,
                 NULL);

    // Indicate the buffer to release
    event.ReleaseBuffer.pBuffer = (*ppBuffer);

    // Make the request, which is synchronous
    HRESULT hr = SendIPCEvent(&event, sizeof(event));
    TESTANDRETURNHR(hr);

    (*ppBuffer) = NULL;

    // Indicate success
    return event.ReleaseBufferResult.hr;
}

/* ------------------------------------------------------------------------- *
 * CordbModule
 * ------------------------------------------------------------------------- */

/*
 * Edit & Continue support.   GetEditAndContinueSnapshot produces a snapshot
 * of the running process.  This snapshot can then be fed into the compiler
 * to guarantee the same token values are returned by the meta data during
 * compile, to find the address where new static data should go, etc.  These
 * changes are comitted using ICorDebugProcess.
 */

HRESULT CordbModule::GetEditAndContinueSnapshot(
    ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot)
{
#ifdef EDIT_AND_CONTINUE_FEATURE
    VALIDATE_POINTER_TO_OBJECT(ppEditAndContinueSnapshot, 
                               ICorDebugEditAndContinueSnapshot **);

	*ppEditAndContinueSnapshot = new CordbEnCSnapshot(this);
	if (!*ppEditAndContinueSnapshot)
		return E_OUTOFMEMORY;
		
	(*ppEditAndContinueSnapshot)->AddRef();
    return S_OK;
#else
    return E_NOTIMPL;
#endif
}



static const char g_szCORMETA[] = ".cormeta";

// Following structure is copied from cor.h
#define IMAGE_DIRECTORY_ENTRY_COMHEADER 	14
#define SIZE_OF_NT_SIGNATURE sizeof(DWORD)

/*++

Routine Description:

	This function locates an RVA within the image header of a file
	that is mapped as a file and returns a pointer to the section
	table entry for that virtual address

Arguments:

	NtHeaders - Supplies the pointer to the image or data file.

	Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

	NULL - The RVA was not found within any of the sections of the image.

	NON-NULL - Returns the pointer to the image section that contains
			   the RVA

--*/
// Following two functions lifted, then modified, from NT sources, imagedir.c
PIMAGE_SECTION_HEADER
Cor_RtlImageRvaToSection(
	IN PIMAGE_NT_HEADERS NtHeaders,
	IN ULONG Rva
	)
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) 
    {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData)
        {
            return NtSection;
        }
        ++NtSection;
    }

    return NULL;
}


/*++

Routine Description:

	This function locates an RVA within the image header of a file that
	is mapped as a file and returns the virtual addrees of the
	corresponding byte in the file.


Arguments:

	NtHeaders - Supplies the pointer to the image or data file.

	Rva - Supplies the relative virtual address (RVA) to locate.

	LastRvaSection - Optional parameter that if specified, points
		to a variable that contains the last section value used for
		the specified image to translate and RVA to a VA.

Return Value:

	NULL - The file does not contain the specified RVA

	NON-NULL - Returns the virtual addrees in the mapped file.

--*/
BYTE *
Cor_RtlImageRvaToVa(PIMAGE_NT_HEADERS NtHeaders,
                    IStream *pIsImage,
                    ULONG Rva,
                    ULONG cb)
{
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = Cor_RtlImageRvaToSection(NtHeaders,
                                         Rva);

    if (NtSection != NULL) 
    {
        BYTE *pb = new BYTE[cb];
        LARGE_INTEGER offset;
        offset.QuadPart = (Rva - NtSection->VirtualAddress) +
                                 NtSection->PointerToRawData;

        ULARGE_INTEGER WhyDoesntAnybodyImplementThisArgCorrectly;
        HRESULT hr = pIsImage->Seek(offset, STREAM_SEEK_SET, 
            &WhyDoesntAnybodyImplementThisArgCorrectly);
        if (FAILED(hr))
        {
            delete [] pb;
            return NULL;
        }

        ULONG cbRead;
        hr = pIsImage->Read(pb, cb, &cbRead);
        if (FAILED(hr) || cbRead !=cb)
        {
            delete [] pb;
            return NULL;
        }
        
        return pb;
    }
    else 
    {
        return NULL;
    }
}


HRESULT FindImageNtHeader (IStream *pIsImage, IMAGE_NT_HEADERS **ppNtHeaders)
{
    _ASSERTE( pIsImage != NULL );
    _ASSERTE( ppNtHeaders != NULL );

    IMAGE_DOS_HEADER    DosHeader;
    ULONG               cbRead = 0;
    HRESULT             hr;
    LARGE_INTEGER       offset;
	IMAGE_NT_HEADERS	temp;

    offset.QuadPart = 0;
    ULARGE_INTEGER WhyDoesntAnybodyImplementThisArgCorrectly;
    hr = pIsImage->Seek(offset, STREAM_SEEK_SET, 
        &WhyDoesntAnybodyImplementThisArgCorrectly);
    if (FAILED(hr))
        goto LFail;

    _ASSERTE( hr == S_OK );
        
    hr = pIsImage->Read( &DosHeader, sizeof(IMAGE_DOS_HEADER), &cbRead);
    if (FAILED(hr))
        goto LFail;
        
    if (cbRead != sizeof(IMAGE_DOS_HEADER))
    {
        hr = E_FAIL;
        goto LFail;
    }

    if (DosHeader.e_magic != IMAGE_DOS_SIGNATURE) 
    {
        hr = E_FAIL;
        goto LFail;
    }
    
    offset.QuadPart = DosHeader.e_lfanew;
    hr = pIsImage->Seek(offset, STREAM_SEEK_SET, 
        &WhyDoesntAnybodyImplementThisArgCorrectly);
    if (FAILED(hr))
        goto LFail;
    
    hr = pIsImage->Read( &temp, sizeof(IMAGE_NT_HEADERS), &cbRead);
    if (FAILED(hr))
        goto LFail;

    if (cbRead != sizeof(IMAGE_NT_HEADERS))
    {
        hr = E_FAIL;
        goto LFail;
    }

    if (temp.Signature != IMAGE_NT_SIGNATURE) 
    {
        hr = E_FAIL;
        goto LFail;
    }

    offset.QuadPart = DosHeader.e_lfanew;
    hr = pIsImage->Seek(offset, STREAM_SEEK_SET, 
        &WhyDoesntAnybodyImplementThisArgCorrectly);
    if (FAILED(hr))
        goto LFail;
    
	ULONG cbSectionHeaders;
	cbSectionHeaders = temp.FileHeader.NumberOfSections 
			* sizeof(IMAGE_SECTION_HEADER);
	ULONG cbNtHeaderTotal;
	cbNtHeaderTotal = sizeof(IMAGE_NT_HEADERS)+cbSectionHeaders;

	(*ppNtHeaders) = (IMAGE_NT_HEADERS*)new BYTE[cbNtHeaderTotal];

    hr = pIsImage->Read((*ppNtHeaders), 
					      cbNtHeaderTotal, 
						 &cbRead);
    if (FAILED(hr))
        goto LFail;


    if (cbRead != cbNtHeaderTotal) 
    {
        hr = E_FAIL;
        goto LFail;
    }

    _ASSERTE( (*ppNtHeaders)->Signature == IMAGE_NT_SIGNATURE);
    
    goto LExit;
    
LFail:
    (*ppNtHeaders) = NULL;
LExit:
    return hr;
}


HRESULT FindIStreamMetaData(IStream *pIsImage, 
                            BYTE **prgbMetaData, 
                            long *pcbMetaData)
{
    IMAGE_COR20_HEADER		*pCorHeader = NULL;
    IMAGE_NT_HEADERS		*pNtImageHeader = NULL;
    PIMAGE_SECTION_HEADER	pSectionHeader = NULL;
    HRESULT                 hr;

    // Get the NT header
    hr = FindImageNtHeader(pIsImage, &pNtImageHeader);
    if (FAILED(hr))
        return hr;
        
    *prgbMetaData = NULL;
    *pcbMetaData = 0;

    // Get the COM2.0 header
    pSectionHeader = (PIMAGE_SECTION_HEADER)
                        Cor_RtlImageRvaToVa(pNtImageHeader, 
                                            pIsImage, 
                                            pNtImageHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress,                                            sizeof(IMAGE_COR20_HEADER));
        
    if (pSectionHeader)
    {
        // Check for a size which would indicate the retail header.
        DWORD dw = *(DWORD *) pSectionHeader;
        if (dw == sizeof(IMAGE_COR20_HEADER))
        {
            pCorHeader = (IMAGE_COR20_HEADER *) pSectionHeader;

            // Grab the metadata itself
            *prgbMetaData = Cor_RtlImageRvaToVa(pNtImageHeader, 
                                                pIsImage,
                                                pCorHeader->MetaData.VirtualAddress,
                                                pCorHeader->MetaData.Size);
                                              
            *pcbMetaData = pCorHeader->MetaData.Size;
        }
        else
            return (E_FAIL);
    }

	if (pSectionHeader != NULL)
		delete [] (BYTE*)pSectionHeader;

	if (pNtImageHeader != NULL)
		delete [] (BYTE *)pNtImageHeader;

    if (*prgbMetaData == NULL || *pcbMetaData == 0)
        return (E_FAIL);
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\divalue.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: DIValue.cpp
//
//*****************************************************************************
#include "stdafx.h"

#ifdef UNDEFINE_RIGHT_SIDE_ONLY
#undef RIGHT_SIDE_ONLY
#endif //UNDEFINE_RIGHT_SIDE_ONLY

/* ------------------------------------------------------------------------- *
 * CordbValue class
 * ------------------------------------------------------------------------- */

//
// Init for the base value class. All value class subclasses call this
// during their initialization to make a private copy of their value's
// signature.
//
HRESULT CordbValue::Init(void)
{
    if (m_cbSigBlob > 0 && m_sigCopied == false)
    {
        LOG((LF_CORDB,LL_INFO1000,"CV::I obj:0x%x has been inited\n", this));
        
        PCCOR_SIGNATURE origSig = m_pvSigBlob;
        m_pvSigBlob = NULL;

        BYTE *sigCopy = new BYTE[m_cbSigBlob];

        if (sigCopy == NULL)
            return E_OUTOFMEMORY;

        memcpy(sigCopy, origSig, m_cbSigBlob);

        m_pvSigBlob = (PCCOR_SIGNATURE) sigCopy;
        m_sigCopied = true; 
    }

    return S_OK;
}

//
// Create the proper value object based on the given element type.
//
/*static*/ HRESULT CordbValue::CreateValueByType(CordbAppDomain *appdomain,
                                                 CordbModule *module,
                                                 ULONG cbSigBlob,
                                                 PCCOR_SIGNATURE pvSigBlob,
                                                 CordbClass *optionalClass,
                                                 REMOTE_PTR remoteAddress,
                                                 void *localAddress,
                                                 bool objectRefsInHandles,
                                                 RemoteAddress *remoteRegAddr,
                                                 IUnknown *pParent,
                                                 ICorDebugValue **ppValue)
{
    HRESULT hr = S_OK;

    *ppValue = NULL;

    // We don't care about the modifiers, but one of the created
    // object might.
    ULONG           cbSigBlobNoMod = cbSigBlob;
    PCCOR_SIGNATURE pvSigBlobNoMod = pvSigBlob;

	// If we've got some funky modifier, then remove it.
	ULONG cb =_skipFunkyModifiersInSignature(pvSigBlobNoMod);
    if( cb != 0)
    {
    	cbSigBlobNoMod -= cb;
        pvSigBlobNoMod = &pvSigBlobNoMod[cb];
    }
	
    switch(*pvSigBlobNoMod)
    {
    case ELEMENT_TYPE_BOOLEAN:
    case ELEMENT_TYPE_CHAR:
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_R4:
    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
    case ELEMENT_TYPE_R8:
    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:
        {
            // A generic value
            CordbGenericValue* pGenValue = new CordbGenericValue(appdomain, module, cbSigBlob, pvSigBlob,
                                                                 remoteAddress, localAddress, remoteRegAddr);

            if (pGenValue != NULL)
            {
                hr = pGenValue->Init();

                if (SUCCEEDED(hr))
                {
                    pGenValue->AddRef();
                    pGenValue->SetParent(pParent);
                    *ppValue = (ICorDebugValue*)(ICorDebugGenericValue*)pGenValue;
                }
                else
                    delete pGenValue;
            }
            else
                hr = E_OUTOFMEMORY;

            break;
        }        

    //
    // @todo: replace MDARRAY with ARRAY when the time comes.
    //
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_STRING:
    case ELEMENT_TYPE_PTR:
    case ELEMENT_TYPE_BYREF:
    case ELEMENT_TYPE_TYPEDBYREF:
    case ELEMENT_TYPE_ARRAY:
	case ELEMENT_TYPE_SZARRAY:
    case ELEMENT_TYPE_FNPTR:
        {
            // A reference, possibly to an object or value class
            // Weak by default
            CordbReferenceValue* pRefValue = new CordbReferenceValue(appdomain, module, cbSigBlob, pvSigBlob,
                                                                     remoteAddress, localAddress, objectRefsInHandles,
                                                                     remoteRegAddr);

            if (pRefValue != NULL)
            {
                hr = pRefValue->Init(bCrvWeak);

                if (SUCCEEDED(hr))
                {
                    pRefValue->AddRef();
                    pRefValue->SetParent(pParent);
                    *ppValue = (ICorDebugValue*)(ICorDebugReferenceValue*)pRefValue;
                }
                else
                    delete pRefValue;
            }
            else
                hr = E_OUTOFMEMORY;
            
            break;
        }
        

    case ELEMENT_TYPE_VALUETYPE:
        {
            // A value class object.
            CordbVCObjectValue* pVCValue = new CordbVCObjectValue(appdomain, module, cbSigBlob, pvSigBlob,
                                                                  remoteAddress, localAddress, optionalClass, remoteRegAddr);

            if (pVCValue != NULL)
            {
                pVCValue->SetParent(pParent);
                hr = pVCValue->Init();

                if (SUCCEEDED(hr))
                {
                    pVCValue->AddRef();
                    *ppValue = (ICorDebugValue*)(ICorDebugObjectValue*)pVCValue;
                }
                else
                    delete pVCValue;
            }
            else
                hr = E_OUTOFMEMORY;
            
            break;
        }
        
    default:
        _ASSERTE(!"Bad value type!");
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CordbValue::CreateBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppBreakpoint, ICorDebugValueBreakpoint **);
    
    return E_NOTIMPL;
#endif //RIGHT_SIDE_ONLY    
}

//
// This will update a register in a given context, and in the
// regdisplay of a given frame.
//
HRESULT CordbValue::SetContextRegister(CONTEXT *c,
                                       CorDebugRegister reg,
                                       DWORD newVal,
                                       CordbNativeFrame *frame)
{
#ifdef _X86_
    HRESULT hr = S_OK;
    DWORD *rdRegAddr;

#define _UpdateFrame() \
    if (frame != NULL) \
    { \
        rdRegAddr = frame->GetAddressOfRegister(reg); \
        *rdRegAddr = newVal; \
    }
    
    switch(reg)
    {
    case REGISTER_X86_EIP:
        c->Eip = newVal;
        break;
        
    case REGISTER_X86_ESP:
        c->Esp = newVal;
        break;
        
    case REGISTER_X86_EBP:
        c->Ebp = newVal;
        _UpdateFrame();
        break;
        
    case REGISTER_X86_EAX:
        c->Eax = newVal;
        _UpdateFrame();
        break;
        
    case REGISTER_X86_ECX:
        c->Ecx = newVal;
        _UpdateFrame();
        break;
        
    case REGISTER_X86_EDX:
        c->Edx = newVal;
        _UpdateFrame();
        break;
        
    case REGISTER_X86_EBX:
        c->Ebx = newVal;
        _UpdateFrame();
        break;
        
    case REGISTER_X86_ESI:
        c->Esi = newVal;
        _UpdateFrame();
        break;
        
    case REGISTER_X86_EDI:
        c->Edi = newVal;
        _UpdateFrame();
         break;

    default:
        _ASSERTE(!"Invalid register number!");
    }

    return hr;
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - SetContextRegister (DIValue.cpp)");
    return E_FAIL;
#endif // _X86_
}

HRESULT CordbValue::SetEnregisteredValue(void *pFrom)
{
#ifdef _X86_
    HRESULT hr = S_OK;

    // Get the thread's context so we can update it.
    CONTEXT *cTemp;
    CordbNativeFrame *frame = (CordbNativeFrame*)m_remoteRegAddr.frame;

    // Can't set an enregistered value unless the frame the value was
    // from is also the current leaf frame. This is because we don't
    // track where we get the registers from every frame from.
    if (frame->GetID() != frame->m_thread->m_stackFrames[0]->GetID())
        return CORDBG_E_SET_VALUE_NOT_ALLOWED_ON_NONLEAF_FRAME;

    if (FAILED(hr =
               frame->m_thread->GetContext(&cTemp)))
        goto Exit;

    // Its important to copy this context that we're given a ptr to.
    CONTEXT c;
    c = *cTemp;
    
    // Update the context based on what kind of enregistration we have.
    switch (m_remoteRegAddr.kind)
    {
    case RAK_REG:
        {
            DWORD newVal;
            switch(m_size)
            {
                case 1:  _ASSERTE(sizeof( BYTE) == 1); newVal = *( BYTE*)pFrom; break;
                case 2:  _ASSERTE(sizeof( WORD) == 2); newVal = *( WORD*)pFrom; break;
                case 4:  _ASSERTE(sizeof(DWORD) == 4); newVal = *(DWORD*)pFrom; break;
                default: _ASSERTE(!"bad m_size");
            }
            hr = SetContextRegister(&c, m_remoteRegAddr.reg1, newVal, frame);
        }
        break;
        
    case RAK_REGREG:
        {
            _ASSERTE(m_size == 8);
            _ASSERTE(sizeof(DWORD) == 4);
            
            // Split the new value into high and low parts.
            DWORD highPart;
            DWORD lowPart;

            memcpy(&lowPart, pFrom, sizeof(DWORD));
            memcpy(&highPart, (void*)((DWORD)pFrom + sizeof(DWORD)),
                   sizeof(DWORD));

            // Update the proper registers.
            hr = SetContextRegister(&c, m_remoteRegAddr.reg1, highPart, frame);

            if (SUCCEEDED(hr))
                hr = SetContextRegister(&c, m_remoteRegAddr.reg2, lowPart,
                                        frame);
        }
        break;
        
    case RAK_REGMEM:
        {
            _ASSERTE(m_size == 8);
            _ASSERTE(sizeof(DWORD) == 4);
            
            // Split the new value into high and low parts.
            DWORD highPart;
            DWORD lowPart;

            memcpy(&lowPart, pFrom, sizeof(DWORD));
            memcpy(&highPart, (void*)((DWORD)pFrom + sizeof(DWORD)),
                   sizeof(DWORD));

            // Update the proper registers.
            hr = SetContextRegister(&c, m_remoteRegAddr.reg1, highPart, frame);

            if (SUCCEEDED(hr))
            {
                BOOL succ = WriteProcessMemory(
                                frame->GetProcess()->m_handle,
                         (void*)m_remoteRegAddr.addr,
                                &lowPart,
                                sizeof(DWORD),
                                NULL);

                if (!succ)
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        break;
        
    case RAK_MEMREG:
        {
            _ASSERTE(m_size == 8);
            _ASSERTE(sizeof(DWORD) == 4);
            
            // Split the new value into high and low parts.
            DWORD highPart;
            DWORD lowPart;

            memcpy(&lowPart, pFrom, sizeof(DWORD));
            memcpy(&highPart, (void*)((DWORD)pFrom + sizeof(DWORD)),
                   sizeof(DWORD));

            // Update the proper registers.
            hr = SetContextRegister(&c, m_remoteRegAddr.reg1, lowPart, frame);

            if (SUCCEEDED(hr))
            {
                BOOL succ = WriteProcessMemory(
                                frame->GetProcess()->m_handle,
                         (void*)m_remoteRegAddr.addr,
                                &highPart,
                                sizeof(DWORD),
                                NULL);

                if (!succ)
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        break;
        
    case RAK_FLOAT:
        {
            _ASSERTE((m_size == 4) || (m_size == 8));

            // Convert the input to a double.
            double newVal = 0.0;

            memcpy(&newVal, pFrom, m_size);

            // What a pain in the butt... on X86, take the floating
            // point state in the context and make it our current FP
            // state, set the value into the current FP state, then
            // save out the FP state into the context again and
            // restore our original state.
            FLOATING_SAVE_AREA currentFPUState;

            __asm fnsave currentFPUState // save the current FPU state.

            // Copy the state out of the context.
            FLOATING_SAVE_AREA floatarea = c.FloatSave;
            floatarea.StatusWord &= 0xFF00; // remove any error codes.
            floatarea.ControlWord |= 0x3F; // mask all exceptions.

            __asm
            {
                fninit
                frstor floatarea          ;; reload the threads FPU state.
            }

            double td; // temp double
            double popArea[DebuggerIPCE_FloatCount];
            int floatIndex = m_remoteRegAddr.floatIndex;

            // Pop off until we reach the value we want to change.
            int i = 0;

            while (i <= floatIndex)
            {
                __asm fstp td
                popArea[i++] = td;
            }
            
            __asm fld newVal; // push on the new value.

            // Push any values that we popled off back onto the stack,
            // _except_ the last one, which was the one we changed.
            i--;
            
            while (i > 0)
            {
                td = popArea[--i];
                __asm fld td
            }

            // Save out the modified float area.
            __asm fnsave floatarea

            // Put it into the context.
            c.FloatSave= floatarea;

            // Restore our FPU state
            __asm
            {
                fninit
                frstor currentFPUState    ;; restore our saved FPU state.
            }
        }
            
        break;

    default:
        _ASSERTE(!"Yikes -- invalid RemoteAddressKind");
    }

    if (FAILED(hr))
        goto Exit;
    
    // Set the thread's modified context.
    if (FAILED(hr = frame->m_thread->SetContext(&c)))
        goto Exit;

    // If all has gone well, update whatever local address points to.
    if (m_localAddress)
        memcpy(m_localAddress, pFrom, m_size);
    
Exit:
    return hr;
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - SetEnregisteredValue (DIValue.cpp)");
    return E_FAIL;
#endif // _X86_
}

void CordbValue::GetRegisterInfo(DebuggerIPCE_FuncEvalArgData *pFEAD)
{
    // Copy the register info into the FuncEvalArgData.
    pFEAD->argHome = m_remoteRegAddr;
}

/* ------------------------------------------------------------------------- *
 * Generic Value class
 * ------------------------------------------------------------------------- */

//
// CordbGenericValue constructor that builds a generic value from
// local and remote addresses. This one is just when a single address
// is enough to specify the location of a value.
//
CordbGenericValue::CordbGenericValue(CordbAppDomain *appdomain,
                                     CordbModule *module,
                                     ULONG cbSigBlob,
                                     PCCOR_SIGNATURE pvSigBlob,
                                     REMOTE_PTR remoteAddress,
                                     void *localAddress,
                                     RemoteAddress *remoteRegAddr)
    : CordbValue(appdomain, module, cbSigBlob, pvSigBlob, remoteAddress, localAddress, remoteRegAddr, false)
{
    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        cbSigBlob -= cb;
        pvSigBlob = &pvSigBlob[cb];
    }

    _ASSERTE(*pvSigBlob != ELEMENT_TYPE_END &&
             *pvSigBlob != ELEMENT_TYPE_VOID &&
             *pvSigBlob < ELEMENT_TYPE_MAX);
             
    // We can fill in the size now for generic values.
    m_size = _sizeOfElementInstance(pvSigBlob);
}

//
// CordbGenericValue constructor that builds a generic value from two
// halves of data. This is valid only for 64-bit values.
//
CordbGenericValue::CordbGenericValue(CordbAppDomain *appdomain,
                                     CordbModule *module,
                                     ULONG cbSigBlob,
                                     PCCOR_SIGNATURE pvSigBlob,
                                     DWORD highWord,
                                     DWORD lowWord,
                                     RemoteAddress *remoteRegAddr)
    : CordbValue(appdomain, module, cbSigBlob, pvSigBlob, NULL, NULL, remoteRegAddr, false)
{
    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        cbSigBlob -= cb;
        pvSigBlob = &pvSigBlob[cb];
    }
    
    _ASSERTE((*pvSigBlob == ELEMENT_TYPE_I8) ||
             (*pvSigBlob == ELEMENT_TYPE_U8) ||
             (*pvSigBlob == ELEMENT_TYPE_R8));

    // We know the size is always 64-bits for these types of values.
    // We can also go ahead and initialize the value right here, making
    // the call to Init() for this object superflous.
    m_size = 8;

    *((DWORD*)(&m_copyOfData[0])) = lowWord;
    *((DWORD*)(&m_copyOfData[4])) = highWord;
}

//
// CordbGenericValue constructor that builds an empty generic value
// from just an element type. Used for literal values for func evals
// only.
//
CordbGenericValue::CordbGenericValue(ULONG cbSigBlob, PCCOR_SIGNATURE pvSigBlob)
    : CordbValue(NULL, NULL, cbSigBlob, pvSigBlob, NULL, NULL, NULL, true)
{
    // The only purpose of a literal value is to hold a RS literal value.
    m_size = _sizeOfElementInstance(pvSigBlob);
    memset(m_copyOfData, 0, sizeof(m_copyOfData));
}

HRESULT CordbGenericValue::QueryInterface(REFIID id, void **pInterface)
{
	if (id == IID_ICorDebugValue)
		*pInterface = (ICorDebugValue*)(ICorDebugGenericValue*)this;
    else if (id == IID_ICorDebugGenericValue)
		*pInterface = (ICorDebugGenericValue*)this;
    else if (id == IID_IUnknown)
		*pInterface = (IUnknown*)(ICorDebugGenericValue*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
	return S_OK;
}

//
// initialize a generic value by copying the necessary data, either
// from the remote process or from another value in this process.
//
HRESULT CordbGenericValue::Init(void)
{
    HRESULT hr = CordbValue::Init();

    if (FAILED(hr))
        return hr;
        
    // If neither m_localAddress nor m_id are set, then all that means
    // is that we've got a pre-initialized 64-bit value.
    if (m_localAddress != NULL)
    {
        // Copy the data out of the local address space.
        //
        // @todo: rather than copying in this case, I'd like to simply
        // keep a pointer. But there is a liveness issue with where
        // we're pointing to...
        memcpy(&m_copyOfData[0], m_localAddress, m_size);
    }
    else if (m_id != NULL)
    {
        // Copy the data out of the remote process.
        BOOL succ = ReadProcessMemoryI(m_process->m_handle,
                                      (const void*) m_id,
                                      &m_copyOfData[0],
                                      m_size,
                                      NULL);

        if (!succ)
            return HRESULT_FROM_WIN32(GetLastError());
    }
        
	return S_OK;
}

HRESULT CordbGenericValue::GetValue(void *pTo)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pTo, BYTE, m_size, false, true);

    // Copy out the value
    memcpy(pTo, &m_copyOfData[0], m_size);
    
	return S_OK;
}

HRESULT CordbGenericValue::SetValue(void *pFrom)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    HRESULT hr = S_OK;

    VALIDATE_POINTER_TO_OBJECT_ARRAY(pFrom, BYTE, m_size, true, false);
    
    // We only need to send to the left side to update values that are
    // object references. For generic values, we can simply do a write
    // memory.

    // We had better have a remote address.
    _ASSERTE((m_id != NULL) || (m_remoteRegAddr.kind != RAK_NONE) ||
             m_isLiteral);

    // Write the new value into the remote process if we have a remote
    // address. Otherwise, update the thread's context.
    if (m_id != NULL)
    {
        BOOL succ = WriteProcessMemory(m_process->m_handle,
                                       (void*)m_id,
                                       pFrom,
                                       m_size,
                                       NULL);

        if (!succ)
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else if (!m_isLiteral)
    {
        hr = SetEnregisteredValue(pFrom);
    }

    // That worked, so update the copy of the value we have in
    // m_copyOfData.
    if (SUCCEEDED(hr))
        memcpy(&m_copyOfData[0], pFrom, m_size);

	return hr;
#endif //RIGHT_SIDE_ONLY    
}

bool CordbGenericValue::CopyLiteralData(BYTE *pBuffer)
{
    // If this is a RS fabrication, copy the literal data into the
    // given buffer and return true.
    if (m_isLiteral)
    {
        memcpy(pBuffer, m_copyOfData, sizeof(m_copyOfData));
        return true;
    }
    else
        return false;
}

/* ------------------------------------------------------------------------- *
 * Reference Value class
 * ------------------------------------------------------------------------- */

CordbReferenceValue::CordbReferenceValue(CordbAppDomain *appdomain,
                                         CordbModule *module,
                                         ULONG cbSigBlob,
                                         PCCOR_SIGNATURE pvSigBlob,
                                         REMOTE_PTR remoteAddress,
                                         void *localAddress,
                                         bool objectRefsInHandles,
                                         RemoteAddress *remoteRegAddr)
    : CordbValue(appdomain, module, cbSigBlob, pvSigBlob, remoteAddress, localAddress, remoteRegAddr, false),
      m_objectRefInHandle(objectRefsInHandles), m_class(NULL),
      m_specialReference(false), m_objectStrong(NULL), m_objectWeak(NULL)
{
    LOG((LF_CORDB,LL_EVERYTHING,"CRV::CRV: this:0x%x\n",this));
    m_size = sizeof(void*);
}

CordbReferenceValue::CordbReferenceValue(ULONG cbSigBlob, PCCOR_SIGNATURE pvSigBlob)
    : CordbValue(NULL, NULL, cbSigBlob, pvSigBlob, NULL, NULL, NULL, true),
      m_objectRefInHandle(false), m_class(NULL),
      m_specialReference(false), m_objectStrong(NULL), m_objectWeak(NULL)
{
    // The only purpose of a literal value is to hold a RS literal value.
    m_size = sizeof(void*);
}

bool CordbReferenceValue::CopyLiteralData(BYTE *pBuffer)
{
    // If this is a RS fabrication, then its a null reference.
    if (m_isLiteral)
    {
        void *n = NULL;
        memcpy(pBuffer, &n, sizeof(n));
        return true;
    }
    else
        return false;
}

CordbReferenceValue::~CordbReferenceValue()
{
    LOG((LF_CORDB,LL_EVERYTHING,"CRV::~CRV: this:0x%x\n",this));

    if (m_objectWeak != NULL)
    {
        LOG((LF_CORDB,LL_EVERYTHING,"CRV::~CRV: Releasing nonNULL weak object 0x%x\n", m_objectWeak));
        m_objectWeak->Release();
        m_objectWeak = NULL;
    }

    if (m_objectStrong != NULL)
    {
        LOG((LF_CORDB,LL_EVERYTHING,"CRV::~CRV: Releasing nonNULL strong object 0x%x\n", m_objectStrong));
        m_objectStrong->Release();
        m_objectStrong = NULL;
    }
}

HRESULT CordbReferenceValue::QueryInterface(REFIID id, void **pInterface)
{
	if (id == IID_ICorDebugValue)
		*pInterface = (ICorDebugValue*)(ICorDebugReferenceValue*)this;
    else if (id == IID_ICorDebugReferenceValue)
		*pInterface = (ICorDebugReferenceValue*)this;
    else if (id == IID_IUnknown)
		*pInterface = (IUnknown*)(ICorDebugReferenceValue*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
	return S_OK;
}

HRESULT CordbReferenceValue::IsNull(BOOL *pbNULL)
{
    VALIDATE_POINTER_TO_OBJECT(pbNULL, BOOL *);

   if (m_isLiteral || (m_info.objRef == NULL))
        *pbNULL = TRUE;
    else
        *pbNULL = FALSE;
    
    return S_OK;
}

HRESULT CordbReferenceValue::GetValue(CORDB_ADDRESS *pTo)
{
    VALIDATE_POINTER_TO_OBJECT(pTo, CORDB_ADDRESS *);
    
    // Copy out the value, which is simply the value the object reference.
    if (m_isLiteral)
        *pTo = NULL;
    else
        *pTo = PTR_TO_CORDB_ADDRESS(m_info.objRef);
    
	return S_OK;
}

HRESULT CordbReferenceValue::SetValue(CORDB_ADDRESS pFrom)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    HRESULT hr = S_OK;

    // Can't change literal refs.
    if (m_isLiteral)
        return E_INVALIDARG;
    
    // We had better have a remote address.
    _ASSERTE((m_id != NULL) || (m_remoteRegAddr.kind != RAK_NONE));

    // If not enregistered, send a Set Reference message to the right
    // side with the address of this reference and whether or not the
    // reference points to a handle.
    if (m_id != NULL)
    {
        DebuggerIPCEvent event;

        m_process->InitIPCEvent(&event, DB_IPCE_SET_REFERENCE, true, (void *)m_appdomain->m_id);
    
        event.SetReference.objectRefAddress = (void*)m_id;
        event.SetReference.objectRefInHandle = m_objectRefInHandle;
        _ASSERTE(m_size == sizeof(void*));
        event.SetReference.newReference = (void *)pFrom;
    
        // Note: two-way event here...
        hr = m_process->m_cordb->SendIPCEvent(m_process, &event,
                                              sizeof(DebuggerIPCEvent));

        // Stop now if we can't even send the event.
        if (!SUCCEEDED(hr))
            return hr;

        _ASSERTE(event.type == DB_IPCE_SET_REFERENCE_RESULT);

        hr = event.hr;
    }
    else
    {
        // The object reference is enregistered, so we don't have to
        // go through the write barrier. Simply update the proper
        // register.

        // Coerce the CORDB_ADDRESS to a DWORD, which is what we're
        // using for register values these days, and pass in that.
        DWORD newValue = (DWORD)pFrom;
        hr = SetEnregisteredValue((void*)&newValue);
    }
    
    if (SUCCEEDED(hr))
    {
        // That worked, so update the copy of the value we have in
        // m_copyOfData.
        m_info.objRef = (void*)pFrom;

        bool fStrong = m_objectStrong ? true : false;

        // Now, dump any cache of object values hanging off of this
        // reference.
        if (m_objectWeak != NULL)
        {
            m_objectWeak->Release();
            m_objectWeak = NULL;
        }

        if (m_objectStrong != NULL)
        {
            m_objectStrong->Release();
            m_objectStrong = NULL;
        }

        if (m_info.objectType == ELEMENT_TYPE_STRING)
        {
            Init(fStrong);
        }
    }
    
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbReferenceValue::Dereference(ICorDebugValue **ppValue)
{
    // Can't dereference literal refs.
    if (m_isLiteral)
        return E_INVALIDARG;
    
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

    CORDBSyncFromWin32StopIfNecessary(m_process);
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(m_process, GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(m_process);
#endif    

    return DereferenceInternal(ppValue, bCrvWeak);
}

HRESULT CordbReferenceValue::DereferenceStrong(ICorDebugValue **ppValue)
{
    // Can't dereference literal refs.
    if (m_isLiteral)
        return E_INVALIDARG;
    
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

    CORDBSyncFromWin32StopIfNecessary(m_process);
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(m_process, GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(m_process);
#endif    

    return DereferenceInternal(ppValue, bCrvStrong);
}

HRESULT CordbReferenceValue::DereferenceInternal(ICorDebugValue **ppValue, bool fStrong)
{
    HRESULT hr = S_OK;

    if (m_continueCounterLastSync != m_module->GetProcess()->m_continueCounter)
        IfFailRet( Init(false) );

    // We may know ahead of time (depending on the reference type) if
    // the reference is bad.
    if ((m_info.objRefBad) || (m_info.objRef == NULL))
        return CORDBG_E_BAD_REFERENCE_VALUE;

    PCCOR_SIGNATURE pvSigBlobNoMod = m_pvSigBlob;
    ULONG           cbSigBlobNoMod = m_cbSigBlob;
    
    //Get rid of funky modifiers
    ULONG cbNoMod = _skipFunkyModifiersInSignature(pvSigBlobNoMod);
    if( cbNoMod != 0)
    {
        _ASSERTE( (int)cbNoMod > 0 );
        cbSigBlobNoMod -= cbNoMod;
        pvSigBlobNoMod = &pvSigBlobNoMod[cbNoMod];
    }

    switch(*pvSigBlobNoMod)
    {
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_STRING:
        {
            // An object value (possibly a string value, too.) If the
            // class of this object is a value class, then we have a
            // reference to a boxed object. So we create a box instead
            // of an object value.
            bool isValueClass = false;

            if ((m_class != NULL) && (*pvSigBlobNoMod != ELEMENT_TYPE_STRING))
            {
                hr = m_class->IsValueClass(&isValueClass);

                if (FAILED(hr))
                    return hr;
            }

            if (isValueClass)
            {
                CordbBoxValue* pBoxValue = new CordbBoxValue(m_appdomain, m_module, m_cbSigBlob, m_pvSigBlob,
                                                             m_info.objRef, m_info.objSize, m_info.objOffsetToVars, m_class);

                if (pBoxValue != NULL)
                {
                    hr = pBoxValue->Init();

                    if (SUCCEEDED(hr))
                    {
                        pBoxValue->AddRef();
                        *ppValue = (ICorDebugValue*)(ICorDebugBoxValue*)pBoxValue;
                    }
                    else
                        delete pBoxValue;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                // Note: we have a small caching scheme here with the weak/strong objects. We have this because we are
                // creating handles on the Left Side for these things, and we don't want to create many handles.
                if (fStrong && (m_objectStrong == NULL))
                {
                    // Calling Init(fStrong) gets us a strong handle to the object.
                    hr = Init(fStrong);

                    if (SUCCEEDED(hr))
                    {
                        m_objectStrong = new CordbObjectValue(m_appdomain,
                                                              m_module,
                                                              m_cbSigBlob,
                                                              m_pvSigBlob,
                                                              &m_info,
                                                              m_class,
                                                              fStrong,
                                                              m_info.objToken);
                        if (m_objectStrong != NULL)
                        {
                            hr = m_objectStrong->Init();

                            if (SUCCEEDED(hr))
                                m_objectStrong->AddRef();
                            else
                            {
                                delete m_objectStrong;
                                m_objectStrong = NULL;
                            }
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }
                else if (!fStrong && (m_objectWeak == NULL))
                {
                    // Note: we call Init(bCrvWeak) by default when we create (or refresh) a reference value, so we
                    // never have to do it again.
                    m_objectWeak = new CordbObjectValue(m_appdomain,
                                                        m_module,
                                                        m_cbSigBlob,
                                                        m_pvSigBlob,
                                                        &m_info,
                                                        m_class,
                                                        fStrong,
                                                        m_info.objToken);
                    if (m_objectWeak != NULL)
                    {
                        hr = m_objectWeak->Init();

                        if (SUCCEEDED(hr))
                            m_objectWeak->AddRef();
                        else
                        {
                            delete m_objectWeak;
                            m_objectWeak = NULL;
                        }
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }

                if (SUCCEEDED(hr))
                {
                    _ASSERTE(((fStrong && (m_objectStrong != NULL)) || (!fStrong && (m_objectWeak !=NULL))));
                
                    CordbObjectValue *pObj = fStrong ? m_objectStrong : m_objectWeak;
                        
                    pObj->AddRef();
                    *ppValue = (ICorDebugValue*)(ICorDebugObjectValue*)pObj;
                }
            }
            
            break;
        }

    case ELEMENT_TYPE_ARRAY:
	case ELEMENT_TYPE_SZARRAY:
        {
            CordbArrayValue* pArrayValue = new CordbArrayValue(m_appdomain, m_module, m_cbSigBlob, m_pvSigBlob,
                                                               &m_info, m_class);

            if (pArrayValue != NULL)
            {
                hr = pArrayValue->Init();

                if (SUCCEEDED(hr))
                {
                    pArrayValue->AddRef();
                    *ppValue = (ICorDebugValue*)(ICorDebugArrayValue*)pArrayValue;
                }
                else
                    delete pArrayValue;
            }
            else
                hr = E_OUTOFMEMORY;
            
            break;
        }

    case ELEMENT_TYPE_BYREF:
    case ELEMENT_TYPE_PTR:
        {
            // Skip past the byref or ptr type in the signature.
            PCCOR_SIGNATURE pvSigBlob = pvSigBlobNoMod;
            UINT_PTR pvSigBlobEnd = (UINT_PTR)pvSigBlobNoMod + cbSigBlobNoMod;
            
            CorElementType et = CorSigUncompressElementType(pvSigBlob);
            _ASSERTE((et == ELEMENT_TYPE_BYREF) ||
                     (et == ELEMENT_TYPE_PTR));

            // Adjust the size of the signature.
            DWORD cbSigBlob = pvSigBlobEnd - (UINT_PTR)pvSigBlob;

            // If we end up with an empty signature, then we can't
            // finish the dereference.
            if (cbSigBlob == 0)
                return CORDBG_E_BAD_REFERENCE_VALUE;

            // Do we have a ptr to something useful?
            if (et == ELEMENT_TYPE_PTR)
            {
                PCCOR_SIGNATURE tmpSigPtr = pvSigBlob;
                et = CorSigUncompressElementType(tmpSigPtr);

                if (et == ELEMENT_TYPE_VOID)
                {
                    *ppValue = NULL;
                    return CORDBG_S_VALUE_POINTS_TO_VOID;
                }
            }

            // Create a value for what this reference points to. Note:
            // this could be almost any type of value.
            hr = CordbValue::CreateValueByType(m_appdomain,
                                               m_module,
                                               cbSigBlob,
                                               pvSigBlob,
                                               NULL,
                                               m_info.objRef,
                                               NULL,
                                               false,
                                               NULL,
                                               NULL,
                                               ppValue);
            
            break;
        }

    case ELEMENT_TYPE_TYPEDBYREF:
        {
            // Build a partial signature for either a CLASS or
            // VALUECLASS based on the type of m_class. The only
            // reason there would be no class from the Left Side is
            // that its an array class, which we treat just like a
            // normal object reference anyway...
            CorElementType et = ELEMENT_TYPE_CLASS;

            if (m_class != NULL)
            {
                bool isValueClass = false;

                hr = m_class->IsValueClass(&isValueClass);

                if (FAILED(hr))
                    return hr;

                if (isValueClass)
                    et = ELEMENT_TYPE_VALUETYPE;
            }
            
            // Create the value for what this reference points
            // to. Note: this will only be pointing to a CLASS or a
            // VALUECLASS.
            hr = CordbValue::CreateValueByType(m_appdomain,
                                               m_module,
                                               1,
                                               (PCCOR_SIGNATURE) &et,
                                               m_class,
                                               m_info.objRef,
                                               NULL,
                                               false,
                                               NULL,
                                               NULL,
                                               ppValue);

            break;
        }

    case ELEMENT_TYPE_VALUETYPE: // should never have a value class here!
    default:
        _ASSERTE(!"Bad value type!");
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CordbReferenceValue::Init(bool fStrong)
{
    HRESULT hr = S_OK;
    
    hr = CordbValue::Init();

    if (FAILED(hr))
        return hr;
        
    // No more init needed for literal refs.
    if (m_isLiteral)
        return hr;

    // If the helper thread id dead, then pretend this is a bad reference.
    if (m_process->m_helperThreadDead)
    {
        m_info.objRef = NULL;
        m_info.objRefBad = TRUE;
        return hr;
    }

    m_continueCounterLastSync = m_module->GetProcess()->m_continueCounter;
    
    // If we have a byref, ptr, or refany type then we go ahead and
    // get the true remote ptr now. All the other info we need to
    // dereference one of these is held in the base value class and in
    // the signature.

    //Get rid of funky modifiers
    ULONG cbMod = _skipFunkyModifiersInSignature(m_pvSigBlob);
    
    CorElementType type = (CorElementType) *(&m_pvSigBlob[cbMod]);
    
    if ((type == ELEMENT_TYPE_BYREF) ||
        (type == ELEMENT_TYPE_PTR) ||
        (type == ELEMENT_TYPE_FNPTR))
    {
        m_info.objRefBad = FALSE;

        if (m_id == NULL)
            m_info.objRef = (void*) *((DWORD*)m_localAddress);
        else
        {
            BOOL succ = ReadProcessMemoryI(m_process->m_handle,
                                          (void*)m_id,
                                          &(m_info.objRef),
                                          sizeof(void*),
                                          NULL);

            if (!succ)
            {
                m_info.objRef = NULL;
                m_info.objRefBad = TRUE;
                return hr;
            }
        }

        // We should never dereference a funtion-pointers, so all references
        // are considered bad.
        if (type == ELEMENT_TYPE_FNPTR)
        {
            m_info.objRefBad = TRUE;
            return hr;
        }

        // The only way to tell if the reference in PTR's is bad or
        // not is to try to deref the darn thing.
        if (m_info.objRef != NULL)
        {
            if (type == ELEMENT_TYPE_PTR)
            {
                ULONG dataSize =
                    _sizeOfElementInstance(&m_pvSigBlob[cbMod+1]);
                if (dataSize == 0)
                    dataSize = 1; // Read at least one byte.
                
                _ASSERTE(dataSize <= 8);
                BYTE dummy[8];
                    
                BOOL succ = ReadProcessMemoryI(m_process->m_handle,
                                               m_info.objRef,
                                               dummy,
                                               dataSize,
                                               NULL);

                if (!succ)
                    m_info.objRefBad = TRUE;
            }
        }
        else
        {
            // Null refs are considered "bad".
            m_info.objRefBad = TRUE;
        }
        
        return hr;
    }
    
    // We've got a remote address that points to the object reference.
    // We need to send to the left side to get real information about
    // the reference, including info about the object it points to.
    DebuggerIPCEvent event;
    
    m_process->InitIPCEvent(&event, 
                            DB_IPCE_GET_OBJECT_INFO, 
                            true,
                            (void *)m_appdomain->m_id);
    
    event.GetObjectInfo.makeStrongObjectHandle = fStrong;
    
    // If we've got a NULL remote address, then all we have is a local address.
    // So we grab the object ref out of the local address and pass it
    // directly over to the left side instead of simply passing the remote
    // address of the object ref.
    if (m_id == NULL)
    {
        event.GetObjectInfo.objectRefAddress = *((void**)m_localAddress);
        event.GetObjectInfo.objectRefIsValue = true;
    }
    else
    {
        event.GetObjectInfo.objectRefAddress = (void*) m_id;
        event.GetObjectInfo.objectRefIsValue = false;
    }
    
    event.GetObjectInfo.objectRefInHandle = m_objectRefInHandle;
    event.GetObjectInfo.objectType = (CorElementType)type;

    // Note: two-way event here...
    hr = m_process->m_cordb->SendIPCEvent(m_process, &event,
                                          sizeof(DebuggerIPCEvent));

    // Stop now if we can't even send the event.
    if (!SUCCEEDED(hr))
        return hr;

    _ASSERTE(event.type == DB_IPCE_GET_OBJECT_INFO_RESULT);

    // Save the results for later.
    m_info = event.GetObjectInfoResult;
    
    // If the object type that we got back is different than the one
    // we sent, then it means that we orignally had a CLASS and now
    // have something more specific, like a SDARRAY, MDARRAY, or
    // STRING. Update our signature accordingly, which is okay since
    // we always have a copy of our sig. This ensures that the
    // reference's signature accuratley reflects what the Runtime
    // knows its pointing to.
    if (m_info.objectType != type)
    {
        _ASSERTE((m_info.objectType == ELEMENT_TYPE_ARRAY) ||
				 (m_info.objectType == ELEMENT_TYPE_SZARRAY) ||
				 (m_info.objectType == ELEMENT_TYPE_CLASS) ||
				 (m_info.objectType == ELEMENT_TYPE_OBJECT) ||
                 (m_info.objectType == ELEMENT_TYPE_STRING));
        _ASSERTE(m_cbSigBlob-cbMod > 0);

        *((BYTE*) &m_pvSigBlob[cbMod]) = (BYTE) m_info.objectType;
    }

    // Find the class that goes with this object. We'll remember
    // it with the other object info for when this reference is
    // dereferenced.
    if (m_info.objClassMetadataToken != mdTypeDefNil)
    {
		// Iterate through each assembly looking for the given module
		CordbModule* pClassModule = m_appdomain->LookupModule(m_info.objClassDebuggerModuleToken);
#ifdef RIGHT_SIDE_ONLY
        _ASSERTE(pClassModule != NULL);
#else
        // This case happens if inproc debugging is used from a ModuleLoadFinished
        // callback for a module that hasn't been bound to an assembly yet.
        if (pClassModule == NULL)
            return (E_FAIL);
#endif
        
        CordbClass* pClass = pClassModule->LookupClass(
                                                m_info.objClassMetadataToken);

        if (pClass == NULL)
        {
            hr = pClassModule->CreateClass(m_info.objClassMetadataToken,
                                           &pClass);

            if (!SUCCEEDED(hr))
                return hr;
        }
                
        _ASSERTE(pClass != NULL);
        m_class = pClass;
    }

    if (m_info.objRefBad)
    {
        return S_OK;
    }

    return hr;
}

/* ------------------------------------------------------------------------- *
 * Object Value class
 * ------------------------------------------------------------------------- */


#ifdef RIGHT_SIDE_ONLY
#define COV_VALIDATE_OBJECT() do {         \
    BOOL bValid;                           \
    HRESULT hr;                            \
    if (FAILED(hr = IsValid(&bValid)))     \
        return hr;                         \
                                           \
        if (!bValid)                       \
        {                                  \
            return CORDBG_E_INVALID_OBJECT; \
        }                                  \
    }while(0)
#else
#define COV_VALIDATE_OBJECT() ((void)0)
#endif

CordbObjectValue::CordbObjectValue(CordbAppDomain *appdomain,
                                   CordbModule *module,
                                   ULONG cbSigBlob,
                                   PCCOR_SIGNATURE pvSigBlob,
                                   DebuggerIPCE_ObjectData *pObjectData,
                                   CordbClass *objectClass,
                                   bool fStrong,
                                   void *token)
    : CordbValue(appdomain, module, cbSigBlob, pvSigBlob, pObjectData->objRef, NULL, NULL, false),
      m_info(*pObjectData), m_class(objectClass),
      m_objectCopy(NULL), m_objectLocalVars(NULL), m_stringBuffer(NULL),
      m_fIsValid(true), m_fStrong(fStrong), m_objectToken(token)
{
    _ASSERTE(module != NULL);
    
    m_size = m_info.objSize;

    m_mostRecentlySynched = module->GetProcess()->m_continueCounter;

    LOG((LF_CORDB,LL_EVERYTHING,"COV::COV:This:0x%x  token:0x%x"
        "  strong:0x%x  continue count:0x%x\n",this, m_objectToken,
        m_fStrong,m_mostRecentlySynched));
}

CordbObjectValue::~CordbObjectValue()
{
    LOG((LF_CORDB,LL_EVERYTHING,"COV::~COV:this:0x%x  token:0x%x"
        "  Strong:0x%x\n",this, m_objectToken, m_fStrong));
        
    // Destroy the copy of the object.
    if (m_objectCopy != NULL)
        delete [] m_objectCopy;

    if (m_objectToken != NULL && m_info.objClassMetadataToken != mdTypeDefNil)
        DiscardObject(m_objectToken, m_fStrong);
}

void CordbObjectValue::DiscardObject(void *token, bool fStrong)
{
    LOG((LF_CORDB,LL_INFO10000,"COV::DO:strong:0x%x discard of token "
        "0x%x!\n",fStrong,token));

    // Only discard the object if the process is not exiting...
    if (CORDBCheckProcessStateOK(m_process))
    {
        // Release the left side handle to the object
        DebuggerIPCEvent event;

        m_process->InitIPCEvent(&event, 
                                DB_IPCE_DISCARD_OBJECT, 
                                false,
                                (void *)m_appdomain->m_id);
        event.DiscardObject.objectToken = token;
        event.DiscardObject.fStrong = fStrong;
    
        // Note: one-way event here...
        HRESULT hr = m_process->m_cordb->SendIPCEvent(m_process, &event,
                                                  sizeof(DebuggerIPCEvent));
        // Pray that it succeeds :)
    }
}

HRESULT CordbObjectValue::QueryInterface(REFIID id, void **pInterface)
{
	if (id == IID_ICorDebugValue)
		*pInterface = (ICorDebugValue*)(ICorDebugObjectValue*)this;
    else if (id == IID_ICorDebugObjectValue)
		*pInterface = (ICorDebugObjectValue*)this;
    else if (id == IID_ICorDebugGenericValue)
		*pInterface = (ICorDebugGenericValue*)this;
    else if (id == IID_ICorDebugHeapValue)
		*pInterface = (ICorDebugHeapValue*)this;
    else if ((id == IID_ICorDebugStringValue) &&
             (m_info.objectType == ELEMENT_TYPE_STRING))
		*pInterface = (ICorDebugStringValue*)this;
    else if (id == IID_IUnknown)
		*pInterface = (IUnknown*)(ICorDebugObjectValue*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
	return S_OK;
}

HRESULT CordbObjectValue::GetType(CorElementType *pType)
{
    return (CordbValue::GetType(pType));
}

HRESULT CordbObjectValue::GetSize(ULONG32 *pSize)
{
    return (CordbValue::GetSize(pSize));
}

HRESULT CordbObjectValue::GetAddress(CORDB_ADDRESS *pAddress)
{
    COV_VALIDATE_OBJECT();

    return (CordbValue::GetAddress(pAddress));
}

HRESULT CordbObjectValue::CreateBreakpoint(ICorDebugValueBreakpoint 
    **ppBreakpoint)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    COV_VALIDATE_OBJECT();

    return (CordbValue::CreateBreakpoint(ppBreakpoint));
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbObjectValue::IsValid(BOOL *pbValid)
{
    VALIDATE_POINTER_TO_OBJECT(pbValid, BOOL *);

#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else

    CORDBSyncFromWin32StopIfNecessary(m_process);
    CORDBRequireProcessStateOKAndSync(m_process, GetAppDomain());
    
    if (!m_fIsValid)
    {
        LOG((LF_CORDB,LL_INFO1000,"COV::IsValid: "
            "previously invalidated object\n"));
            
        (*pbValid) = FALSE;
        return S_OK;
    }

	HRESULT hr = S_OK;

    // @todo What if m_class is NULL?
    if (m_mostRecentlySynched == m_class->GetModule()->GetProcess()->m_continueCounter)
    {
        LOG((LF_CORDB,LL_INFO1000,"COV::IsValid: object is N'Sync!\n"));
        
        (*pbValid) = TRUE; //since m_fIsValid isn't false
	     hr = S_OK;
	     goto LExit;
    }

    if(SyncObject())
    {
        LOG((LF_CORDB,LL_INFO1000,"COV::IsValid object now "
            "synched up fine!\n"));
            
        m_mostRecentlySynched = m_class->GetModule()->GetProcess()->m_continueCounter;
        (*pbValid)=TRUE;
    }
    else
    {
        LOG((LF_CORDB,LL_INFO1000,"COV::IsValid: SyncObject=> "
            "object invalidated\n"));

        _ASSERTE( !m_fStrong );
        
        m_fIsValid = false;
        (*pbValid) = FALSE;
    }

LExit:
    return S_OK;
#endif // RIGHT_SIDE_ONLY
}

// @mfunc bool|CordbObjectValue|SyncObject|Obtains the most current info
// from the left side, and refreshes all the internal data members of this
// instance with it.  DOESN'T refresh any sub-objects or outstanding field
// objects - this is the responsibility of the caller.
// @rdesc Returns true if the object is still valid & this instance has been
// properly refreshed. Returns false if the object is no longer valid. (note
// that once an object has been invalidated, it will never again be valid)
bool CordbObjectValue::SyncObject(void)
{
    LOG((LF_CORDB,LL_INFO1000,"COV::SO\n"));
    
    DebuggerIPCEvent event;
    CordbProcess *process = m_class->GetModule()->GetProcess();
    _ASSERTE(process != NULL);

    process->InitIPCEvent(&event, 
                          DB_IPCE_VALIDATE_OBJECT, 
                          true,
                          (void *)m_appdomain->m_id);
    event.ValidateObject.objectToken = m_objectToken;
    event.ValidateObject.objectType  = m_info.objectType;
    
    // Note: two-way event here...
    HRESULT hr = process->m_cordb->SendIPCEvent(process, &event,
                                        sizeof(DebuggerIPCEvent));

    // Stop now if we can't even send the event.
    if (!SUCCEEDED(hr))
        return false;

    _ASSERTE(event.type == DB_IPCE_GET_OBJECT_INFO_RESULT);

    // Since the process has been continued, we need to go re-get all
    // the sync block fields, since the objects may have moved.
    m_syncBlockFieldsInstance.Clear();

    // Save the results for later.
    m_info = event.GetObjectInfoResult;

    //  This pithy one-liner actually resets the remote address of the
    // object in question, and thus shouldn't be forgotten!! Note
    // also how we cleverly place this _after_ the new m_info is obtained, and
    // _before_ the call to init.
    m_id = (ULONG)m_info.objRef;

    if (m_info.objRefBad)
    {
        return false;
    }
    else
    {
        Init();
        return true;
    }
}

HRESULT CordbObjectValue::CreateRelocBreakpoint(
                                      ICorDebugValueBreakpoint **ppBreakpoint)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppBreakpoint, ICorDebugValueBreakpoint **);

   COV_VALIDATE_OBJECT();
   
   return E_NOTIMPL;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbObjectValue::GetClass(ICorDebugClass **ppClass)
{
    VALIDATE_POINTER_TO_OBJECT(ppClass, ICorDebugClass **);
    
    *ppClass = (ICorDebugClass*) m_class;
    
    if (*ppClass != NULL)
        (*ppClass)->AddRef();

    return S_OK;
}

HRESULT CordbObjectValue::GetFieldValue(ICorDebugClass *pClass,
                                        mdFieldDef fieldDef,
                                        ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(pClass, ICorDebugClass *);
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

    COV_VALIDATE_OBJECT();

    CordbClass *c;
	HRESULT hr = S_OK;
    BOOL fSyncBlockField = FALSE;
    
    //
    // @todo: need to ensure that pClass is really on the class
    // hierarchy of m_class!!!
    //
    if (pClass == NULL)
        c = m_class;
    else
        c = (CordbClass*)pClass;
    
    // Validate the token.
    if (!c->GetModule()->m_pIMImport->IsValidToken(fieldDef))
    {
    	hr = E_INVALIDARG;
    	goto LExit;
   	}
        
    DebuggerIPCE_FieldData *pFieldData;
    
#ifdef _DEBUG
    pFieldData = NULL;
#endif
    
    hr = c->GetFieldInfo(fieldDef, &pFieldData);

    if (hr == CORDBG_E_ENC_HANGING_FIELD)
    {
        hr = m_class->GetSyncBlockField(fieldDef, 
                                        &pFieldData,
                                        this);
            
        if (SUCCEEDED(hr))
            fSyncBlockField = TRUE;
    }

    if (SUCCEEDED(hr))
    {
        _ASSERTE(pFieldData != NULL);

        // Compute the remote address, too, so that SetValue will work.
        DWORD ra = m_id + m_info.objOffsetToVars + pFieldData->fldOffset;
        
        hr = CordbValue::CreateValueByType(m_appdomain,
                                           c->GetModule(),
                                           pFieldData->fldFullSigSize, pFieldData->fldFullSig,
                                           NULL,
                                           (void*)ra,
                                           (!fSyncBlockField ? &(m_objectLocalVars[pFieldData->fldOffset])
                                            : NULL), // don't claim we have a local addr if we don'td
                                           false,
                                           NULL,
                                           NULL,
                                           ppValue);
    }
    
    // If we can't get it b/c it's a constant, then say so.
    hr = CordbClass::PostProcessUnavailableHRESULT(hr, c->GetModule()->m_pIMImport, fieldDef);

LExit:
    return hr;
}

HRESULT CordbObjectValue::GetVirtualMethod(mdMemberRef memberRef,
                                           ICorDebugFunction **ppFunction)
{
    VALIDATE_POINTER_TO_OBJECT(ppFunction, ICorDebugFunction **);
    
    COV_VALIDATE_OBJECT();

    return E_NOTIMPL;
}

HRESULT CordbObjectValue::GetContext(ICorDebugContext **ppContext)
{
    VALIDATE_POINTER_TO_OBJECT(ppContext, ICorDebugContext **);
    
    COV_VALIDATE_OBJECT();

    return E_NOTIMPL;
}

HRESULT CordbObjectValue::IsValueClass(BOOL *pbIsValueClass)
{
    COV_VALIDATE_OBJECT();

    if (pbIsValueClass)
        *pbIsValueClass = FALSE;
    
    return S_OK;
}

HRESULT CordbObjectValue::GetManagedCopy(IUnknown **ppObject)
{
    COV_VALIDATE_OBJECT();

    return CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS;
}

HRESULT CordbObjectValue::SetFromManagedCopy(IUnknown *pObject)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    COV_VALIDATE_OBJECT();

    return CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbObjectValue::GetValue(void *pTo)
{
    COV_VALIDATE_OBJECT();

    VALIDATE_POINTER_TO_OBJECT_ARRAY(pTo, BYTE, m_size, false, true);
    
   // Copy out the value, which is the whole object.
    memcpy(pTo, m_objectCopy, m_size);
    
    return S_OK;
}

HRESULT CordbObjectValue::SetValue(void *pFrom)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    // You're not allowed to set a whole object at once.
	return E_INVALIDARG;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbObjectValue::GetLength(ULONG32 *pcchString)
{
    VALIDATE_POINTER_TO_OBJECT(pcchString, SIZE_T *);
    
    _ASSERTE(m_info.objectType == ELEMENT_TYPE_STRING);

    COV_VALIDATE_OBJECT();

    *pcchString = m_info.stringInfo.length;
    return S_OK;
}

HRESULT CordbObjectValue::GetString(ULONG32 cchString,
                                    ULONG32 *pcchString,
                                    WCHAR szString[])
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(szString, WCHAR, cchString, true, true);
    VALIDATE_POINTER_TO_OBJECT(pcchString, SIZE_T *);

    _ASSERTE(m_info.objectType == ELEMENT_TYPE_STRING);

    COV_VALIDATE_OBJECT();

    if ((szString == NULL) || (cchString == 0))
        return E_INVALIDARG;
    
    // Add 1 to include null terminator
    SIZE_T len = m_info.stringInfo.length + 1;

    if (cchString < len)
        len = cchString;
        
    memcpy(szString, m_stringBuffer, len * 2);
    *pcchString = m_info.stringInfo.length;

    return S_OK;
}

HRESULT CordbObjectValue::Init(void)
{
    LOG((LF_CORDB,LL_INFO1000,"Invoking COV::Init\n"));

    HRESULT hr = S_OK;

    hr = CordbValue::Init();

    if (FAILED(hr))
        return hr;
        
    SIZE_T nstructSize = 0;

    if (m_info.objectType == ELEMENT_TYPE_CLASS)
        nstructSize = m_info.nstructInfo.size;
    
    // Copy the entire object over to this process.
    m_objectCopy = new BYTE[m_size + nstructSize];

    if (m_objectCopy == NULL)
        return E_OUTOFMEMORY;

    BOOL succ = ReadProcessMemoryI(m_process->m_handle,
                                  (const void*) m_id,
                                  m_objectCopy,
                                  m_size,
                                  NULL);

    if (!succ)
        return HRESULT_FROM_WIN32(GetLastError());

    // If this is an NStruct, copy the seperated NStruct fields and
    // append them onto the object. NOTE: the field offsets are
    // automatically adjusted by the left side in GetAndSendClassInfo.
    if (nstructSize != 0)
    {
        succ = ReadProcessMemoryI(m_process->m_handle,
                                 (const void*) m_info.nstructInfo.ptr,
                                 m_objectCopy + m_size,
                                 nstructSize,
                                 NULL);
    
        if (!succ)
            return HRESULT_FROM_WIN32(GetLastError());
    }


    // Compute offsets to the locals and to a string if this is a
    // string object.
    m_objectLocalVars = m_objectCopy + m_info.objOffsetToVars;

    if (m_info.objectType == ELEMENT_TYPE_STRING)
        m_stringBuffer = m_objectCopy + m_info.stringInfo.offsetToStringBase;
    
    return hr;
}

/* ------------------------------------------------------------------------- *
 * Valuce Class Object Value class
 * ------------------------------------------------------------------------- */

CordbVCObjectValue::CordbVCObjectValue(CordbAppDomain *appdomain,
                                       CordbModule *module,
                                       ULONG cbSigBlob,
                                       PCCOR_SIGNATURE pvSigBlob,
                                       REMOTE_PTR remoteAddress,
                                       void *localAddress,
                                       CordbClass *objectClass,
                                       RemoteAddress *remoteRegAddr)
    : CordbValue(appdomain, module, cbSigBlob, pvSigBlob, remoteAddress, localAddress, remoteRegAddr, false),
      m_objectCopy(NULL), m_class(objectClass)
{
}

CordbVCObjectValue::~CordbVCObjectValue()
{
    // Destroy the copy of the object.
    if (m_objectCopy != NULL)
        delete [] m_objectCopy;
}

HRESULT CordbVCObjectValue::QueryInterface(REFIID id, void **pInterface)
{
	if (id == IID_ICorDebugValue)
		*pInterface = (ICorDebugValue*)(ICorDebugObjectValue*)this;
    else if (id == IID_ICorDebugObjectValue)
		*pInterface = (ICorDebugObjectValue*)(ICorDebugObjectValue*)this;
    else if (id == IID_ICorDebugGenericValue)
		*pInterface = (ICorDebugGenericValue*)this;
    else if (id == IID_IUnknown)
		*pInterface = (IUnknown*)(ICorDebugObjectValue*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
	return S_OK;
}

HRESULT CordbVCObjectValue::GetClass(ICorDebugClass **ppClass)
{
    *ppClass = (ICorDebugClass*) m_class;

    if (*ppClass != NULL)
        (*ppClass)->AddRef();

    return S_OK;
}

HRESULT CordbVCObjectValue::GetFieldValue(ICorDebugClass *pClass,
                                          mdFieldDef fieldDef,
                                          ICorDebugValue **ppValue)
{
    // Validate the token.
    if (!m_class->GetModule()->m_pIMImport->IsValidToken(fieldDef))
        return E_INVALIDARG;

    CordbClass *c;

    //
    // @todo: need to ensure that pClass is really on the class
    // hierarchy of m_class!!!
    //
    if (pClass == NULL)
        c = m_class;
    else
        c = (CordbClass*) pClass;

    DebuggerIPCE_FieldData *pFieldData;

#ifdef _DEBUG
    pFieldData = NULL;
#endif
    
    HRESULT hr = c->GetFieldInfo(fieldDef, &pFieldData);

    _ASSERTE(hr != CORDBG_E_ENC_HANGING_FIELD);
    // If we get back CORDBG_E_ENC_HANGING_FIELD we'll just fail - 
    // value classes should be able to add fields once they're loaded,
    // since the new fields _can't_ be contiguous with the old fields,
    // and having all the fields contiguous is kinda the point of a V.C.

    if (SUCCEEDED(hr))
    {
        _ASSERTE(pFieldData != NULL);

        // Compute the remote address, too, so that SetValue will work.
        DWORD ra = NULL;
        RemoteAddress *pra = NULL;
        
        if (m_remoteRegAddr.kind == RAK_NONE)
            ra = m_id + pFieldData->fldOffset;
        else
        {
            // We only handle single and double register values for now.
            if (m_remoteRegAddr.kind != RAK_REG && m_remoteRegAddr.kind != RAK_REGREG)
                return E_INVALIDARG;

            // Remote register address is the same as the parent.
            pra = &m_remoteRegAddr;
        }
        
        hr = CordbValue::CreateValueByType(m_appdomain,
                                           c->GetModule(),
                                           pFieldData->fldFullSigSize, pFieldData->fldFullSig,
                                           NULL,
                                           (void*)ra,
                                           &(m_objectCopy[pFieldData->fldOffset]),
                                           false,
                                           pra,
                                           NULL,
                                           ppValue);
    }

	return hr;
}

HRESULT CordbVCObjectValue::GetValue(void *pTo)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pTo, BYTE, m_size, false, true);

    // Copy out the value, which is the whole object.
    memcpy(pTo, m_objectCopy, m_size);
    
	return S_OK;
}

HRESULT CordbVCObjectValue::SetValue(void *pFrom)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    HRESULT hr = S_OK;

    VALIDATE_POINTER_TO_OBJECT_ARRAY(pFrom, BYTE, m_size, true, false);
    
    // Can't change literals...
    if (m_isLiteral)
        return E_INVALIDARG;
    
    // We had better have a remote address.
    _ASSERTE((m_id != NULL) || (m_remoteRegAddr.kind != RAK_NONE));

    // If not enregistered, send a Set Value Class message to the right side with the address of this value class, the
    // address of the new data, and the class of the value class that we're setting.
    if (m_id != NULL)
    {
        DebuggerIPCEvent event;

        // First, we have to make room on the Left Side for the new data for the value class. We allocate memory on the
        // Left Side for this, then write the new data across. The Set Value Class message will free the buffer when its
        // done.
        void *buffer = NULL;
        
        m_process->InitIPCEvent(&event, DB_IPCE_GET_BUFFER, true, (void *)m_appdomain->m_id);
        event.GetBuffer.bufSize = m_size;
        
        // Note: two-way event here...
        hr = m_process->m_cordb->SendIPCEvent(m_process, &event, sizeof(DebuggerIPCEvent));

        _ASSERTE(event.type == DB_IPCE_GET_BUFFER_RESULT);
        hr = event.GetBufferResult.hr;

        if (!SUCCEEDED(hr))
            return hr;

        // This is the pointer to the buffer on the Left Side.
        buffer = event.GetBufferResult.pBuffer;

        // Write the new data into the buffer.
        BOOL succ = WriteProcessMemory(m_process->m_handle, buffer, pFrom, m_size, NULL);

        if (!succ)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            return hr;
        }

        // Finally, send over the Set Value Class message.
        m_process->InitIPCEvent(&event, DB_IPCE_SET_VALUE_CLASS, true, (void *)m_appdomain->m_id);
        event.SetValueClass.oldData = (void*)m_id;
        event.SetValueClass.newData = buffer;
        event.SetValueClass.classMetadataToken = m_class->m_id;
        event.SetValueClass.classDebuggerModuleToken = m_class->GetModule()->m_debuggerModuleToken;
    
        // Note: two-way event here...
        hr = m_process->m_cordb->SendIPCEvent(m_process, &event, sizeof(DebuggerIPCEvent));

        // Stop now if we can't even send the event.
        if (!SUCCEEDED(hr))
            return hr;

        _ASSERTE(event.type == DB_IPCE_SET_VALUE_CLASS_RESULT);

        hr = event.hr;
    }
    else
    {
        // The value class is enregistered, so we don't have to go through the Left Side. Simply update the proper
        // register.
        if (m_size > sizeof(DWORD))
            return E_INVALIDARG;
        
        DWORD newValue = *((DWORD*)pFrom);
        hr = SetEnregisteredValue((void*)&newValue);
    }
    
    // That worked, so update the copy of the value we have over here.
    if (SUCCEEDED(hr))
        memcpy(m_objectCopy, pFrom, m_size);

	return hr;

#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbVCObjectValue::GetVirtualMethod(mdMemberRef memberRef,
                                           ICorDebugFunction **ppFunction)
{
    return E_NOTIMPL;
}

HRESULT CordbVCObjectValue::GetContext(ICorDebugContext **ppContext)
{
    return E_NOTIMPL;
}

HRESULT CordbVCObjectValue::IsValueClass(BOOL *pbIsValueClass)
{
    if (pbIsValueClass)
        *pbIsValueClass = TRUE;
    
    return S_OK;
}

HRESULT CordbVCObjectValue::GetManagedCopy(IUnknown **ppObject)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    ICorDBPrivHelper *pHelper = NULL;

    HRESULT hr = m_process->m_cordb->GetCorDBPrivHelper(&pHelper);

    if (SUCCEEDED(hr))
    {
        // Grab the module name...
        WCHAR *moduleName = m_class->GetModule()->GetModuleName();

        // Gotta have a module name...
        if ((moduleName == NULL) || (wcslen(moduleName) == 0))
        {
            hr = E_INVALIDARG;
            goto ErrExit;
        }

        // Grab the assembly name...
        WCHAR *assemblyName;
        assemblyName =
            m_class->GetModule()->GetCordbAssembly()->m_szAssemblyName;

        // Again, gotta have an assembly name...
        if ((assemblyName == NULL) || (wcslen(assemblyName) == 0))
        {
            hr = E_INVALIDARG;
            goto ErrExit;
        }

        // Groovy... go get a managed copy of this object.
        hr = pHelper->CreateManagedObject(assemblyName,
                                          moduleName,
                                          (mdTypeDef)m_class->m_id,
                                          m_objectCopy,
                                          ppObject);

    }
    
ErrExit:
    // Release the helper.
    if (pHelper)
        pHelper->Release();

    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbVCObjectValue::SetFromManagedCopy(IUnknown *pObject)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    ICorDBPrivHelper *pHelper = NULL;

    HRESULT hr = m_process->m_cordb->GetCorDBPrivHelper(&pHelper);

    if (SUCCEEDED(hr))
    {
        // Make room to receive the new bits.
        CQuickBytes dataBuf;
        BYTE *newData = (BYTE*)dataBuf.Alloc(m_size);
        
        // Get the helper to give us back a copy of the new bits.
        hr = pHelper->GetManagedObjectContents(pObject,
                                               newData,
                                               m_size);

        if (SUCCEEDED(hr))
        {
            // We've got the new bits, so update this object's copy.
            memcpy(m_objectCopy, newData, m_size);

            // Any local copy...
            if (m_localAddress != NULL)
                memcpy(m_localAddress, m_objectCopy, m_size);

            // Any remote data...
            if (m_id != NULL)
            {
                // Note: the only reason we can update the in-process
                // copy like this is because we know it doesn't
                // contain any object refs. If it did, then
                // GetManagedObjectContents would have returned a
                // failure.
                BOOL succ = WriteProcessMemory(m_process->m_handle,
                                               (void*)m_id,
                                               m_objectCopy,
                                               m_size,
                                               NULL);

                if (!succ)
                    hr =  HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    
    // Release the helper.
    if (pHelper)
        pHelper->Release();
    
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbVCObjectValue::Init(void)
{
    HRESULT hr = S_OK;

    hr = CordbValue::Init();

    if (FAILED(hr))
        return hr;
        
    // If we don't have the class, look it up using the signature
    if (m_class == NULL)
    {
        hr = ResolveValueClass();
        
        if (FAILED(hr))
            return hr;

        _ASSERTE(m_class != NULL);
    }

#ifdef _DEBUG
    // Make sure we've got a value class.
    bool isValueClass;

    hr = m_class->IsValueClass(&isValueClass);

    if (FAILED(hr))
        return hr;
    
    _ASSERTE(isValueClass);
#endif    

    // Get the object size from the class
    hr = m_class->GetObjectSize(&m_size);

    if (FAILED(hr))
        return hr;
    
    // Copy the entire object over to this process.
    m_objectCopy = new BYTE[m_size];

    if (m_objectCopy == NULL)
        return E_OUTOFMEMORY;

    if (m_localAddress != NULL)
    {
        // Copy the data from the local address space
        memcpy(&m_objectCopy[0], m_localAddress, m_size);
    }
    else
    {
		if (m_id != NULL)
		{
			// Copy the data out of the remote process
			BOOL succ = ReadProcessMemoryI(m_process->m_handle,
										(const void*) m_id,
										m_objectCopy,
										m_size,
										NULL);

			if (!succ)
				return HRESULT_FROM_WIN32(GetLastError());
		}
		else 
		{
			if (m_remoteRegAddr.kind == RAK_REGREG)
			{
				ICorDebugNativeFrame *pNativeFrame = NULL;
				hr = m_pParent->QueryInterface( IID_ICorDebugNativeFrame, (void **) &pNativeFrame);
				if (SUCCEEDED(hr))
				{
					_ASSERTE( pNativeFrame != NULL );
					_ASSERTE(m_size == 8);
					CordbNativeFrame	*pFrame = (CordbNativeFrame*) pNativeFrame;
					DWORD *highWordAddr = pFrame->GetAddressOfRegister(m_remoteRegAddr.reg1);
					DWORD *lowWordAddr = pFrame->GetAddressOfRegister(m_remoteRegAddr.reg2);
					memcpy(m_objectCopy, lowWordAddr, 4);
					memcpy(&m_objectCopy[4], highWordAddr, 4);
					pNativeFrame->Release();
				}
			}
			else
			{
				_ASSERTE(!"NYI");
				hr = E_NOTIMPL;
			}

		}
    }
    
    return hr;
}

HRESULT CordbVCObjectValue::ResolveValueClass(void)
{
    HRESULT hr = S_OK;

    _ASSERTE(m_pvSigBlob != NULL);

    // Skip the element type in the signature.
    PCCOR_SIGNATURE sigBlob = m_pvSigBlob;
    
    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(sigBlob);
    if( cb != 0)
    {
        sigBlob = &sigBlob[cb];
    }
    
    CorElementType et = CorSigUncompressElementType(sigBlob);
    _ASSERTE(et == ELEMENT_TYPE_VALUETYPE);
    
    // Grab the class token out of the signature.
    mdToken tok = CorSigUncompressToken(sigBlob);
    
    // If this is a typedef then we're done.
    if (TypeFromToken(tok) == mdtTypeDef)
        return m_module->LookupClassByToken(tok, &m_class);
    else
    {
        _ASSERTE(TypeFromToken(tok) == mdtTypeRef);

        // We have a TypeRef that could refer to a class in any loaded
        // module. It must refer to a class in a loaded module since
        // otherwise the Runtime could not have created the object.
        return m_module->ResolveTypeRef(tok, &m_class);
    }
    
    return hr;
}

/* ------------------------------------------------------------------------- *
 * Box Value class
 * ------------------------------------------------------------------------- */

CordbBoxValue::CordbBoxValue(CordbAppDomain *appdomain,
                             CordbModule *module,
                             ULONG cbSigBlob,
                             PCCOR_SIGNATURE pvSigBlob,
                             REMOTE_PTR remoteAddress,
                             SIZE_T objectSize,
                             SIZE_T offsetToVars,
                             CordbClass *objectClass)
    : CordbValue(appdomain, module, cbSigBlob, pvSigBlob, remoteAddress, NULL, NULL, false),
      m_class(objectClass), m_offsetToVars(offsetToVars)
{
    m_size = objectSize;
}

CordbBoxValue::~CordbBoxValue()
{
}

HRESULT CordbBoxValue::QueryInterface(REFIID id, void **pInterface)
{
	if (id == IID_ICorDebugValue)
		*pInterface = (ICorDebugValue*)(ICorDebugBoxValue*)this;
    else if (id == IID_ICorDebugBoxValue)
		*pInterface = (ICorDebugBoxValue*)this;
    else if (id == IID_ICorDebugGenericValue)
		*pInterface = (ICorDebugGenericValue*)this;
    else if (id == IID_ICorDebugHeapValue)
		*pInterface = (ICorDebugHeapValue*)this;
    else if (id == IID_IUnknown)
		*pInterface = (IUnknown*)(ICorDebugBoxValue*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
	return S_OK;
}

HRESULT CordbBoxValue::IsValid(BOOL *pbValid)
{
    VALIDATE_POINTER_TO_OBJECT(pbValid, BOOL *);
    
    // @todo: implement tracking of objects across collections.
    
    return E_NOTIMPL;
}

HRESULT CordbBoxValue::CreateRelocBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppBreakpoint, ICorDebugValueBreakpoint **);

    return E_NOTIMPL;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbBoxValue::GetValue(void *pTo)
{
    // Can't get a whole copy of a box.
	return E_INVALIDARG;
}

HRESULT CordbBoxValue::SetValue(void *pFrom)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    // You're not allowed to set a box value.
	return E_INVALIDARG;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbBoxValue::GetObject(ICorDebugObjectValue **ppObject)
{
    VALIDATE_POINTER_TO_OBJECT(ppObject, ICorDebugObjectValue **);
    
    HRESULT hr = S_OK;
    
    CordbVCObjectValue* pVCValue =
        new CordbVCObjectValue(m_appdomain, m_module, m_cbSigBlob, m_pvSigBlob,
                               (REMOTE_PTR)((BYTE*)m_id + m_offsetToVars), NULL, m_class, NULL);

    if (pVCValue != NULL)
    {
        hr = pVCValue->Init();

        if (SUCCEEDED(hr))
        {
            pVCValue->AddRef();
            *ppObject = (ICorDebugObjectValue*)pVCValue;
        }
        else
            delete pVCValue;
    }
    else
        hr = E_OUTOFMEMORY;
            
    return hr;
}

HRESULT CordbBoxValue::Init(void)
{
    HRESULT hr = CordbValue::Init();

    if (FAILED(hr))
        return hr;
        
    // Box values only really remember the info needed to unbox and
    // create a value class value.
    return S_OK;
}


/* ------------------------------------------------------------------------- *
 * Array Value class
 * ------------------------------------------------------------------------- */

// How large of a buffer do we allocate to hold array elements.
// Note that since we must be able to hold at least one element, we may
// allocate larger than the cache size here.
// Also, this cache doesn't include a small header used to store the rank vectors
#ifdef _DEBUG
// For debug, use a small size to cause more churn
    #define ARRAY_CACHE_SIZE (1000)
#else
// For release, guess 4 pages should be enough. Subtract some bytes to store
// the header so that that doesn't push us onto another page. (We guess a reasonable
// header size, but it's ok if it's larger). 
    #define ARRAY_CACHE_SIZE (4 * 4096 - 24)
#endif


CordbArrayValue::CordbArrayValue(CordbAppDomain *appdomain,
                                 CordbModule *module,
                                 ULONG cbSigBlob,
                                 PCCOR_SIGNATURE pvSigBlob,
                                 DebuggerIPCE_ObjectData *pObjectInfo,
                                 CordbClass *elementClass)
    : CordbValue(appdomain, module, cbSigBlob, pvSigBlob, pObjectInfo->objRef, NULL, NULL, false),
      m_objectCopy(NULL),
      m_class(elementClass), m_info(*pObjectInfo)
{
    m_size = m_info.objSize;

// Set range to illegal values to force a load on first access
	m_idxLower = m_idxUpper = -1;
}

CordbArrayValue::~CordbArrayValue()
{
    // Destroy the copy of the object.
    if (m_objectCopy != NULL)
        delete [] m_objectCopy;
}

HRESULT CordbArrayValue::QueryInterface(REFIID id, void **pInterface)
{
	if (id == IID_ICorDebugValue)
		*pInterface = (ICorDebugValue*)(ICorDebugArrayValue*)this;
    else if (id == IID_ICorDebugArrayValue)
		*pInterface = (ICorDebugArrayValue*)this;
    else if (id == IID_ICorDebugGenericValue)
		*pInterface = (ICorDebugGenericValue*)this;
    else if (id == IID_ICorDebugHeapValue)
		*pInterface = (ICorDebugHeapValue*)this;
    else if (id == IID_IUnknown)
		*pInterface = (IUnknown*)(ICorDebugArrayValue*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
	return S_OK;
}

HRESULT CordbArrayValue::GetElementType(CorElementType *pType)
{
    VALIDATE_POINTER_TO_OBJECT(pType, CorElementType *);
    
    *pType = m_info.arrayInfo.elementType;
    return S_OK;
}

HRESULT CordbArrayValue::GetRank(ULONG32 *pnRank)
{
    VALIDATE_POINTER_TO_OBJECT(pnRank, SIZE_T *);
    
    *pnRank = m_info.arrayInfo.rank;
    return S_OK;
}

HRESULT CordbArrayValue::GetCount(ULONG32 *pnCount)
{
    VALIDATE_POINTER_TO_OBJECT(pnCount, SIZE_T *);
    
    *pnCount = m_info.arrayInfo.componentCount;
    return S_OK;
}

HRESULT CordbArrayValue::GetDimensions(ULONG32 cdim, ULONG32 dims[])
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(dims, SIZE_T, cdim, true, true);

    if (cdim != m_info.arrayInfo.rank)
        return E_INVALIDARG;

    // SDArrays don't have bounds info, so return the component count.
    if (cdim == 1)
        dims[0] = m_info.arrayInfo.componentCount;
    else
    {
        _ASSERTE(m_info.arrayInfo.offsetToUpperBounds != 0);
        _ASSERTE(m_arrayUpperBase != NULL);

        // The upper bounds info in the array is the true size of each
        // dimension.
        for (unsigned int i = 0; i < cdim; i++)
            dims[i] = m_arrayUpperBase[i];
    }

    return S_OK;
}

HRESULT CordbArrayValue::HasBaseIndicies(BOOL *pbHasBaseIndicies)
{
    VALIDATE_POINTER_TO_OBJECT(pbHasBaseIndicies, BOOL *);

    *pbHasBaseIndicies = m_info.arrayInfo.offsetToLowerBounds != 0;
    return S_OK;
}

HRESULT CordbArrayValue::GetBaseIndicies(ULONG32 cdim, ULONG32 indicies[])
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(indicies, SIZE_T, cdim, true, true);

    if ((cdim != m_info.arrayInfo.rank) || 
        (m_info.arrayInfo.offsetToLowerBounds == 0))
        return E_INVALIDARG;

    _ASSERTE(m_arrayLowerBase != NULL);
    
    for (unsigned int i = 0; i < cdim; i++)
        indicies[i] = m_arrayLowerBase[i];

    return S_OK;
}

HRESULT CordbArrayValue::CreateElementValue(void *remoteElementPtr,
                                            void *localElementPtr,
                                            ICorDebugValue **ppValue)
{
    HRESULT hr = S_OK;
    
    if (m_info.arrayInfo.elementType == ELEMENT_TYPE_VALUETYPE)
    {
        _ASSERTE(m_class != NULL);
        
        hr = CordbValue::CreateValueByType(m_appdomain,
                                           m_module,
                                           1,
                         (PCCOR_SIGNATURE) &m_info.arrayInfo.elementType,
                                           m_class,
                                           remoteElementPtr,
                                           localElementPtr,
                                           false,
                                           NULL,
                                           NULL,
                                           ppValue);
    }
    else
        hr = CordbValue::CreateValueByType(m_appdomain,
                                           m_module,
                                           1,
                         (PCCOR_SIGNATURE) &m_info.arrayInfo.elementType,
                                           NULL,
                                           remoteElementPtr,
                                           localElementPtr,
                                           false,
                                           NULL,
                                           NULL,
                                           ppValue);
    
	return hr;
    
}

HRESULT CordbArrayValue::GetElement(ULONG32 cdim, ULONG32 indicies[],
                                    ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(indicies, SIZE_T, cdim, true, true);
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

    *ppValue = NULL;
    
    if ((cdim != m_info.arrayInfo.rank) || (indicies == NULL))
        return E_INVALIDARG;

    // If the array has lower bounds, adjust the indicies.
    if (m_info.arrayInfo.offsetToLowerBounds != 0)
    {
        _ASSERTE(m_arrayLowerBase != NULL);
        
        for (unsigned int i = 0; i < cdim; i++)
            indicies[i] -= m_arrayLowerBase[i];
    }

    SIZE_T offset = 0;
    
    // SDArrays don't have upper bounds
    if (cdim == 1)
    {
        offset = indicies[0];

        // Bounds check
        if (offset >= m_info.arrayInfo.componentCount)
            return E_INVALIDARG;
    }
    else
    {
        _ASSERTE(m_info.arrayInfo.offsetToUpperBounds != 0);
        _ASSERTE(m_arrayUpperBase != NULL);
        
        // Calculate the offset for all dimensions.
        DWORD multiplier = 1;

        for (int i = cdim - 1; i >= 0; i--)
        {
            // Bounds check
            if (indicies[i] >= m_arrayUpperBase[i])
                return E_INVALIDARG;

            offset += indicies[i] * multiplier;
            multiplier *= m_arrayUpperBase[i];
        }

        _ASSERTE(offset < m_info.arrayInfo.componentCount);
    }

    return GetElementAtPosition(offset, ppValue);
}

HRESULT CordbArrayValue::GetElementAtPosition(ULONG32 nPosition,
                                              ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

    if (nPosition >= m_info.arrayInfo.componentCount)
    {
        *ppValue = NULL;
        return E_INVALIDARG;
    }

    const int cbHeader = 2 * m_info.arrayInfo.rank * sizeof(DWORD);

    // Ensure that the proper subset is in the cache
    if (nPosition < m_idxLower || nPosition >= m_idxUpper) 
    {    
        const int cbElemSize = m_info.arrayInfo.elementSize;
        int len = max(ARRAY_CACHE_SIZE / cbElemSize, 1);        
        m_idxLower = nPosition;
        m_idxUpper = min(m_idxLower + len, m_info.arrayInfo.componentCount);        
        _ASSERTE(m_idxLower < m_idxUpper);
        
        int cbOffsetFrom = m_info.arrayInfo.offsetToArrayBase + m_idxLower * cbElemSize;
        
        int cbSize = (m_idxUpper - m_idxLower) * cbElemSize;

    // Copy the proper subrange of the array over 
        BOOL succ = ReadProcessMemoryI(m_process->m_handle,
                                      ((const BYTE*) m_id) + cbOffsetFrom,
                                      m_objectCopy + cbHeader,
                                      cbSize,
                                      NULL);

        if (!succ)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    // calculate local address
	void *localElementPtr = m_objectCopy + cbHeader +
		((nPosition - m_idxLower) * m_info.arrayInfo.elementSize);
    
    REMOTE_PTR remoteElementPtr = (REMOTE_PTR)(m_id +
        m_info.arrayInfo.offsetToArrayBase +
        (nPosition * m_info.arrayInfo.elementSize));

    return CreateElementValue(remoteElementPtr, localElementPtr, ppValue);
}

HRESULT CordbArrayValue::IsValid(BOOL *pbValid)
{
    VALIDATE_POINTER_TO_OBJECT(pbValid, BOOL *);

    // @todo: implement tracking of objects across collections.

    return E_NOTIMPL;
}

HRESULT CordbArrayValue::CreateRelocBreakpoint(
                                      ICorDebugValueBreakpoint **ppBreakpoint)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppBreakpoint, ICorDebugValueBreakpoint **);

    return E_NOTIMPL;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbArrayValue::GetValue(void *pTo)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pTo, void *, 1, false, true);
    
    // Copy out the value, which is the whole array.
    // There's no lazy-evaluation here, so this could be rather large
    BOOL succ = ReadProcessMemoryI(m_process->m_handle,
                                  (const void*) m_id,
                                  pTo,
                                  m_size,
                                  NULL);
    
	if (!succ)
            return HRESULT_FROM_WIN32(GetLastError());

	return S_OK;
}

HRESULT CordbArrayValue::SetValue(void *pFrom)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    // You're not allowed to set a whole array at once.
	return E_INVALIDARG;
#endif //RIGHT_SIDE_ONLY    
}


HRESULT CordbArrayValue::Init(void)
{
    HRESULT hr = S_OK;
    
    hr = CordbValue::Init();

    if (FAILED(hr))
        return hr;

    
    int cbVector = m_info.arrayInfo.rank * sizeof(DWORD);
    int cbHeader = 2 * cbVector;
    
    // Find largest data size that will fit in cache 
    unsigned int cbData = m_info.arrayInfo.componentCount * m_info.arrayInfo.elementSize;
    if (cbData > ARRAY_CACHE_SIZE) 
    {
        cbData = (ARRAY_CACHE_SIZE / m_info.arrayInfo.elementSize) 
            * m_info.arrayInfo.elementSize;
    }
    if (cbData < m_info.arrayInfo.elementSize) cbData = m_info.arrayInfo.elementSize;
    
    // Allocate memory 
    m_objectCopy = new BYTE[cbHeader + cbData];
    if (m_objectCopy == NULL)
        return E_OUTOFMEMORY;


    m_arrayLowerBase  = NULL;
    m_arrayUpperBase  = NULL;

    // Copy base vectors into header. (Offsets are 0 if the vectors aren't used)
    if (m_info.arrayInfo.offsetToLowerBounds != 0) 
    {    
        m_arrayLowerBase  = (DWORD*)(m_objectCopy);

        BOOL succ = ReadProcessMemoryI(m_process->m_handle,
                                      ((const BYTE*) m_id) + m_info.arrayInfo.offsetToLowerBounds,
                                      m_arrayLowerBase,
                                      cbVector,
                                      NULL);

        if (!succ)
            return HRESULT_FROM_WIN32(GetLastError());
    }


    if (m_info.arrayInfo.offsetToUpperBounds != 0)
    {
        m_arrayUpperBase  = (DWORD*)(m_objectCopy + cbVector);
        BOOL succ = ReadProcessMemoryI(m_process->m_handle,
                                      ((const BYTE*) m_id) + m_info.arrayInfo.offsetToUpperBounds,
                                      m_arrayUpperBase,
                                      cbVector,
                                      NULL);

        if (!succ)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    // That's all for now. We'll do lazy-evaluation for the array contents.

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\module.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: module.cpp
//
//*****************************************************************************
#include "stdafx.h"

// We have an assert in ceemain.cpp that validates this assumption
#define FIELD_OFFSET_NEW_ENC_DB          0x07FFFFFB

#ifdef UNDEFINE_RIGHT_SIDE_ONLY
#undef RIGHT_SIDE_ONLY
#endif //UNDEFINE_RIGHT_SIDE_ONLY

#include "WinBase.h"
#include "CorPriv.h"

/* ------------------------------------------------------------------------- *
 * Module class
 * ------------------------------------------------------------------------- */

#ifndef RIGHT_SIDE_ONLY

// Put this here to avoid dragging in EnC.cpp

HRESULT CordbModule::GetEditAndContinueSnapshot(
    ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot)
{
    return CORDBG_E_INPROC_NOT_IMPL;
}
#endif //RIGHT_SIDE_ONLY

MetadataPointerCache  CordbModule::m_metadataPointerCache;

CordbModule::CordbModule(CordbProcess *process, CordbAssembly *pAssembly,
                         REMOTE_PTR debuggerModuleToken, void* pMetadataStart, 
                         ULONG nMetadataSize, REMOTE_PTR PEBaseAddress, 
                         ULONG nPESize, BOOL fDynamic, BOOL fInMemory,
                         const WCHAR *szName,
                         CordbAppDomain *pAppDomain,
                         BOOL fInproc)
    : CordbBase((ULONG)debuggerModuleToken, enumCordbModule), m_process(process),
    m_pAssembly(pAssembly),
    m_classes(11), 
    m_functions(101),
    m_debuggerModuleToken(debuggerModuleToken),
    m_pMetadataStart(pMetadataStart),
    m_nMetadataSize(nMetadataSize),
    m_pMetadataCopy(NULL),
    m_PEBaseAddress(PEBaseAddress),
    m_nPESize(nPESize),
    m_fDynamic(fDynamic),
    m_fInMemory(fInMemory),
    m_szModuleName(NULL),
    m_pIMImport(NULL),
    m_pClass(NULL),
    m_pAppDomain(pAppDomain),
    m_fInproc(fInproc)
{
    _ASSERTE(m_debuggerModuleToken != NULL);
    // Make a copy of the name. 
    m_szModuleName = new WCHAR[wcslen(szName) + 1];
    if (m_szModuleName)
        wcscpy(m_szModuleName, szName);

    {
        DWORD dwErr;
        dwErr = process->GetID(&m_dwProcessId);
        _ASSERTE(!FAILED(dwErr));
    }
}

/*
    A list of which resources owened by this object are accounted for.

UNKNOWN:
        void*            m_pMetadataStartToBe;        
        void*            m_pMetadataStart; 
HANDLED:
        CordbProcess*    m_process; // Assigned w/o AddRef() 
        CordbAssembly*   m_pAssembly; // Assigned w/o AddRef() 
        CordbAppDomain*  m_pAppDomain; // Assigned w/o AddRef() 
        CordbHashTable   m_classes; // Neutered
        CordbHashTable   m_functions; // Neutered
        IMetaDataImport *m_pIMImport; // Released in ~CordbModule
        BYTE*            m_pMetadataCopy; // Deleted by m_metadataPointerCache when no other modules use it
        WCHAR*           m_szModuleName; // Deleted in ~CordbModule
        CordbClass*      m_pClass; // Released in ~CordbModule
*/

CordbModule::~CordbModule()
{
#ifdef RIGHT_SIDE_ONLY
    // We don't want to release this inproc, b/c we got it from
    // GetImporter(), which just gave us a copy of the pointer that
    // it owns.
    if (m_pIMImport)
        m_pIMImport->Release();
#endif //RIGHT_SIDE_ONLY

    if (m_pClass)
        m_pClass->Release();

    if (m_pMetadataCopy && !m_fInproc)
    {
        if (!m_fDynamic)
        {
            CordbModule::m_metadataPointerCache.ReleaseCachePointer(m_dwProcessId, m_pMetadataCopy, m_pMetadataStart, m_nMetadataSize);
        }
        else
        {
            delete[] m_pMetadataCopy;
        }
        m_pMetadataCopy = NULL;
        m_nMetadataSize = 0;
    }

    if (m_szModuleName != NULL)
        delete [] m_szModuleName;
}

// Neutered by CordbAppDomain
void CordbModule::Neuter()
{
    AddRef();
    {
        // m_process, m_pAppDomain, m_pAssembly assigned w/o AddRef()
        NeuterAndClearHashtable(&m_classes);
        NeuterAndClearHashtable(&m_functions);

        CordbBase::Neuter();
    }        
    Release();
}

HRESULT CordbModule::ConvertToNewMetaDataInMemory(BYTE *pMD, DWORD cb)
{
    if (pMD == NULL || cb == 0)
        return E_INVALIDARG;
    
    //Save what we've got
    BYTE *rgbMetadataCopyOld = m_pMetadataCopy;
    DWORD cbOld = m_nMetadataSize;

    // Try the new stuff.
    m_pMetadataCopy = pMD;
    m_nMetadataSize = cb;
    

    HRESULT hr = ReInit(true);

    if (!FAILED(hr))
    {
        if (rgbMetadataCopyOld)
        {
            delete[] rgbMetadataCopyOld;            
        }
    }
    else
    {
        // Presumably, the old MD is still there...
        m_pMetadataCopy = rgbMetadataCopyOld;
        m_nMetadataSize = cbOld;
    }

    return hr;
}

HRESULT CordbModule::Init(void)
{
    return ReInit(false);
}

// Note that if we're reopening the metadata, then this must be a dynamic
// module & we've already dragged the metadata over from the left side, so
// don't go get it again.
//
// CordbHashTableEnum::GetBase simulates the work done here by 
// simply getting an IMetaDataImporter interface from the runtime Module* -
// if more work gets done in the future, change that as well.
HRESULT CordbModule::ReInit(bool fReopen)
{
    HRESULT hr = S_OK;
    BOOL succ = true;
    //
    // Allocate enough memory for the metadata for this module and copy
    // it over from the remote process.
    //
    if (m_nMetadataSize == 0)
        return S_OK;
    
    // For inproc, simply use the already present metadata.
    if (!fReopen && !m_fInproc) 
    {
        DWORD dwErr;
        if (!m_fDynamic)
        {
            dwErr = CordbModule::m_metadataPointerCache.AddRefCachePointer(GetProcess()->m_handle, m_dwProcessId, m_pMetadataStart, m_nMetadataSize, &m_pMetadataCopy);
            if (FAILED(dwErr))
            {
                succ = false;
            }
        }
        else
        {
            dwErr = CordbModule::m_metadataPointerCache.CopyRemoteMetadata(GetProcess()->m_handle, m_pMetadataStart, m_nMetadataSize, &m_pMetadataCopy);
            if (FAILED(dwErr))
            {
                succ = false;
            }
        }
    }
    
    // else it's already local, so don't get it again (it's invalid
    //  by now, anyways)

    if (succ || fReopen)
    {
        //
        // Open the metadata scope in Read/Write mode.
        //
        IMetaDataDispenserEx *pDisp;
        hr = m_process->m_cordb->m_pMetaDispenser->QueryInterface(
                                                    IID_IMetaDataDispenserEx,
                                                    (void**)&pDisp);
        if( FAILED(hr) )
            return hr;
         
        if (fReopen)
        {   
            LOG((LF_CORDB,LL_INFO100000, "CM::RI: converting to new metadata\n"));
            IMetaDataImport *pIMImport = NULL;
            hr = pDisp->OpenScopeOnMemory(m_pMetadataCopy,
                                          m_nMetadataSize,
                                          0,
                                          IID_IMetaDataImport,
                                          (IUnknown**)&pIMImport);
            if (FAILED(hr))
            {
                pDisp->Release();
                return hr;
            }

            typedef HRESULT (_stdcall *pfnReOpenMetaData)
                (void *pUnk, LPCVOID pData, ULONG cbData);

            pfnReOpenMetaData pfn = (pfnReOpenMetaData)
                GetProcAddress(WszGetModuleHandle(L"mscoree.dll"),(LPCSTR)23); 
            if (pfn == NULL)
            {
                pDisp->Release();
                pIMImport->Release();
                return E_FAIL;
            }

            hr = pfn(m_pIMImport,
                     m_pMetadataCopy,
                     m_nMetadataSize);    

            pDisp->Release();
            pIMImport->Release();

            return hr;
        }

        // Save the old mode for restoration
        VARIANT valueOld;
        hr = pDisp->GetOption(MetaDataSetUpdate, &valueOld);
        if (FAILED(hr))
            return hr;

        // Set R/W mode so that we can update the metadata when
        // we do EnC operations.
        VARIANT valueRW;
        valueRW.vt = VT_UI4;
        valueRW.lVal = MDUpdateFull;
        
        hr = pDisp->SetOption(MetaDataSetUpdate, &valueRW);
        if (FAILED(hr))
        {
            pDisp->Release();
            return hr;
        }

        hr = pDisp->OpenScopeOnMemory(m_pMetadataCopy,
                                      m_nMetadataSize,
                                      0,
                                      IID_IMetaDataImport,
                                      (IUnknown**)&m_pIMImport);
        if (FAILED(hr))
        {
            pDisp->Release();
            return hr;
        }
        
        // Restore the old setting
        hr = pDisp->SetOption(MetaDataSetUpdate, &valueOld);
        pDisp->Release();
        
        if (FAILED(hr))
            return hr;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        if (m_pMetadataCopy)
        {
            if (!m_fDynamic)
            {
                CordbModule::m_metadataPointerCache.ReleaseCachePointer(m_dwProcessId, m_pMetadataCopy, m_pMetadataStart, m_nMetadataSize);
            }
            else
            {
                delete[] m_pMetadataCopy;
            }
            m_pMetadataCopy = NULL;
            m_nMetadataSize = 0;
        }
        return hr;
    }
    
    return hr;
}


HRESULT CordbModule::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugModule)
        *pInterface = (ICorDebugModule*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugModule*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbModule::GetProcess(ICorDebugProcess **ppProcess)
{
    VALIDATE_POINTER_TO_OBJECT(ppProcess, ICorDebugProcess **);
    
    *ppProcess = (ICorDebugProcess*)m_process;
    (*ppProcess)->AddRef();

    return S_OK;
}

HRESULT CordbModule::GetBaseAddress(CORDB_ADDRESS *pAddress)
{
    VALIDATE_POINTER_TO_OBJECT(pAddress, CORDB_ADDRESS *);
    
    *pAddress = PTR_TO_CORDB_ADDRESS(m_PEBaseAddress);
    return S_OK;
}

HRESULT CordbModule::GetAssembly(ICorDebugAssembly **ppAssembly)
{
    VALIDATE_POINTER_TO_OBJECT(ppAssembly, ICorDebugAssembly **);

#ifndef RIGHT_SIDE_ONLY
    // There exists a chance that the assembly wasn't available when we
    // got the module the first time (eg, ModuleLoadFinished before
    // AssemblyLoadFinished).  If the module's assembly is now available,
    // attach it to the module.
    if (m_pAssembly == NULL)
    {
        // try and go get it.
        DebuggerModule *dm = (DebuggerModule *)m_debuggerModuleToken;
        Assembly *as = dm->m_pRuntimeModule->GetAssembly();
        if (as != NULL)
        {
            CordbAssembly *ca = (CordbAssembly*)GetAppDomain()
                ->m_assemblies.GetBase((ULONG)as);

            _ASSERTE(ca != NULL);
            m_pAssembly = ca;
        }
    }
#endif //RIGHT_SIDE_ONLY

    *ppAssembly = (ICorDebugAssembly *)m_pAssembly;
    if ((*ppAssembly) != NULL)
        (*ppAssembly)->AddRef();

    return S_OK;
}

HRESULT CordbModule::GetName(ULONG32 cchName, ULONG32 *pcchName, WCHAR szName[])
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY_OR_NULL(szName, WCHAR, cchName, true, true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pcchName, ULONG32);

    const WCHAR *szTempName = m_szModuleName;

    // In case we didn't get the name (most likely out of memory on ctor).
    if (!szTempName)
        szTempName = L"<unknown>";

    // true length of the name, with null
    SIZE_T iTrueLen = wcslen(szTempName) + 1;

    // Do a safe buffer copy including null if there is room.
    if (szName != NULL)
    {
        // Figure out the length that can actually be copied
        SIZE_T iCopyLen = min(cchName, iTrueLen);
    
        wcsncpy(szName, szTempName, iCopyLen);

        // Force a null no matter what, and return the count if desired.
        szName[iCopyLen - 1] = 0;
    }
    
    // Always provide the true string length, so the caller can know if they
    // provided an insufficient buffer.  The length includes the null char.
    if (pcchName)
        *pcchName = iTrueLen;

    return S_OK;
}

HRESULT CordbModule::EnableJITDebugging(BOOL bTrackJITInfo, BOOL bAllowJitOpts)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    CordbProcess *pProcess = GetProcess();
    CORDBCheckProcessStateOKAndSync(pProcess, GetAppDomain());
    
    DebuggerIPCEvent event;
    pProcess->InitIPCEvent(&event, 
                           DB_IPCE_CHANGE_JIT_DEBUG_INFO, 
                           true,
                           (void *)(GetAppDomain()->m_id));
                           
    event.JitDebugInfo.debuggerModuleToken = m_debuggerModuleToken;
    event.JitDebugInfo.fTrackInfo = bTrackJITInfo;
    event.JitDebugInfo.fAllowJitOpts = bAllowJitOpts;
    
    // Note: two-way event here...
    HRESULT hr = pProcess->m_cordb->SendIPCEvent(pProcess, 
                                                 &event,
                                                 sizeof(DebuggerIPCEvent));

    if (!SUCCEEDED(hr))
        return hr;

    _ASSERTE(event.type == DB_IPCE_CHANGE_JIT_INFO_RESULT);
    
    return event.hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbModule::EnableClassLoadCallbacks(BOOL bClassLoadCallbacks)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    // You must receive ClassLoad callbacks for dynamic modules so that we can keep the metadata up-to-date on the Right
    // Side. Therefore, we refuse to turn them off for all dynamic modules (they were forced on when the module was
    // loaded on the Left Side.)
    if (m_fDynamic && !bClassLoadCallbacks)
        return E_INVALIDARG;
    
    // Send a Set Class Load Flag event to the left side. There is no need to wait for a response, and this can be
    // called whether or not the process is synchronized.
    CordbProcess *pProcess = GetProcess();
    
    DebuggerIPCEvent event;
    pProcess->InitIPCEvent(&event, 
                           DB_IPCE_SET_CLASS_LOAD_FLAG, 
                           false,
                           (void *)(GetAppDomain()->m_id));
    event.SetClassLoad.debuggerModuleToken = m_debuggerModuleToken;
    event.SetClassLoad.flag = (bClassLoadCallbacks == TRUE);

    HRESULT hr = pProcess->m_cordb->SendIPCEvent(pProcess, &event,
                                                 sizeof(DebuggerIPCEvent));
    
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbModule::GetFunctionFromToken(mdMethodDef token,
                                          ICorDebugFunction **ppFunction)
{
    if (token == mdMethodDefNil)
        return E_INVALIDARG;
        
    VALIDATE_POINTER_TO_OBJECT(ppFunction, ICorDebugFunction **);
    
    HRESULT hr = S_OK;

    INPROC_LOCK();
    
    // If we already have a CordbFunction for this token, then we'll
    // take since we know it has to be valid.
    CordbFunction *f = (CordbFunction *)m_functions.GetBase(token);

    if (f == NULL)
    {
        // Validate the token.
        if (!m_pIMImport->IsValidToken(token))
        {
            hr = E_INVALIDARG;
            goto LExit;
        }

        f = new CordbFunction(this, token, 0);
            
        if (f == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }

        hr = m_functions.AddBase(f);
        
        if (FAILED(hr))
        {
            delete f;
            goto LExit;
        }
    }
    
    *ppFunction = (ICorDebugFunction*)f;
    (*ppFunction)->AddRef();
    
LExit:
    INPROC_UNLOCK();
    return hr;
}

HRESULT CordbModule::GetFunctionFromRVA(CORDB_ADDRESS rva,
                                        ICorDebugFunction **ppFunction)
{
    VALIDATE_POINTER_TO_OBJECT(ppFunction, ICorDebugFunction **);
    
    return E_NOTIMPL;
}

HRESULT CordbModule::LookupClassByToken(mdTypeDef token,
                                        CordbClass **ppClass)
{
    *ppClass = NULL;
    
    if ((token == mdTypeDefNil) || (TypeFromToken(token) != mdtTypeDef))
        return E_INVALIDARG;
    
    CordbClass *c = (CordbClass *)m_classes.GetBase(token);

    if (c == NULL)
    {
        // Validate the token.
        if (!m_pIMImport->IsValidToken(token))
            return E_INVALIDARG;
        
        c = new CordbClass(this, token);

        if (c == NULL)
            return E_OUTOFMEMORY;
        
        HRESULT res = m_classes.AddBase(c);

        if (FAILED(res))
        {
            delete c;
            return (res);
        }
    }
    
    *ppClass = c;

    return S_OK;
}

HRESULT CordbModule::LookupClassByName(LPWSTR fullClassName,
                                       CordbClass **ppClass)
{
    WCHAR fullName[MAX_CLASSNAME_LENGTH + 1];
    wcscpy(fullName, fullClassName);

    *ppClass = NULL;

    // Find the TypeDef for this class, if it exists.
    mdTypeDef token = mdTokenNil;
    WCHAR *pStart = fullName;
    HRESULT hr;

    do
    {
        WCHAR *pEnd = wcschr(pStart, NESTED_SEPARATOR_WCHAR);
        if (pEnd)
            *pEnd++ = L'\0';

        hr = m_pIMImport->FindTypeDefByName(pStart,
                                            token,
                                            &token);
        pStart = pEnd;

    } while (pStart && SUCCEEDED(hr));

    if (FAILED(hr))
        return hr;

    // Now that we have the token, simply call the normal lookup...
    return LookupClassByToken(token, ppClass);
}

HRESULT CordbModule::GetClassFromToken(mdTypeDef token,
                                       ICorDebugClass **ppClass)
{
    CordbClass *c;

    VALIDATE_POINTER_TO_OBJECT(ppClass, ICorDebugClass **);
    
    // Validate the token.
    if (!m_pIMImport->IsValidToken(token))
        return E_INVALIDARG;
        
    INPROC_LOCK();    
    
    HRESULT hr = LookupClassByToken(token, &c);

    if (SUCCEEDED(hr))
    {
        *ppClass = (ICorDebugClass*)c;
        (*ppClass)->AddRef();
    }
    
    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbModule::CreateBreakpoint(ICorDebugModuleBreakpoint **ppBreakpoint)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppBreakpoint, ICorDebugModuleBreakpoint **);

    return E_NOTIMPL;
#endif //RIGHT_SIDE_ONLY    
}

//
// Return the token for the Module table entry for this object.  The token
// may then be passed to the meta data import api's.
//
HRESULT CordbModule::GetToken(mdModule *pToken)
{
    VALIDATE_POINTER_TO_OBJECT(pToken, mdModule *);
    HRESULT hr = S_OK;

    INPROC_LOCK();

    _ASSERTE(m_pIMImport);
    hr = (m_pIMImport->GetModuleFromScope(pToken));

    INPROC_UNLOCK();
    
    return hr;
}


//
// Return a meta data interface pointer that can be used to examine the
// meta data for this module.
HRESULT CordbModule::GetMetaDataInterface(REFIID riid, IUnknown **ppObj)
{
    VALIDATE_POINTER_TO_OBJECT(ppObj, IUnknown **);
    HRESULT hr = S_OK;

    INPROC_LOCK();
    
    // QI the importer that we already have and return the result.
    hr = m_pIMImport->QueryInterface(riid, (void**)ppObj);

    INPROC_UNLOCK();

    return hr;
}

//
// LookupFunction finds an existing CordbFunction in the given module.
// If the function doesn't exist, it returns NULL.
//
CordbFunction* CordbModule::LookupFunction(mdMethodDef funcMetadataToken)
{
    return (CordbFunction *)m_functions.GetBase(funcMetadataToken);
}

HRESULT CordbModule::IsDynamic(BOOL *pDynamic)
{
    VALIDATE_POINTER_TO_OBJECT(pDynamic, BOOL *);

    (*pDynamic) = m_fDynamic;

    return S_OK;
}

HRESULT CordbModule::IsInMemory(BOOL *pInMemory)
{
    VALIDATE_POINTER_TO_OBJECT(pInMemory, BOOL *);

    (*pInMemory) = m_fInMemory;

    return S_OK;
}

HRESULT CordbModule::GetGlobalVariableValue(mdFieldDef fieldDef,
                                            ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

    HRESULT hr = S_OK;

    INPROC_LOCK();

    if (m_pClass == NULL)
    {
        hr = LookupClassByToken(COR_GLOBAL_PARENT_TOKEN,
                                &m_pClass);
        if (FAILED(hr))
            goto LExit;
        _ASSERTE( m_pClass != NULL);
    }        
    
    hr = m_pClass->GetStaticFieldValue(fieldDef, NULL, ppValue);
                                       
LExit:

    INPROC_UNLOCK();
    return hr;
}



//
// CreateFunction creates a new function from the given information and
// adds it to the module.
//
HRESULT CordbModule::CreateFunction(mdMethodDef funcMetadataToken,
                                    SIZE_T funcRVA,
                                    CordbFunction** ppFunction)
{
    // Create a new function object.
    CordbFunction* pFunction = new CordbFunction(this,funcMetadataToken, funcRVA);

    if (pFunction == NULL)
        return E_OUTOFMEMORY;

    // Add the function to the Module's hash of all functions.
    HRESULT hr = m_functions.AddBase(pFunction);
        
    if (SUCCEEDED(hr))
        *ppFunction = pFunction;
    else
        delete pFunction;

    return hr;
}


//
// LookupClass finds an existing CordbClass in the given module.
// If the class doesn't exist, it returns NULL.
//
CordbClass* CordbModule::LookupClass(mdTypeDef classMetadataToken)
{
    return (CordbClass *)m_classes.GetBase(classMetadataToken);
}

//
// CreateClass creates a new class from the given information and
// adds it to the module.
//
HRESULT CordbModule::CreateClass(mdTypeDef classMetadataToken,
                                 CordbClass** ppClass)
{
    CordbClass* pClass =
        new CordbClass(this, classMetadataToken);

    if (pClass == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = m_classes.AddBase(pClass);

    if (SUCCEEDED(hr))
        *ppClass = pClass;
    else
        delete pClass;

    if (classMetadataToken == COR_GLOBAL_PARENT_TOKEN)
    {
        _ASSERTE( m_pClass == NULL ); //redundant create
        m_pClass = pClass;
        m_pClass->AddRef();
    }

    return hr;
}

HRESULT CordbModule::ResolveTypeRef(mdTypeRef token,
                                    CordbClass **ppClass)
{
    *ppClass = NULL;
    
    if ((token == mdTypeRefNil) || (TypeFromToken(token) != mdtTypeRef))
        return E_INVALIDARG;
    
    // Get the necessary properties of the typeref from this module.
    WCHAR typeName[MAX_CLASSNAME_LENGTH + 1];
    WCHAR fullName[MAX_CLASSNAME_LENGTH + 1];
    HRESULT hr;

    WCHAR *pName = typeName + MAX_CLASSNAME_LENGTH + 1;
    WCHAR cSep = L'\0';
    ULONG fullNameLen;

    do
    {
        if (pName <= typeName)
            hr = E_FAIL;       // buffer too small
        else
            hr = m_pIMImport->GetTypeRefProps(token,
                                          &token,
                                          fullName,
                                          MAX_CLASSNAME_LENGTH,
                                          &fullNameLen);
        if (SUCCEEDED(hr))
        {
            *(--pName) = cSep;
            cSep = NESTED_SEPARATOR_WCHAR;

            fullNameLen--;          // don't count null terminator
            pName -= fullNameLen;

            if (pName < typeName)
                hr = E_FAIL;       // buffer too small
            else
                memcpy(pName, fullName, fullNameLen*sizeof(fullName[0]));
         }

    }
    while (TypeFromToken(token) == mdtTypeRef && SUCCEEDED(hr));

    if (FAILED(hr))
        return hr;

    return GetAppDomain()->ResolveClassByName(pName, ppClass);
}


//
// Copy the metadata from the in-memory cached copy to the output stream given.
// This was done in lieu of using an accessor to return the pointer to the cached
// data, which would not have been thread safe during updates.
//
HRESULT CordbModule::SaveMetaDataCopyToStream(IStream *pIStream)
{
    ULONG       cbWritten;              // Junk variable for output.
    HRESULT     hr;

    // Caller must have the stream ready for input at current location.  Simply
    // write from our copy of the current metadata to the stream.  Expectations
    // are that the data can be written and all of it was, which we assert.
    _ASSERTE(pIStream);
    hr = pIStream->Write(m_pMetadataCopy, m_nMetadataSize, &cbWritten);
    _ASSERTE(FAILED(hr) || cbWritten == m_nMetadataSize);
    return (hr);
}

//
// GetSize returns the size of the module.
//
HRESULT CordbModule::GetSize(ULONG32 *pcBytes)
{
    VALIDATE_POINTER_TO_OBJECT(pcBytes, ULONG32 *);

    *pcBytes = m_nPESize;

    return S_OK;
}

CordbAssembly *CordbModule::GetCordbAssembly(void)
{
#ifndef RIGHT_SIDE_ONLY
    // There exists a chance that the assembly wasn't available when we
    // got the module the first time (eg, ModuleLoadFinished before
    // AssemblyLoadFinished).  If the module's assembly is now available,
    // attach it to the module.
    if (m_pAssembly == NULL)
    {
        // try and go get it.
        DebuggerModule *dm = (DebuggerModule *)m_debuggerModuleToken;
        Assembly *as = dm->m_pRuntimeModule->GetAssembly();
        if (as != NULL)
        {
            CordbAssembly *ca = (CordbAssembly*)GetAppDomain()
                ->m_assemblies.GetBase((ULONG)as);
    
            _ASSERTE(ca != NULL);
            m_pAssembly = ca;
        }
    }
#endif //RIGHT_SIDE_ONLY

    return m_pAssembly;
}


/* ------------------------------------------------------------------------- *
 * Class class
 * ------------------------------------------------------------------------- */

CordbClass::CordbClass(CordbModule *m, mdTypeDef classMetadataToken)
  : CordbBase(classMetadataToken, enumCordbClass), m_module(m), m_EnCCounterLastSyncClass(0),
    m_instanceVarCount(0), m_staticVarCount(0), m_fields(NULL),
    m_staticVarBase(NULL), m_isValueClass(false), m_objectSize(0),
    m_thisSigSize(0), m_hasBeenUnloaded(false), m_continueCounterLastSync(0),
    m_loadEventSent(FALSE)
{
}

/*
    A list of which resources owened by this object are accounted for.

    UNKNOWN:
        CordbSyncBlockFieldTable m_syncBlockFieldsStatic; 
    HANDLED:
        CordbModule*            m_module; // Assigned w/o AddRef()
        DebuggerIPCE_FieldData *m_fields; // Deleted in ~CordbClass
*/

CordbClass::~CordbClass()
{
    if(m_fields)
        delete [] m_fields;
}

// Neutered by CordbModule
void CordbClass::Neuter()
{
    AddRef();
    {   
        CordbBase::Neuter();
    }
    Release();
}    

HRESULT CordbClass::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugClass)
        *pInterface = (ICorDebugClass*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugClass*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbClass::GetStaticFieldValue(mdFieldDef fieldDef,
                                        ICorDebugFrame *pFrame,
                                        ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll always be synched, but not neccessarily b/c we've gotten a
    // synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    HRESULT          hr = S_OK;
    *ppValue = NULL;
    BOOL             fSyncBlockField = FALSE;
    ULONG            cbSigBlobNoMod;
    PCCOR_SIGNATURE  pvSigBlobNoMod;
    ULONG            cb;

    // Used below for faking out CreateValueByType
    static CorElementType elementTypeClass = ELEMENT_TYPE_CLASS;

    INPROC_LOCK();
    
    // Validate the token.
    if (!GetModule()->m_pIMImport->IsValidToken(fieldDef))
    {
        hr = E_INVALIDARG;
        goto LExit;
    }

    // Make sure we have enough info about the class. Also re-query if the static var base is still NULL.
    hr = Init(m_staticVarBase == NULL);

    if (!SUCCEEDED(hr))
        goto LExit;

    // Lookup the field given its metadata token.
    DebuggerIPCE_FieldData *pFieldData;

    hr = GetFieldInfo(fieldDef, &pFieldData);

    if (hr == CORDBG_E_ENC_HANGING_FIELD)
    {
        hr = GetSyncBlockField(fieldDef, 
                               &pFieldData,
                               NULL);
            
        if (SUCCEEDED(hr))
            fSyncBlockField = TRUE;
    }
    
    if (!SUCCEEDED(hr))
        goto LExit;

    if (!pFieldData->fldIsStatic)
    {
        hr = CORDBG_E_FIELD_NOT_STATIC;
        goto LExit;
    }
    
    REMOTE_PTR pRmtStaticValue;

    if (!pFieldData->fldIsTLS && !pFieldData->fldIsContextStatic)
    {
        // We'd better have the static area initialized on the Left Side.
        if (m_staticVarBase == NULL)
        {
            hr = CORDBG_E_STATIC_VAR_NOT_AVAILABLE;
            goto LExit;
        }
    
        // For normal old static variables (including ones that are relative to the app domain... that's handled on the
        // Left Side through manipulation of m_staticVarBase) the address of the variable is m_staticVarBase + the
        // variable's offset.
        pRmtStaticValue = (BYTE*)m_staticVarBase + pFieldData->fldOffset;
    }
    else
    {
        if (fSyncBlockField)
        {
            _ASSERTE(!pFieldData->fldIsContextStatic);
            pRmtStaticValue = (REMOTE_PTR)pFieldData->fldOffset;
        }
        else
        {
            // What thread are we working on here.
            if (pFrame == NULL)
            {
                hr = E_INVALIDARG;
                goto LExit;
            }
            
            ICorDebugChain *pChain = NULL;

            hr = pFrame->GetChain(&pChain);

            if (FAILED(hr))
                goto LExit;

            CordbChain *c = (CordbChain*)pChain;
            CordbThread *t = c->m_thread;

            // Send an event to the Left Side to find out the address of this field for the given thread.
            DebuggerIPCEvent event;
            GetProcess()->InitIPCEvent(&event, DB_IPCE_GET_SPECIAL_STATIC, true, (void *)(m_module->GetAppDomain()->m_id));
            event.GetSpecialStatic.fldDebuggerToken = pFieldData->fldDebuggerToken;
            event.GetSpecialStatic.debuggerThreadToken = t->m_debuggerThreadToken;

            // Note: two-way event here...
            hr = GetProcess()->m_cordb->SendIPCEvent(GetProcess(), &event, sizeof(DebuggerIPCEvent));

            if (FAILED(hr))
                goto LExit;

            _ASSERTE(event.type == DB_IPCE_GET_SPECIAL_STATIC_RESULT);

            // @todo: for a given static on a given thread, the address will never change. We should be taking advantage of
            // that...
            pRmtStaticValue = (BYTE*)event.GetSpecialStaticResult.fldAddress;
        }
        
        if (pRmtStaticValue == NULL)
        {
            hr = CORDBG_E_STATIC_VAR_NOT_AVAILABLE;
            goto LExit;
        }
    }

    ULONG cbSigBlob;
    PCCOR_SIGNATURE pvSigBlob;

    cbSigBlob = cbSigBlobNoMod = pFieldData->fldFullSigSize;
    pvSigBlob = pvSigBlobNoMod = pFieldData->fldFullSig;

    // If we've got some funky modifier, then remove it.
    cb =_skipFunkyModifiersInSignature(pvSigBlobNoMod);

    if( cb != 0)
    {
        cbSigBlobNoMod -= cb;
        pvSigBlobNoMod = &pvSigBlobNoMod[cb];
    }

    // If this is a static that is non-primitive, then we have to do an extra level of indirection.
    if (!pFieldData->fldIsTLS &&
        !pFieldData->fldIsContextStatic &&
        !fSyncBlockField &&               // EnC-added fields don't need the extra de-ref.
        !pFieldData->fldIsPrimitive &&    // Classes that are really primitives don't need the extra de-ref.
        ((pvSigBlobNoMod[0] == ELEMENT_TYPE_CLASS)    || 
         (pvSigBlobNoMod[0] == ELEMENT_TYPE_OBJECT)   ||
         (pvSigBlobNoMod[0] == ELEMENT_TYPE_SZARRAY)  || 
         (pvSigBlobNoMod[0] == ELEMENT_TYPE_ARRAY)    ||
         (pvSigBlobNoMod[0] == ELEMENT_TYPE_STRING)   ||
         (pvSigBlobNoMod[0] == ELEMENT_TYPE_VALUETYPE && !pFieldData->fldIsRVA)))
    {
        REMOTE_PTR pRealRmtStaticValue = NULL;
        
        BOOL succ = ReadProcessMemoryI(GetProcess()->m_handle,
                                       pRmtStaticValue,
                                       &pRealRmtStaticValue,
                                       sizeof(pRealRmtStaticValue),
                                       NULL);
        
        if (!succ)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto LExit;
        }

        if (pRealRmtStaticValue == NULL)
        {
            hr = CORDBG_E_STATIC_VAR_NOT_AVAILABLE;
            goto LExit;
        }

        pRmtStaticValue = pRealRmtStaticValue;
    }
    
    // Static value classes are stored as handles so that GC can deal with them properly.  Thus, we need to follow the
    // handle like an objectref.  Do this by forcing CreateValueByType to think this is an objectref. Note: we don't do
    // this for value classes that have an RVA, since they're layed out at the RVA with no handle.
    if (*pvSigBlobNoMod == ELEMENT_TYPE_VALUETYPE &&
        !pFieldData->fldIsRVA &&
        !pFieldData->fldIsPrimitive &&
        !pFieldData->fldIsTLS &&
        !pFieldData->fldIsContextStatic)
    {
        pvSigBlob = (PCCOR_SIGNATURE)&elementTypeClass;
        cbSigBlob = sizeof(elementTypeClass);
    }
    
    ICorDebugValue *pValue;
    hr = CordbValue::CreateValueByType(GetAppDomain(),
                                       GetModule(),
                                       cbSigBlob, pvSigBlob,
                                       NULL,
                                       pRmtStaticValue, NULL,
                                       false,
                                       NULL,
                                       NULL,
                                       &pValue);

    if (SUCCEEDED(hr))
        *ppValue = pValue;
      
LExit:
    INPROC_UNLOCK();

    hr = CordbClass::PostProcessUnavailableHRESULT(hr, GetModule()->m_pIMImport, fieldDef);
    
    return hr;
}

HRESULT CordbClass::PostProcessUnavailableHRESULT(HRESULT hr, 
                                       IMetaDataImport *pImport,
                                       mdFieldDef fieldDef)
{                                       
    if (hr == CORDBG_E_FIELD_NOT_AVAILABLE)
    {
        DWORD dwFieldAttr;
        hr = pImport->GetFieldProps(
            fieldDef,
            NULL,
            NULL,
            0,
            NULL,
            &dwFieldAttr,
            NULL,
            0,
            NULL,
            NULL,
            0);

        if (IsFdLiteral(dwFieldAttr))
        {
            hr = CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL;
        }
    }

    return hr;
}

HRESULT CordbClass::GetModule(ICorDebugModule **ppModule)
{
    VALIDATE_POINTER_TO_OBJECT(ppModule, ICorDebugModule **);
    
    *ppModule = (ICorDebugModule*) m_module;
    (*ppModule)->AddRef();

    return S_OK;
}

HRESULT CordbClass::GetToken(mdTypeDef *pTypeDef)
{
    VALIDATE_POINTER_TO_OBJECT(pTypeDef, mdTypeDef *);
    
    *pTypeDef = m_id;

    return S_OK;
}

HRESULT CordbClass::GetObjectSize(ULONG32 *pObjectSize)
{
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    HRESULT hr = S_OK;
    *pObjectSize = 0;
    
    hr = Init(FALSE);

    if (!SUCCEEDED(hr))
        return hr;

    *pObjectSize = m_objectSize;

    return hr;
}

HRESULT CordbClass::IsValueClass(bool *pIsValueClass)
{
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    HRESULT hr = S_OK;
    *pIsValueClass = false;
    
    hr = Init(FALSE);

    if (!SUCCEEDED(hr))
        return hr;

    *pIsValueClass = m_isValueClass;

    return hr;
}

HRESULT CordbClass::GetThisSignature(ULONG *pcbSigBlob,
                                     PCCOR_SIGNATURE *ppvSigBlob)
{
    HRESULT hr = S_OK;
    
    if (m_thisSigSize == 0)
    {
        hr = Init(FALSE);

        if (!SUCCEEDED(hr))
            return hr;

        if (m_isValueClass)
        {
            // Value class methods implicitly have their 'this'
            // argument passed by reference.
            m_thisSigSize += CorSigCompressElementType(
                                                   ELEMENT_TYPE_BYREF,
                                                   &m_thisSig[m_thisSigSize]);
            m_thisSigSize += CorSigCompressElementType(
                                                   ELEMENT_TYPE_VALUETYPE,
                                                   &m_thisSig[m_thisSigSize]);
        }
        else
            m_thisSigSize += CorSigCompressElementType(
                                                   ELEMENT_TYPE_CLASS,
                                                   &m_thisSig[m_thisSigSize]);

        m_thisSigSize += CorSigCompressToken(m_id,
                                             &m_thisSig[m_thisSigSize]);

        _ASSERTE(m_thisSigSize <= sizeof(m_thisSig));
    }

    *pcbSigBlob = m_thisSigSize;
    *ppvSigBlob = (PCCOR_SIGNATURE) &m_thisSig;

    return hr;
}

HRESULT CordbClass::Init(BOOL fForceInit)
{
    // If we've done a continue since we last time we got hanging static fields,
    // we should clear our our cache, since everything may have moved.
    if (m_continueCounterLastSync < GetProcess()->m_continueCounter)
    {
        m_syncBlockFieldsStatic.Clear();
        m_continueCounterLastSync = GetProcess()->m_continueCounter;
    }
    
    // We don't have to reinit if the EnC version is up-to-date &
    // we haven't been told to do the init regardless.
    if (m_EnCCounterLastSyncClass >= GetProcess()->m_EnCCounter
        && !fForceInit)
        return S_OK;
        
    bool wait = true;
    bool fFirstEvent = true;
    unsigned int fieldIndex = 0;
    unsigned int totalFieldCount = 0;
    DebuggerIPCEvent *retEvent = NULL;
    
    CORDBSyncFromWin32StopIfStopped(GetProcess());

    INPROC_LOCK();
    
    HRESULT hr = S_OK;
    
    // We've got a remote address that points to the EEClass.
    // We need to send to the left side to get real information about
    // the class, including its instance and static variables.
    CordbProcess *pProcess = GetProcess();
    
    DebuggerIPCEvent event;
    pProcess->InitIPCEvent(&event, 
                           DB_IPCE_GET_CLASS_INFO, 
                           false,
                           (void *)(m_module->GetAppDomain()->m_id));
    event.GetClassInfo.classMetadataToken = m_id;
    event.GetClassInfo.classDebuggerModuleToken =
        m_module->m_debuggerModuleToken;

    hr = pProcess->m_cordb->SendIPCEvent(pProcess, &event,
                                         sizeof(DebuggerIPCEvent));

    // Stop now if we can't even send the event.
    if (!SUCCEEDED(hr))
        goto exit;

    // Wait for events to return from the RC. We expect at least one
    // class info result event.
    retEvent = (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);

    while (wait)
    {
#ifdef RIGHT_SIDE_ONLY
        hr = pProcess->m_cordb->WaitForIPCEventFromProcess(pProcess, 
                                                    m_module->GetAppDomain(),
                                                    retEvent);
#else 
        if (fFirstEvent)
            hr = pProcess->m_cordb->GetFirstContinuationEvent(pProcess,retEvent);
        else
            hr = pProcess->m_cordb->GetNextContinuationEvent(pProcess,retEvent);
#endif //RIGHT_SIDE_ONLY    

        if (!SUCCEEDED(hr))
            goto exit;
        
        _ASSERTE(retEvent->type == DB_IPCE_GET_CLASS_INFO_RESULT);

        // If this is the first event back from the RC, then create the
        // array to hold the field.
        if (fFirstEvent)
        {
            fFirstEvent = false;

#ifdef _DEBUG
            // Shouldn't ever loose fields!
            totalFieldCount = m_instanceVarCount + m_staticVarCount;
            _ASSERTE(retEvent->GetClassInfoResult.instanceVarCount +
                     retEvent->GetClassInfoResult.staticVarCount >=
                     totalFieldCount);
#endif
            
            m_isValueClass = retEvent->GetClassInfoResult.isValueClass;
            m_objectSize = retEvent->GetClassInfoResult.objectSize;
            m_staticVarBase = retEvent->GetClassInfoResult.staticVarBase;
            m_instanceVarCount = retEvent->GetClassInfoResult.instanceVarCount;
            m_staticVarCount = retEvent->GetClassInfoResult.staticVarCount;

            totalFieldCount = m_instanceVarCount + m_staticVarCount;

            // Since we don't keep pointers to the m_fields elements, 
            // just toss it & get a new one.
            if (m_fields != NULL)
            {
                delete m_fields;
                m_fields = NULL;
            }
            
            if (totalFieldCount > 0)
            {
                m_fields = new DebuggerIPCE_FieldData[totalFieldCount];

                if (m_fields == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
            }
        }

        DebuggerIPCE_FieldData *currentFieldData =
            &(retEvent->GetClassInfoResult.fieldData);

        for (unsigned int i = 0; i < retEvent->GetClassInfoResult.fieldCount;
             i++)
        {
            m_fields[fieldIndex] = *currentFieldData;
            m_fields[fieldIndex].fldFullSigSize = 0;
            
            _ASSERTE(m_fields[fieldIndex].fldOffset != FIELD_OFFSET_NEW_ENC_DB);
            
            currentFieldData++;
            fieldIndex++;
        }

        if (fieldIndex >= totalFieldCount)
            wait = false;
    }

    // Remember the most recently acquired version of this class
    m_EnCCounterLastSyncClass = GetProcess()->m_EnCCounter;

exit:    

#ifndef RIGHT_SIDE_ONLY    
    GetProcess()->ClearContinuationEvents();
#endif
    
    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbClass::GetFieldSig(mdFieldDef fldToken, DebuggerIPCE_FieldData *pFieldData)
{
    HRESULT hr = S_OK;
    
    if (pFieldData->fldType == ELEMENT_TYPE_VALUETYPE || 
        pFieldData->fldType == ELEMENT_TYPE_PTR)
    {
        hr = GetModule()->m_pIMImport->GetFieldProps(fldToken, NULL, NULL, 0, NULL, NULL,
                                                     &(pFieldData->fldFullSig),
                                                     &(pFieldData->fldFullSigSize),
                                                     NULL, NULL, NULL);

        if (FAILED(hr))
            return hr;

        // Point past the calling convention, adjusting
        // the sig size accordingly.
        UINT_PTR pvSigBlobEnd = (UINT_PTR)pFieldData->fldFullSig + pFieldData->fldFullSigSize;
        
        CorCallingConvention conv = (CorCallingConvention) CorSigUncompressData(pFieldData->fldFullSig);
        _ASSERTE(conv == IMAGE_CEE_CS_CALLCONV_FIELD);

        pFieldData->fldFullSigSize = pvSigBlobEnd - (UINT_PTR)pFieldData->fldFullSig;
    }
    else
    {
        pFieldData->fldFullSigSize = 1;
        pFieldData->fldFullSig = (PCCOR_SIGNATURE) &(pFieldData->fldType);
    }

    return hr;
}

// ****** DON'T CALL THIS WITHOUT FIRST CALLING object->IsValid !!!!!!! ******
// object is NULL if this is being called from GetStaticFieldValue
HRESULT CordbClass::GetSyncBlockField(mdFieldDef fldToken, 
                                      DebuggerIPCE_FieldData **ppFieldData,
                                      CordbObjectValue *object)
{
    HRESULT hr = S_OK;
    _ASSERTE(object == NULL || object->m_fIsValid); 
            // What we really want to assert is that
            // IsValid has been called, if this is for an instance value

    BOOL fStatic = (object == NULL);

    // Static stuff should _NOT_ be cleared, since they stick around.  Thus
    // the separate tables.

    // We must get new copies each time we call continue b/c we get the
    // actual Object ptr from the left side, which can move during a GC.
    
    DebuggerIPCE_FieldData *pInfo = NULL;
    if (!fStatic)
    {
        pInfo = object->m_syncBlockFieldsInstance.GetFieldInfo(fldToken);

        // We've found a previously located entry
        if (pInfo != NULL)
        {
            (*ppFieldData) = pInfo;
            return S_OK;
        }
    }
    else
    {
        pInfo = m_syncBlockFieldsStatic.GetFieldInfo(fldToken);

        // We've found a previously located entry
        if (pInfo != NULL)
        {
            (*ppFieldData) = pInfo;
            return S_OK;
        }
    }
    
    // We're not going to be able to get the instance-specific field
    // if we can't get the instance.
    if (!fStatic && object->m_info.objRefBad)
        return CORDBG_E_ENC_HANGING_FIELD;

    // Go get this particular field.
    DebuggerIPCEvent event;
    CordbProcess *process = GetModule()->GetProcess();
    _ASSERTE(process != NULL);

    process->InitIPCEvent(&event, 
                          DB_IPCE_GET_SYNC_BLOCK_FIELD, 
                          true, // two-way event
                          (void *)m_module->GetAppDomain()->m_id);
                          
    event.GetSyncBlockField.debuggerModuleToken = (void *)GetModule()->m_id;
    hr = GetToken(&(event.GetSyncBlockField.classMetadataToken));
    _ASSERTE(!FAILED(hr));
    event.GetSyncBlockField.fldToken = fldToken;

    if (fStatic)
    {
        event.GetSyncBlockField.staticVarBase = m_staticVarBase; // in case it's static.
        
        event.GetSyncBlockField.pObject = NULL;
        event.GetSyncBlockField.objectType = ELEMENT_TYPE_MAX;
        event.GetSyncBlockField.offsetToVars = NULL;
    }
    else
    {
        _ASSERTE(object != NULL);
    
        event.GetSyncBlockField.pObject = (void *)object->m_id;
        event.GetSyncBlockField.objectType = object->m_info.objectType;
        event.GetSyncBlockField.offsetToVars = object->m_info.objOffsetToVars;
        
        event.GetSyncBlockField.staticVarBase = NULL;
    }
    
    // Note: two-way event here...
    hr = process->m_cordb->SendIPCEvent(process, 
                                        &event,
                                        sizeof(DebuggerIPCEvent));

    // Stop now if we can't even send the event.
    if (!SUCCEEDED(hr))
        return hr;

    _ASSERTE(event.type == DB_IPCE_GET_SYNC_BLOCK_FIELD_RESULT);

    if (!SUCCEEDED(event.hr))
        return event.hr;

    _ASSERTE(pInfo == NULL);

    _ASSERTE( fStatic == event.GetSyncBlockFieldResult.fStatic );
    
    // Save the results for later.
    if(fStatic)
    {
        m_syncBlockFieldsStatic.AddFieldInfo(&(event.GetSyncBlockFieldResult.fieldData));
        pInfo = m_syncBlockFieldsStatic.GetFieldInfo(fldToken);

        // We've found a previously located entry.esove
        if (pInfo != NULL)
        {
            (*ppFieldData) = pInfo;
        }
    }
    else
    {
        object->m_syncBlockFieldsInstance.AddFieldInfo(&(event.GetSyncBlockFieldResult.fieldData));
        pInfo = object->m_syncBlockFieldsInstance.GetFieldInfo(fldToken);

        // We've found a previously located entry.esove
        if (pInfo != NULL)
        {
            (*ppFieldData) = pInfo;
        }
    }

    if (pInfo != NULL)
    {
        // It's important to do this here, once we've got the final memory blob for pInfo
        hr = GetFieldSig(fldToken, pInfo);
        return hr;
    }
    else
        return CORDBG_E_ENC_HANGING_FIELD;
}


HRESULT CordbClass::GetFieldInfo(mdFieldDef fldToken, DebuggerIPCE_FieldData **ppFieldData)
{
    HRESULT hr = S_OK;

    *ppFieldData = NULL;
    
    hr = Init(FALSE);

    if (!SUCCEEDED(hr))
        return hr;

    unsigned int i;

    for (i = 0; i < (m_instanceVarCount + m_staticVarCount); i++)
    {
        if (m_fields[i].fldMetadataToken == fldToken)
        {
            if (m_fields[i].fldType == ELEMENT_TYPE_MAX)
            {
                return CORDBG_E_ENC_HANGING_FIELD; // caller should get instance-specific info.
            }
        
            if (m_fields[i].fldFullSigSize == 0)
            {
                hr = GetFieldSig(fldToken, &m_fields[i]);
                if (FAILED(hr))
                    return hr;
            }

            *ppFieldData = &(m_fields[i]);
            return S_OK;
        }
    }

    // Hmmm... we didn't find the field on this class. See if the field really belongs to this class or not.
    mdTypeDef classTok;
    
    hr = GetModule()->m_pIMImport->GetFieldProps(fldToken, &classTok, NULL, 0, NULL, NULL, NULL, 0, NULL, NULL, NULL);

    if (FAILED(hr))
        return hr;

    if (classTok == (mdTypeDef) m_id)
    {
        // Well, the field belongs in this class. The assumption is that the Runtime optimized the field away.
        return CORDBG_E_FIELD_NOT_AVAILABLE;
    }

    // Well, the field doesn't even belong to this class...
    return E_INVALIDARG;
}

/* ------------------------------------------------------------------------- *
 * Function class
 * ------------------------------------------------------------------------- */

CordbFunction::CordbFunction(CordbModule *m,
                             mdMethodDef funcMetadataToken,
                             SIZE_T funcRVA)
  : CordbBase(funcMetadataToken, enumCordbFunction), m_module(m), m_class(NULL),
    m_token(funcMetadataToken), m_isNativeImpl(false),
    m_functionRVA(funcRVA), m_nativeInfoCount(0), m_nativeInfo(NULL), 
    m_nativeInfoValid(false), m_argumentCount(0), m_methodSig(NULL), 
    m_localsSig(NULL), m_argCount(0), m_isStatic(false), m_localVarCount(0),
    m_localVarSigToken(mdSignatureNil), 
    m_encCounterLastSynch(0),
    m_nVersionMostRecentEnC(0), 
    m_nVersionLastNativeInfo(0)
{
}

/*
    A list of which resources owened by this object are accounted for.

    UNKNOWN:
        PCCOR_SIGNATURE          m_methodSig;
        PCCOR_SIGNATURE          m_localsSig;
        ICorJitInfo::NativeVarInfo *m_nativeInfo;           
        
    HANDLED:
        CordbModule             *m_module; // Assigned w/o AddRef()
        CordbClass              *m_class; // Assigned w/o AddRef()
*/

CordbFunction::~CordbFunction()
{
    if ( m_rgilCode.Table() != NULL)
        for (int i =0; i < m_rgilCode.Count();i++)
        {
            CordbCode * pCordbCode = m_rgilCode.Table()[i];
            pCordbCode->Release();
        }

    if ( m_rgnativeCode.Table() != NULL)
        for (int i =0; i < m_rgnativeCode.Count();i++)
        {
            CordbCode * pCordbCode = m_rgnativeCode.Table()[i];
            pCordbCode->Release();
        }

    if (m_nativeInfo != NULL)
        delete [] m_nativeInfo;
}

// Neutered by CordbModule
void CordbFunction::Neuter()
{
    AddRef();
    {
        // Neuter any/all native CordbCode objects
        if ( m_rgilCode.Table() != NULL)
        {
            for (int i =0; i < m_rgilCode.Count();i++)
            {
                CordbCode * pCordbCode = m_rgilCode.Table()[i];
                pCordbCode->Neuter();
            }
        }

        // Neuter any/all native CordbCode objects
        if ( m_rgnativeCode.Table() != NULL)
        {
            for (int i =0; i < m_rgnativeCode.Count();i++)
            {
                CordbCode * pCordbCode = m_rgnativeCode.Table()[i];
                pCordbCode->Neuter();
            }
        }
        
        CordbBase::Neuter();
    }
    Release();
}

HRESULT CordbFunction::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugFunction)
        *pInterface = (ICorDebugFunction*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugFunction*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

// if nVersion == const int DJI_VERSION_MOST_RECENTLY_JITTED,
// get the highest-numbered version.  Otherwise,
// get the version asked for.
CordbCode *UnorderedCodeArrayGet( UnorderedCodeArray *pThis, SIZE_T nVersion )
{
#ifdef LOGGING
    if (nVersion == DJI_VERSION_MOST_RECENTLY_JITTED)
        LOG((LF_CORDB,LL_EVERYTHING,"Looking for DJI_VERSION_MOST_"
            "RECENTLY_JITTED\n"));
    else
        LOG((LF_CORDB,LL_EVERYTHING,"Looking for ver 0x%x\n", nVersion));
#endif //LOGGING
        
    if (pThis->Table() != NULL)
    {
        CordbCode *pCode = *pThis->Table();
        CordbCode *pCodeMax = pCode;
        USHORT cCode;
        USHORT i;
        for(i = 0,cCode=pThis->Count(); i <cCode; i++)
        {
            pCode = (pThis->Table())[i];
            if (nVersion == DJI_VERSION_MOST_RECENTLY_JITTED )
            {
                if (pCode->m_nVersion > pCodeMax->m_nVersion)
                {   
                    pCodeMax = pCode;
                }
            }
            else if (pCode->m_nVersion == nVersion)
            {
                LOG((LF_CORDB,LL_EVERYTHING,"Found ver 0x%x\n", nVersion));
                return pCode;
            }
        }

        if (nVersion == DJI_VERSION_MOST_RECENTLY_JITTED )
        {
    #ifdef LOGGING
            if (pCodeMax != NULL )
                LOG((LF_CORDB,LL_INFO10000,"Found 0x%x, ver 0x%x as "
                    "most recent\n",pCodeMax,pCodeMax->m_nVersion));
    #endif //LOGGING
            return pCodeMax;
        }
    }

    return NULL;
}

HRESULT UnorderedCodeArrayAdd( UnorderedCodeArray *pThis, CordbCode *pCode )
{
    CordbCode **ppCodeNew =pThis->Append();

    if (NULL == ppCodeNew)
        return E_OUTOFMEMORY;

    *ppCodeNew = pCode;
    
    // This ref is freed whenever the code array we are storing is freed.
    pCode->AddRef();
    return S_OK;
}


HRESULT CordbFunction::GetModule(ICorDebugModule **ppModule)
{
    VALIDATE_POINTER_TO_OBJECT(ppModule, ICorDebugModule **);

    HRESULT hr = UpdateToMostRecentEnCVersion();
    if (FAILED(hr))
        return hr;
    
    *ppModule = (ICorDebugModule*) m_module;
    (*ppModule)->AddRef();

    return hr;
}

HRESULT CordbFunction::GetClass(ICorDebugClass **ppClass)
{
    VALIDATE_POINTER_TO_OBJECT(ppClass, ICorDebugClass **);
    
    *ppClass = NULL;
    
    INPROC_LOCK();

    HRESULT hr = UpdateToMostRecentEnCVersion();
    if (FAILED(hr))
        return hr;
    
    if (m_class == NULL)
    {
        // We're not looking for any particular version, just
        // the class info.  This seems like the best version to request
        hr = Populate(DJI_VERSION_MOST_RECENTLY_JITTED);

        if (FAILED(hr))
            goto LExit;
    }

    *ppClass = (ICorDebugClass*) m_class;

LExit:
    INPROC_UNLOCK();

    if (FAILED(hr))
        return hr;

    if (*ppClass)
    {
        (*ppClass)->AddRef();
        return S_OK;
    }
    else
        return S_FALSE;
}

HRESULT CordbFunction::GetToken(mdMethodDef *pMemberDef)
{
    VALIDATE_POINTER_TO_OBJECT(pMemberDef, mdMethodDef *);

    HRESULT hr = UpdateToMostRecentEnCVersion();

    if (FAILED(hr))
        return hr;
    
    *pMemberDef = m_token;
    return S_OK;
}

HRESULT CordbFunction::GetILCode(ICorDebugCode **ppCode)
{
    VALIDATE_POINTER_TO_OBJECT(ppCode, ICorDebugCode **);

    INPROC_LOCK();

    HRESULT hr = UpdateToMostRecentEnCVersion();
    if (FAILED(hr))
        return hr;
    
    CordbCode *pCode = NULL;
    hr = GetCodeByVersion(TRUE, bILCode, DJI_VERSION_MOST_RECENTLY_JITTED, &pCode);
    *ppCode = (ICorDebugCode*)pCode;

    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbFunction::GetNativeCode(ICorDebugCode **ppCode)
{
    VALIDATE_POINTER_TO_OBJECT(ppCode, ICorDebugCode **);

    INPROC_LOCK();

    HRESULT hr = UpdateToMostRecentEnCVersion();
    if (FAILED(hr))
        return hr;

    CordbCode *pCode = NULL;
    hr = GetCodeByVersion(TRUE, bNativeCode, DJI_VERSION_MOST_RECENTLY_JITTED, &pCode);
    
    *ppCode = (ICorDebugCode*)pCode;

    if (SUCCEEDED(hr) && (pCode == NULL))
        hr = CORDBG_E_CODE_NOT_AVAILABLE;

    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbFunction::GetCodeByVersion(BOOL fGetIfNotPresent, BOOL fIsIL, 
                                        SIZE_T nVer, CordbCode **ppCode)
{
    VALIDATE_POINTER_TO_OBJECT(ppCode, ICorDebugCode **);

    _ASSERTE(*ppCode == NULL && "Common source of errors is getting addref'd copy here and never Release()ing it");
    *ppCode = NULL;

    // Its okay to do this if the process is not sync'd.
    CORDBRequireProcessStateOK(GetProcess());

    HRESULT hr = S_OK;
    CordbCode *pCode = NULL;

    LOG((LF_CORDB, LL_EVERYTHING, "Asked to find code ver 0x%x\n", nVer));

    if (((fIsIL && (pCode = UnorderedCodeArrayGet(&m_rgilCode, nVer)) == NULL) ||
         (!fIsIL && (pCode = UnorderedCodeArrayGet(&m_rgnativeCode, nVer)) == NULL)) &&
        fGetIfNotPresent)
        hr = Populate(nVer);

    if (SUCCEEDED(hr) && pCode == NULL)
    {
        if (fIsIL)
            pCode=UnorderedCodeArrayGet(&m_rgilCode, nVer);
        else
            pCode=UnorderedCodeArrayGet(&m_rgnativeCode, nVer);
    }

    if (pCode != NULL)
    {
        pCode->AddRef();
        *ppCode = pCode;
    }
    
    return hr;
}

HRESULT CordbFunction::CreateBreakpoint(ICorDebugFunctionBreakpoint **ppBreakpoint)
{
    HRESULT hr = S_OK;

#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppBreakpoint, ICorDebugFunctionBreakpoint **);

    hr = UpdateToMostRecentEnCVersion();
    if (FAILED(hr))
        return hr;

    ICorDebugCode *pCode = NULL;

    // Use the IL code so that we stop after the prolog
    hr = GetILCode(&pCode);
    
    if (FAILED(hr))
        goto LError;

    hr = pCode->CreateBreakpoint(0, ppBreakpoint);

LError:
    if (pCode != NULL)
        pCode->Release();

    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbFunction::GetLocalVarSigToken(mdSignature *pmdSig)
{
    VALIDATE_POINTER_TO_OBJECT(pmdSig, mdSignature *);
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    
    HRESULT hr = UpdateToMostRecentEnCVersion();
    if (FAILED(hr))
        return hr;

    *pmdSig = m_localVarSigToken;

    return S_OK;
}


HRESULT CordbFunction::GetCurrentVersionNumber(ULONG32 *pnCurrentVersion)
{
    VALIDATE_POINTER_TO_OBJECT(pnCurrentVersion, ULONG32 *);

    INPROC_LOCK();

    HRESULT hr = UpdateToMostRecentEnCVersion();
    if (FAILED(hr))
        return hr;

    CordbCode *pCode = NULL;
    hr = GetCodeByVersion(TRUE, FALSE, DJI_VERSION_MOST_RECENTLY_EnCED, &pCode);
    
    if (FAILED(hr))
        goto LError;

    (*pnCurrentVersion) = INTERNAL_TO_EXTERNAL_VERSION(m_nVersionMostRecentEnC);
    _ASSERTE((*pnCurrentVersion) >= USER_VISIBLE_FIRST_VALID_VERSION_NUMBER);
    
LError:
    if (pCode != NULL)
        pCode->Release();

    INPROC_UNLOCK();

    return hr;
}


HRESULT CordbFunction::CreateCode(BOOL isIL, REMOTE_PTR startAddress,
                                  SIZE_T size, CordbCode** ppCode,
                                  SIZE_T nVersion, void *CodeVersionToken,
                                  REMOTE_PTR ilToNativeMapAddr,
                                  SIZE_T ilToNativeMapSize)
{
    _ASSERTE(ppCode != NULL);

    *ppCode = NULL;
    
    CordbCode* pCode = new CordbCode(this, isIL, startAddress, size,
                                     nVersion, CodeVersionToken,
                                     ilToNativeMapAddr, ilToNativeMapSize);

    if (pCode == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = S_OK;
    
    if (isIL)
    {
        hr = UnorderedCodeArrayAdd( &m_rgilCode, pCode);
    }
    else
    {
        hr = UnorderedCodeArrayAdd( &m_rgnativeCode, pCode);
    }

    if (FAILED(hr))
    {
        delete pCode;
        return hr;
    }

    pCode->AddRef();
    *ppCode = pCode;

    return S_OK;
}

HRESULT CordbFunction::Populate( SIZE_T nVersion)
{
    HRESULT hr = S_OK;
    CordbProcess* pProcess = m_module->m_process;

    _ASSERTE(m_token != mdMethodDefNil);

    // Bail now if we've already discovered that this function is implemented natively as part of the Runtime.
    if (m_isNativeImpl)
        return CORDBG_E_FUNCTION_NOT_IL;

    // Figure out if this function is implemented as a native part of the Runtime. If it is, then this ICorDebugFunction
    // is just a container for certian Right Side bits of info, i.e., module, class, token, etc.
    DWORD attrs;
    DWORD implAttrs;
    ULONG ulRVA;
	BOOL	isDynamic;

    hr = GetModule()->m_pIMImport->GetMethodProps(m_token, NULL, NULL, 0, NULL,
                                     &attrs, NULL, NULL, &ulRVA, &implAttrs);

    if (FAILED(hr))
        return hr;
	IfFailRet( GetModule()->IsDynamic(&isDynamic) );

	// A method has associated IL if it's RVA is non-zero unless it is a dynamic module
    if (IsMiNative(implAttrs) || (isDynamic == FALSE && ulRVA == 0))
    {
        m_isNativeImpl = true;
        return CORDBG_E_FUNCTION_NOT_IL;
    }

    // Make sure the Left Side is running free before trying to send an event to it.
    CORDBSyncFromWin32StopIfStopped(pProcess);

    // Send the get function data event to the RC.
    DebuggerIPCEvent event;
    pProcess->InitIPCEvent(&event, DB_IPCE_GET_FUNCTION_DATA, true, (void *)(m_module->GetAppDomain()->m_id));
    event.GetFunctionData.funcMetadataToken = m_token;
    event.GetFunctionData.funcDebuggerModuleToken = m_module->m_debuggerModuleToken;
    event.GetFunctionData.nVersion = nVersion;

    _ASSERTE(m_module->m_debuggerModuleToken != NULL);

    // Note: two-way event here...
    hr = pProcess->m_cordb->SendIPCEvent(pProcess, &event, sizeof(DebuggerIPCEvent));

    // Stop now if we can't even send the event.
    if (!SUCCEEDED(hr))
        return hr;

    _ASSERTE(event.type == DB_IPCE_FUNCTION_DATA_RESULT);

    // Cache the most recently EnC'ed version number
    m_nVersionMostRecentEnC = event.FunctionDataResult.nVersionMostRecentEnC;

    // Fill in the proper function data.
    m_functionRVA = event.FunctionDataResult.funcRVA;
    
    // Should we make or fill in some class data for this function?
    if ((m_class == NULL) && (event.FunctionDataResult.classMetadataToken != mdTypeDefNil))
    {
        CordbAssembly *pAssembly = m_module->GetCordbAssembly();
        CordbModule* pClassModule = pAssembly->m_pAppDomain->LookupModule(event.FunctionDataResult.funcDebuggerModuleToken);
        _ASSERTE(pClassModule != NULL);
        
        CordbClass* pClass = pClassModule->LookupClass(event.FunctionDataResult.classMetadataToken);

        if (pClass == NULL)
        {
            hr = pClassModule->CreateClass(event.FunctionDataResult.classMetadataToken, &pClass);

            if (!SUCCEEDED(hr))
                goto exit;
        }
                
        _ASSERTE(pClass != NULL);
        m_class = pClass;
    }

    // Do we need to make any code objects for this function?
    LOG((LF_CORDB,LL_INFO10000,"R:CF::Pop: looking for IL code, version 0x%x\n", event.FunctionDataResult.ilnVersion));
        
    CordbCode *pCodeTemp = NULL;
    if ((UnorderedCodeArrayGet(&m_rgilCode, event.FunctionDataResult.ilnVersion) == NULL) &&
        (event.FunctionDataResult.ilStartAddress != 0))
    {
        LOG((LF_CORDB,LL_INFO10000,"R:CF::Pop: not found, creating...\n"));
        _ASSERTE(DJI_VERSION_INVALID != event.FunctionDataResult.ilnVersion);
        
        hr = CreateCode(TRUE,
                        event.FunctionDataResult.ilStartAddress,
                        event.FunctionDataResult.ilSize,
                        &pCodeTemp, event.FunctionDataResult.ilnVersion,
                        event.FunctionDataResult.CodeVersionToken,
                        NULL, 0);

        if (!SUCCEEDED(hr))
            goto exit;
    }
    
    LOG((LF_CORDB,LL_INFO10000,"R:CF::Pop: looking for native code, ver 0x%x\n", event.FunctionDataResult.nativenVersion));
        
    if (UnorderedCodeArrayGet(&m_rgnativeCode, event.FunctionDataResult.nativenVersion) == NULL &&
        event.FunctionDataResult.nativeStartAddressPtr != 0)
    {
        LOG((LF_CORDB,LL_INFO10000,"R:CF::Pop: not found, creating...\n"));
        _ASSERTE(DJI_VERSION_INVALID != event.FunctionDataResult.nativenVersion);
        
        if (pCodeTemp)
            pCodeTemp->Release();

        hr = CreateCode(FALSE,
                        event.FunctionDataResult.nativeStartAddressPtr,
                        event.FunctionDataResult.nativeSize,
                        &pCodeTemp, event.FunctionDataResult.nativenVersion,
                        event.FunctionDataResult.CodeVersionToken,
                        event.FunctionDataResult.ilToNativeMapAddr,
                        event.FunctionDataResult.ilToNativeMapSize);

        if (!SUCCEEDED(hr))
            goto exit;
    }

    SetLocalVarToken(event.FunctionDataResult.localVarSigToken);
    
exit:
    if (pCodeTemp)
        pCodeTemp->Release();

    return hr;
}

//
// LoadNativeInfo loads from the left side any native variable info
// from the JIT.
//
HRESULT CordbFunction::LoadNativeInfo(void)
{
    HRESULT hr = S_OK;

    // Then, if we've either never done this before (no info), or we have, but the version number has increased, we
    // should try and get a newer version of our JIT info.
    if(m_nativeInfoValid && m_nVersionLastNativeInfo >= m_nVersionMostRecentEnC)
        return S_OK;

    // You can't do this if the function is implemented as part of the Runtime.
    if (m_isNativeImpl)
        return CORDBG_E_FUNCTION_NOT_IL;

    DebuggerIPCEvent *retEvent = NULL;
    bool wait = true;
    bool fFirstEvent = true;

    // We might be here b/c we've done some EnCs, but we also may have pitched some code, so don't overwrite this until
    // we're sure we've got a good replacement.
    unsigned int argumentCount = 0;
    unsigned int nativeInfoCount = 0;
    unsigned int nativeInfoCountTotal = 0;
    ICorJitInfo::NativeVarInfo *nativeInfo = NULL;
    
    CORDBSyncFromWin32StopIfStopped(GetProcess());

    INPROC_LOCK();

    // We've got a remote address that points to the EEClass.  We need to send to the left side to get real information
    // about the class, including its instance and static variables.
    CordbProcess *pProcess = GetProcess();

    DebuggerIPCEvent event;
    pProcess->InitIPCEvent(&event, DB_IPCE_GET_JIT_INFO, false, (void *)(GetAppDomain()->m_id));
    event.GetJITInfo.funcMetadataToken = m_token;
    event.GetJITInfo.funcDebuggerModuleToken = m_module->m_debuggerModuleToken;
    _ASSERTE(m_module->m_debuggerModuleToken != NULL);

    hr = pProcess->m_cordb->SendIPCEvent(pProcess, &event, sizeof(DebuggerIPCEvent));

    // Stop now if we can't even send the event.
    if (!SUCCEEDED(hr))
        goto exit;

    // Wait for events to return from the RC. We expect at least one jit info result event.
    retEvent = (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);
    
    while (wait)
    {
        unsigned int currentInfoCount = 0;
        
#ifdef RIGHT_SIDE_ONLY
        hr = pProcess->m_cordb->WaitForIPCEventFromProcess(pProcess, GetAppDomain(), retEvent);
#else 
        if (fFirstEvent)
        {
            hr = pProcess->m_cordb->GetFirstContinuationEvent(pProcess,retEvent);
            fFirstEvent = false;
        }
        else
        {
            hr = pProcess->m_cordb->GetNextContinuationEvent(pProcess,retEvent);
        }
#endif //RIGHT_SIDE_ONLY
        
        if (!SUCCEEDED(hr))
            goto exit;
        
        _ASSERTE(retEvent->type == DB_IPCE_GET_JIT_INFO_RESULT);

        // If this is the first event back from the RC, then create the array to hold the data.
        if ((retEvent->GetJITInfoResult.totalNativeInfos > 0) && (nativeInfo == NULL))
        {
            argumentCount = retEvent->GetJITInfoResult.argumentCount;
            nativeInfoCountTotal = retEvent->GetJITInfoResult.totalNativeInfos;

            nativeInfo = new ICorJitInfo::NativeVarInfo[nativeInfoCountTotal];

            if (nativeInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }

        ICorJitInfo::NativeVarInfo *currentNativeInfo = &(retEvent->GetJITInfoResult.nativeInfo);

        while (currentInfoCount++ < retEvent->GetJITInfoResult.nativeInfoCount)
        {
            nativeInfo[nativeInfoCount] = *currentNativeInfo;
            
            currentNativeInfo++;
            nativeInfoCount++;
        }

        if (nativeInfoCount >= nativeInfoCountTotal)
            wait = false;
    }

    if (m_nativeInfo != NULL)
    {
        delete [] m_nativeInfo;
        m_nativeInfo = NULL;
    }
    
    m_nativeInfo = nativeInfo;
    m_argumentCount = argumentCount;
    m_nativeInfoCount = nativeInfoCount;
    m_nativeInfoValid = true;
    
    m_nVersionLastNativeInfo = retEvent->GetJITInfoResult.nVersion;
    
exit:

#ifndef RIGHT_SIDE_ONLY    
    GetProcess()->ClearContinuationEvents();
#endif    

    INPROC_UNLOCK();

    return hr;
}

//
// Given an IL local variable number and a native IP offset, return the
// location of the variable in jitted code.
//
HRESULT CordbFunction::ILVariableToNative(DWORD dwIndex,
                                          SIZE_T ip,
                                          ICorJitInfo::NativeVarInfo **ppNativeInfo)
{
    _ASSERTE(m_nativeInfoValid);
    
    return FindNativeInfoInILVariableArray(dwIndex,
                                           ip,
                                           ppNativeInfo,
                                           m_nativeInfoCount,
                                           m_nativeInfo);
}

HRESULT CordbFunction::LoadSig( void )
{
    HRESULT hr = S_OK;

    INPROC_LOCK();

    if (m_methodSig == NULL)
    {
        DWORD methodAttr = 0;
        ULONG sigBlobSize = 0;
        
        hr = GetModule()->m_pIMImport->GetMethodProps(
                               m_token, NULL, NULL, 0, NULL,            
                               &methodAttr, &m_methodSig, &sigBlobSize,     
                               NULL, NULL);

        if (FAILED(hr))
            goto exit;
        
        // Run past the calling convetion, then get the
        // arg count, and return type   
        ULONG cb = 0;
        cb += _skipMethodSignatureHeader(m_methodSig, &m_argCount);

        m_methodSig = &m_methodSig[cb];
        m_methodSigSize = sigBlobSize - cb;

        // If this function is not static, then we've got one extra arg.
        m_isStatic = (methodAttr & mdStatic) != 0;

        if (!m_isStatic)
            m_argCount++;
    }

exit:
    INPROC_UNLOCK();

    return hr;
}

//
// Figures out if an EnC has happened since the last time we were updated, and
// if so, updates all the fields of this CordbFunction so that everything
// is up-to-date.
//
// @todo update for InProc, as well.
HRESULT CordbFunction::UpdateToMostRecentEnCVersion(void)
{
    HRESULT hr = S_OK;

#ifdef RIGHT_SIDE_ONLY
    if (m_isNativeImpl)
        m_encCounterLastSynch = m_module->GetProcess()->m_EnCCounter;

    if (m_encCounterLastSynch < m_module->GetProcess()->m_EnCCounter)
    {
        hr = Populate(DJI_VERSION_MOST_RECENTLY_EnCED);

        if (FAILED(hr) && hr != CORDBG_E_FUNCTION_NOT_IL)
            return hr;

        // These 'signatures' are actually sub-signatures whose memory is owned
        // by someone else.  We don't delete them in the Dtor, so don't 
        // delete them here, either.
        // Get rid of these so that Load(LocalVar)Sig will re-get them.
        m_methodSig = NULL;
        m_localsSig = NULL;
        
        hr = LoadSig();
        if (FAILED(hr))
            return hr;

        if (!m_isNativeImpl)
        {
            hr = LoadLocalVarSig();
            if (FAILED(hr))
                return hr;
        }

        m_encCounterLastSynch = m_module->GetProcess()->m_EnCCounter;
    }
#endif

    return hr;
}

//
// Given an IL argument number, return its type.
//
HRESULT CordbFunction::GetArgumentType(DWORD dwIndex,
                                       ULONG *pcbSigBlob,
                                       PCCOR_SIGNATURE *ppvSigBlob)
{
    HRESULT hr = S_OK;
    ULONG cb;

    // Load the method's signature if necessary.
    if (m_methodSig == NULL)
    {
        hr = LoadSig();
        if( !SUCCEEDED( hr ) )
            return hr;
    }

    // Check the index
    if (dwIndex >= m_argCount)
        return E_INVALIDARG;

    if (!m_isStatic)
        if (dwIndex == 0)
        {
            // Return the signature for the 'this' pointer for the
            // class this method is in.
            return m_class->GetThisSignature(pcbSigBlob, ppvSigBlob);
        }
        else
            dwIndex--;
    
    cb = 0;
    
    // Run the signature and find the required argument.
    for (unsigned int i = 0; i < dwIndex; i++)
        cb += _skipTypeInSignature(&m_methodSig[cb]);

    //Get rid of funky modifiers
    cb += _skipFunkyModifiersInSignature(&m_methodSig[cb]);

    *pcbSigBlob = m_methodSigSize - cb;
    *ppvSigBlob = &(m_methodSig[cb]);
    
    return hr;
}

//
// Set the info needed to build a local var signature for this function.
//
void CordbFunction::SetLocalVarToken(mdSignature localVarSigToken)
{
    m_localVarSigToken = localVarSigToken;
}


//@TODO remove this after removing the IMetaDataHelper* hack below
#include "corpriv.h"

//
// LoadLocalVarSig loads the local variable signature from the token
// passed over from the Left Side.
//
HRESULT CordbFunction::LoadLocalVarSig(void)
{
    HRESULT hr = S_OK;
    
    INPROC_LOCK();

    if ((m_localsSig == NULL) && (m_localVarSigToken != mdSignatureNil))
    {
        hr = GetModule()->m_pIMImport->GetSigFromToken(m_localVarSigToken,
                                                       &m_localsSig,
                                                       &m_localsSigSize);

        if (FAILED(hr))
            goto Exit;

        _ASSERTE(*m_localsSig == IMAGE_CEE_CS_CALLCONV_LOCAL_SIG);
        m_localsSig++;
        --m_localsSigSize;

        // Snagg the count of locals in the sig.
        m_localVarCount = CorSigUncompressData(m_localsSig);
    }

Exit:
    INPROC_UNLOCK();
    
    return hr;
}

//
// Given an IL variable number, return its type.
//
HRESULT CordbFunction::GetLocalVariableType(DWORD dwIndex,
                                            ULONG *pcbSigBlob,
                                            PCCOR_SIGNATURE *ppvSigBlob)
{
    HRESULT hr = S_OK;
    ULONG cb;

    // Load the method's signature if necessary.
    if (m_localsSig == NULL)
    {
        hr = Populate(DJI_VERSION_MOST_RECENTLY_JITTED);

        if (FAILED(hr))
            return hr;
        
        hr = LoadLocalVarSig();

        if (FAILED(hr))
            return hr;
    }

    // Check the index
    if (dwIndex >= m_localVarCount)
        return E_INVALIDARG;

    cb = 0;
    
    // Run the signature and find the required argument.
    for (unsigned int i = 0; i < dwIndex; i++)
        cb += _skipTypeInSignature(&m_localsSig[cb]);

    //Get rid of funky modifiers
    cb += _skipFunkyModifiersInSignature(&m_localsSig[cb]);

    *pcbSigBlob = m_localsSigSize - cb;
    *ppvSigBlob = &(m_localsSig[cb]);
    
    return hr;
}

/* ------------------------------------------------------------------------- *
 * Code class
 * ------------------------------------------------------------------------- */

CordbCode::CordbCode(CordbFunction *m, BOOL isIL, REMOTE_PTR startAddress,
                     SIZE_T size, SIZE_T nVersion, void *CodeVersionToken,
                     REMOTE_PTR ilToNativeMapAddr, SIZE_T ilToNativeMapSize)
  : CordbBase(0, enumCordbCode), m_function(m), m_isIL(isIL), 
    m_address(startAddress), m_size(size), m_nVersion(nVersion),
    m_CodeVersionToken(CodeVersionToken),
    m_ilToNativeMapAddr(ilToNativeMapAddr),
    m_ilToNativeMapSize(ilToNativeMapSize),
    m_rgbCode(NULL),
    m_continueCounterLastSync(0)
{
}

CordbCode::~CordbCode()
{
    if (m_rgbCode != NULL)
        delete [] m_rgbCode;
}

// Neutered by CordbFunction
void CordbCode::Neuter()
{
    AddRef();
    {
        CordbBase::Neuter();
    }
    Release();
}

HRESULT CordbCode::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugCode)
        *pInterface = (ICorDebugCode*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugCode*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbCode::IsIL(BOOL *pbIL)
{
    VALIDATE_POINTER_TO_OBJECT(pbIL, BOOL *);
    
    *pbIL = m_isIL;

    return S_OK;
}


HRESULT CordbCode::GetFunction(ICorDebugFunction **ppFunction)
{
    VALIDATE_POINTER_TO_OBJECT(ppFunction, ICorDebugFunction **);
    
    *ppFunction = (ICorDebugFunction*) m_function;
    (*ppFunction)->AddRef();

    return S_OK;
}

HRESULT CordbCode::GetAddress(CORDB_ADDRESS *pStart)
{
    VALIDATE_POINTER_TO_OBJECT(pStart, CORDB_ADDRESS *);
    
    // Native can be pitched, and so we have to actually
    // grab the address from the left side, whereas the
    // IL code address doesn't change.
    if (m_isIL )
    {
        *pStart = PTR_TO_CORDB_ADDRESS(m_address);
    }
    else
    {
        // Undone: The following assert is no longer
        // valid. AtulC
//      _ASSERTE(m_address != NULL);

        _ASSERTE( this != NULL );
        _ASSERTE( this->m_function != NULL );
        _ASSERTE( this->m_function->m_module != NULL );
        _ASSERTE( this->m_function->m_module->m_process != NULL );

        if (m_address != NULL)
        {
            DWORD dwRead = 0;
            if ( 0 == ReadProcessMemoryI( m_function->m_module->m_process->m_handle,
                    m_address, pStart, sizeof(CORDB_ADDRESS),&dwRead))
            {
                *pStart = NULL;
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }

        // If the address was zero'd out on the left side, then
        // the code has been pitched & isn't available.
        if ((*pStart == NULL) || (m_address == NULL))
        {
            return CORDBG_E_CODE_NOT_AVAILABLE;
        }
    }
    return S_OK;
}

HRESULT CordbCode::GetSize(ULONG32 *pcBytes)
{
    VALIDATE_POINTER_TO_OBJECT(pcBytes, ULONG32 *);
    
    *pcBytes = m_size;
    return S_OK;
}

HRESULT CordbCode::CreateBreakpoint(ULONG32 offset, 
                                    ICorDebugFunctionBreakpoint **ppBreakpoint)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppBreakpoint, ICorDebugFunctionBreakpoint **);
    
    CordbFunctionBreakpoint *bp = new CordbFunctionBreakpoint(this, offset);

    if (bp == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = bp->Activate(TRUE);
    if (SUCCEEDED(hr))
    {
        *ppBreakpoint = (ICorDebugFunctionBreakpoint*) bp;
        bp->AddRef();
        return S_OK;
    }
    else
    {
        delete bp;
        return hr;
    }
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbCode::GetCode(ULONG32 startOffset, 
                           ULONG32 endOffset,
                           ULONG32 cBufferAlloc,
                           BYTE buffer[],
                           ULONG32 *pcBufferSize)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(buffer, BYTE, cBufferAlloc, true, true);
    VALIDATE_POINTER_TO_OBJECT(pcBufferSize, ULONG32 *);
    
    LOG((LF_CORDB,LL_EVERYTHING, "CC::GC: for token:0x%x\n", m_function->m_token));

    CORDBSyncFromWin32StopIfStopped(GetProcess());
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    
    INPROC_LOCK();

    HRESULT hr = S_OK;
    *pcBufferSize = 0;

    //
    // Check ranges.
    //

    if (cBufferAlloc < endOffset - startOffset)
        endOffset = startOffset + cBufferAlloc;

    if (endOffset > m_size)
        endOffset = m_size;

    if (startOffset > m_size)
        startOffset = m_size;

    if (m_rgbCode == NULL || 
        m_continueCounterLastSync < GetProcess()->m_continueCounter)
    {
        BYTE *rgbCodeOrCodeSnippet;
        ULONG32 start;
        ULONG32 end;
        ULONG cAlloc;

        if (m_continueCounterLastSync < GetProcess()->m_continueCounter &&
            m_rgbCode != NULL )
        {
            delete [] m_rgbCode;
        }
        
        m_rgbCode = new BYTE[m_size];
        if (m_rgbCode == NULL)
        {
            rgbCodeOrCodeSnippet = buffer;
            start = startOffset;
            end = endOffset;
            cAlloc = cBufferAlloc;
        }
        else
        {
            rgbCodeOrCodeSnippet = m_rgbCode;
            start = 0;
            end = m_size;
            cAlloc = m_size;
        }

        DebuggerIPCEvent *event = 
          (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);

        //
        // Send event to get code.
        // !!! This assumes that we're currently synchronized.  
        //
        GetProcess()->InitIPCEvent(event,
                                   DB_IPCE_GET_CODE, 
                                   false,
                                   (void *)(GetAppDomain()->m_id));
        event->GetCodeData.funcMetadataToken = m_function->m_token;
        event->GetCodeData.funcDebuggerModuleToken =
            m_function->m_module->m_debuggerModuleToken;
        event->GetCodeData.il = m_isIL != 0;
        event->GetCodeData.start = start;
        event->GetCodeData.end = end;
        event->GetCodeData.CodeVersionToken = m_CodeVersionToken;

        hr = GetProcess()->SendIPCEvent(event, CorDBIPC_BUFFER_SIZE);

        if FAILED(hr)
            goto LExit;

        //
        // Keep getting result events until we get the last bit of code.
        //
        bool fFirstLoop = true;
        do
        {
#ifdef RIGHT_SIDE_ONLY

            hr = GetProcess()->m_cordb->WaitForIPCEventFromProcess(
                    GetProcess(), 
                    GetAppDomain(), 
                    event);
            
#else

            if (fFirstLoop)
            {
                hr = GetProcess()->m_cordb->GetFirstContinuationEvent(
                        GetProcess(), 
                        event);
                fFirstLoop = false;
            }
            else
            {
                hr = GetProcess()->m_cordb->GetNextContinuationEvent(
                        GetProcess(), 
                        event);
            }
            
#endif //RIGHT_SIDE_ONLY
            if(FAILED(hr))
                goto LExit;


            _ASSERTE(event->type == DB_IPCE_GET_CODE_RESULT);

            memcpy(rgbCodeOrCodeSnippet + event->GetCodeData.start - start, 
                   &event->GetCodeData.code, 
                   event->GetCodeData.end - event->GetCodeData.start);

        } while (event->GetCodeData.end < end);

        // We sluiced the code into the caller's buffer, so tell the caller
        // how much space is used.
        if (rgbCodeOrCodeSnippet == buffer)
            *pcBufferSize = endOffset - startOffset;
        
        m_continueCounterLastSync = GetProcess()->m_continueCounter;
    }

    // if we just got the code, we'll have to copy it over
    if (*pcBufferSize == 0 && m_rgbCode != NULL)
    {
        memcpy(buffer, 
               m_rgbCode+startOffset, 
               endOffset - startOffset);
        *pcBufferSize = endOffset - startOffset;
    }

LExit:

#ifndef RIGHT_SIDE_ONLY    
    GetProcess()->ClearContinuationEvents();
#endif    

    INPROC_UNLOCK();

    return hr;
}

#include "DbgIPCEvents.h"
HRESULT CordbCode::GetVersionNumber( ULONG32 *nVersion)
{
    VALIDATE_POINTER_TO_OBJECT(nVersion, ULONG32 *);
    
    LOG((LF_CORDB,LL_INFO10000,"R:CC:GVN:Returning 0x%x "
        "as version\n",m_nVersion));
    
    *nVersion = INTERNAL_TO_EXTERNAL_VERSION(m_nVersion);
    _ASSERTE((*nVersion) >= USER_VISIBLE_FIRST_VALID_VERSION_NUMBER);
    return S_OK;
}

HRESULT CordbCode::GetILToNativeMapping(ULONG32 cMap,
                                        ULONG32 *pcMap,
                                        COR_DEBUG_IL_TO_NATIVE_MAP map[])
{
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pcMap, ULONG32 *);
    VALIDATE_POINTER_TO_OBJECT_ARRAY_OR_NULL(map, COR_DEBUG_IL_TO_NATIVE_MAP *,cMap,true,true);

    // Gotta have a map address to return a map.
    if (m_ilToNativeMapAddr == NULL)
        return CORDBG_E_NON_NATIVE_FRAME;
    
    HRESULT hr = S_OK;
    DebuggerILToNativeMap *mapInt = NULL;

    mapInt = new DebuggerILToNativeMap[cMap];
    
    if (mapInt == NULL)
        return E_OUTOFMEMORY;
    
    // If they gave us space to copy into...
    if (map != NULL)
    {
        // Only copy as much as either they gave us or we have to copy.
        SIZE_T cnt = min(cMap, m_ilToNativeMapSize);

        if (cnt > 0)
        {
            // Read the map right out of the Left Side.
            BOOL succ = ReadProcessMemory(GetProcess()->m_handle,
                                          m_ilToNativeMapAddr,
                                          mapInt,
                                          cnt *
                                          sizeof(DebuggerILToNativeMap),
                                          NULL);

            if (!succ)
                hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // Remember that we need to translate between our internal DebuggerILToNativeMap and the external
        // COR_DEBUG_IL_TO_NATIVE_MAP!
        if (SUCCEEDED(hr))
            ExportILToNativeMap(cMap, map, mapInt, m_size);
    }
    
    if (pcMap)
        *pcMap = m_ilToNativeMapSize;

    if (mapInt != NULL)
        delete [] mapInt;

    return hr;
}

HRESULT CordbCode::GetEnCRemapSequencePoints(ULONG32 cMap, ULONG32 *pcMap, ULONG32 offsets[])
{
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pcMap, ULONG32*);
    VALIDATE_POINTER_TO_OBJECT_ARRAY_OR_NULL(offsets, ULONG32*, cMap, true, true);

    // Gotta have a map address to return a map.
    if (m_ilToNativeMapAddr == NULL)
        return CORDBG_E_NON_NATIVE_FRAME;
    
    _ASSERTE(m_ilToNativeMapSize > 0);
    
    HRESULT hr = S_OK;
    DebuggerILToNativeMap *mapInt = NULL;

    // We need space for the entire map from the Left Side. We really should be caching this...
    mapInt = new DebuggerILToNativeMap[m_ilToNativeMapSize];
    
    if (mapInt == NULL)
        return E_OUTOFMEMORY;
    
    // Read the map right out of the Left Side.
    BOOL succ = ReadProcessMemory(GetProcess()->m_handle,
                                  m_ilToNativeMapAddr,
                                  mapInt,
                                  m_ilToNativeMapSize * sizeof(DebuggerILToNativeMap),
                                  NULL);

    if (!succ)
        hr = HRESULT_FROM_WIN32(GetLastError());

    // We'll count up how many entries there are as we go.
    ULONG32 cnt = 0;
            
    if (SUCCEEDED(hr))
    {
        for (ULONG32 iMap = 0; iMap < m_ilToNativeMapSize; iMap++)
        {
            SIZE_T offset = mapInt[iMap].ilOffset;
            ICorDebugInfo::SourceTypes src = mapInt[iMap].source;

            // We only set EnC remap breakpoints at valid, stack empty IL offsets.
            if ((offset != ICorDebugInfo::MappingTypes::PROLOG) &&
                (offset != ICorDebugInfo::MappingTypes::EPILOG) &&
                (offset != ICorDebugInfo::MappingTypes::NO_MAPPING) &&
                (src & ICorDebugInfo::STACK_EMPTY))
            {
                // If they gave us space to copy into...
                if ((offsets != NULL) && (cnt < cMap))
                    offsets[cnt] = offset;

                // We've got another one, so count it.
                cnt++;
            }
        }
    }
    
    if (pcMap)
        *pcMap = cnt;

    if (mapInt != NULL)
        delete [] mapInt;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\rsthread.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: thread.cpp
//
//*****************************************************************************
#include "stdafx.h"

#ifdef UNDEFINE_RIGHT_SIDE_ONLY
#undef RIGHT_SIDE_ONLY
#endif //UNDEFINE_RIGHT_SIDE_ONLY

//
// Global partial signature for any object. The address of this is
// passed into CreateValueByType as the signature for an exception
// object. (Note: we don't need a specific typedef for the exception,
// since knowing that its an object is enough.)
//
static CorElementType g_elementTypeClass = ELEMENT_TYPE_CLASS;

/* ------------------------------------------------------------------------- *
 * Managed Thread classes
 * ------------------------------------------------------------------------- */

CordbThread::CordbThread(CordbProcess *process, DWORD id, HANDLE handle)
  : CordbBase(id, enumCordbThread), m_process(process), m_handle(handle),
    m_pContext(NULL),m_contextFresh(false), m_pvLeftSideContext(NULL),
    m_debuggerThreadToken(NULL),
    m_stackBase(NULL),
    m_stackLimit(NULL),
//  m_frozen(false), 
    m_debugState(THREAD_RUN),
//  m_special(false), 
    m_framesFresh(false),
    m_stackFrames(NULL), m_stackFrameCount(0),
    m_stackChains(NULL), m_stackChainCount(0), m_stackChainAlloc(0),
    m_floatStateValid(false), m_floatStackTop(0),
    m_thrown(NULL), m_exception(false),
    // Log message stuff
    m_pstrLogSwitch(NULL),
    m_pstrLogMsg(NULL),
    m_iLogMsgIndex(0),
    m_iTotalCatLength(0),
    m_iTotalMsgLength(0),
    m_fLogMsgContinued(FALSE),
    m_detached(false)
#ifndef RIGHT_SIDE_ONLY
    , m_pModuleSpecial(NULL)
    , m_pAssemblySpecial(NULL)
    , m_pAssemblySpecialAlloc(1)
    , m_pAssemblySpecialCount(0)
    , m_dwSuspendVersion(0)
    , m_fThreadInprocIsActive(FALSE)
#endif //RIGHT_SIDE_ONLY
{
#if _DEBUG
    for (unsigned int i = 0;
         i < (sizeof(m_floatValues) / sizeof(m_floatValues[0]));
         i++)
        m_floatValues[i] = 0;
#endif    
}

/*
    A list of which resources owened by this object are accounted for.

    UNKNOWN:
        void                 *m_pvLeftSideContext;  
        void*                 m_debuggerThreadToken; 
        void*                 m_stackBase; 
        void*                 m_stackLimit; 
        CorDebugThreadState   m_debugState; 
        CorDebugUserState     m_userState;  
        void                 *m_thrown;
        WCHAR                *m_pstrLogSwitch;
        WCHAR                *m_pstrLogMsg; 
        Module               *m_pModuleSpecial; 
        
    HANDLED:
        HANDLE                m_handle; // Closed in ~CordbThread()
        CONTEXT              *m_pContext; // Deleted in ~CordbThread()
        CordbProcess         *m_process; // This pointer created w/o AddRef() DBUG(chrisk)
        CordbAppDomain       *m_pAppDomain; // This pointer created w/o AddRef() DBUG(chrisk)
        CordbNativeFrame    **m_stackFrames; // CleanupStack in ~CordbThread()
        CordbChain          **m_stackChains; // CleanupStack in ~CordbThread()
        void                 *m_firstExceptionHandler; //left-side pointer - fs:[0] on x86
        union  {     
            Assembly        **m_pAssemblySpecialStack; // Deleted in ~CordbThread()
            Assembly         *m_pAssemblySpecial;
        };
*/

CordbThread::~CordbThread()
{
    CleanupStack();

    if (m_stackFrames != NULL)
        delete [] m_stackFrames;
        
    if (m_stackChains != NULL)
        delete [] m_stackChains;

#ifdef RIGHT_SIDE_ONLY
    // For IPD, we get the handle from Thread::GetHandle, which
    // doesn't increment the OS count on these things.  By this
    // time, the thread is probably dead, so we'll barf if we try
    // and close it's handle again.
    if (m_handle != NULL)
        CloseHandle(m_handle);
#endif //RIGHT_SIDE_ONLY

    if( m_pContext != NULL )
        delete [] m_pContext;

#ifndef RIGHT_SIDE_ONLY
    if (m_pAssemblySpecialAlloc > 1)
        delete [] m_pAssemblySpecialStack;
#endif

}

// Neutered by the CordbProcess
void CordbThread::Neuter()
{
    AddRef();
    {
        CordbBase::Neuter();
    }
    Release();    
}

HRESULT CordbThread::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugThread)
        *pInterface = (ICorDebugThread*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugThread*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbThread::GetProcess(ICorDebugProcess **ppProcess)
{
    VALIDATE_POINTER_TO_OBJECT(ppProcess, ICorDebugProcess **);
    
    *ppProcess = m_process;
    (*ppProcess)->AddRef();

    return S_OK;
}

HRESULT CordbThread::GetID(DWORD *pdwThreadId)
{
    VALIDATE_POINTER_TO_OBJECT(pdwThreadId, DWORD *);

    *pdwThreadId = m_id;

    return S_OK;
}

HRESULT CordbThread::GetHandle(void** phThreadHandle)
{
    VALIDATE_POINTER_TO_OBJECT(phThreadHandle, void**);
    
    *phThreadHandle = (void*) m_handle;

    return S_OK;
}

HRESULT CordbThread::SetDebugState(CorDebugThreadState state)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    CORDBLeftSideDeadIsOkay(GetProcess());
    CORDBSyncFromWin32StopIfNecessary(GetProcess());
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());

    LOG((LF_CORDB, LL_INFO1000, "CT::SDS: thread=0x%08x 0x%x, state=%d\n", this, m_id, state));

    DebuggerIPCEvent event;
    GetProcess()->InitIPCEvent(&event, 
                               DB_IPCE_SET_DEBUG_STATE, 
                               true,
                               (void *)(GetAppDomain()->m_id));
    event.SetDebugState.debuggerThreadToken = m_debuggerThreadToken;
    event.SetDebugState.debugState = state;

    HRESULT hr = GetProcess()->SendIPCEvent(&event, sizeof(DebuggerIPCEvent));

    if (SUCCEEDED(hr))
        m_debugState = event.SetDebugState.debugState;

    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbThread::GetDebugState(CorDebugThreadState *pState)
{
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    
    VALIDATE_POINTER_TO_OBJECT(pState, CorDebugThreadState *);
    
    (*pState) = m_debugState;
    
    return S_OK;;
}

HRESULT CordbThread::GetUserState(CorDebugUserState *pState)
{
    VALIDATE_POINTER_TO_OBJECT(pState, CorDebugUserState *);
    
    HRESULT hr = RefreshStack();
    if (FAILED(hr))
        return hr;

    *pState = m_userState;
    
    return S_OK;
}

HRESULT CordbThread::GetCurrentException(ICorDebugValue **ppExceptionObject)
{
    INPROC_LOCK();

    HRESULT hr = E_FAIL;

#ifndef RIGHT_SIDE_ONLY
    _ASSERTE(m_debuggerThreadToken != NULL);
    Thread *pThread = (Thread *)m_debuggerThreadToken;

    if (pThread->GetThrowable() == NULL)
        goto Exit;
#else
    if (!m_exception)
        goto Exit;

    _ASSERTE(m_thrown != NULL);
#endif //RIGHT_SIDE_ONLY    

    VALIDATE_POINTER_TO_OBJECT(ppExceptionObject, ICorDebugValue **);

    // We need a module to create the value in. The module only
    // technically matters for value classes, since the signature
    // would contain a token that we would need to resolve. However,
    // exceptions can't be value classes at this time, so this isn't a
    // problem. Note: if exceptions should one day be able to be value
    // classes, then all we need to do is pass back the class token
    // and module from the Left Side along with the exception's
    // address. For now, we simply use any module out of the process.
    CordbModule *module = GetAppDomain()->GetAnyModule();

    if (module == NULL)
        goto Exit;
    
    hr = CordbValue::CreateValueByType(  GetAppDomain(),
                                         module,
                                         sizeof(g_elementTypeClass),
                                         (PCCOR_SIGNATURE) &g_elementTypeClass,
                                         NULL,
#ifndef RIGHT_SIDE_ONLY
                                         (REMOTE_PTR) pThread->GetThrowableAsHandle(),
#else
                                         m_thrown,
#endif
                                         NULL,
                                         true,
                                         NULL,
                                         NULL,
                                         ppExceptionObject);

Exit:
    INPROC_UNLOCK();

    return (hr);
}

HRESULT CordbThread::ClearCurrentException()
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    CORDBLeftSideDeadIsOkay(GetProcess());
    CORDBSyncFromWin32StopIfNecessary(GetProcess());
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());

    if (!m_exception)
        return E_FAIL;
    
    if (!m_continuable) 
        return CORDBG_E_NONCONTINUABLE_EXCEPTION;

    DebuggerIPCEvent event;
    GetProcess()->InitIPCEvent(&event, 
                               DB_IPCE_CONTINUE_EXCEPTION, 
                               false,
                               (void *)(GetAppDomain()->m_id));
    event.ClearException.debuggerThreadToken = m_debuggerThreadToken;

    HRESULT hr = GetProcess()->SendIPCEvent(&event,
                                            sizeof(DebuggerIPCEvent));

    if (SUCCEEDED(hr))
        m_exception = false;

    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbThread::CreateStepper(ICorDebugStepper **ppStepper)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    CORDBSyncFromWin32StopIfNecessary(GetProcess());
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
    VALIDATE_POINTER_TO_OBJECT(ppStepper, ICorDebugStepper **);

    CordbStepper *stepper = new CordbStepper(this, NULL);

    if (stepper == NULL)
        return E_OUTOFMEMORY;

    stepper->AddRef();
    *ppStepper = stepper;

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbThread::EnumerateChains(ICorDebugChainEnum **ppChains)
{
#ifndef RIGHT_SIDE_ONLY
#ifdef PROFILING_SUPPORTED
    // Need to check that this thread is in a valid state for in-process debugging.
    if (!CHECK_INPROC_THREAD_STATE())
        return (CORPROF_E_INPROC_NOT_ENABLED);
#endif // PROFILING_SUPPORTED
#endif // RIGHT_SIDE_ONLY
    
    HRESULT hr = S_OK;

    VALIDATE_POINTER_TO_OBJECT(ppChains, ICorDebugChainEnum **);
    *ppChains = NULL;

    CORDBSyncFromWin32StopIfNecessary(GetProcess());
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    CordbChainEnum *e = NULL;
    INPROC_LOCK();

    //
    // Refresh the stack frames for this thread.
    //
    hr = RefreshStack();

    if (FAILED(hr))
        goto LExit;

    //
    // Create and return a chain enumerator.
    //
    e = new CordbChainEnum(this);

    if (e != NULL)
    {
        *ppChains = (ICorDebugChainEnum*)e;
        e->AddRef();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        CleanupStack();
    }

LExit:
    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbThread::GetActiveChain(ICorDebugChain **ppChain)
{
#ifndef RIGHT_SIDE_ONLY
#ifdef PROFILING_SUPPORTED
    // Need to check that this thread is in a valid state for in-process debugging.
    if (!CHECK_INPROC_THREAD_STATE())
        return (CORPROF_E_INPROC_NOT_ENABLED);
#endif // PROFILING_SUPPORTED
#endif // RIGHT_SIDE_ONLY
    
    HRESULT hr = S_OK;

    VALIDATE_POINTER_TO_OBJECT(ppChain, ICorDebugChain **);

    CORDBSyncFromWin32StopIfNecessary(GetProcess());
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    INPROC_LOCK();

    //
    // Refresh the stack frames for this thread.
    //
    hr = RefreshStack();

    if (FAILED(hr))
        goto LExit;

#ifndef RIGHT_SIDE_ONLY
    if (m_stackChains == NULL)
    {
        hr = E_FAIL;
        goto LExit;
    }
#endif //RIGHT_SIDE_ONLY

    if (m_stackChainCount == 0)
        *ppChain = NULL;
    else
    {
        _ASSERTE(m_stackChains != NULL);
        
        (*ppChain) = (ICorDebugChain *)m_stackChains[0];
        (*ppChain)->AddRef();
    }

LExit:
    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbThread::GetActiveFrame(ICorDebugFrame **ppFrame)
{
#ifndef RIGHT_SIDE_ONLY
#ifdef PROFILING_SUPPORTED
    // Need to check that this thread is in a valid state for in-process debugging.
    if (!CHECK_INPROC_THREAD_STATE())
        return (CORPROF_E_INPROC_NOT_ENABLED);
#endif // PROFILING_SUPPORTED
#endif // RIGHT_SIDE_ONLY
    
    VALIDATE_POINTER_TO_OBJECT(ppFrame, ICorDebugFrame **);

    (*ppFrame) = NULL;

    CORDBSyncFromWin32StopIfNecessary(GetProcess());
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    HRESULT hr = S_OK;
    INPROC_LOCK();

    //
    // Refresh the stack frames for this thread.
    //
    hr = RefreshStack();

    if (FAILED(hr))
        goto LExit;

    if (m_stackFrameCount == 0 || m_stackFrames == NULL || m_stackFrames[0]->m_chain != m_stackChains[0])
    {
        *ppFrame = NULL;
    }
    else
    {
        (*ppFrame) = (ICorDebugFrame*)(CordbFrame*)m_stackFrames[0];
        (*ppFrame)->AddRef();
    }

LExit:    
    INPROC_UNLOCK();
    return hr;
}

HRESULT CordbThread::GetRegisterSet(ICorDebugRegisterSet **ppRegisters)
{
#ifndef RIGHT_SIDE_ONLY
#ifdef PROFILING_SUPPORTED
    // Need to check that this thread is in a valid state for in-process debugging.
    if (!CHECK_INPROC_THREAD_STATE())
        return (CORPROF_E_INPROC_NOT_ENABLED);
#endif // PROFILING_SUPPORTED
#endif // RIGHT_SIDE_ONLY
    
    VALIDATE_POINTER_TO_OBJECT(ppRegisters, ICorDebugRegisterSet **);

    INPROC_LOCK();

    HRESULT hr = S_OK;
    
    //
    // Refresh the stack frames for this thread.
    //
    hr = RefreshStack();

    if (FAILED(hr))
        goto LExit;

#ifdef RIGHT_SIDE_ONLY
    _ASSERTE( m_stackChains != NULL );
    _ASSERTE( m_stackChains[0] != NULL );
#else
    if (m_stackChains ==NULL ||
        m_stackChains[0] == NULL)
    {        
        hr = E_FAIL;
        goto LExit;
    }
#endif // RIGHT_SIDE_ONLY    

    hr = m_stackChains[0]->GetRegisterSet( ppRegisters );


LExit:
    INPROC_UNLOCK();
    return hr;
}

HRESULT CordbThread::CreateEval(ICorDebugEval **ppEval)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppEval, ICorDebugEval **);

    CordbEval *eval = new CordbEval(this);

    if (eval == NULL)
        return E_OUTOFMEMORY;

    eval->AddRef();
    *ppEval = (ICorDebugEval*)eval;
    
    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbThread::RefreshStack(void)
{
    HRESULT hr = S_OK;
    unsigned int totalTraceCount = 0;
    unsigned int inProgressFrameCount = 0; //so we can CleanupStack w/o bombing
    unsigned int inProgressChainCount = 0; //so we can CleanupStack w/o bombing
    bool wait = true;

    CordbNativeFrame **f = NULL;
    CordbChain **c, *chain;
    CordbCode* pCode = NULL;


#ifdef RIGHT_SIDE_ONLY
    if (m_framesFresh)
        return S_OK;
#else
    _ASSERTE(m_dwSuspendVersion <= g_profControlBlock.dwSuspendVersion);

    // This checks whether or not a refresh is necessary
    if(m_fThreadInprocIsActive ? m_framesFresh : m_dwSuspendVersion == g_profControlBlock.dwSuspendVersion)
        return (S_OK);
#endif //RIGHT_SIDE_ONLY    

    //
    // Clean up old snapshot.
    //
    CleanupStack();

#ifdef RIGHT_SIDE_ONLY
    CORDBLeftSideDeadIsOkay(GetProcess());
#endif //RIGHT_SIDE_ONLY    

    //
    // If we don't have a debugger thread token, then this thread has never
    // executed managed code and we have no frame information for it.
    //
    if (m_debuggerThreadToken == NULL)
        return E_FAIL;

    //
    // Send the stack trace event to the RC.
    //
    DebuggerIPCEvent *event = 
      (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);

    INPROC_LOCK();
    
    m_process->InitIPCEvent(event, 
                            DB_IPCE_STACK_TRACE, 
                            false,
                            (void *)(GetAppDomain()->m_id));
    event->StackTraceData.debuggerThreadToken = m_debuggerThreadToken;

    hr = m_process->m_cordb->SendIPCEvent(m_process, event,
                                          CorDBIPC_BUFFER_SIZE);

    //
    // Stop now if we can't even send the event.
    //
    if (!SUCCEEDED(hr))
        goto exit;

    m_userState = (CorDebugUserState)0;
    LOG((LF_CORDB,LL_INFO1000, "CT::RS:thread:0x%x zeroing out "
        "userThreadState:\n", m_id));
    
    //
    // Wait for events to return from the RC. We expect at least one
    // stack trace result event.
    //
    while (wait)
    {
#ifdef RIGHT_SIDE_ONLY
         hr = m_process->m_cordb->WaitForIPCEventFromProcess(m_process, 
                                                             GetAppDomain(),
                                                             event);
#else 
         if (totalTraceCount == 0)
            hr = m_process->m_cordb->GetFirstContinuationEvent(m_process, event);
         else
            hr= m_process->m_cordb->GetNextContinuationEvent(m_process, event);
#endif //RIGHT_SIDE_ONLY         


        _ASSERTE(SUCCEEDED(hr) || 
                 hr == CORDBG_E_BAD_THREAD_STATE || 
                 !"FAILURE" );
        if (!SUCCEEDED(hr))
            goto exit;
        
        //
        // @todo: assert that the event is from the proper thread and
        // process, too.
        //
        _ASSERTE(event->type == DB_IPCE_STACK_TRACE_RESULT);

        //
        // If this is the first event back from the RC then create the
        // array to hold the frame pointers.
        //
        if (f == NULL)
        {
            m_stackFrameCount =
                event->StackTraceResultData.totalFrameCount;
            f = m_stackFrames = new CordbNativeFrame*[m_stackFrameCount];
            
            if (f == NULL)
            {
                _ASSERTE( !"FAILURE" );
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            memset(f, 0, sizeof(CordbNativeFrame *) * m_stackFrameCount);

            //
            // Build the list of chains.
            //
            // Allocate m_stackChainCount CordbChains here, then go through the
            // individual chains as they arrive.  When a new chain
            // is needed, fix the m_stackEnd field of the last chain
            //

            m_stackChainCount = event->StackTraceResultData.totalChainCount;
            _ASSERTE( m_stackChainCount > 0 );
            
            c = m_stackChains = new CordbChain*[m_stackChainCount];
            if (c == NULL)
            {
                _ASSERTE( !"FAILURE" );
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            memset( c, 0, sizeof(CordbChain*)*m_stackChainCount);
            chain = NULL;

            //
            // Remember our context.
            //

            if (event->StackTraceResultData.pContext != NULL)
                m_pvLeftSideContext = event->StackTraceResultData.pContext;

            // While we're doing once-only work, remember the User state of the
            // thread
            m_userState = event->StackTraceResultData.threadUserState;
            LOG((LF_CORDB,LL_INFO1000, "CT::RS:thread:0x%x userThreadState:0x%x\n",
                m_id, m_userState));
        }

        //
        // Go through each returned frame in the event and build a
        // CordbFrame for it. 
        //
        DebuggerIPCE_STRData* currentSTRData =
            &(event->StackTraceResultData.traceData);

        unsigned int traceCount = 0;

        while (traceCount < event->StackTraceResultData.traceCount)
        {
            if (chain == NULL)
            {
                *c++ = chain = new CordbChain(this, TRUE,
                                              (CordbFrame**)f, NULL, c - m_stackChains);
                if (chain==NULL )
                {
                    _ASSERTE( !"FAILURE" );
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                inProgressChainCount++;

                // One addref for the thread
                chain->AddRef();
            }

            if (currentSTRData->isChain)
            {
                chain->m_end = (CordbFrame **)f;
                chain->m_reason = currentSTRData->chainReason;
                chain->m_managed = currentSTRData->managed;
                chain->m_context = PTR_TO_CORDB_ADDRESS(currentSTRData->context);
                chain->m_rd = currentSTRData->rd;
                chain->m_quicklyUnwound = currentSTRData->quicklyUnwound;
                chain->m_id = (ULONG) currentSTRData->fp;
                
                chain = NULL;
            }
            else
            {
                DebuggerIPCE_FuncData* currentFuncData = &currentSTRData->funcData;

                // Find the CordbModule for this function. Note: this check is actually appdomain independent.
                CordbAppDomain *pAppDomain = GetAppDomain();
                CordbModule* pFunctionModule = pAppDomain->LookupModule(currentFuncData->funcDebuggerModuleToken);
                _ASSERTE(pFunctionModule != NULL);

                // Does this function already exist?
                CordbFunction *pFunction = NULL;
            
                pFunction = pFunctionModule->LookupFunction(currentFuncData->funcMetadataToken);

                if (pFunction == NULL)
                {
                    // New function. Go ahead and create it.
                    hr = pFunctionModule->CreateFunction(currentFuncData->funcMetadataToken,
                                                         currentFuncData->funcRVA,
                                                         &pFunction);

                    _ASSERTE( SUCCEEDED(hr) || !"FAILURE" );
                    if (!SUCCEEDED(hr))
                        goto exit;

                    pFunction->SetLocalVarToken(currentFuncData->localVarSigToken);
                }
            
                _ASSERTE(pFunction != NULL);

                // Does this function have a class?
                if ((pFunction->m_class == NULL) && (currentFuncData->classMetadataToken != mdTypeDefNil))
                {
                    // No. Go ahead and create the class.
                    CordbAppDomain *pAppDomain = GetAppDomain();
                    CordbModule* pClassModule = pAppDomain->LookupModule(currentFuncData->funcDebuggerModuleToken);
                    _ASSERTE(pClassModule != NULL);

                    // Does the class already exist?
                    CordbClass* pClass = pClassModule->LookupClass(currentFuncData->classMetadataToken);

                    if (pClass == NULL)
                    {
                        // New class. Create it now.
                        hr = pClassModule->CreateClass(currentFuncData->classMetadataToken, &pClass);
                        _ASSERTE(SUCCEEDED(hr) || !"FAILURE");

                        if (!SUCCEEDED(hr))
                            goto exit;
                    }
                
                    _ASSERTE(pClass != NULL);
                    pFunction->m_class = pClass;
                }

                if (FAILED(hr = pFunction->GetCodeByVersion(FALSE, bNativeCode, currentFuncData->nativenVersion, &pCode)))
                {
                    _ASSERTE( !"FAILURE" );
                    goto exit;
                }

                if (pCode == NULL)
                {
                    LOG((LF_CORDB,LL_INFO10000,"R:CT::RSCreating code w/ ver:0x%x, token:0x%x\n",
                         currentFuncData->nativenVersion,
                         currentFuncData->CodeVersionToken));

                    hr = pFunction->CreateCode(bNativeCode,
                                               currentFuncData->nativeStartAddressPtr,
                                               currentFuncData->nativeSize,
                                               &pCode, currentFuncData->nativenVersion,
                                               currentFuncData->CodeVersionToken,
                                               currentFuncData->ilToNativeMapAddr,
                                               currentFuncData->ilToNativeMapSize);
                    
                    _ASSERTE( SUCCEEDED(hr) || !"FAILURE" );
                    if (!SUCCEEDED(hr))
                        goto exit;
                }

                // Lookup the appdomain that the thread was in when it was executing code for this frame. We pass this
                // to the frame when we create it so we can properly resolve locals in that frame later.
                CordbAppDomain *currentAppDomain = (CordbAppDomain*) GetProcess()->m_appDomains.GetBase(
                                                                           (ULONG)currentSTRData->currentAppDomainToken);
                _ASSERTE(currentAppDomain != NULL);
                
                // Create the native frame.
                CordbNativeFrame* nativeFrame = new CordbNativeFrame(chain,
                                                                     currentSTRData->fp,
                                                                     pFunction,
                                                                     pCode,
                                                                     (UINT_PTR) currentFuncData->nativeOffset,
                                                                     &(currentSTRData->rd),
                                                                     currentSTRData->quicklyUnwound,
                                                                     (CordbFrame**)f - chain->m_start,
                                                                     currentAppDomain);

                if (NULL == nativeFrame )
                {
                    _ASSERTE( !"FAILURE" );
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                else if (pCode) 
                {
                    pCode->Release();
                    pCode = NULL;
                }

                // Addref for the thread
                nativeFrame->AddRef();

                // Add this frame into the array
                *f++ = nativeFrame;
                inProgressFrameCount++;

                if (currentSTRData->ILIP != NULL)
                {
                    if (FAILED(hr=pFunction->GetCodeByVersion(FALSE, bILCode,
                        currentFuncData->ilnVersion, &pCode)))
                    {
                        _ASSERTE( !"FAILURE" );
                        goto exit;
                    }

                    if (pCode == NULL)
                    {
                        LOG((LF_CORDB,LL_INFO10000,"R:CT::RSCreating code"
                            "w/ ver:0x%x,token:0x%x\n", 
                            currentFuncData->ilnVersion,
                            currentFuncData->CodeVersionToken));
                            
                        hr = pFunction->CreateCode(
                                               bILCode,
                                               currentFuncData->ilStartAddress,
                                               currentFuncData->ilSize,
                                               &pCode, currentFuncData->ilnVersion,
                                               currentFuncData->CodeVersionToken,
                                               NULL, 0);
                        _ASSERTE( SUCCEEDED(hr) || !"FAILURE" );
                        if (!SUCCEEDED(hr))
                            goto exit;
                    }

                    CordbJITILFrame* JITILFrame =
                      new CordbJITILFrame(nativeFrame, pCode,
                                          (UINT_PTR) currentSTRData->ILIP
                                          - (UINT_PTR) currentFuncData->ilStartAddress,
                                          currentSTRData->mapping,
                                          currentFuncData->fVarArgs,
                                          currentFuncData->rpSig,
                                          currentFuncData->cbSig,
                                          currentFuncData->rpFirstArg);

                    if (!JITILFrame)
                    {
                        hr = E_OUTOFMEMORY;
                        goto exit;
                    }
                    else if (pCode)
                    {
                        pCode->Release();
                        pCode = NULL;
                    }

                    //
                    // @todo: error checking!
                    //
                    //user expects refcount of 1
                    JITILFrame->AddRef();
                    
                    nativeFrame->m_JITILFrame = JITILFrame;
                }
            }

            currentSTRData++;
            traceCount++;
        }

        totalTraceCount += traceCount;
            
        if (totalTraceCount >= m_stackFrameCount + m_stackChainCount)
            wait = false;
    }

exit:
    _ASSERTE(f == NULL || f == m_stackFrames + m_stackFrameCount);

    if (!SUCCEEDED(hr))
    {
        m_stackFrameCount = inProgressFrameCount;
        m_stackChainCount = inProgressChainCount;
        CleanupStack(); // sets frames fresh to false
    }
    else
    {
        m_framesFresh = true;
#ifndef RIGHT_SIDE_ONLY
        m_dwSuspendVersion = g_profControlBlock.dwSuspendVersion;
#endif
    }

#ifndef RIGHT_SIDE_ONLY    
    m_process->ClearContinuationEvents();
#endif
    
    if (pCode)
        pCode->Release();

    INPROC_UNLOCK();
    
    return hr;
}


void CordbThread::CleanupStack()
{
    if (m_stackFrames != NULL)
    {
        CordbNativeFrame **f, **fEnd;
        f = m_stackFrames;
        fEnd = f + m_stackFrameCount;

        while (f < fEnd)
        {
            // Watson error paths have found cases of NULL in the
            // wild, so report it and prevent it.
            _ASSERTE((*f) != NULL);
            if (!*f)
                break;
            
            (*f)->Neuter();
            (*f)->Release();
            f++;
        }

        m_stackFrameCount = 0;
        delete [] m_stackFrames;
        m_stackFrames = NULL;
    }

    if (m_stackChains != NULL)
    {
        CordbChain **s, **sEnd;
        s = m_stackChains;
        sEnd = s + m_stackChainCount;

         while (s < sEnd)
         {
             _ASSERTE( (const unsigned int)*s != (const unsigned int)0xabababab);
             (*s)->Neuter();
             (*s)->Release();
             s++;
         }

        m_stackChainCount = 0;
        delete [] m_stackChains;
        m_stackChains = NULL;
    }

    // If the stack is old, then the CONTEXT (if any) is out of date
    // as well.
    m_contextFresh = false;
    m_pvLeftSideContext = NULL;
    m_framesFresh = false;
}

//
// LoadFloatState loads the floating point stack from the left side.
// This is only really used for native code.
//
HRESULT CordbThread::LoadFloatState(void)
{
#ifndef RIGHT_SIDE_ONLY
#ifdef PROFILING_SUPPORTED
    // Need to check that this thread is in a valid state for in-process debugging.
    if (!CHECK_INPROC_THREAD_STATE())
        return (CORPROF_E_INPROC_NOT_ENABLED);
#endif // PROFILING_SUPPORTED
#endif // RIGHT_SIDE_ONLY
    
    HRESULT hr = S_OK;
    DebuggerIPCEvent *retEvent = NULL;

    CordbProcess *pProcess = GetProcess();
#ifdef RIGHT_SIDE_ONLY
    _ASSERTE(pProcess->GetSynchronized());
#endif

    INPROC_LOCK();

    //
    // Send the get float state event to the RC.
    //
    DebuggerIPCEvent event;
    pProcess->InitIPCEvent(&event, 
                           DB_IPCE_GET_FLOAT_STATE, 
                           false,
                           (void *)(GetAppDomain()->m_id));
    event.GetFloatState.debuggerThreadToken = m_debuggerThreadToken;

    hr = pProcess->m_cordb->SendIPCEvent(pProcess, &event,
                                         sizeof(DebuggerIPCEvent));

    //
    // Stop now if we can't even send the event.
    //
    if (!SUCCEEDED(hr))
        goto exit;

    //
    // Wait for events to return from the RC. We expect only one
    // float state result event.
    //
    retEvent = (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);

#ifdef RIGHT_SIDE_ONLY
    hr = pProcess->m_cordb->WaitForIPCEventFromProcess(pProcess, 
                                                       GetAppDomain(),
                                                       retEvent);
#else 
    hr = pProcess->m_cordb->GetFirstContinuationEvent(pProcess, 
                                                      retEvent);
#endif //RIGHT_SIDE_ONLY    

    if (!SUCCEEDED(hr))
        goto exit;
        
    //
    // @todo: assert that the event is from the proper thread and
    // process, too.
    //
    _ASSERTE(retEvent->type == DB_IPCE_GET_FLOAT_STATE_RESULT);

    //
    // Fill in the proper float state data.
    //
    m_floatStateValid = retEvent->GetFloatStateResult.floatStateValid;
    m_floatStackTop = retEvent->GetFloatStateResult.floatStackTop;
    memcpy(m_floatValues,
           retEvent->GetFloatStateResult.floatValues,
           sizeof(m_floatValues));

exit:

#ifndef RIGHT_SIDE_ONLY    
    pProcess->ClearContinuationEvents();
#endif    
    
    INPROC_UNLOCK();

#if 0
    //to verify that the right side got the correct values
    for (int i = 0; i < 8; i++)
        fprintf(stderr, "CT::LFS: m_floatValues[%d]: %.16g\n", i, m_floatValues[i]);
#endif //LOGGING

    return hr;
}

const bool SetIP_fCanSetIPOnly = TRUE;
const bool SetIP_fSetIP = FALSE;

const bool SetIP_fIL = TRUE;
const bool SetIP_fNative = FALSE;

HRESULT CordbThread::SetIP( bool fCanSetIPOnly,
                            REMOTE_PTR debuggerModule, 
                            mdMethodDef mdMethod, 
                            void *versionToken, 
                            SIZE_T offset, 
                            bool fIsIL)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    _ASSERTE(m_firstExceptionHandler != NULL);
    _ASSERTE(debuggerModule != NULL);

    // If this thread is stopped due to an exception, never allow SetIP
    if (m_exception)
        return (CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION);

    DebuggerIPCEvent *event = (DebuggerIPCEvent*) _alloca(CorDBIPC_BUFFER_SIZE);
    m_process->InitIPCEvent(event, 
                            DB_IPCE_SET_IP, 
                            true,
                            (void *)(GetAppDomain()->m_id));
    event->SetIP.fCanSetIPOnly = fCanSetIPOnly;
    event->SetIP.debuggerThreadToken = m_debuggerThreadToken;
    event->SetIP.debuggerModule = debuggerModule;
    event->SetIP.mdMethod = mdMethod;
    event->SetIP.versionToken = versionToken;
    event->SetIP.offset = offset;
    event->SetIP.fIsIL = fIsIL;
    event->SetIP.firstExceptionHandler = m_firstExceptionHandler;
    
    LOG((LF_CORDB, LL_INFO10000, "[%x] CT::SIP: Info:thread:0x%x"
        "mod:0x%x  MethodDef:0x%x VerTok:0x%x offset:0x%x  il?:0x%x\n", 
        GetCurrentThreadId(),m_debuggerThreadToken, debuggerModule,
        mdMethod, versionToken,offset, fIsIL));

    LOG((LF_CORDB, LL_INFO10000, "[%x] CT::SIP: sizeof(DebuggerIPCEvent):0x%x **********\n",
        sizeof(DebuggerIPCEvent)));

    HRESULT hr = m_process->m_cordb->SendIPCEvent(m_process, event, 
                                                  sizeof(DebuggerIPCEvent));

    if (FAILED( hr ) )
        return hr;

    _ASSERTE(event->type == DB_IPCE_SET_IP);

    if (!fCanSetIPOnly && SUCCEEDED(event->hr))
    {
        m_framesFresh = false;
        hr = RefreshStack();
        if (FAILED(hr))
            return hr;
    }

    return event->hr;
#endif //RIGHT_SIDE_ONLY    
}


HRESULT CordbThread::GetContext(CONTEXT **ppContext)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else

    if (ppContext == NULL)
        return E_INVALIDARG;

    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
    
    // Each CordbThread object allocates the m_pContext's CONTEXT structure only once, the first time GetContext is
    // invoked.
    if(m_pContext == NULL)
    {
        m_pContext = (CONTEXT*) new BYTE[sizeof(CONTEXT)];  

        if (m_pContext == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT hr = S_OK;

    if (m_contextFresh == false)
    {

        hr = RefreshStack();
        
        if (FAILED(hr))
            return hr;

        if (m_pvLeftSideContext == NULL) 
        {
            LOG((LF_CORDB, LL_INFO1000, "CT::GC: getting context from unmanaged thread.\n"));
            
            // The thread we're inspecting isn't handling an exception, so get the regular CONTEXT.  Since this is an
            // "IN OUT" parameter, we have to tell GetThreadContext what fields we're interested in.
            m_pContext->ContextFlags = CONTEXT_FULL;

            if (GetProcess()->m_state & CordbProcess::PS_WIN32_ATTACHED)
                hr = GetProcess()->GetThreadContext(m_id, sizeof(CONTEXT), (BYTE*) m_pContext);
            else
            {
                BOOL succ = ::GetThreadContext(m_handle, m_pContext);

                if (!succ)
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            LOG((LF_CORDB, LL_INFO1000, "CT::GC: getting context from left side pointer.\n"));
            
            // The thread we're examining IS handling an exception, So grab the CONTEXT of the exception, NOT the
            // currently executing thread's CONTEXT (which would be the context of the exception handler.)
            hr = m_process->SafeReadThreadContext(m_pvLeftSideContext, m_pContext);
        }

        // m_contextFresh should be marked false when CleanupStack, MarkAllFramesAsDirty, etc get called.
        if (SUCCEEDED(hr))
            m_contextFresh = true;
    }

    if (SUCCEEDED(hr))
        (*ppContext) = m_pContext;

    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbThread::SetContext(CONTEXT *pContext)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    if(pContext == NULL)
        return E_INVALIDARG;

    CORDBRequireProcessStateOKAndSync(m_process, GetAppDomain());
    
    HRESULT hr = RefreshStack();
    
    if (FAILED(hr))
        return hr;

    if (m_pvLeftSideContext == NULL) 
    {
        // Thread we're inspect isn't handling an exception, so set the regular CONTEXT.
        if (GetProcess()->m_state & CordbProcess::PS_WIN32_ATTACHED)
            hr = GetProcess()->SetThreadContext(m_id, sizeof(CONTEXT), (BYTE*)pContext);
        else
        {
            BOOL succ = ::SetThreadContext(m_handle, pContext);

            if (!succ)
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        // The thread we're examining IS handling an exception, So set the CONTEXT of the exception, NOT the currently
        // executing thread's CONTEXT (which would be the context of the exception handler.)
        //
        // Note: we read the remote context and merge the new one in, then write it back. This ensures that we don't
        // write too much information into the remote process.
        CONTEXT tempContext;
        hr = m_process->SafeReadThreadContext(m_pvLeftSideContext, &tempContext);

        if (SUCCEEDED(hr))
        {
            _CopyThreadContext(&tempContext, pContext);
            
            hr = m_process->SafeWriteThreadContext(m_pvLeftSideContext, &tempContext);
        }
    }

    if (SUCCEEDED(hr) && m_contextFresh && (m_pContext != NULL))
        *m_pContext = *pContext;

    return hr;
#endif //RIGHT_SIDE_ONLY    
}


HRESULT CordbThread::GetAppDomain(ICorDebugAppDomain **ppAppDomain)
{
#ifndef RIGHT_SIDE_ONLY
#ifdef PROFILING_SUPPORTED
    // Need to check that this thread is in a valid state for in-process debugging.
    if (!CHECK_INPROC_THREAD_STATE())
        return (CORPROF_E_INPROC_NOT_ENABLED);
#endif // PROFILING_SUPPORTED
#endif // RIGHT_SIDE_ONLY
    
    VALIDATE_POINTER_TO_OBJECT(ppAppDomain, ICorDebugAppDomain **);

    (*ppAppDomain) = (ICorDebugAppDomain *)m_pAppDomain;

    if ((*ppAppDomain) != NULL)
        (*ppAppDomain)->AddRef();
    
    return S_OK;
}

HRESULT CordbThread::GetObject(ICorDebugValue **ppThreadObject)
{
#ifndef RIGHT_SIDE_ONLY
#ifdef PROFILING_SUPPORTED
    // Need to check that this thread is in a valid state for in-process debugging.
    if (!CHECK_INPROC_THREAD_STATE())
        return (CORPROF_E_INPROC_NOT_ENABLED);
#endif // PROFILING_SUPPORTED
#endif
    
    HRESULT hr;

    VALIDATE_POINTER_TO_OBJECT(ppThreadObject, ICorDebugObjectValue **);

    // Default to NULL
    *ppThreadObject = NULL;

#ifdef RIGHT_SIDE_ONLY
    // Require Sync for out-of-proc case
    CORDBLeftSideDeadIsOkay(GetProcess());
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif

    if (m_detached)
        return CORDBG_E_BAD_THREAD_STATE;

    // Get the address of this thread's managed object from the 
    // left side.
    DebuggerIPCEvent event;
    
    m_process->InitIPCEvent(&event, 
                            DB_IPCE_GET_THREAD_OBJECT, 
                            true,
                            (void *)GetAppDomain()->m_id);
    
    event.ObjectRef.debuggerObjectToken = (void *)m_debuggerThreadToken;
    
    // Note: two-way event here...
    hr = m_process->m_cordb->SendIPCEvent(m_process, &event,
                                          sizeof(DebuggerIPCEvent));

    // Stop now if we can't even send the event.
    if (!SUCCEEDED(hr))
        return hr;

    _ASSERTE(event.type == DB_IPCE_THREAD_OBJECT_RESULT);

    if (!SUCCEEDED(event.hr))
        return event.hr;

    REMOTE_PTR pObjectHandle = event.ObjectRef.managedObject;
    if (pObjectHandle == NULL)
        return E_FAIL;

    CordbModule *module = GetAppDomain()->GetAnyModule();

    if (module == NULL)
#ifdef RIGHT_SIDE_ONLY
        return E_FAIL;
#else
        // This indicates to inproc debugging that this information is not
        // yet available from this callback.  Basically, this function can't
        // be used until a module is loaded into the appdomain.
        return (CORPROF_E_NOT_YET_AVAILABLE);
#endif
    
    hr = CordbValue::CreateValueByType(GetAppDomain(),
                                         module,
                                         sizeof(g_elementTypeClass),
                                         (PCCOR_SIGNATURE) &g_elementTypeClass,
                                         NULL,
                                         pObjectHandle, NULL,
                                         true,
                                         NULL,
                                         NULL,
                                         ppThreadObject);
    
    // Don't return a null pointer with S_OK.
    _ASSERTE(!(hr == S_OK && *ppThreadObject == NULL));
    return hr;
}


/* ------------------------------------------------------------------------- *
 * Unmanaged Thread classes
 * ------------------------------------------------------------------------- */

CordbUnmanagedThread::CordbUnmanagedThread(CordbProcess *pProcess, DWORD dwThreadId, HANDLE hThread, void *lpThreadLocalBase)
  : CordbBase(dwThreadId, enumCordbUnmanagedThread),
    m_process(pProcess),
    m_handle(hThread),
    m_threadLocalBase(lpThreadLocalBase),
    m_pTLSArray(NULL),
    m_state(CUTS_None),
    m_pLeftSideContext(NULL),
    m_originalHandler(NULL)
{
    IBEvent()->m_state = CUES_None;
    IBEvent()->m_next = NULL;
    IBEvent()->m_owner = this;
    
    IBEvent2()->m_state = CUES_None;
    IBEvent2()->m_next = NULL;
    IBEvent2()->m_owner = this;
    
    OOBEvent()->m_state = CUES_None;
    OOBEvent()->m_next = NULL;
    OOBEvent()->m_owner = this;
}

CordbUnmanagedThread::~CordbUnmanagedThread()
{
}

#define WINNT_TLS_OFFSET    0xe10     // TLS[0] at fs:[WINNT_TLS_OFFSET]
#define WINNT5_TLSEXPANSIONPTR_OFFSET 0xf94 // TLS[64] at [fs:[WINNT5_TLSEXPANSIONPTR_OFFSET]]
#define WIN95_TLSPTR_OFFSET 0x2c      // TLS[0] at [fs:[WIN95_TLSPTR_OFFSET]]

HRESULT CordbUnmanagedThread::LoadTLSArrayPtr(void)
{
    if (m_pTLSArray != NULL)
        return S_OK;

    if (!Cordb::m_runningOnNT)
    {
        // On Win9x, we have to grab the ptr to the thread local array
        // first, then use that as the base to index off of.  This
        // will never move once we find it for a given thread, so we
        // cache it here so we don't always have to perform two
        // ReadProcessMemoryI's.
        void *ppTLSArray = (BYTE*) m_threadLocalBase +
            WIN95_TLSPTR_OFFSET;
        
        BOOL succ = ReadProcessMemoryI(m_process->m_handle,
                                      ppTLSArray,
                                      &m_pTLSArray,
                                      sizeof(void*),
                                      NULL);

        if (!succ)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "CUT::LTLSAP: failed to read TLS array ptr: 0x%08x, "
                 "err=%d\n", ppTLSArray, GetLastError()));
        
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        if (m_process->m_runtimeOffsets.m_TLSIndex < 64)
        {
            // Just simple math on NT with a small tls index.
            m_pTLSArray = (BYTE*) m_threadLocalBase + WINNT_TLS_OFFSET;
        }
        else
        {
            // On NT 5 you can have TLS index's greater than 63, so we
            // have to grab the ptr to the TLS expansion array first,
            // then use that as the base to index off of.  This will
            // never move once we find it for a given thread, so we
            // cache it here so we don't always have to perform two
            // ReadProcessMemoryI's.
            void *ppTLSArray = (BYTE*) m_threadLocalBase +
                WINNT5_TLSEXPANSIONPTR_OFFSET;
        
            BOOL succ = ReadProcessMemoryI(m_process->m_handle,
                                          ppTLSArray,
                                          &m_pTLSArray,
                                          sizeof(void*),
                                          NULL);

            if (!succ)
            {
                LOG((LF_CORDB, LL_INFO1000,
                     "CUT::LTLSAP: failed to read TLS array ptr: 0x%08x, "
                     "err=%d\n", ppTLSArray, GetLastError()));
        
                return HRESULT_FROM_WIN32(GetLastError());
            }

            // Go ahead and adjust the EE TLS slot down so that we
            // don't need to worry about adjusting it when
            // reading/writing it later.
            m_process->m_runtimeOffsets.m_TLSIndex -= 64;
        }
    }

    return S_OK;
}

REMOTE_PTR CordbUnmanagedThread::GetEETlsValue(void)
{
    REMOTE_PTR ret = NULL;
    
    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);
    
    // Compute the address of the necessary TLS value.
    if (m_pTLSArray == NULL)
        if (FAILED(LoadTLSArrayPtr()))
            return NULL;
        
    void *pEEThreadTLS = (BYTE*) m_pTLSArray + (pRO->m_TLSIndex * sizeof(void*));
    
    // Read the thread's TLS value.
    BOOL succ = ReadProcessMemoryI(m_process->m_handle, pEEThreadTLS, &ret, sizeof(REMOTE_PTR), NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::GEETV: failed to read TLS value: computed addr=0x%08x index=%d, err=%d\n",
             pEEThreadTLS, pRO->m_TLSIndex, GetLastError()));
        
        return NULL;
    }

    LOG((LF_CORDB, LL_INFO1000000, "CUT::GEETV: EE Thread TLS value is 0x%08x for thread 0x%x\n", ret, m_id));

    return ret;
}

HRESULT CordbUnmanagedThread::SetEETlsValue(REMOTE_PTR EETlsValue)
{
    // Compute the address of the necessary TLS value.
    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);
    
    // Compute the address of the necessary TLS value.
    if (m_pTLSArray == NULL)
    {
        HRESULT hr = LoadTLSArrayPtr();

        if (FAILED(hr))
            return hr;
    }
        
    void *pEEThreadTLS =
        (BYTE*) m_pTLSArray + (pRO->m_TLSIndex * sizeof(void*));
    
    // Write the thread's TLS value.
    BOOL succ = WriteProcessMemory(m_process->m_handle,
                                   pEEThreadTLS,
                                   &EETlsValue,
                                   sizeof(REMOTE_PTR),
                                   NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::SEETV: failed to set TLS value: "
             "computed addr=0x%08x index=%d, err=%d\n",
             pEEThreadTLS, pRO->m_TLSIndex, GetLastError()));
        
        return HRESULT_FROM_WIN32(GetLastError());
    }

    LOG((LF_CORDB, LL_INFO1000000,
        "CUT::SEETV: EE Thread TLS value is now 0x%08x for thread 0x%x\n",
        EETlsValue, m_id));

    return S_OK;
}

//
// Returns the EETlsValue, or NULL if the EETlsValue is not actually a Thread ptr.
//
REMOTE_PTR CordbUnmanagedThread::GetEEThreadPtr(void)
{
    REMOTE_PTR ret = GetEETlsValue();

    // If we got a TLS value, but the low bit is set, then its not really a true EE thread pointer, so return NULL.
    if (((UINT_PTR)ret) & 0x01)
        ret = NULL;

    return ret;
}

void CordbUnmanagedThread::GetEEThreadState(REMOTE_PTR EETlsValue, bool *threadStepping, bool *specialManagedException)
{
    _ASSERTE((((UINT_PTR)EETlsValue) & 0x01) == 0);
    
    *threadStepping = false;
    *specialManagedException = false;
    
    // Compute the address of the thread's state
    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);
    void *pEEThreadStateNC = (BYTE*) EETlsValue + pRO->m_EEThreadStateNCOffset;
    
    // Grab the thread state out of the EE Thread.
    DWORD EEThreadStateNC;
    BOOL succ = ReadProcessMemoryI(m_process->m_handle, pEEThreadStateNC, &EEThreadStateNC, sizeof(EEThreadStateNC), NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::GEETS: failed to read thread state NC: 0x%08x + 0x%x = 0x%08x, err=%d\n",
             EETlsValue, pRO->m_EEThreadStateNCOffset, pEEThreadStateNC, GetLastError()));
        
        return;
    }

    LOG((LF_CORDB, LL_INFO1000000, "CUT::GEETS: EE Thread state NC is 0x%08x\n", EEThreadStateNC));

    // Looks like we've got the state of the thread.
    *threadStepping = ((EEThreadStateNC & pRO->m_EEThreadSteppingStateMask) != 0);
    *specialManagedException = ((EEThreadStateNC & pRO->m_EEIsManagedExceptionStateMask) != 0);

    return;
}

bool CordbUnmanagedThread::GetEEThreadCantStop(REMOTE_PTR EETlsValue)
{
    // Note: we take this opprotunity to make sure that we don't stop while we're in a
    // hijack. We want to treat all of our hijacks as big Can't Stop regions, and this is the easy way to do it.
    if (IsFirstChanceHijacked() || IsHideFirstChanceHijackState() || IsGenericHijacked() || IsSecondChanceHijacked())
        return true;
    
    // Note: any failure to read memory is okay for this method. We simply say that the thread is not is a can't stop
    // state, and that's okay.
    
    _ASSERTE((((UINT_PTR)EETlsValue) & 0x01) == 0);
    
    // Compute the address of the thread's debugger word #1
    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);
    void *pEEThreadCantStop = (BYTE*) EETlsValue + pRO->m_EEThreadCantStopOffset;
    
    // Grab the debugger word #1 out of the EE Thread.
    DWORD EEThreadCantStop;
    BOOL succ = ReadProcessMemoryI(m_process->m_handle, pEEThreadCantStop, &EEThreadCantStop, sizeof(EEThreadCantStop), NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::GEETS: failed to read thread cant stop: 0x%08x + 0x%x = 0x%08x, err=%d\n",
             EETlsValue, pRO->m_EEThreadCantStopOffset, pEEThreadCantStop, GetLastError()));

        return false;
    }

    LOG((LF_CORDB, LL_INFO1000000, "CUT::GEETS: EE Thread cant stop is 0x%08x\n", EEThreadCantStop));

    // Looks like we've got it.
    if (EEThreadCantStop != 0)
        return true;
    else
        return false;
}

bool CordbUnmanagedThread::GetEEThreadPGCDisabled(REMOTE_PTR EETlsValue)
{
    // Note: any failure to read memory is okay for this method. We simply say that the thread has PGC disabled, which
    // is always the worst case scenario.
    
    _ASSERTE((((UINT_PTR)EETlsValue) & 0x01) == 0);
    
    // Compute the address of the thread's PGC disabled word
    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);
    void *pEEThreadPGCDisabled = (BYTE*) EETlsValue + pRO->m_EEThreadPGCDisabledOffset;
    
    // Grab the PGC disabled word out of the EE Thread.
    DWORD EEThreadPGCDisabled;
    BOOL succ = ReadProcessMemoryI(m_process->m_handle, pEEThreadPGCDisabled, &EEThreadPGCDisabled,
                                   sizeof(EEThreadPGCDisabled), NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::GEETS: failed to read thread PGC Disabled: 0x%08x + 0x%x = 0x%08x, err=%d\n",
             EETlsValue, pRO->m_EEThreadPGCDisabledOffset, pEEThreadPGCDisabled, GetLastError()));
        
        return true;
    }

    LOG((LF_CORDB, LL_INFO1000000, "CUT::GEETS: EE Thread PGC Disabled is 0x%08x\n", EEThreadPGCDisabled));

    // Looks like we've got it.
    if (EEThreadPGCDisabled == pRO->m_EEThreadPGCDisabledValue)
        return true;
    else
        return false;
}

bool CordbUnmanagedThread::GetEEThreadFrame(REMOTE_PTR EETlsValue)
{
    _ASSERTE((((UINT_PTR)EETlsValue) & 0x01) == 0);
    
    // Compute the address of the thread's frame ptr
    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);
    void *pEEThreadFrame = (BYTE*) EETlsValue + pRO->m_EEThreadFrameOffset;
    
    // Grab the thread's frame out of the EE Thread.
    DWORD EEThreadFrame;
    BOOL succ = ReadProcessMemoryI(m_process->m_handle, pEEThreadFrame, &EEThreadFrame, sizeof(EEThreadFrame), NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::GEETF: failed to read thread frame: 0x%08x + 0x%x = 0x%08x, err=%d\n",
             EETlsValue, pRO->m_EEThreadFrameOffset, pEEThreadFrame, GetLastError()));
        
        return false;
    }

    LOG((LF_CORDB, LL_INFO1000000, "CUT::GEETF: EE Thread's frame is 0x%08x\n", EEThreadFrame));

    // Looks like we've got the frame of the thread.
    if (EEThreadFrame != pRO->m_EEMaxFrameValue)
        return true;
    else
        return false;
}

#ifdef RIGHT_SIDE_ONLY

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    void *Handler;
} EXCEPTION_REGISTRATION_RECORD;

#endif //RIGHT_SIDE_ONLY

HRESULT CordbUnmanagedThread::SetupFirstChanceHijack(REMOTE_PTR EETlsValue)
{
    _ASSERTE(!IsFirstChanceHijacked());
    
    // Compute the address of the pointer to the thread's exception list.
    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);
    
    void *pExceptionList = (BYTE*) m_threadLocalBase + offsetof(NT_TIB, ExceptionList);
    
    // Read the thread's pointer to the head of the exception list.
    EXCEPTION_REGISTRATION_RECORD *pErr;
    
    BOOL succ = ReadProcessMemoryI(m_process->m_handle, pExceptionList, &pErr, sizeof(EXCEPTION_REGISTRATION_RECORD*), NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::SFCH: failed to read excep head: 0x%08x + 0x%x = 0x%08x, err=%d\n",
             m_threadLocalBase, offsetof(NT_TIB, ExceptionList), pExceptionList, GetLastError()));
        
        return HRESULT_FROM_WIN32(GetLastError());
    }

    LOG((LF_CORDB, LL_INFO1000, "CUT::SFCH: head err is at 0x%08x for thread 0x%x\n", pErr, m_id));

    // Next, read the head exception registration record.
    EXCEPTION_REGISTRATION_RECORD err;

    succ = ReadProcessMemoryI(m_process->m_handle, pErr, &err, sizeof(EXCEPTION_REGISTRATION_RECORD), NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::SFCH: failed to read excep rec: err=%d\n", GetLastError()));
        
        return HRESULT_FROM_WIN32(GetLastError());
    }

    LOG((LF_CORDB, LL_INFO1000, "CUT::SFCH: head ERR read, handler is at 0x%08x\n", err.Handler));

    // Store the address of the original handler into the EE Thread object. If there is no EE Thread object yet, then
    // we'll pass over the original handler when we get notified that the exception was not for the Runtime.
    if ((EETlsValue != NULL) && ((((UINT_PTR)EETlsValue) & 0x01) == 0))
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::SFCH: passing over original handler in EE Thread Object's debugger word.\n"));
        SetEEThreadDebuggerWord(EETlsValue, (DWORD)err.Handler);
    }
    else
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::SFCH: deferring pass of original handler...\n"));
        m_originalHandler = err.Handler;
    }

    // Update the handler in the head exception registration record to point to our hijack handler.
    _ASSERTE(pRO->m_firstChanceHijackFilterAddr != NULL);
    err.Handler = pRO->m_firstChanceHijackFilterAddr;

    // Write the update ERR back.
    succ = WriteProcessMemory(m_process->m_handle, pErr, &err, sizeof(EXCEPTION_REGISTRATION_RECORD), NULL);
    
    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::SFCH: failed to write updated handler: err=%d\n", GetLastError()));
        
        return HRESULT_FROM_WIN32(GetLastError());
    }

    LOG((LF_CORDB, LL_INFO1000000, "CUT::SFCH: updated handler to 0x%08x\n", err.Handler));

    // We're hijacked now...
    SetState(CUTS_FirstChanceHijacked);
    SetState(CUTS_AwaitingOwnershipAnswer);
    m_process->m_state |= CordbProcess::PS_HIJACKS_IN_PLACE;
    m_process->m_awaitingOwnershipAnswer++;

    // Make sure the trace flag isn't on. This can happen if we were single stepping the thread when we faulted. This
    // will ensure that we don't try to single step through the OS's exception logic, which greatly confuses our first
    // chance hijack logic. This also mimics what the OS does for us automaically when singel stepping in process, i.e.,
    // when you turn the trace flag on in-process and go, if there is a fault, the fault is reported and the trace flag
    // is automatically turned off.
    //
    // Note: we only do this all the time. We can't try to single step through one of our hijacks.

    // Snag the thread's context.
    CONTEXT c;
    c.ContextFlags = CONTEXT_FULL;

    succ = GetThreadContext(m_handle, &c);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::SFCH: couldn't get thread context: %d\n", GetLastError()));

        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Yank out the trace flag if its set.
    if (c.EFlags & 0x100)
    {
        c.EFlags &= ~0x100;
        
        // Put the context back.
        succ = SetThreadContext(m_handle, &c);
            
        if (!succ)
        {
            LOG((LF_CORDB, LL_INFO1000, "CUT::SFCH: couldn't set thread context: %d\n", GetLastError()));

            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    // Check the thread's supsend count. There is a nasty race where a thread that we're hijacking may have passed the
    // HandledJITCase test during a suspension and become suspended in the slip time between faulting and getting the
    // process stopped before passing the Win32 event out to us. If the thread is suspended, then we drag its suspend
    // count down now.
    //
    // Note: there is similar logic in SweepFCHThreads in process.cpp to handle the resumption window, after we continue
    // the event but before the process is fully resumed.
    DWORD sres = SuspendThread(m_handle);

    if (sres != -1)
        ResumeThread(m_handle);

    if (sres > 0)
        while (sres--)
            ResumeThread(m_handle);
    
    return S_OK;
}

HRESULT CordbUnmanagedThread::FixupFromFirstChanceHijack(EXCEPTION_RECORD *pExceptionRecord,
                                                         bool *pbExceptionBelongsToRuntime)
{
    HRESULT hr = S_OK;
    
    _ASSERTE(IsFirstChanceHijacked());
    
    *pbExceptionBelongsToRuntime = false;
    
    // The only valid exception from a first-chance hijacked thread is a breakpoint exception.
    if (pExceptionRecord->ExceptionCode != STATUS_BREAKPOINT)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT:FFFCH: invalid exception code for "
             "a thread that has been first-chance hijacked: 0x%08x\n",
             pExceptionRecord->ExceptionCode));
        
        return E_FAIL;
    }
    
    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);

    if (pExceptionRecord->ExceptionAddress == pRO->m_excepForRuntimeBPAddr)
    {
        // The previous exception belongs to the Runtime.
        LOG((LF_CORDB, LL_INFO10000, "CUT::FFFCH: exception belonged to the Runtime.\n"));

        // This exception belonged to the Runtime.
        *pbExceptionBelongsToRuntime = true;
    }
    else if (pExceptionRecord->ExceptionAddress == pRO->m_excepForRuntimeHandoffStartBPAddr)
    {
        // The previous exception belongs to the Runtime, and its the start of a managed->unmanaged handoff, so we need
        // to be sure to continue to hide the hijack state of the thread.
        LOG((LF_CORDB, LL_INFO10000, "CUT::FFFCH: exception did belonged to the Runtime, *** handoff start ***\n"));

        // This exception belonged to the Runtime.
        *pbExceptionBelongsToRuntime = true;

        // Hide the hijack state...
        SetState(CUTS_HideFirstChanceHijackState);
        
        // Grab the thread's context pointer from the thread's TLS and hold it in the unmanaged thread object so that
        // Get/SetThreadContext will work properly.
        REMOTE_PTR EETlsValue = GetEETlsValue();
        m_pLeftSideContext = (CONTEXT*)GetEEThreadDebuggerWord(EETlsValue);
    }
    else if (pExceptionRecord->ExceptionAddress == pRO->m_excepNotForRuntimeBPAddr)
    {
        // The previous exception does not belong to the Runtime.
        LOG((LF_CORDB, LL_INFO10000, "CUT::FFFCH: exception did not belong to the Runtime.\n"));

        // Reset the unmanaged waiting event that all hijacked threads are waiting on.
        BOOL succ = ResetEvent(m_process->m_leftSideUnmanagedWaitEvent);

        // Grab the thread's context pointer from the thread's TLS and hold it in the unmanaged thread object so that
        // Get/SetThreadContext will work properly.
        REMOTE_PTR EETlsValue = GetEETlsValue();

        // Now, if there is no EE Thread object for this thread yet, then we're getting a ptr to a
        // DebuggerIPCFirstChanceData. This holds the pointer to the left side context, and the address of the original
        // handler that we need to update. Otherwise, we've got the pointer to the left side context in the debugger
        // word.
        if ((((UINT_PTR)EETlsValue) & 0x01) == 1)
        {
            // Read over the FCD...
            DebuggerIPCFirstChanceData fcd;
            DebuggerIPCFirstChanceData *pfcd = (DebuggerIPCFirstChanceData*)(((UINT_PTR)EETlsValue) & ~0x01);

            succ = ReadProcessMemoryI(m_process->m_handle, pfcd, &fcd, sizeof(fcd), NULL);
            _ASSERTE(succ);

            // Save the pointer to the left side context.
            m_pLeftSideContext = fcd.pLeftSideContext;

            // Update the original handler
            _ASSERTE(m_originalHandler != NULL);
            _ASSERTE(fcd.pOriginalHandler != NULL);
            
            LOG((LF_CORDB, LL_INFO10000, "CUT::FFFCH: Passing over original handler addr 0x%08x.\n", m_originalHandler));

            succ = WriteProcessMemory(m_process->m_handle, fcd.pOriginalHandler, &m_originalHandler, sizeof(void*), NULL);
            _ASSERTE(succ);
            
            m_originalHandler = NULL;
        }
        else
        {
            m_pLeftSideContext = (CONTEXT*)GetEEThreadDebuggerWord(EETlsValue);
        }
    }
    else
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::FFFCH: bad debug event for hijacked thread.\n"));
        return E_FAIL;
    }
    
    // When we first-chance hijacked this thread, we marked that we were awaiting its answer regarding who owns the
    // exception (either the Runtime or not.) We've got the answer, so decrement the count.
    _ASSERTE(m_process->m_awaitingOwnershipAnswer > 0);
    _ASSERTE(IsAwaitingOwnershipAnswer());
    m_process->m_awaitingOwnershipAnswer--;
    ClearState(CUTS_AwaitingOwnershipAnswer);
    
    return hr;
}

HRESULT CordbUnmanagedThread::SetupGenericHijack(DWORD eventCode)
{
    if (eventCode == EXIT_THREAD_DEBUG_EVENT)
        return S_OK;
    
    _ASSERTE(!IsGenericHijacked());

    // Save the thread's full context.
    m_context.ContextFlags = CONTEXT_FULL;

    BOOL succ = GetThreadContext(m_handle, &m_context);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::SGH: couldn't get thread context: %d\n", GetLastError()));

        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Remember that we've hijacked the guy.
    SetState(CUTS_GenericHijacked);

#ifdef _X86_
    LOG((LF_CORDB, LL_INFO1000000, "CUT::SGH: Current IP is 0x%08x\n", m_context.Eip));
#elif defined(_ALPHA_)
    LOG((LF_CORDB, LL_INFO1000000, "CUT::SGH: Current IP is 0x%08x\n", m_context.Fir));
#endif // _X86_

    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);

    // Wack the IP over to our generic hijack function.
#ifdef _X86_
    DWORD holdIP = m_context.Eip;
    m_context.Eip = (DWORD)pRO->m_genericHijackFuncAddr;

    LOG((LF_CORDB, LL_INFO1000000, "CUT::SGH: New IP is 0x%08x\n", m_context.Eip));
#elif defined(_ALPHA_)
    DWORD holdIP = m_context.Fir;
    m_context.Fir = (DWORD)pRO->m_genericHijackFuncAddr;

    LOG((LF_CORDB, LL_INFO1000000, "CUT::SGH: New IP is 0x%08x\n", m_context.Fir));
#endif // _X86_

    succ = SetThreadContext(m_handle, &m_context);
            
    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::SGH: couldn't set thread context: %d\n", GetLastError()));

        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Put the original IP back into the local context copy for later.
#ifdef _X86_
    m_context.Eip = holdIP;
#else // !_X86_
    m_context.Fir = holdIP;
#endif // _X86_
    return S_OK;
}
    
HRESULT CordbUnmanagedThread::FixupFromGenericHijack(void)
{
    LOG((LF_CORDB, LL_INFO1000, "CUT::FFGH: fixing up from generic hijack. Eip=0x%08x, Esp=0x%08x\n",
         m_context.Eip, m_context.Esp));
    
    // We're no longer hijacked
    _ASSERTE(IsGenericHijacked());
    ClearState(CUTS_GenericHijacked);

    // Clear the exception so we do a DBG_CONTINUE with the original context. Note: we only do generic hijacks on
    // in-band events.
    IBEvent()->SetState(CUES_ExceptionCleared);

    // Using the context we saved when the event came in originally, reset the thread as if it were never hijacked.
    BOOL succ = SetThreadContext(m_handle, &m_context);
            
    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::FFGH: couldn't set thread context: %d\n", GetLastError()));

        return HRESULT_FROM_WIN32(GetLastError());
    }
                
    return S_OK;
}

#if 0
//
// Leave this here for debugging purposes later. It runs a thread's SEH handler chain from FS:0.
//
void _printChain(void *teb, HANDLE hProcess, DWORD tid, HANDLE hThread)
{
    CONTEXT c;
    c.ContextFlags = CONTEXT_FULL;

    BOOL succ = ::GetThreadContext(hThread, &c);
    
    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO10000, "Couldn't read thread context %d\n", GetLastError()));
        return;
    }

    
    NT_TIB *pTIB = (NT_TIB*) teb;
    NT_TIB tib;

    LOG((LF_CORDB, LL_INFO10000, "\nThread info for 0x%x: TIB is at 0x%08x, ESP=0x%08x\n", tid, teb, c.Esp));

    succ = ReadProcessMemory(hProcess, pTIB, &tib, sizeof(tib), NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO10000, "Couldn't read TIB %d\n", GetLastError()));
        return;
    }

    LOG((LF_CORDB, LL_INFO10000, "ExceptionList=0x%08x StackBase=0x%08x StackLimit=0x%08x SubSystemTib=0x%08x Self=0x%08x\n",
            tib.ExceptionList, tib.StackBase, tib.StackLimit, tib.SubSystemTib, tib.Self));

    EXCEPTION_REGISTRATION_RECORD err;
    EXCEPTION_REGISTRATION_RECORD *pErr = (EXCEPTION_REGISTRATION_RECORD*)tib.ExceptionList;

    while ((void*)pErr != (void*)0xFFFFFFFF)
    {
        succ = ReadProcessMemory(hProcess, pErr, &err, sizeof(err), NULL);

        if (!succ)
        {
            LOG((LF_CORDB, LL_INFO10000, "Couldn't read ER %d\n", GetLastError()));
            return;
        }

        LOG((LF_CORDB, LL_INFO10000, "pERR=0x%08x, Next=0x%08x, Handler=0x%08x\n", pErr, err.Next, err.Handler));
        
        pErr = err.Next;
    }
}
#endif

HRESULT CordbUnmanagedThread::SetupSecondChanceHijack(REMOTE_PTR EETlsValue)
{
    _ASSERTE(!IsSecondChanceHijacked());
    
    // Save the thread's full context.
    m_context.ContextFlags = CONTEXT_FULL;

    BOOL succ = GetThreadContext(m_handle, &m_context);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000,
             "CUT::SSCH: couldn't get thread context: %d\n",
             GetLastError()));

        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Remember that we've hijacked the guy.
    SetState(CUTS_SecondChanceHijacked);

#ifdef _X86_
    LOG((LF_CORDB, LL_INFO1000000, "CUT::SSCH: Current IP/SP is 0x%08x/0x%08x\n", m_context.Eip, m_context.Esp));
#elif defined(_ALPHA_)
    LOG((LF_CORDB, LL_INFO1000000, "CUT::SSCH: Current IP is 0x%08x\n", m_context.Fir));
#endif // _X86_

    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);

    // Wack the IP over to our second chance hijack function.
#ifdef _X86_
    DWORD holdIP = m_context.Eip;
    m_context.Eip = (DWORD)pRO->m_secondChanceHijackFuncAddr;

    LOG((LF_CORDB, LL_INFO1000000, "CUT::SSCH: New IP/SP is 0x%08x/0x%08x\n", m_context.Eip, m_context.Esp));
#elif defined(_ALPHA_)
    DWORD holdIP = m_context.Fir;
    m_context.Fir = (DWORD)pRO->m_secondChanceHijackFuncAddr;

    LOG((LF_CORDB, LL_INFO1000000, "CUT::SSCH: New IP is 0x%08x\n", m_context.Fir));
#endif // _X86_

    // Make sure the trace flag isn't on. This can happen if we were single stepping the thread when we faulted. This
    // will ensure that we don't try to single step through the OS's exception logic, which greatly confuses our second
    // chance hijack logic. This also mimics what the OS does for us automaically when singel stepping in process, i.e.,
    // when you turn the trace flag on in-process and go, if there is a fault, the fault is reported and the trace flag
    // is automatically turned off.
    //
    // Note: we only do this all the time. We can't try to single step through one of our hijacks.
#ifdef _X86_
    // Yank out the trace flag.
    m_context.EFlags &= ~0x100;
#endif            

    succ = SetThreadContext(m_handle, &m_context);
            
    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::SSCH: couldn't set thread context: %d\n", GetLastError()));

        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Put the original IP back into the local context copy for later.
#ifdef _X86_
    m_context.Eip = holdIP;
#else // !_X86_
    m_context.Fir = holdIP;
#endif // _X86_

    // Now, the Runtime plays games with exception records now and then, and it may have stashed a different context
    // into an exception record that has fooled the Win32 GetThreadContext above. So we need to inspect the FS:0 chain
    // and the managed Frame chain and remove any entries that are currently below the current ESP. We can do this
    // safely because we will never try to run code that depends on these elements. (Func evals at the second chance
    // managed exception event are okay because the managed objectrefs are protected by the func eval frame.
    HRESULT hr = FixupStackBasedChains(EETlsValue);
    
    return hr;
}

HRESULT CordbUnmanagedThread::FixupStackBasedChains(REMOTE_PTR EETlsValue)
{
    DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);
    
#ifdef _X86_
    DWORD SP = m_context.Esp;
#else
    // @todo: porting
    DWORD SP = 0;
#endif
    
    // First, lets strip off any SEH handlers that are below SP. Compute the address of the pointer to the thread's
    // exception list.
    void *pExceptionList = (BYTE*) m_threadLocalBase + offsetof(NT_TIB, ExceptionList);
    
    // Read the thread's pointer to the head of the exception list.
    EXCEPTION_REGISTRATION_RECORD *pErr;
    EXCEPTION_REGISTRATION_RECORD *pHeadErr;
    
    BOOL succ = ReadProcessMemoryI(m_process->m_handle, pExceptionList, &pErr, sizeof(EXCEPTION_REGISTRATION_RECORD*), NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::FSBC: failed to read excep head: 0x%08x + 0x%x = 0x%08x, err=%d\n",
             m_threadLocalBase, offsetof(NT_TIB, ExceptionList), pExceptionList, GetLastError()));
        
        return HRESULT_FROM_WIN32(GetLastError());
    }

    pHeadErr = pErr;
    
    LOG((LF_CORDB, LL_INFO1000000, "CUT::FSBC: head err is at 0x%08x for thread 0x%x, ESP is 0x%08x\n", pHeadErr, m_id, SP));

    // Read ERR's until we find one that is higher than the SP.
    while ((DWORD)pErr < SP)
    {
        EXCEPTION_REGISTRATION_RECORD err;

        succ = ReadProcessMemoryI(m_process->m_handle, pErr, &err, sizeof(EXCEPTION_REGISTRATION_RECORD), NULL);

        if (!succ)
        {
            LOG((LF_CORDB, LL_INFO1000, "CUT::FSBC: failed to read excep rec: err=%d\n", GetLastError()));
        
            return HRESULT_FROM_WIN32(GetLastError());
        }

        LOG((LF_CORDB, LL_INFO1000000, "CUT::FSBC: ERR at 0x%08x read, next is at 0x%08x\n", pErr, err.Next));
        pErr = err.Next;
    }

    // We now have a pErr that is on the valid stack. If its different than the current head, go ahead and make it the
    // current head.
    if (pErr != pHeadErr)
    {
        // Write the updated ERR back.
        succ = WriteProcessMemory(m_process->m_handle, pExceptionList, &pErr, sizeof(EXCEPTION_REGISTRATION_RECORD*), NULL);
    
        if (!succ)
        {
            LOG((LF_CORDB, LL_INFO1000, "CUT::FSBC: failed to write updated head handler: err=%d\n", GetLastError()));
        
            return HRESULT_FROM_WIN32(GetLastError());
        }

        LOG((LF_CORDB, LL_INFO1000000, "CUT::FSBC: updated head handler to 0x%08x\n", pErr));
    }
#ifdef LOGGING
    else
        LOG((LF_CORDB, LL_INFO1000000, "CUT::FSBC: no update to SEH chain necessary.\n"));
#endif
    
    // Next, lets strip off any CLR Frames that are below SP.
    void *pEEThreadFrame = (BYTE*) EETlsValue + pRO->m_EEThreadFrameOffset;
    
    // Grab the thread's frame out of the EE Thread.
    void *EEThreadFrame;
    void *HeadFrame;
    
    succ = ReadProcessMemoryI(m_process->m_handle, pEEThreadFrame, &EEThreadFrame, sizeof(EEThreadFrame), NULL);

    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::FSBC: failed to read thread frame: 0x%08x + 0x%x = 0x%08x, err=%d\n",
             EETlsValue, pRO->m_EEThreadFrameOffset, pEEThreadFrame, GetLastError()));
        
        return HRESULT_FROM_WIN32(GetLastError());
    }

    LOG((LF_CORDB, LL_INFO1000000, "CUT::FSBC: EE Thread's frame is 0x%08x\n", EEThreadFrame));

    HeadFrame = EEThreadFrame;

    // Read frame pointers until we find one that is higher than the current SP.
    while ((DWORD)EEThreadFrame < SP)
    {
        // Point to the Next field in the current frame.
        pEEThreadFrame = (BYTE*)EEThreadFrame + pRO->m_EEFrameNextOffset;
        
        succ = ReadProcessMemoryI(m_process->m_handle, pEEThreadFrame, &EEThreadFrame, sizeof(EEThreadFrame), NULL);

        if (!succ)
        {
            LOG((LF_CORDB, LL_INFO1000, "CUT::FSBC: failed to read thread frame: 0x%08x + 0x%x = 0x%08x, err=%d\n",
                 EEThreadFrame, pRO->m_EEFrameNextOffset, pEEThreadFrame, GetLastError()));
        
            return HRESULT_FROM_WIN32(GetLastError());
        }

        LOG((LF_CORDB, LL_INFO1000000, "CUT::FSBC: next frame is 0x%08x\n", EEThreadFrame));
    }

    // We now have a Frame that is on the valid stack. If its different than the current head, go ahead and make it the
    // current head.
    if (EEThreadFrame != HeadFrame)
    {
        // Write the updated Frame back.
        void *pEEThreadFrame = (BYTE*) EETlsValue + pRO->m_EEThreadFrameOffset;
        
        succ = WriteProcessMemory(m_process->m_handle, pEEThreadFrame, &EEThreadFrame, sizeof(EEThreadFrame), NULL);
    
        if (!succ)
        {
            LOG((LF_CORDB, LL_INFO1000, "CUT::FSBC: failed to write updated head frame: err=%d\n", GetLastError()));
        
            return HRESULT_FROM_WIN32(GetLastError());
        }

        LOG((LF_CORDB, LL_INFO1000000, "CUT::FSBC: updated head frame to 0x%08x\n", EEThreadFrame));
    }
#ifdef LOGGING
    else
        LOG((LF_CORDB, LL_INFO1000000, "CUT::FSBC: no update to Frame chain necessary.\n"));
#endif
    
    return S_OK;
}
    
HRESULT CordbUnmanagedThread::DoMoreSecondChanceHijack(void)
{
    _ASSERTE(IsSecondChanceHijacked());

    // Grab the address of the SCD from the Runtime Thread's debugger word.
    REMOTE_PTR EETlsValue = GetEETlsValue();

    DebuggerIPCSecondChanceData *pSCD = (DebuggerIPCSecondChanceData*)GetEEThreadDebuggerWord(EETlsValue);
    _ASSERTE(pSCD != NULL);

    LOG((LF_CORDB, LL_INFO1000, "CUT::DMSCH: SCD is at 0x%08x, size is 0x%x\n", pSCD, sizeof(CONTEXT)));

    // Write over the thread's context from when it faulted.
    BOOL succ = WriteProcessMemory(m_process->m_handle, pSCD, &m_context, sizeof(CONTEXT), NULL);
    
    if (!succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CUT::DMSCH: failed to write thread context: 0x%08x, 0x%08x, err=%d\n",
             pSCD, &m_context, GetLastError()));
            
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

DWORD CordbUnmanagedThread::GetEEThreadDebuggerWord(REMOTE_PTR EETlsValue)
{
    DWORD ret = NULL;
    
    // If the TLS value has the low bit set, then it is the debugger word. Otherwise, its a ptr to an EE Thread object
    // which we need to suck the word out of.
    if (((UINT_PTR)EETlsValue) & 0x01)
        ret = ((DWORD)EETlsValue) & ~0x01;
    else if (EETlsValue == NULL)
        ret = NULL;
    else
    {
        // Compute the address of the debugger word #2.
        DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);
        void *pEEDebuggerWord = (BYTE*) EETlsValue + pRO->m_EEThreadDebuggerWord2Offset;

        // Update the word.
        BOOL succ = ReadProcessMemoryI(m_process->m_handle, pEEDebuggerWord, &ret, sizeof(DWORD), NULL);
    
        if (!succ)
        {
            LOG((LF_CORDB, LL_INFO1000, "CUT::GEETDW: failed to read debugger word: 0x%08x + 0x%x = 0x%08x, err=%d\n",
                 EETlsValue, pRO->m_EEThreadDebuggerWord2Offset, pEEDebuggerWord, GetLastError()));
        
            return NULL;
        }
    }
    
    LOG((LF_CORDB, LL_INFO1000000, "CUT::GEETDW: debugger word is 0x%08x for thread 0x%x\n", ret, m_id));

    return ret;
}

HRESULT CordbUnmanagedThread::SetEEThreadDebuggerWord(REMOTE_PTR EETlsValue, DWORD word)
{
    HRESULT hr = S_OK;
    
    // If the TLS value is NULL, then it is the debugger word.  Otherwise, its a ptr to an EE Thread object which we
    // need to suck the word out of.
    if ((EETlsValue == NULL) || ((UINT_PTR)EETlsValue & 0x01))
    {
        if (word != 0)
            word |= 0x01;
    
        hr = SetEETlsValue((REMOTE_PTR)word);
    }
    else
    {
        // Compute the address of the debugger word #2.
        DebuggerIPCRuntimeOffsets *pRO = &(m_process->m_runtimeOffsets);
        void *pEEDebuggerWord = (BYTE*) EETlsValue + pRO->m_EEThreadDebuggerWord2Offset;

        // Update the word.
        BOOL succ = WriteProcessMemory(m_process->m_handle, pEEDebuggerWord, &word, sizeof(DWORD), NULL);
    
        if (!succ)
        {
            LOG((LF_CORDB, LL_INFO1000, "CUT::SEETDW: failed to write debugger word: 0x%08x + 0x%x = 0x%08x, err=%d\n",
                 EETlsValue, pRO->m_EEThreadDebuggerWord2Offset, pEEDebuggerWord, GetLastError()));
            
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    LOG((LF_CORDB, LL_INFO1000000, "CUT::SEETDW: debugger word is now 0x%08x for thread 0x%x\n", word, m_id));

    return hr;
}

//
// FixupAfterOOBException automatically gets the debuggee past an OOB exception event. These are only BP or SS
// events. For SS, we just clear it, assuming that the only reason the thread was stepped in such place was to get it
// off of a BP. For a BP, we clear and backup the IP by one, and turn the trace flag on under the assumption that the
// only thing a debugger is allowed to do with an OOB BP exception is to get us off of it.
//
HRESULT CordbUnmanagedThread::FixupAfterOOBException(CordbUnmanagedEvent *ue)
{
    // We really should only be doing things to single steps and breakpoint exceptions.
    if (ue->m_currentDebugEvent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
    {
        DWORD ec = ue->m_currentDebugEvent.u.Exception.ExceptionRecord.ExceptionCode;
        
        if ((ec == STATUS_BREAKPOINT) || (ec == STATUS_SINGLE_STEP))
        {
            // Automatically clear the exception.
            ue->SetState(CUES_ExceptionCleared);

            // If its a breakpoint exception, then we backup Eip by one and turn on the trace flag.
            if (ec == STATUS_BREAKPOINT)
            {
                CONTEXT c;
                c.ContextFlags = CONTEXT_FULL;
                
                BOOL succ = ::GetThreadContext(m_handle, &c);

                if (!succ)
                    return HRESULT_FROM_WIN32(GetLastError());

#ifdef _X86_
                // Enable single step
                c.EFlags |= 0x100;

                // Backup Eip to point to the instruction we need to execute. Continuing from a breakpoint exception
                // continues execution at the instruction after the breakpoint, but we need to continue where the
                // breakpoint was.
                c.Eip -= 1;
#else // !_X86_
                _ASSERTE(!"@TODO Alpha - port");
#endif // _X86_

                succ = ::SetThreadContext(m_handle, &c);

                if (!succ)
                    return HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    
    return S_OK;
}

/* ------------------------------------------------------------------------- *
 * Chain class
 * ------------------------------------------------------------------------- */

CordbChain::CordbChain(CordbThread* thread, bool managed,
                       CordbFrame **start, CordbFrame **end, UINT iChainInThread) 
  : CordbBase(0, enumCordbChain), 
    m_thread(thread), 
    m_managed(managed),
    m_start(start), m_end(end), 
    m_caller(NULL),m_callee(NULL), m_iThisChain(iChainInThread)
{
}

/*
    A list of which resources owened by this object are accounted for.

    UNRESOLVED:
        CordbChain              *m_caller, *m_callee;
        CordbFrame             **m_start, **m_end;
        
    RESOLVED:
        CordbThread             *m_thread;              // Neutered
*/

CordbChain::~CordbChain()
{
}

// Neutered by CordbThread::CleanupStack
void CordbChain::Neuter()
{
    AddRef();
    {
        CordbBase::Neuter();
    }
    Release();
}


HRESULT CordbChain::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugChain)
        *pInterface = (ICorDebugChain*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugChain*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbChain::GetThread(ICorDebugThread **ppThread)
{
    VALIDATE_POINTER_TO_OBJECT(ppThread, ICorDebugThread **);
    
    *ppThread = (ICorDebugThread*)m_thread;
    (*ppThread)->AddRef();

    return S_OK;
}

HRESULT CordbChain::GetStackRange(CORDB_ADDRESS *pStart, CORDB_ADDRESS *pEnd)
{
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pStart, CORDB_ADDRESS *);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pEnd, CORDB_ADDRESS *);

#ifdef _X86_
    if (pStart)
        *pStart = m_rd.Esp;

    if (pEnd && m_id == 0xFFFFFFFF)
        *pEnd = PTR_TO_CORDB_ADDRESS(m_thread->m_stackBase);
    else if (pEnd)
        *pEnd = m_id;
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - GetStackRange (Thread.cpp)");
#endif // _X86_

#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    return S_OK;
#endif
}

HRESULT CordbChain::GetContext(ICorDebugContext **ppContext)
{
    VALIDATE_POINTER_TO_OBJECT(ppContext, ICorDebugContext **);
    /* !!! */

    return E_NOTIMPL;
}

HRESULT CordbChain::GetCaller(ICorDebugChain **ppChain)
{
    VALIDATE_POINTER_TO_OBJECT(ppChain, ICorDebugChain **);

    INPROC_LOCK();
    
    // For now, just return the next chain

    HRESULT hr = GetNext(ppChain);

    INPROC_UNLOCK();

    return hr;
}

HRESULT CordbChain::GetCallee(ICorDebugChain **ppChain)
{
    VALIDATE_POINTER_TO_OBJECT(ppChain, ICorDebugChain **);

    INPROC_LOCK();

    // For now, just return the previous chain

    HRESULT hr = GetPrevious(ppChain);

    INPROC_UNLOCK();    

    return hr;
}

HRESULT CordbChain::GetPrevious(ICorDebugChain **ppChain)
{
    VALIDATE_POINTER_TO_OBJECT(ppChain, ICorDebugChain **);

    INPROC_LOCK();

    *ppChain = NULL;
    if (m_iThisChain != 0)
        *ppChain = m_thread->m_stackChains[m_iThisChain-1];

    if (*ppChain != NULL )
        (*ppChain)->AddRef();

    INPROC_UNLOCK();

    return S_OK;
}

HRESULT CordbChain::GetNext(ICorDebugChain **ppChain)
{
    VALIDATE_POINTER_TO_OBJECT(ppChain, ICorDebugChain **);

    INPROC_LOCK();  
    
    *ppChain = NULL;
    if (m_iThisChain+1 != m_thread->m_stackChainCount)
        *ppChain = m_thread->m_stackChains[m_iThisChain+1];

    if (*ppChain != NULL )
        (*ppChain)->AddRef();

    INPROC_UNLOCK();

    return S_OK;
}

HRESULT CordbChain::IsManaged(BOOL *pManaged)
{
    VALIDATE_POINTER_TO_OBJECT(pManaged, BOOL *);

    *pManaged = m_managed;

    return S_OK;
}

HRESULT CordbChain::EnumerateFrames(ICorDebugFrameEnum **ppFrames)
{
    VALIDATE_POINTER_TO_OBJECT(ppFrames, ICorDebugFrameEnum **);

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    CordbFrameEnum* e = new CordbFrameEnum(this);
    this->AddRef();

    if (e != NULL)
    {
        *ppFrames = (ICorDebugFrameEnum*)e;
        e->AddRef();
    }
    else
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT CordbChain::GetActiveFrame(ICorDebugFrame **ppFrame)
{
    VALIDATE_POINTER_TO_OBJECT(ppFrame, ICorDebugFrame **);
    (*ppFrame) = NULL;

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    INPROC_LOCK();

    HRESULT hr = S_OK;

    //
    // Refresh the stack frames for this thread.
    //
    hr = m_thread->RefreshStack();

    if (FAILED(hr))
        goto LExit;

#ifdef RIGHT_SIDE_ONLY
    _ASSERTE( m_start != NULL && *m_start != NULL );
#endif //RIGHT_SIDE_ONLY    

    if (m_end <= m_start
#ifndef RIGHT_SIDE_ONLY
        || m_start == NULL
        || m_start == m_end
        || *m_start == NULL
#endif
        )
        *ppFrame = NULL;
    else
    {
        (*ppFrame) = (ICorDebugFrame*)*m_start;
        (*ppFrame)->AddRef();
    }

    
LExit:    

    INPROC_UNLOCK();
    return hr;
}

HRESULT CordbChain::GetRegisterSet(ICorDebugRegisterSet **ppRegisters)
{
    VALIDATE_POINTER_TO_OBJECT(ppRegisters, ICorDebugRegisterSet **);

    CordbThread *thread = m_thread;

    CordbRegisterSet *pRegisterSet 
      = new CordbRegisterSet( &m_rd, thread, 
                              m_iThisChain == 0,
                              m_quicklyUnwound);

    if( pRegisterSet == NULL )
        return E_OUTOFMEMORY;

    pRegisterSet->AddRef();

    (*ppRegisters) = (ICorDebugRegisterSet *)pRegisterSet;
    return S_OK;
}

HRESULT CordbChain::GetReason(CorDebugChainReason *pReason)
{
    VALIDATE_POINTER_TO_OBJECT(pReason, CorDebugChainReason *);

    *pReason = m_reason;

    return S_OK;
}

/* ------------------------------------------------------------------------- *
 * Chain Enumerator class
 * ------------------------------------------------------------------------- */

CordbChainEnum::CordbChainEnum(CordbThread *thread)
  : CordbBase(0, enumCordbChainEnum),
    m_thread(thread), 
    m_currentChain(0)
{
}

HRESULT CordbChainEnum::Reset(void)
{
    m_currentChain = 0;

    return S_OK;
}

HRESULT CordbChainEnum::Clone(ICorDebugEnum **ppEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppEnum, ICorDebugEnum **);

    HRESULT hr = S_OK;
    INPROC_LOCK();
        
    CordbChainEnum *e = new CordbChainEnum(m_thread);

    if (e == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }
    
    e->m_currentChain = m_currentChain;
    e->AddRef();

    *ppEnum = (ICorDebugEnum*)e;

LExit:
    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbChainEnum::GetCount(ULONG *pcelt)
{
    VALIDATE_POINTER_TO_OBJECT(pcelt, ULONG *);
    
    *pcelt = m_thread->m_stackChainCount;
    return S_OK;
}

HRESULT CordbChainEnum::Next(ULONG celt, ICorDebugChain *chains[], 
                             ULONG *pceltFetched)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(chains, ICorDebugChain *, 
        celt, true, true);
    VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

    if (!pceltFetched && (celt != 1))
        return E_INVALIDARG;

    INPROC_LOCK();
    
    ICorDebugChain **c = chains;

    while ((m_currentChain < m_thread->m_stackChainCount) &&
           (celt-- > 0))
    {
        *c = (ICorDebugChain*) m_thread->m_stackChains[m_currentChain];
        (*c)->AddRef();
        c++;
        m_currentChain++;
    }

    if (pceltFetched)
        *pceltFetched = c - chains;

    INPROC_UNLOCK();

    return S_OK;
}

HRESULT CordbChainEnum::Skip(ULONG celt)
{
    INPROC_LOCK();

    m_currentChain += celt;

    INPROC_UNLOCK();
    
    return S_OK;
}

HRESULT CordbChainEnum::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugChainEnum)
        *pInterface = (ICorDebugChainEnum*)this;
    else if (id == IID_ICorDebugEnum)
        *pInterface = (ICorDebugEnum*)(ICorDebugChainEnum*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugChainEnum*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbContext::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugContext)
        *pInterface = (ICorDebugContext*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugContext*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

    
/* ------------------------------------------------------------------------- *
 * Frame class
 * ------------------------------------------------------------------------- */

CordbFrame::CordbFrame(CordbChain *chain, void *id,
                       CordbFunction *function, CordbCode* code,
                       SIZE_T ip, UINT iFrameInChain,
                       CordbAppDomain *currentAppDomain)
  : CordbBase((UINT_PTR)id, enumCordbFrame), 
    m_chain(chain), m_function(function), m_code(code),
    m_ip(ip), m_iThisFrame(iFrameInChain), m_thread(chain->m_thread),
    m_currentAppDomain(currentAppDomain)
{
    if (m_code)
        m_code->AddRef();
}

/*
    A list of which resources owened by this object are accounted for.

    UNKNOWN:
        CordbThread            *m_thread;
        CordbFunction          *m_function;
        CordbChain             *m_chain;
        CordbAppDomain         *m_currentAppDomain;
        
    RESOLVED:
        CordbCode              *m_code; // Neutered
*/

CordbFrame::~CordbFrame()
{
}

// Neutered by DerivedClasses
void CordbFrame::Neuter()
{
    AddRef();
    {    
        if (m_code)
        {
            m_code->Neuter();
            m_code->Release();
        } 
        
        CordbBase::Neuter();
    }
    Release();
}


HRESULT CordbFrame::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugFrame)
        *pInterface = (ICorDebugFrame*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugFrame*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbFrame::GetChain(ICorDebugChain **ppChain)
{
    VALIDATE_POINTER_TO_OBJECT(ppChain, ICorDebugChain **);

    *ppChain = (ICorDebugChain*)m_chain;
    (*ppChain)->AddRef();

    return S_OK;
}

HRESULT CordbFrame::GetCode(ICorDebugCode **ppCode)
{
    VALIDATE_POINTER_TO_OBJECT(ppCode, ICorDebugCode **);
    
    *ppCode = (ICorDebugCode*)m_code;
    (*ppCode)->AddRef();

    return S_OK;;
}

HRESULT CordbFrame::GetStackRange(CORDB_ADDRESS *pStart, CORDB_ADDRESS *pEnd)
{
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pStart, CORDB_ADDRESS *);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pEnd, CORDB_ADDRESS *);

    return E_NOTIMPL;
}

HRESULT CordbFrame::GetFunction(ICorDebugFunction **ppFunction)
{
    VALIDATE_POINTER_TO_OBJECT(ppFunction, ICorDebugFunction **);
    
    *ppFunction = (ICorDebugFunction*)m_function;
    (*ppFunction)->AddRef();

    return S_OK;
}

HRESULT CordbFrame::GetFunctionToken(mdMethodDef *pToken)
{
    VALIDATE_POINTER_TO_OBJECT(pToken, mdMethodDef *);
    
    *pToken = m_function->m_token;

    return S_OK;
}

HRESULT CordbFrame::GetCaller(ICorDebugFrame **ppFrame)
{
    VALIDATE_POINTER_TO_OBJECT(ppFrame, ICorDebugFrame **);

    *ppFrame = NULL;

    CordbFrame **nextFrame = m_chain->m_start + m_iThisFrame + 1;
    if (nextFrame < m_chain->m_end)
        *ppFrame = *nextFrame;

    if (*ppFrame != NULL )
        (*ppFrame)->AddRef();
    
    return S_OK;
}

HRESULT CordbFrame::GetCallee(ICorDebugFrame **ppFrame)
{
    VALIDATE_POINTER_TO_OBJECT(ppFrame, ICorDebugFrame **);

    *ppFrame = NULL;

    if (m_iThisFrame == 0)
        *ppFrame = NULL;
    else
        *ppFrame = m_chain->m_start[m_iThisFrame - 1];

    if (*ppFrame != NULL )
        (*ppFrame)->AddRef();
    
    return S_OK;
}

HRESULT CordbFrame::CreateStepper(ICorDebugStepper **ppStepper)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    
    VALIDATE_POINTER_TO_OBJECT(ppStepper, ICorDebugStepper **);
    
    CordbStepper *stepper = new CordbStepper(m_chain->m_thread, this);

    if (stepper == NULL)
        return E_OUTOFMEMORY;

    stepper->AddRef();
    *ppStepper = stepper;

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

/* ------------------------------------------------------------------------- *
 * Frame Enumerator class
 * ------------------------------------------------------------------------- */

CordbFrameEnum::CordbFrameEnum(CordbChain *chain)
  : CordbBase(0, enumCordbFrameEnum),
    m_chain(chain), 
    m_currentFrame(NULL)
{
    _ASSERTE(m_chain != NULL);
    m_currentFrame = m_chain->m_start;
}

CordbFrameEnum::~CordbFrameEnum()
{
    if (NULL != m_chain)
        m_chain->Release();
}

HRESULT CordbFrameEnum::Reset(void)
{
    INPROC_LOCK();
    
    _ASSERTE(m_chain != NULL);
    m_currentFrame = m_chain->m_start;

    INPROC_UNLOCK();

    return S_OK;
}

HRESULT CordbFrameEnum::Clone(ICorDebugEnum **ppEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppEnum, ICorDebugEnum **);

    HRESULT hr = S_OK;
    INPROC_LOCK();
    
    CordbFrameEnum *e = new CordbFrameEnum(m_chain);
    m_chain->AddRef();

    if (e == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    e->m_currentFrame = m_currentFrame;
    e->AddRef();
    
    *ppEnum = (ICorDebugEnum*)e;

LExit:
    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbFrameEnum::GetCount(ULONG *pcelt)
{
    VALIDATE_POINTER_TO_OBJECT(pcelt, ULONG *);

    INPROC_LOCK();
    
    *pcelt = m_chain->m_end - m_chain->m_start;

    INPROC_UNLOCK();
    
    return S_OK;
}

HRESULT CordbFrameEnum::Next(ULONG celt, ICorDebugFrame *frames[], 
                             ULONG *pceltFetched)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(frames, ICorDebugFrame *, 
        celt, true, true);
    VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

    if (!pceltFetched && (celt != 1))
        return E_INVALIDARG;

    INPROC_LOCK();
    
    ICorDebugFrame **f = frames;

    while ((m_currentFrame < m_chain->m_end) && (celt-- > 0))
    {
        *f = (ICorDebugFrame*) *m_currentFrame;
        (*f)->AddRef();
        f++;
        m_currentFrame++;
    }

    if (pceltFetched)
        *pceltFetched = f - frames;

    INPROC_UNLOCK();
    
    return S_OK;
}

HRESULT CordbFrameEnum::Skip(ULONG celt)
{
    INPROC_LOCK();

    while ((m_currentFrame < m_chain->m_end) && (celt-- > 0))
        m_currentFrame++;

    INPROC_UNLOCK();

    return S_OK;
}

HRESULT CordbFrameEnum::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugFrameEnum)
        *pInterface = (ICorDebugFrameEnum*)this;
    else if (id == IID_ICorDebugEnum)
        *pInterface = (ICorDebugEnum*)(ICorDebugFrameEnum*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugFrameEnum*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
    
/* ------------------------------------------------------------------------- *
 * IL Frame class
 * ------------------------------------------------------------------------- */

CordbILFrame::CordbILFrame(CordbChain *chain, void *id,
                           CordbFunction *function, CordbCode* code,
                           SIZE_T ip, void* sp, const void **localMap,
                           void* argMap, void* frameToken, bool active,
                           CordbAppDomain *currentAppDomain) 
  : CordbFrame(chain, id, function, code, ip, active, currentAppDomain),
    m_sp(sp), m_localMap(localMap), m_argMap(argMap),
    m_frameToken(frameToken)
{
}

CordbILFrame::~CordbILFrame()
{
}

HRESULT CordbILFrame::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugFrame)
        *pInterface = (ICorDebugFrame*)(ICorDebugILFrame*)this;
    else if (id == IID_ICorDebugILFrame)
        *pInterface = (ICorDebugILFrame*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugILFrame*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbILFrame::GetIP(ULONG32 *pnOffset,
                            CorDebugMappingResult *pMappingResult)
{
    VALIDATE_POINTER_TO_OBJECT(pnOffset, ULONG32 *);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pMappingResult, CorDebugMappingResult *);
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    *pnOffset = m_ip;
    if (pMappingResult)
        *pMappingResult = MAPPING_EXACT; // A pure-IL frame is always exact...

    return S_OK;
}

HRESULT CordbILFrame::CanSetIP(ULONG32 nOffset)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    // @todo Since CordbILFrames aren't used any more, no implementation of
    // SetIP
    // was provided
    
    return E_NOTIMPL;
#endif //RIGHT_SIDE_ONLY    
}


HRESULT CordbILFrame::SetIP(ULONG32 nOffset)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    // @todo Since CordbILFrames aren't used any more, no implementation of
    // SetIP
    // was provided

    return E_NOTIMPL;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbILFrame::EnumerateLocalVariables(ICorDebugValueEnum **ppValueEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppValueEnum, ICorDebugValueEnum **);

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    ICorDebugValueEnum *icdVE = new CordbValueEnum( (CordbFrame*)this,
                   CordbValueEnum::LOCAL_VARS, CordbValueEnum::IL_FRAME);
    
    if ( icdVE == NULL )
    {
        (*ppValueEnum) = NULL;
        return E_OUTOFMEMORY;
    }
    
    (*ppValueEnum) = (ICorDebugValueEnum*)icdVE;
    icdVE->AddRef();
    return S_OK;
}

HRESULT CordbILFrame::GetLocalVariable(DWORD dwIndex, ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    // Get the type of this argument from the function
    PCCOR_SIGNATURE pvSigBlob;
    ULONG cbSigBlob;

    HRESULT hr = m_function->GetArgumentType(dwIndex, &cbSigBlob, &pvSigBlob);

    if (!SUCCEEDED(hr))
        return hr;
    
    //
    // local map address indexed by dwIndex gives us the address of the
    // pointer to the local variable.
    //
    CordbProcess *process = m_function->m_module->m_process;
    REMOTE_PTR ppRmtLocalValue = &(((const void**) m_localMap)[dwIndex]);

    REMOTE_PTR pRmtLocalValue;
    BOOL succ = ReadProcessMemoryI(process->m_handle,
                                  ppRmtLocalValue,
                                  &pRmtLocalValue,
                                  sizeof(void*),
                                  NULL);

    if (!succ)
        return HRESULT_FROM_WIN32(GetLastError());

    ICorDebugValue* pValue;
    hr = CordbValue::CreateValueByType(GetCurrentAppDomain(),
                                       m_function->GetModule(),
                                       cbSigBlob, pvSigBlob,
                                       NULL,
                                       pRmtLocalValue, NULL,
                                       false,
                                       NULL,
                                       NULL,
                                       &pValue);

    if (SUCCEEDED(hr))
        *ppValue = pValue;
    
    return hr;
}

HRESULT CordbILFrame::GetLocalVariableWithType(ULONG cbSigBlob,
                                               PCCOR_SIGNATURE pvSigBlob,
                                               DWORD dwIndex, 
                                               ICorDebugValue **ppValue)
{
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        cbSigBlob -= cb;
        pvSigBlob = &pvSigBlob[cb];
    }

    //
    // local map address indexed by dwIndex gives us the address of the
    // pointer to the local variable.
    //
    CordbProcess *process = m_function->m_module->m_process;
    REMOTE_PTR ppRmtLocalValue = &(((const void**) m_localMap)[dwIndex]);

    REMOTE_PTR pRmtLocalValue;
    BOOL succ = ReadProcessMemoryI(process->m_handle,
                                  ppRmtLocalValue,
                                  &pRmtLocalValue,
                                  sizeof(void*),
                                  NULL);

    if (!succ)
        return HRESULT_FROM_WIN32(GetLastError());

    ICorDebugValue* pValue;
    HRESULT hr = CordbValue::CreateValueByType(GetCurrentAppDomain(),
                                               m_function->GetModule(),
                                               cbSigBlob, pvSigBlob,
                                               NULL,
                                               pRmtLocalValue, NULL,
                                               false,
                                               NULL,
                                               NULL,
                                               &pValue);

    if (SUCCEEDED(hr))
        *ppValue = pValue;
    
    return hr;
}

HRESULT CordbILFrame::EnumerateArguments(ICorDebugValueEnum **ppValueEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppValueEnum, ICorDebugValueEnum **);

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

  
    ICorDebugValueEnum *icdVE = new CordbValueEnum( (CordbFrame*)this,
                    CordbValueEnum::ARGS, CordbValueEnum::IL_FRAME);
    if ( icdVE == NULL )
    {
        (*ppValueEnum) = NULL;
        return E_OUTOFMEMORY;
    }
    
    (*ppValueEnum) = (ICorDebugValueEnum*)icdVE;
    icdVE->AddRef();
    return S_OK;
}

HRESULT CordbILFrame::GetArgument(DWORD dwIndex, ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    // Get the type of this argument from the function
    PCCOR_SIGNATURE pvSigBlob;
    ULONG cbSigBlob;

    HRESULT hr = m_function->GetArgumentType(dwIndex, &cbSigBlob, &pvSigBlob);

    if (!SUCCEEDED(hr))
        return hr;
    
    //
    // arg map address indexed by dwIndex gives us the address of the
    // pointer to the argument.
    //
    CordbProcess *process = m_function->m_module->m_process;
    REMOTE_PTR ppRmtArgValue = &(((const void**) m_argMap)[dwIndex]);

    REMOTE_PTR pRmtArgValue;
    BOOL succ = ReadProcessMemoryI(process->m_handle,
                                  ppRmtArgValue,
                                  &pRmtArgValue,
                                  sizeof(void*),
                                  NULL);

    if (!succ)
        return HRESULT_FROM_WIN32(GetLastError());

    ICorDebugValue* pValue;
    hr = CordbValue::CreateValueByType(GetCurrentAppDomain(),
                                       m_function->GetModule(),
                                       cbSigBlob, pvSigBlob,
                                       NULL,
                                       pRmtArgValue, NULL,
                                       false,
                                       NULL,
                                       NULL,
                                       &pValue);

    if (SUCCEEDED(hr))
        *ppValue = pValue;
    else
        *ppValue = NULL;
    
    return hr;
}

HRESULT CordbILFrame::GetArgumentWithType(ULONG cbSigBlob,
                                          PCCOR_SIGNATURE pvSigBlob,
                                          DWORD dwIndex, 
                                          ICorDebugValue **ppValue)
{
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        cbSigBlob -= cb;
        pvSigBlob = &pvSigBlob[cb];
    }

    //
    // arg map address indexed by dwIndex gives us the address of the
    // pointer to the argument.
    //
    CordbProcess *process = m_function->m_module->m_process;
    REMOTE_PTR ppRmtArgValue = &(((const void**) m_argMap)[dwIndex]);

    REMOTE_PTR pRmtArgValue;
    BOOL succ = ReadProcessMemoryI(process->m_handle,
                                  ppRmtArgValue,
                                  &pRmtArgValue,
                                  sizeof(void*),
                                  NULL);

    if (!succ)
        return HRESULT_FROM_WIN32(GetLastError());

    ICorDebugValue* pValue;
    HRESULT hr = CordbValue::CreateValueByType(GetCurrentAppDomain(),
                                               m_function->GetModule(),
                                               cbSigBlob, pvSigBlob,
                                               NULL,
                                               pRmtArgValue, NULL,
                                               false,
                                               NULL,
                                               NULL,
                                               &pValue);

    if (SUCCEEDED(hr))
        *ppValue = pValue;
    else
        *ppValue = NULL;
    
    return hr;
}

HRESULT CordbILFrame::GetStackDepth(ULONG32 *pDepth)
{
    VALIDATE_POINTER_TO_OBJECT(pDepth, ULONG32 *);
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    /* !!! */

    return E_NOTIMPL;
}

HRESULT CordbILFrame::GetStackValue(DWORD dwIndex, ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    /* !!! */

    return E_NOTIMPL;
}

/* ------------------------------------------------------------------------- *
 * Value Enumerator class
 *
 * Used by CordbJITILFrame for EnumLocalVars & EnumArgs.
 * NOTE NOTE NOTE WE ASSUME THAT when a frameSrc of type JIT_IL_FRAME is used,
 * that the 'frame' argument is actually the CordbJITILFrame's native frame
 * member variable.
 * ------------------------------------------------------------------------- */

CordbValueEnum::CordbValueEnum(CordbFrame *frame, ValueEnumMode mode,
                               ValueEnumFrameSource frameSrc) :
    CordbBase(0)
{
    _ASSERTE( frame != NULL );
    _ASSERTE( mode == LOCAL_VARS || mode ==ARGS);
    
    m_frame = frame;
    m_frameSrc = frameSrc;
    m_mode = mode;
    m_iCurrent = 0;
    switch  (mode)
    {
    case ARGS:  
        {
            //sig is lazy-loaded: force it to be there
            m_frame->m_function->LoadSig();
            m_iMax = frame->m_function->m_argCount;

            if (frameSrc == JIT_IL_FRAME)
            {
                CordbNativeFrame *nil = (CordbNativeFrame*)frame;
                CordbJITILFrame *jil = nil->m_JITILFrame;

                if (jil->m_fVarArgFnx && jil->m_sig != NULL)
                    m_iMax = jil->m_argCount;
                else
                    m_iMax = frame->m_function->m_argCount;
            }
            break;
        }
    case LOCAL_VARS:
        {
            //locals are lazy-loaded: force them to be there
            m_frame->m_function->LoadLocalVarSig();
            m_iMax = m_frame->m_function->m_localVarCount;
            break;
        }   
    }
}

HRESULT CordbValueEnum::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugEnum)
        *pInterface = (ICorDebugEnum*)this;
    else if (id == IID_ICorDebugValueEnum)
        *pInterface = (ICorDebugValueEnum*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugValueEnum*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbValueEnum::Skip(ULONG celt)
{
    INPROC_LOCK();

    HRESULT hr = E_FAIL;
    if ( (m_iCurrent+celt) < m_iMax ||
         celt == 0)
    {
        m_iCurrent += celt;
        hr = S_OK;
    }

    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbValueEnum::Reset(void)
{
    m_iCurrent = 0;
    return S_OK;
}

HRESULT CordbValueEnum::Clone(ICorDebugEnum **ppEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppEnum, ICorDebugEnum **);

    HRESULT hr = S_OK;
    INPROC_LOCK();
    
    CordbValueEnum *pCVE = new CordbValueEnum( m_frame, m_mode, m_frameSrc );
    if ( pCVE == NULL )
    {
        (*ppEnum) = NULL;
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    pCVE->AddRef();
    (*ppEnum) = (ICorDebugEnum*)pCVE;

LExit:
    INPROC_UNLOCK();
    
    return hr;
}

HRESULT CordbValueEnum::GetCount(ULONG *pcelt)
{
    VALIDATE_POINTER_TO_OBJECT(pcelt, ULONG *);
    
    if( pcelt == NULL)
        return E_INVALIDARG;
    
    (*pcelt) = m_iMax;
    return S_OK;
}

//
// In the event of failure, the current pointer will be left at
// one element past the troublesome element.  Thus, if one were
// to repeatedly ask for one element to iterate through the
// array, you would iterate exactly m_iMax times, regardless
// of individual failures.
HRESULT CordbValueEnum::Next(ULONG celt, ICorDebugValue *values[], ULONG *pceltFetched)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(values, ICorDebugValue *, 
        celt, true, true);
    VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

    if (!pceltFetched && (celt != 1))
        return E_INVALIDARG;
    
    HRESULT hr = S_OK;

    INPROC_LOCK();
    
    //The tricky/stupid thing about this class is that we want one class
    //for EnumLocals,EnumArgs, both JITILframe & ILframe. We want to
    //invoke the correct argument off of either the CordbJITILFrame/ILFrame
    int iMax = min( m_iMax, m_iCurrent+celt);
    for ( int i = m_iCurrent; i< iMax;i++)
    {
        switch ( m_mode ) {
        case ARGS:
            {
                switch ( m_frameSrc ) {
                case JIT_IL_FRAME:
                    {
                        hr = (((CordbNativeFrame*)m_frame)->m_JITILFrame)
                                   ->GetArgument( i, &(values[i-m_iCurrent]) );
                        break;
                    }
                case IL_FRAME:
                    {
                        hr = ((CordbILFrame*)m_frame)
                            ->GetArgument( i, &(values[i-m_iCurrent]) );
                        break;
                    }
                }
                break;
            }
        case LOCAL_VARS:
            {
                switch ( m_frameSrc ) {
                case JIT_IL_FRAME:
                    {
                        hr = (((CordbNativeFrame*)m_frame)->m_JITILFrame)
                              ->GetLocalVariable( i, &(values[i-m_iCurrent]) );
                        break;
                    }
                case IL_FRAME:
                    {
                        hr = ((CordbILFrame*)m_frame)
                            ->GetLocalVariable( i, &(values[i-m_iCurrent]) );
                        break;
                    }
                }
                break;
            }
        }
        if ( FAILED( hr ) )
            break;
    }

    int count = (i - m_iCurrent);
    
    if ( FAILED( hr ) )
    {   //we failed: +1 pushes us past troublesome element
        m_iCurrent += 1 + count;
    }
    else
    {
        m_iCurrent += count;
    }

    if (pceltFetched)
        *pceltFetched = count;
    
    INPROC_UNLOCK();
    
    return hr;
}




/* ------------------------------------------------------------------------- *
 * Native Frame class
 * ------------------------------------------------------------------------- */


CordbNativeFrame::CordbNativeFrame(CordbChain *chain, void *id,
                                   CordbFunction *function, CordbCode* code,
                                   SIZE_T ip, DebuggerREGDISPLAY* rd,
                                   bool quicklyUnwound, 
                                   UINT iFrameInChain,
                                   CordbAppDomain *currentAppDomain) 
  : CordbFrame(chain, id, function, code, ip, iFrameInChain, currentAppDomain),
    m_rd(*rd), m_quicklyUnwound(quicklyUnwound), m_JITILFrame(NULL)
{
}

/*
    A list of which resources owened by this object are accounted for.

    RESOLVED:
        CordbJITILFrame*   m_JITILFrame; // Neutered
*/

CordbNativeFrame::~CordbNativeFrame()
{    
}

// Neutered by CordbThread::CleanupStack
void CordbNativeFrame::Neuter()
{
    AddRef();
    {
        if (m_JITILFrame != NULL)
        {
            // AddRef() called in CordbThread::RefreshStack before being assigned to
            // CordbNativeFrame::m_JITILFrame by RefreshStack.
            // AddRef() is called there so we release it here...
            m_JITILFrame->Neuter();
            m_JITILFrame->Release();
        }
        
        CordbFrame::Neuter();
    }
    Release();
}

HRESULT CordbNativeFrame::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugFrame)
        *pInterface = (ICorDebugFrame*)(ICorDebugNativeFrame*)this;
    else if (id == IID_ICorDebugNativeFrame)
        *pInterface = (ICorDebugNativeFrame*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugNativeFrame*)this;
    else if ((id == IID_ICorDebugILFrame) && (m_JITILFrame != NULL))
    {
        *pInterface = (ICorDebugILFrame*)m_JITILFrame;
        m_JITILFrame->AddRef();
        return S_OK;
    }
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbNativeFrame::GetIP(ULONG32 *pnOffset)
{
    VALIDATE_POINTER_TO_OBJECT(pnOffset, ULONG32 *);
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    *pnOffset = m_ip;

    return S_OK;
}

HRESULT CordbNativeFrame::CanSetIP(ULONG32 nOffset)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    _ASSERTE(m_chain->m_thread->m_stackFrames != NULL &&
             m_chain->m_thread->m_stackChains != NULL);

    if (m_chain->m_thread->m_stackFrames[0] != this ||
        m_chain->m_thread->m_stackChains[0] != m_chain)
    {
        return CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME;
    }

    HRESULT hr = m_chain->m_thread->SetIP(
                    SetIP_fCanSetIPOnly,
                    m_function->m_module->m_debuggerModuleToken,
                    m_function->m_token, 
                    m_code->m_CodeVersionToken,
                    nOffset, 
                    SetIP_fNative );
   
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbNativeFrame::SetIP(ULONG32 nOffset)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    _ASSERTE(m_chain->m_thread->m_stackFrames != NULL &&
             m_chain->m_thread->m_stackChains != NULL);

    if (m_chain->m_thread->m_stackFrames[0] != this ||
        m_chain->m_thread->m_stackChains[0] != m_chain)
    {
        return CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME;
    }

    HRESULT hr = m_chain->m_thread->SetIP(
                    SetIP_fSetIP,
                    m_function->m_module->m_debuggerModuleToken,
                    m_function->m_token, 
                    m_code->m_CodeVersionToken,
                    nOffset, 
                    SetIP_fNative );
    
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbNativeFrame::GetStackRange(CORDB_ADDRESS *pStart, 
                                        CORDB_ADDRESS *pEnd)
{

#ifdef _X86_
    if (pStart)
        *pStart = m_rd.Esp;

    if (pEnd)
        *pEnd = m_id;
#else //!_X86_
    _ASSERTE(!"@TODO Alpha - GetStackRange (Thread.cpp)");
#endif // _X86_
    return S_OK;
}

HRESULT CordbNativeFrame::GetRegisterSet(ICorDebugRegisterSet **ppRegisters)
{
    VALIDATE_POINTER_TO_OBJECT(ppRegisters, ICorDebugRegisterSet **);

    CordbThread *thread = m_chain->m_thread;

    CordbRegisterSet *pRegisterSet 
      = new CordbRegisterSet( &m_rd, thread, 
                              m_iThisFrame == 0
                              && m_chain->m_iThisChain == 0,
                              m_quicklyUnwound);

    if( pRegisterSet == NULL )
        return E_OUTOFMEMORY;

    pRegisterSet->AddRef();

    (*ppRegisters) = (ICorDebugRegisterSet *)pRegisterSet;
    return S_OK;
}

//
// GetAddressOfRegister returns the address of the given register in the
// frames current register display. This is usually used to build a
// ICorDebugValue from.
//
DWORD *CordbNativeFrame::GetAddressOfRegister(CorDebugRegister regNum)
{
    DWORD* ret = 0;

#ifdef _X86_    
    switch (regNum)
    {
    case REGISTER_X86_EAX:
        ret = &m_rd.Eax;
        break;
        
    case REGISTER_X86_ECX:
        ret = &m_rd.Ecx;
        break;
        
    case REGISTER_X86_EDX:
        ret = &m_rd.Edx;
        break;
        
    case REGISTER_X86_EBX:
        ret = &m_rd.Ebx;
        break;
        
    case REGISTER_X86_ESP:
        ret = &m_rd.Esp;
        break;
        
    case REGISTER_X86_EBP:
        ret = &m_rd.Ebp;
        break;
        
    case REGISTER_X86_ESI:
        ret = &m_rd.Esi;
        break;
        
    case REGISTER_X86_EDI:
        ret = &m_rd.Edi;
        break;
        
    default:
        _ASSERT(!"Invalid register number!");
    }
#endif
    
    return ret;
}

//
// GetLeftSideAddressOfRegister returns the Left Side address of the given register in the frames current register
// display.
//
void *CordbNativeFrame::GetLeftSideAddressOfRegister(CorDebugRegister regNum)
{
    void* ret = 0;

#ifdef _X86_    
    switch (regNum)
    {
    case REGISTER_X86_EAX:
        ret = m_rd.pEax;
        break;
        
    case REGISTER_X86_ECX:
        ret = m_rd.pEcx;
        break;
        
    case REGISTER_X86_EDX:
        ret = m_rd.pEdx;
        break;
        
    case REGISTER_X86_EBX:
        ret = m_rd.pEbx;
        break;
        
    case REGISTER_X86_EBP:
        ret = m_rd.pEbp;
        break;
        
    case REGISTER_X86_ESI:
        ret = m_rd.pEsi;
        break;
        
    case REGISTER_X86_EDI:
        ret = m_rd.pEdi;
        break;
        
    default:
        _ASSERT(!"Invalid register number!");
    }
#endif
    
    return ret;
}

HRESULT CordbNativeFrame::GetLocalRegisterValue(CorDebugRegister reg, 
                                                ULONG cbSigBlob,
                                                PCCOR_SIGNATURE pvSigBlob,
                                                ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pvSigBlob, BYTE, cbSigBlob, true, false);
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        cbSigBlob -= cb;
        pvSigBlob = &pvSigBlob[cb];
    }

    // Floating point registers are special...
    if ((reg >= REGISTER_X86_FPSTACK_0) && (reg <= REGISTER_X86_FPSTACK_7))
        return GetLocalFloatingPointValue(reg,
                                          cbSigBlob, pvSigBlob, ppValue);

    // The address of the given register is the address of the value
    // in this process. We have no remote address here.
    void *pLocalValue = (void*)GetAddressOfRegister(reg);

    // Remember the register info as we create the value.
    RemoteAddress ra;
    ra.kind = RAK_REG;
    ra.reg1 = reg;
    ra.reg1Addr = GetLeftSideAddressOfRegister(reg);
    ra.frame = this;

    ICorDebugValue *pValue;
    HRESULT hr = CordbValue::CreateValueByType(GetCurrentAppDomain(),
                                               m_function->GetModule(),
                                               cbSigBlob, pvSigBlob,
                                               NULL,
                                               NULL, pLocalValue,
                                               false,
                                               &ra,
                                               (IUnknown*)(ICorDebugNativeFrame*)this,
                                               &pValue);

    if (SUCCEEDED(hr))
        *ppValue = pValue;

    return hr;
}

HRESULT CordbNativeFrame::GetLocalDoubleRegisterValue(
                                            CorDebugRegister highWordReg, 
                                            CorDebugRegister lowWordReg, 
                                            ULONG cbSigBlob,
                                            PCCOR_SIGNATURE pvSigBlob,
                                            ICorDebugValue **ppValue)
{
    if (cbSigBlob == 0)
        return E_INVALIDARG;
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pvSigBlob, BYTE, cbSigBlob, true, false);
    
    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    ULONG cbSigBlobNoMod = cbSigBlob;
    PCCOR_SIGNATURE pvSigBlobNoMod = pvSigBlob;
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        cbSigBlobNoMod -= cb;
        pvSigBlobNoMod = &pvSigBlobNoMod[cb];
    }

    if ((*pvSigBlobNoMod != ELEMENT_TYPE_I8) &&
        (*pvSigBlobNoMod != ELEMENT_TYPE_U8) &&
        (*pvSigBlobNoMod != ELEMENT_TYPE_R8) &&
		(*pvSigBlobNoMod != ELEMENT_TYPE_VALUETYPE))
        return E_INVALIDARG;

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    //
    // Here we have a 64-bit value that is split between two registers.
    // We've got both halves of the data in this process, so we
    // simply create a generic value from the two words of data.
    //
    DWORD *highWordAddr = GetAddressOfRegister(highWordReg);
    DWORD *lowWordAddr = GetAddressOfRegister(lowWordReg);
    _ASSERTE(!(highWordAddr == NULL && lowWordAddr == NULL));

    // Remember the register info as we create the value.
    RemoteAddress ra;
    ra.kind = RAK_REGREG;
    ra.reg1 = highWordReg;
    ra.reg1Addr = GetLeftSideAddressOfRegister(highWordReg);
    ra.reg2 = lowWordReg;
    ra.reg2Addr = GetLeftSideAddressOfRegister(lowWordReg);
    ra.frame = this;
    
	if (*pvSigBlobNoMod == ELEMENT_TYPE_VALUETYPE)
	{
		ICorDebugValue *pValue;
		HRESULT hr = CordbValue::CreateValueByType(GetCurrentAppDomain(),
												m_function->GetModule(),
												cbSigBlob, pvSigBlob,
												NULL,
												NULL, NULL,
												false,
												&ra,
												(IUnknown*)(ICorDebugNativeFrame*)this,
												&pValue);

		if (SUCCEEDED(hr))
			*ppValue = pValue;
		return hr;
	}
	else
	{
		CordbGenericValue *pGenValue = new CordbGenericValue(GetCurrentAppDomain(),
															m_function->GetModule(),
															cbSigBlob,
															pvSigBlob,
															*highWordAddr,
															*lowWordAddr,
															&ra);

		if (pGenValue != NULL)
		{
			HRESULT hr = pGenValue->Init();

			if (SUCCEEDED(hr))
			{
				pGenValue->AddRef();
				*ppValue = (ICorDebugValue*)(ICorDebugGenericValue*)pGenValue;

				return S_OK;
			}
			else
			{
				delete pGenValue;
				return hr;
			}
		}
		else
			return E_OUTOFMEMORY;
	}
}

HRESULT 
CordbNativeFrame::GetLocalMemoryValue(CORDB_ADDRESS address,
                                      ULONG cbSigBlob,
                                      PCCOR_SIGNATURE pvSigBlob,
                                      ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pvSigBlob, BYTE, cbSigBlob, true, false);
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    _ASSERTE(m_function != NULL);

    ICorDebugValue *pValue;
    HRESULT hr = CordbValue::CreateValueByType(GetCurrentAppDomain(),
                                               m_function->GetModule(),
                                               cbSigBlob, pvSigBlob,
                                               NULL,
                                               (REMOTE_PTR) address, NULL,
                                               false,
                                               NULL,
                                               (IUnknown*)(ICorDebugNativeFrame*)this,
                                               &pValue);

    if (SUCCEEDED(hr))
        *ppValue = pValue;

    return hr;
}

HRESULT 
CordbNativeFrame::GetLocalRegisterMemoryValue(CorDebugRegister highWordReg,
                                              CORDB_ADDRESS lowWordAddress,
                                              ULONG cbSigBlob,
                                              PCCOR_SIGNATURE pvSigBlob,
                                              ICorDebugValue **ppValue)
{
    if (cbSigBlob == 0)
        return E_INVALIDARG;
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pvSigBlob, BYTE, cbSigBlob, true, true);
        
    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    PCCOR_SIGNATURE pvSigBlobNoMod = pvSigBlob;
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        pvSigBlobNoMod = &pvSigBlobNoMod[cb];
    }

    if ((*pvSigBlobNoMod != ELEMENT_TYPE_I8) &&
        (*pvSigBlobNoMod != ELEMENT_TYPE_U8) &&
        (*pvSigBlobNoMod != ELEMENT_TYPE_R8))
        return E_INVALIDARG;
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    //
    // Here we have a 64-bit value that is split between a register
    // and a stack location. We've got half of the value in this
    // process, but we need to read the other half from the other
    // process to build the proper value object.
    //
    DWORD *highWordAddr = GetAddressOfRegister(highWordReg);
    DWORD lowWord;

    BOOL succ = ReadProcessMemoryI(GetProcess()->m_handle,
                                  (void*) lowWordAddress,
                                  (void*)&lowWord,
                                  sizeof(DWORD),
                                  NULL);

    if (!succ)
        return HRESULT_FROM_WIN32(GetLastError());

    // Remember the register info as we create the value.
    RemoteAddress ra;
    ra.kind = RAK_REGMEM;
    ra.reg1 = highWordReg;
    ra.reg1Addr = GetLeftSideAddressOfRegister(highWordReg);
    ra.addr = lowWordAddress;
    ra.frame = this;

    CordbGenericValue *pGenValue = new CordbGenericValue(GetCurrentAppDomain(),
                                                         m_function->GetModule(),
                                                         cbSigBlob,
                                                         pvSigBlob,
                                                         *highWordAddr,
                                                         lowWord,
                                                         &ra);

    if (pGenValue != NULL)
    {
        HRESULT hr = pGenValue->Init();

        if (SUCCEEDED(hr))
        {
            pGenValue->AddRef();
            *ppValue = (ICorDebugValue*)(ICorDebugGenericValue*)pGenValue;

            return S_OK;
        }
        else
        {
            delete pGenValue;
            return hr;
        }
    }
    else
        return E_OUTOFMEMORY;
}

HRESULT 
CordbNativeFrame::GetLocalMemoryRegisterValue(CORDB_ADDRESS highWordAddress,
                                              CorDebugRegister lowWordRegister,
                                              ULONG cbSigBlob,
                                              PCCOR_SIGNATURE pvSigBlob,
                                              ICorDebugValue **ppValue)
{
    if (cbSigBlob == 0)
        return E_INVALIDARG;
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pvSigBlob, BYTE, cbSigBlob, true, false);
        
    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    PCCOR_SIGNATURE pvSigBlobNoMod = pvSigBlob;
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        pvSigBlobNoMod = &pvSigBlobNoMod[cb];
    }

    if ((*pvSigBlobNoMod != ELEMENT_TYPE_I8) &&
        (*pvSigBlobNoMod != ELEMENT_TYPE_U8) &&
        (*pvSigBlobNoMod != ELEMENT_TYPE_R8))
        return E_INVALIDARG;
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    //
    // Here we have a 64-bit value that is split between a register
    // and a stack location. We've got half of the value in this
    // process, but we need to read the other half from the other
    // process to build the proper value object.
    //
    DWORD highWord;
    DWORD *lowWordAddr = GetAddressOfRegister(lowWordRegister);

    BOOL succ = ReadProcessMemoryI(GetProcess()->m_handle,
                                  (REMOTE_PTR) highWordAddress,
                                  (void*)&highWord,
                                  sizeof(DWORD),
                                  NULL);

    if (!succ)
        return HRESULT_FROM_WIN32(GetLastError());

    // Remember the register info as we create the value.
    RemoteAddress ra;
    ra.kind = RAK_MEMREG;
    ra.reg1 = lowWordRegister;
    ra.reg1Addr = GetLeftSideAddressOfRegister(lowWordRegister);
    ra.addr = highWordAddress;
    ra.frame = this;

    CordbGenericValue *pGenValue = new CordbGenericValue(GetCurrentAppDomain(),
                                                         m_function->GetModule(),
                                                         cbSigBlob,
                                                         pvSigBlob,
                                                         highWord,
                                                         *lowWordAddr,
                                                         &ra);

    if (pGenValue != NULL)
    {
        HRESULT hr = pGenValue->Init();

        if (SUCCEEDED(hr))
        {
            pGenValue->AddRef();
            *ppValue = (ICorDebugValue*)(ICorDebugGenericValue*)pGenValue;

            return S_OK;
        }
        else
        {
            delete pGenValue;
            return hr;
        }
    }
    else
        return E_OUTOFMEMORY;
}

HRESULT CordbNativeFrame::GetLocalFloatingPointValue(DWORD index,
                                                     ULONG cbSigBlob,
                                                     PCCOR_SIGNATURE pvSigBlob,
                                                     ICorDebugValue **ppValue)
{
    HRESULT hr = S_OK;

    if (cbSigBlob == 0)
        return E_INVALIDARG;
    
    //Get rid of funky modifiers
    PCCOR_SIGNATURE pvSigBlobNoMod = pvSigBlob;
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        pvSigBlobNoMod = &pvSigBlobNoMod[cb];
    }
    
    if ((*pvSigBlobNoMod != ELEMENT_TYPE_R4) &&
        (*pvSigBlobNoMod != ELEMENT_TYPE_R8))
        return E_INVALIDARG;

    if (!((index >= REGISTER_X86_FPSTACK_0) &&
          (index <= REGISTER_X86_FPSTACK_7)))
        return E_INVALIDARG;

    index -= REGISTER_X86_FPSTACK_0;
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    // Make sure the thread's floating point stack state is loaded
    // over from the left side.
    //
    CordbThread *pThread = m_chain->m_thread;

    if (!pThread->m_floatStateValid)
        hr = pThread->LoadFloatState();

    if (SUCCEEDED(hr))
    {
        index = pThread->m_floatStackTop - index;

        if (index >= (sizeof(pThread->m_floatValues) /
                      sizeof(pThread->m_floatValues[0])))
            return E_INVALIDARG;

        ICorDebugValue* pValue;

        // Remember the register info as we create the value.
        RemoteAddress ra;
        ra.kind = RAK_FLOAT;
        ra.floatIndex = index;
        ra.frame = this;

        HRESULT hr = CordbValue::CreateValueByType(GetCurrentAppDomain(),
                                                   m_function->GetModule(),
                                                   cbSigBlob, pvSigBlob,
                                                   NULL,
                                                   NULL,
                                                   &(pThread->m_floatValues[index]),
                                                   false,
                                                   &ra,
                                                   (IUnknown*)(ICorDebugNativeFrame*)this,
                                                   &pValue);

        if (SUCCEEDED(hr))
            *ppValue = pValue;
    }

    return hr;
}

/* ------------------------------------------------------------------------- *
 * RegisterSet class
 * ------------------------------------------------------------------------- */

#define SETBITULONG64( x ) ( (ULONG64)1 << (x) )

HRESULT CordbRegisterSet::GetRegistersAvailable(ULONG64 *pAvailable)
{
    VALIDATE_POINTER_TO_OBJECT(pAvailable, ULONG64 *);

    (*pAvailable) = SETBITULONG64( REGISTER_INSTRUCTION_POINTER )
            |   SETBITULONG64( REGISTER_STACK_POINTER )
            |   SETBITULONG64( REGISTER_FRAME_POINTER );

#ifdef _X86_

    if (!m_quickUnwind || m_active)
        (*pAvailable) |= SETBITULONG64( REGISTER_X86_EAX )
            |   SETBITULONG64( REGISTER_X86_ECX )
            |   SETBITULONG64( REGISTER_X86_EDX )
            |   SETBITULONG64( REGISTER_X86_EBX )
            |   SETBITULONG64( REGISTER_X86_ESI )
            |   SETBITULONG64( REGISTER_X86_EDI );

    if (m_active)
        (*pAvailable) |= SETBITULONG64( REGISTER_X86_FPSTACK_0 )
            |   SETBITULONG64( REGISTER_X86_FPSTACK_1 )
            |   SETBITULONG64( REGISTER_X86_FPSTACK_2 )
            |   SETBITULONG64( REGISTER_X86_FPSTACK_3 )
            |   SETBITULONG64( REGISTER_X86_FPSTACK_4 )
            |   SETBITULONG64( REGISTER_X86_FPSTACK_5 )
            |   SETBITULONG64( REGISTER_X86_FPSTACK_6 )
            |   SETBITULONG64( REGISTER_X86_FPSTACK_7 );

#else // not _X86_
    (*pAvailable) = SETBITULONG64( REGISTER_INSTRUCTION_POINTER );
#endif //_X86_
    return S_OK;
}


#define FPSTACK_FROM_INDEX( _index )  (m_thread->m_floatValues[m_thread->m_floatStackTop -( (REGISTER_X86_FPSTACK_##_index)-REGISTER_X86_FPSTACK_0 ) ] )

HRESULT CordbRegisterSet::GetRegisters(ULONG64 mask, ULONG32 regCount,
                     CORDB_REGISTER regBuffer[])
{ 
    UINT iRegister = 0;

    VALIDATE_POINTER_TO_OBJECT_ARRAY(regBuffer, CORDB_REGISTER, regCount, true, true);
    
#ifdef _X86_
    //If we need some floating point value, tell the thread to get it
    if ( mask & (       SETBITULONG64(REGISTER_X86_FPSTACK_0)
                    |   SETBITULONG64(REGISTER_X86_FPSTACK_1)
                    |   SETBITULONG64(REGISTER_X86_FPSTACK_2)
                    |   SETBITULONG64(REGISTER_X86_FPSTACK_3)
                    |   SETBITULONG64(REGISTER_X86_FPSTACK_4)
                    |   SETBITULONG64(REGISTER_X86_FPSTACK_5)
                    |   SETBITULONG64(REGISTER_X86_FPSTACK_6)
                    |   SETBITULONG64(REGISTER_X86_FPSTACK_7 ) ) )
    {
        HRESULT     hr;

        if (!m_active)
            return E_INVALIDARG;

        if (!m_thread->m_floatStateValid)
        {
            hr = m_thread->LoadFloatState();
            if ( !SUCCEEDED(hr) )
            {
                return hr;
            }
            LOG( ( LF_CORDB, LL_INFO1000, "CRS::GR: Loaded float state\n" ) );
        }
    }

    // Make sure that the registers are really available
    if ( mask & (       SETBITULONG64( REGISTER_X86_EAX )
                    |   SETBITULONG64( REGISTER_X86_ECX )
                    |   SETBITULONG64( REGISTER_X86_EDX )
                    |   SETBITULONG64( REGISTER_X86_EBX )
                    |   SETBITULONG64( REGISTER_X86_ESI )
                    |   SETBITULONG64( REGISTER_X86_EDI ) ) )
    {
        if (!m_active && m_quickUnwind)
            return E_INVALIDARG;
    }

    for ( int i = REGISTER_INSTRUCTION_POINTER
        ; i<=REGISTER_X86_FPSTACK_7 && iRegister < regCount 
        ; i++)
    {
        if( mask &  SETBITULONG64(i) )
        {
            switch( i )
            {
            case REGISTER_INSTRUCTION_POINTER: 
                regBuffer[iRegister++] = m_rd->PC; break;
            case REGISTER_STACK_POINTER:
                regBuffer[iRegister++] = m_rd->Esp; break;
            case REGISTER_FRAME_POINTER:
                regBuffer[iRegister++] = m_rd->Ebp; break;
            case REGISTER_X86_EAX:
                regBuffer[iRegister++] = m_rd->Eax; break;
            case REGISTER_X86_EBX:
                regBuffer[iRegister++] = m_rd->Ebx; break;
            case REGISTER_X86_ECX:
                regBuffer[iRegister++] = m_rd->Ecx; break;
            case REGISTER_X86_EDX:
                regBuffer[iRegister++] = m_rd->Edx; break;
            case REGISTER_X86_ESI:
                regBuffer[iRegister++] = m_rd->Esi; break;
            case REGISTER_X86_EDI:
                regBuffer[iRegister++] = m_rd->Edi; break;

            //for floats, copy the bits, not the integer part of 
            //the value, into the register
            case REGISTER_X86_FPSTACK_0:
                memcpy(&regBuffer[iRegister++],
                       &(FPSTACK_FROM_INDEX(0)),
                       sizeof(CORDB_REGISTER)); 
                break;
            case REGISTER_X86_FPSTACK_1:
                memcpy( &regBuffer[iRegister++],
                    & (FPSTACK_FROM_INDEX( 1 ) ),
                    sizeof(CORDB_REGISTER) ); 
                break;
            case    REGISTER_X86_FPSTACK_2:
                memcpy( &regBuffer[iRegister++],
                    & (FPSTACK_FROM_INDEX( 2 ) ),
                    sizeof(CORDB_REGISTER) ); break;
            case    REGISTER_X86_FPSTACK_3:
                memcpy( &regBuffer[iRegister++],
                    & (FPSTACK_FROM_INDEX( 3 ) ),
                    sizeof(CORDB_REGISTER) ); break;
            case    REGISTER_X86_FPSTACK_4:
                memcpy( &regBuffer[iRegister++],
                    & (FPSTACK_FROM_INDEX( 4 ) ),
                    sizeof(CORDB_REGISTER) ); break;
            case    REGISTER_X86_FPSTACK_5:
                memcpy( &regBuffer[iRegister++],
                    & (FPSTACK_FROM_INDEX( 5 ) ),
                    sizeof(CORDB_REGISTER) ); break;
            case    REGISTER_X86_FPSTACK_6:
                memcpy( &regBuffer[iRegister++],
                    & (FPSTACK_FROM_INDEX( 6 ) ),
                    sizeof(CORDB_REGISTER) ); break;
            case    REGISTER_X86_FPSTACK_7:
                memcpy( &regBuffer[iRegister++],
                    & (FPSTACK_FROM_INDEX( 7 ) ),
                    sizeof(CORDB_REGISTER) ); break;
            }
        }
    }

#else // not _X86_
    if( mask &  SETBITULONG64(REGISTER_INSTRUCTION_POINTER) )
    {
        regBuffer[iRegister++] = m_rd->PC;
    }

#endif //_X86_
    _ASSERTE( iRegister <= regCount );
    return S_OK;
}

HRESULT CordbRegisterSet::GetThreadContext(ULONG32 contextSize, BYTE context[])
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else

#ifdef _X86_
    _ASSERTE( m_thread != NULL );
    if( contextSize < sizeof( CONTEXT ))
        return E_INVALIDARG;

    VALIDATE_POINTER_TO_OBJECT_ARRAY(context, BYTE, contextSize, true, true);

    CONTEXT *pContext = NULL;
    HRESULT hr = m_thread->GetContext( &pContext );
    if( !SUCCEEDED( hr ) )
    {
        return hr; 
    }

    memmove( context, pContext, sizeof( CONTEXT) );

    //now update the registers based on the current frame
    CONTEXT *pInputContext = (CONTEXT *)context;

    if((pInputContext->ContextFlags & CONTEXT_INTEGER)==CONTEXT_INTEGER)
    {
        pInputContext->Eax = m_rd->Eax;
        pInputContext->Ebx = m_rd->Ebx;
        pInputContext->Ecx = m_rd->Ecx;
        pInputContext->Edx = m_rd->Edx;
        pInputContext->Esi = m_rd->Esi;
        pInputContext->Edi = m_rd->Edi;
    }

    if((pInputContext->ContextFlags & CONTEXT_CONTROL)==CONTEXT_CONTROL)
    {
        pInputContext->Eip = m_rd->PC;
        pInputContext->Esp = m_rd->Esp;
        pInputContext->Ebp = m_rd->Ebp;
    }
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - GetThreadContext (Thread.cpp)");
#endif // _X86_
    return S_OK;
#endif // RIGHT_SIDE_ONLY
}

HRESULT CordbRegisterSet::SetThreadContext(ULONG32 contextSize, BYTE context[])
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
#ifdef _X86_ // Reliance on context registers
    _ASSERTE( m_thread != NULL );
    if(contextSize < sizeof( CONTEXT ))
        return E_INVALIDARG;

    VALIDATE_POINTER_TO_OBJECT_ARRAY(context, BYTE, contextSize, true, true);

    if (!m_active)
        return E_NOTIMPL;

    HRESULT hr = m_thread->SetContext((CONTEXT*)context);
    if (!FAILED( hr ) )
    {
        CONTEXT *pInputContext = (CONTEXT *)context;

        if((pInputContext->ContextFlags & CONTEXT_INTEGER)==CONTEXT_INTEGER)
        {
            m_rd->Eax = pInputContext->Eax;
            m_rd->Ebx = pInputContext->Ebx;
            m_rd->Ecx = pInputContext->Ecx;
            m_rd->Edx = pInputContext->Edx;
            m_rd->Esi = pInputContext->Esi;
            m_rd->Edi = pInputContext->Edi;
        }

        if((pInputContext->ContextFlags & CONTEXT_CONTROL)==CONTEXT_CONTROL)
        {
           m_rd->PC  = pInputContext->Eip;
           m_rd->Esp = pInputContext->Esp;
           m_rd->Ebp = pInputContext->Ebp;
        }
    }
    
    return hr;
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - SetThreadContext (Thread.cpp)");
    return E_FAIL;
#endif // _X86_
#endif //RIGHT_SIDE_ONLY    
}


/* ------------------------------------------------------------------------- *
 * JIT-IL Frame class
 * ------------------------------------------------------------------------- */

CordbJITILFrame::CordbJITILFrame(CordbNativeFrame *nativeFrame,
                                 CordbCode* code,
                                 UINT_PTR ip,
                                 CorDebugMappingResult mapping,
                                 bool fVarArgFnx,
                                 void *sig,
                                 ULONG cbSig,
                                 void *rpFirstArg)
  : CordbBase(0, enumCordbJITILFrame), m_nativeFrame(nativeFrame), m_ilCode(code), m_ip(ip),
    m_mapping(mapping), m_fVarArgFnx(fVarArgFnx), m_sig((PCCOR_SIGNATURE)sig),
    m_cbSig(cbSig), m_rpFirstArg(rpFirstArg), m_argCount(0), m_rgNVI(NULL)
{
    if (m_fVarArgFnx == true)
    {
        m_ilCode->m_function->LoadSig(); // to get the m_isStatic field

        // m_sig is initially a remote value - copy it over
        if (m_sig != NULL)
        {
            DWORD cbRead;
            BYTE *pbBuf = new BYTE [m_cbSig];
           
            if (pbBuf == NULL ||
                !ReadProcessMemory(GetProcess()->m_handle,
                              m_sig,
                              pbBuf, //overwrite
                              m_cbSig,
                              &cbRead)
                || cbRead != m_cbSig)
            {
                LOG((LF_CORDB,LL_INFO1000, "Failed to grab left "
                     "side varargs!"));

                if (pbBuf != NULL)
                    delete [] pbBuf;
                    
                m_sig = NULL;
                return;
            }
            
            m_sig = (PCCOR_SIGNATURE)pbBuf;
        
            _ASSERTE(m_cbSig > 0);

            // get the actual count of arguments
            _skipMethodSignatureHeader(m_sig, &m_argCount);

            if (!m_ilCode->m_function->m_isStatic)
                m_argCount++; //hidden argument 'This'
                
            m_rgNVI = new ICorJitInfo::NativeVarInfo[m_argCount];
            if (m_rgNVI != NULL)
            {
                _ASSERTE( ICorDebugInfo::VarLocType::VLT_COUNT <=
                          ICorDebugInfo::VarLocType::VLT_INVALID);
                for (ULONG i = 0; i < m_argCount; i++)
                    m_rgNVI[i].loc.vlType = ICorDebugInfo::VarLocType::VLT_INVALID;
            }
        }
    }
}

/*
    A list of which resources owened by this object are accounted for.

    UNKNOWN:    
        CordbNativeFrame* m_nativeFrame;
        CordbCode*        m_ilCode;
        CorDebugMappingResult m_mapping;
        void *            m_rpFirstArg;
        PCCOR_SIGNATURE   m_sig; // Deleted in ~CordbJITILFrame
        ICorJitInfo::NativeVarInfo * m_rgNVI; // Deleted in ~CordbJITILFrame
*/

CordbJITILFrame::~CordbJITILFrame()
{
    if (m_sig != NULL)
        delete [] (void *)m_sig;

    if (m_rgNVI != NULL)
        delete [] m_rgNVI;
}

// Neutered by CordbNativeFrame
void CordbJITILFrame::Neuter()
{
    AddRef();
    {    
        // If this class ever inherits from the CordbFrame we'll need a call
        // to CordbFrame::Neuter() here instead of to CordbBase::Neuter();
        CordbBase::Neuter();
    }
    Release();
}

HRESULT CordbJITILFrame::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugFrame)
        *pInterface = (ICorDebugFrame*)(ICorDebugILFrame*)this;
    else if (id == IID_ICorDebugILFrame)
        *pInterface = (ICorDebugILFrame*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugILFrame*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbJITILFrame::GetChain(ICorDebugChain **ppChain)
{
    VALIDATE_POINTER_TO_OBJECT(ppChain, ICorDebugChain **);
    
    *ppChain = m_nativeFrame->m_chain;
    (*ppChain)->AddRef();

    return S_OK;
}

HRESULT CordbJITILFrame::GetCode(ICorDebugCode **ppCode)
{
    VALIDATE_POINTER_TO_OBJECT(ppCode, ICorDebugCode **);
    
    *ppCode = (ICorDebugCode*)m_ilCode;
    (*ppCode)->AddRef();

    return S_OK;;
}

HRESULT CordbJITILFrame::GetFunction(ICorDebugFunction **ppFunction)
{
    VALIDATE_POINTER_TO_OBJECT(ppFunction, ICorDebugFunction **);
    
    *ppFunction = (ICorDebugFunction*)m_nativeFrame->m_function;
    (*ppFunction)->AddRef();

    return S_OK;
}

HRESULT CordbJITILFrame::GetFunctionToken(mdMethodDef *pToken)
{
    VALIDATE_POINTER_TO_OBJECT(pToken, mdMethodDef *);
    
    *pToken = m_nativeFrame->m_function->m_token;

    return S_OK;
}

HRESULT CordbJITILFrame::GetStackRange(CORDB_ADDRESS *pStart, CORDB_ADDRESS *pEnd)
{
    return m_nativeFrame->GetStackRange(pStart, pEnd);
}

HRESULT CordbJITILFrame::GetCaller(ICorDebugFrame **ppFrame)
{
    return m_nativeFrame->GetCaller(ppFrame);
}

HRESULT CordbJITILFrame::GetCallee(ICorDebugFrame **ppFrame)
{
    return m_nativeFrame->GetCallee(ppFrame);
}

HRESULT CordbJITILFrame::CreateStepper(ICorDebugStepper **ppStepper)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    //
    // !!! should this stepper somehow remember that it does IL->native mapping?
    //
    return m_nativeFrame->CreateStepper(ppStepper);
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbJITILFrame::GetIP(ULONG32 *pnOffset,
                               CorDebugMappingResult *pMappingResult)
{
    VALIDATE_POINTER_TO_OBJECT(pnOffset, ULONG32 *);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pMappingResult, CorDebugMappingResult *);
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    *pnOffset = m_ip;
    if (pMappingResult)
        *pMappingResult = m_mapping;
    return S_OK;
}

HRESULT CordbJITILFrame::CanSetIP(ULONG32 nOffset)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());

    _ASSERTE(m_nativeFrame->m_chain->m_thread->m_stackFrames != NULL &&
             m_nativeFrame->m_chain->m_thread->m_stackChains != NULL);

    // Check to see that this is a leaf frame
    if (m_nativeFrame->m_chain->m_thread->m_stackFrames[0]->m_JITILFrame != this ||
        m_nativeFrame->m_chain->m_thread->m_stackChains[0] != m_nativeFrame->m_chain)
    {
        return CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME;
    }

    HRESULT hr = m_nativeFrame->m_chain->m_thread->SetIP(
                    SetIP_fCanSetIPOnly,
                    m_nativeFrame->m_function->m_module->m_debuggerModuleToken,
                    m_nativeFrame->m_function->m_token, 
                    m_nativeFrame->m_code->m_CodeVersionToken,
                    nOffset, 
                    SetIP_fIL );

    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbJITILFrame::SetIP(ULONG32 nOffset)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());

    _ASSERTE(m_nativeFrame->m_chain->m_thread->m_stackFrames != NULL &&
             m_nativeFrame->m_chain->m_thread->m_stackChains != NULL);

// Check to see that this is a leaf frame
    if (m_nativeFrame->m_chain->m_thread->m_stackFrames[0]->m_JITILFrame != this ||
        m_nativeFrame->m_chain->m_thread->m_stackChains[0] != m_nativeFrame->m_chain)
    {
        return CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME;
    }

    HRESULT hr = m_nativeFrame->m_chain->m_thread->SetIP(
                    SetIP_fSetIP,
                    m_nativeFrame->m_function->m_module->m_debuggerModuleToken,
                    m_nativeFrame->m_function->m_token, 
                    m_nativeFrame->m_code->m_CodeVersionToken,
                    nOffset, 
                    SetIP_fIL );
    
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

//
// Mapping from ICorDebugInfo register numbers to CorDebugRegister
// numbers. Note: this must match the order in corjit.h.
//
static CorDebugRegister g_JITToCorDbgReg[] = 
{
    REGISTER_X86_EAX,
    REGISTER_X86_ECX,
    REGISTER_X86_EDX,
    REGISTER_X86_EBX,
    REGISTER_X86_ESP,
    REGISTER_X86_EBP,
    REGISTER_X86_ESI,
    REGISTER_X86_EDI
};

HRESULT CordbJITILFrame::FabricateNativeInfo(DWORD dwIndex,
                                      ICorJitInfo::NativeVarInfo **ppNativeInfo)
{
    _ASSERTE( m_fVarArgFnx );

    if (m_rgNVI == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = S_OK;

    // If we already made it.
    if (m_rgNVI[dwIndex].loc.vlType != ICorDebugInfo::VarLocType::VLT_INVALID)
    {
        (*ppNativeInfo) = &m_rgNVI[dwIndex];
        return S_OK;
    }
    
    // We'll initialize everything at once
    ULONG cArgs;
    ULONG cb = 0;
    ULONG cbArchitectureMin;
    BYTE *rpCur = (BYTE *)m_rpFirstArg;
    
#ifdef _X86_
    cbArchitectureMin = 4;
#else
    _ASSERTE( !"What is the architecture-dependentent minimum word size?" );
#endif // _X86_

    cb += _skipMethodSignatureHeader(&m_sig[cb], &cArgs);
 

    // The the rpCur pointer starts off in the right spot for the
    // first argument, but thereafter we have to decrement it
    // before getting the variable's location from it.  So increment
    // it here to be consistent later.
    mdTypeDef md;
    ULONG32 cbType = _sizeOfElementInstance(&m_sig[cb], &md);
    CordbClass *cc;
    
    if (md != mdTokenNil)
    {
        // @todo what if we're given a type ref, instead?
        
        if (TypeFromToken(md)==mdtTypeRef)
        {
            hr = m_ilCode->m_function->GetModule()
                ->ResolveTypeRef(md, &cc);
                
            if (FAILED(hr))
                return hr;
        }
        else
        {
            _ASSERTE( TypeFromToken(md)==mdtTypeDef );
            hr = m_ilCode->m_function->GetModule()->
                LookupClassByToken(md, &cc);
            
            if (FAILED(hr))
                return hr;                
        }

        hr = cc->GetObjectSize(&cbType);
        if (FAILED(hr))
            return hr;

#ifdef _DEBUG        
        bool ValClassCheck;
        cc->IsValueClass(&ValClassCheck);
        _ASSERTE( ValClassCheck == true);
#endif // _DEBUG        
    }
    
    rpCur += max(cbType, cbArchitectureMin);
    
    ULONG i;
    if (m_ilCode->m_function->m_isStatic)
        i = 0;
    else
        i = 1;
        
    for ( ; i < m_argCount; i++)
    {
        m_rgNVI[i].startOffset = 0;
        m_rgNVI[i].endOffset = 0xFFffFFff;
        m_rgNVI[i].varNumber = i;
        m_rgNVI[i].loc.vlType = ICorDebugInfo::VarLocType::VLT_FIXED_VA;

        // Ugly code to get size of thingee, including value type thingees
        cbType = _sizeOfElementInstance(&m_sig[cb], &md);           
        if (md != mdTokenNil)
        {
            if (TypeFromToken(md)==mdtTypeRef)
            {
                hr = m_ilCode->m_function->GetModule()
                    ->ResolveTypeRef(md, &cc);
                
                if (FAILED(hr))
                    return hr;
            }
            else
            {
                _ASSERTE( TypeFromToken(md)==mdtTypeDef );
                hr = m_ilCode->m_function->GetModule()->
                    LookupClassByToken(md, &cc);
            
                if (FAILED(hr))
                    return hr;                
            }

            _ASSERTE( cc != NULL );
            hr = cc->GetObjectSize(&cbType);
            
            if (FAILED(hr))
                return hr;

#ifdef _DEBUG        
            bool ValClassCheck;
            cc->IsValueClass(&ValClassCheck);
            _ASSERTE( ValClassCheck == true);
#endif // _DEBUG
        }

        rpCur -= max(cbType, cbArchitectureMin);

        m_rgNVI[i].loc.vlFixedVarArg.vlfvOffset = (BYTE *)m_rpFirstArg - rpCur;

        // Since the JIT adds in the size of this field, we do too to
        // be consistent.
        m_rgNVI[i].loc.vlFixedVarArg.vlfvOffset += 
            sizeof(((CORINFO_VarArgInfo*)0)->argBytes);

        cb += _skipTypeInSignature(&m_sig[cb]);
    }
    
    (*ppNativeInfo) = &m_rgNVI[dwIndex];
    return S_OK;
}

HRESULT CordbJITILFrame::ILVariableToNative(DWORD dwIndex,
                                            SIZE_T ip,
                                        ICorJitInfo::NativeVarInfo **ppNativeInfo)
{
    CordbFunction *pFunction =  m_ilCode->m_function;
    bool fVar = false;
    
    // We keep the fixed argument native var infos in the
    // CordbFunction, which only is an issue for var args info:
    if (!m_fVarArgFnx || //not  a var args function
        dwIndex < pFunction->m_argumentCount || // var args,fixed arg
           // note that this include the implicit 'this' for nonstatic fnxs
        dwIndex >= m_argCount ||// var args, local variable
        m_sig == NULL ) //we don't have any VA info
    {
        // If we're in a var args fnx, but we're actually looking
        // for a local variable, then we want to use the variable
        // index as the function sees it - fixed (but not var)
        // args are added to local var number to get native info
        if (m_fVarArgFnx && 
            dwIndex >= m_argCount &&
            m_sig != NULL)
        {
            dwIndex -= m_argCount;
            dwIndex += pFunction->m_argumentCount;
        }

        return pFunction->ILVariableToNative(dwIndex,
                                             m_nativeFrame->m_ip,
                                             ppNativeInfo);
    }

    return FabricateNativeInfo(dwIndex,ppNativeInfo);
}   

HRESULT CordbJITILFrame::GetArgumentType(DWORD dwIndex,
                                         ULONG *pcbSigBlob,
                                         PCCOR_SIGNATURE *ppvSigBlob)
{
    if (m_fVarArgFnx && m_sig != NULL)
    {
        ULONG cArgs;
        ULONG cb = 0;

        cb += _skipMethodSignatureHeader(m_sig,&cArgs);

        if (!m_ilCode->m_function->m_isStatic)
        {
            if (dwIndex == 0)
            {
                // Return the signature for the 'this' pointer for the
                // class this method is in.
                return m_ilCode->m_function->m_class
                    ->GetThisSignature(pcbSigBlob, ppvSigBlob);
            }
            else
                dwIndex--;
        }
        
        for (ULONG i = 0; i < dwIndex; i++)
        {
            cb += _skipTypeInSignature(&m_sig[cb]);            
        }

        cb += _skipFunkyModifiersInSignature(&m_sig[cb]);
        cb += _detectAndSkipVASentinel(&m_sig[cb]);
        
        *pcbSigBlob = m_cbSig - cb;
        *ppvSigBlob = &(m_sig[cb]);
        return S_OK;
    }
    else
    {
        return m_ilCode->m_function->GetArgumentType(dwIndex,
                                                     pcbSigBlob,
                                                     ppvSigBlob);
    }
}

//
// GetNativeVariable uses the JIT variable information to delegate to
// the native frame when the value is really created.
//
HRESULT CordbJITILFrame::GetNativeVariable(ULONG cbSigBlob,
                                           PCCOR_SIGNATURE pvSigBlob,
                                           ICorJitInfo::NativeVarInfo *pJITInfo,
                                           ICorDebugValue **ppValue)
{
    HRESULT hr = S_OK;
    
    switch (pJITInfo->loc.vlType)
    {
    case ICorJitInfo::VLT_REG:
        hr = m_nativeFrame->GetLocalRegisterValue(
                                 g_JITToCorDbgReg[pJITInfo->loc.vlReg.vlrReg],
                                 cbSigBlob, pvSigBlob, ppValue);
        break;

    case ICorJitInfo::VLT_STK:
        {
            DWORD *pRegAddr =
                m_nativeFrame->GetAddressOfRegister(g_JITToCorDbgReg[pJITInfo->loc.vlStk.vlsBaseReg]);
            _ASSERTE(pRegAddr != NULL);

            CORDB_ADDRESS pRemoteValue = PTR_TO_CORDB_ADDRESS(*pRegAddr +
                                    pJITInfo->loc.vlStk.vlsOffset);

            hr = m_nativeFrame->GetLocalMemoryValue(pRemoteValue,
                                                    cbSigBlob, pvSigBlob,
                                                    ppValue);
        }
        break;

    case ICorJitInfo::VLT_REG_REG:
        hr = m_nativeFrame->GetLocalDoubleRegisterValue(
                            g_JITToCorDbgReg[pJITInfo->loc.vlRegReg.vlrrReg2],
                            g_JITToCorDbgReg[pJITInfo->loc.vlRegReg.vlrrReg1],
                            cbSigBlob, pvSigBlob, ppValue);
        break;

    case ICorJitInfo::VLT_REG_STK:
        {
            DWORD *pRegAddr =
                m_nativeFrame->GetAddressOfRegister(g_JITToCorDbgReg[pJITInfo->loc.vlRegStk.vlrsStk.vlrssBaseReg]);
            _ASSERTE(pRegAddr != NULL);

            CORDB_ADDRESS pRemoteValue = PTR_TO_CORDB_ADDRESS(*pRegAddr +
                                  pJITInfo->loc.vlRegStk.vlrsStk.vlrssOffset);

            hr = m_nativeFrame->GetLocalMemoryRegisterValue(
                          pRemoteValue,
                          g_JITToCorDbgReg[pJITInfo->loc.vlRegStk.vlrsReg],
                          cbSigBlob, pvSigBlob, ppValue);
        }
        break;

    case ICorJitInfo::VLT_STK_REG:
        {
            DWORD *pRegAddr =
                m_nativeFrame->GetAddressOfRegister(g_JITToCorDbgReg[pJITInfo->loc.vlStkReg.vlsrStk.vlsrsBaseReg]);
            _ASSERTE(pRegAddr != NULL);

            CORDB_ADDRESS pRemoteValue = PTR_TO_CORDB_ADDRESS(*pRegAddr +
                                  pJITInfo->loc.vlStkReg.vlsrStk.vlsrsOffset);

            hr = m_nativeFrame->GetLocalRegisterMemoryValue(
                          g_JITToCorDbgReg[pJITInfo->loc.vlStkReg.vlsrReg],
                          pRemoteValue, cbSigBlob, pvSigBlob, ppValue);
        }
        break;

    case ICorJitInfo::VLT_STK2:
        {
            DWORD *pRegAddr =
                m_nativeFrame->GetAddressOfRegister(g_JITToCorDbgReg[pJITInfo->loc.vlStk2.vls2BaseReg]);
            _ASSERTE(pRegAddr != NULL);

            CORDB_ADDRESS pRemoteValue = PTR_TO_CORDB_ADDRESS(*pRegAddr +
                                    pJITInfo->loc.vlStk2.vls2Offset);

            hr = m_nativeFrame->GetLocalMemoryValue(pRemoteValue,
                                                    cbSigBlob, pvSigBlob,
                                                    ppValue);
        }
        break;

    case ICorJitInfo::VLT_FPSTK:
        hr = m_nativeFrame->GetLocalFloatingPointValue(
                         pJITInfo->loc.vlFPstk.vlfReg + REGISTER_X86_FPSTACK_0,
                         cbSigBlob, pvSigBlob, ppValue);
        break;

    case ICorJitInfo::VLT_MEMORY:
        hr = m_nativeFrame->GetLocalMemoryValue(
                                PTR_TO_CORDB_ADDRESS(pJITInfo->loc.vlMemory.rpValue),
                                cbSigBlob, pvSigBlob,
                                ppValue);
        break;

    case ICorJitInfo::VLT_FIXED_VA:
        if (m_sig == NULL) //no var args info
            return CORDBG_E_IL_VAR_NOT_AVAILABLE;
    
        CORDB_ADDRESS pRemoteValue;
        pRemoteValue = PTR_TO_CORDB_ADDRESS((BYTE*)m_rpFirstArg - 
                                    pJITInfo->loc.vlFixedVarArg.vlfvOffset);
        // Remember to subtract out this amount                                    
        pRemoteValue += sizeof(((CORINFO_VarArgInfo*)0)->argBytes);
        hr = m_nativeFrame->GetLocalMemoryValue(pRemoteValue,
                                                cbSigBlob, pvSigBlob,
                                                ppValue);
                                                
        break;

        
    default:
        _ASSERTE(!"Invalid locVarType");
        hr = E_FAIL;
        break;
    }
                
    return hr;
}

HRESULT CordbJITILFrame::EnumerateLocalVariables(ICorDebugValueEnum **ppValueEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppValueEnum, ICorDebugValueEnum **);

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    ICorDebugValueEnum *icdVE = new CordbValueEnum( (CordbFrame*)m_nativeFrame,
                      CordbValueEnum::LOCAL_VARS, CordbValueEnum::JIT_IL_FRAME);
    if ( icdVE == NULL )
    {
        (*ppValueEnum) = NULL;
        return E_OUTOFMEMORY;
    }
    
    (*ppValueEnum) = (ICorDebugValueEnum*)icdVE;
    icdVE->AddRef();
    return S_OK;
}

HRESULT CordbJITILFrame::GetLocalVariable(DWORD dwIndex, 
                                          ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    CordbFunction *pFunction = m_ilCode->m_function;
    ICorJitInfo::NativeVarInfo *pNativeInfo;

    //
    // First, make sure that we've got the jitted variable location data
    // loaded from the left side.
    //

    HRESULT hr = pFunction->LoadNativeInfo();

    if (SUCCEEDED(hr))
    {
        ULONG cArgs;
        if (m_fVarArgFnx == true && m_sig != NULL)
        {
            cArgs = m_argCount;
        }
        else
        {
            cArgs = pFunction->m_argumentCount;
        }

        hr = ILVariableToNative(dwIndex + cArgs,
                                m_nativeFrame->m_ip,
                                &pNativeInfo);

        if (SUCCEEDED(hr))
        {
            // Get the type of this argument from the function
            ULONG cbSigBlob;
            PCCOR_SIGNATURE pvSigBlob;

            hr = pFunction->GetLocalVariableType(dwIndex,&cbSigBlob, &pvSigBlob);

            if (SUCCEEDED(hr))
                hr = GetNativeVariable(cbSigBlob, pvSigBlob,
                                       pNativeInfo, ppValue);
        }
    }

    return hr;
}

HRESULT CordbJITILFrame::GetLocalVariableWithType(ULONG cbSigBlob,
                                                  PCCOR_SIGNATURE pvSigBlob,
                                                  DWORD dwIndex, 
                                                  ICorDebugValue **ppValue)
{
    *ppValue = NULL;

    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        cbSigBlob -= cb;
        pvSigBlob = &pvSigBlob[cb];
    }
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    CordbFunction *pFunction = m_ilCode->m_function;
    ICorJitInfo::NativeVarInfo *pNativeInfo;

    //
    // First, make sure that we've got the jitted variable location data
    // loaded from the left side.
    //
    HRESULT hr = pFunction->LoadNativeInfo();

    if (SUCCEEDED(hr))
    {
        ULONG cArgs;
        if (m_fVarArgFnx == true && m_sig != NULL)
        {
            cArgs = m_argCount;
        }
        else
        {
            cArgs = pFunction->m_argumentCount;
        }

        hr =ILVariableToNative(dwIndex + cArgs,
                               m_nativeFrame->m_ip,
                               &pNativeInfo);

        if (SUCCEEDED(hr))
            hr = GetNativeVariable(cbSigBlob, pvSigBlob, pNativeInfo, ppValue);
    }

    return hr;
}

HRESULT CordbJITILFrame::EnumerateArguments(ICorDebugValueEnum **ppValueEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppValueEnum, ICorDebugValueEnum **);

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    ICorDebugValueEnum *icdVE = new CordbValueEnum( (CordbFrame*)m_nativeFrame,
                         CordbValueEnum::ARGS, CordbValueEnum::JIT_IL_FRAME);
    if ( icdVE == NULL )
    {
        (*ppValueEnum) = NULL;
        return E_OUTOFMEMORY;
    }
    
    (*ppValueEnum) = (ICorDebugValueEnum*)icdVE;
    icdVE->AddRef();
    return S_OK;
}

HRESULT CordbJITILFrame::GetArgument(DWORD dwIndex, ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    CordbFunction *pFunction = m_ilCode->m_function;
    ICorJitInfo::NativeVarInfo *pNativeInfo;

    //
    // First, make sure that we've got the jitted variable location data
    // loaded from the left side.
    //
    HRESULT hr = pFunction->LoadNativeInfo();

    if (SUCCEEDED(hr))
    {
        hr = ILVariableToNative(dwIndex, m_nativeFrame->m_ip, &pNativeInfo);

        if (SUCCEEDED(hr))
        {
            // Get the type of this argument from the function
            ULONG cbSigBlob;
            PCCOR_SIGNATURE pvSigBlob;

            hr = GetArgumentType(dwIndex, &cbSigBlob, &pvSigBlob);

            if (SUCCEEDED(hr))
                hr = GetNativeVariable(cbSigBlob, pvSigBlob,
                                       pNativeInfo, ppValue);
        }
    }

    return hr;
}

HRESULT CordbJITILFrame::GetArgumentWithType(ULONG cbSigBlob,
                                             PCCOR_SIGNATURE pvSigBlob,
                                             DWORD dwIndex, 
                                             ICorDebugValue **ppValue)
{
    *ppValue = NULL;

    //Get rid of funky modifiers
    ULONG cb = _skipFunkyModifiersInSignature(pvSigBlob);
    if( cb != 0)
    {
        _ASSERTE( (int)cb > 0 );
        cbSigBlob -= cb;
        pvSigBlob = &pvSigBlob[cb];
    }

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    CordbFunction *pFunction = m_ilCode->m_function;
    ICorJitInfo::NativeVarInfo *pNativeInfo;

    //
    // First, make sure that we've got the jitted variable location data
    // loaded from the left side.
    //
    HRESULT hr = pFunction->LoadNativeInfo();

    if (SUCCEEDED(hr))
    {
        hr = ILVariableToNative(dwIndex,
                                m_nativeFrame->m_ip,
                                &pNativeInfo);

        if (SUCCEEDED(hr))
            hr = GetNativeVariable(cbSigBlob, pvSigBlob, pNativeInfo, ppValue);
    }

    return hr;
}

HRESULT CordbJITILFrame::GetStackDepth(ULONG32 *pDepth)
{
    VALIDATE_POINTER_TO_OBJECT(pDepth, ULONG32 *);
    
#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    /* !!! */

    return E_NOTIMPL;
}

HRESULT CordbJITILFrame::GetStackValue(DWORD dwIndex, ICorDebugValue **ppValue)
{
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(GetProcess(), GetAppDomain());
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(GetProcess());
#endif    

    /* !!! */

    return E_NOTIMPL;
}

/* ------------------------------------------------------------------------- *
 * Eval class
 * ------------------------------------------------------------------------- */

CordbEval::CordbEval(CordbThread *pThread)
    : CordbBase(0), m_thread(pThread), m_complete(false),
      m_successful(false), m_aborted(false), m_resultAddr(NULL),
      m_resultType(ELEMENT_TYPE_VOID),
      m_resultDebuggerModuleToken(NULL),
      m_resultAppDomainToken(NULL),
      m_debuggerEvalKey(NULL),
      m_evalDuringException(false)
{
    // We must AddRef the process and the thread so we can properly fail out of SendCleanup if someone releases an
    // ICorDebugEval after the process has completely gone away. Bug 84251.
    m_thread->AddRef();
    m_thread->GetProcess()->AddRef();
}

CordbEval::~CordbEval()
{
    SendCleanup();

    // Release our references to the process and thread.
    m_thread->GetProcess()->Release();
    m_thread->Release();
}

HRESULT CordbEval::SendCleanup(void)
{
    HRESULT hr = S_OK;
    
    // Send a message to the left side to release the eval object over
    // there if one exists.
    if ((m_debuggerEvalKey != NULL) &&
        CORDBCheckProcessStateOK(m_thread->GetProcess()))
    {
        // Call Abort() before doing new CallFunction()
        if (!m_complete)
            return CORDBG_E_FUNC_EVAL_NOT_COMPLETE;

        // Release the left side handle to the object
        DebuggerIPCEvent event;

        m_thread->GetProcess()->InitIPCEvent(
                                &event, 
                                DB_IPCE_FUNC_EVAL_CLEANUP, 
                                true,
                                (void *)(m_thread->GetAppDomain()->m_id));

        event.FuncEvalCleanup.debuggerEvalKey = m_debuggerEvalKey;
    
        hr = m_thread->GetProcess()->SendIPCEvent(&event,
                                                  sizeof(DebuggerIPCEvent));

#if _DEBUG
        if (SUCCEEDED(hr))
            _ASSERTE(event.type == DB_IPCE_FUNC_EVAL_CLEANUP_RESULT);
#endif
        
        // Null out the key so we don't try to do this again.
        m_debuggerEvalKey = NULL;
    }

    return hr;
}

HRESULT CordbEval::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugEval)
        *pInterface = (ICorDebugEval*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugEval*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//
// Gather data about an argument to either CallFunction or NewObject
// and place it into a DebuggerIPCE_FuncEvalArgData struct for passing
// to the Left Side.
//
HRESULT CordbEval::GatherArgInfo(ICorDebugValue *pValue,
                                 DebuggerIPCE_FuncEvalArgData *argData)
{
    CORDB_ADDRESS addr;
    CorElementType ty;
    ICorDebugClass *pClass = NULL;
    ICorDebugModule *pModule = NULL;
    bool needRelease = false;

    pValue->GetType(&ty);

    // Note: if the value passed in is in fact a byref, then we need to dereference it to get to the real thing. Passing
    // a byref as a byref to a func eval is never right.
    if ((ty == ELEMENT_TYPE_BYREF) || (ty == ELEMENT_TYPE_TYPEDBYREF))
    {
        ICorDebugReferenceValue *prv = NULL;

        // The value had better implement ICorDebugReference value, or we're screwed.
        HRESULT hr = pValue->QueryInterface(IID_ICorDebugReferenceValue, (void**)&prv);

        if (FAILED(hr))
            return hr;

        // This really should always work for a byref, unless we're out of memory.
        hr = prv->Dereference(&pValue);
        prv->Release();

        if (FAILED(hr))
            return hr;

        // Make sure to get the type we were referencing for use below.
        pValue->GetType(&ty);
        needRelease = true;
    }

    // We should never have a byref by this point.
    _ASSERTE((ty != ELEMENT_TYPE_BYREF) && (ty != ELEMENT_TYPE_TYPEDBYREF));
    
    pValue->GetAddress(&addr);
            
    argData->argAddr = (void*)addr;
    argData->argType = ty;
    argData->argRefsInHandles = false;
    argData->argIsLiteral = false;

    // We have to have knowledge of our value implementation here,
    // which it would nice if we didn't have to know.
    CordbValue *cv = NULL;
                
    switch(ty)
    {
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_STRING:
    case ELEMENT_TYPE_PTR:
    case ELEMENT_TYPE_ARRAY:
    case ELEMENT_TYPE_SZARRAY:
        // A reference value
        cv = (CordbValue*)(CordbReferenceValue*)pValue;
        argData->argRefsInHandles =
            ((CordbReferenceValue*)pValue)->m_objectRefInHandle;

        // Is this a literal value? If, we'll copy the data to the
        // buffer area so the left side can get it.
        CordbReferenceValue *rv;
        rv = (CordbReferenceValue*)pValue;
        argData->argIsLiteral = rv->CopyLiteralData(argData->argLiteralData);
        break;

    case ELEMENT_TYPE_VALUETYPE:
        // A value class object
        cv = (CordbValue*)(CordbVCObjectValue*)(ICorDebugObjectValue*)pValue;

        ((CordbVCObjectValue*)(ICorDebugObjectValue*)pValue)->GetClass(&pClass);
        _ASSERTE(pClass);
        pClass->GetModule(&pModule);
        argData->GetClassInfo.classDebuggerModuleToken = ((CordbModule *)pModule)->m_debuggerModuleToken;
        pClass->GetToken(&(argData->GetClassInfo.classMetadataToken));
        break;

    default:
        // A generic value
        cv = (CordbValue*)(CordbGenericValue*)pValue;

        // Is this a literal value? If, we'll copy the data to the
        // buffer area so the left side can get it.
        CordbGenericValue *gv = (CordbGenericValue*)pValue;
        argData->argIsLiteral = gv->CopyLiteralData(argData->argLiteralData);
    }

    // Is it enregistered?
    if (addr == NULL)
        cv->GetRegisterInfo(argData);

    // clean up
    if (pClass)
        pClass->Release();
    if (pModule)
        pModule->Release();

    // Release pValue if we got it via a dereference from above.
    if (needRelease)
        pValue->Release();

    return S_OK;
}

HRESULT CordbEval::SendFuncEval(DebuggerIPCEvent * event)
{
    // Are we doing an eval during an exception? If so, we need to remember
    // that over here and also tell the Left Side.
    m_evalDuringException = event->FuncEval.evalDuringException = m_thread->m_exception;
    
    // Corresponding Release() on DB_IPCE_FUNC_EVAL_COMPLETE.
    // If a func eval is aborted, the LHS may not complete the abort
    // immediately and hence we cant do a SendCleanup(). Hence, we maintain
    // an extra ref-count to determine when this can be done.
    AddRef();

    HRESULT hr = m_thread->GetProcess()->SendIPCEvent(event, sizeof(DebuggerIPCEvent));

    // If the send failed, return that failure.
    if (FAILED(hr))
        goto LExit;

    _ASSERTE(event->type == DB_IPCE_FUNC_EVAL_SETUP_RESULT);

    hr = event->hr;

LExit:
    // Save the key to the eval on the left side for future reference.
    if (SUCCEEDED(hr))
    {
        m_debuggerEvalKey = event->FuncEvalSetupComplete.debuggerEvalKey;
    }
    else
    {
        // We dont expect to receive a DB_IPCE_FUNC_EVAL_COMPLETE, so just release here
        Release();
    }
 
    return hr;
}

HRESULT CordbEval::CallFunction(ICorDebugFunction *pFunction, 
                                ULONG32 nArgs,
                                ICorDebugValue *pArgs[])
{
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE( !"Shouldn't have invoked this function from the left side!\n");
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(pFunction, ICorDebugFunction *);
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pArgs, ICorDebugValue *, nArgs, true, true);

    CORDBRequireProcessStateOKAndSync(m_thread->GetProcess(), m_thread->GetAppDomain());

    HRESULT hr = S_OK;


    // The LS will assume that all of the ICorDebugValue's are in the same
    // appdomain as the pFunction. Verify this assumption now, and fail if
    // it's not true.
    {
        CordbAppDomain * pAppDomain = ((CordbFunction*) pFunction)->GetAppDomain();
        
        // Make sure each arg is also in that appdomain.
        for(unsigned int i = 0; i < nArgs; i++)
        {
            // Assuming that only Ref Values have AD affinity
            ICorDebugValue * p = pArgs[i];
            ICorDebugReferenceValue * refP = NULL;

            p->QueryInterface(IID_ICorDebugReferenceValue, (void**)&refP);
            if (refP != NULL)
            {
                CordbReferenceValue * crp = (CordbReferenceValue *) refP;
                CordbValue * pValue = crp;
                
                if ((pValue->GetAppDomain() != NULL) && (pValue->GetAppDomain() != pAppDomain))
                {
                    LOG((LF_CORDB,LL_INFO1000, "CordbEval::CF - AD mismatch. method=0x%08x, param #%d=0x%08x, must fail.\n",
                        pAppDomain, i, pValue->GetAppDomain()));
                    refP->Release();
                    return E_INVALIDARG;
                }
                
                refP->Release();
            }
        } // end for each argument
    } // end AppDomain Check

    

    // Callers are free to reuse an ICorDebugEval object for multiple
    // evals. Since we create a Left Side eval representation each
    // time, we need to be sure to clean it up now that we know we're
    // done with it.
    hr = SendCleanup();

    if (FAILED(hr))
        return hr;
    
    // Remember the function that we're evaluating.
    m_function = (CordbFunction*)pFunction;
    m_evalType = DB_IPCE_FET_NORMAL;

    // Arrange the arguments into a form that the left side can deal
    // with. We do this before starting the func eval setup to ensure
    // that we can complete this step before screwing up the left
    // side.
    DebuggerIPCE_FuncEvalArgData *argData = NULL;
    
    if (nArgs > 0)
    {
        // We need to make the same type of array that the left side
        // holds.
        argData = new DebuggerIPCE_FuncEvalArgData[nArgs];

        if (argData == NULL)
            return E_OUTOFMEMORY;

        // For each argument, convert its home into something the left
        // side can understand.
        for (unsigned int i = 0; i < nArgs; i++)
        {
            hr = GatherArgInfo(pArgs[i], &(argData[i]));

            if (FAILED(hr))
                return hr;
        }
    }
        
    // Send over to the left side and get it to setup this eval.
    DebuggerIPCEvent event;
    m_thread->GetProcess()->InitIPCEvent(&event, 
                                         DB_IPCE_FUNC_EVAL, 
                                         true,
                                         (void *)(m_thread->GetAppDomain()->m_id));
    event.FuncEval.funcDebuggerThreadToken = m_thread->m_debuggerThreadToken;
    event.FuncEval.funcEvalType = m_evalType;
    event.FuncEval.funcMetadataToken = m_function->m_token;
    event.FuncEval.funcDebuggerModuleToken = m_function->GetModule()->m_debuggerModuleToken;
    event.FuncEval.funcEvalKey = (void*)this;
    event.FuncEval.argCount = nArgs;

    hr = SendFuncEval(&event);

    // Memory has been allocated to hold info about each argument on
    // the left side now, so copy the argument data over to the left
    // side. No need to send another event, since the left side won't
    // take any more action on this evaluation until the process is
    // continued anyway.
    if (SUCCEEDED(hr) && (nArgs > 0))
    {
        _ASSERTE(argData != NULL);
        
        if (!WriteProcessMemory(m_thread->m_process->m_handle,
                                event.FuncEvalSetupComplete.argDataArea,
                                argData,
                                sizeof(DebuggerIPCE_FuncEvalArgData) * nArgs,
                                NULL))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // Cleanup

    if (argData)
        delete [] argData;
    
    // Return any failure the Left Side may have told us about.
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbEval::NewObject(ICorDebugFunction *pConstructor,
                             ULONG32 nArgs,
                             ICorDebugValue *pArgs[])
{
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE( !"Shouldn't have invoked this function from the left side!\n");
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(pConstructor, ICorDebugFunction *);
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pArgs, ICorDebugValue *, nArgs, true, true);    

    CORDBRequireProcessStateOKAndSync(m_thread->GetProcess(), m_thread->GetAppDomain());

    // Callers are free to reuse an ICorDebugEval object for multiple
    // evals. Since we create a Left Side eval representation each
    // time, we need to be sure to clean it up now that we know we're
    // done with it.
    HRESULT hr = SendCleanup();

    if (FAILED(hr))
        return hr;
    
    // Remember the function that we're evaluating.
    m_function = (CordbFunction*)pConstructor;
    m_evalType = DB_IPCE_FET_NEW_OBJECT;

    // Arrange the arguments into a form that the left side can deal
    // with. We do this before starting the func eval setup to ensure
    // that we can complete this step before screwing up the left
    // side.
    DebuggerIPCE_FuncEvalArgData *argData = NULL;
    
    if (nArgs > 0)
    {
        // We need to make the same type of array that the left side
        // holds.
        argData = new DebuggerIPCE_FuncEvalArgData[nArgs];

        if (argData == NULL)
            return E_OUTOFMEMORY;

        // For each argument, convert its home into something the left
        // side can understand.
        for (unsigned int i = 0; i < nArgs; i++)
        {
            hr = GatherArgInfo(pArgs[i], &(argData[i]));

            if (FAILED(hr))
                return hr;
        }
    }

    // Send over to the left side and get it to setup this eval.
    DebuggerIPCEvent event;
    m_thread->GetProcess()->InitIPCEvent(&event, 
                                         DB_IPCE_FUNC_EVAL, 
                                         true,
                                         (void *)(m_thread->GetAppDomain()->m_id));
    event.FuncEval.funcDebuggerThreadToken = m_thread->m_debuggerThreadToken;
    event.FuncEval.funcEvalType = m_evalType;
    event.FuncEval.funcMetadataToken = m_function->m_token;
    event.FuncEval.funcDebuggerModuleToken =
        m_function->GetModule()->m_debuggerModuleToken;
    event.FuncEval.funcEvalKey = (void*)this;
    event.FuncEval.argCount = nArgs;

    hr = SendFuncEval(&event);
    
    // Memory has been allocated to hold info about each argument on
    // the left side now, so copy the argument data over to the left
    // side. No need to send another event, since the left side won't
    // take any more action on this evaluation until the process is
    // continued anyway.
    if (SUCCEEDED(hr) && (nArgs > 0))
    {
        _ASSERTE(argData != NULL);
        
        if (!WriteProcessMemory(m_thread->m_process->m_handle,
                                event.FuncEvalSetupComplete.argDataArea,
                                argData,
                                sizeof(DebuggerIPCE_FuncEvalArgData) * nArgs,
                                NULL))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // Cleanup

    if (argData)
        delete [] argData;
    
    // Return any failure the Left Side may have told us about.
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbEval::NewObjectNoConstructor(ICorDebugClass *pClass)
{
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE( !"Shouldn't have invoked this function from the left side!\n");
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(pClass, ICorDebugClass *);

    CORDBRequireProcessStateOKAndSync(m_thread->GetProcess(), m_thread->GetAppDomain());

    // Callers are free to reuse an ICorDebugEval object for multiple
    // evals. Since we create a Left Side eval representation each
    // time, we need to be sure to clean it up now that we know we're
    // done with it.
    HRESULT hr = SendCleanup();

    if (FAILED(hr))
        return hr;
    
    // Remember the function that we're evaluating.
    m_class = (CordbClass*)pClass;
    m_evalType = DB_IPCE_FET_NEW_OBJECT_NC;

    // Send over to the left side and get it to setup this eval.
    DebuggerIPCEvent event;
    m_thread->GetProcess()->InitIPCEvent(&event, 
                                         DB_IPCE_FUNC_EVAL, 
                                         true,
                                         (void *)(m_thread->GetAppDomain()->m_id));
    event.FuncEval.funcDebuggerThreadToken = m_thread->m_debuggerThreadToken;
    event.FuncEval.funcEvalType = m_evalType;
    event.FuncEval.funcMetadataToken = mdMethodDefNil;
    event.FuncEval.funcClassMetadataToken = (mdTypeDef)m_class->m_id;
    event.FuncEval.funcDebuggerModuleToken =
        m_class->GetModule()->m_debuggerModuleToken;
    event.FuncEval.funcEvalKey = (void*)this;
    event.FuncEval.argCount = 0;

    hr = SendFuncEval(&event);

    // Return any failure the Left Side may have told us about.
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbEval::NewString(LPCWSTR string)
{
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE( !"Shouldn't have invoked this function from the left side!\n");
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    // Gotta have a string...
    VALIDATE_POINTER_TO_OBJECT(string, LPCWSTR);

    CORDBRequireProcessStateOKAndSync(m_thread->GetProcess(), m_thread->GetAppDomain());

    // Callers are free to reuse an ICorDebugEval object for multiple
    // evals. Since we create a Left Side eval representation each
    // time, we need to be sure to clean it up now that we know we're
    // done with it.
    HRESULT hr = SendCleanup();

    if (FAILED(hr))
        return hr;
    
    // Length of the string? Don't forget to add 1 for the \0...
    SIZE_T strLen = (wcslen(string) + 1) * sizeof(WCHAR);

    // Remember that we're doing a func eval for a new string.
    m_function = NULL;
    m_evalType = DB_IPCE_FET_NEW_STRING;

    // Send over to the left side and get it to setup this eval.
    DebuggerIPCEvent event;
    m_thread->GetProcess()->InitIPCEvent(&event, 
                                         DB_IPCE_FUNC_EVAL, 
                                         true,
                                         (void *)(m_thread->GetAppDomain()->m_id));
    event.FuncEval.funcDebuggerThreadToken = m_thread->m_debuggerThreadToken;
    event.FuncEval.funcEvalType = m_evalType;
    event.FuncEval.funcEvalKey = (void*)this;
    event.FuncEval.stringSize = strLen;

    // Note: no function or module here...
    event.FuncEval.funcMetadataToken = mdMethodDefNil;
    event.FuncEval.funcDebuggerModuleToken = NULL;
    
    hr = SendFuncEval(&event);
    
    // Memory has been allocated to hold the string on the left side
    // now, so copy the string over to the left side. No need to send
    // another event, since the left side won't take any more action
    // on this evaluation until the process is continued anyway.
    if (SUCCEEDED(hr) && (strLen > 0))
    {
        if (!WriteProcessMemory(m_thread->m_process->m_handle,
                                event.FuncEvalSetupComplete.argDataArea,
                                (void*)string,
                                strLen,
                                NULL))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // Return any failure the Left Side may have told us about.
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbEval::NewArray(CorElementType elementType,
                            ICorDebugClass *pElementClass, 
                            ULONG32 rank,
                            ULONG32 dims[], 
                            ULONG32 lowBounds[])
{
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE( !"Shouldn't have invoked this function from the left side!\n");
    return CORDBG_E_INPROC_NOT_IMPL;
#else

    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pElementClass, ICorDebugClass *);

    CORDBRequireProcessStateOKAndSync(m_thread->GetProcess(), m_thread->GetAppDomain());

    // Callers are free to reuse an ICorDebugEval object for multiple evals. Since we create a Left Side eval
    // representation each time, we need to be sure to clean it up now that we know we're done with it.
    HRESULT hr = SendCleanup();

    if (FAILED(hr))
        return hr;
    
    // Arg check...
    if ((elementType == ELEMENT_TYPE_VOID) || (rank == 0) || (dims == NULL))
        return E_INVALIDARG;

    // If you want a class, you gotta pass a class.
    if ((elementType == ELEMENT_TYPE_CLASS) && (pElementClass == NULL))
        return E_INVALIDARG;

    // If you want an array of objects, then why pass a class?
    if ((elementType == ELEMENT_TYPE_OBJECT) && (pElementClass != NULL))
        return E_INVALIDARG;

    // Amount of extra data space we'll need...
    SIZE_T dataLen;

    if (lowBounds == NULL)
        dataLen = rank * sizeof(SIZE_T);
    else
        dataLen = rank * sizeof(SIZE_T) * 2;

    // Remember that we're doing a func eval for a new string.
    m_function = NULL;
    m_evalType = DB_IPCE_FET_NEW_ARRAY;

    // Send over to the left side and get it to setup this eval.
    DebuggerIPCEvent event;
    m_thread->GetProcess()->InitIPCEvent(&event, 
                                         DB_IPCE_FUNC_EVAL, 
                                         true,
                                         (void *)(m_thread->GetAppDomain()->m_id));
    event.FuncEval.funcDebuggerThreadToken = m_thread->m_debuggerThreadToken;
    event.FuncEval.funcEvalType = m_evalType;
    event.FuncEval.funcEvalKey = (void*)this;

    event.FuncEval.arrayRank = rank;
    event.FuncEval.arrayDataLen = dataLen;
    event.FuncEval.arrayElementType = elementType;

    if (pElementClass != NULL)
    {
        CordbClass *c = (CordbClass*)pElementClass;

        event.FuncEval.arrayClassMetadataToken = c->m_id;
        event.FuncEval.arrayClassDebuggerModuleToken = c->GetModule()->m_debuggerModuleToken;
    }
    else
    {
        event.FuncEval.arrayClassMetadataToken = mdTypeDefNil;
        event.FuncEval.arrayClassDebuggerModuleToken = NULL;
    }

    // Note: no function or module here...
    event.FuncEval.funcMetadataToken = mdMethodDefNil;
    event.FuncEval.funcDebuggerModuleToken = NULL;

    hr = SendFuncEval(&event);
    
    // Memory has been allocated to hold the dimension and bounds data on the left side, so copy the data over to the
    // left side. No need to send another event, since the left side won't take any more action on this evaluation until
    // the process is continued anyway.
    if (SUCCEEDED(hr) && (dataLen > 0))
    {
        if (!WriteProcessMemory(m_thread->m_process->m_handle,
                                event.FuncEvalSetupComplete.argDataArea,
                                (void*)dims,
                                rank * sizeof(SIZE_T),
                                NULL))
            hr = HRESULT_FROM_WIN32(GetLastError());

        if (SUCCEEDED(hr) && (lowBounds != NULL))
            if (!WriteProcessMemory(m_thread->m_process->m_handle,
                                    event.FuncEvalSetupComplete.argDataArea + (rank * sizeof(SIZE_T)),
                                    (void*)lowBounds,
                                    rank * sizeof(SIZE_T),
                                    NULL))
                hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // Return any failure the Left Side may have told us about.
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbEval::IsActive(BOOL *pbActive)
{
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE( !"Shouldn't have invoked this function from the left side!\n");
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(pbActive, BOOL *);

    *pbActive = (m_complete == true);
    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbEval::Abort(void)
{
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE( !"Shouldn't have invoked this function from the left side!\n");
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    // No need to abort if its already completed.
    if (m_complete)
        return S_OK;

    // Can't abort if its never even been started.
    if (m_debuggerEvalKey == NULL)
        return E_INVALIDARG;
    
    CORDBRequireProcessStateOK(m_thread->GetProcess());

    // Send over to the left side to get the eval aborted.
    DebuggerIPCEvent event;
    
    m_thread->GetProcess()->InitIPCEvent(&event,
                                         DB_IPCE_FUNC_EVAL_ABORT, 
                                         true,
                                         (void *)(m_thread->GetAppDomain()->m_id));
    event.FuncEvalAbort.debuggerEvalKey = m_debuggerEvalKey;

    HRESULT hr = m_thread->GetProcess()->SendIPCEvent(
                                                 &event,
                                                 sizeof(DebuggerIPCEvent));
    // If the send failed, return that failure.
    if (FAILED(hr))
        return hr;

    _ASSERTE(event.type == DB_IPCE_FUNC_EVAL_ABORT_RESULT);

    hr = event.hr;

    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbEval::GetResult(ICorDebugValue **ppResult)
{
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE( !"Shouldn't have invoked this function from the left side!\n");
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppResult, ICorDebugValue **);

    // Is the evaluation complete?
    if (!m_complete)
        return CORDBG_E_FUNC_EVAL_NOT_COMPLETE;

    if (m_aborted)
        return CORDBG_S_FUNC_EVAL_ABORTED;
    
    // Does the evaluation have a result?
    if (m_resultType == ELEMENT_TYPE_VOID)
    {
        *ppResult = NULL;
        return CORDBG_S_FUNC_EVAL_HAS_NO_RESULT;
    }

    CORDBRequireProcessStateOKAndSync(m_thread->GetProcess(), m_thread->GetAppDomain());

    HRESULT hr = S_OK;

    // Make a ICorDebugValue out of the result. We need the
    // CordbModule that the result is relative to, so find the
    // appdomain, then the module within that app domain.
    CordbAppDomain *appdomain;
    CordbModule *module;

    if (m_resultDebuggerModuleToken != NULL)
    {
        appdomain = (CordbAppDomain*) m_thread->GetProcess()->m_appDomains.GetBase((ULONG)m_resultAppDomainToken);
        _ASSERTE(appdomain != NULL);

        module = (CordbModule*) appdomain->LookupModule(m_resultDebuggerModuleToken);
    }
    else
    {
        // Some results from CreateString and CreateArray wont have a module. But that's okay, any module will do.
        appdomain = m_thread->GetAppDomain();
        module = m_thread->GetAppDomain()->GetAnyModule();
    }

    _ASSERTE(module != NULL);

    // Now that we have the module, go ahead and create the result.
    hr = CordbValue::CreateValueByType(appdomain,
                                       module,
                                       sizeof(CorElementType),
                                       (PCCOR_SIGNATURE) &m_resultType,
                                       NULL,
                                       m_resultAddr,
                                       NULL,
                                       true,
                                       NULL,
                                       (IUnknown*)(ICorDebugEval*)this,
                                       ppResult);
    
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbEval::GetThread(ICorDebugThread **ppThread)
{
#ifndef RIGHT_SIDE_ONLY
    _ASSERTE( !"Shouldn't have invoked this function from the left side!\n");
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppThread, ICorDebugThread **);

    *ppThread = (ICorDebugThread*)m_thread;
    (*ppThread)->AddRef();

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbEval::CreateValue(CorElementType elementType,
                               ICorDebugClass *pElementClass,
                               ICorDebugValue **ppValue)
{
    HRESULT hr = S_OK;
    
    VALIDATE_POINTER_TO_OBJECT(ppValue, ICorDebugValue **);

    // @todo: only primitive values right now.
    if (((elementType < ELEMENT_TYPE_BOOLEAN) ||
         (elementType > ELEMENT_TYPE_R8)) &&
        (elementType != ELEMENT_TYPE_CLASS))
        return E_INVALIDARG;

    if (elementType == ELEMENT_TYPE_CLASS)
    {
        CordbReferenceValue *rv = new CordbReferenceValue(
                                                1,
                                                (PCCOR_SIGNATURE)&elementType);
        
        if (rv)
        {
            HRESULT hr = rv->Init(false);

            if (SUCCEEDED(hr))
            {
                rv->AddRef();
                *ppValue = (ICorDebugValue*)(ICorDebugReferenceValue*)rv;
            }
            else
                delete rv;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        // Create a generic value.
        CordbGenericValue *gv = new CordbGenericValue(
                                             1,
                                             (PCCOR_SIGNATURE)&elementType);

        if (gv)
        {
            HRESULT hr = gv->Init();

            if (SUCCEEDED(hr))
            {
                gv->AddRef();
                *ppValue = (ICorDebugValue*)(ICorDebugGenericValue*)gv;
            }
            else
                delete gv;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <stdio.h>

// Note that we want right-side specific code
#define RIGHT_SIDE_ONLY 

#include "corpub.h"
#include "..\inc\cordb.h"

#ifdef _DEBUG
#include "dbgalloc.h"
#include "utilcode.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\debugger.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: debugger.h
//
// Header file for Runtime Controller classes of the COM+ Debugging Services.
//
// @doc
//*****************************************************************************

#ifndef DEBUGGER_H_
#define DEBUGGER_H_

#define COMPLUS_EE 1
#include <Windows.h>

#include <UtilCode.h>

#ifdef _DEBUG
#define LOGGING
#endif

#include <Log.h>

#include "cor.h"
#include "corpriv.h"

#include "common.h"
#include "winwrap.h"
#include "threads.h"
#include "frames.h"

#include "AppDomain.hpp"
#include "eedbginterface.h"
#include "dbginterface.h"
#include "corhost.h"


#include "corjit.h"
#include <DbgMeta.h> // need to rip this out of here...

#include "frameinfo.h"

#include "CorPub.h"
#include "Cordb.h"

#include "gmheap.hpp"

#include "nexport.h"

// !!! need better definitions...

#undef ASSERT
#define CRASH(x)  _ASSERTE(!x)
#define ASSERT(x) _ASSERTE(x)
#define PRECONDITION _ASSERTE
#define POSTCONDITION _ASSERTE

#ifndef TRACE_MEMORY
#define TRACE_MEMORY 0
#endif

#if TRACE_MEMORY
#define TRACE_ALLOC(p)  LOG((LF_CORDB, LL_INFO10000, \
                       "--- Allocated %x at %s:%d\n", p, __FILE__, __LINE__));
#define TRACE_FREE(p)   LOG((LF_CORDB, LL_INFO10000, \
                       "--- Freed %x at %s:%d\n", p, __FILE__, __LINE__));
#else
#define TRACE_ALLOC(p)
#define TRACE_FREE(p)
#endif

typedef CUnorderedArray<BYTE *,11> UnorderedBytePtrArray;


/* ------------------------------------------------------------------------ *
 * Forward class declarations
 * ------------------------------------------------------------------------ */

class DebuggerFrame;
class DebuggerModule;
class DebuggerModuleTable;
class Debugger;
class DebuggerRCThread;
class DebuggerBreakpoint;
class DebuggerStepper;
class DebuggerJitInfo;
struct DebuggerControllerPatch;
struct DebuggerEval;
class DebuggerControllerQueue;
class DebuggerController;
class DebuggerHeap;
class CNewZeroData;
template<class T> void DeleteInteropSafe(T *p);

/* ------------------------------------------------------------------------ *
 * Global variables
 * ------------------------------------------------------------------------ */

extern Debugger             *g_pDebugger;
extern EEDebugInterface     *g_pEEInterface;
extern DebuggerRCThread     *g_pRCThread;

#define CORDBDebuggerSetUnrecoverableWin32Error(__d, __code, __w) \
    ((__d)->UnrecoverableError(HRESULT_FROM_WIN32(GetLastError()), \
                               (__code), __FILE__, __LINE__, (__w)), \
     HRESULT_FROM_WIN32(GetLastError()))

#define CORDBUnrecoverableError(__d) ((__d)->m_unrecoverableError == TRUE)
        
/* ------------------------------------------------------------------------ *
 * Thread classes
 * ------------------------------------------------------------------------ */

class DebuggerThread
{
public:
    static HRESULT TraceAndSendStack(Thread *thread,
                                     DebuggerRCThread* rcThread,
                                     IpcTarget iWhich);
                                     
    static HRESULT GetAndSendFloatState(Thread *thread,
                                        DebuggerRCThread* rcThread,
                                        IpcTarget iWhich);

  private:
    static StackWalkAction TraceAndSendStackCallback(FrameInfo *pInfo,
                                                     VOID* data);
                                                     
    static StackWalkAction StackWalkCount(FrameInfo *pinfo,
                                          VOID* data);

    static inline CORDB_ADDRESS GetObjContext( CrawlFrame *pCf );
};


/* ------------------------------------------------------------------------ *
 * Module classes
 * ------------------------------------------------------------------------ */

// DebuggerModules don't get deleted until the Debugger object is deleted.
// This is so we can set m_fDeleted, and check it before derefing it, in
// case some goober decides to keep a CordbBreakpoint object around,
// and try and (de)activate it after the module's been unloaded.
// So when the module gets unloaded, we'll tack it onto the front 
// of the DebuggerModuleTable->m_pDeletedList,
// and check for it in the future before derefing it.
class DebuggerModule
{
  public:
    DebuggerModule(Module* pRuntimeModule, AppDomain *pAppDomain) :
        m_pRuntimeModule(pRuntimeModule),
        m_pAppDomain(pAppDomain),
        m_enableClassLoadCallbacks(FALSE),
        m_fHasLoadedSymbols(FALSE),
        m_fDeleted(FALSE)
        
    {
        LOG((LF_CORDB,LL_INFO10000, "DM::DM this:0x%x Module:0x%x AD:0x%x\n",
            this, pRuntimeModule, pAppDomain));
    }
    
    BOOL ClassLoadCallbacksEnabled(void) { return m_enableClassLoadCallbacks; }
    void EnableClassLoadCallbacks(BOOL f) { m_enableClassLoadCallbacks = f; }

    BOOL GetHasLoadedSymbols(void) { return m_fHasLoadedSymbols; }
    void SetHasLoadedSymbols(BOOL f) { m_fHasLoadedSymbols = f; }

    Module*       m_pRuntimeModule;

    union 
    {
        AppDomain*     m_pAppDomain;
        // m_pNextDeleted is only valid if this is in the DebuggerModuleTable's
        // list of deleted DebuggerModules.
        DebuggerModule *m_pNextDeleted;
    };

    AppDomain* GetAppDomain() 
    {
        _ASSERTE(!m_fDeleted);
        return m_pAppDomain;
    }
    
  private:
    BOOL          m_fHasLoadedSymbols;
    BOOL          m_enableClassLoadCallbacks;
    
  public: //@todo will putting these all adjacent clue the compiler in to 
          // the fact that we want them all in the same DWORD?  Perhaps
          // bitfields?
    BOOL          m_fDeleted;
};

struct DebuggerModuleEntry
{
    FREEHASHENTRY   entry;
    DebuggerModule* module;
};

class DebuggerModuleTable : private CHashTableAndData<CNewZeroData>
{
  private:

    BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
    { return ((Module*)pc1) !=
          ((DebuggerModuleEntry*)pc2)->module->m_pRuntimeModule; }

    USHORT HASH(Module* module)
    { return (USHORT) ((DWORD) module ^ ((DWORD)module>>16)); }

    BYTE *KEY(Module* module)
    { return (BYTE *) module; }

  public:
    DebuggerModule *m_pDeletedList;
    
    // We put something into the 'deleted' list by setting the 
    // 'deleted' flag, then putting it into a list (for later, true,
    // deletion), and setting the bool
    void AddDMToDeletedList(DebuggerModule *dm)
    {
        LOG((LF_CORDB, LL_INFO10000, "DMT::ATDDM: Adding DebuggerModule 0x%x"
            "in the deleted list\n", dm));
            
        // Prepend onto front of list.
        dm->m_pNextDeleted = m_pDeletedList;
        m_pDeletedList = dm;
        dm->m_fDeleted = TRUE;
    }

    void DeleteAllDeletedDebuggerModulesForReal(void)
    {
        LOG((LF_CORDB, LL_INFO10000, "DMT::DADDMFR\n"));

        while (m_pDeletedList != NULL)
        {
            DebuggerModule *pTemp = m_pDeletedList;
            m_pDeletedList = m_pDeletedList->m_pNextDeleted;
            DeleteInteropSafe(pTemp);
            
            LOG((LF_CORDB, LL_INFO10000, "DMT::DADDMFR: DebuggerModule 0x%x is now "
                "deleted for real!\n", pTemp));
        }
    }

    BOOL IsDebuggerModuleDeleted(DebuggerModule *dm)
    {
        LOG((LF_CORDB, LL_INFO10000, "DMT::IDMD 0x%x\n", dm));

		if (dm == NULL)
			return FALSE;

#ifdef _DEBUG        
        DebuggerModule *pTemp = m_pDeletedList;
        while (pTemp != NULL)
        {
            LOG((LF_CORDB, LL_INFO10000, "DMT::IDMD: Given:0x%x cur List item:0x%x\n",
                dm, pTemp));
            if (pTemp == dm)
            {
                _ASSERTE(dm->m_fDeleted==TRUE);
            }
            pTemp = pTemp->m_pNextDeleted;
        }
        _ASSERTE(dm->m_fDeleted==FALSE);
#endif //_DEBUG

        return dm->m_fDeleted;
    }

    DebuggerModuleTable() : CHashTableAndData<CNewZeroData>(101), m_pDeletedList(NULL)
    { 
        NewInit(101, sizeof(DebuggerModuleEntry), 101); 
    }

    ~DebuggerModuleTable()
    {
        DeleteAllDeletedDebuggerModulesForReal();
        Clear();
    }

    void AddModule(DebuggerModule *module)
    { 
        _ASSERTE(module != NULL);
        
        LOG((LF_CORDB, LL_EVERYTHING, "DMT::AM: DebuggerMod:0x%x Module:0x%x AD:0x%x\n", 
            module, module->m_pRuntimeModule, module->m_pAppDomain));
    
        ((DebuggerModuleEntry*)Add(HASH(module->m_pRuntimeModule)))->module =
          module; 
    }

    DebuggerModule *GetModule(Module* module)
    { 
        _ASSERTE(module != NULL);
    
        DebuggerModuleEntry *entry 
          = (DebuggerModuleEntry *) Find(HASH(module), KEY(module)); 
        if (entry == NULL)
            return NULL;
        else
            return entry->module;
    }

    // We should never look for a NULL Module *
    DebuggerModule *GetModule(Module* module, AppDomain* pAppDomain)
	{
        _ASSERTE(module != NULL);
    
		HASHFIND findmodule;
		DebuggerModuleEntry *moduleentry;

		for (moduleentry =  (DebuggerModuleEntry*) FindFirstEntry(&findmodule);
			 moduleentry != NULL;
			 moduleentry =  (DebuggerModuleEntry*) FindNextEntry(&findmodule))
		{
			DebuggerModule *pModule = moduleentry->module;

			if ((pModule->m_pRuntimeModule == module) &&
				(pModule->m_pAppDomain == pAppDomain))
				return pModule;
		}

		// didn't find any match! So return a matching module for any app domain
		return NULL;
	}

    void RemoveModule(Module* module, AppDomain *pAppDomain)
    {
        _ASSERTE(module != NULL);
    
        LOG((LF_CORDB, LL_EVERYTHING, "DMT::RM: mod:0x%x AD:0x%x sys:0x%x\n",
            module, pAppDomain, 
            ((module->GetAssembly() == SystemDomain::SystemAssembly()) || module->GetAssembly()->IsShared())));

		// If this is a module belonging to the system assembly, then scan the complete list of DebuggerModules looking
		// for the one with a matching appdomain id.
        // Note: we have to make sure to lookup the module with the app domain parameter if the module lives in a shared
        // assembly or the system assembly. Bugs 65943 & 81728.
		if ((module->GetAssembly() == SystemDomain::SystemAssembly()) || module->GetAssembly()->IsShared())
		{
			HASHFIND findmodule;
			DebuggerModuleEntry *moduleentry;

			for (moduleentry =  (DebuggerModuleEntry*) FindFirstEntry(&findmodule);
				 moduleentry != NULL;
				 moduleentry =  (DebuggerModuleEntry*) FindNextEntry(&findmodule))
			{
				DebuggerModule *pModule = moduleentry->module;

				if ((pModule->m_pRuntimeModule == module) &&
					(pModule->m_pAppDomain == pAppDomain))
				{
                    LOG((LF_CORDB, LL_EVERYTHING, "DMT::RM: found 0x%x (DM:0x%x)\n", 
                        moduleentry, moduleentry->module));

                    // Don't actually delete the DebuggerModule - Add it to the list
                    AddDMToDeletedList(pModule);

                    // Remove from table
                    Delete(HASH(module), (HASHENTRY *)moduleentry);

					break;
				}
			}		
			// we should always find the module!!	
			_ASSERTE (moduleentry != NULL);
		}
		else
		{
			DebuggerModuleEntry *entry 
			  = (DebuggerModuleEntry *) Find(HASH(module), KEY(module));

			_ASSERTE(entry != NULL); // it had better be in there!
        
			if (entry != NULL) // if its not, we fail gracefully in a free build
			{
                LOG((LF_CORDB, LL_EVERYTHING, "DMT::RM: found 0x%x (DM:0x%x)\n", 
                    entry, entry->module));

                // Don't actually delete the DebuggerModule - Add it to the list
                AddDMToDeletedList(entry->module);

                // Remove from table
                Delete(HASH(module), (HASHENTRY *)entry);
			}
		}
    }

    void Clear()
    {
        HASHFIND hf;
        DebuggerModuleEntry *pDME;

        pDME = (DebuggerModuleEntry *) FindFirstEntry(&hf);

        while (pDME)
        {
            DebuggerModule *pDM = pDME->module;
            Module         *pEEM = pDM->m_pRuntimeModule;

            TRACE_FREE(moduleentry->module);
            DeleteInteropSafe(pDM);
            Delete(HASH(pEEM), (HASHENTRY *) pDME);

            pDME = (DebuggerModuleEntry *) FindFirstEntry(&hf);
        }

        CHashTableAndData<CNewZeroData>::Clear();
    }

    //
    // RemoveModules removes any module loaded into the given appdomain from the hash.  This is used when we send an
    // ExitAppdomain event to ensure that there are no leftover modules in the hash. This can happen when we have shared
    // modules that aren't properly accounted for in the CLR. We miss sending UnloadModule events for those modules, so
    // we clean them up with this method.
    //
    void RemoveModules(AppDomain *pAppDomain)
    {
        LOG((LF_CORDB, LL_INFO1000, "DMT::RM removing all modules from AD 0x%08x\n", pAppDomain));
        
        HASHFIND hf;
        DebuggerModuleEntry *pDME = (DebuggerModuleEntry *) FindFirstEntry(&hf);

        while (pDME != NULL)
        {
            DebuggerModule *pDM = pDME->module;

            if (pDM->m_pAppDomain == pAppDomain)
            {
                LOG((LF_CORDB, LL_INFO1000, "DMT::RM removing DebuggerModule 0x%08x\n", pDM));

                // Defer to the normal logic in RemoveModule for the actual removal. This accuratley simulates what
                // happens when we process an UnloadModule event.
                RemoveModule(pDM->m_pRuntimeModule, pAppDomain);

                // Start back at the first entry since we just modified the hash.
                pDME = (DebuggerModuleEntry *) FindFirstEntry(&hf);
            }
            else
            {
                pDME = (DebuggerModuleEntry *) FindNextEntry(&hf);
            }
        }

        LOG((LF_CORDB, LL_INFO1000, "DMT::RM done removing all modules from AD 0x%08x\n", pAppDomain));
    }

    DebuggerModule *GetFirstModule(HASHFIND *info)
    { 
        DebuggerModuleEntry *entry 
          = (DebuggerModuleEntry *) FindFirstEntry(info);
        if (entry == NULL)
            return NULL;
        else
            return entry->module;
    }

    DebuggerModule *GetNextModule(HASHFIND *info)
    { 
        DebuggerModuleEntry *entry 
            = (DebuggerModuleEntry *) FindNextEntry(info);
        if (entry == NULL)
            return NULL;
        else
            return entry->module;
    }
};

/* ------------------------------------------------------------------------ *
 * Hash to hold pending func evals by thread id
 * ------------------------------------------------------------------------ */

struct DebuggerPendingFuncEval
{
    FREEHASHENTRY   entry;
    Thread         *pThread;
    DebuggerEval   *pDE;
};

class DebuggerPendingFuncEvalTable : private CHashTableAndData<CNewZeroData>
{
  private:

    BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
    { return ((Thread*)pc1) !=
          ((DebuggerPendingFuncEval*)pc2)->pThread; }

    USHORT HASH(Thread* pThread)
    { return (USHORT) ((DWORD) pThread ^ ((DWORD)pThread>>16)); }

    BYTE *KEY(Thread* pthread)
    { return (BYTE *) pthread; }

  public:

    DebuggerPendingFuncEvalTable() : CHashTableAndData<CNewZeroData>(11)
    { NewInit(11, sizeof(DebuggerPendingFuncEval), 11); }

    void AddPendingEval(Thread *pThread, DebuggerEval *pDE)
    { 
        _ASSERTE((pThread != NULL) && (pDE != NULL));

        DebuggerPendingFuncEval *pfe = (DebuggerPendingFuncEval*)Add(HASH(pThread));
        pfe->pThread = pThread;
        pfe->pDE = pDE;
    }

    DebuggerPendingFuncEval *GetPendingEval(Thread* pThread)
    { 
        DebuggerPendingFuncEval *entry = (DebuggerPendingFuncEval*)Find(HASH(pThread), KEY(pThread)); 
        return entry;
    }

    void RemovePendingEval(Thread* pThread)
    {
        _ASSERTE(pThread != NULL);
    
        DebuggerPendingFuncEval *entry = (DebuggerPendingFuncEval*)Find(HASH(pThread), KEY(pThread)); 
        Delete(HASH(pThread), (HASHENTRY*)entry);
   }
};

/* ------------------------------------------------------------------------ *
 * DebuggerRCThread class -- the Runtime Controller thread.
 * ------------------------------------------------------------------------ */

#define DRCT_CONTROL_EVENT  0
#define DRCT_RSEA           1
#define DRCT_FAVORAVAIL		2
#define DRCT_COUNT_INITIAL  3

#define DRCT_DEBUGGER_EVENT 3
#define DRCT_COUNT_FINAL    4
class DebuggerRCThread
{
public:	
    DebuggerRCThread(Debugger* debugger);
    virtual ~DebuggerRCThread();
	void CloseIPCHandles(IpcTarget iWhich);

    //
    // You create a new instance of this class, call Init() to set it up,
    // then call Start() start processing events. Stop() terminates the
    // thread and deleting the instance cleans all the handles and such
    // up.
    //
    HRESULT Init(void);
    HRESULT Start(void);
    HRESULT Stop(void);

    //
    // These are used by this thread to send IPC events to the Debugger
    // Interface side.
    //
    DebuggerIPCEvent* GetIPCEventSendBuffer(IpcTarget iTarget)
    {
        _ASSERTE(m_rgDCB != NULL);

        _ASSERTE(m_rgDCB[iTarget] != NULL);

        // In case this turns into a continuation event
        ((DebuggerIPCEvent*) (m_rgDCB[iTarget])->m_sendBuffer)->next = NULL;

        LOG((LF_CORDB,LL_EVERYTHING, "GIPCESBuffer: got event 0x%x\n",
            (m_rgDCB[iTarget])->m_sendBuffer));
        
        return (DebuggerIPCEvent*) (m_rgDCB[iTarget])->m_sendBuffer;
    }

    DebuggerIPCEvent *GetIPCEventSendBufferContinuation(
        DebuggerIPCEvent *eventCur)
    {
        _ASSERTE(eventCur != NULL);
        _ASSERTE(eventCur->next == NULL);

        DebuggerIPCEvent *dipce = (DebuggerIPCEvent *)
            new BYTE [CorDBIPC_BUFFER_SIZE];
        dipce->next = NULL;

        LOG((LF_CORDB,LL_INFO1000000, "About to GIPCESBC 0x%x\n",dipce));

        if (dipce != NULL)
        {            
            eventCur->next = dipce;
        }
#ifdef _DEBUG
        else
        {
            _ASSERTE( !"GetIPCEventSendBufferContinuation failed to allocate mem!" );
        }
#endif //_DEBUG

        return dipce;
    }
   
    HRESULT SendIPCEvent(IpcTarget iTarget);
    HRESULT EnsureRuntimeOffsetsInit(int i); // helper function for SendIPCEvent
    void NeedRuntimeOffsetsReInit(int i);

    DebuggerIPCEvent* GetIPCEventReceiveBuffer(IpcTarget iTarget)
    {
        _ASSERTE(m_rgDCB != NULL);
        _ASSERTE(m_rgDCB[iTarget] != NULL);
        
        return (DebuggerIPCEvent*) (m_rgDCB[iTarget])->m_receiveBuffer;
    }
    
    HRESULT SendIPCReply(IpcTarget iTarget);

	//
	// Handle Favors - get the Helper thread to do a function call for us
	// because our thread can't (eg, we don't have the stack space)
	// DoFavor will call (*fp)(pData) and block until fp returns.
	// pData can store parameters, return value, and a this ptr (if we
	// need to call a member function)
	//
	typedef void (*FAVORCALLBACK)(void *);  
	void DoFavor(FAVORCALLBACK fp, void * pData); 

    //
    // Convience routines
    //
    DebuggerIPCControlBlock *GetDCB(IpcTarget iTarget)
    {
        if (iTarget >= IPC_TARGET_COUNT)
        {
            iTarget = IPC_TARGET_OUTOFPROC;
        }
        
        return m_rgDCB[iTarget];
    }

    void WatchForStragglers(void)
    {
        _ASSERTE(m_threadControlEvent != NULL);
        LOG((LF_CORDB,LL_INFO100000, "DRCT::WFS:setting event to watch "
            "for stragglers\n"));
        
        SetEvent(m_threadControlEvent);
    }

    HRESULT SetupRuntimeOffsets(DebuggerIPCControlBlock *pDCB);

    void MainLoop(bool temporaryHelp);

    HANDLE GetHelperThreadCanGoEvent(void) { return m_helperThreadCanGoEvent; }

    void EarlyHelperThreadDeath(void);

    DebuggerIPCControlBlock *GetInprocControlBlock(void)
    {
        return &m_DCBInproc;
    }

    HRESULT InitInProcDebug(void);

    HRESULT UninitInProcDebug(void);

    HRESULT CreateSetupSyncEvent(void);

	void RightSideDetach(void);

    //
    // If there's one thing that I hate is that CreateThread can't understand
    // that you want to invoke a method on an object as your thread proc...
    //
    void ThreadProc(void);
    static DWORD WINAPI ThreadProcStatic(LPVOID parameter);

    DWORD GetRCThreadId() 
    {
        return m_rgDCB[IPC_TARGET_OUTOFPROC]->m_helperThreadId;
    }

    // Return true if the Helper Thread up & initialized. 
    bool IsRCThreadReady();
    
private:
    Debugger*                       m_debugger;
    	
    // IPC_TARGET_* define default targets - if we ever want to do
    // multiple right sides, we'll have to switch to a INPROC, and
    // OUTOFPROC + iTargetProcess scheme
    DebuggerIPCControlBlock       **m_rgDCB;
    // we need to create this so that
    // both the RC thread and the managed thread can get to it.  This is
    // storage only - we'll access this through
    // m_rgDCB[IPC_TARGET_INPROC]	
    DebuggerIPCControlBlock         m_DCBInproc;
    
    HANDLE                          m_thread;
    bool                            m_run;
    
    HANDLE                          m_threadControlEvent;
    HANDLE                          m_helperThreadCanGoEvent;
    bool                            m_rgfInitRuntimeOffsets[IPC_TARGET_COUNT];

	bool							m_fDetachRightSide;

	// Stuff for having the helper thread do function calls for a thread
	// that blew its stack
	FAVORCALLBACK                   m_fpFavor;
	void                           *m_pFavorData;
	HANDLE                          m_FavorAvailableEvent;
	HANDLE                          m_FavorReadEvent;
	CRITICAL_SECTION                m_FavorLock;

    // Stuff for inproc debugging
public:    
    Cordb                          *m_cordb;
    HANDLE                          m_SetupSyncEvent;
};


/* ------------------------------------------------------------------------ *
 * Debugger JIT Info struct and hash table
 * ------------------------------------------------------------------------ */

//  @struct DebuggerOldILToNewILMap| Holds the old IL to new il offset map
//		between different version of EnC'd functions.
//  @field SIZE_T|ilOffsetOld|Old IL offset
//  @field SIZE_T|ilOffsetNew|The new IL offset corrsponding to the old.
struct DebuggerOldILToNewILMap
{
    SIZE_T ilOffsetOld;
    SIZE_T ilOffsetNew;
    BOOL    fAccurate;
};

// @class DebuggerJitInfo| Struct to hold all the JIT information 
// necessary for a given function.
//
// @field MethodDesc*|m_fd|MethodDesc of the method that this DJI applies to
//
// @field CORDB_ADDRESS	|m_addrOfCode|Address of the code.  This will be read by
//		the right side (via ReadProcessMemory) to grab the actual  native start
//		address of the jitted method.
//
// @field SIZE_T|m_sizeOfCode|Pseudo-private variable: use the GetSkzeOfCode
//		method to get this value.  
//
// @field bool|m_codePitched| Set to true if the code is, in fact,
// 		no longer there, but the DJI will be valid once
// 		the method is reJITted.
//
// @field bool|m_jitComplete|Set to true once JITComplete has been called.
//
// @field bool|m_encBreakpointsApplied|Set to true once UpdateFunction has
//		plaster all the sequence points with DebuggerEnCBreakpoints
//
// @field DebuggerILToNativeMap*|m_sequenceMap|This is the sequence map, which
//		is actually a collection of IL-Native pairs, where each IL corresponds
//		to a line of source code.  Each pair is refered to as a sequence map point.
//
// @field unsigned int|m_sequenceMapCount| Count of the <t DebuggerILToNativeMap>s
//		in m_sequenceMap.
//
// @field bool|m_sequenceMapSorted|Set to true once m_sequenceMapSorted is sorted
//		into ascending IL order (Debugger::setBoundaries, SortMap).
//
// @field SIZE_T|m_lastIL|last nonEPILOG instruction
//
// @field COR_IL_MAP|m_rgInstrumentedILMap|The profiler may instrument the 
//      code. This is done by modifying the IL code that gets handed to the 
//      JIT.  This array will map offsets within the original ("old") IL code, 
//      to offsets within the instrumented ("new") IL code that is actually
//      being instrumented.  Note that this map will actually be folded into
//      the IL-Native map, so that we don't have to go through this
//      except in special cases.  We have to keep this around for corner
//      cases like a rejiting a pitched method.
//
// @field SIZE_T|m_cInstrumentedILMap|A count of elements in 
//      m_rgInstrumentedILMap
//
const bool bOriginalToInstrumented = true;
const bool bInstrumentedToOriginal = false;

class DebuggerJitInfo
{
public:
    //@enum DJI_VERSION|Holds special constants for use in refering
    //      to versions of DJI for a method.
    //@emem DJI_VERSION_MOST_RECENTLY_JITTED|Note that there is a dependency
    //      between this constant and the 
    //      CordbFunction::DJI_VERSION_MOST_RECENTLY_JITTED constant in
    //      cordb.h
    //@emem DJI_VERSION_FIRST_VALID|First value to be assigned to an
    //      actual DJI.
    //      *** WARNING *** WARNING *** WARNING ***
    //          DebuggerJitInfo::DJI_VERSION_FIRST_VALID MUST be equal to 
    //          FIRST_VALID_VERSION_NUMBER (in debug\inc\dbgipcevents.h)

    enum {
        DJI_VERSION_INVALID = 0,
        DJI_VERSION_MOST_RECENTLY_JITTED = 1,
        DJI_VERSION_MOST_RECENTLY_EnCED = 2,
        DJI_VERSION_FIRST_VALID = 3,
    } DJI_VERSION;


    MethodDesc              *m_fd;
    bool				     m_codePitched; 
    bool                     m_jitComplete;

    // If this is true, then we've plastered the method w/ EnC patches,
    // and the method has been EnC'd
    bool                     m_encBreakpointsApplied;

    // If the variable layout of this method changes from this version
    // to the next, then it's illegal to move from this version to the next.
    // The caller is responsible for ensuring that local variable layout
    // only changes when there are no frames in any stack that are executing
    // this method.
    // In a debug build, we'll assert if we try to make this EnC transition,
    // in a free/retail build we'll silently fail to make the transition.
    BOOL                     m_illegalToTransitionFrom;
    
    DebuggerControllerQueue *m_pDcq;
    
    CORDB_ADDRESS			 m_addrOfCode;
	SIZE_T					 m_sizeOfCode;
	
    DebuggerJitInfo         *m_prevJitInfo; 
    DebuggerJitInfo			*m_nextJitInfo; 
    
    SIZE_T					 m_nVersion;
    
    DebuggerILToNativeMap   *m_sequenceMap;
    unsigned int             m_sequenceMapCount;
    bool                     m_sequenceMapSorted;
   
    ICorJitInfo::NativeVarInfo *m_varNativeInfo;
    unsigned int             m_varNativeInfoCount;
	bool					 m_varNeedsDelete;
	
	DebuggerOldILToNewILMap	*m_OldILToNewIL;
	SIZE_T					 m_cOldILToNewIL;
    SIZE_T                   m_lastIL;
    
    SIZE_T                   m_cInstrumentedILMap;
    COR_IL_MAP               *m_rgInstrumentedILMap;

    DebuggerJitInfo(MethodDesc *fd) : m_fd(fd), m_codePitched(false),
        m_jitComplete(false), 
        m_encBreakpointsApplied(false), 
        m_illegalToTransitionFrom(FALSE),
        m_addrOfCode(NULL),
        m_sizeOfCode(0), m_prevJitInfo(NULL), m_nextJitInfo(NULL), 
        m_nVersion(DJI_VERSION_INVALID), m_sequenceMap(NULL), 
        m_sequenceMapCount(0), m_sequenceMapSorted(false),
        m_varNativeInfo(NULL), m_varNativeInfoCount(0),m_OldILToNewIL(NULL),
        m_cOldILToNewIL(0), m_lastIL(0),
        m_cInstrumentedILMap(0), m_rgInstrumentedILMap(NULL),
        m_pDcq(NULL)
     {
        LOG((LF_CORDB,LL_EVERYTHING, "DJI::DJI : created at 0x%x\n", this));
     }

    ~DebuggerJitInfo();

    // @cmember Invoking SortMap will ensure that  the native
    //      ranges (which are infered by sorting the <t DebuggerILToNativeMap>s into
    //      ascending native order, then assuming that there are no gaps in the native
    //      code) are properly set up, as well.  
    void SortMap();

    DebuggerILToNativeMap *MapILOffsetToMapEntry(SIZE_T ilOffset, BOOL *exact=NULL);
    void MapILRangeToMapEntryRange(SIZE_T ilStartOffset, SIZE_T ilEndOffset,
                                   DebuggerILToNativeMap **start,
                                   DebuggerILToNativeMap **end);
    SIZE_T MapILOffsetToNative(SIZE_T ilOffset, BOOL *exact=NULL);

    // @cmember MapSpecialToNative maps a <t CordDebugMappingResult> to a native
    //      offset so that we can get the address of the prolog & epilog. which
    //      determines which epilog or prolog, if there's more than one.
    SIZE_T MapSpecialToNative(CorDebugMappingResult mapping, 
                              SIZE_T which,
                              BOOL *pfAccurate);

    // @cmember MapNativeOffsetToIL Takes a given nativeOffset, and maps it back
    //      to the corresponding IL offset, which it returns.  If mapping indicates
    //      that a the native offset corresponds to a special region of code (for 
    //      example, the epilog), then the return value will be specified by 
    //      ICorDebugILFrame::GetIP (see cordebug.idl)
    DWORD MapNativeOffsetToIL(DWORD nativeOffset, 
                              CorDebugMappingResult *mapping,
                              DWORD *which);

    DebuggerJitInfo *GetJitInfoByVersionNumber(SIZE_T nVer,
                                               SIZE_T nVerMostRecentlyEnC);

    DebuggerJitInfo *GetJitInfoByAddress( const BYTE *pbAddr );

    // @cmember This will copy over the map for the use of the DebuggerJitInfo
    HRESULT LoadEnCILMap(UnorderedILMap *ilMap);

    // @cmember TranslateToInstIL will take offOrig, and translate it to the 
    //      correct IL offset if this code happens to be instrumented (i.e.,
    //      if m_rgInstrumentedILMap != NULL && m_cInstrumentedILMap > 0)
    SIZE_T TranslateToInstIL(SIZE_T offOrig, bool fOrigToInst);

    void SetVars(ULONG32 cVars, ICorDebugInfo::NativeVarInfo *pVars, bool fDelete);
    HRESULT SetBoundaries(ULONG32 cMap, ICorDebugInfo::OffsetMapping *pMap);

    // @cmember UpdateDeferedBreakpoints will DoDeferedPatch on any controllers
    // for which the user tried to add them after the EnC, but before we had
    // actually moved to the new version.
    // We only move steppers that are active for this thread & frame, in
    // case EnC fails in another thread and/or frame.
    HRESULT UpdateDeferedBreakpoints(DebuggerJitInfo *pDji,
                                     Thread *pThread,
                                     void *fp);

    HRESULT AddToDeferedQueue(DebuggerController *dc);
    HRESULT RemoveFromDeferedQueue(DebuggerController *dc);

    ICorDebugInfo::SourceTypes GetSrcTypeFromILOffset(SIZE_T ilOffset);
};


// @struct DebuggerJitInfoKey|Key for each of the method info hash table entries.
// @field Module *| m_pModule | This and m_token make up the key
// @field mdMethodDef | m_token | This and m_pModule make up the key
struct DebuggerJitInfoKey
{
    Module             *pModule;
    mdMethodDef         token;
} ;

// @struct DebuggerJitInfoEntry |Entry for the JIT info hash table.
// @field FREEHASHENTRY | entry | Needed for use by the hash table
// @field DebuggerJitInfo *|ji|The actual <t DebuggerJitInfo> to
//          hash.  Note that DJI's will be hashed by <t MethodDesc>.
struct DebuggerJitInfoEntry
{
    FREEHASHENTRY       entry;
    DebuggerJitInfoKey  key;
    SIZE_T              nVersion;
    SIZE_T              nVersionLastRemapped;
    DebuggerJitInfo    *ji;
};

// @class DebuggerJitInfoTable | Hash table to hold all the JIT 
// info blocks we have for each function
// that gets jitted. Hangs off of the Debugger object.
// INVARIANT: There is only one <t DebuggerJitInfo> per method
// in the table. Note that DJI's will be hashed by <t MethodDesc>.
//
class DebuggerJitInfoTable : private CHashTableAndData<CNewZeroData>
{
  private:

    BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
    {   
        DebuggerJitInfoKey *pDjik = (DebuggerJitInfoKey*)pc1;
        DebuggerJitInfoEntry*pDjie = (DebuggerJitInfoEntry*)pc2;
        
        return pDjik->pModule != pDjie->key.pModule ||
               pDjik->token != pDjie->key.token;
    }

    USHORT HASH(DebuggerJitInfoKey* pDjik)
    { 
        DWORD base = (DWORD)pDjik->pModule + (DWORD)pDjik->token;
        return (USHORT) (base ^ (base>>16)); 
    }

    BYTE *KEY(DebuggerJitInfoKey* djik)
    { 
        return (BYTE *) djik; 
    }

//#define _DEBUG_DJI_TABLE

#ifdef _DEBUG_DJI_TABLE
public:
    ULONG CheckDjiTable();

#define CHECK_DJI_TABLE (CheckDjiTable())
#define CHECK_DJI_TABLE_DEBUGGER (m_pJitInfos->CheckDjiTable())

#else

#define CHECK_DJI_TABLE
#define CHECK_DJI_TABLE_DEBUGGER

#endif // _DEBUG_DJI_TABLE

  public:


    DebuggerJitInfoTable() : CHashTableAndData<CNewZeroData>(101)
    { 
        NewInit(101, sizeof(DebuggerJitInfoEntry), 101); 
    }

    // Methods that deal with JITs use MethodDescs b/c MethodDescs
    // will exist before a method gets jitted.
    HRESULT AddJitInfo(MethodDesc *pFD, DebuggerJitInfo *ji, SIZE_T nVersion)
    { 
        if (pFD == NULL)
            return S_OK;
            
        LOG((LF_CORDB, LL_INFO1000, "Added 0x%x (%s::%s), nVer:0x%x\n", ji, 
            pFD->m_pszDebugClassName, pFD->m_pszDebugMethodName, nVersion));
            
        return AddJitInfo(pFD->GetModule(), 
                          pFD->GetMemberDef(),
                          ji,
                          nVersion);
    }


    HRESULT AddJitInfo(Module *pModule, 
                       mdMethodDef token, 
                       DebuggerJitInfo *ji, 
                       SIZE_T nVersion)
    {
       LOG((LF_CORDB, LL_INFO1000, "DJIT::AMI Adding dji:0x%x Mod:0x%x tok:"
            "0x%x nVer:0x%x\n", ji, pModule, token, nVersion));
            
       HRESULT hr = OverwriteJitInfo(pModule, token, ji, TRUE);
        if (hr == S_OK)
            return hr;

        DebuggerJitInfoKey djik;
        djik.pModule = pModule;
        djik.token = token;

        DebuggerJitInfoEntry *djie = 
            (DebuggerJitInfoEntry *) Add(HASH(&djik));
          
        if (djie != NULL)
        {
            djie->key.pModule = pModule;
            djie->key.token = token;
            djie->ji = ji; 
            
            if (nVersion >= DebuggerJitInfo::DJI_VERSION_FIRST_VALID)
                djie->nVersion = nVersion;

            // We haven't sent the remap event for this yet.  Of course,
            // we might not need to, if we're adding the first version

            djie->nVersionLastRemapped = max(djie->nVersion-1, 
                                   DebuggerJitInfo::DJI_VERSION_FIRST_VALID);

            LOG((LF_CORDB, LL_INFO1000, "DJIT::AJI: mod:0x%x tok:0%x "
                "remap nVer:0x%x\n", pModule, token, 
                djie->nVersionLastRemapped));
            return S_OK;
        }

        return E_OUTOFMEMORY;
    }

    HRESULT OverwriteJitInfo(Module *pModule, 
                             mdMethodDef token, 
                             DebuggerJitInfo *ji, 
                             BOOL fOnlyIfNull)
    { 
		LOG((LF_CORDB, LL_INFO1000, "DJIT::OJI: dji:0x%x mod:0x%x tok:0x%x\n", ji, 
            pModule, token));

        DebuggerJitInfoKey djik;
        djik.pModule = pModule;
        djik.token = token;

        DebuggerJitInfoEntry *entry 
          = (DebuggerJitInfoEntry *) Find(HASH(&djik), KEY(&djik)); 
		if (entry != NULL)
		{
			if ( (fOnlyIfNull &&
				  entry->nVersion == ji->m_nVersion && 
				  entry->ji == NULL) ||
				 !fOnlyIfNull)
			{
                entry->ji = ji;

                LOG((LF_CORDB, LL_INFO1000, "DJIT::OJI: mod:0x%x tok:0x%x remap"
                    "nVer:0x%x\n", pModule, token, entry->nVersionLastRemapped));
                return S_OK;
            }
        }

        return E_FAIL;
    }

    DebuggerJitInfo *GetJitInfo(MethodDesc* fd)
    { 
//        CHECK_DJI_TABLE;
        if (fd == NULL)
            return NULL;
        
        DebuggerJitInfoKey djik;
        djik.pModule = fd->GetModule();
        djik.token = fd->GetMemberDef();

        DebuggerJitInfoEntry *entry 
          = (DebuggerJitInfoEntry *) Find(HASH(&djik), KEY(&djik)); 
        if (entry == NULL )
            return NULL;
        else
        {
			LOG((LF_CORDB, LL_INFO1000, "DJI::GJI: for md 0x%x, got 0x%x prev:0x%x\n",
				fd, entry->ji, (entry->ji?entry->ji->m_prevJitInfo:0)));
			return entry->ji; // May be NULL if only version
                              // number is set.
        }
    }

     DebuggerJitInfo *GetFirstJitInfo(HASHFIND *info)
    { 
        DebuggerJitInfoEntry *entry 
          = (DebuggerJitInfoEntry *) FindFirstEntry(info);
        if (entry == NULL)
            return NULL;
        else
            return entry->ji;
    }

    DebuggerJitInfo *GetNextJitInfo(HASHFIND *info)
    { 
        DebuggerJitInfoEntry *entry = 
        	(DebuggerJitInfoEntry *) FindNextEntry(info);

		// We may have incremented the version number
		// for methods that never got JITted, so we should
		// pretend like they don't exist here.
        while (entry != NULL &&
        	   entry->ji == NULL)
        {
         	entry = (DebuggerJitInfoEntry *) FindNextEntry(info);
		}
          
        if (entry == NULL)
            return NULL;
        else
            return entry->ji;
    }

    // pModule is being unloaded - remove any entries that belong to it.  Why?
    // (a) Correctness: the module can be reloaded at the same address, 
    //      which will cause accidental matches with our hashtable (indexed by
    //      {Module*,mdMethodDef}
    // (b) Perf: don't waste the memory!
    void ClearMethodsOfModule(Module *pModule)
    {
        LOG((LF_CORDB, LL_INFO1000000, "CMOM:mod:0x%x (%S)\n", pModule
            ,pModule->GetFileName()));
    
        HASHFIND info;
    
        DebuggerJitInfoEntry *entry 
          = (DebuggerJitInfoEntry *) FindFirstEntry(&info);
        while(entry != NULL)
        {
            Module *pMod = entry->key.pModule ;
            if (pMod == pModule)
            {
                // This method actually got jitted, at least
                // once - remove all version info.
                while(entry->ji != NULL)
                {
                    DeleteEntryDJI(entry);
                }

                Delete(HASH(&(entry->key)), (HASHENTRY*)entry);
            }
        
            entry = (DebuggerJitInfoEntry *) FindNextEntry(&info);
        }
    }

    void RemoveJitInfo(MethodDesc* fd)
    {
//        CHECK_DJI_TABLE;
        if (fd == NULL)
            return;

        LOG((LF_CORDB, LL_INFO1000000, "RJI:removing :0x%x (%s::%s)\n", fd,
            fd->m_pszDebugClassName, fd->m_pszDebugMethodName));

        DebuggerJitInfoKey djik;
        djik.pModule = fd->GetModule();
        djik.token = fd->GetMemberDef();

        DebuggerJitInfoEntry *entry 
          = (DebuggerJitInfoEntry *) Find(HASH(&djik), KEY(&djik)); 

        _ASSERTE(entry != NULL); // it had better be in there!

        LOG((LF_CORDB,LL_INFO1000000, "Remove entry 0x%x for %s::%s\n",
            entry, fd->m_pszDebugClassName, fd->m_pszDebugMethodName));
        
        if (entry != NULL) // if its not, we fail gracefully in a free build
        {
			LOG((LF_CORDB, LL_INFO1000000, "DJI::RJI: for md 0x%x, got 0x%x prev:0x%x\n",
				fd, entry->ji, (entry->ji?entry->ji->m_prevJitInfo:0)));
        
            // If we remove the hash table entry, we'll lose
            // the version number info, which would be bad.
            // Also, since this is called to undo a failed JIT operation,we
            // shouldn't mess with the version number.
            DeleteEntryDJI(entry);
        }

//        CHECK_DJI_TABLE;
    }

    // @todo How to force the compiler to inline this?
    void DeleteEntryDJI(DebuggerJitInfoEntry *entry)
    {
        DebuggerJitInfo *djiPrev = entry->ji->m_prevJitInfo;
        TRACE_FREE(entry->ji);
        DeleteInteropSafe(entry->ji);
        entry->ji = djiPrev;
        if ( djiPrev != NULL )
            djiPrev->m_nextJitInfo = NULL;
    }

    // Methods that deal with version numbers use the {Module, mdMethodDef} key
    // since we may set/increment the version number way before the method
    // gets JITted (if it ever does).

    // @mfunc SIZE_T|DebuggerJitInfoTable|GetVersionNumberLastRemapped|This
    // will look for the given method's version number that has
    // had an EnC 'Remap' event sent for it.
    SIZE_T GetVersionNumberLastRemapped(Module *pModule, mdMethodDef token)
    {
        LOG((LF_CORDB, LL_INFO1000, "DJIT::GVNLR: Mod:0x%x (%S) tok:0x%x\n",
            pModule, pModule->GetFileName(), token));

        DebuggerJitInfoKey djik;
        djik.pModule = pModule;
        djik.token = token;

        DebuggerJitInfoEntry *entry 
          = (DebuggerJitInfoEntry *) Find(HASH(&djik), KEY(&djik)); 
         
        if (entry == NULL)
        {
            LOG((LF_CORDB, LL_INFO100000, "DJIT::GVNLR mod:0x%x tok:0%x is "
                "DJI_VERSION_INVALID (0x%x)\n",
                pModule, token, DebuggerJitInfo::DJI_VERSION_INVALID));
                
            return DebuggerJitInfo::DJI_VERSION_INVALID;
        }
        else
        {
            LOG((LF_CORDB, LL_INFO100000, "DJIT::GVNLR mod:0x%x tok:0x%x is "
                " 0x%x\n", pModule, token, entry->nVersionLastRemapped));
                
            return entry->nVersionLastRemapped;
        }
    }

    // @mfunc SIZE_T|DebuggerJitInfoTable|SetVersionNumberLastRemapped|This
    // will look for the given method's version number that has
    // had an EnC 'Remap' event sent for it.
    void SetVersionNumberLastRemapped(Module *pModule, 
                                      mdMethodDef token, 
                                      SIZE_T nVersionRemapped)
    {
        LOG((LF_CORDB, LL_INFO1000, "DJIT::SVNLR: Mod:0x%x (%S) tok:0x%x to remap"
            "V:0x%x\n", pModule, pModule->GetFileName(), token, nVersionRemapped));

        DebuggerJitInfoKey djik;
        djik.pModule = pModule;
        djik.token = token;

        DebuggerJitInfoEntry *entry 
          = (DebuggerJitInfoEntry *) Find(HASH(&djik), KEY(&djik)); 
          
        if (entry == NULL)
        {
            HRESULT hr = AddJitInfo(pModule,
                                    token, 
                                    NULL, 
                                    DebuggerJitInfo::DJI_VERSION_FIRST_VALID);
            if (FAILED(hr))
                return;
                
            entry = (DebuggerJitInfoEntry *) Find(HASH(&djik), KEY(&djik)); 
            _ASSERTE(entry != NULL);
            entry->nVersionLastRemapped = nVersionRemapped;
        }
        else
        {
            // Shouldn't ever bump this down.
            if( nVersionRemapped > entry->nVersionLastRemapped )
                entry->nVersionLastRemapped = nVersionRemapped;
        }

        LOG((LF_CORDB, LL_INFO100000, "DJIT::SVNLR set mod:0x%x tok:0x%x to 0x%x\n",
            pModule, token, entry->nVersionLastRemapped));
    }

    // @mfunc SIZE_T|DebuggerJitInfoTable|EnCRemapSentForThisVersion|
    // Returns TRUE if the most current version of the function 
    // has had an EnC remap event sent.
    BOOL EnCRemapSentForThisVersion(Module *pModule, 
                                    mdMethodDef token, 
                                    SIZE_T nVersion)
    {
        SIZE_T lastRemapped = GetVersionNumberLastRemapped(pModule, 
                                                           token);

        LOG((LF_CORDB, LL_INFO10000, "DJIT::EnCRSFTV: Mod:0x%x (%S) tok:0x%x "
            "lastSent:0x%x nVer Query:0x%x\n", pModule, pModule->GetFileName(), token, 
            lastRemapped, nVersion));

        LOG((LF_CORDB, LL_INFO10000, "DJIT::EnCRSFTV: last:0x%x dji->nVer:0x%x\n",
            lastRemapped, nVersion));

        if (lastRemapped < nVersion)
            return FALSE;
        else
            return TRUE;
    }

    // @mfunc SIZE_T|DebuggerJitInfoTable|GetVersionNumber|This
    // will look for the given method's most recent version
    // number (the number of the version that either has been
    // jitted, or will be jitted (ie and EnC operation has 'bumped
    // up' the version number)).  It will return the DJI_VERSION_FIRST_VALID
    // if it fails to find any version.
    SIZE_T GetVersionNumber(Module *pModule, mdMethodDef token)
    {
        DebuggerJitInfoKey djik;
        djik.pModule = pModule;
        djik.token = token;

        DebuggerJitInfoEntry *entry 
          = (DebuggerJitInfoEntry *) Find(HASH(&djik), KEY(&djik)); 

        if (entry == NULL)
        {
            LOG((LF_CORDB, LL_INFO1000, "DJIT::GVN: Mod:0x%x (%S) tok:0x%x V:0x%x FIRST\n",
                pModule, pModule->GetFileName(), token, DebuggerJitInfo::DJI_VERSION_FIRST_VALID));
                
            return DebuggerJitInfo::DJI_VERSION_FIRST_VALID;
        }
        else
        {
            LOG((LF_CORDB, LL_INFO1000, "DJIT::GVN: Mod:0x%x (%S) tok: 0x%x V:0x%x\n",
                pModule, pModule->GetFileName(), token, entry->nVersion));
                
            return entry->nVersion;
        }
    }

    // @mfunc SIZE_T|DebuggerJitInfoTable|SetVersionNumber|This
    void SetVersionNumber(Module *pModule, mdMethodDef token, SIZE_T nVersion)
    {
        LOG((LF_CORDB, LL_INFO1000, "DJIT::SVN: Mod:0x%x (%S) tok:0x%x Setting to 0x%x\n",
            pModule, pModule->GetFileName(), token, nVersion));
    
        DebuggerJitInfoKey djik;
        djik.pModule = pModule;
        djik.token = token;

        DebuggerJitInfoEntry *entry 
          = (DebuggerJitInfoEntry *) Find(HASH(&djik), KEY(&djik)); 
          
        if (entry == NULL)
        {
            AddJitInfo( pModule, token, NULL, nVersion );
        }
        else
        {
            entry->nVersion = nVersion;
        }
    }
    
    // @mfunc SIZE_T|DebuggerJitInfoTable|IncrementVersionNumber|This
    // will increment the version number if there exists at least one
    // <t DebuggerJitInfo> for the given method, otherwise
    HRESULT IncrementVersionNumber(Module *pModule, mdMethodDef token)
    {
        LOG((LF_CORDB, LL_INFO1000, "DJIT::IVN: Mod:0x%x (%S) tok:0x%x\n",
            pModule, pModule->GetFileName(), token));

        DebuggerJitInfoKey djik;
        djik.pModule = pModule;
        djik.token = token;

        DebuggerJitInfoEntry *entry 
          = (DebuggerJitInfoEntry *) Find(HASH(&djik), KEY(&djik)); 
          
        if (entry == NULL)
        {
            return AddJitInfo(pModule, 
                              token, 
                              NULL, 
                              DebuggerJitInfo::DJI_VERSION_FIRST_VALID+1);
        }
        else
        {
            entry->nVersion++;
            return S_OK;
        }
    }
};


/* ------------------------------------------------------------------------ *
 * Debugger class
 * ------------------------------------------------------------------------ */


enum DebuggerAttachState
{
    SYNC_STATE_0,   // Debugger is attached
    SYNC_STATE_1,   // Debugger is attaching: Send CREATE_APP_DOMAIN_EVENTS
    SYNC_STATE_2,   // Debugger is attaching: Send LOAD_ASSEMBLY and LOAD_MODULE events 
    SYNC_STATE_3,   // Debugger is attaching: Send LOAD_CLASS and THREAD_ATTACH events
    SYNC_STATE_10,  // Attaching to appdomain during create: send LOAD_ASSEMBLY and LOAD_MODULE events. (Much like SYNC_STATE_2)
    SYNC_STATE_11,  // Attaching to appdomain during create: send LOAD_CLASS events. (Much like SYNC_STATE_3, but no THREAD_ATTACH events)
    SYNC_STATE_20,  // Debugger is attached; We've accumulated EnC remap info to send on next continue
};

// Forward declare some parameter marshalling structs 
struct ShouldAttachDebuggerParams;
struct EnsureDebuggerAttachedParams;
       
// @class Debugger | This class implements DebugInterface to provide 
// the hooks to the Runtime directly.
//
class Debugger : public DebugInterface
{
public:
    Debugger();
    ~Debugger();

    // Checks if the JitInfos table has been allocated, and if not does so.
    HRESULT inline CheckInitJitInfoTable();
    HRESULT inline CheckInitModuleTable();
    HRESULT inline CheckInitPendingFuncEvalTable();

    DWORD GetRCThreadId()
    {
        if (m_pRCThread)
            return m_pRCThread->GetRCThreadId();
        else
            return 0;
    }

    //
    // Methods exported from the Runtime Controller to the Runtime.
    // (These are the methods specified by DebugInterface.)
    //
    HRESULT Startup(void);
    void SetEEInterface(EEDebugInterface* i);
    void StopDebugger(void);
    BOOL IsStopped(void)
    {
        return m_stopped;
    }

    void ThreadCreated(Thread* pRuntimeThread);
    void ThreadStarted(Thread* pRuntimeThread, BOOL fAttaching);
    void DetachThread(Thread *pRuntimeThread, BOOL fHoldingThreadStoreLock);

    BOOL SuspendComplete(BOOL fHoldingThreadStoreLock);

    void LoadModule(Module* pRuntimeModule, 
                    IMAGE_COR20_HEADER* pCORHeader,
                    VOID* baseAddress, 
                    LPCWSTR pszModuleName, 
					DWORD dwModuleName, 
					Assembly *pAssembly,
					AppDomain *pAppDomain, 
					BOOL fAttaching);
	DebuggerModule* AddDebuggerModule(Module* pRuntimeModule,
                              AppDomain *pAppDomain);
    DebuggerModule* GetDebuggerModule(Module* pRuntimeModule,
                              AppDomain *pAppDomain);
    void UnloadModule(Module* pRuntimeModule, 
                      AppDomain *pAppDomain);
    void DestructModule(Module *pModule);

    void UpdateModuleSyms(Module *pRuntimeModule,
                          AppDomain *pAppDomain,
                          BOOL fAttaching);
    
    HRESULT ModuleMetaDataToMemory(Module *pMod, BYTE **prgb, DWORD *pcb);

    BOOL LoadClass(EEClass* pRuntimeClass, 
                   mdTypeDef classMetadataToken,
                   Module* classModule, 
                   AppDomain *pAD, 
                   BOOL fAllAppDomains,
                   BOOL fAttaching);
    void UnloadClass(mdTypeDef classMetadataToken,
                     Module* classModule, 
                     AppDomain *pAD, 
                     BOOL fAllAppDomains);
                     
	void SendClassLoadUnloadEvent (mdTypeDef classMetadataToken,
								   DebuggerModule *classModule,
								   Assembly *pAssembly,
								   AppDomain *pAppDomain,
								   BOOL fIsLoadEvent);
	BOOL SendSystemClassLoadUnloadEvent (mdTypeDef classMetadataToken,
										 Module *classModule,
										 BOOL fIsLoadEvent);

    bool FirstChanceNativeException(EXCEPTION_RECORD *exception,
                               CONTEXT *context,
                               DWORD code,
                               Thread *thread);

    bool FirstChanceManagedException(bool continuable, CONTEXT *pContext);
    LONG LastChanceManagedException(EXCEPTION_RECORD *pExceptionRecord, 
                             CONTEXT *pContext,
                             Thread *pThread,
                             UnhandledExceptionLocation location);


    void ExceptionFilter(BYTE *pStack, MethodDesc *fd, SIZE_T offset);
    void ExceptionHandle(BYTE *pStack, MethodDesc *fd, SIZE_T offset);

    void ExceptionCLRCatcherFound();
    
    int NotifyUserOfFault(bool userBreakpoint, DebuggerLaunchSetting dls);

    void FixupEnCInfo(EnCInfo *info, UnorderedEnCErrorInfoArray *pEnCError);
    
    void FixupILMapPointers(EnCInfo *info, UnorderedEnCErrorInfoArray *pEnCError);
    
    void TranslateDebuggerTokens(EnCInfo *info, UnorderedEnCErrorInfoArray *pEnCError);
	DebuggerModule *TranslateRuntimeModule(Module *pModule);

    SIZE_T GetArgCount(MethodDesc* md, BOOL *fVarArg = NULL);

    void FuncEvalComplete(Thread *pThread, DebuggerEval *pDE);
    
    DebuggerJitInfo *CreateJitInfo(MethodDesc* fd);
    void JITBeginning(MethodDesc* fd, bool trackJITInfo);
    void JITComplete(MethodDesc* fd, BYTE* newAddress, SIZE_T sizeOfCode, bool trackJITInfo);

    HRESULT UpdateFunction(MethodDesc* pFD, 
                           const UnorderedILMap *ilMap,
                           UnorderedEnCRemapArray *pEnCRemapInfo,
                           UnorderedEnCErrorInfoArray *pEnCError);
                           
    HRESULT MapILInfoToCurrentNative(MethodDesc *PFD, 
                                     SIZE_T ilOffset, 
                                     UINT mapType, 
                                     SIZE_T which, 
                                     SIZE_T *nativeFnxStart,
                                     SIZE_T *nativeOffset, 
                                     void *DebuggerVersionToken,
                                     BOOL *fAccurate);
    
    HRESULT DoEnCDeferedWork(MethodDesc *pMd, 
                             BOOL fAccurateMapping);

    HRESULT ActivatePatchSkipForEnc(CONTEXT *pCtx, 
                                    MethodDesc *pMd, 
                                    BOOL fShortCircuit);

    void GetVarInfo(MethodDesc *       fd,   	   // [IN] method of interest
                    void *DebuggerVersionToken,    // [IN] which edit version
                    SIZE_T *           cVars,      // [OUT] size of 'vars'
                    const NativeVarInfo **vars     // [OUT] map telling where local vars are stored
                    );

    // @todo jenh: remove this when no longer needed through shell command
    HRESULT ResumeInUpdatedFunction(mdMethodDef funcMetadataToken,
                                    void *funcDebuggerModuleToken,
                                    CORDB_ADDRESS ip, CorDebugMappingResult mapping,
                                    SIZE_T which, void *DebuggerVersionToken);

    void * __stdcall allocateArray(SIZE_T cBytes);
    void __stdcall freeArray(void *array);

    void __stdcall getBoundaries(CORINFO_METHOD_HANDLE ftn,
                                 unsigned int *cILOffsets, DWORD **pILOffsets,
                                 ICorDebugInfo::BoundaryTypes* implictBoundaries);
    void __stdcall setBoundaries(CORINFO_METHOD_HANDLE ftn,
                                 ULONG32 cMap, OffsetMapping *pMap);

    void __stdcall getVars(CORINFO_METHOD_HANDLE ftn,
                           ULONG32 *cVars, ILVarInfo **vars, 
                           bool *extendOthers);
    void __stdcall setVars(CORINFO_METHOD_HANDLE ftn,
                           ULONG32 cVars, NativeVarInfo *vars);

    DebuggerJitInfo *GetJitInfo(MethodDesc *fd, const BYTE *pbAddr,
									bool fByVersion = false);

    HRESULT GetILToNativeMapping(MethodDesc *pMD, ULONG32 cMap, ULONG32 *pcMap,
                                 COR_DEBUG_IL_TO_NATIVE_MAP map[]);

    DWORD GetPatchedOpcode(const BYTE *ip);
    void FunctionStubInitialized(MethodDesc *fd, const BYTE *stub);

    void TraceCall(const BYTE *address);
    void PossibleTraceCall(UMEntryThunk *pUMEntryThunk, Frame *pFrame);

    bool ThreadsAtUnsafePlaces(void);

	void PitchCode( MethodDesc *fd,const BYTE *pbAddr );

	void MovedCode( MethodDesc *fd, const BYTE *pbOldAddress,
		const BYTE *pbNewAddress);

    void IncThreadsAtUnsafePlaces(void)
    {
        InterlockedIncrement(&m_threadsAtUnsafePlaces);
    }
    
    void DecThreadsAtUnsafePlaces(void)
    {
        InterlockedDecrement(&m_threadsAtUnsafePlaces);
    }

    static StackWalkAction AtSafePlaceStackWalkCallback(CrawlFrame *pCF,
                                                        VOID* data);
    bool IsThreadAtSafePlace(Thread *thread);

    void Terminate();
    void Continue();

    bool HandleIPCEvent(DebuggerIPCEvent* event, IpcTarget iWhich);

    void SendSyncCompleteIPCEvent();

    DebuggerModule* LookupModule(Module* pModule, AppDomain *pAppDomain)
    {
		// if this is a module belonging to the system assembly, then scan
		// the complete list of DebuggerModules looking for the one 
		// with a matching appdomain id
		// it. 
        if (m_pModules == NULL)
            return (NULL);
		else if ((pModule->GetAssembly() == SystemDomain::SystemAssembly()) || pModule->GetAssembly()->IsShared())
        {
            // We have to make sure to lookup the module with the app domain parameter if the module lives in a shared
            // assembly or the system assembly. Bugs 65943 & 81728.
	        return m_pModules->GetModule(pModule, pAppDomain);
        }
		else
	        return m_pModules->GetModule(pModule);
    }

    void EnsureModuleLoadedForInproc(
	    void ** pobjClassDebuggerModuleToken, // in-out
	    EEClass *objClass,
	    AppDomain *pAppDomain,
	    IpcTarget iWhich
	);

    HRESULT GetAndSendSyncBlockFieldInfo(void *debuggerModuleToken,
                                         mdTypeDef classMetadataToken,
                                         Object *pObject,
                                         CorElementType objectType,
                                         SIZE_T offsetToVars,
                                         mdFieldDef fldToken,
                                         BYTE *staticVarBase,
                                         DebuggerRCThread* rcThread,
                                         IpcTarget iWhich);

    HRESULT GetAndSendFunctionData(DebuggerRCThread* rcThread,
                                   mdMethodDef methodToken,
                                   void* functionModuleToken,
                                   SIZE_T nVersion,
                                   IpcTarget iWhich);

    HRESULT GetAndSendObjectInfo(DebuggerRCThread* rcThread,
                                 AppDomain *pAppDomain,
                                 void* objectRefAddress,
                                 bool objectRefInHandle,
                                 bool objectRefIsValue,
                                 CorElementType objectType,
                                 bool fStrongNewRef,
                                 bool fMakeHandle,
                                 IpcTarget iWhich);
                                       
    HRESULT GetAndSendClassInfo(DebuggerRCThread* rcThread,
                                 void* classDebuggerModuleToken,
                                 mdTypeDef classMetadataToken,
                                 AppDomain *pAppDomain,
                                 mdFieldDef fldToken, // for special use by GASSBFI, above
                                 FieldDesc **pFD, //OUT
                                 IpcTarget iWhich);

    HRESULT GetAndSendSpecialStaticInfo(DebuggerRCThread *rcThread,
                                        void *fldDebuggerToken,
                                        void *debuggerThreadToken,
                                        IpcTarget iWhich);

    HRESULT GetAndSendJITInfo(DebuggerRCThread* rcThread,
                              mdMethodDef funcMetadataToken,
                              void *funcDebuggerModuleToken,
                              AppDomain *pAppDomain,
                              IpcTarget iWhich);

    void GetAndSendTransitionStubInfo(const BYTE *stubAddress,
                                      IpcTarget iWhich);

    void SendBreakpoint(Thread *thread, CONTEXT *context, 
                        DebuggerBreakpoint *breakpoint);

    void SendStep(Thread *thread, CONTEXT *context, 
                  DebuggerStepper *stepper,
                  CorDebugStepReason reason);
                  
    void SendEncRemapEvents(UnorderedEnCRemapArray *pEnCRemapInfo);
    void LockAndSendEnCRemapEvent(MethodDesc *pFD,
                                  BOOL fAccurate);
    void LockAndSendBreakpointSetError(DebuggerControllerPatch *patch);

    HRESULT SendException(Thread *thread, bool firstChance, bool continuable, bool fAttaching);

    void SendUserBreakpoint(Thread *thread);
    void SendRawUserBreakpoint(Thread *thread);

    HRESULT AttachDebuggerForBreakpoint(Thread *thread,
                                                  WCHAR *wszLaunchReason);

    BOOL SyncAllThreads();
    void LockForEventSending(BOOL fNoRetry = FALSE);
    void UnlockFromEventSending();

    void ThreadIsSafe(Thread *thread);
    
    void UnrecoverableError(HRESULT errorHR,
                            unsigned int errorCode,
                            const char *errorFile,
                            unsigned int errorLine,
                            bool exitThread);

    BOOL IsSynchronizing(void)
    {
        return m_trappingRuntimeThreads;
    }

    //
    // The debugger mutex is used to protect any "global" Left Side
    // data structures. The RCThread takes it when handling a Right
    // Side event, and Runtime threads take it when processing
    // debugger events.
    //
#ifdef _DEBUG
    int m_mutexCount;
#endif
    void Lock(void)
    {
        LOG((LF_CORDB,LL_INFO10000, "D::Lock aquire attempt by 0x%x\n", 
            GetCurrentThreadId()));

		// We don't need to worry about lock mismatches in Debugger.h, since having
		// an open lock during shutdown will not hurt anything, and the locking mechanisms
		// prevent deadlock conditions on shutdown
		// LOCKCOUNTINCL("Lock in Debugger.h");
        if (!g_fProcessDetach)
        {
            EnterCriticalSection(&m_mutex);

#ifdef _DEBUG
            _ASSERTE(m_mutexCount >= 0);

            if (m_mutexCount>0)
                _ASSERTE(m_mutexOwner == GetCurrentThreadId());

            m_mutexCount++;
            m_mutexOwner = GetCurrentThreadId();

            if (m_mutexCount == 1)
                LOG((LF_CORDB,LL_INFO10000, "D::Lock aquired by 0x%x\n", 
                    m_mutexOwner));
#endif
        }
    }
    
    void Unlock(void)
    {
		// See Lock for why we don't care about this.
        //LOCKCOUNTDECL("UnLock in Debugger.h");
    
        if (!g_fProcessDetach)
        {
#ifdef _DEBUG
            if (m_mutexCount == 1)
                LOG((LF_CORDB,LL_INFO10000, "D::Unlock released by 0x%x\n", 
                    m_mutexOwner));
                    
            if(0 == --m_mutexCount)
                m_mutexOwner = 0;
                
            _ASSERTE( m_mutexCount >= 0);
#endif    
            LeaveCriticalSection(&m_mutex);
        }
         
    }

#ifdef _DEBUG    
    bool ThreadHoldsLock(void)
    {
        return ((GetCurrentThreadId() == m_mutexOwner) || g_fProcessDetach);
    }
#endif
    
    static EXCEPTION_DISPOSITION __cdecl FirstChanceHijackFilter(
                             EXCEPTION_RECORD *pExceptionRecord,
                             EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                             CONTEXT *pContext,
                             void *DispatcherContext);
    static void GenericHijackFunc(void);
    static void SecondChanceHijackFunc(void);
    static void ExceptionForRuntime(void);
    static void ExceptionForRuntimeHandoffStart(void);
    static void ExceptionForRuntimeHandoffComplete(void);
    static void ExceptionNotForRuntime(void);
    static void NotifyRightSideOfSyncComplete(void);
    static void NotifySecondChanceReadyForData(void);

    static void FuncEvalHijack(void);
    
    // @cmember InsertAtHeadOfList puts the given DJI into the DJI table,
    // thus prepending it to the list of DJIs for the given method (MethodDesc
    // is extracted from dji->m_fd, which had better be valid).
    HRESULT InsertAtHeadOfList( DebuggerJitInfo *dji );

    // @cmember DeleteHeadOfList removes the current head of the list,
    // deleting the DJI, fixing up the list if the previous element
    // exists.
    HRESULT DeleteHeadOfList( MethodDesc *pFD );

    // @cmember MapBreakpoints will map any and all breakpoints (except EnC
    //		patches) from previous versions of the method into the current version.
    HRESULT MapAndBindFunctionPatches( DebuggerJitInfo *pJiNew,
        MethodDesc * fd,
        BYTE * addrOfCode);

    // @cmember MPTDJI takes the given patch (and djiFrom, if you've got it), and
    // does the IL mapping forwards to djiTo.  Returns 
    // CORDBG_E_CODE_NOT_AVAILABLE if there isn't a mapping, which means that
    // no patch was placed.
    HRESULT MapPatchToDJI( DebuggerControllerPatch *dcp, DebuggerJitInfo *djiTo);

    // @cmember MapOldILToNew takes an oldIL, and does a binary search on the
    //      <t DebuggerOldILToNewILMap> map, and
    //      fills in newIL appropriately.
    HRESULT MapOldILToNewIL(BOOL fOldToNew,
        DebuggerOldILToNewILMap *min, 
        DebuggerOldILToNewILMap *max, 
        SIZE_T oldIL, 
        SIZE_T *newIL,
        BOOL *fAccurate);


    void MapForwardsCurrentBreakpoints(UnorderedILMap *ilMapReal, MethodDesc *pFD);

    HRESULT  MapThroughVersions(SIZE_T fromIL, 
                                DebuggerJitInfo *djiFrom,  
                                SIZE_T *toIL, 
                                DebuggerJitInfo *djiTo, 
                                BOOL fMappingForwards,
                                BOOL *fAccurate);


	HRESULT LaunchDebuggerForUser (void);

	void SendLogMessage (int iLevel, WCHAR *pCategory, int iCategoryLen,
								WCHAR *pMessage, int iMessageLen);

	void SendLogSwitchSetting (int iLevel, int iReason, 
							WCHAR *pLogSwitchName, WCHAR *pParentSwitchName);

	bool IsLoggingEnabled (void) 
	{
		if (m_LoggingEnabled) 
			return true;
		return false;
	}

	void EnableLogMessages (bool fOnOff) { m_LoggingEnabled = fOnOff;}
	bool GetILOffsetFromNative (MethodDesc *PFD, const BYTE *pbAddr, 
								DWORD nativeOffset, DWORD *ilOffset);

    DWORD GetHelperThreadID(void );


    HRESULT SetIP( bool fCanSetIPOnly, 
                   Thread *thread,
                   Module *module, 
                   mdMethodDef mdMeth,
                   DebuggerJitInfo* dji, 
                   SIZE_T offsetTo,
                   BOOL fIsIL,
                   void *firstExceptionHandler);

    // Helper routines used by Debugger::SetIP
    HRESULT ShuffleVariablesGet(DebuggerJitInfo  *dji, 
                                SIZE_T            offsetFrom, 
                                CONTEXT          *pCtx,
                                DWORD           **prgVal1,
                                DWORD           **prgVal2,
                                BYTE           ***prgpVCs);
                                
    void ShuffleVariablesSet(DebuggerJitInfo  *dji, 
                             SIZE_T            offsetTo, 
                             CONTEXT          *pCtx,
                             DWORD           **prgVal1,
                             DWORD           **prgVal2,
                             BYTE            **rgpVCs);

    HRESULT GetVariablesFromOffset(MethodDesc                 *pMD,
                                   UINT                        varNativeInfoCount, 
                                   ICorJitInfo::NativeVarInfo *varNativeInfo,
                                   SIZE_T                      offsetFrom, 
                                   CONTEXT                    *pCtx,
                                   DWORD                      *rgVal1,
                                   DWORD                      *rgVal2,
                                   BYTE                     ***rgpVCs);
                               
    void SetVariablesAtOffset(MethodDesc                 *pMD,
                              UINT                        varNativeInfoCount, 
                              ICorJitInfo::NativeVarInfo *varNativeInfo,
                              SIZE_T                      offsetTo, 
                              CONTEXT                    *pCtx,
                              DWORD                      *rgVal1,
                              DWORD                      *rgVal2,
                              BYTE                      **rgpVCs);

    BOOL IsThreadContextInvalid(Thread *pThread);

	HRESULT	AddAppDomainToIPC (AppDomain *pAppDomain);
	HRESULT RemoveAppDomainFromIPC (AppDomain *pAppDomain);
	HRESULT UpdateAppDomainEntryInIPC (AppDomain *pAppDomain);
    HRESULT IterateAppDomainsForAttach(AttachAppDomainEventsEnum EventsToSend, BOOL *fEventSent, BOOL fAttaching);
    HRESULT AttachDebuggerToAppDomain(ULONG id);
    HRESULT MarkAttachingAppDomainsAsAttachedToDebugger(void);
    HRESULT DetachDebuggerFromAppDomain(ULONG id, AppDomain **ppAppDomain);
	
	void SendCreateAppDomainEvent (AppDomain *pAppDomain,
	                               BOOL fAttaching);
	void SendExitAppDomainEvent (AppDomain *pAppDomain);

	void LoadAssembly(AppDomain* pRuntimeAppDomain,
                      Assembly *pAssembly,
                      BOOL fSystem,
                      BOOL fAttaching);
	void UnloadAssembly(AppDomain *pAppDomain, 
	                    Assembly* pAssembly);

    HRESULT FuncEvalSetup(DebuggerIPCE_FuncEvalInfo *pEvalInfo, BYTE **argDataArea, void **debuggerEvalKey);
    HRESULT FuncEvalSetupReAbort(Thread *pThread);
    static void *FuncEvalHijackWorker(DebuggerEval *pDE);
    HRESULT FuncEvalAbort(void *debuggerEvalKey);
    HRESULT FuncEvalCleanup(void *debuggerEvalKey);

    HRESULT SetReference(void *objectRefAddress, bool  objectRefInHandle, void *newReference);
    HRESULT SetValueClass(void *oldData, void *newData, mdTypeDef classMetadataToken, void *classDebuggerModuleToken);

    HRESULT SetILInstrumentedCodeMap(MethodDesc *fd,
                                     BOOL fStartJit,
                                     ULONG32 cILMapEntries,
                                     COR_IL_MAP rgILMapEntries[]);

    void EarlyHelperThreadDeath(void);

    void ShutdownBegun(void);

    // Callbacks from the profiler that get at/set inproc debugging
    HRESULT GetInprocICorDebug( IUnknown **iu, bool fThisThread );
    HRESULT SetInprocActiveForThread(BOOL fIsActive);
    BOOL    GetInprocActiveForThread();
    HRESULT SetCurrentPointerForDebugger(void *ptr, PTR_TYPE ptrType);
    void    InprocOnThreadDestroy(Thread *pThread);

    // Pid of the left side process that this Debugger instance is in.
    DWORD GetPid(void) { return m_processId; }

    // Virtual RPC to Virtual Left side, called by the in-proc Cordb
    // Note that this means that all calls from the Left side are synchronous
    // with respect to the thread that's making the calls.
    // See also: CordbgRCEvent::VrpcToVrs
    HRESULT VrpcToVls(DebuggerIPCEvent *event);

    HRESULT NameChangeEvent(AppDomain *pAppDomain, Thread *pThread);

    // This aquires a lock on the jit patch table, iterates through the table,
    // and eliminates all the patches / controllers that are specific to
    // the given domain.  Used as part of the AppDomain detach logic.
    void ClearAppDomainPatches(AppDomain *pAppDomain);

    void IgnoreThreadDetach(void)
	{
		m_ignoreThreadDetach = TRUE;
	}

    BOOL SendCtrlCToDebugger(DWORD dwCtrlType);

    // Allows the debugger to keep an up to date list of special threads
    HRESULT UpdateSpecialThreadList(DWORD cThreadArrayLength, DWORD *rgdwThreadIDArray);
	
    // Updates the pointer for the debugger services
    void SetIDbgThreadControl(IDebuggerThreadControl *pIDbgThreadControl);

    void BlockAndReleaseTSLIfNecessary(BOOL fHoldingThreadStoreLock);

    HRESULT InitInProcDebug()
    {
        INPROC_INIT_LOCK();

        _ASSERTE(m_pRCThread != NULL); 
        return(m_pRCThread->InitInProcDebug());
    }

    HRESULT UninitInProcDebug()
    {
        m_pRCThread->UninitInProcDebug();
        INPROC_UNINIT_LOCK();
        return (S_OK);
    }

    SIZE_T GetVersionNumber(MethodDesc *fd);
    void SetVersionNumberLastRemapped(MethodDesc *fd, SIZE_T nVersionRemapped);
    HRESULT IncrementVersionNumber(Module *pModule, mdMethodDef token);

    // These should only be called by the Debugger, or from ResumeInUpdatedFunction
    void LockJITInfoMutex(void)
    {
        LOCKCOUNTINCL("LockJITInfoMutex in Debugger.h");

        if (!g_fProcessDetach)
            EnterCriticalSection(&m_jitInfoMutex);
    }
    
    void UnlockJITInfoMutex(void)
    {
        if (!g_fProcessDetach)
            LeaveCriticalSection(&m_jitInfoMutex);
        
        LOCKCOUNTDECL("UnLockJITInfoMutex in Debugger.h");
    }

    // Note that you'll have to lock the JITInfoMutex in order to
    // take this.
    void SetEnCTransitionIllegal(MethodDesc *fd)
    {
        _ASSERTE(fd != NULL);
        
        DebuggerJitInfo *dji = GetJitInfo(fd, 
                                          NULL);
        _ASSERTE(dji != NULL);
        dji->m_illegalToTransitionFrom = TRUE;
    }

    AppDomainEnumerationIPCBlock *GetAppDomainEnumIPCBlock() { return m_pAppDomainCB; }
 
private:
    void    DoHelperThreadDuty(bool temporaryHelp);

    typedef enum
    {
        ATTACH_YES,
        ATTACH_NO,
        ATTACH_TERMINATE
    } ATTACH_ACTION;

    // Returns true if the debugger is not attached and DbgJITDebugLaunchSetting
    // is set to either ATTACH_DEBUGGER or ASK_USER and the user request attaching.
    ATTACH_ACTION ShouldAttachDebugger(bool fIsUserBreakpoint, UnhandledExceptionLocation location);
	ATTACH_ACTION ShouldAttachDebuggerProxy(bool fIsUserBreakpoint, UnhandledExceptionLocation location);
	friend void ShouldAttachDebuggerStub(ShouldAttachDebuggerParams * p);
	friend ShouldAttachDebuggerParams;
	
    // @todo APPDOMAIN remove this hack when we get real support
    BOOL m_fGCPrevented;
    
    void DisableEventHandling(void);
    void EnableEventHandling(bool forceIt = false);

    BOOL TrapAllRuntimeThreads(AppDomain *pAppDomain, BOOL fHoldingThreadStoreLock = FALSE);
    void ReleaseAllRuntimeThreads(AppDomain *pAppDomain);

    void InitIPCEvent(DebuggerIPCEvent *ipce,
                      DebuggerIPCEventType type,
                      DWORD threadId,
                      void *pAppDomainToken)
    {
        _ASSERTE(ipce != NULL);
        ipce->type = type;
        ipce->hr = S_OK;
        ipce->processId = m_processId;
        ipce->appDomainToken = pAppDomainToken;
        ipce->threadId = threadId;
    }
    
    void InitIPCEvent(DebuggerIPCEvent *ipce,
                      DebuggerIPCEventType type)
    {
        _ASSERTE(type == DB_IPCE_SYNC_COMPLETE ||
                 type == DB_IPCE_GET_DATA_RVA_RESULT ||
                 type == DB_IPCE_GET_SYNC_BLOCK_FIELD_RESULT);
    
        Thread *pThread = g_pEEInterface->GetThread();
        AppDomain *pAppDomain = NULL;
    
        if (pThread)
            pAppDomain = pThread->GetDomain();
        
        InitIPCEvent(ipce, 
                     type, 
                     GetCurrentThreadId(),
                     (void *)pAppDomain);
    }

    HRESULT GetFunctionInfo(Module *pModule,
                            mdToken functionToken,
                            MethodDesc **ppFD,
                            ULONG *pRVA,
                            BYTE **pCodeStart,
                            unsigned int *pCodeSize,
                            mdToken *pLocalSigToken);
                            
    HRESULT GetAndSendBuffer(DebuggerRCThread* rcThread, ULONG bufSize);

    HRESULT SendReleaseBuffer(DebuggerRCThread* rcThread, BYTE *pBuffer);

	HRESULT ReleaseRemoteBuffer(BYTE *pBuffer, bool removeFromBlobList);

    HRESULT CommitAndSendResult(DebuggerRCThread* rcThread, BYTE *pData,
                                BOOL checkOnly);

    WCHAR *GetDebuggerLaunchString(void);
    
    HRESULT EnsureDebuggerAttached(AppDomain *pAppDomain,
                                   LPWSTR exceptionName);
    HRESULT EDAHelper(AppDomain *pAppDomain, LPWSTR wszAttachReason);
    
    HRESULT EDAHelperProxy(AppDomain *pAppDomain, LPWSTR exceptionName);
	friend void EDAHelperStub(EnsureDebuggerAttachedParams * p);
	
    HRESULT FinishEnsureDebuggerAttached();

    DebuggerLaunchSetting GetDbgJITDebugLaunchSetting(void);

    HRESULT InitAppDomainIPC(void);
    HRESULT TerminateAppDomainIPC(void);

    ULONG IsDebuggerAttachedToAppDomain(Thread *pThread);

    bool ResumeThreads(AppDomain* pAppDomain);

private:
    DebuggerRCThread*     m_pRCThread;
    DWORD                 m_processId;
    BOOL                  m_trappingRuntimeThreads;
    BOOL                  m_stopped;
    BOOL                  m_unrecoverableError;
	BOOL				  m_ignoreThreadDetach;
    DebuggerJitInfoTable *m_pJitInfos;
    CRITICAL_SECTION      m_jitInfoMutex;



    CRITICAL_SECTION      m_mutex;
	HANDLE                m_CtrlCMutex;
    HANDLE                m_debuggerAttachedEvent;
	BOOL                  m_DebuggerHandlingCtrlC;
#ifdef _DEBUG
    DWORD                 m_mutexOwner;
#endif
    HANDLE                m_eventHandlingEvent;
    DebuggerAttachState   m_syncingForAttach;
    LONG                  m_threadsAtUnsafePlaces;
    HANDLE                m_exAttachEvent;
    HANDLE                m_exAttachAbortEvent;
    HANDLE                m_runtimeStoppedEvent;
    BOOL                  m_attachingForException;
    LONG                  m_exLock;
	SIZE_T_UNORDERED_ARRAY m_BPMappingDuplicates; // Used by 
		// MapAndBindFunctionBreakpoints.  Note that this is
		// thread-safe only b/c we access it from within
		// the DebuggerController::Lock
	BOOL                  m_LoggingEnabled;
	AppDomainEnumerationIPCBlock	*m_pAppDomainCB;

    UnorderedBytePtrArray*m_pMemBlobs;
    
    UnorderedEnCRemapArray m_EnCRemapInfo;
public:    
    DebuggerModuleTable          *m_pModules;
    BOOL                          m_debuggerAttached;
    IDebuggerThreadControl       *m_pIDbgThreadControl;
    DebuggerPendingFuncEvalTable *m_pPendingEvals;

    BOOL                          m_RCThreadHoldsThreadStoreLock;

    DebuggerHeap                 *m_heap;
};


/* ------------------------------------------------------------------------ *
 * DebuggerEval class
 * ------------------------------------------------------------------------ */

struct DebuggerEval
{
    // Note: this first field must be big enough to hold a breakpoint 
    // instruction, and it MUST be the first field. (This
    // is asserted in debugger.cpp)
    DWORD                          m_breakpointInstruction;
    CONTEXT                        m_context;
    Thread                        *m_thread;
    DebuggerIPCE_FuncEvalType      m_evalType;
    mdMethodDef                    m_methodToken;
    mdTypeDef                      m_classToken;
    EEClass                       *m_class;
    DebuggerModule                *m_debuggerModule;
    void                          *m_funcEvalKey;
    bool                           m_successful;        // Did the eval complete successfully
    SIZE_T                         m_argCount;
    SIZE_T                         m_stringSize;
    BYTE                          *m_argData;
    MethodDesc                    *m_md;
    INT64                          m_result;
    CorElementType                 m_resultType;
    Module                        *m_resultModule;
    SIZE_T                         m_arrayRank;
    mdTypeDef                      m_arrayClassMetadataToken;
    DebuggerModule                *m_arrayClassDebuggerModuleToken;
    CorElementType                 m_arrayElementType;
    bool                           m_aborting;          // Has an abort been requested
    bool                           m_aborted;           // Was this eval aborted
    bool                           m_completed;          // Is the eval complete - successfully or by aborting
    bool                           m_evalDuringException;
    bool                           m_rethrowAbortException;
    
    DebuggerEval(CONTEXT *context, DebuggerIPCE_FuncEvalInfo *pEvalInfo, bool fInException)
    {
        m_thread = (Thread*)pEvalInfo->funcDebuggerThreadToken;
        m_evalType = pEvalInfo->funcEvalType;
        m_methodToken = pEvalInfo->funcMetadataToken;
        m_classToken = pEvalInfo->funcClassMetadataToken;
        m_class = NULL;
        m_debuggerModule = (DebuggerModule*) pEvalInfo->funcDebuggerModuleToken;
        m_funcEvalKey = pEvalInfo->funcEvalKey;
        m_argCount = pEvalInfo->argCount;
        m_stringSize = pEvalInfo->stringSize;
        m_arrayRank = pEvalInfo->arrayRank;
        m_arrayClassMetadataToken = pEvalInfo->arrayClassMetadataToken;
        m_arrayClassDebuggerModuleToken = (DebuggerModule*) pEvalInfo->arrayClassDebuggerModuleToken;
        m_arrayElementType = pEvalInfo->arrayElementType;
        m_successful = false;
        m_argData = NULL;
        m_result = 0;
        m_md = NULL;
        m_resultModule = NULL;
        m_resultType = ELEMENT_TYPE_VOID;
        m_aborting = false;
        m_aborted = false;
        m_completed = false;
        m_evalDuringException = fInException;
        m_rethrowAbortException = false;
        // Copy the thread's context.
        if (context == NULL) 
            memset(&m_context, 0, sizeof(m_context));
        else
            memcpy(&m_context, context, sizeof(m_context));
    }

    // This constructor is only used when setting up an eval to re-abort a thread.
    DebuggerEval(CONTEXT *context, Thread *pThread)
    {
        m_thread = pThread;
        m_evalType = DB_IPCE_FET_RE_ABORT;
        m_methodToken = mdMethodDefNil;
        m_classToken = mdTypeDefNil;
        m_class = NULL;
        m_debuggerModule = NULL;
        m_funcEvalKey = NULL;
        m_argCount = 0;
        m_stringSize = 0;
        m_arrayRank = 0;
        m_arrayClassMetadataToken = mdTypeDefNil;
        m_arrayClassDebuggerModuleToken = NULL;
        m_arrayElementType = ELEMENT_TYPE_VOID;
        m_successful = false;
        m_argData = NULL;
        m_result = 0;
        m_md = NULL;
        m_resultModule = NULL;
        m_resultType = ELEMENT_TYPE_VOID;
        m_aborting = false;
        m_aborted = false;
        m_completed = false;
        m_evalDuringException = false;
        m_rethrowAbortException = false;
        // Copy the thread's context.
        memcpy(&m_context, context, sizeof(m_context));
        if (context == NULL) 
            memset(&m_context, 0, sizeof(m_context));
        else
            memcpy(&m_context, context, sizeof(m_context));
    }

    ~DebuggerEval()
    {
        if (m_argData)
            DeleteInteropSafe(m_argData);
    }
};

/* ------------------------------------------------------------------------ *
 * DebuggerHeap class
 * ------------------------------------------------------------------------ */

class DebuggerHeap
{
public:
    DebuggerHeap() : m_heap(NULL) {}
    ~DebuggerHeap();

    HRESULT Init(char *name);
    
    void *Alloc(DWORD size);
    void *Realloc(void *pMem, DWORD newSize);
    void  Free(void *pMem);

private:
    gmallocHeap      *m_heap;
    CRITICAL_SECTION  m_cs;
};

/* ------------------------------------------------------------------------ *
 * New/delete overrides to use the debugger's private heap
 * ------------------------------------------------------------------------ */

class InteropSafe {};
extern const InteropSafe interopsafe;
        
static inline void * __cdecl operator new(size_t n, const InteropSafe&)
{
    _ASSERTE(g_pDebugger != NULL);
    _ASSERTE(g_pDebugger->m_heap != NULL);
    
    return g_pDebugger->m_heap->Alloc(n);
}

static inline void * __cdecl operator new[](size_t n, const InteropSafe&)
{ 
    _ASSERTE(g_pDebugger != NULL);
    _ASSERTE(g_pDebugger->m_heap != NULL);
    
    return g_pDebugger->m_heap->Alloc(n);
}

// Note: there is no C++ syntax for manually invoking this, but if a constructor throws an exception I understand that
// this delete operator will be invoked automatically to destroy the object.
static inline void __cdecl operator delete(void *p, const InteropSafe&)
{
    if (p != NULL)
    {
        _ASSERTE(g_pDebugger != NULL);
        _ASSERTE(g_pDebugger->m_heap != NULL);
    
        g_pDebugger->m_heap->Free(p);
    }
}

// Note: there is no C++ syntax for manually invoking this, but if a constructor throws an exception I understand that
// this delete operator will be invoked automatically to destroy the object.
static inline void __cdecl operator delete[](void *p, const InteropSafe&)
{
    if (p != NULL)
    {
        _ASSERTE(g_pDebugger != NULL);
        _ASSERTE(g_pDebugger->m_heap != NULL);
    
        g_pDebugger->m_heap->Free(p);
    }
}

//
// Interop safe delete to match the interop safe new's above. There is no C++ syntax for actually invoking those interop
// safe delete operators above, so we use this method to accomplish the same thing.
//
template<class T> void DeleteInteropSafe(T *p)
{
    if (p != NULL)
    {
        p->T::~T();
    
        _ASSERTE(g_pDebugger != NULL);
        _ASSERTE(g_pDebugger->m_heap != NULL);
    
        g_pDebugger->m_heap->Free(p);
    }
}


// CNewZeroData is the allocator used by the all the hash tables that the helper thread could possibly alter. It uses
// the interop safe allocator.
class CNewZeroData
{
public:
	static BYTE *Alloc(int iSize, int iMaxSize)
	{
        _ASSERTE(g_pDebugger != NULL);
        _ASSERTE(g_pDebugger->m_heap != NULL);
        
        BYTE *pb = (BYTE *) g_pDebugger->m_heap->Alloc(iSize);
        
        if (pb != NULL)
            memset(pb, 0, iSize);
		return pb;
	}
	static void Free(BYTE *pPtr, int iSize)
	{
        _ASSERTE(g_pDebugger != NULL);
        _ASSERTE(g_pDebugger->m_heap != NULL);

		g_pDebugger->m_heap->Free(pPtr);
	}
	static BYTE *Grow(BYTE *&pPtr, int iCurSize)
	{
        _ASSERTE(g_pDebugger != NULL);
        _ASSERTE(g_pDebugger->m_heap != NULL);
        
		void *p = g_pDebugger->m_heap->Realloc(pPtr, iCurSize + GrowSize());
        
		if (p == 0) return (0);
        
        memset((BYTE*)p+iCurSize, 0, GrowSize());
		return (pPtr = (BYTE *)p);
	}
	static int RoundSize(int iSize)
	{
		return (iSize);
	}
	static int GrowSize()
	{
		return (256);
	}
};
#endif /* DEBUGGER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\di\process.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: process.cpp
//
//*****************************************************************************
#include "stdafx.h"

#ifdef UNDEFINE_RIGHT_SIDE_ONLY
#undef RIGHT_SIDE_ONLY
#endif //UNDEFINE_RIGHT_SIDE_ONLY

#include <tlhelp32.h>

#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION 0x1000
#endif

// Get version numbers for IPCHeader stamp
#include "__file__.ver"

#include "CorPriv.h"
#include "..\..\dlls\mscorrc\resource.h"


//-----------------------------------------------------------------------------
// For debugging ease, cache some global values.
// Include these in retail & free because that's where we need them the most!!
// Optimized builds may not let us view locals & parameters. So Having these 
// cached as global values should let us inspect almost all of
// the interesting parts of the RS even in a Retail build!
//-----------------------------------------------------------------------------
struct RSDebuggingInfo
{
    // There should only be 1 global Cordb object. Store it here.
    Cordb * m_Cordb; 

    // We have lots of processes. Keep a pointer to the most recently touched
    // (subjective) process, as a hint about what our "current" process is.
    // If we're only debugging 1 process, this will be sufficient.
    CordbProcess * m_MRUprocess; 

    // Keep a pointer to the win32 & RC event threads.
    CordbWin32EventThread * m_Win32ET;
    CordbRCEventThread * m_RCET;
};

// since there's some overlap between in-process & oop, we'll have
// 2 totally disjoint structure and be really clear.
#ifdef RIGHT_SIDE_ONLY
// For rightside (out-of process)
RSDebuggingInfo g_RSDebuggingInfo_OutOfProc = {0 }; // set to NULL
static RSDebuggingInfo * g_pRSDebuggingInfo = &g_RSDebuggingInfo_OutOfProc;
#else
// For left-side (in-process)
RSDebuggingInfo g_RSDebuggingInfo_Inproc = {0 }; // set to NULL
static RSDebuggingInfo * g_pRSDebuggingInfo = &g_RSDebuggingInfo_Inproc;
#endif


#ifdef RIGHT_SIDE_ONLY

inline DWORD CORDbgGetInstruction(const unsigned char* address)
{
#ifdef _X86_
    return *address; // retrieving only one byte is important
#else
    _ASSERTE(!"@TODO Alpha - CORDbgGetInstruction (Process.cpp)");
    return 0;
#endif // _X86_
}

inline void CORDbgSetInstruction(const unsigned char* address,
                                 DWORD instruction)
{
#ifdef _X86_
    *((unsigned char*)address)
          = (unsigned char) instruction; // setting one byte is important
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - CORDbgSetInstruction (Process.cpp)");
#endif // _X86_
}

inline void CORDbgInsertBreakpoint(const unsigned char* address)
{
#ifdef _X86_
    *((unsigned char*)address) = 0xCC; // int 3 (single byte patch)
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - CORDbgInsertBreakpoint (Process.cpp)");
#endif // _X86_
}

#endif //RIGHT_SIDE_ONLY // SkipGetSetInsert

#define CORDB_WAIT_TIMEOUT 360000 // milliseconds

inline DWORD CordbGetWaitTimeout()
{
#ifdef _DEBUG
    // 0 = Wait forever
    // 1 = Wait for CORDB_WAIT_TIMEOUT
    // n = Wait for n milliseconds
    static ConfigDWORD cordbWaitTimeout(L"DbgWaitTimeout", 1);
    DWORD timeoutVal = cordbWaitTimeout.val();
    if (timeoutVal == 0)
        return DWORD(-1);
    else if (timeoutVal != 1)
        return timeoutVal;
    else    
#endif
    {
        return CORDB_WAIT_TIMEOUT;
    }
}


#ifdef _DEBUG
void vDbgNameEvent(PWCHAR wczName, DWORD dwNameSize, DWORD dwLine, PCHAR szFile, const PWCHAR wczEventName)
{
    MAKE_WIDEPTR_FROMANSI(wczFile, szFile)
    PWCHAR pwc = wczFile;

    // Replace \ characters with . characters 
    // See documenation for CreateEvent. It doesn't like \ characters to be in the name.
    while(*pwc != L'')
    {
        if (L'\\' == *pwc)
        {
            *pwc = L'.';
        }
        pwc++;
    }

    // An example name might be "CorDBI.DI.process.cpp@3203 CrazyWin98WorkAround ProcId=1239"
    swprintf(wczName, L"CorDBI.%s@%d %s ProcId=%d", wczFile, dwLine, wczEventName, GetCurrentProcessId());
}

LONG CordbBase::m_saDwInstance[enumMaxDerived];
LONG CordbBase::m_saDwAlive[enumMaxDerived];
PVOID CordbBase::m_sdThis[enumMaxDerived][enumMaxThis];

DWORD            g_dwInprocLockOwner = 0;
DWORD            g_dwInprocLockRecursionCount = 0;
#endif

CRITICAL_SECTION g_csInprocLock;
/* ------------------------------------------------------------------------- *
 * CordbBase class
 * ------------------------------------------------------------------------- */
void CordbBase::NeuterAndClearHashtable(CordbHashTable * pCordbHashtable)
{
    HASHFIND hfDT;
    CordbBase * pCordbBase;

    while ((pCordbBase = ((CordbBase *)pCordbHashtable->FindFirst(&hfDT))) != 0)
    {
        pCordbBase->Neuter();
        pCordbHashtable->RemoveBase(pCordbBase->m_id);
    }
} 

/* ------------------------------------------------------------------------- *
 * Cordb class
 * ------------------------------------------------------------------------- */

bool Cordb::m_runningOnNT = false;

Cordb::Cordb()
  : CordbBase(0, enumCordb), 
    m_managedCallback(NULL), m_unmanagedCallback(NULL), m_processes(11),
    m_initialized(false), m_pMetaDispenser(NULL),
    m_crazyWin98WorkaroundEvent(NULL),
    m_pCorHost(NULL)
#ifndef RIGHT_SIDE_ONLY
    ,m_procThis(NULL)
#endif //INPROC only
{
    _ASSERTE(g_pRSDebuggingInfo->m_Cordb == NULL);
    g_pRSDebuggingInfo->m_Cordb = this;
}

Cordb::~Cordb()
{
    LOG((LF_CORDB, LL_INFO10, "C::~C Terminating Cordb object."));
#ifndef RIGHT_SIDE_ONLY
    if (m_rcEventThread != NULL)
    {
        delete m_rcEventThread;
        m_rcEventThread = NULL;
    }  

    if(m_procThis != NULL)
    {
        m_procThis->Release();
        m_procThis = NULL;
    }

    if(m_pMetaDispenser != NULL)
    {
        m_pMetaDispenser->Release();
        m_pMetaDispenser = NULL;
    }
#endif //INPROC only
    _ASSERTE(g_pRSDebuggingInfo->m_Cordb == this);
    g_pRSDebuggingInfo->m_Cordb = NULL;
}

void Cordb::Neuter()
{
    AddRef();
    {
        NeuterAndClearHashtable(&m_processes);

        CordbBase::Neuter();
    }
    Release();
}

HRESULT Cordb::Terminate()
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    LOG((LF_CORDB, LL_INFO10000, "[%x] Terminating Cordb\n", GetCurrentThreadId()));

    if (!m_initialized)
        return E_FAIL;
            
    //
    // Stop the event handling threads.
    //
    if (m_win32EventThread != NULL)
    {
        m_win32EventThread->Stop();
        delete m_win32EventThread;
    }

    if (m_rcEventThread != NULL)
    {
        m_rcEventThread->Stop();
        delete m_rcEventThread;
    }

    if (m_crazyWin98WorkaroundEvent != NULL)
    {
    	CloseHandle(m_crazyWin98WorkaroundEvent);
        m_crazyWin98WorkaroundEvent = NULL;
   	}
    
    //
    // Delete all of the processes.
    //
    CordbBase* entry;
    HASHFIND find;

    for (entry =  m_processes.FindFirst(&find);
         entry != NULL;
         entry =  m_processes.FindNext(&find))
    {
        CordbProcess* p = (CordbProcess*) entry;
        LOG((LF_CORDB, LL_INFO1000, "[%x] Releasing process %d\n",
             GetCurrentThreadId(), p->m_id));
        p->Release();
    }

    DeleteCriticalSection(&m_processListMutex);
    
    //
    // Release the metadata interfaces
    //
    if (m_pMetaDispenser)
        m_pMetaDispenser->Release();
    
    //
    // Release the callbacks
    //
    if (m_managedCallback)
        m_managedCallback->Release();

    if (m_unmanagedCallback)
        m_unmanagedCallback->Release();

    if (m_pCorHost)
    {
        m_pCorHost->Stop();
        m_pCorHost->Release();
        m_pCorHost = NULL;
    }

#ifdef LOGGING
    ShutdownLogging();
#endif

    m_initialized = FALSE;

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT Cordb::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebug)
        *pInterface = (ICorDebug*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebug*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//
// Initialize -- setup the ICorDebug object by creating any objects
// that the object needs to operate and starting the two needed IPC
// threads.
//
HRESULT Cordb::Initialize(void)
{
    HRESULT hr = S_OK;
	INPROC_LOCK();
	
    if (!m_initialized)
    {
#ifdef RIGHT_SIDE_ONLY
#ifdef LOGGING
        InitializeLogging();
#endif
#endif //RIGHT_SIDE_ONLY

        LOG((LF_CORDB, LL_INFO10, "Initializing ICorDebug...\n"));

        // Ensure someone hasn't screwed up the IPC buffer size
        _ASSERTE(sizeof(DebuggerIPCEvent) <= CorDBIPC_BUFFER_SIZE);
        
        m_runningOnNT = (RunningOnWinNT() != FALSE);
        
        //
        // Init things that the Cordb will need to operate
        //
        InitializeCriticalSection(&m_processListMutex);
        
#ifdef RIGHT_SIDE_ONLY
        //
        // Create the win32 event listening thread
        //
        m_win32EventThread = new CordbWin32EventThread(this);
        
        if (m_win32EventThread != NULL)
        {
            hr = m_win32EventThread->Init();

            if (SUCCEEDED(hr))
                hr = m_win32EventThread->Start();

            if (FAILED(hr))
            {
                delete m_win32EventThread;
                m_win32EventThread = NULL;
            }
        }
        else
            hr = E_OUTOFMEMORY;

        if (FAILED(hr))
            goto exit;

        NAME_EVENT_BUFFER;
        m_crazyWin98WorkaroundEvent = WszCreateEvent(NULL, FALSE, FALSE, NAME_EVENT(L"CrazyWin98WorkaroundEvent"));
        
        if (m_crazyWin98WorkaroundEvent == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

#endif //RIGHT_SIDE_ONLY

        //
        // Create the runtime controller event listening thread
        //
        m_rcEventThread = new CordbRCEventThread(this);

        if (m_rcEventThread == NULL)
            hr = E_OUTOFMEMORY;
            
#ifdef RIGHT_SIDE_ONLY
        else
        {
            // This stuff only creates events & starts the thread-
            // inproc doesn't want to do this
            hr = m_rcEventThread->Init();

            if (SUCCEEDED(hr))
                hr = m_rcEventThread->Start();

            if (FAILED(hr))
            {
                delete m_rcEventThread;
                m_rcEventThread = NULL;
            }
        }
            
        if (FAILED(hr))
            goto exit;

        hr = CoCreateInstance(CLSID_CorMetaDataDispenser, NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IMetaDataDispenser,
                              (void**)&m_pMetaDispenser);
        
        if (FAILED(hr))
            goto exit;
        
#else
        hr = MetaDataGetDispenser(CLSID_CorMetaDataDispenser,
                                  IID_IMetaDataDispenser,
                                  (void**)&m_pMetaDispenser);        
        if (FAILED(hr))
            goto exit;

        // Don't need to muck w/ environment variables since we're in
        // the already-running process
        
#endif //RIGHT_SIDE_ONLY
        
        m_initialized = TRUE;
    }
    
exit:
	INPROC_UNLOCK();
    return hr;
}

//
// Do we allow another process?
// This is highly dependent on the wait sets in the Win32 & RCET threads.
//
bool Cordb::AllowAnotherProcess()
{
    bool fAllow;
    
    LockProcessList();

    // Cordb, Win32, and RCET all have process sets, but Cordb's is the
    // best count of total debuggees. The RCET set is volatile (processes
    // are added / removed when they become synchronized), and Win32's set
    // doesn't include all processes.
    int cCurProcess = m_processes.GetCount();

    // In order to accept another debuggee, we must have a free slot in all
    // wait sets. Currently, we don't expose the size of those sets, but
    // we know they're MAXIMUM_WAIT_OBJECTS. Note that we lose one slot
    // to the control event.
    if (cCurProcess >= MAXIMUM_WAIT_OBJECTS - 1)
    {
        fAllow = false;
    } else {
        fAllow = true;
    }
    
    UnlockProcessList();

    return fAllow;
}

//
// AddProcess -- add a process object to this ICorDebug's hash of processes.
// This also tells this ICorDebug's runtime controller thread that the
// process set has changed so it can update its list of wait events.
//
HRESULT Cordb::AddProcess(CordbProcess* process)
{
    // At this point, we should have already checked that we 
    // can have another debuggee.
    _ASSERTE(AllowAnotherProcess());
    
    LockProcessList();

    HRESULT hr = m_processes.AddBase(process);
    
#ifdef RIGHT_SIDE_ONLY
    if (SUCCEEDED(hr))
        m_rcEventThread->ProcessStateChanged();
#endif //RIGHT_SIDE_ONLY
    
    UnlockProcessList();

    return hr;
}

//
// RemoveProcess -- remove a process object from this ICorDebug's hash of
// processes. This also tells this ICorDebug's runtime controller thread
// that the process set has changed so it can update its list of wait events.
//
void Cordb::RemoveProcess(CordbProcess* process)
{
    LockProcessList();
    m_processes.RemoveBase(process->m_id);

#ifdef RIGHT_SIDE_ONLY    
    m_rcEventThread->ProcessStateChanged();
#endif //RIGHT_SIDE_ONLY
    
    UnlockProcessList();    
}

//
// LockProcessList -- Lock the process list.
//
void Cordb::LockProcessList(void)
{
	LOCKCOUNTINC
    EnterCriticalSection(&m_processListMutex);
}

//
// UnlockProcessList -- Unlock the process list.
//
void Cordb::UnlockProcessList(void)
{
    LeaveCriticalSection(&m_processListMutex);
	LOCKCOUNTDECL("UnlockProcessList in Process.cpp");
}


HRESULT Cordb::SendIPCEvent(CordbProcess* process,
                            DebuggerIPCEvent* event,
                            SIZE_T eventSize)
{
    return m_rcEventThread->SendIPCEvent(process, event, eventSize);
}


void Cordb::ProcessStateChanged(void)
{
    m_rcEventThread->ProcessStateChanged();
}


HRESULT Cordb::WaitForIPCEventFromProcess(CordbProcess* process,
                                          CordbAppDomain *pAppDomain,
                                          DebuggerIPCEvent* event)
{
    return m_rcEventThread->WaitForIPCEventFromProcess(process, 
                                                       pAppDomain, 
                                                       event);
}

HRESULT Cordb::GetFirstContinuationEvent(CordbProcess *process, 
                                         DebuggerIPCEvent *event)
{
    return m_rcEventThread->ReadRCEvent(process,
                                        event);
}

HRESULT Cordb::GetNextContinuationEvent(CordbProcess *process, 
                                        DebuggerIPCEvent *event)
{
    _ASSERTE( event->next != NULL );
    if ( event->next == NULL)
        return E_FAIL;
        
    m_rcEventThread->CopyRCEvent((BYTE*)event->next, (BYTE*)event);

    return S_OK;
}

HRESULT Cordb::GetCorRuntimeHost(ICorRuntimeHost **ppHost)
{
    // If its already created, pass it out with an extra reference.
    if (m_pCorHost != NULL)
    {
        m_pCorHost->AddRef();
        *ppHost = m_pCorHost;
        return S_OK;
    }

    // Create the cor host.
    HRESULT hr = CoCreateInstance(CLSID_CorRuntimeHost,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_ICorRuntimeHost,
                                  (void**)&m_pCorHost);

    if (SUCCEEDED(hr))
    {
        // Start it up.
        hr = m_pCorHost->Start();

        if (SUCCEEDED(hr))
        {
            *ppHost = m_pCorHost;

            // Keep a ref for ourselves.
            m_pCorHost->AddRef();
        }
        else
        {
            m_pCorHost->Release();
            m_pCorHost = NULL;
        }
    }

    return hr;
}

HRESULT Cordb::GetCorDBPrivHelper(ICorDBPrivHelper **ppHelper)
{
    ICorRuntimeHost *pCorHost;

    HRESULT hr = GetCorRuntimeHost(&pCorHost);

    if (SUCCEEDED(hr))
    {
        hr = pCorHost->QueryInterface(IID_ICorDBPrivHelper,
                                      (void**)ppHelper);

        pCorHost->Release();
    }

    return hr;
}

//-----------------------------------------------------------
// ICorDebug
//-----------------------------------------------------------

// Set the handler for callbacks on managed events
// This can not be NULL.
HRESULT Cordb::SetManagedHandler(ICorDebugManagedCallback *pCallback)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    if (!m_initialized)
        return E_FAIL;

    VALIDATE_POINTER_TO_OBJECT(pCallback, ICorDebugManagedCallback*);
    
    if (m_managedCallback)
        m_managedCallback->Release();
    
    m_managedCallback = pCallback;

    if (m_managedCallback != NULL)
        m_managedCallback->AddRef();
    
    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT Cordb::SetUnmanagedHandler(ICorDebugUnmanagedCallback *pCallback)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    if (!m_initialized)
        return E_FAIL;

    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pCallback, ICorDebugUnmanagedCallback*);
    
    if (m_unmanagedCallback)
        m_unmanagedCallback->Release();
    
    m_unmanagedCallback = pCallback;

    if (m_unmanagedCallback != NULL)
    {
        m_unmanagedCallback->AddRef();

        // There is a crazy problem on Win98 with VS7 where they may do a CreateProcess with Win32 attach, but not
        // register a handler yet. So we need to block before sending any unamanged events out. This will release us if
        // we're blocking.
        SetEvent(m_crazyWin98WorkaroundEvent);
    }

    return S_OK;
#endif //RIGHT_SIDE_ONLY        
}

HRESULT Cordb::CreateProcess(LPCWSTR lpApplicationName,
                             LPWSTR lpCommandLine,
                             LPSECURITY_ATTRIBUTES lpProcessAttributes,
                             LPSECURITY_ATTRIBUTES lpThreadAttributes,
                             BOOL bInheritHandles,
                             DWORD dwCreationFlags,
                             PVOID lpEnvironment,
                             LPCWSTR lpCurrentDirectory,
                             LPSTARTUPINFOW lpStartupInfo,
                             LPPROCESS_INFORMATION lpProcessInformation,
                             CorDebugCreateProcessFlags debuggingFlags,
                             ICorDebugProcess **ppProcess)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    _ASSERTE(lpCommandLine == NULL || 
        IsBadWritePtr(lpCommandLine, sizeof(WCHAR) * (wcslen(lpCommandLine) + 1)) == FALSE);

    VALIDATE_POINTER_TO_OBJECT(ppProcess, ICorDebugProcess**);

    if (!m_initialized)
        return E_FAIL;

    // No interop on Win9x
    if (RunningOnWin95() && 
        ((dwCreationFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)) != 0))
        return CORDBG_E_INTEROP_NOT_SUPPORTED;


    // Check that we can even accept another debuggee before trying anything.
    if (!AllowAnotherProcess())
    {
        return CORDBG_E_TOO_MANY_PROCESSES;
    }
            
    HRESULT hr = S_OK;
    
    hr = m_win32EventThread->SendCreateProcessEvent(lpApplicationName,
                                                    lpCommandLine,
                                                    lpProcessAttributes,
                                                    lpThreadAttributes,
                                                    bInheritHandles,
                                                    dwCreationFlags,
                                                    lpEnvironment,
                                                    lpCurrentDirectory,
                                                    lpStartupInfo,
                                                    lpProcessInformation,
                                                    debuggingFlags);

    if (SUCCEEDED(hr))
    {
        LockProcessList();
        CordbProcess *process = (CordbProcess*) m_processes.GetBase(
                                          lpProcessInformation->dwProcessId);
        UnlockProcessList();

        _ASSERTE(process != NULL);

        *ppProcess = (ICorDebugProcess*) process;
        (*ppProcess)->AddRef();

        // also indicate that this process was started under the debugger 
        // as opposed to attaching later.
        process->m_attached = false;
    }

    return hr;
#endif //RIGHT_SIDE_ONLY        
}

HRESULT Cordb::DebugActiveProcess(DWORD processId,
                                  BOOL win32Attach,
                                  ICorDebugProcess **ppProcess)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    if (!m_initialized)
        return E_FAIL;

    VALIDATE_POINTER_TO_OBJECT(ppProcess, ICorDebugProcess **);

    // Check that we can even accept another debuggee before trying anything.
    if (!AllowAnotherProcess())
    {
        return CORDBG_E_TOO_MANY_PROCESSES;
    }

    if (RunningOnWin95() && win32Attach)
        return CORDBG_E_INTEROP_NOT_SUPPORTED;
            
    HRESULT hr =
        m_win32EventThread->SendDebugActiveProcessEvent(processId,
                                                        win32Attach == TRUE,
                                                        NULL);

    // If that worked, then there will be a process object...
    if (SUCCEEDED(hr))
    {
        LockProcessList();
        CordbProcess* process =
            (CordbProcess*) m_processes.GetBase(processId);
        UnlockProcessList();

        _ASSERTE(process != NULL);

        // If the process was already setup for attach, then we go
        // ahead and send the attach event and wait for the resulting
        // events to come in. However, if the process wasn't setup for
        // attach, then it may not have entered managed code yet, so
        // we simply wait for the normal sequence of events to occur,
        // as if we created the process.
        if (process->m_sendAttachIPCEvent)
        {
            // If we're Win32 attaching, wait for the CreateProcess
            // event to come in so we know we're really Win32 attached
            // to the process before proceeding.
            if (win32Attach)
            {
                DWORD ret = WaitForSingleObject(process->m_miscWaitEvent,
                                                INFINITE);

                if (ret != WAIT_OBJECT_0)
                    return HRESULT_FROM_WIN32(GetLastError());
            }

            DebuggerIPCEvent *event =
                (DebuggerIPCEvent*) _alloca(CorDBIPC_BUFFER_SIZE);
            process->InitIPCEvent(event, 
                                  DB_IPCE_ATTACHING, 
                                  false,
                                  NULL);

            LOG((LF_CORDB, LL_INFO1000, "[%x] CP::S: sending attach.\n",
                 GetCurrentThreadId()));

            hr = SendIPCEvent(process, event, CorDBIPC_BUFFER_SIZE);

            LOG((LF_CORDB, LL_INFO1000, "[%x] CP::S: sent attach.\n",
                 GetCurrentThreadId()));

            // Must set this after we've sent the event, as we use this flag to indicate to other parts of interop
            // debugging that we need to be able to send this event.
            process->m_sendAttachIPCEvent = false;
        }

        *ppProcess = (ICorDebugProcess*) process;
        (*ppProcess)->AddRef();

        // also indicate that this process was attached to, as  
        // opposed to being started under the debugger.
        process->m_attached = true;
    }
    
    return hr;
#endif //RIGHT_SIDE_ONLY        
}

HRESULT Cordb::GetProcess(DWORD dwProcessId, ICorDebugProcess **ppProcess)
{
#ifndef RIGHT_SIDE_ONLY
#ifdef PROFILING_SUPPORTED
    // Need to check that this thread is in a valid state for in-process debugging.
    if (!CHECK_INPROC_PROCESS_STATE())
        return (CORPROF_E_INPROC_NOT_ENABLED);
#endif // PROFILING_SUPPORTED
#endif // RIGHT_SIDE_ONLY

    if (!m_initialized)
        return E_FAIL;

    VALIDATE_POINTER_TO_OBJECT(ppProcess, ICorDebugProcess**);
            
    CordbProcess *p = (CordbProcess *) m_processes.GetBase(dwProcessId);

    if (p == NULL)
        return E_INVALIDARG;

    *ppProcess = (ICorDebugProcess*)p;
    (*ppProcess)->AddRef();

    return S_OK;
}

HRESULT Cordb::EnumerateProcesses(ICorDebugProcessEnum **ppProcesses)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    if (!m_initialized)
        return E_FAIL;

    VALIDATE_POINTER_TO_OBJECT(ppProcesses, ICorDebugProcessEnum **);
            
    CordbHashTableEnum *e = new CordbHashTableEnum(&m_processes,
                                                   IID_ICorDebugProcessEnum);
    if (e == NULL)
        return E_OUTOFMEMORY;

    *ppProcesses = (ICorDebugProcessEnum*)e;
    e->AddRef();

    return S_OK;
#endif //RIGHT_SIDE_ONLY        
}


//
// Note: the following defs and structs are copied from various NT headers. I wasn't able to include those headers (like
// ntexapi.h) due to loads of redef problems and other conflicts with headers that we already pull in.
//
typedef LONG NTSTATUS;
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation,
    SystemProcessorInformation,             // obsolete...delete
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemFullMemoryInformation,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSummaryMemoryInformation,
    SystemMirrorMemoryInformation,
    SystemPerformanceTraceInformation,
    SystemObsolete0,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemVerifierAddDriverInformation,
    SystemVerifierRemoveDriverInformation,
    SystemProcessorIdleInformation,
    SystemLegacyDriverInformation,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation,
    SystemTimeSlipNotification,
    SystemSessionCreate,
    SystemSessionDetach,
    SystemSessionInformation,
    SystemRangeStartInformation,
    SystemVerifierInformation,
    SystemVerifierThunkExtend,
    SystemSessionProcessInformation,
    SystemLoadGdiDriverInSystemSpace,
    SystemNumaProcessorMap,
    SystemPrefetcherInformation,
    SystemExtendedProcessInformation,
    SystemRecommendedSharedDataAlignment,
    SystemComPlusPackage,
    SystemNumaAvailableMemory,
    SystemProcessorPowerInformation,
    SystemEmulationBasicInformation,
    SystemEmulationProcessorInformation
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef BOOL (*NTQUERYSYSTEMINFORMATION)(SYSTEM_INFORMATION_CLASS SystemInformationClass,
                                         PVOID SystemInformation,
                                         ULONG SystemInformationLength,
                                         PULONG ReturnLength);

HRESULT Cordb::CanLaunchOrAttach(DWORD dwProcessId, BOOL win32DebuggingEnabled)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    if (!m_initialized)
        return E_FAIL;

    if (!AllowAnotherProcess())
        return CORDBG_E_TOO_MANY_PROCESSES;

    // Don't allow interop on a win9x platform
    if (RunningOnWin95() && win32DebuggingEnabled)
        return CORDBG_E_INTEROP_NOT_SUPPORTED;

    // Right now, the only thing we know that would prevent a launch or attach is if a kernel debugger is installed on
    // the machine. We can only check this on NT, and it doesn't matter if we're doing an interop attach. If we're not
    // on NT, then we're going to assume the best.
    if (win32DebuggingEnabled)
        return S_OK;

    if (!m_runningOnNT)
        return S_OK;

    // Find ntdll.dll
	HMODULE hModNtdll = WszGetModuleHandle(L"ntdll.dll");

	if (!hModNtdll)
    {
		return S_OK;
	}

    // Find NtQuerySystemInformation... it won't exist on Win9x.
	NTQUERYSYSTEMINFORMATION ntqsi = (NTQUERYSYSTEMINFORMATION) GetProcAddress(hModNtdll, "NtQuerySystemInformation");

	if (!ntqsi)
    {
		return S_OK;
	}

    // Grab the kernel debugger information.
    SYSTEM_KERNEL_DEBUGGER_INFORMATION skdi;
    skdi.KernelDebuggerEnabled = FALSE;
    skdi.KernelDebuggerNotPresent = FALSE;
    
    NTSTATUS status = ntqsi(SystemKernelDebuggerInformation, &skdi, sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION), NULL);

    if (NT_SUCCESS(status))
    {
        if (skdi.KernelDebuggerEnabled)
        {
            if (skdi.KernelDebuggerNotPresent)
                return CORDBG_E_KERNEL_DEBUGGER_ENABLED;
            else
                return CORDBG_E_KERNEL_DEBUGGER_PRESENT;
        }
    }
    
    return S_OK;
#endif //RIGHT_SIDE_ONLY        
}

DWORD MetadataPointerCache::dwInsert(DWORD dwProcessId, PVOID pRemoteMetadataPtr, PBYTE pLocalMetadataPtr, DWORD dwMetadataSize)
{
    MetadataCache * pMetadataCache = new MetadataCache;

    if (!pMetadataCache)
    {
        return E_OUTOFMEMORY;
    }

    memset(pMetadataCache, 0, sizeof(MetadataCache));

    pMetadataCache->pRemoteMetadataPtr = pRemoteMetadataPtr;
    pMetadataCache->pLocalMetadataPtr = pLocalMetadataPtr;
    pMetadataCache->dwProcessId = dwProcessId;
    pMetadataCache->dwRefCount = 1;
    pMetadataCache->dwMetadataSize = dwMetadataSize;
    pMetadataCache->pNext = m_pHead;
    
    m_pHead = pMetadataCache;
    return S_OK;
}

BOOL MetadataPointerCache::bFindMetadataCache(DWORD dwProcessId, PVOID pKey, MetadataCache *** pppNext, BOOL bRemotePtr)
{
    MetadataCache ** ppNext = &m_pHead;
    MetadataCache * pMetadataCache;

    while(*ppNext != NULL)
    {
        pMetadataCache = *ppNext;
        
        _ASSERTE(pMetadataCache);
        _ASSERTE(pMetadataCache->pRemoteMetadataPtr);
        _ASSERTE(pMetadataCache->pLocalMetadataPtr);
        _ASSERTE(pMetadataCache->dwRefCount);
        
        if (bRemotePtr ? 
            pMetadataCache->pRemoteMetadataPtr == pKey : 
            pMetadataCache->pLocalMetadataPtr == pKey)
        {
            if (dwProcessId == pMetadataCache->dwProcessId)
            {
                *pppNext = ppNext;
                return true;
            }
        }

        ppNext = &pMetadataCache->pNext;
    }

    *pppNext = NULL;
    
    return false;
}

void MetadataPointerCache::vRemoveNode(MetadataCache **ppNext)
{
    MetadataCache * pMetadataCache = *ppNext;

    _ASSERTE(pMetadataCache);
    *ppNext = pMetadataCache->pNext;

    _ASSERTE(pMetadataCache->pLocalMetadataPtr);
    delete pMetadataCache->pLocalMetadataPtr;

    delete pMetadataCache;
}
 
MetadataPointerCache::MetadataPointerCache()
{
    m_pHead = NULL;
}

void MetadataPointerCache::Neuter()
{
    while(m_pHead != NULL)
    {
        vRemoveNode(&m_pHead);
    }
    _ASSERTE(m_pHead == NULL);
}

BOOL MetadataPointerCache::IsEmpty()
{
    return m_pHead== NULL;
}

MetadataPointerCache::~MetadataPointerCache()
{
    Neuter();
}

DWORD MetadataPointerCache::CopyRemoteMetadata(
    HANDLE hProcess, PVOID pRemoteMetadataPtr, DWORD dwMetadataSize, PBYTE* ppLocalMetadataPtr)
{
    // Allocate space for the local copy of the metadata
    PBYTE pLocalMetadataPtr = new BYTE[dwMetadataSize];
    
    if (pLocalMetadataPtr == NULL)
    {
        *ppLocalMetadataPtr = NULL;
        return E_OUTOFMEMORY;
    }
    
    memset(pLocalMetadataPtr, 0, dwMetadataSize);

    // Copy the metadata from the left side
    BOOL succ;
    succ = ReadProcessMemoryI(hProcess,
                              pRemoteMetadataPtr,
                              pLocalMetadataPtr,
                              dwMetadataSize,
                              NULL);
                              
    if (!succ)
    {
        *ppLocalMetadataPtr = NULL;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *ppLocalMetadataPtr = pLocalMetadataPtr;
    return S_OK;
}

DWORD MetadataPointerCache::AddRefCachePointer(HANDLE hProcess, DWORD dwProcessId, 
                                                PVOID pRemoteMetadataPtr, DWORD dwMetadataSize, PBYTE* ppLocalMetadataPtr)
{
    _ASSERTE(pRemoteMetadataPtr && dwMetadataSize && ppLocalMetadataPtr);

    *ppLocalMetadataPtr = NULL;
     
    MetadataCache ** ppNext = NULL;   

    BOOL bHit = bFindMetadataCache(dwProcessId, pRemoteMetadataPtr, &ppNext, true);
    DWORD dwErr;
    
    if (bHit)
    {
        // Cache hit case:
        MetadataCache* pMetadataCache = *ppNext;
        
        _ASSERTE(pMetadataCache);
        _ASSERTE(pMetadataCache->dwMetadataSize == dwMetadataSize);
        _ASSERTE(pMetadataCache->dwProcessId == dwProcessId);
        _ASSERTE(pMetadataCache->pLocalMetadataPtr);
        
        pMetadataCache->dwRefCount++;

        *ppLocalMetadataPtr = pMetadataCache->pLocalMetadataPtr;
        return S_OK;
    }
    else
    {
        // Cache miss case:
        PBYTE pLocalMetadataPtr = NULL;

        dwErr = CopyRemoteMetadata(hProcess, pRemoteMetadataPtr, dwMetadataSize, &pLocalMetadataPtr);
        if (SUCCEEDED(dwErr))
        {
            dwErr = dwInsert(dwProcessId, pRemoteMetadataPtr, pLocalMetadataPtr, dwMetadataSize);
            if (SUCCEEDED(dwErr))
            {
                *ppLocalMetadataPtr = pLocalMetadataPtr;
                return S_OK;                    
            }
        }
    }

    _ASSERTE(!ppLocalMetadataPtr);

    return dwErr;
}

void MetadataPointerCache::ReleaseCachePointer(DWORD dwProcessId, PBYTE pLocalMetadataPtr, PVOID pRemotePtr, DWORD dwMetadataSize)
{
    _ASSERTE(pLocalMetadataPtr);

    MetadataCache ** ppNext;
    MetadataCache * pMetadataCache;
    BOOL bCacheHit = bFindMetadataCache(dwProcessId, pLocalMetadataPtr, &ppNext, false);

    // If Release is called then there should be an entry in the the cache to release.
    _ASSERTE(bCacheHit);
    _ASSERTE(ppNext);

    pMetadataCache = *ppNext;
    _ASSERT(pMetadataCache); // The pNext pointer shouldn't be NULL
    _ASSERT(pMetadataCache->pLocalMetadataPtr == pLocalMetadataPtr); // We used the local pointer to look up the entry
    _ASSERT(pMetadataCache->dwRefCount); // The refCount should be > 0 if we are releasing it
    _ASSERT(pMetadataCache->pRemoteMetadataPtr == pRemotePtr); // The remote metadata pointer should match
    _ASSERT(pMetadataCache->dwMetadataSize == dwMetadataSize); // The user should also know the size

    pMetadataCache->dwRefCount--;

    if(0 == pMetadataCache->dwRefCount)
    {
        // If the refcount hits zero remove the node and free the local copy of the metadata
        // and the node in the hashtable.
        vRemoveNode(ppNext);
    }
}

/* ------------------------------------------------------------------------- *
 * Process class
 * ------------------------------------------------------------------------- */
    
CordbProcess::CordbProcess(Cordb* cordb, DWORD processID, HANDLE handle)
  : CordbBase(processID, enumCordbProcess), m_cordb(cordb), m_handle(handle),
    m_attached(false), m_detached(false), m_uninitializedStop(false), m_synchronized(false),
    m_createing(false), m_exiting(false), m_terminated(false), 
    m_firstExceptionHandled(false),
    m_firstManagedEvent(false), m_specialDeferment(false),
    m_helperThreadDead(false),
    m_loaderBPReceived(false),
    m_unrecoverableError(false), m_sendAttachIPCEvent(false),
    m_userThreads(11), 
    m_unmanagedThreads(11), 
    m_appDomains(11),
    m_steppers(11),
    m_continueCounter(1),
    m_EnCCounter(1), //set to 1 so that functions can start at zero
    m_DCB(NULL),
    m_leftSideEventAvailable(NULL),
    m_leftSideEventRead(NULL),
    m_rightSideEventAvailable(NULL),
    m_rightSideEventRead(NULL),
    m_leftSideUnmanagedWaitEvent(NULL),
    m_syncThreadIsLockFree(NULL),
    m_SetupSyncEvent(NULL),    
    m_initialized(false),
    m_queuedEventList(NULL),
    m_lastQueuedEvent(NULL),
    m_dispatchingEvent(false),
    m_stopRequested(false),
    m_stopWaitEvent(NULL),
    m_miscWaitEvent(NULL),
    m_debuggerAttachedEvent(NULL),
    m_unmanagedEventQueue(NULL),
    m_lastQueuedUnmanagedEvent(NULL),
    m_lastIBStoppingEvent(NULL),
    m_outOfBandEventQueue(NULL),
    m_lastQueuedOOBEvent(NULL),
    m_dispatchingUnmanagedEvent(false),
    m_dispatchingOOBEvent(false),
    m_doRealContinueAfterOOBBlock(false),
    m_deferContinueDueToOwnershipWait(false),
    m_helperThreadId(0),
    m_state(0),
    m_awaitingOwnershipAnswer(0),
#ifdef _DEBUG
    m_processMutexOwner(0),
    m_processMutexRecursionCount(0),
#endif
    m_pPatchTable(NULL),
    m_minPatchAddr(MAX_ADDRESS),
    m_maxPatchAddr(MIN_ADDRESS),
    m_iFirstPatch(0),
    m_rgNextPatch(NULL),
    m_rgData(NULL),
    m_cPatch(0),
    m_rgUncommitedOpcode(NULL),
    // EnC stuff
    m_pbRemoteBuf(NULL),
    m_cbRemoteBuf(0),
    m_pSnapshotInfos(NULL),
    m_stopCount(0),
    m_syncCompleteReceived(false),
    m_oddSync(false)
{
#ifndef RIGHT_SIDE_ONLY
    m_appDomains.m_guid = IID_ICorDebugAppDomainEnum;
    m_appDomains.m_creator.lsAppD.m_proc = this;

    m_userThreads.m_guid = IID_ICorDebugThreadEnum;
    m_userThreads.m_creator.lsThread.m_proc = this;
#endif //RIGHT_SIDE_ONLY
}

/*
    A list of which resources owened by this object are accounted for.

    UNKNOWN
        Cordb*                      m_cordb;  
        CordbHashTable              m_unmanagedThreads; // Released in CordbProcess but not removed from hash
        DebuggerIPCControlBlock     *m_DCB;
        DebuggerIPCEvent*           m_lastQueuedEvent; 
        
        // CordbUnmannagedEvent is a struct which is not derrived from CordbBase.
        // It contains a CordbUnmannagedThread which may need to be released.
        CordbUnmanagedEvent         *m_unmanagedEventQueue;
        CordbUnmanagedEvent         *m_lastQueuedUnmanagedEvent;
        CordbUnmanagedEvent         *m_lastIBStoppingEvent;
        CordbUnmanagedEvent         *m_outOfBandEventQueue;
        CordbUnmanagedEvent         *m_lastQueuedOOBEvent;

        BYTE*                       m_pPatchTable;
        BYTE                        *m_rgData;
        void                        *m_pbRemoteBuf;
        UnorderedSnapshotInfoArray  *m_pSnapshotInfos;
        
   RESOLVED
        // Nutered
        CordbHashTable        m_userThreads;
        CordbHashTable        m_appDomains;        

        // Cleaned up in ExitProcess
        HANDLE                m_SetupSyncEvent; 
        DebuggerIPCEvent*     m_queuedEventList; 
        
        CordbHashTable        m_steppers; // Closed in ~CordbProcess

        // Closed in CloseIPCEventHandles called from ~CordbProcess
        HANDLE                m_leftSideEventAvailable;         
        HANDLE                m_leftSideEventRead; 

        // Closed in ~CordbProcess
        HANDLE                m_handle; 
        HANDLE                m_rightSideEventAvailable;
        HANDLE                m_rightSideEventRead;
        HANDLE                m_leftSideUnmanagedWaitEvent;
        HANDLE                m_syncThreadIsLockFree;
        HANDLE                m_stopWaitEvent;
        HANDLE                m_miscWaitEvent;
        HANDLE                m_debuggerAttachedEvent;

        // Deleted in ~CordbProcess
        CRITICAL_SECTION      m_processMutex;
        CRITICAL_SECTION      m_sendMutex;
*/

CordbProcess::~CordbProcess()
{
    CordbBase* entry;
    HASHFIND find;
    
#ifdef _DEBUG
    _ASSERTE(!m_cordb->m_processes.GetBase(m_id));
#endif
    
    LOG((LF_CORDB, LL_INFO1000, "[%x]CP::~CP: deleting process 0x%08x\n", 
         GetCurrentThreadId(), this));

#ifdef RIGHT_SIDE_ONLY
	CordbProcess::CloseIPCHandles();
    if (m_rightSideEventAvailable != NULL)
    {
    	CloseHandle(m_rightSideEventAvailable);
        m_rightSideEventAvailable = NULL;
   	}

    if (m_rightSideEventRead != NULL)
    {
    	CloseHandle(m_rightSideEventRead);
        m_rightSideEventRead = NULL;
    }

    if (m_leftSideUnmanagedWaitEvent != NULL)
    {
    	CloseHandle(m_leftSideUnmanagedWaitEvent);
        m_leftSideUnmanagedWaitEvent = NULL;
   	}

    if (m_syncThreadIsLockFree != NULL)
    {
    	CloseHandle(m_syncThreadIsLockFree);
        m_syncThreadIsLockFree = NULL;
   	}

    if (m_stopWaitEvent != NULL)
    {
    	CloseHandle(m_stopWaitEvent);
        m_stopWaitEvent = NULL;
   	}

    if (m_miscWaitEvent != NULL)
    {
    	CloseHandle(m_miscWaitEvent);
        m_miscWaitEvent = NULL;
   	}

    if (m_debuggerAttachedEvent != NULL)
    {
    	CloseHandle(m_debuggerAttachedEvent);
        m_debuggerAttachedEvent = NULL;
   	}

    //
    // Disconnect any active steppers
    //
    for (entry =  m_steppers.FindFirst(&find);
         entry != NULL;
         entry =  m_steppers.FindNext(&find))
    {
        CordbStepper *stepper = (CordbStepper*) entry;
        stepper->Disconnect();
    }

#endif //RIGHT_SIDE_ONLY

    ClearPatchTable();
    
    DeleteCriticalSection(&m_processMutex);
    DeleteCriticalSection(&m_sendMutex);

    if (m_handle != NULL)
        CloseHandle(m_handle);

    if (m_pSnapshotInfos)
    {
        delete m_pSnapshotInfos;
        m_pSnapshotInfos = NULL;
    }

    // Delete any left over unmanaged thread objects. There are a
    // number of cases where the OS doesn't send us all of the proper
    // exit thread events.
    for (entry =  m_unmanagedThreads.FindFirst(&find);
         entry != NULL;
         entry =  m_unmanagedThreads.FindNext(&find))
    {
        CordbUnmanagedThread* ut = (CordbUnmanagedThread*) entry;
        ut->Release();
    }
}

// Neutered when process dies
void CordbProcess::Neuter()
{
    AddRef();
    {        
        NeuterAndClearHashtable(&m_userThreads);
        NeuterAndClearHashtable(&m_appDomains);

        CordbBase::Neuter();
    }        
    Release();
}

void CordbProcess::CloseIPCHandles(void)
{
	// Close off Right Side's IPC handles.

    if (m_leftSideEventAvailable != NULL)
    {
        CloseHandle(m_leftSideEventAvailable);
        m_leftSideEventAvailable = NULL;
	}
	
    if (m_leftSideEventRead != NULL)
	{
		CloseHandle(m_leftSideEventRead);
        m_leftSideEventRead = NULL;
	}
}

//
// Init -- create any objects that the process object needs to operate.
// Currently, this is just a few events.
//
HRESULT CordbProcess::Init(bool win32Attached)
{
    HRESULT hr = S_OK;
    BOOL succ = TRUE;
#ifdef RIGHT_SIDE_ONLY
    WCHAR tmpName[256];
#endif //RIGHT_SIDE_ONLY    

    if (win32Attached)
        m_state |= PS_WIN32_ATTACHED;
    
    IPCWriterInterface *pIPCManagerInterface = new IPCWriterInterface();

    if (pIPCManagerInterface == NULL)
        return (E_OUTOFMEMORY);

    hr = pIPCManagerInterface->Init();

    if (FAILED(hr))
        return (hr);
        
    InitializeCriticalSection(&m_processMutex);
    InitializeCriticalSection(&m_sendMutex);

    // Grab the security attributes that we'll use to create kernel objects for the target process.
    SECURITY_ATTRIBUTES *pSA = NULL;

    hr = pIPCManagerInterface->GetSecurityAttributes(m_id, &pSA);

    if (FAILED(hr))
        return hr;
    
    //
    // Setup events needed by the left side to send the right side an event.
    //
#ifdef RIGHT_SIDE_ONLY
    // Are we running as a TS client? If so, then we'll need to create
    // our named events a little differently...
    //
    // PERF: We are no longer calling GetSystemMetrics in an effort to prevent
    //       superfluous DLL loading on startup.  Instead, we're prepending
    //       "Global\" to named kernel objects if we are on NT5 or above.  The
    //       only bad thing that results from this is that you can't debug
    //       cross-session on NT4.  Big bloody deal.
    if (RunningOnWinNT5())
        swprintf(tmpName, L"Global\\" CorDBIPCLSEventAvailName, m_id);
    else
        swprintf(tmpName, CorDBIPCLSEventAvailName, m_id);

    m_leftSideEventAvailable = WszCreateEvent(pSA, FALSE, FALSE, tmpName);
    
    if (m_leftSideEventAvailable == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        goto exit;
    }

    // IMPORTANT: The existence of this event determines whether or not
    // another debugger has attached to this process.  I assume that this
    // event is destroyed on a detach, so this shouldn't screw up a
    // reattach.  I'm picking this because it's early enough in the init
    // to make backing out easy.
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        hr = CORDBG_E_DEBUGGER_ALREADY_ATTACHED;

        goto exit;
    }
    
    if (RunningOnWinNT5())
        swprintf(tmpName, L"Global\\" CorDBIPCLSEventReadName, m_id);
    else
        swprintf(tmpName, CorDBIPCLSEventReadName, m_id);

    m_leftSideEventRead = WszCreateEvent(pSA, FALSE, FALSE, tmpName);
    
    if (m_leftSideEventRead == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    _ASSERTE(GetLastError() != ERROR_ALREADY_EXISTS);
    
    // Note: this one is only temporary. We would have rather added this event into the DCB or into the RuntimeOffsets
    // but we can't without that being a breaking change at this point (Fri Jul 13 15:17:20 2001). So we're using a
    // named event for now, and next time we change the struct we'll put it back in. Also note that we don't really care
    // if we don't get this event. The event is used to relieve a race during interop attach, and it was added very late
    // in RTM. If we required this event, it would be a breaking change. So we get it if we can, and we use it if we
    // can. If we can't, then we're no worse off than we were before this fix.
    if (RunningOnWinNT5())
        swprintf(tmpName, L"Global\\" CorDBDebuggerAttachedEvent, m_id);
    else
        swprintf(tmpName, CorDBDebuggerAttachedEvent, m_id);

    m_debuggerAttachedEvent = WszCreateEvent(pSA, TRUE, FALSE, tmpName);

    
    NAME_EVENT_BUFFER;
    m_stopWaitEvent = WszCreateEvent(NULL, TRUE, FALSE, NAME_EVENT(L"StopWaitEvent"));
    if (m_stopWaitEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    m_miscWaitEvent = WszCreateEvent(NULL, FALSE, FALSE, NAME_EVENT(L"MiscWaitEvent"));
    if (m_miscWaitEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    //
    // Duplicate our own copy of the process's handle because the handle
    // we've got right now is also passed back to the caller of CreateProcess
    // in the process info structure, and they're supposed to be able to
    // close that handle whenever they want to. 
    
    HANDLE tmpHandle;
    
    succ = DuplicateHandle(GetCurrentProcess(),
                           m_handle,
                           GetCurrentProcess(),
                           &tmpHandle,
                           NULL,
                           FALSE,
                           DUPLICATE_SAME_ACCESS);

    if (!succ)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    m_handle = tmpHandle;

    // Attempt to create the Setup Sync event.
    if (RunningOnWinNT5())
        swprintf(tmpName, L"Global\\" CorDBIPCSetupSyncEventName, m_id);
    else
        swprintf(tmpName, CorDBIPCSetupSyncEventName, m_id);
    
    LOG((LF_CORDB, LL_INFO10000,
         "CP::I: creating setup sync event with name [%S]\n", tmpName));
    
    m_SetupSyncEvent = WszCreateEvent(pSA, TRUE, FALSE, tmpName);

    if (m_SetupSyncEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // If the event already exists, then the Left Side has already
        // setup the shared memory.
        LOG((LF_CORDB, LL_INFO10000, "CP::I: setup sync event already exists.\n"));

        // Wait for the Setup Sync event before continuing. This
        // ensures that the Left Side is finished setting up the
        // control block.
        DWORD ret = WaitForSingleObject(m_SetupSyncEvent, INFINITE);

        if (ret != WAIT_OBJECT_0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        // We no longer need this event now.
        CloseHandle(m_SetupSyncEvent);
        m_SetupSyncEvent = NULL;

        hr = m_IPCReader.OpenPrivateBlockOnPid(m_id);
        if (!SUCCEEDED(hr))
        {            
            goto exit;
        }

        m_DCB = m_IPCReader.GetDebugBlock();

#else
        _ASSERTE( g_pRCThread != NULL ); // the Debugger part of the EE had better be 
            // initialized already
        m_DCB = g_pRCThread->GetInprocControlBlock();

        // The same-process structures should not exist
        _ASSERTE(m_DCB->m_leftSideEventAvailable == NULL);
        _ASSERTE(m_DCB->m_leftSideEventRead == NULL);
        _ASSERTE(m_rightSideEventRead == NULL);
        _ASSERTE(m_rightSideEventAvailable == NULL);
        _ASSERTE(m_DCB->m_leftSideUnmanagedWaitEvent == NULL);
        _ASSERTE(m_DCB->m_syncThreadIsLockFree == NULL);
        
#endif //RIGHT_SIDE_ONLY    
        
        if (m_DCB == NULL)
        {
            hr = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

#ifdef RIGHT_SIDE_ONLY
        // Verify that the control block is valid.
        hr = VerifyControlBlock();

        if (FAILED(hr))
            goto exit;

        // Dup LSEA and LSER into the remote process.
        succ = DuplicateHandle(GetCurrentProcess(),
                               m_leftSideEventAvailable,
                               m_handle,
                               &(m_DCB->m_leftSideEventAvailable),
                               NULL, FALSE, DUPLICATE_SAME_ACCESS);
        if (!succ)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        succ = DuplicateHandle(GetCurrentProcess(),
                               m_leftSideEventRead,
                               m_handle,
                               &(m_DCB->m_leftSideEventRead),
                               NULL, FALSE, DUPLICATE_SAME_ACCESS);

        if (!succ)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        // Dup our own process handle into the remote process.
        succ = DuplicateHandle(GetCurrentProcess(),
                               GetCurrentProcess(),
                               m_handle,
                               &(m_DCB->m_rightSideProcessHandle),
                               NULL, FALSE, DUPLICATE_SAME_ACCESS);

        if (!succ)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        // Dup RSEA and RSER into this process.
        succ = DuplicateHandle(m_handle,
                               m_DCB->m_rightSideEventAvailable,
                               GetCurrentProcess(),
                               &m_rightSideEventAvailable,
                               NULL, FALSE, DUPLICATE_SAME_ACCESS);

        if (!succ)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        succ = DuplicateHandle(m_handle,
                               m_DCB->m_rightSideEventRead,
                               GetCurrentProcess(),
                               &m_rightSideEventRead,
                               NULL, FALSE, DUPLICATE_SAME_ACCESS);

        if (!succ)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        succ = DuplicateHandle(m_handle,
                               m_DCB->m_leftSideUnmanagedWaitEvent,
                               GetCurrentProcess(),
                               &m_leftSideUnmanagedWaitEvent,
                               NULL, FALSE, DUPLICATE_SAME_ACCESS);

        if (!succ)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }
        
        succ = DuplicateHandle(m_handle,
                               m_DCB->m_syncThreadIsLockFree,
                               GetCurrentProcess(),
                               &m_syncThreadIsLockFree,
                               NULL, FALSE, DUPLICATE_SAME_ACCESS);

        if (!succ)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }
        
#endif //RIGHT_SIDE_ONLY        

        m_sendAttachIPCEvent = true;

        m_DCB->m_rightSideIsWin32Debugger = win32Attached;

#ifndef RIGHT_SIDE_ONLY
        _ASSERTE( !win32Attached );
#endif //RIGHT_SIDE_ONLY
#ifdef RIGHT_SIDE_ONLY
        
        // At this point, the control block is complete and all four
        // events are available and valid for the remote process.
    }
    else
    {
        // If the event was created by us, then we need to signal
        // its state. The fields in the shared mem which need to be
        // filled out by us will be done upon receipt of the first
        // event from the LHS
        LOG((LF_CORDB, LL_INFO10000, "DRCT::I: setup sync event was created.\n"));
        
        // Set the Setup Sync event 
        SetEvent(m_SetupSyncEvent);
    }
#endif //RIGHT_SIDE_ONLY    

    m_pSnapshotInfos = new UnorderedSnapshotInfoArray();
    if (NULL == m_pSnapshotInfos)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

exit:
    if (pSA != NULL)
        pIPCManagerInterface->DestroySecurityAttributes(pSA);
    
    if (pIPCManagerInterface != NULL)
    {
        pIPCManagerInterface->Terminate();
        delete pIPCManagerInterface;
    }

    if (FAILED(hr))
    {
        if (m_leftSideEventAvailable)
        {
            CloseHandle(m_leftSideEventAvailable);
            m_leftSideEventAvailable = NULL;
        }
    }

    return hr;
}


#ifndef RIGHT_SIDE_ONLY

// Spliced here so we don't have include EnC.cpp in the left side build process

COM_METHOD CordbProcess::CanCommitChanges(ULONG cSnapshots, 
                ICorDebugEditAndContinueSnapshot *pSnapshots[], 
                ICorDebugErrorInfoEnum **pError)
{
    return CORDBG_E_INPROC_NOT_IMPL;;
}

COM_METHOD CordbProcess::CommitChanges(ULONG cSnapshots, 
    ICorDebugEditAndContinueSnapshot *pSnapshots[], 
    ICorDebugErrorInfoEnum **pError)
{
    return CORDBG_E_INPROC_NOT_IMPL;;
}

#endif //RIGHT_SIDE_ONLY


//
// Terminating -- places the process into the terminated state. This should
// also get any blocking process functions unblocked so they'll return
// a failure code. 
//
void CordbProcess::Terminating(BOOL fDetach)
{
    LOG((LF_CORDB, LL_INFO1000,"CP::T: Terminating process %4X detach=%d\n", m_id, fDetach));
    m_terminated = true;

    m_cordb->ProcessStateChanged();

    SetEvent(m_leftSideEventRead);
    SetEvent(m_rightSideEventRead);
    SetEvent(m_leftSideEventAvailable);
    SetEvent(m_stopWaitEvent);

    if (fDetach)
    {
        // This averts a race condition wherein we'll detach, then reattach,
        // and find these events in the still-signalled state.
        ResetEvent(m_rightSideEventAvailable);
        ResetEvent(m_rightSideEventRead);
    }
}


//
// HandleManagedCreateThread processes a managed create thread debug event.
//
void CordbProcess::HandleManagedCreateThread(DWORD dwThreadId,
                                             HANDLE hThread)
{
    LOG((LF_CORDB, LL_INFO10000, "[%x] CP::HMCT: Create Thread %#x\n",
         GetCurrentThreadId(),
         dwThreadId));

    Lock();
    
    CordbThread* t = new CordbThread(this, dwThreadId, hThread);

    if (t != NULL)
    {
        HRESULT hr = m_userThreads.AddBase(t);

        if (FAILED(hr))
        {
            delete t;

            LOG((LF_CORDB, LL_INFO10000,
                 "Failed adding thread to process!\n"));
            CORDBSetUnrecoverableError(this, hr, 0);
        }
    }
    else
    {
        LOG((LF_CORDB, LL_INFO10000, "New CordbThread failed!\n"));
        CORDBSetUnrecoverableError(this, E_OUTOFMEMORY, 0);
    }

    Unlock();
}


HRESULT CordbProcess::QueryInterface(REFIID id, void **pInterface)
{
    if (id == IID_ICorDebugProcess)
        *pInterface = (ICorDebugProcess*)this;
    else if (id == IID_ICorDebugController)
        *pInterface = (ICorDebugController*)(ICorDebugProcess*)this;
    else if (id == IID_IUnknown)
        *pInterface = (IUnknown*)(ICorDebugProcess*)this;
    else
    {
        *pInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbProcess::Detach()
{
    LOG((LF_CORDB, LL_INFO1000, "CP::Detach - beginning\n"));
#ifndef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOK(this);
    
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    // A very important note: we require that the process is synchronized before doing a detach. This ensures
    // that no events are on their way from the Left Side. We also require that the user has drained the
    // managed event queue, but there is currently no way to really enforce that here.
    CORDBRequireProcessStateOKAndSync(this, NULL);

    HASHFIND hf;
    HRESULT hr = S_OK;

    // Detach from each AD before detaching from the entire process.
    CordbAppDomain *cad = (CordbAppDomain *)m_appDomains.FindFirst(&hf);

    while (cad != NULL)
    {
        hr = cad->Detach();

        if (FAILED(hr))
            return hr;
            
        cad = (CordbAppDomain *)m_appDomains.FindNext(&hf);
    }

    if (m_SetupSyncEvent != NULL)
    {
        CloseHandle(m_SetupSyncEvent);
        m_SetupSyncEvent = NULL;
    }

    // Go ahead and detach from the entire process now.
    DebuggerIPCEvent *event = (DebuggerIPCEvent*) _alloca(CorDBIPC_BUFFER_SIZE);
    InitIPCEvent(event, DB_IPCE_DETACH_FROM_PROCESS, true, (void *)m_id);

    hr = m_cordb->SendIPCEvent(this, event, CorDBIPC_BUFFER_SIZE);

	if (!FAILED(hr))
	{
		m_cordb->m_win32EventThread->SendDetachProcessEvent(this);
		CloseIPCHandles();

        // Since we're auto-continuing when we detach, we should set the stop count back to zero. This
        // prevents anyone from calling Continue on this process after this call returns.
		m_stopCount = 0;

        // Remember that we've detached from this process object. This will prevent any further operations on
        // this process, just in case... :)
        m_detached = true;
    }

    LOG((LF_CORDB, LL_INFO1000, "CP::Detach - returning w/ hr=0x%x\n", hr));
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbProcess::Terminate(unsigned int exitCode)
{
    LOG((LF_CORDB, LL_INFO1000, "CP::Terminate: with exitcode %u\n", exitCode));
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    // You must be stopped and sync'd before calling Terminate.
    CORDBRequireProcessStateOKAndSync(this, NULL);

    // When we terminate the process, it's handle will become signaled and
    // Win32 Event Thread will leap into action and call CordbWin32EventThread::ExitProcess
    // Unfortunately, that may destroy this object if the ExitProcess callback
    // decides to call Release() on the process.

    // Indicate that the process is exiting so that (among other things) we don't try and
    // send messages to the left side while it's being nuked.
    Lock();

    m_exiting = true;

    // Free all the remaining events
    DebuggerIPCEvent *pCur = m_queuedEventList;
    while (pCur != NULL)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::Terminate: Deleting queued event: '%s'\n", IPCENames::GetName(pCur->type)));
                    
        DebuggerIPCEvent *pDel = pCur;
        pCur = pCur->next;
        free(pDel);
    }
    m_queuedEventList = NULL;

    Unlock();
    
    
    // We'd like to just take a lock around everything here, but that may deadlock us
    // since W32ET will wait on the lock, and Continue may wait on W32ET.
    // So we just do an extra AddRef/Release to make sure we're still around

    AddRef();
    
    // Right now, we simply pass through to the Win32 terminate...
    TerminateProcess(m_handle, exitCode);
       
    // Get the process to continue automatically.
    Continue(FALSE);

    // After this release, this object may be destroyed. So don't use any member functions
    // (including Locks) after here.
    Release();

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbProcess::GetID(DWORD *pdwProcessId)
{
    VALIDATE_POINTER_TO_OBJECT(pdwProcessId, DWORD *);

    *pdwProcessId = m_id;

    return S_OK;
}

HRESULT CordbProcess::GetHandle(HANDLE *phProcessHandle)
{
    VALIDATE_POINTER_TO_OBJECT(phProcessHandle, HANDLE *);
    *phProcessHandle = m_handle;

    return S_OK;
}

HRESULT CordbProcess::IsRunning(BOOL *pbRunning)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(pbRunning, BOOL*);

    *pbRunning = !GetSynchronized();

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbProcess::EnableSynchronization(BOOL bEnableSynchronization)
{
    /* !!! */

    return E_NOTIMPL;
}

HRESULT CordbProcess::Stop(DWORD dwTimeout)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#endif
    return StopInternal(dwTimeout, NULL);
}

HRESULT CordbProcess::StopInternal(DWORD dwTimeout, void *pAppDomainToken)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    DebuggerIPCEvent* event;
    HRESULT hr = S_OK;

    LOG((LF_CORDB, LL_INFO1000, "CP::S: stopping process 0x%x(%d) with timeout %d\n", m_id, m_id,  dwTimeout));

    CORDBRequireProcessStateOK(this);
    
    Lock();
    
    // Don't need to stop if the process hasn't even executed any managed code yet.
    if (!m_initialized)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::S: process isn't initialized yet.\n"));

        // Mark the process as synchronized so no events will be dispatched until the thing is continued.
        SetSynchronized(true);

        // Remember uninitialized stop...
        m_uninitializedStop = true;

        // If we're Win32 attached, then suspend all the unmanaged threads in the process.
        if (m_state & PS_WIN32_ATTACHED)
            SuspendUnmanagedThreads(0);

        // Get the RC Event Thread to stop listening to the process.
        m_cordb->ProcessStateChanged();
        
        hr = S_OK;
        goto Exit;
    }

    // Don't need to stop if the process is already synchronized.
    if (GetSynchronized())
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::S: process was already synchronized.\n"));

        hr = S_OK;
        goto Exit;
    }

    LOG((LF_CORDB, LL_INFO1000, "CP::S: process not sync'd, requesting stop.\n"));

    m_stopRequested = true;
    Unlock();
    
    BOOL asyncBreakSent;
    
    CORDBSyncFromWin32StopIfNecessaryCheck(this, &asyncBreakSent);

    if (asyncBreakSent)
    {
        hr = S_OK;
        Lock();

        m_stopRequested = false;
        
        goto Exit;
    }

    // Send the async break event to the RC.
    event = (DebuggerIPCEvent*) _alloca(CorDBIPC_BUFFER_SIZE);
    InitIPCEvent(event, DB_IPCE_ASYNC_BREAK, false, pAppDomainToken);
    
    LOG((LF_CORDB, LL_INFO1000, "CP::S: sending async stop to appd 0x%x.\n", pAppDomainToken));

    hr = m_cordb->SendIPCEvent(this, event, CorDBIPC_BUFFER_SIZE);

    LOG((LF_CORDB, LL_INFO1000, "CP::S: sent async stop to appd 0x%x.\n", pAppDomainToken));

    // Wait for the sync complete message to come in. Note: when the sync complete message arrives to the RCEventThread,
    // it will mark the process as synchronized and _not_ dispatch any events. Instead, it will set m_stopWaitEvent
    // which will let this function return. If the user wants to process any queued events, they will need to call
    // Continue.
    LOG((LF_CORDB, LL_INFO1000, "CP::S: waiting for event.\n"));

    DWORD ret;
    ret = WaitForSingleObject(m_stopWaitEvent, dwTimeout);

    LOG((LF_CORDB, LL_INFO1000, "CP::S: got event, %d.\n", ret));

    if (m_terminated)
        return CORDBG_E_PROCESS_TERMINATED;
    
    if (ret == WAIT_OBJECT_0)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::S: process stopped.\n"));
        
        m_stopRequested = false;
        m_cordb->ProcessStateChanged();

        hr = S_OK;
        Lock();
        goto Exit;
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    // We came out of the wait, but we weren't signaled because a sync complete event came in. Re-check the process and
    // remove the stop requested flag.
    Lock();
    m_stopRequested = false;

    if (GetSynchronized())
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::S: process stopped.\n"));
        
        m_cordb->ProcessStateChanged();

        hr = S_OK;
    }

Exit:
    if (SUCCEEDED(hr))
        m_stopCount++;

    LOG((LF_CORDB, LL_INFO1000, "CP::S: returning from Stop, hr=0x%08x, m_stopCount=%d.\n", hr, m_stopCount));
    
    Unlock();
    
    return hr;
#endif //RIGHT_SIDE_ONLY    
}


void CordbProcess::MarkAllThreadsDirty(void)
{
    CordbBase* entry;
    HASHFIND find;

    Lock();
    
    for (entry =  m_userThreads.FindFirst(&find);
         entry != NULL;
         entry =  m_userThreads.FindNext(&find))
    {
        CordbThread* t = (CordbThread*) entry;
        _ASSERTE(t != NULL);

        t->MarkStackFramesDirty();
    }

    ClearPatchTable();

    Unlock();
}

HRESULT CordbProcess::Continue(BOOL fIsOutOfBand)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#endif
    return ContinueInternal(fIsOutOfBand, NULL);
}

HRESULT CordbProcess::ContinueInternal(BOOL fIsOutOfBand, void *pAppDomainToken)
{
    DebuggerIPCEvent* event;
    HRESULT hr = S_OK;

    if (m_unrecoverableError)
        return CORDBHRFromProcessState(this, NULL);

    Lock();

    LOG((LF_CORDB, LL_INFO1000, "CP::CI: continuing, fIsOutOfBand=%d, this=0x%08x\n", fIsOutOfBand, this));

    // If we're continuing from an out-of-band unmanaged event, then just go
    // ahead and get the Win32 event thread to continue the process. No other
    // work needs to be done (i.e., don't need to send a managed continue message
    // or dispatch any events) because any processing done due to the out-of-band
    // message can't alter the synchronized state of the process.
    if (fIsOutOfBand)
    {
        _ASSERTE(m_outOfBandEventQueue != NULL);
        
        // Are we calling this from the unmanaged callback?
        if (m_dispatchingOOBEvent)
        {
            LOG((LF_CORDB, LL_INFO1000, "CP::CI: continue while dispatching unmanaged out-of-band event.\n"));
        
            // Tell the Win32 event thread to continue when it returns from handling its unmanaged callback.
            m_dispatchingOOBEvent = false;

            Unlock();
        }
        else
        {
            LOG((LF_CORDB, LL_INFO1000, "CP::CI: continue outside of dispatching.\n"));
        
            Unlock();
            
            // Send an event to the Win32 event thread to do the continue. This is an out-of-band continue.
            hr = m_cordb->m_win32EventThread->SendUnmanagedContinue(this, false, true);
        }

        return hr;
    }
    
    _ASSERTE(fIsOutOfBand == FALSE);

    // If we've got multiple Stop calls, we need a Continue for each one. So, if the stop count > 1, just go ahead and
    // return without doing anything. Note: this is only for in-band or managed events. OOB events are still handled as
    // normal above.
    _ASSERTE(m_stopCount > 0);

    if (m_stopCount == 0)
        return CORDBG_E_SUPERFLOUS_CONTINUE;
    
    m_stopCount--;

    // We give managed events priority over unmanaged events. That way, the entire queued managed state can drain before
    // we let any other unmanaged events through.

    // If we're processing a CreateProcess managed event, then simply mark that we're not syncronized anymore and
    // return. This is because the CreateProcess event isn't a real managed event.
    if (m_createing)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::CI: continuing from CreateProcess event.\n"));
        
        MarkAllThreadsDirty();
        
        m_createing = false;
        
        Unlock();
        return S_OK;
    }

    // Every stop or event must be matched by a corresponding Continue. m_stopCount counts outstanding stopping events
    // along with calls to Stop. If the count is high at this point, we simply return. This ensures that even if someone
    // calls Stop just as they're receiving an event that they can call Continue for that Stop and for that event
    // without problems.
    if (m_stopCount > 0)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::CI: m_stopCount=%d, Continue just returning S_OK...\n", m_stopCount));

        Unlock();
        return S_OK;
    }

    // We're no longer stopped, so reset the m_stopWaitEvent.
    ResetEvent(m_stopWaitEvent);
    
    // If we're continuing from an uninitialized stop, then we don't need to do much at all. No event need be sent to
    // the Left Side (duh, it isn't even there yet.) We just need to get the RC Event Thread to start listening to the
    // process again, and resume any unmanaged threads if necessary.
    if (m_uninitializedStop)
    {
        LOG((LF_CORDB, LL_INFO1000,
             "CP::CI: continuing from uninitialized stop.\n"));

        // No longer synchronized (it was a half-assed sync in the
        // first place.)
        SetSynchronized(false);
        MarkAllThreadsDirty();

        // No longer in an uninitialized stop.
        m_uninitializedStop = false;

        // Notify the RC Event Thread.
        m_cordb->ProcessStateChanged();

        // If we're Win32 attached, resume all the unmanaged threads.
        if (m_state & PS_WIN32_ATTACHED)
            ResumeUnmanagedThreads(false);

        Unlock();
        return S_OK;
    }
    
    // If there are more managed events, get them dispatched now.
    if ((m_queuedEventList != NULL) && GetSynchronized())
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::CI: managed event queued.\n"));
        
        // Mark that we're not synchronized anymore.
        SetSynchronized(false);
        MarkAllThreadsDirty();

        // If we're in the middle of dispatching a managed event, then simply return. This indicates to HandleRCEvent
        // that the user called Continue and HandleRCEvent will dispatch the next queued event. But if Continue was
        // called outside the managed callback, all we have to do is tell the RC event thread that something about the
        // process has changed and it will dispatch the next managed event.
        if (!m_dispatchingEvent)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "CP::CI: continuing while not dispatching managed event.\n"));

            m_cordb->ProcessStateChanged();
        }

        Unlock();
        return S_OK;
    }
    
    // At this point, if the managed event queue is empty, m_synchronized may still be true if we had previously
    // synchronized.

    // Next, check for unmanaged events that may be queued. If there are some queued, then we need to get the Win32
    // event thread to go ahead and dispatch the next one. If there aren't any queued, then we can just fall through and
    // send the continue message to the left side. This works even if we have an outstanding ownership request, because
    // until that answer is received, its just like the event hasn't happened yet.
    bool doWin32Continue = ((m_state & (PS_WIN32_STOPPED | PS_SOME_THREADS_SUSPENDED | PS_HIJACKS_IN_PLACE)) != 0);
    
    if (m_unmanagedEventQueue != NULL)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::CI: there are queued unmanaged events.\n"));

        // Are we being called while in the unmanaged event callback?
        if (m_dispatchingUnmanagedEvent)
        {
            LOG((LF_CORDB, LL_INFO1000, "CP::CI: continue while dispatching.\n"));
        
            // Tell the Win32 therad to continue when it returns from handling its unmanaged callback.
            m_dispatchingUnmanagedEvent = false;

            // Dequeue the head event
            DequeueUnmanagedEvent(m_unmanagedEventQueue->m_owner);

            // If there are no more unmanaged events, then we fall through and continue the process for real. Otherwise,
            // we can simply return.
            if (m_unmanagedEventQueue != NULL)
            {
                LOG((LF_CORDB, LL_INFO1000, "CP::CI: more unmanaged events queued.\n"));

                // Note: if we tried to access the Left Side while stopped but couldn't, then m_oddSync will be true. We
                // need to reset it to false since we're continuing now.
                m_oddSync = false;
                
                Unlock();
                return S_OK;
            }
            else
            {
                // Also, if there are no more unmanaged events, then when DispatchUnmanagedInBandEvent sees that
                // m_dispatchingUnmanagedEvent is false, it will continue the process. So we set doWin32Continue to
                // false here so that we don't try to double continue the process below.
                LOG((LF_CORDB, LL_INFO1000, "CP::CI: unmanaged event queue empty.\n"));

                doWin32Continue = false;
            }
        }
        else
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "CP::CI: continue outside of dispatching.\n"));

            // If the event at the head of the queue is really the last event, or if the event at the head of the queue
            // hasn't been dispatched yet, then we simply fall through and continue the process for real. However, if
            // its not the last event, we send to the Win32 event thread and get it to continue, then we return.
            if ((m_unmanagedEventQueue->m_next != NULL) || !m_unmanagedEventQueue->IsDispatched())
            {
                LOG((LF_CORDB, LL_INFO1000, "CP::CI: more queued unmanaged events.\n"));

                // Note: if we tried to access the Left Side while stopped but couldn't, then m_oddSync will be true. We
                // need to reset it to false since we're continuing now.
                m_oddSync = false;
                
                Unlock();

                hr = m_cordb->m_win32EventThread->SendUnmanagedContinue(this, false, false);

                return hr;
            }
        }
    }

    // Both the managed and unmanaged event queues are now empty. Go
    // ahead and continue the process for real.
    LOG((LF_CORDB, LL_INFO1000, "CP::CI: headed for true continue.\n"));

    // We need to check these while under the lock, but action must be
    // taked outside of the lock.
    bool isExiting = m_exiting;
    bool wasSynchronized = GetSynchronized();

    // Mark that we're no longer synchronized.
    if (wasSynchronized)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::CI: process was synchronized.\n"));
        
        SetSynchronized(false);
        m_syncCompleteReceived = false;
        MarkAllThreadsDirty();
    
        // Tell the RC event thread that something about this process has changed.
        m_cordb->ProcessStateChanged();
    }

    m_continueCounter++;

    // If m_oddSync is set, then out last synchronization was due to us syncing the process because we were Win32
    // stopped. Therefore, while we do need to do most of the work to continue the process below, we don't actually have
    // to send the managed continue event. Setting wasSynchronized to false here helps us do that.
    if (m_oddSync)
    {
        wasSynchronized = false;
        m_oddSync = false;
    }
    
    // We must ensure that all managed threads are suspended here. We're about to let all managed threads run free via
    // the managed continue message to the Left Side. If we don't suspend the managed threads, then they may start
    // slipping forward even if we receive an in-band unmanaged event. We have to hijack in-band unmanaged events while
    // getting the managed continue message over to the Left Side to keep the process running free. Otherwise, the
    // SendIPCEvent will hang below. But in doing so, we could let managed threads slip to far. So we ensure they're all
    // suspended here.
    //
    // Note: we only do this suspension if the helper thread hasn't died yet. If the helper thread has died, then we
    // know that we're loosing the Runtime. No more managed code is going to run, so we don't bother trying to prevent
    // managed threads from slipping via the call below.
    //
    // Note: we just remember here, under the lock, so we can unlock then wait for the syncing thread to free the
    // debugger lock. Otherwise, we may block here and prevent someone from continuing from an OOB event, which also
    // prevents the syncing thread from releasing the debugger lock like we want it to.
    bool needSuspend = wasSynchronized && doWin32Continue && !m_helperThreadDead;

    // If we receive a new in-band event once we unlock, we need to know to hijack it and keep going while we're still
    // trying to send the managed continue event to the process.
    if (wasSynchronized && doWin32Continue && !isExiting)
        m_specialDeferment = true;
    
    Unlock();

    if (needSuspend)
    {
        // Note: we need to make sure that the thread that sent us the sync complete flare has actually released the
        // debugger lock.
        DWORD ret = WaitForSingleObject(m_syncThreadIsLockFree, INFINITE);
        _ASSERTE(ret == WAIT_OBJECT_0);

        Lock();
        SuspendUnmanagedThreads(0);
        Unlock();
    }

    // If we're processing an ExitProcess managed event, then we don't want to really continue the process, so just fall
    // thru.  Note: we did let the unmanaged continue go through above for this case.
    if (isExiting)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::CI: continuing from exit case.\n"));
    }
    else if (wasSynchronized)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::CI: Sending continue to AppD:0x%x.\n", pAppDomainToken));
    
        // Send to the RC to continue the process.
        event = (DebuggerIPCEvent*) _alloca(CorDBIPC_BUFFER_SIZE);
        InitIPCEvent(event, DB_IPCE_CONTINUE, false, pAppDomainToken);

        hr = m_cordb->SendIPCEvent(this, event, CorDBIPC_BUFFER_SIZE);
        
        LOG((LF_CORDB, LL_INFO1000, "CP::CI: Continue sent to AppD:0x%x.\n", pAppDomainToken));
    }

    // If we're win32 attached to the Left side, then we need to win32 continue the process too (unless, of course, it's
    // already been done above.)
    //
    // Note: we do this here because we want to get the Left Side to receive and ack our continue message above if we
    // were sync'd. If we were sync'd, then by definition the process (and the helper thread) is running anyway, so all
    // this continue is going to do is to let the threads that have been suspended go.
    if (doWin32Continue)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::CI: sending unmanaged continue.\n"));

        // Send to the Win32 event thread to do the unmanaged continue for us.
        hr = m_cordb->m_win32EventThread->SendUnmanagedContinue(this, false, false);
    }

    LOG((LF_CORDB, LL_INFO1000, "CP::CI: continue done, returning.\n"));
    
    return hr;
}

HRESULT CordbProcess::HasQueuedCallbacks(ICorDebugThread *pThread,
                                         BOOL *pbQueued)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pThread,ICorDebugThread *);
    VALIDATE_POINTER_TO_OBJECT(pbQueued,BOOL *);

    CORDBRequireProcessStateOKAndSync(this, NULL);

    Lock();

    if (pThread == NULL)
        *pbQueued = (m_queuedEventList != NULL);
    else
    {
        *pbQueued = FALSE;

        for (DebuggerIPCEvent *event = m_queuedEventList;
             event != NULL;
             event = event->next)
        {
            CordbThread *t =
                (CordbThread*) m_userThreads.GetBase(event->threadId);

            if (t == (CordbThread*)pThread)
            {
                *pbQueued = TRUE;
                break;
            }
        }
    }

    Unlock();

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

//
// A small helper function to convert a CordbBreakpoint to an ICorDebugBreakpoint based on its type.
//
static ICorDebugBreakpoint *CordbBreakpointToInterface(CordbBreakpoint *bp)
{
    //
    // I really hate this. We've got three subclasses of CordbBreakpoint, but we store them all into the same hash
    // (m_breakpoints), so when we get one out of the hash, we don't really know what type it is. But we need to know
    // what type it is because we need to cast it to the proper interface before passing it out. I.e., when we create a
    // function breakpoint, we return the breakpoint casted to an ICorDebugFunctionBreakpoint. But if we grab that same
    // breakpoint out of the hash as a CordbBreakpoint and pass it out as an ICorDebugBreakpoint, then that's a
    // different pointer, and its wrong. So I've added the type to the breakpoint so we can cast properly here. I'd love
    // to do this a different way, though...
    //
    // -- Mon Dec 14 21:06:46 1998
    //
    switch(bp->GetBPType())
    {
    case CBT_FUNCTION:
        return ((ICorDebugFunctionBreakpoint*)(CordbFunctionBreakpoint*)bp);
        break;
                    
    case CBT_MODULE:
        return ((ICorDebugFunctionBreakpoint*)(CordbModuleBreakpoint*)bp);
        break;

    case CBT_VALUE:
        return ((ICorDebugFunctionBreakpoint*)(CordbValueBreakpoint*)bp);
        break;

    default:
        _ASSERTE(!"Invalid breakpoint type!");
    }

    return NULL;
}
//
// DispatchRCEvent -- dispatches a previously queued IPC event reveived
// from the runtime controller. This represents the last amount of processing
// the DI gets to do on an event before giving it to the user.
//
void CordbProcess::DispatchRCEvent(void)
{
    //
    // Note: the current thread should have the process locked when it
    // enters this method.
    //
    _ASSERTE(ThreadHoldsProcessLock());

    _ASSERTE(m_cordb->m_managedCallback != NULL);
    
    //
    // Snag the first event off the queue.
    //
    DebuggerIPCEvent* event = m_queuedEventList;

    if (event == NULL)
        return;

    m_queuedEventList = event->next;

    if (m_queuedEventList == NULL)
        m_lastQueuedEvent = NULL;

    // Bump up the stop count. Either we'll dispatch a managed event,
    // or the logic below will decide not to dispatch one and call
    // Continue itself. Either way, the stop count needs to go up by
    // one...
    m_stopCount++;
    
    CordbAppDomain *ad = NULL;

    //
    // Set m_dispatchingEvent to true to guard against calls to Continue()
    // from within the user's callback. We need Continue() to behave a little
    // bit differently in such a case.
    // 
    // Also note that Win32EventThread::ExitProcess will take the lock and free all 
    // events in the queue. (the current event is already off the queue, so 
    // it will be ok). But we can't do the EP callback in the middle of this dispatch
    // so if this flag is set, EP will wait on the miscWaitEvent (which will 
    // get set in FlushQueuedEvents when we return from here) and let us finish here.
    //        
    m_dispatchingEvent = true;

    // The thread may have moved the appdomain it occupies since the last time
    // we saw it, so update it.
    CordbAppDomain *pAppDomain = NULL;
    CordbThread* thread = NULL;
    
    thread = (CordbThread*)m_userThreads.GetBase(event->threadId);
    pAppDomain =(CordbAppDomain*) m_appDomains.GetBase(
            (ULONG)event->appDomainToken);

    // Update the app domain that this thread lives in.
    if (thread != NULL && pAppDomain != NULL)
    {
        thread->m_pAppDomain = pAppDomain;
    }

    Unlock();
    
    switch (event->type & DB_IPCE_TYPE_MASK)
    {
    case DB_IPCE_BREAKPOINT:
        {
#ifdef RIGHT_SIDE_ONLY
            LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::DRCE: breakpoint.\n",
                 GetCurrentThreadId()));

            Lock();

            _ASSERTE(thread != NULL); 
            _ASSERTE (pAppDomain != NULL);

            // Find the breakpoint object on this side.
            CordbBreakpoint *bp = (CordbBreakpoint *) 
              thread->m_pAppDomain->m_breakpoints.GetBase((unsigned long) 
                                    event->BreakpointData.breakpointToken);

            ICorDebugBreakpoint *ibp = NULL;
            if (bp != NULL)
            {
                bp->AddRef();
                ibp = CordbBreakpointToInterface(bp);
                _ASSERTE(ibp != NULL);
            }
            
            Unlock();

            if (m_cordb->m_managedCallback && (bp != NULL))
            {
                m_cordb->m_managedCallback->Breakpoint((ICorDebugAppDomain*) thread->m_pAppDomain,
                                                       (ICorDebugThread*) thread,
                                                       ibp);
            }

            if (bp != NULL)
                bp->Release();
            else
            {
                // If we didn't find a breakpoint object on this side,
                // the we have an extra BP event for a breakpoint that
                // has been removed and released on this side. Just
                // ignore the event.
                Continue(FALSE);
            }
#else
        _ASSERTE( !"Inproc got a breakpoint alert, which it shouldn't have!" );
#endif        
        }
        break;

    case DB_IPCE_USER_BREAKPOINT:
        {
            LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::DRCE: user breakpoint.\n",
                 GetCurrentThreadId()));

            Lock();

            _ASSERTE(thread != NULL);
            _ASSERTE (pAppDomain != NULL);

            Unlock();

            if (m_cordb->m_managedCallback)
            {
                _ASSERTE(thread->m_pAppDomain != NULL);

                m_cordb->m_managedCallback->Break((ICorDebugAppDomain*) thread->m_pAppDomain,
                                                  (ICorDebugThread*) thread);

            }
        }
        break;

    case DB_IPCE_STEP_COMPLETE:
        {
            LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::DRCE: step complete.\n", 
                 GetCurrentThreadId()));

            Lock();
            _ASSERTE(thread != NULL);

            CordbStepper *stepper = (CordbStepper *) 
              thread->m_process->m_steppers.GetBase((unsigned long) 
                                    event->StepData.stepperToken);

            if (stepper != NULL)
            {
                stepper->AddRef();
                stepper->m_active = false;
                thread->m_process->m_steppers.RemoveBase(stepper->m_id);
            }

            Unlock();

            if (m_cordb->m_managedCallback)
            {
                _ASSERTE(thread->m_pAppDomain != NULL);

                m_cordb->m_managedCallback->StepComplete(
                                                   (ICorDebugAppDomain*) thread->m_pAppDomain,
                                                   (ICorDebugThread*) thread,
                                                   (ICorDebugStepper*) stepper,
                                                   event->StepData.reason);

            }

            if (stepper != NULL)
                stepper->Release();
        }
        break;

    case DB_IPCE_EXCEPTION:
        {
            LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::DRCE: exception.\n",
                 GetCurrentThreadId()));

            _ASSERTE(thread != NULL);
            _ASSERTE(pAppDomain != NULL);
           
            thread->m_exception = true;
            thread->m_continuable = event->Exception.continuable;
            thread->m_thrown = event->Exception.exceptionHandle;

            if (m_cordb->m_managedCallback)
            {
                _ASSERTE (thread->m_pAppDomain != NULL);

                m_cordb->m_managedCallback->Exception((ICorDebugAppDomain*) thread->m_pAppDomain,
                                                      (ICorDebugThread*) thread,
                                                      !event->Exception.firstChance);

            }
        }
        break;

    case DB_IPCE_SYNC_COMPLETE:
        _ASSERTE(!"Should have never queued a sync complete event.");
        break;

    case DB_IPCE_THREAD_ATTACH:
        {
            LOG((LF_CORDB, LL_INFO100, "[%x] RCET::DRCE: thread attach : ID=%x.\n", 
                 GetCurrentThreadId(), event->threadId));

            Lock();

#ifdef _DEBUG
            _ASSERTE(thread == NULL);
#endif
            // Dup the runtime thread's handle into our process.
            HANDLE threadHandle;
            BOOL succ = DuplicateHandle(this->m_handle,
                                        event->ThreadAttachData.threadHandle,
                                        GetCurrentProcess(),
                                        &threadHandle,
                                        NULL, FALSE, DUPLICATE_SAME_ACCESS);

            if (succ)
            {
                HandleManagedCreateThread(event->threadId, threadHandle);

                thread =
                    (CordbThread*) m_userThreads.GetBase(event->threadId);

                _ASSERTE(thread != NULL);

				thread->m_debuggerThreadToken =
					event->ThreadAttachData.debuggerThreadToken;
                thread->m_firstExceptionHandler = 
                    event->ThreadAttachData.firstExceptionHandler;
                thread->m_stackBase =
                    event->ThreadAttachData.stackBase;
                thread->m_stackLimit =
                    event->ThreadAttachData.stackLimit;

                _ASSERTE(thread->m_firstExceptionHandler != NULL);

				thread->AddRef();

                _ASSERTE (pAppDomain != NULL);
                
                thread->m_pAppDomain = pAppDomain;
				pAppDomain->m_fHasAtLeastOneThreadInsideIt = true;
			
                Unlock();
        
                if (m_cordb->m_managedCallback)
                {
                    m_cordb->m_managedCallback->CreateThread(
                                                 (ICorDebugAppDomain*) pAppDomain,
                                                 (ICorDebugThread*) thread);

                }

                thread->Release();
            }
            else
            {
            // If we failed b/c the LS exited, then just ignore this event
            // and make way for the ExitProcess() callback.            
                if (CheckIfLSExited())
                {
                    Unlock();
                    Continue(FALSE);
                    break;                    
                }
                
                Unlock();
                CORDBProcessSetUnrecoverableWin32Error(this, 0);
            }
        }
        break;
        
    case DB_IPCE_THREAD_DETACH:
        {
            LOG((LF_CORDB, LL_INFO100, "[%x] RCET::HRCE: thread detach : ID=%x \n", 
                 GetCurrentThreadId(), event->threadId));

            Lock();

            // If the runtime thread never entered managed code, there
            // won't be a CordbThread, and CreateThread was never
            // called, so don't bother calling ExitThread.
            if (thread != NULL)
            {
                thread->AddRef();

                _ASSERTE(pAppDomain != NULL);
                _ASSERTE(thread->m_detached);

                // Remove the thread from the hash.
                m_userThreads.RemoveBase(event->threadId);

                // Remove this app domain if we can.
                if (pAppDomain->IsMarkedForDeletion() == TRUE)
                {
                    pAppDomain->AddRef();
                    pAppDomain->m_pProcess->Release();
                    m_appDomains.RemoveBase((ULONG)event->appDomainToken);
                }
            
                Unlock();

                if (m_cordb->m_managedCallback)
                {
                    LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::HRCE: sending "
                         "thread detach.\n", 
                         GetCurrentThreadId()));
                    
                    m_cordb->m_managedCallback->ExitThread(
                                       (ICorDebugAppDomain*) pAppDomain,
                                       (ICorDebugThread*) thread);

                }

                if (pAppDomain->IsMarkedForDeletion() == TRUE)
                {
                    pAppDomain->Release();
                }

                thread->Release();
            }
            else
            {
                Unlock();
                Continue(FALSE);
            }
        }
        break;
        
    case DB_IPCE_LOAD_MODULE:
        {
            LOG((LF_CORDB, LL_INFO100,
                 "RCET::HRCE: load module on thread %#x Mod:0x%08x Asm:0x%08x AD:0x%08x Metadata:0x%08x/%d IsDynamic:%d\n", 
                 event->threadId,
                 event->LoadModuleData.debuggerModuleToken,
                 event->LoadModuleData.debuggerAssemblyToken,
                 event->appDomainToken,
                 event->LoadModuleData.pMetadataStart,
                 event->LoadModuleData.nMetadataSize,
                 event->LoadModuleData.fIsDynamic));

            _ASSERTE (pAppDomain != NULL);

            CordbModule *moduleDup = (CordbModule*) pAppDomain->LookupModule (
							event->LoadModuleData.debuggerModuleToken);
            if (moduleDup != NULL)
            {
                LOG((LF_CORDB, LL_INFO100, "Already loaded Module - continue()ing!" ));
#ifdef RIGHT_SIDE_ONLY
                pAppDomain->Continue(FALSE);

#endif //RIGHT_SIDE_ONLY    
                break;
            }
            _ASSERTE(moduleDup == NULL);

            bool fIsDynamic = (event->LoadModuleData.fIsDynamic!=0)?true:false;

			CordbAssembly *pAssembly = 
				(CordbAssembly *)pAppDomain->m_assemblies.GetBase (
							(ULONG)event->LoadModuleData.debuggerAssemblyToken);

            // It is possible to get a load module event before the corresponding 
            // assembly has been loaded. Therefore, just ignore the event and continue. 
            // A load module event for this module will be sent by the left side
            // after it has loaded the assembly.
            if (pAssembly == NULL)
            {
                LOG((LF_CORDB, LL_INFO100, "Haven't loaded Assembly "
                    "yet - continue()ing!" ));
#ifdef RIGHT_SIDE_ONLY
                pAppDomain->Continue(FALSE);

#endif //RIGHT_SIDE_ONLY    
                
            }
            else
            {
                HRESULT hr = S_OK;
                CordbModule* module = new CordbModule(
                                        this,
                                        pAssembly,
                                        event->LoadModuleData.debuggerModuleToken,
                                        event->LoadModuleData.pMetadataStart,
                                        event->LoadModuleData.nMetadataSize,
                                        event->LoadModuleData.pPEBaseAddress,
                                        event->LoadModuleData.nPESize,
                                        event->LoadModuleData.fIsDynamic,
                                        event->LoadModuleData.fInMemory,
                                        event->LoadModuleData.rcName,
                                        pAppDomain);

                if (module != NULL)
                {
                    hr = module->Init();

                    if (SUCCEEDED(hr))
                    {
                        hr = pAppDomain->m_modules.AddBase(module);

                        if (SUCCEEDED(hr))
                        {
                            if (m_cordb->m_managedCallback)
                            {
                                // @todo: Callback should be changed to take param 
                                // ICorDebugAssembly instead of ICorDebugAppDomain
                                m_cordb->m_managedCallback->LoadModule(
                                                 (ICorDebugAppDomain*) pAppDomain,
                                                 (ICorDebugModule*) module);

                            }
                        }
                        else
                            CORDBSetUnrecoverableError(this, hr, 0);
                    }
                    else
                        CORDBSetUnrecoverableError(this, hr, 0);
                }
                else
                    CORDBSetUnrecoverableError(this, E_OUTOFMEMORY, 0);
            }
        }


        break;

    case DB_IPCE_UNLOAD_MODULE:
        {
            LOG((LF_CORDB, LL_INFO100, "RCET::HRCE: unload module on thread %#x Mod:0x%x AD:0x%08x\n", 
                 event->threadId,
                 event->UnloadModuleData.debuggerModuleToken,
                 event->appDomainToken));

            _ASSERTE (pAppDomain != NULL);

            CordbModule *module = (CordbModule*) pAppDomain->LookupModule (
                            event->UnloadModuleData.debuggerModuleToken);
            if (module == NULL)
            {
                LOG((LF_CORDB, LL_INFO100, "Already unloaded Module - continue()ing!" ));
#ifdef RIGHT_SIDE_ONLY
                pAppDomain->Continue(FALSE);

#endif //RIGHT_SIDE_ONLY    
                break;
            }
            _ASSERTE(module != NULL);

            // The appdomain we're unloading in must be the appdomain we were loaded in. Otherwise, we've got mismatched
            // module and appdomain pointers. Bugs 65943 & 81728.
            _ASSERTE(pAppDomain == module->GetAppDomain());

            if (m_cordb->m_managedCallback)
            {
                m_cordb->m_managedCallback->UnloadModule((ICorDebugAppDomain*) pAppDomain,
                                                         (ICorDebugModule*) module);

            }

            pAppDomain->m_modules.RemoveBase(
                         (ULONG) event->UnloadModuleData.debuggerModuleToken);
        }
        break;

    case DB_IPCE_LOAD_CLASS:
        {
            HRESULT hrConvert = S_OK;
            void * remotePtr = NULL;

            LOG((LF_CORDB, LL_INFO10000,
                 "RCET::HRCE: load class on thread %#x Tok:0x%08x Mod:0x%08x Asm:0x%08x AD:0x%08x\n", 
                 event->threadId,
                 event->LoadClass.classMetadataToken,
                 event->LoadClass.classDebuggerModuleToken,
                 event->LoadClass.classDebuggerAssemblyToken,
                 event->appDomainToken));

			_ASSERTE (pAppDomain != NULL);

            CordbModule* module =
                (CordbModule*) pAppDomain->LookupModule(event->LoadClass.classDebuggerModuleToken);
            if (module == NULL)
            {
                LOG((LF_CORDB, LL_INFO100, "Load Class on not-loaded Module - continue()ing!" ));
#ifdef RIGHT_SIDE_ONLY
                pAppDomain->Continue(FALSE);

#endif //RIGHT_SIDE_ONLY    
                break;
            }
            _ASSERTE(module != NULL);

            BOOL dynamic = FALSE;
            HRESULT hr = module->IsDynamic(&dynamic);
            if (FAILED(hr))
            {
                Continue(FALSE);
                break;
            }

            // If this is a class load in a dynamic module, then we'll have
            // to grab an up-to-date copy of the metadata from the left side,
            // then send the "release buffer" message to free the memory.
            if (dynamic && !FAILED(hr))
            {
                BYTE *pMetadataCopy;
                            
                // Get it
                remotePtr = event->LoadClass.pNewMetaData;
                BOOL succ = TRUE;
                if (remotePtr != NULL)
                {
                    DWORD dwErr;
                    dwErr = CordbModule::m_metadataPointerCache.CopyRemoteMetadata(
                        m_handle,
                        remotePtr, 
                        event->LoadClass.cbNewMetaData, 
                        &pMetadataCopy);
                    
                    if(dwErr == E_OUTOFMEMORY)
                    {
                        Continue(FALSE);
                        break; // out of the switch
                    }
                    else if (FAILED(dwErr))
                    {
                        succ = false;
                    }
                }
                // Deal with problems involved in getting it.
                if (succ)
                {
                    event->LoadClass.pNewMetaData = pMetadataCopy;
                }
                else
                {
                    event->LoadClass.pNewMetaData = NULL;
                }

                hrConvert = module->ConvertToNewMetaDataInMemory(
                    event->LoadClass.pNewMetaData,
                    event->LoadClass.cbNewMetaData);
                    
                if (FAILED(hrConvert))
                {
                    LOG((LF_CORDB, LL_INFO1000, "RCET::HRCE: Failed to convert MD!\n"));
                    Continue(FALSE);
                    break;
    	        }
    	        
            }

            CordbClass *pClass = module->LookupClass(
                                       event->LoadClass.classMetadataToken);

            if (pClass == NULL)
            {
                HRESULT hr = module->CreateClass(
                                     event->LoadClass.classMetadataToken,
                                     &pClass);

                if (!SUCCEEDED(hr))
                    pClass = NULL;
            }

            if (pClass->m_loadEventSent)
            {
                // Dynamic modules are dynamic at the module level - 
                // you can't add a new version of a class once the module
                // is baked.
                // EnC adds completely new classes.
                // There shouldn't be any other way to send multiple
                // ClassLoad events.
                // Except that there are race conditions between loading
                // an appdomain, and loading a class, so if we get the extra
                // class load, we should ignore it.

                Continue(FALSE);
                break; //out of the switch statement
            }

            pClass->m_loadEventSent = TRUE;

            if (dynamic && remotePtr != NULL)
            {
                // Free it on the left side
                // Now free the left-side memory
                DebuggerIPCEvent eventReleaseBuffer;

                InitIPCEvent(&eventReleaseBuffer, 
                             DB_IPCE_RELEASE_BUFFER, 
                             true,
                             NULL);

                // Indicate the buffer to release
                eventReleaseBuffer.ReleaseBuffer.pBuffer = remotePtr;

                // Make the request, which is synchronous
                hr = SendIPCEvent(&eventReleaseBuffer, sizeof(eventReleaseBuffer));
#ifdef _DEBUG
                if (FAILED(hr))
                    LOG((LF_CORDB, LL_INFO1000, "RCET::HRCE: Failed to send msg!\n"));
#endif                    
            }

            if (pClass != NULL)
            {
                if (m_cordb->m_managedCallback)
                {
                    // @todo: Callback should be changed to take param 
                    // ICorDebugAssembly instead of ICorDebugAppDomain
                    m_cordb->m_managedCallback->LoadClass(
                                               (ICorDebugAppDomain*) pAppDomain,
                                               (ICorDebugClass*) pClass);

                }
            }
        }
        break;

    case DB_IPCE_UNLOAD_CLASS:
        {
            LOG((LF_CORDB, LL_INFO10000,
                 "RCET::HRCE: unload class on thread %#x Tok:0x%08x Mod:0x%08x AD:0x%08x\n", 
                 event->threadId,
                 event->UnloadClass.classMetadataToken,
                 event->UnloadClass.classDebuggerModuleToken,
                 event->appDomainToken));

            // get the appdomain object
            _ASSERTE (pAppDomain != NULL);

            CordbModule *module = (CordbModule*) pAppDomain->LookupModule (
                            event->UnloadClass.classDebuggerModuleToken);
            if (module == NULL)
            {
                LOG((LF_CORDB, LL_INFO100, "Unload Class on not-loaded Module - continue()ing!" ));
#ifdef RIGHT_SIDE_ONLY
                pAppDomain->Continue(FALSE);

#endif //RIGHT_SIDE_ONLY    
                break;
            }
            _ASSERTE(module != NULL);

            CordbClass *pClass = module->LookupClass(
                                       event->UnloadClass.classMetadataToken);
            
            if (pClass != NULL && !pClass->m_hasBeenUnloaded)
            {
                pClass->m_hasBeenUnloaded = true;
                if (m_cordb->m_managedCallback)
                {
                    // @todo: Callback should be changed to take param 
                    // ICorDebugAssembly instead of ICorDebugAppDomain
                    m_cordb->m_managedCallback->UnloadClass(
                                            (ICorDebugAppDomain*) pAppDomain,
                                            (ICorDebugClass*) pClass);

                }
            }
            else
            {
                LOG((LF_CORDB, LL_INFO10000,
                     "Unload already unloaded class 0x%08x.\n",
                     event->UnloadClass.classMetadataToken));
                
#ifdef RIGHT_SIDE_ONLY
                Continue(FALSE);
#endif //RIGHT_SIDE_ONLY    
            }
        }
        break;

    case DB_IPCE_FIRST_LOG_MESSAGE:
            ProcessFirstLogMessage (event);

        break;

    case DB_IPCE_CONTINUED_LOG_MESSAGE:
            ProcessContinuedLogMessage (event);

        break;

    case DB_IPCE_LOGSWITCH_SET_MESSAGE:
        {

            LOG((LF_CORDB, LL_INFO10000, 
                "[%x] RCET::DRCE: Log Switch Setting Message.\n",
                 GetCurrentThreadId()));

            Lock();

            _ASSERTE(thread != NULL);

            Unlock();

            int iSwitchNameLength = wcslen (&event->LogSwitchSettingMessage.Dummy[0]);
            int iParentNameLength = wcslen (
                        &event->LogSwitchSettingMessage.Dummy[iSwitchNameLength+1]);

            // allocate memory for storing the logswitch name and parent's name
            // This memory will be free by us after returning from the callback.
            WCHAR *pstrLogSwitchName;
            WCHAR *pstrParentName;

            _ASSERTE (iSwitchNameLength > 0);
            if (
                ((pstrLogSwitchName = new WCHAR [iSwitchNameLength+1])
                    != NULL)
                &&
                ((pstrParentName = new WCHAR [iParentNameLength+1])
                    != NULL)
                )
            {
                wcscpy (pstrLogSwitchName, 
                    &event->LogSwitchSettingMessage.Dummy[0]);
                wcscpy (pstrParentName, 
                    &event->LogSwitchSettingMessage.Dummy[iSwitchNameLength+1]);

                // Do the callback...
                if (m_cordb->m_managedCallback)
                {
                    // from the thread object get the appdomain object
                    pAppDomain = thread->m_pAppDomain;
                    _ASSERTE (pAppDomain != NULL);

                    m_cordb->m_managedCallback->LogSwitch(
                                               (ICorDebugAppDomain*) pAppDomain,
                                               (ICorDebugThread*) thread,
                                               event->LogSwitchSettingMessage.iLevel,
                                               event->LogSwitchSettingMessage.iReason,
                                               pstrLogSwitchName,
                                               pstrParentName);

                }

                delete [] pstrLogSwitchName;
                delete [] pstrParentName;
            }
            else
            {
                if (pstrLogSwitchName != NULL)
                    delete [] pstrLogSwitchName;
            }
        }

        break;

    case DB_IPCE_CREATE_APP_DOMAIN:
        {
            LOG((LF_CORDB, LL_INFO100,
                 "RCET::HRCE: create appdomain on thread %#x AD:0x%08x \n", 
                 event->threadId,
                 event->appDomainToken));

			CordbAppDomain* pAppDomainDup =
					(CordbAppDomain*) m_appDomains.GetBase(
							(ULONG)event->appDomainToken);

            // Remove this app domain if we can.
            if (pAppDomainDup)
            {
                _ASSERTE(pAppDomainDup->IsMarkedForDeletion());

                pAppDomainDup->AddRef();
                pAppDomainDup->m_pProcess->Release();
                m_appDomains.RemoveBase((ULONG)event->appDomainToken);
                pAppDomainDup->Release();
            }

            pAppDomain = new CordbAppDomain(
                                    this,
                                    event->appDomainToken,
                                    event->AppDomainData.id,
                                    event->AppDomainData.rcName);

            if (pAppDomain != NULL)
            {
                this->AddRef();

                HRESULT hr = m_appDomains.AddBase(pAppDomain);

                if (SUCCEEDED(hr))
                {
                    if (m_cordb->m_managedCallback)
                    {
                        hr = m_cordb->m_managedCallback->CreateAppDomain(
                                         (ICorDebugProcess*) this,
                                         (ICorDebugAppDomain*) pAppDomain);

                        // If they don't implement this callback, then just attach and continue.
                        if (hr == E_NOTIMPL)
                        {
                            pAppDomain->Attach();
                            pAppDomain->Continue(FALSE);
                        }
                    }
                }
                else
                    CORDBSetUnrecoverableError(this, hr, 0);
            }
            else
                CORDBSetUnrecoverableError(this, E_OUTOFMEMORY, 0);
        }


        break;

    case DB_IPCE_EXIT_APP_DOMAIN:
        {
            LOG((LF_CORDB, LL_INFO100, "RCET::HRCE: exit appdomain on thread %#x AD:0x%08x \n", 
                 event->threadId,
                 event->appDomainToken));

            _ASSERTE (pAppDomain != NULL);

            if (m_cordb->m_managedCallback)
            {
                HRESULT hr = m_cordb->m_managedCallback->ExitAppDomain(
                                               (ICorDebugProcess*) this,
                                               (ICorDebugAppDomain*) pAppDomain);

                // Just continue if they didn't implement the callback.
                if (hr == E_NOTIMPL)
                {
                    pAppDomain->Continue(FALSE);
                }
            }


            // Mark the app domain for deletion from the appdomain hash. Need to 
            // do this since the app domain is destroyed before the last thread
            // has exited. Therefore, this appdomain will be removed from the hash
            // list upon receipt of the "ThreadDetach" event.
            pAppDomain->MarkForDeletion();
        }

        break;

    case DB_IPCE_LOAD_ASSEMBLY:
        {
            HRESULT hr = S_OK;

            LOG((LF_CORDB, LL_INFO100,
                 "RCET::HRCE: load assembly on thread %#x Asm:0x%08x AD:0x%08x \n", 
                 event->threadId,
                 event->AssemblyData.debuggerAssemblyToken,
                 event->appDomainToken));

			_ASSERTE (pAppDomain != NULL);

            // If the debugger detached from, then reattached to an AppDomain,
            //  this side may get LoadAssembly messages for previously loaded
            //  Assemblies.
                        
            // Determine if this Assembly is cached.
            CordbAssembly* assembly =
                (CordbAssembly*) pAppDomain->m_assemblies.GetBase(
                         (ULONG) event->AssemblyData.debuggerAssemblyToken);
            
            if (assembly != NULL)
            { 
                // We may receive multiple LOAD_ASSEMBLY events in the case of shared assemblies
                // (since the EE doesn't quite produce them in a reliable way.)  So if we see
                // a duplicate here, just ignore it.
                
                // If the Assembly is cached, assert that the properties are unchanged.
                _ASSERTE(wcscmp(assembly->m_szAssemblyName, event->AssemblyData.rcName) == 0);
                _ASSERTE(assembly->m_fIsSystemAssembly == event->AssemblyData.fIsSystemAssembly);

                pAppDomain->Continue(FALSE);
            }
            else
            {
                //currently, event->AssemblyData.fIsSystemAssembly is never true
                assembly = new CordbAssembly(
                                pAppDomain,
                                event->AssemblyData.debuggerAssemblyToken,
                                event->AssemblyData.rcName,
                                event->AssemblyData.fIsSystemAssembly);
    
                if (assembly != NULL)
                {
                    hr = pAppDomain->m_assemblies.AddBase(assembly);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                // If created, or have, an Assembly, notify callback.
                if (SUCCEEDED(hr))
                {
                    if (m_cordb->m_managedCallback)
                    {
                        hr = m_cordb->m_managedCallback->LoadAssembly(
                                                                      (ICorDebugAppDomain*) pAppDomain,
                                                                      (ICorDebugAssembly*) assembly);

                        // Just continue if they didn't implement the callback.
                        if (hr == E_NOTIMPL)
                        {
                            pAppDomain->Continue(FALSE);
                        }
                    }
                }
                else
                    CORDBSetUnrecoverableError(this, hr, 0);
            }
        }

        break;

    case DB_IPCE_UNLOAD_ASSEMBLY:
        {
            LOG((LF_CORDB, LL_INFO100, "RCET::DRCE: unload assembly on thread %#x Asm:0x%x AD:0x%x\n", 
                 event->threadId,
                 event->AssemblyData.debuggerAssemblyToken,
                 event->appDomainToken));

            _ASSERTE (pAppDomain != NULL);

            CordbAssembly* assembly =
                (CordbAssembly*) pAppDomain->m_assemblies.GetBase(
                         (ULONG) event->AssemblyData.debuggerAssemblyToken);
            if (assembly == NULL)
            {
                LOG((LF_CORDB, LL_INFO100, "Assembly not loaded - continue()ing!" ));
#ifdef RIGHT_SIDE_ONLY
                pAppDomain->Continue(FALSE);

#endif //RIGHT_SIDE_ONLY    
                break;
            }
            _ASSERTE(assembly != NULL);

            if (m_cordb->m_managedCallback)
            {
                HRESULT hr = m_cordb->m_managedCallback->UnloadAssembly(
                                               (ICorDebugAppDomain*) pAppDomain,
                                               (ICorDebugAssembly*) assembly);

                // Just continue if they didn't implement this callback.
                if (hr == E_NOTIMPL)
                {
                    pAppDomain->Continue(FALSE);
                }
            }

            pAppDomain->m_assemblies.RemoveBase(
                         (ULONG) event->AssemblyData.debuggerAssemblyToken);
        }

        break;

    case DB_IPCE_FUNC_EVAL_COMPLETE:
        {
            LOG((LF_CORDB, LL_INFO1000, "RCET::DRCE: func eval complete.\n"));

            CordbEval *pEval = (CordbEval*)event->FuncEvalComplete.funcEvalKey;

            Lock();

            _ASSERTE(thread != NULL);
            _ASSERTE(pAppDomain != NULL);

            // Hold the data about the result in the CordbEval for later.
            pEval->m_complete = true;
            pEval->m_successful = event->FuncEvalComplete.successful;
            pEval->m_aborted = event->FuncEvalComplete.aborted;
            pEval->m_resultAddr = event->FuncEvalComplete.resultAddr;
            pEval->m_resultType = event->FuncEvalComplete.resultType;
            pEval->m_resultDebuggerModuleToken = event->FuncEvalComplete.resultDebuggerModuleToken;
            pEval->m_resultAppDomainToken = event->appDomainToken;

            // If we did this func eval with this thread stopped at an excpetion, then we need to pretend as if we
            // really didn't continue from the exception, since, of course, we really didn't on the Left Side.
            if (pEval->m_evalDuringException)
            {
                thread->m_exception = true;
            }
            
            Unlock();

            bool evalCompleted = pEval->m_successful || pEval->m_aborted;

            // Corresponding AddRef() in CallFunction()
            // If a CallFunction() is aborted, the LHS may not complete the abort
            // immediately and hence we cant do a SendCleanup() at that point. Also,
            // the debugger may (incorrectly) release the CordbEval before this
            // DB_IPCE_FUNC_EVAL_COMPLETE event is received. Hence, we maintain an
            // extra ref-count to determine when this can be done.
            // Note that this can cause a two-way DB_IPCE_FUNC_EVAL_CLEANUP event
            // to be sent. Hence, it has to be done before the Continue (see bug 102745).

            pEval->Release();

            if (m_cordb->m_managedCallback)
            {
                // Note that if the debugger has already (incorrectly) released the CordbEval,
                // pEval will be pointing to garbage and should not be used by the debugger.
                if (evalCompleted)
                    m_cordb->m_managedCallback->EvalComplete(
                                          (ICorDebugAppDomain*)pAppDomain,
                                          (ICorDebugThread*)thread,
                                          (ICorDebugEval*)pEval);
                else
                    m_cordb->m_managedCallback->EvalException(
                                          (ICorDebugAppDomain*)pAppDomain,
                                          (ICorDebugThread*)thread,
                                          (ICorDebugEval*)pEval);
            }
            else
            {
#ifdef RIGHT_SIDE_ONLY
                pAppDomain->Continue(FALSE);
#endif //RIGHT_SIDE_ONLY    
            }
        }
        break;


    case DB_IPCE_NAME_CHANGE:
        {
            LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::HRCE: Name Change %d  0x%08x 0x%08x\n", 
                 GetCurrentThreadId(),
                 event->threadId,
                 event->NameChange.debuggerAppDomainToken,
                 event->NameChange.debuggerThreadToken));

            thread = NULL;
            pAppDomain = NULL;
            if (event->NameChange.eventType == THREAD_NAME_CHANGE)
            {
                // Lookup the CordbThread that matches this runtime thread.
                thread = (CordbThread*) m_userThreads.GetBase(
                                        event->NameChange.debuggerThreadToken);
            }
            else
            {
                _ASSERTE (event->NameChange.eventType == APP_DOMAIN_NAME_CHANGE);
                pAppDomain = (CordbAppDomain*) m_appDomains.GetBase(
                                (ULONG)event->appDomainToken);
                if (pAppDomain)
                    pAppDomain->m_nameIsValid = false;
            }

            if (thread || pAppDomain)
            {
                if (m_cordb->m_managedCallback)
                {
                    HRESULT hr = m_cordb->m_managedCallback->NameChange(
                                                   (ICorDebugAppDomain*) pAppDomain,
                                                   (ICorDebugThread*) thread);
                }
            }
            else
            {
                Continue(FALSE);
            }
        }

        break;
        
    case DB_IPCE_UPDATE_MODULE_SYMS:
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "RCET::HRCE: update module syms 0x%08x 0x%08x 0x%08x %d\n", 
                 event->UpdateModuleSymsData.debuggerModuleToken,
                 event->UpdateModuleSymsData.debuggerAppDomainToken,
                 event->UpdateModuleSymsData.pbSyms,
                 event->UpdateModuleSymsData.cbSyms));

            // Find the app domain the module lives in.
            _ASSERTE (pAppDomain != NULL);

            // Find the Right Side module for this module.
            CordbModule *module = (CordbModule*) pAppDomain->LookupModule (
                            event->UpdateModuleSymsData.debuggerModuleToken);
            _ASSERTE(module != NULL);

            // Make room for the memory on this side.
            BYTE *syms = new BYTE[event->UpdateModuleSymsData.cbSyms];
            
            _ASSERTE(syms != NULL);
            if (!syms)
            {
                CORDBSetUnrecoverableError(this, E_OUTOFMEMORY, 0);            
                break;
            }
            
            // Read the data from the Left Side.
            BOOL succ = ReadProcessMemoryI(m_handle,
                                           event->UpdateModuleSymsData.pbSyms,
                                           syms,
                                           event->UpdateModuleSymsData.cbSyms,
                                           NULL);
            _ASSERTE(succ);

            // Create a stream from the memory.
            IStream *pStream = NULL;
            HRESULT hr = CInMemoryStream::CreateStreamOnMemoryCopy(
                                         syms,
                                         event->UpdateModuleSymsData.cbSyms,
                                         &pStream);
            _ASSERTE(SUCCEEDED(hr) && (pStream != NULL));

            // Free memory on the left side if we need to.
            if (event->UpdateModuleSymsData.needToFreeMemory)
            {
                DebuggerIPCEvent eventReleaseBuffer;

                InitIPCEvent(&eventReleaseBuffer, 
                             DB_IPCE_RELEASE_BUFFER, 
                             true,
                             NULL);

                // Indicate the buffer to release.
                eventReleaseBuffer.ReleaseBuffer.pBuffer =
                    event->UpdateModuleSymsData.pbSyms;

                // Make the request, which is synchronous.
                SendIPCEvent(&eventReleaseBuffer, sizeof(eventReleaseBuffer));
            }
            
            if (m_cordb->m_managedCallback)
            {
                m_cordb->m_managedCallback->UpdateModuleSymbols(
                                     (ICorDebugAppDomain*) pAppDomain,
                                     (ICorDebugModule*) module,
                                     pStream);
            }

            pStream->Release();
            delete [] syms;
        }
        break;

    case DB_IPCE_CONTROL_C_EVENT:
        {
            LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::HRCE: ControlC Event %d  0x%08x\n", 
                 GetCurrentThreadId(),
                 event->threadId,
                 event->Exception.exceptionHandle));


			HRESULT hr = S_FALSE;

			if (m_cordb->m_managedCallback)
            {
                hr = m_cordb->m_managedCallback->ControlCTrap((ICorDebugProcess*) this);
            }

            DebuggerIPCEvent eventControlCResult;

            InitIPCEvent(&eventControlCResult, 
                         DB_IPCE_CONTROL_C_EVENT_RESULT, 
                         false,
                         NULL);

            // Indicate the buffer to release.
            eventControlCResult.hr = hr;

            // Send the event
            SendIPCEvent(&eventControlCResult, sizeof(eventControlCResult));

        }
		break;

        case DB_IPCE_ENC_REMAP:
        {
#ifdef RIGHT_SIDE_ONLY
            LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::DRCE: EnC Remap!.\n",
                 GetCurrentThreadId()));

            _ASSERTE(NULL != pAppDomain);
            if (m_cordb->m_managedCallback)
            {
                CordbModule* module = (CordbModule *)pAppDomain->LookupModule(
                                            event->EnCRemap.debuggerModuleToken);
                CordbFunction *f = NULL;

                if (module != NULL)
                {
                    f = (CordbFunction *)module->LookupFunction(
                            event->EnCRemap.funcMetadataToken);
                    if (f == NULL)
                    {
                        HRESULT hr = module->CreateFunction(
                                    (mdMethodDef)event->EnCRemap.funcMetadataToken,
                                    event->EnCRemap.RVA,
                                    &f);
                        _ASSERTE( SUCCEEDED(hr) || !"FAILURE" );
                        if (SUCCEEDED(hr))
                            f->SetLocalVarToken(event->EnCRemap.localSigToken);
                    }
                }
                
                m_cordb->m_managedCallback->EditAndContinueRemap(
                                      (ICorDebugAppDomain*)pAppDomain,
                                      (ICorDebugThread*) thread,
                                      (ICorDebugFunction *)f,
                                      event->EnCRemap.fAccurate);
            }
#endif // RIGHT_SIDE_ONLY
        }
        break;

        case DB_IPCE_BREAKPOINT_SET_ERROR:
        {
#ifdef RIGHT_SIDE_ONLY
            LOG((LF_CORDB, LL_INFO1000, "RCET::DRCE: breakpoint set error.\n"));

            Lock();

            _ASSERTE(thread != NULL); 
            _ASSERTE(pAppDomain != NULL);

            // Find the breakpoint object on this side.
            CordbBreakpoint *bp = (CordbBreakpoint *)thread->m_pAppDomain->m_breakpoints.GetBase(
                                                           (unsigned long) event->BreakpointSetErrorData.breakpointToken);

            if (bp != NULL)
                bp->AddRef();

            ICorDebugBreakpoint *ibp = CordbBreakpointToInterface(bp);
            _ASSERTE(ibp != NULL);
            
            Unlock();

            if (m_cordb->m_managedCallback && (bp != NULL))
            {
                m_cordb->m_managedCallback->BreakpointSetError((ICorDebugAppDomain*) thread->m_pAppDomain,
                                                               (ICorDebugThread*) thread,
                                                               ibp,
                                                               0);
            }

            if (bp != NULL)
                bp->Release();
            else
            {
                // If we didn't find a breakpoint object on this side,
                // the we have an extra BP event for a breakpoint that
                // has been removed and released on this side. Just
                // ignore the event.
                Continue(FALSE);
            }
#endif // RIGHT_SIDE_ONLY
        }
        break;
    default:
        LOG((LF_CORDB, LL_INFO1000,
             "[%x] RCET::HRCE: Unknown event: 0x%08x\n", 
             GetCurrentThreadId(), event->type));
    }

    Lock();

    //
    // Set for Continue().
    //
    m_dispatchingEvent = false;

    free(event);
}


HRESULT CordbProcess::EnumerateThreads(ICorDebugThreadEnum **ppThreads)
{
    VALIDATE_POINTER_TO_OBJECT(ppThreads,ICorDebugThreadEnum **);

    CordbHashTableEnum *e = new CordbHashTableEnum(&m_userThreads, 
                                                   IID_ICorDebugThreadEnum);
    if (e == NULL)
        return E_OUTOFMEMORY;

    *ppThreads = (ICorDebugThreadEnum*)e;
    e->AddRef();

    return S_OK;
}

HRESULT CordbProcess::GetThread(DWORD dwThreadId, ICorDebugThread **ppThread)
{
    VALIDATE_POINTER_TO_OBJECT(ppThread, ICorDebugThread **);

	HRESULT hr = S_OK;
	INPROC_LOCK();

    CordbThread *t = (CordbThread *) m_userThreads.GetBase(dwThreadId);

    if (t == NULL)
    {
    	hr = E_INVALIDARG;
    	goto LExit;
    }

    *ppThread = (ICorDebugThread*)t;
    (*ppThread)->AddRef();
    
LExit:
	INPROC_UNLOCK();
         
    return hr;
}

HRESULT CordbProcess::ThreadForFiberCookie(DWORD fiberCookie,
                                           ICorDebugThread **ppThread)
{
    HASHFIND find;
    CordbThread *t = NULL;

	INPROC_LOCK();

    Lock();
    
    for (t  = (CordbThread*)m_userThreads.FindFirst(&find);
         t != NULL;
         t  = (CordbThread*)m_userThreads.FindNext(&find))
    {
        // The fiber cookie is really a ptr to the EE's Thread object,
        // which is exactly what out m_debuggerThreadToken is.
        if ((DWORD)t->m_debuggerThreadToken == fiberCookie)
            break;
    }

    Unlock();

    INPROC_UNLOCK();
    
    if (t == NULL)
        return S_FALSE;
    else
    {
        *ppThread = (ICorDebugThread*)t;
        (*ppThread)->AddRef();

        return S_OK;
    }
}

HRESULT CordbProcess::GetHelperThreadID(DWORD *pThreadID)
{
    if (pThreadID == NULL)
        return (E_INVALIDARG);

    // Return the ID of the current helper thread. There may be no thread in the process, or there may be a true helper
    // thread.
    if ((m_helperThreadId != 0) && !m_helperThreadDead)
        *pThreadID = m_helperThreadId;
    else if ((m_DCB != NULL) && (m_DCB->m_helperThreadId != 0))
        *pThreadID = m_DCB->m_helperThreadId;
    else
        *pThreadID = 0;

    return S_OK;
}

HRESULT CordbProcess::SetAllThreadsDebugState(CorDebugThreadState state,
                                              ICorDebugThread *pExceptThread)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pExceptThread,ICorDebugThread *);

    CORDBLeftSideDeadIsOkay(this);
    CORDBSyncFromWin32StopIfNecessary(this);
    CORDBRequireProcessStateOKAndSync(this, NULL);
    
    CordbThread *et = (CordbThread*)pExceptThread;
    
    LOG((LF_CORDB, LL_INFO1000, "CP::SATDS: except thread=0x%08x 0x%x\n", pExceptThread, et != NULL ? et->m_id : 0));

    // Send one event to the Left Side to twiddle each thread's state.
    DebuggerIPCEvent event;
    InitIPCEvent(&event, DB_IPCE_SET_ALL_DEBUG_STATE, true, NULL);
    event.SetAllDebugState.debuggerExceptThreadToken = et != NULL ? et->m_debuggerThreadToken : NULL;
    event.SetAllDebugState.debugState = state;

    HRESULT hr = SendIPCEvent(&event, sizeof(DebuggerIPCEvent));

    // If that worked, then loop over all the threads on this side and set their states.
    if (SUCCEEDED(hr))
    {
        HASHFIND        find;
        CordbThread    *thread;
    
        for (thread = (CordbThread*)m_userThreads.FindFirst(&find);
             thread != NULL;
             thread = (CordbThread*)m_userThreads.FindNext(&find))
        {
            if (thread != et)
                thread->m_debugState = state;
        }
    }

    return hr;
#endif //RIGHT_SIDE_ONLY    
}


HRESULT CordbProcess::EnumerateObjects(ICorDebugObjectEnum **ppObjects)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    /* !!! */
    VALIDATE_POINTER_TO_OBJECT(ppObjects, ICorDebugObjectEnum **);

    return E_NOTIMPL;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbProcess::IsTransitionStub(CORDB_ADDRESS address, BOOL *pbTransitionStub)
{
#ifdef RIGHT_SIDE_ONLY
    VALIDATE_POINTER_TO_OBJECT(pbTransitionStub, BOOL *);

    // Default to FALSE
    *pbTransitionStub = FALSE;
    
    CORDBLeftSideDeadIsOkay(this);

    // If we're not initialized, then it can't be a stub...
    if (!m_initialized)
        return S_OK;
    
    CORDBRequireProcessStateOK(this);
    CORDBSyncFromWin32StopIfNecessary(this);

    LOG((LF_CORDB, LL_INFO1000, "CP::ITS: addr=0x%08x\n", address));
    
    DebuggerIPCEvent *event = 
      (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);

    InitIPCEvent(event, DB_IPCE_IS_TRANSITION_STUB, true, NULL);

    event->IsTransitionStub.address = (void*) address;

    HRESULT hr = SendIPCEvent(event, CorDBIPC_BUFFER_SIZE);

    if (FAILED(hr))
        return hr;

    _ASSERTE(event->type == DB_IPCE_IS_TRANSITION_STUB_RESULT);

    *pbTransitionStub = event->IsTransitionStubResult.isStub;

    return S_OK;
#else 
    return CORDBG_E_INPROC_NOT_IMPL;
#endif //RIGHT_SIDE_ONLY    
}


HRESULT CordbProcess::SetStopState(DWORD threadID, CorDebugThreadState state)
{
#ifdef RIGHT_SIDE_ONLY
    return E_NOTIMPL;
#else 
    return CORDBG_E_INPROC_NOT_IMPL;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbProcess::IsOSSuspended(DWORD threadID, BOOL *pbSuspended)
{
#ifdef RIGHT_SIDE_ONLY
    // Gotta have a place for the result!
    if (!pbSuspended)
        return E_INVALIDARG;

    // Have we seen this thread?
    CordbUnmanagedThread *ut = GetUnmanagedThread(threadID);

    // If we have, and if we've suspended it, then say so.
    if (ut && ut->IsSuspended())
        *pbSuspended = TRUE;
    else
        *pbSuspended = FALSE;

    return S_OK;
#else 
    VALIDATE_POINTER_TO_OBJECT(pbSuspended, BOOL *);

    return CORDBG_E_INPROC_NOT_IMPL;
#endif //RIGHT_SIDE_ONLY    
}

//
// This routine reads a thread context from the process being debugged, taking into account the fact that the context
// record may be a different size than the one we compiled with. On systems < NT5, then OS doesn't usually allocate
// space for the extended registers. However, the CONTEXT struct that we compile with does have this space.
//
HRESULT CordbProcess::SafeReadThreadContext(void *pRemoteContext, CONTEXT *pCtx)
{
    HRESULT hr = S_OK;
    DWORD nRead = 0;
    
    // At a minimum we have room for a whole context up to the extended registers.
    DWORD minContextSize = offsetof(CONTEXT, ExtendedRegisters);

    // The extended registers are optional...
    DWORD extRegSize = sizeof(CONTEXT) - minContextSize;

    // Start of the extended registers, in the remote process and in the current process
    void *pRmtExtReg = (void*)((UINT_PTR)pRemoteContext + minContextSize);
    void *pCurExtReg = (void*)((UINT_PTR)pCtx + minContextSize);

    // Read the minimum part.
    BOOL succ = ReadProcessMemoryI(m_handle, pRemoteContext, pCtx, minContextSize, &nRead);

    if (!succ || (nRead != minContextSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // Now, read the extended registers if the context contains them. If the context does not have extended registers,
    // just set them to zero.
    if (SUCCEEDED(hr) && (pCtx->ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS)
    {
        succ = ReadProcessMemoryI(m_handle, pRmtExtReg, pCurExtReg, extRegSize, &nRead);

        if (!succ || (nRead != extRegSize))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        memset(pCurExtReg, 0, extRegSize);
    }

    return hr;
}

//
// This routine writes a thread context to the process being debugged, taking into account the fact that the context
// record may be a different size than the one we compiled with. On systems < NT5, then OS doesn't usually allocate
// space for the extended registers. However, the CONTEXT struct that we compile with does have this space.
//
HRESULT CordbProcess::SafeWriteThreadContext(void *pRemoteContext, CONTEXT *pCtx)
{
    HRESULT hr = S_OK;
    DWORD nWritten = 0;
    DWORD sizeToWrite = 0;

    // If our context has extended registers, then write the whole thing. Otherwise, just write the minimum part.
    if ((pCtx->ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS)
        sizeToWrite = sizeof(CONTEXT);
    else
        sizeToWrite = offsetof(CONTEXT, ExtendedRegisters);

    // Write the context.
    BOOL succ = WriteProcessMemory(m_handle, pRemoteContext, pCtx, sizeToWrite, &nWritten);

    if (!succ || (nWritten != sizeToWrite))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


HRESULT CordbProcess::GetThreadContext(DWORD threadID, ULONG32 contextSize, BYTE context[])
{
#ifdef RIGHT_SIDE_ONLY  // This is not permitted in-proc

    if (contextSize != sizeof(CONTEXT))
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::GTC: thread=0x%x, context size is invalid.\n", threadID));
        return E_INVALIDARG;
    }

    VALIDATE_POINTER_TO_OBJECT_ARRAY(context, BYTE, contextSize, true, true);

    // Find the unmanaged thread
    CordbUnmanagedThread *ut = GetUnmanagedThread(threadID);

    if (ut == NULL)
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::GTC: thread=0x%x, thread id is invalid.\n", threadID));

        return E_INVALIDARG;
    }

    // If the thread is first chance hijacked, then read the context from the remote process. If the thread is generic
    // hijacked, then we have a copy of the thread's context already. Otherwise call the normal Win32 function.
	HRESULT hr = S_OK;
    
    LOG((LF_CORDB, LL_INFO10000, "CP::GTC: thread=0x%x, flags=0x%x.\n", threadID, ((CONTEXT*)context)->ContextFlags));
    
    if (ut->IsFirstChanceHijacked() || ut->IsHideFirstChanceHijackState())
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::GTC: getting context from first chance hijack, addr=0x%08x.\n",
             ut->m_pLeftSideContext));

        // Read the context into a temp context then copy to the out param.
        CONTEXT tempContext;
        
        hr = SafeReadThreadContext(ut->m_pLeftSideContext, &tempContext);

        if (SUCCEEDED(hr))
            _CopyThreadContext((CONTEXT*)context, &tempContext);
    }
    else if (ut->IsGenericHijacked() || ut->IsSecondChanceHijacked())
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::GTC: getting context from generic/2nd chance hijack.\n"));

        _CopyThreadContext((CONTEXT*)context, &(ut->m_context));
    }
    else
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::GTC: getting context from win32.\n"));
        
        BOOL succ = ::GetThreadContext(ut->m_handle, (CONTEXT*)context);

        if (!succ)
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    LOG((LF_CORDB, LL_INFO10000,
         "CP::GTC: Eip=0x%08x, Esp=0x%08x, Eflags=0x%08x\n", ((CONTEXT*)context)->Eip, ((CONTEXT*)context)->Esp,
         ((CONTEXT*)context)->EFlags));
    
    return hr;

#else  // In-proc

    return (CORDBG_E_INPROC_NOT_IMPL);

#endif
}

HRESULT CordbProcess::SetThreadContext(DWORD threadID, ULONG32 contextSize, BYTE context[])
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    if (contextSize != sizeof(CONTEXT))
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::STC: thread=0x%x, context size is invalid.\n", threadID));
        return E_INVALIDARG;
    }

    VALIDATE_POINTER_TO_OBJECT_ARRAY(context, BYTE, contextSize, true, true);
    
    // Find the unmanaged thread
    CordbUnmanagedThread *ut = GetUnmanagedThread(threadID);

    if (ut == NULL)
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::STC: thread=0x%x, thread is invalid.\n", threadID));
        return E_INVALIDARG;
    }

    LOG((LF_CORDB, LL_INFO10000,
         "CP::STC: thread=0x%x, flags=0x%x.\n", threadID, ((CONTEXT*)context)->ContextFlags));
    
    LOG((LF_CORDB, LL_INFO10000,
         "CP::STC: Eip=0x%08x, Esp=0x%08x, Eflags=0x%08x\n", ((CONTEXT*)context)->Eip, ((CONTEXT*)context)->Esp,
         ((CONTEXT*)context)->EFlags));
    
    // If the thread is first chance hijacked, then write the context into the remote process. If the thread is generic
    // hijacked, then update the copy of the context that we already have. Otherwise call the normal Win32 function.
    HRESULT hr = S_OK;
    
    if (ut->IsFirstChanceHijacked() || ut->IsHideFirstChanceHijackState())
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::STC: setting context from first chance hijack, addr=0x%08x.\n",
             ut->m_pLeftSideContext));

        // Grab the context from the left side into a temporary context, do the proper copy, then shove it back.
        CONTEXT tempContext;

        hr = SafeReadThreadContext(ut->m_pLeftSideContext, &tempContext);

        if (SUCCEEDED(hr))
        {
            LOG((LF_CORDB, LL_INFO10000,
                 "CP::STC: current FCH context: Eip=0x%08x, Esp=0x%08x, Eflags=0x%08x\n",
                 tempContext.Eip, tempContext.Esp, tempContext.EFlags));
            
            _CopyThreadContext(&tempContext, (CONTEXT*)context);
            
            hr = SafeWriteThreadContext(ut->m_pLeftSideContext, &tempContext);
        }
    }
    else if (ut->IsGenericHijacked() || ut->IsSecondChanceHijacked()) 
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::STC: setting context from generic/2nd chance hijack.\n"));

        _CopyThreadContext(&(ut->m_context), (CONTEXT*)context);
    }
    else
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::STC: setting context from win32.\n"));
        
        BOOL succ = ::SetThreadContext(ut->m_handle, (CONTEXT*)context);

        if (!succ)
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (SUCCEEDED(hr))
    {
        // Find the managed thread
        CordbThread *pTh = (CordbThread *) m_userThreads.GetBase(threadID);
 
        if (pTh != NULL)
        {
            if (pTh->m_stackChains != NULL && pTh->m_stackChainCount > 0)
            {
                if (pTh->m_stackChains[0]->m_managed == false)
                {
                    CONTEXT *pContext = (CONTEXT *) context;
                    pTh->m_stackChains[0]->m_rd.PC = pContext->Eip;
                    pTh->m_stackChains[0]->m_rd.Eax = pContext->Eax;
                    pTh->m_stackChains[0]->m_rd.Ebx = pContext->Ebx;
                    pTh->m_stackChains[0]->m_rd.Ecx = pContext->Ecx;
                    pTh->m_stackChains[0]->m_rd.Edx = pContext->Edx;
                    pTh->m_stackChains[0]->m_rd.Esi = pContext->Esi;
                    pTh->m_stackChains[0]->m_rd.Edi = pContext->Edi;
                    pTh->m_stackChains[0]->m_rd.Esp = pContext->Esp;
                    pTh->m_stackChains[0]->m_rd.Ebp = pContext->Ebp;
                }
            }
        }
    }
  
    return hr;
#endif //RIGHT_SIDE_ONLY    
}


HRESULT CordbProcess::ReadMemory(CORDB_ADDRESS address, 
                                 DWORD size,
                                 BYTE buffer[], 
                                 LPDWORD read)
{
    // A read of 0 bytes is okay.
    if (size == 0)
        return S_OK;

    VALIDATE_POINTER_TO_OBJECT_ARRAY(buffer, BYTE, size, true, true);
    VALIDATE_POINTER_TO_OBJECT(buffer, SIZE_T *);
    
    if (address == NULL)
        return E_INVALIDARG;

    *read = 0;

	INPROC_LOCK();

    HRESULT hr = S_OK;
    HRESULT hrSaved = hr; // this will hold the 'real' hresult in case of a partially completed operation.
    HRESULT hrPartialCopy = HRESULT_FROM_WIN32(ERROR_PARTIAL_COPY);

    // Win98 will allow us to read from an area, despite the fact that we shouldn't be allowed to Make sure we don't.
    if (RunningOnWin95())
    {
        MEMORY_BASIC_INFORMATION mbi;
        DWORD okProt = (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE);
        DWORD badFlag = PAGE_GUARD;

        DWORD dw = VirtualQueryEx(m_handle, (void *)address, &mbi, sizeof(MEMORY_BASIC_INFORMATION));

        if (dw != sizeof(MEMORY_BASIC_INFORMATION))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOACCESS);
            goto LExit;
        }

        for (DWORD i = 0; i < size; )
        {
            if ((mbi.State == MEM_COMMIT) && mbi.Protect & okProt && ((mbi.Protect & badFlag) == 0))
            {
                i += mbi.RegionSize;
                
                dw = VirtualQueryEx(m_handle, (void *) (address + (CORDB_ADDRESS)i), &mbi, sizeof(MEMORY_BASIC_INFORMATION));

                if (dw != sizeof(MEMORY_BASIC_INFORMATION))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOACCESS);
                    goto LExit;
                }

                continue;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOACCESS);
                goto LExit;
            }
        }
    }
    
    CORDBRequireProcessStateOK(this);

    //grab the memory we want to read
    if (ReadProcessMemoryI(m_handle, (LPCVOID)address, buffer, size, read) == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        if (hr != hrPartialCopy)
            goto LExit;
        else
            hrSaved = hr;
    }
    
    // There seem to be strange cases where ReadProcessMemory will return a seemingly negative number into *read, which
    // is an unsigned value. So we check the sanity of *read by ensuring that its no bigger than the size we tried to
    // read.
    if ((*read > 0) && (*read <= size))
    {
        LOG((LF_CORDB, LL_INFO100000, "CP::RM: read %d bytes from 0x%08x, first byte is 0x%x\n",
             *read, (DWORD)address, buffer[0]));
        
        if (m_initialized)
        {
            // If m_pPatchTable is NULL, then it's been cleaned out b/c of a Continue for the left side.  Get the table
            // again. Only do this, of course, if the managed state of the process is initialized.
            if (m_pPatchTable == NULL)
            {
                hr = RefreshPatchTable(address, *read, buffer);
            }
            else
            {
                // The previously fetched table is still good, so run through it & see if any patches are applicable
                hr = AdjustBuffer(address, *read, buffer, NULL, AB_READ);
            }
        }
    }

LExit:    
    if (FAILED(hr))
    {
        ClearPatchTable();
    }   
    else if (FAILED(hrSaved))
    {
        hr = hrSaved;
    }

	INPROC_UNLOCK();

    return hr;
}

HRESULT CordbProcess::AdjustBuffer( CORDB_ADDRESS address,
                                    SIZE_T size,
                                    BYTE buffer[],
                                    BYTE **bufferCopy,
                                    AB_MODE mode,
                                    BOOL *pbUpdatePatchTable)
{
    _ASSERTE(m_initialized);
    
    if (    address == NULL
         || size == NULL
         || buffer == NULL
         || (mode != AB_READ && mode != AB_WRITE) )
        return E_INVALIDARG;

    if (pbUpdatePatchTable != NULL )
        *pbUpdatePatchTable = FALSE;

    // If we don't have a patch table loaded, then return S_OK since there are no patches to adjust
    if (m_pPatchTable == NULL)
        return S_OK;

    //is the requested memory completely out-of-range?
    if ((m_minPatchAddr > (address + (size - 1))) ||
        (m_maxPatchAddr < address))
    {
        return S_OK;
    }
        
    USHORT iNextFree = m_iFirstPatch;
    while( iNextFree != DPT_TERMINATING_INDEX )
    {
        BYTE *DebuggerControllerPatch = m_pPatchTable +
            m_runtimeOffsets.m_cbPatch*iNextFree;
        DWORD opcode = *(DWORD *)(DebuggerControllerPatch +
                                  m_runtimeOffsets.m_offOpcode);
        BYTE *patchAddress = *(BYTE**)(DebuggerControllerPatch +
                                       m_runtimeOffsets.m_offAddr);

        if ((PTR_TO_CORDB_ADDRESS(patchAddress) >= address) &&
            (PTR_TO_CORDB_ADDRESS(patchAddress) <= (address+(size-1))))
        {
            if (mode == AB_READ )
            {
                CORDbgSetInstruction( buffer+(PTR_TO_CORDB_ADDRESS(patchAddress)
                                              -address), opcode);
            }
            else if (mode == AB_WRITE )
            {
                _ASSERTE( pbUpdatePatchTable != NULL );
                _ASSERTE( bufferCopy != NULL );

                // We don't want to mess up the original copy of the buffer, so
                // for right now, just copy it wholesale.
                (*bufferCopy) = new BYTE[size];
                if (NULL == (*bufferCopy))
                    return E_OUTOFMEMORY;

                memmove((*bufferCopy), buffer, size);
                
                // Copy this back to the copy of the patch table.
                // @todo port: this is X86 specific
                if ( *(buffer+(PTR_TO_CORDB_ADDRESS(patchAddress)-address)) != (BYTE)0xCC)
                {
                    //There can be multiple patches at the same address:
                    //we don't want 2nd+ patches to get the break opcode
                    
                    m_rgUncommitedOpcode[iNextFree] = 
                        (unsigned int) CORDbgGetInstruction(
                                buffer+(PTR_TO_CORDB_ADDRESS(patchAddress)-address) );
                    //put the breakpoint into the memory itself
                    CORDbgInsertBreakpoint(buffer+(PTR_TO_CORDB_ADDRESS(patchAddress)
                                                   -address));
                }
                else
                { 
                    // One of two situations exists: a prior patch for this address
                    // has been found already (which is why it's patched), or it's
                    // not ours at all.  If the first situation exists, then simply
                    // copy the opcode to here.  Otherwise ignore the breakpoint
                    // since it's not ours & thus we don't care.
                    USHORT iNextSearch = m_iFirstPatch;
                    bool fFound = false;
                    while( iNextSearch != DPT_TERMINATING_INDEX  &&
                           iNextSearch < iNextFree)
                    {
                        BYTE *DCPatchSearch = m_pPatchTable +
                            m_runtimeOffsets.m_cbPatch*iNextSearch;
                        BYTE *patchAddressSearch=*(BYTE**)(DCPatchSearch
                                                + m_runtimeOffsets.m_offAddr);

                        if (patchAddressSearch == patchAddress)
                        {
                            // Copy the previous opcode into the current
                            // patch.
                            m_rgUncommitedOpcode[iNextFree] =
                                m_rgUncommitedOpcode[iNextSearch];
                            fFound = true;
                            break;
                        }

                        iNextSearch = m_rgNextPatch[iNextSearch];
                    }
                    // Must be somebody else's - trash it.
                    if( !fFound )
                    {
                        m_rgUncommitedOpcode[iNextFree] = 
                            (unsigned int) CORDbgGetInstruction(
                                buffer+(PTR_TO_CORDB_ADDRESS(patchAddress)-address) );
                        //put the breakpoint into the memory itself
                        CORDbgInsertBreakpoint(buffer+(PTR_TO_CORDB_ADDRESS(patchAddress)
                                                   -address));
                    }
                }
                    *pbUpdatePatchTable = TRUE;
            }
            else
                _ASSERTE( !"CordbProcess::AdjustBuffergiven non(Read|Write) mode!" );
        }

        iNextFree = m_rgNextPatch[iNextFree];
    }

    return S_OK;
}


void CordbProcess::CommitBufferAdjustments( CORDB_ADDRESS start,
                                            CORDB_ADDRESS end )
{
    _ASSERTE(m_initialized);
    
    USHORT iPatch = m_iFirstPatch;
    while( iPatch != DPT_TERMINATING_INDEX )
    {
        BYTE *DebuggerControllerPatch = m_pPatchTable +
            m_runtimeOffsets.m_cbPatch*iPatch;

        BYTE *patchAddress = *(BYTE**)(DebuggerControllerPatch +
                                       m_runtimeOffsets.m_offAddr);

        if (PTR_TO_CORDB_ADDRESS(patchAddress) >= start &&
            PTR_TO_CORDB_ADDRESS(patchAddress) <= end &&
            m_rgUncommitedOpcode[iPatch] != 0xCC)
        {
#ifdef _ALPHA_
        _ASSERTE(!"@TODO Alpha - CommitBufferAdjustments (Process.cpp)");
#endif //_ALPHA_
            //copy this back to the copy of the patch table
            *(unsigned int *)(DebuggerControllerPatch +
                              m_runtimeOffsets.m_offOpcode) =
                m_rgUncommitedOpcode[iPatch];
        }

        iPatch = m_rgNextPatch[iPatch];
    }
}

void CordbProcess::ClearBufferAdjustments( )
{
    USHORT iPatch = m_iFirstPatch;
    while( iPatch != DPT_TERMINATING_INDEX )
    {
        BYTE *DebuggerControllerPatch = m_pPatchTable +
            m_runtimeOffsets.m_cbPatch*iPatch;
        DWORD opcode = *(DWORD *)(DebuggerControllerPatch +
                                  m_runtimeOffsets.m_offOpcode);
#ifdef _X86_
        m_rgUncommitedOpcode[iPatch] = 0xCC;
#else
        _ASSERTE(!"@TODO Alpha - ClearBufferAdjustments (Pocess.cpp)");
#endif //_X86_

        iPatch = m_rgNextPatch[iPatch];
    }
}

void CordbProcess::ClearPatchTable(void )
{
    if (m_pPatchTable != NULL )
    {
        delete [] m_pPatchTable;
        m_pPatchTable = NULL;

        delete [] m_rgNextPatch;
        m_rgNextPatch = NULL;

        delete [] m_rgUncommitedOpcode;
        m_rgUncommitedOpcode = NULL;

        m_iFirstPatch = DPT_TERMINATING_INDEX;
        m_minPatchAddr = MAX_ADDRESS;
        m_maxPatchAddr = MIN_ADDRESS;
        m_rgData = NULL;
        m_cPatch = 0;
    }
}

HRESULT CordbProcess::RefreshPatchTable(CORDB_ADDRESS address, SIZE_T size, BYTE buffer[])
{
    _ASSERTE(m_initialized);
    
    HRESULT hr = S_OK;
    BYTE *rgb = NULL;    
    DWORD dwRead = 0;
    BOOL fOk = false;

    _ASSERTE( m_runtimeOffsets.m_cbOpcode == sizeof(DWORD) );
    
    CORDBRequireProcessStateOK(this);
    
    if (m_pPatchTable == NULL )
    {
        // First, check to be sure the patch table is valid on the Left Side. If its not, then we won't read it.
        BOOL fPatchTableValid = FALSE;

        fOk = ReadProcessMemoryI(m_handle, m_runtimeOffsets.m_pPatchTableValid,
                                 &fPatchTableValid, sizeof(fPatchTableValid), &dwRead);

        if (!fOk || (dwRead != sizeof(fPatchTableValid)) || !fPatchTableValid)
        {
            LOG((LF_CORDB, LL_INFO10000, "Wont refresh patch table because its not valid now.\n"));
            return S_OK;
        }
        
        SIZE_T offStart = 0;
        SIZE_T offEnd = 0;
        UINT cbTableSlice = 0;

        UINT cbRgData = 0;

        // Grab the patch table info
        offStart = min(m_runtimeOffsets.m_offRgData, m_runtimeOffsets.m_offCData);
        offEnd   = max(m_runtimeOffsets.m_offRgData, m_runtimeOffsets.m_offCData) + sizeof(SIZE_T);
        cbTableSlice = offEnd - offStart;

        if (cbTableSlice == 0)
        {
            LOG((LF_CORDB, LL_INFO10000, "Wont refresh patch table because its not valid now.\n"));
            return S_OK;
        }
        
        rgb = new BYTE[cbTableSlice];
        
        if (rgb == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }
    
        fOk = ReadProcessMemoryI(m_handle, (BYTE*)m_runtimeOffsets.m_pPatches + offStart,
                                 rgb, cbTableSlice, &dwRead);

        if ( !fOk || (dwRead != cbTableSlice ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto LExit;
        }

        // Note that rgData is a pointer in the left side address space
        m_rgData = *(BYTE**)(rgb + m_runtimeOffsets.m_offRgData - offStart);
        m_cPatch = *(USHORT*)(rgb + m_runtimeOffsets.m_offCData - offStart);

        // Grab the patch table
        UINT cbPatchTable = m_cPatch * m_runtimeOffsets.m_cbPatch;

        if (cbPatchTable == 0)
        {
            LOG((LF_CORDB, LL_INFO10000, "Wont refresh patch table because its not valid now.\n"));
            return S_OK;
        }
        
        m_pPatchTable = new BYTE[ cbPatchTable ];
        m_rgNextPatch = new USHORT[m_cPatch];
        m_rgUncommitedOpcode = new DWORD[m_cPatch];
        
        if (m_pPatchTable == NULL || m_rgNextPatch == NULL || m_rgUncommitedOpcode == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }

        fOk = ReadProcessMemoryI(m_handle, m_rgData, m_pPatchTable, cbPatchTable, &dwRead);

        if ( !fOk || (dwRead != cbPatchTable ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto LExit;
        }

        //As we go through the patch table we do three things:
        //
        // 1. collect min,max address seen for quick fail check
        //
        // 2. Link all valid entries into a linked list, the first entry of which is m_iFirstPatch
        //
        // 3. Initialize m_rgUncommitedOpcode, so that we can undo local patch table changes if WriteMemory can't write
        // atomically.
        //
        // 4. If the patch is in the memory we grabbed, unapply it.

        USHORT iDebuggerControllerPatchPrev = DPT_TERMINATING_INDEX;

        m_minPatchAddr = MAX_ADDRESS;
        m_maxPatchAddr = MIN_ADDRESS;
        m_iFirstPatch = DPT_TERMINATING_INDEX;

        for (USHORT iPatch = 0; iPatch < m_cPatch;iPatch++)
        {
            // @todo port: we're making assumptions about the size of opcodes,address pointers, etc
            BYTE *DebuggerControllerPatch = m_pPatchTable + m_runtimeOffsets.m_cbPatch * iPatch;
            DWORD opcode = *(DWORD*)(DebuggerControllerPatch + m_runtimeOffsets.m_offOpcode);
            BYTE *patchAddress = *(BYTE**)(DebuggerControllerPatch + m_runtimeOffsets.m_offAddr);
                        
            // A non-zero opcode indicates to us that this patch is valid.
            if (opcode != 0)
            {
                _ASSERTE( patchAddress != 0 );

                // (1), above
                if (m_minPatchAddr > PTR_TO_CORDB_ADDRESS(patchAddress) )
                    m_minPatchAddr = PTR_TO_CORDB_ADDRESS(patchAddress);
                if (m_maxPatchAddr < PTR_TO_CORDB_ADDRESS(patchAddress) )
                    m_maxPatchAddr = PTR_TO_CORDB_ADDRESS(patchAddress);

                // (2), above
                if ( m_iFirstPatch == DPT_TERMINATING_INDEX)
                {
                    m_iFirstPatch = iPatch;
                    _ASSERTE( iPatch != DPT_TERMINATING_INDEX);
                }

                if (iDebuggerControllerPatchPrev != DPT_TERMINATING_INDEX)
                {
                    m_rgNextPatch[iDebuggerControllerPatchPrev] = iPatch;
                }

                iDebuggerControllerPatchPrev = iPatch;

                // (3), above
#ifdef _X86_
                m_rgUncommitedOpcode[iPatch] = 0xCC;
#endif _X86_
                
                // (4), above
                if  (address != NULL && 
                    PTR_TO_CORDB_ADDRESS(patchAddress) >= address && PTR_TO_CORDB_ADDRESS(patchAddress) <= address + (size - 1))
                {
                    _ASSERTE( buffer != NULL );
                    _ASSERTE( size != NULL );
                    
                    //unapply the patch here.
                    CORDbgSetInstruction(buffer + (PTR_TO_CORDB_ADDRESS(patchAddress) - address), opcode);
                }
            }
        }
        
        if (iDebuggerControllerPatchPrev != DPT_TERMINATING_INDEX)
            m_rgNextPatch[iDebuggerControllerPatchPrev] = DPT_TERMINATING_INDEX;
    }

 LExit:
    if (rgb != NULL )
        delete [] rgb;

    if (FAILED( hr ) )
        ClearPatchTable();

    return hr;
}

//
// Given an address, see if there is a patch in the patch table that matches it and return if its an unmanaged patch or
// not.
//
// Note: this method is pretty in-efficient. It refreshes the patch table, then scans it. Refreshing the patch table
// involves a scan, too, so this method could be folded with that.
//
HRESULT CordbProcess::FindPatchByAddress(CORDB_ADDRESS address, bool *patchFound, bool *patchIsUnmanaged)
{
    _ASSERTE(patchFound != NULL && patchIsUnmanaged != NULL);
    
    *patchFound = false;
    *patchIsUnmanaged = false;

    // First things first. If the process isn't initialized, then there can be no patch table, so we know the breakpoint
    // doesn't belong to the Runtime.
    if (!m_initialized)
        return S_OK;
    
    // This method is called from the main loop of the win32 event thread in response to a first chance breakpoint event
    // that we know is not a flare. The process has been runnning, and it may have invalidated the patch table, so we'll
    // flush it here before refreshing it to make sure we've got the right thing.
    //
    // Note: we really should have the Left Side mark the patch table dirty to help optimize this.
    ClearPatchTable();

    // Refresh the patch table.
    HRESULT hr = RefreshPatchTable();

    if (FAILED(hr))
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::FPBA: failed to refresh the patch table\n"));
        return hr;
    }

    // If there is no patch table yet, then we know there is no patch at the given address, so return S_OK with
    // *patchFound = false.
    if (m_pPatchTable == NULL)
    {
        LOG((LF_CORDB, LL_INFO1000, "CP::FPBA: no patch table\n"));
        return S_OK;
    }

    // Scan the patch table for a matching patch.
    for (USHORT iNextPatch = m_iFirstPatch; iNextPatch != DPT_TERMINATING_INDEX; iNextPatch = m_rgNextPatch[iNextPatch])
    {
        BYTE *patch = m_pPatchTable + (m_runtimeOffsets.m_cbPatch * iNextPatch);
        BYTE *patchAddress = *(BYTE**)(patch + m_runtimeOffsets.m_offAddr);
        DWORD traceType = *(DWORD*)(patch + m_runtimeOffsets.m_offTraceType);

        if (address == PTR_TO_CORDB_ADDRESS(patchAddress))
        {
            *patchFound = true;

            if (traceType == m_runtimeOffsets.m_traceTypeUnmanaged)
                *patchIsUnmanaged = true;
            
            break;
        }
    }

    // If we didn't find a patch, its actually still possible that this breakpoint exception belongs to us. There are
    // races with very large numbers of threads entering the Runtime through the same managed function. We will have
    // multiple threads adding and removing ref counts to an int 3 in the code stream. Sometimes, this count will go to
    // zero and the int 3 will be removed, then it will come back up and the int 3 will be replaced. The in-process
    // logic takes pains to ensure that such cases are handled properly, therefore we need to perform the same check
    // here to make the correct decision. Basically, the check is to see if there is indeed an int 3 at the exception
    // address. If there is _not_ an int 3 there, then we've hit this race. We will lie and say a managed patch was
    // found to cover this case. This is tracking the logic in DebuggerController::ScanForTriggers, where we call
    // IsPatched.
    if (*patchFound == false)
    {
        // Read one byte from the faulting address...
#ifdef _X86_
        BYTE int3Check = 0;
        
        BOOL succ = ReadProcessMemoryI(m_handle, (void*)address, &int3Check, sizeof(int3Check), NULL);

        if (succ && (int3Check != 0xcc))
        {
            LOG((LF_CORDB, LL_INFO1000, "CP::FPBA: patchFound=true based on odd missing int 3 case.\n"));
            
            *patchFound = true;
        }
#endif        
    }
    
    LOG((LF_CORDB, LL_INFO1000, "CP::FPBA: patchFound=%d, patchIsUnmanaged=%d\n", *patchFound, *patchIsUnmanaged));
    
    return S_OK;
}

HRESULT CordbProcess::WriteMemory(CORDB_ADDRESS address, DWORD size,
                                  BYTE buffer[], LPDWORD written)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    CORDBRequireProcessStateOK(this);

    if (size == 0 || address == NULL)
        return E_INVALIDARG;

    VALIDATE_POINTER_TO_OBJECT_ARRAY(buffer, BYTE, size, true, true);
    VALIDATE_POINTER_TO_OBJECT(written, SIZE_T *);
    
    *written = 0;
    
    HRESULT hr = S_OK;
    HRESULT hrSaved = hr; // this will hold the 'real' hresult in case of a 
                          // partially completed operation
    HRESULT hrPartialCopy = HRESULT_FROM_WIN32(ERROR_PARTIAL_COPY);

    DWORD dwWritten = 0;
    BOOL bUpdateOriginalPatchTable = FALSE;
    BYTE *bufferCopy = NULL;
    
    // Win98 will allow us to
    // write to an area, despite the fact that
    // we shouldn't be allowed to
    // Make sure we don't.
    if( RunningOnWin95() )
    {
        MEMORY_BASIC_INFORMATION mbi;
        DWORD okProt = (PAGE_READWRITE|PAGE_WRITECOPY|PAGE_EXECUTE_READWRITE|
                      PAGE_EXECUTE_WRITECOPY);
        DWORD badFlag = PAGE_GUARD;

        DWORD dw = VirtualQueryEx(  m_handle,(void *)address, &mbi,sizeof(MEMORY_BASIC_INFORMATION));
        _ASSERTE( dw == sizeof(MEMORY_BASIC_INFORMATION));

        for( DWORD i = 0; i < size;)
        {
            if(mbi.State == MEM_COMMIT &&
               mbi.Protect & okProt &&
              (mbi.Protect & badFlag)==0)
            {
                i+=mbi.RegionSize;
                dw = VirtualQueryEx(m_handle, (void *)
                                    (address+(CORDB_ADDRESS)i),&mbi,
                                    sizeof(MEMORY_BASIC_INFORMATION));
                _ASSERTE( dw == sizeof(MEMORY_BASIC_INFORMATION));
                
                continue;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOACCESS);
                goto LExit;
            }
        }
    }

    // Only update the patch table if the managed state of the process
    // is initialized.
    if (m_initialized)
    {
        if (m_pPatchTable == NULL )
        {
            if (!SUCCEEDED( hr = RefreshPatchTable() ) )
            {
                goto LExit;
            }
        }

        if ( !SUCCEEDED( hr = AdjustBuffer( address,
                                            size,
                                            buffer,
                                            &bufferCopy,
                                            AB_WRITE,
                                            &bUpdateOriginalPatchTable)))
        {
            goto LExit;
        }
    }

    //conveniently enough, WPM will fail if it can't complete the entire
    //operation
    if ( WriteProcessMemory( m_handle,
                             (LPVOID)address,
                             buffer,
                             size,
                             written) == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError() );
        if(hr != hrPartialCopy)
            goto LExit;
        else
            hrSaved = hr;
    }

    LOG((LF_CORDB, LL_INFO100000, "CP::WM: wrote %d bytes at 0x%08x, first byte is 0x%x\n",
         *written, (DWORD)address, buffer[0]));

    if (bUpdateOriginalPatchTable == TRUE )
    {
        //don't tweak patch table for stuff that isn't written to LeftSide
        CommitBufferAdjustments( address, address + *written);
        
        // The only way this should be able to fail is if
        //someone else fiddles with the memory protections on the
        //left side while it's frozen
        WriteProcessMemory( m_handle,
                            (LPVOID)m_rgData,
                            m_pPatchTable,
                            m_cPatch*m_runtimeOffsets.m_cbPatch,
                            &dwWritten);
        _ASSERTE( dwWritten ==m_cPatch*m_runtimeOffsets.m_cbPatch);
    }

    // Since we may have
    // overwritten anything (objects, code, etc), we should mark
    // everything as needing to be re-cached.  
    m_continueCounter++;

 LExit:
    if (m_initialized)
        ClearBufferAdjustments( );

    //we messed up our local copy, so get a clean copy the next time
    //we need it
    if (bUpdateOriginalPatchTable==TRUE)
    {
        if (bufferCopy != NULL)
        {
            memmove(buffer, bufferCopy, size);
            delete bufferCopy;
        }
    }
    
    if (FAILED( hr ))
    {
        //we messed up our local copy, so get a clean copy the next time
        //we need it
        if (bUpdateOriginalPatchTable==TRUE)
        {
            ClearPatchTable();
        }
    }
    else if( FAILED(hrSaved) )
    {
        hr = hrSaved;
    }
    
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbProcess::ClearCurrentException(DWORD threadID)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    // There's something wrong if you're calling this an there are no queued unmanaged events.
    if ((m_unmanagedEventQueue == NULL) && (m_outOfBandEventQueue == NULL))
        return E_INVALIDARG;

    // Grab the unmanaged thread object.
    CordbUnmanagedThread *pUThread = GetUnmanagedThread(threadID);

    if (pUThread == NULL)
        return E_INVALIDARG;

    LOG((LF_CORDB, LL_INFO1000, "CP::CCE: tid=0x%x\n", threadID));
    
    // We clear both the IB and OOB event.
    if (pUThread->HasIBEvent())
        pUThread->IBEvent()->SetState(CUES_ExceptionCleared);

    if (pUThread->HasOOBEvent())
        pUThread->OOBEvent()->SetState(CUES_ExceptionCleared);

    // If the thread is first chance hijacked, then set the thread's debugger word to 0 to indicate to it that the
    // exception has been cleared.
    if (pUThread->IsFirstChanceHijacked() || pUThread->IsGenericHijacked() || pUThread->IsSecondChanceHijacked())
    {
        REMOTE_PTR EETlsValue = pUThread->GetEETlsValue();
        HRESULT hr = pUThread->SetEEThreadDebuggerWord(EETlsValue, 0);
        _ASSERTE(SUCCEEDED(hr));
    }

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

CordbUnmanagedThread *CordbProcess::HandleUnmanagedCreateThread(DWORD dwThreadId, HANDLE hThread, void *lpThreadLocalBase)
{
    CordbUnmanagedThread *ut = new CordbUnmanagedThread(this, dwThreadId, hThread, lpThreadLocalBase);

    if (ut != NULL)
    {
        HRESULT hr = m_unmanagedThreads.AddBase(ut);

        if (!SUCCEEDED(hr))
        {
            delete ut;

            LOG((LF_CORDB, LL_INFO10000, "Failed adding unmanaged thread to process!\n"));
            CORDBSetUnrecoverableError(this, hr, 0);
        }
    }
    else
    {
        LOG((LF_CORDB, LL_INFO10000, "New CordbThread failed!\n"));
        CORDBSetUnrecoverableError(this, E_OUTOFMEMORY, 0);
    }

    return ut;
}

//
// Verify that the version info in the control block matches what we expect. The minimum supported protocol from the
// Left Side must be greater or equal to the minimum required protocol of the Right Side. Note: its the Left Side's job
// to conform to whatever protocol the Right Side requires, so long as minimum is supported.
//
HRESULT CordbProcess::VerifyControlBlock(void)
{
    // Fill in the protocol numbers for the Right Side.
    m_DCB->m_rightSideProtocolCurrent = CorDB_RightSideProtocolCurrent;
    m_DCB->m_rightSideProtocolMinSupported = CorDB_RightSideProtocolMinSupported;

    // For V1 the size of the control block must match exactly.
    if (m_DCB->m_DCBSize != sizeof(DebuggerIPCControlBlock))
        return CORDBG_E_INCOMPATIBLE_PROTOCOL;

    // The Left Side has to support at least our minimum required protocol.
    if (m_DCB->m_leftSideProtocolCurrent < m_DCB->m_rightSideProtocolMinSupported)
        return CORDBG_E_INCOMPATIBLE_PROTOCOL;

    // The Left Side has to be able to emulate at least our minimum required protocol.
    if (m_DCB->m_leftSideProtocolMinSupported > m_DCB->m_rightSideProtocolCurrent)
        return CORDBG_E_INCOMPATIBLE_PROTOCOL;

#ifdef _DEBUG
    char buf[MAX_PATH];
    DWORD len = GetEnvironmentVariableA("CORDBG_NotCompatible", buf, sizeof(buf));
    _ASSERTE(len < sizeof(buf));

    if (len > 0)
        return CORDBG_E_INCOMPATIBLE_PROTOCOL;
#endif    
    
    return S_OK;
}

HRESULT CordbProcess::GetRuntimeOffsets(void)
{
    BOOL succ;
    succ = ReadProcessMemoryI(m_handle,
                             m_DCB->m_runtimeOffsets,
                             &m_runtimeOffsets,
                             sizeof(DebuggerIPCRuntimeOffsets),
                             NULL);

    if (!succ)
        return HRESULT_FROM_WIN32(GetLastError());

    LOG((LF_CORDB, LL_INFO10000, "CP::GRO: got runtime offsets: \n"));
    
    LOG((LF_CORDB, LL_INFO10000, "    m_firstChanceHijackFilterAddr=    0x%08x\n",
         m_runtimeOffsets.m_firstChanceHijackFilterAddr));
    LOG((LF_CORDB, LL_INFO10000, "    m_genericHijackFuncAddr=          0x%08x\n",
         m_runtimeOffsets.m_genericHijackFuncAddr));
    LOG((LF_CORDB, LL_INFO10000, "    m_secondChanceHijackFuncAddr=     0x%08x\n",
         m_runtimeOffsets.m_secondChanceHijackFuncAddr));
    LOG((LF_CORDB, LL_INFO10000, "    m_excepForRuntimeBPAddr=          0x%08x\n",
         m_runtimeOffsets.m_excepForRuntimeBPAddr));
    LOG((LF_CORDB, LL_INFO10000, "    m_excepNotForRuntimeBPAddr=       0x%08x\n",
         m_runtimeOffsets.m_excepNotForRuntimeBPAddr));
    LOG((LF_CORDB, LL_INFO10000, "    m_notifyRSOfSyncCompleteBPAddr=   0x%08x\n",
         m_runtimeOffsets.m_notifyRSOfSyncCompleteBPAddr));
    LOG((LF_CORDB, LL_INFO10000, "    m_notifySecondChanceReadyForData= 0x%08x\n",
         m_runtimeOffsets.m_notifySecondChanceReadyForData));
    LOG((LF_CORDB, LL_INFO10000, "    m_TLSIndex=                       0x%08x\n",
         m_runtimeOffsets.m_TLSIndex));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEThreadStateOffset=            0x%08x\n",
         m_runtimeOffsets.m_EEThreadStateOffset));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEThreadStateNCOffset=          0x%08x\n",
         m_runtimeOffsets.m_EEThreadStateNCOffset));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEThreadPGCDisabledOffset=      0x%08x\n",
         m_runtimeOffsets.m_EEThreadPGCDisabledOffset));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEThreadPGCDisabledValue=       0x%08x\n",
         m_runtimeOffsets.m_EEThreadPGCDisabledValue));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEThreadDebuggerWord2Offset=    0x%08x\n",
         m_runtimeOffsets.m_EEThreadDebuggerWord2Offset));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEThreadFrameOffset=            0x%08x\n",
         m_runtimeOffsets.m_EEThreadFrameOffset));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEThreadMaxNeededSize=          0x%08x\n",
         m_runtimeOffsets.m_EEThreadMaxNeededSize));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEThreadSteppingStateMask=      0x%08x\n",
         m_runtimeOffsets.m_EEThreadSteppingStateMask));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEMaxFrameValue=                0x%08x\n",
         m_runtimeOffsets.m_EEMaxFrameValue));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEThreadDebuggerWord1Offset=    0x%08x\n",
         m_runtimeOffsets.m_EEThreadDebuggerWord1Offset));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEThreadCantStopOffset=         0x%08x\n",
         m_runtimeOffsets.m_EEThreadCantStopOffset));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEFrameNextOffset=              0x%08x\n",
         m_runtimeOffsets.m_EEFrameNextOffset));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEBuiltInExceptionCode1=        0x%08x\n",
         m_runtimeOffsets.m_EEBuiltInExceptionCode1));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEBuiltInExceptionCode2=        0x%08x\n",
         m_runtimeOffsets.m_EEBuiltInExceptionCode2));
    LOG((LF_CORDB, LL_INFO10000, "    m_EEIsManagedExceptionStateMask=  0x%08x\n",
         m_runtimeOffsets.m_EEIsManagedExceptionStateMask));
    LOG((LF_CORDB, LL_INFO10000, "    m_pPatches=                       0x%08x\n",
         m_runtimeOffsets.m_pPatches));          
    LOG((LF_CORDB, LL_INFO10000, "    m_offRgData=                      0x%08x\n",
         m_runtimeOffsets.m_offRgData));         
    LOG((LF_CORDB, LL_INFO10000, "    m_offCData=                       0x%08x\n",
         m_runtimeOffsets.m_offCData));          
    LOG((LF_CORDB, LL_INFO10000, "    m_cbPatch=                        0x%08x\n",
         m_runtimeOffsets.m_cbPatch));           
    LOG((LF_CORDB, LL_INFO10000, "    m_offAddr=                        0x%08x\n",
         m_runtimeOffsets.m_offAddr));           
    LOG((LF_CORDB, LL_INFO10000, "    m_offOpcode=                      0x%08x\n",
         m_runtimeOffsets.m_offOpcode));         
    LOG((LF_CORDB, LL_INFO10000, "    m_cbOpcode=                       0x%08x\n",
         m_runtimeOffsets.m_cbOpcode));          
    LOG((LF_CORDB, LL_INFO10000, "    m_offTraceType=                   0x%08x\n",
         m_runtimeOffsets.m_offTraceType));          
    LOG((LF_CORDB, LL_INFO10000, "    m_traceTypeUnmanaged=             0x%08x\n",
         m_runtimeOffsets.m_traceTypeUnmanaged));          

    return S_OK;
}

void CordbProcess::QueueUnmanagedEvent(CordbUnmanagedThread *pUThread, DEBUG_EVENT *pEvent)
{
    _ASSERTE(ThreadHoldsProcessLock());

    LOG((LF_CORDB, LL_INFO10000, "CP::QUE: queued unmanaged event %d for thread 0x%x\n",
         pEvent->dwDebugEventCode, pUThread->m_id));

    // EXIT_THREAD is special. If we receive it for a thread, then either its the first queued event on that thread, or
    // we've already received and queued an event for that thread. We may or may not have dispatched the old
    // event. Regardless, we're gonna go ahead and overwrite the old event with the new EXIT_THREAD event. We should
    // know, however, that we have indeed continued from the old event.
    _ASSERTE((pEvent->dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT) || !pUThread->HasIBEvent() ||
             pUThread->HasSpecialStackOverflowCase());

    // Copy the event into the given thread
    CordbUnmanagedEvent *ue;

    // Use the primary IB event slot unless this is the special stack overflow event case.
    if (!pUThread->HasSpecialStackOverflowCase())
        ue = pUThread->IBEvent();
    else
        ue = pUThread->IBEvent2();
    
    memcpy(&(ue->m_currentDebugEvent), pEvent, sizeof(DEBUG_EVENT));
    ue->m_state = CUES_None;
    ue->m_next = NULL;

    // Enqueue the event.
    if (!pUThread->HasIBEvent() || pUThread->HasSpecialStackOverflowCase())
    {
        pUThread->SetState(CUTS_HasIBEvent);
        
        if (m_unmanagedEventQueue == NULL)
            m_unmanagedEventQueue = ue;
        else
            m_lastQueuedUnmanagedEvent->m_next = ue;

        m_lastQueuedUnmanagedEvent = ue;
        m_lastIBStoppingEvent = ue;
    }
}

void CordbProcess::DequeueUnmanagedEvent(CordbUnmanagedThread *ut)
{
    _ASSERTE(m_unmanagedEventQueue != NULL);
    _ASSERTE(ut->HasIBEvent() || ut->HasSpecialStackOverflowCase());

    CordbUnmanagedEvent *ue;

    if (ut->HasIBEvent())
        ue = ut->IBEvent();
    else
    {
        ue = ut->IBEvent2();

        // Since we're dequeuing the special stack overflow event, we're no longer in the special stack overflow case.
        ut->ClearState(CUTS_HasSpecialStackOverflowCase);
    }
    
    DWORD ec = ue->m_currentDebugEvent.dwDebugEventCode;

    LOG((LF_CORDB, LL_INFO10000, "CP::DUE: dequeue unmanaged event %d for thread 0x%x\n", ec, ut->m_id));
    
    CordbUnmanagedEvent **tmp = &m_unmanagedEventQueue;
    CordbUnmanagedEvent **prev = NULL;

    // Note: this supports out-of-order dequeing of unmanaged events. This is necessary because we queue events even if
    // we're not clear on the ownership question. When we get the answer, and if the event belongs to the Runtime, we go
    // ahead and yank the event out of the queue, wherever it may be.
    while (*tmp && *tmp != ue)
    {
        prev = tmp;
        tmp = &((*tmp)->m_next);
    }

    _ASSERTE(*tmp == ue);

    *tmp = (*tmp)->m_next;

    if (m_unmanagedEventQueue == NULL)
        m_lastQueuedUnmanagedEvent = NULL;
    else if (m_lastQueuedUnmanagedEvent == ue)
    {
        _ASSERTE(prev != NULL);
        m_lastQueuedUnmanagedEvent = *prev;
    }

    ut->ClearState(CUTS_HasIBEvent);

    // If this thread is marked for deletion (exit thread or exit process event on it), then we need to delete the
    // unmanaged thread object.
    if ((ut->IsDeleted()) && ((ec == EXIT_PROCESS_DEBUG_EVENT) || (ec == EXIT_THREAD_DEBUG_EVENT)))
        m_unmanagedThreads.RemoveBase(ut->m_id);
}

void CordbProcess::QueueOOBUnmanagedEvent(CordbUnmanagedThread *pUThread, DEBUG_EVENT *pEvent)
{
    _ASSERTE(ThreadHoldsProcessLock());
    _ASSERTE(!pUThread->HasOOBEvent());

    LOG((LF_CORDB, LL_INFO10000, "CP::QUE: queued OOB unmanaged event %d for thread 0x%x\n",
         pEvent->dwDebugEventCode, pUThread->m_id));
    
    // Copy the event into the given thread
    CordbUnmanagedEvent *ue = pUThread->OOBEvent();
    memcpy(&(ue->m_currentDebugEvent), pEvent, sizeof(DEBUG_EVENT));
    ue->m_state = CUES_None;
    ue->m_next = NULL;

    // Enqueue the event.
    pUThread->SetState(CUTS_HasOOBEvent);
    
    if (m_outOfBandEventQueue == NULL)
        m_outOfBandEventQueue = ue;
    else
        m_lastQueuedOOBEvent->m_next = ue;

    m_lastQueuedOOBEvent = ue;
}

void CordbProcess::DequeueOOBUnmanagedEvent(CordbUnmanagedThread *ut)
{
    _ASSERTE(m_outOfBandEventQueue != NULL);
    _ASSERTE(ut->HasOOBEvent());
    
    CordbUnmanagedEvent *ue = ut->OOBEvent();
    DWORD ec = ue->m_currentDebugEvent.dwDebugEventCode;

    LOG((LF_CORDB, LL_INFO10000, "CP::DUE: dequeue OOB unmanaged event %d for thread 0x%x\n", ec, ut->m_id));
    
    CordbUnmanagedEvent **tmp = &m_outOfBandEventQueue;
    CordbUnmanagedEvent **prev = NULL;

    // Note: this supports out-of-order dequeing of unmanaged events. This is necessary because we queue events even if
    // we're not clear on the ownership question. When we get the answer, and if the event belongs to the Runtime, we go
    // ahead and yank the event out of the queue, wherever it may be.
    while (*tmp && *tmp != ue)
    {
        prev = tmp;
        tmp = &((*tmp)->m_next);
    }

    _ASSERTE(*tmp == ue);

    *tmp = (*tmp)->m_next;

    if (m_outOfBandEventQueue == NULL)
        m_lastQueuedOOBEvent = NULL;
    else if (m_lastQueuedOOBEvent == ue)
    {
        _ASSERTE(prev != NULL);
        m_lastQueuedOOBEvent = *prev;
    }

    ut->ClearState(CUTS_HasOOBEvent);
}

HRESULT CordbProcess::SuspendUnmanagedThreads(DWORD notThisThread)
{
    _ASSERTE(ThreadHoldsProcessLock());
    
    DWORD helperThreadId = 0;
    DWORD temporaryHelperThreadId = 0;

    if (m_DCB)
    {
        helperThreadId = m_DCB->m_helperThreadId;
        temporaryHelperThreadId = m_DCB->m_temporaryHelperThreadId;

        // If the list of debugger special threads is dirty, must
        // re-read it and update the local values.
        if (m_DCB->m_specialThreadListDirty)
        {
            DWORD listLen = m_DCB->m_specialThreadListLength;
            _ASSERTE(listLen > 0);

            DWORD *list =
                (DWORD *)_alloca(m_DCB->m_specialThreadListLength);

            // Read the list from the debuggee
            DWORD bytesRead;
            ReadProcessMemoryI(m_handle,
                               (LPCVOID)m_DCB->m_specialThreadList,
                               (LPVOID)list,
                               listLen * sizeof(DWORD),
                               &bytesRead);
            _ASSERTE(bytesRead == (listLen * sizeof(DWORD)));

            // Loop through the list and update the local
            // unmanaged thread objects
            for (DWORD i = 0; i < listLen; i++)
            {
                CordbUnmanagedThread *ut = 
                    (CordbUnmanagedThread *) m_unmanagedThreads.GetBase(list[i]);
                _ASSERTE(ut);

                ut->SetState(CUTS_IsSpecialDebuggerThread);
            }

            // Reset the dirty bit.
            m_DCB->m_specialThreadListDirty = false;
        }
    }

    LOG((LF_CORDB, LL_INFO1000, "CP::SUT: helper thread id is 0x%x, "
         "temp helper thread id is 0x%x\n",
         helperThreadId, temporaryHelperThreadId));
    
    // Iterate over all unmanaged threads...
    CordbBase* entry;
    HASHFIND find;

    for (entry =  m_unmanagedThreads.FindFirst(&find); entry != NULL; entry =  m_unmanagedThreads.FindNext(&find))
    {
        CordbUnmanagedThread* ut = (CordbUnmanagedThread*) entry;

        // Only suspend those unmanaged threads that aren't already suspended by us and that aren't already hijacked by
        // us.
        if (!ut->IsSuspended() &&
            !ut->IsFirstChanceHijacked() &&
            !ut->IsGenericHijacked() &&
            !ut->IsSecondChanceHijacked() &&
            !ut->IsSpecialDebuggerThread() &&
            !ut->IsDeleted() &&
            (ut->m_id != helperThreadId) &&
            (ut->m_id != temporaryHelperThreadId) &&
            (ut->m_id != notThisThread))
        {
            LOG((LF_CORDB, LL_INFO1000, "CP::SUT: suspending unmanaged thread 0x%x, handle 0x%x\n", ut->m_id, ut->m_handle));
            
            DWORD succ = SuspendThread(ut->m_handle);

            if (succ == 0xFFFFFFFF)
            {
                // This is okay... the thread may be dying after an ExitThread event.
                LOG((LF_CORDB, LL_INFO1000, "CP::SUT: failed to suspend thread 0x%x\n", ut->m_id));
            }
            else
            {
                m_state |= PS_SOME_THREADS_SUSPENDED;

                ut->SetState(CUTS_Suspended);
            }
        }
    }

    return S_OK;
}

HRESULT CordbProcess::ResumeUnmanagedThreads(bool unmarkHijacks)
{
    _ASSERTE(ThreadHoldsProcessLock());
    
    // Iterate over all unmanaged threads...
    CordbBase* entry;
    HASHFIND find;
    bool stillSomeHijacks = false;

    for (entry =  m_unmanagedThreads.FindFirst(&find); entry != NULL; entry =  m_unmanagedThreads.FindNext(&find))
    {
        CordbUnmanagedThread* ut = (CordbUnmanagedThread*) entry;

        // Only resume those unmanaged threads that were suspended by us.
        if (ut->IsSuspended())
        {
            LOG((LF_CORDB, LL_INFO1000, "CP::RUT: resuming unmanaged thread 0x%x\n", ut->m_id));
            
            DWORD succ = ResumeThread(ut->m_handle);

            if (succ == 0xFFFFFFFF)
            {
                LOG((LF_CORDB, LL_INFO1000, "CP::RUT: failed to resume thread 0x%x\n", ut->m_id));
            }
            else
                ut->ClearState(CUTS_Suspended);
        }

        if (unmarkHijacks && (ut->IsFirstChanceHijacked() || ut->IsHijackedForSync()))
        {
            if (!ut->IsAwaitingOwnershipAnswer())
            {
                LOG((LF_CORDB, LL_INFO1000, "CP::RUT: unmarking hijack on thread 0x%x\n", ut->m_id));
            
                ut->ClearState(CUTS_FirstChanceHijacked);
                ut->ClearState(CUTS_HijackedForSync);
            }
            else
                stillSomeHijacks = true;
        }
    }

    m_state &= ~PS_SOME_THREADS_SUSPENDED;

    if (unmarkHijacks && !stillSomeHijacks)
        m_state &= ~PS_HIJACKS_IN_PLACE;
    
    return S_OK;
}

void CordbProcess::DispatchUnmanagedInBandEvent(void)
{
    _ASSERTE(ThreadHoldsProcessLock());

    // There should be no queued OOB events!!! If there are, then we have a breakdown in our protocol, since all OOB
    // events should be dispatched before attempting to really continue from any in-band event.
    _ASSERTE(m_outOfBandEventQueue == NULL);
    _ASSERTE(m_cordb->m_unmanagedCallback != NULL);

    CordbUnmanagedThread *ut = NULL;
    CordbUnmanagedEvent *ue = NULL;

    do
    {
        // If this not the first time around the loop, release our reference to the unmanaged thread that we dispatched
        // the prior time through the loop.
        if (ut)
        {
            // This event should have been continued long ago...
            _ASSERTE(ut->IBEvent()->IsEventContinued());
            
            ut->Release();
        }
        
        // Get the first event in the IB Queue...
        ue = m_unmanagedEventQueue;
        ut = ue->m_owner;

        // We better not have dispatched it yet!
        _ASSERTE(!ue->IsDispatched());
        _ASSERTE(m_awaitingOwnershipAnswer == 0);
        _ASSERTE(!ut->IsAwaitingOwnershipAnswer());

        // Make sure we keep the thread alive while we're playing with it.
        ut->AddRef();

        LOG((LF_CORDB, LL_INFO10000, "CP::DUE: dispatching unmanaged event %d for thread 0x%x\n",
             ue->m_currentDebugEvent.dwDebugEventCode, ut->m_id));
            
        m_dispatchingUnmanagedEvent = true;
        ue->SetState(CUES_Dispatched);

        m_stopCount++;
        
        Unlock();

        m_cordb->m_unmanagedCallback->DebugEvent(&(ue->m_currentDebugEvent), FALSE);

        Lock();
    }
    while (!m_dispatchingUnmanagedEvent && (m_unmanagedEventQueue != NULL));

    m_dispatchingUnmanagedEvent = false;

    if (m_unmanagedEventQueue == NULL)
    {
        LOG((LF_CORDB, LL_INFO10000, "CP::DUE: no more unmanged events to dispatch, continuing.\n"));

        // Continue from this last IB event if it hasn't been continued yet.
        if (!ut->IBEvent()->IsEventContinued())
        {
            _ASSERTE(ue == ut->IBEvent());
            
            // We had better be Win32 stopped or else something is seriously wrong... based on the flag above, we have
            // an event that we haven't done a Win32 ContinueDebugEvent on, so we must be Win32 stopped...
            _ASSERTE(m_state & PS_WIN32_STOPPED);

            m_cordb->m_win32EventThread->DoDbgContinue(this,
                                                       ue,
                                                       (ue->IsExceptionCleared() | ut->IsFirstChanceHijacked()) ?
                          DBG_CONTINUE : DBG_EXCEPTION_NOT_HANDLED,
                          true);
        }
    }

    // Release our reference to the last thread that we dispatched now...
    ut->Release();
}

void CordbProcess::DispatchUnmanagedOOBEvent(void)
{
    _ASSERTE(ThreadHoldsProcessLock());

    // There should be OOB events queued...
    _ASSERTE(m_outOfBandEventQueue != NULL);
    _ASSERTE(m_cordb->m_unmanagedCallback != NULL);

    do
    {
        // Get the first event in the OOB Queue...
        CordbUnmanagedEvent *ue = m_outOfBandEventQueue;
        CordbUnmanagedThread *ut = ue->m_owner;

        // Make sure we keep the thread alive while we're playing with it.
        ut->AddRef();

        LOG((LF_CORDB, LL_INFO10000, "[%x] CP::DUE: dispatching OOB unmanaged event %d for thread 0x%x\n",
             GetCurrentThreadId(), ue->m_currentDebugEvent.dwDebugEventCode, ut->m_id));
            
        m_dispatchingOOBEvent = true;
        ue->SetState(CUES_Dispatched);
        Unlock();

        m_cordb->m_unmanagedCallback->DebugEvent(&(ue->m_currentDebugEvent), TRUE);

        Lock();

        // If they called Continue from the callback, then continue the OOB event right now before dispatching the next
        // one.
        if (!m_dispatchingOOBEvent)
        {
            DequeueOOBUnmanagedEvent(ut);

            // Should not have continued from this debug event yet.
            _ASSERTE(!ue->IsEventContinued());

            // Do a little extra work if that was an OOB exception event...
            HRESULT hr = ue->m_owner->FixupAfterOOBException(ue);
            _ASSERTE(SUCCEEDED(hr));

            // Go ahead and continue now...
            m_cordb->m_win32EventThread->DoDbgContinue(this,
                                                       ue,
                                                       ue->IsExceptionCleared() ?
                           DBG_CONTINUE :
                           DBG_EXCEPTION_NOT_HANDLED,
                          false);
        }

        ut->Release();
    }
    while (!m_dispatchingOOBEvent && (m_outOfBandEventQueue != NULL));

    m_dispatchingOOBEvent = false;

    LOG((LF_CORDB, LL_INFO10000, "CP::DUE: done dispatching OOB events. Queue=0x%08x\n", m_outOfBandEventQueue));
}

HRESULT CordbProcess::StartSyncFromWin32Stop(BOOL *asyncBreakSent)
{
    HRESULT hr = S_OK;

    if (asyncBreakSent)
        *asyncBreakSent = FALSE;
    
    // If we're win32 stopped (but not out-of-band win32 stopped), or if we're running free on the Left Side but we're
    // just not synchronized (and we're win32 attached), then go ahead and do an internal continue and send an async
    // break event to get the Left Side sync'd up.
    //
    // The process can be running free as far as Win32 events are concerned, but still not synchronized as far as the
    // Runtime is concerned. This can happen in a lot of cases where we end up with the Runtime not sync'd but with the
    // process running free due to hijacking, etc...
    if (((m_state & PS_WIN32_STOPPED) && (m_outOfBandEventQueue == NULL))
        || (!GetSynchronized() && (m_state & PS_WIN32_ATTACHED)))
    {
        Lock();

        if (((m_state & PS_WIN32_STOPPED) && (m_outOfBandEventQueue == NULL))
            || (!GetSynchronized() && (m_state & PS_WIN32_ATTACHED)))
        {
            LOG((LF_CORDB, LL_INFO1000, "[%x] CP::SSFW32S: sending internal continue\n", GetCurrentThreadId()));

            // Can't do this on the win32 event thread.
            _ASSERTE(!m_cordb->m_win32EventThread->IsWin32EventThread());

            // If the helper thread is already dead, then we just return as if we sync'd the process.
            if (m_helperThreadDead)
            {
                if (asyncBreakSent)
                    *asyncBreakSent = TRUE;

                // Mark the process as synchronized so no events will be dispatched until the thing is
                // continued. However, the marking here is not a usual marking for synchronized. It has special
                // semantics when we're interop debugging. We use m_oddSync to remember this so that we can take special
                // action in Continue().
                SetSynchronized(true);
                m_oddSync = true;

                // Get the RC Event Thread to stop listening to the process.
                m_cordb->ProcessStateChanged();
        
                Unlock();

                return S_OK;
            }

            m_stopRequested = true;

            Unlock();
                
            // If the process gets synchronized between the Unlock() and here, then SendUnmanagedContinue() will end up
            // not doing anything at all since a) it holds the process lock when working and b) it gates everything on
            // if the process is sync'd or not. This is exactly what we want.
            HRESULT hr = m_cordb->m_win32EventThread->SendUnmanagedContinue(this, true, false);

            LOG((LF_CORDB, LL_INFO1000, "[%x] CP::SSFW32S: internal continue returned\n", GetCurrentThreadId()));

            // Send an async break to the left side now that its running.
            DebuggerIPCEvent *event = (DebuggerIPCEvent*) _alloca(CorDBIPC_BUFFER_SIZE);
            InitIPCEvent(event, DB_IPCE_ASYNC_BREAK, false, NULL);

            LOG((LF_CORDB, LL_INFO1000, "[%x] CP::SSFW32S: sending async stop\n", GetCurrentThreadId()));

            // If the process gets synchronized between the Unlock() and here, then this message will do nothing (Left
            // Side swallows it) and we'll never get a response, and it won't hurt anything.
            hr = m_cordb->SendIPCEvent(this, event, CorDBIPC_BUFFER_SIZE);

            // If the send returns with the helper thread being dead, then we know we don't need to wait for the process
            // to sync.
            if (!m_helperThreadDead)
            {
                LOG((LF_CORDB, LL_INFO1000, "[%x] CP::SSFW32S: sent async stop, waiting for event\n", GetCurrentThreadId()));

                // If we got synchronized between the Unlock() and here its okay since m_stopWaitEvent is still high
                // from the last sync.
                DWORD ret = WaitForSingleObject(m_stopWaitEvent, INFINITE);

                LOG((LF_CORDB, LL_INFO1000, "[%x] CP::SSFW32S: got event, %d\n", GetCurrentThreadId(), ret));

                _ASSERTE(ret == WAIT_OBJECT_0);
            }

            Lock();
    
            if (asyncBreakSent)
                *asyncBreakSent = TRUE;

            // If the helper thread died while we were trying to send an event to it, then we just do the same odd sync
            // logic we do above.
            if (m_helperThreadDead)
            {
                SetSynchronized(true);
                m_oddSync = true;

                hr = S_OK;
            }

            m_stopRequested = false;
            m_cordb->ProcessStateChanged();
        }

        Unlock();
    }

    return hr;
}

// Check if the left side has exited. If so, get the right-side
// into shutdown mode. Only use this to avert us from going into
// an unrecoverable error.
bool CordbProcess::CheckIfLSExited()
{    
// Check by waiting on the handle with no timeout.
    if (WaitForSingleObject(m_handle, 0) == WAIT_OBJECT_0)
    {
        Lock();
        m_terminated = true;
        m_exiting = true;
        Unlock();
    }

    LOG((LF_CORDB, LL_INFO10, "CP::IsLSExited() returning '%s'\n", 
        m_exiting ? "true" : "false"));
            
    return m_exiting;
}

// Call this if something really bad happened and we can't do
// anything meaningful with the CordbProcess. 
void CordbProcess::UnrecoverableError(HRESULT errorHR,
                                      unsigned int errorCode,
                                      const char *errorFile,
                                      unsigned int errorLine)
{
    LOG((LF_CORDB, LL_INFO10, "[%x] CP::UE: unrecoverable error 0x%08x "
         "(%d) %s:%d\n",
         GetCurrentThreadId(),
         errorHR, errorCode, errorFile, errorLine));

    if (errorHR != CORDBG_E_INCOMPATIBLE_PROTOCOL)
    {
        _ASSERTE(!"Unrecoverable internal error!");
    
        m_unrecoverableError = true;
    
        //
        // Mark the process as no longer synchronized.
        //
        Lock();
        SetSynchronized(false);
        m_stopCount++;
        Unlock();
    }
    
    // Set the error flags in the process so that if parts of it are
    // still alive, it will realize that its in this mode and do the
    // right thing.
    if (m_DCB != NULL)
    {
        m_DCB->m_errorHR = errorHR;
        m_DCB->m_errorCode = errorCode;
    }

    //
    // Let the user know that we've hit an unrecoverable error.    
    //
    if (m_cordb->m_managedCallback)
        m_cordb->m_managedCallback->DebuggerError((ICorDebugProcess*) this,
                                                  errorHR,
                                                  errorCode);
}


HRESULT CordbProcess::CheckForUnrecoverableError(void)
{
    HRESULT hr = S_OK;
    
    if (m_DCB->m_errorHR != S_OK)
    {
        UnrecoverableError(m_DCB->m_errorHR,
                           m_DCB->m_errorCode,
                           __FILE__, __LINE__);

        hr = m_DCB->m_errorHR;
    }

    return hr;
}


/*
 * EnableLogMessages enables/disables sending of log messages to the 
 * debugger for logging.
 */
HRESULT CordbProcess::EnableLogMessages(BOOL fOnOff)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    HRESULT hr = S_OK;

    DebuggerIPCEvent *event = (DebuggerIPCEvent*) _alloca(CorDBIPC_BUFFER_SIZE);
    InitIPCEvent(event, DB_IPCE_ENABLE_LOG_MESSAGES, false, NULL);
    event->LogSwitchSettingMessage.iLevel = (int)fOnOff;

    hr = m_cordb->SendIPCEvent(this, event, CorDBIPC_BUFFER_SIZE);

    LOG((LF_CORDB, LL_INFO10000, "[%x] CP::EnableLogMessages: EnableLogMessages=%d sent.\n", 
         GetCurrentThreadId(), fOnOff));

    return hr;
#endif //RIGHT_SIDE_ONLY    
}

/*
 * ModifyLogSwitch modifies the specified switch's severity level.
 */
COM_METHOD CordbProcess::ModifyLogSwitch(WCHAR *pLogSwitchName, LONG lLevel)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    HRESULT hr = S_OK;
    
    _ASSERTE (pLogSwitchName != NULL);

    DebuggerIPCEvent *event = (DebuggerIPCEvent*) _alloca(CorDBIPC_BUFFER_SIZE);
    InitIPCEvent(event, DB_IPCE_MODIFY_LOGSWITCH, false, NULL);
    event->LogSwitchSettingMessage.iLevel = lLevel;
    wcscpy (&event->LogSwitchSettingMessage.Dummy[0], pLogSwitchName);
    
    hr = m_cordb->SendIPCEvent(this, event, CorDBIPC_BUFFER_SIZE);

    LOG((LF_CORDB, LL_INFO10000, "[%x] CP::ModifyLogSwitch: ModifyLogSwitch sent.\n", 
         GetCurrentThreadId()));

    return hr;
#endif //RIGHT_SIDE_ONLY    
}


void CordbProcess::ProcessFirstLogMessage (DebuggerIPCEvent* event)
{
    LOG((LF_CORDB, LL_INFO10000, "[%x] RCET::DRCE: FirstLogMessage.\n",
         GetCurrentThreadId()));

    Lock();

    CordbThread* thread =
            (CordbThread*) m_userThreads.GetBase(event->threadId);
    
    if(thread == NULL)
    {
        Unlock();
        Continue(false); 
        return; //we haven't seen the thread yet, so don't do anything
    }

    Unlock();

    thread->m_fLogMsgContinued = event->FirstLogMessage.fMoreToFollow;
    thread->m_iLogMsgLevel = event->FirstLogMessage.iLevel;
    thread->m_iLogMsgIndex = 0;
    thread->m_iTotalCatLength = event->FirstLogMessage.iCategoryLength;
    thread->m_iTotalMsgLength = event->FirstLogMessage.iMessageLength;

    // allocate memory for storing the logswitch name and log message
    if (
        ((thread->m_pstrLogSwitch = new WCHAR [thread->m_iTotalCatLength+1])
            != NULL)
        &&
        ((thread->m_pstrLogMsg = new WCHAR [thread->m_iTotalMsgLength+1]) != NULL))
    {
        // copy the LogSwitch name
        wcscpy (thread->m_pstrLogSwitch, &event->FirstLogMessage.Dummy[0]);

        int iBytesToCopy;
        // are there more messages to follow?
        if (thread->m_fLogMsgContinued)
        {
            iBytesToCopy = (CorDBIPC_BUFFER_SIZE - 
                ((int)((char*)&event->FirstLogMessage.Dummy[0] - 
                (char*)event + 
                (char*)LOG_MSG_PADDING) 
                + (thread->m_iTotalCatLength * sizeof (WCHAR)))) / sizeof (WCHAR);

            wcsncpy (thread->m_pstrLogMsg,
                    &event->FirstLogMessage.Dummy[thread->m_iTotalCatLength+1],
                    iBytesToCopy);

            thread->m_iLogMsgIndex = iBytesToCopy;

            Continue(FALSE);
        }
        else
        {
            wcsncpy (thread->m_pstrLogMsg,
                    &event->FirstLogMessage.Dummy[thread->m_iTotalCatLength+1], 
                    thread->m_iTotalMsgLength);

            thread->m_pstrLogMsg [thread->m_iTotalMsgLength] = L'\0';

            // do a callback to the debugger
            if (m_cordb->m_managedCallback)
            {
                // from the thread object get the appdomain object
                CordbAppDomain *pAppDomain = thread->m_pAppDomain;
                _ASSERTE (pAppDomain != NULL);

                m_cordb->m_managedCallback->LogMessage(
                                           (ICorDebugAppDomain*) pAppDomain,
                                           (ICorDebugThread*) thread,
                                           thread->m_iLogMsgLevel,
                                           thread->m_pstrLogSwitch,
                                           thread->m_pstrLogMsg);
            }

            thread->m_iLogMsgIndex = 0;
            thread->m_pstrLogSwitch = NULL;
            thread->m_pstrLogMsg = NULL;

            // free up the memory which was allocated
            delete [] thread->m_pstrLogSwitch;
            delete [] thread->m_pstrLogMsg;

            thread->m_pstrLogSwitch = NULL;
            thread->m_pstrLogMsg = NULL;
        }
    }
    else
    {
        if (thread->m_pstrLogSwitch != NULL)
        {
            delete [] thread->m_pstrLogSwitch;
            thread->m_pstrLogSwitch = NULL;
        }

        // signal that we're out of memory
        CORDBSetUnrecoverableError(this, E_OUTOFMEMORY, 0);
    }

}



void CordbProcess::ProcessContinuedLogMessage (DebuggerIPCEvent* event)
{

    LOG((LF_CORDB, LL_INFO10000, "[%x] RCET::DRCE: ContinuedLogMessage.\n",
         GetCurrentThreadId()));

    Lock();

    CordbThread* thread =
            (CordbThread*) m_userThreads.GetBase(event->threadId);
    
    if(thread == NULL)
    {
        return;
    }

    Unlock();

    // if there was an error while allocating memory when the first log
    // message buffer was received, then no point processing this 
    // message.
    if (thread->m_pstrLogMsg != NULL)
    {
        int iBytesToCopy = event->ContinuedLogMessage.iMessageLength;
        
        _ASSERTE ((iBytesToCopy+thread->m_iLogMsgIndex) <= 
                    thread->m_iTotalMsgLength);

        wcsncpy (&thread->m_pstrLogMsg [thread->m_iLogMsgIndex], 
                &event->ContinuedLogMessage.Dummy[0],
                iBytesToCopy);

        thread->m_iLogMsgIndex += iBytesToCopy;

        if (event->ContinuedLogMessage.fMoreToFollow == false)
        {
            thread->m_pstrLogMsg [thread->m_iTotalMsgLength] = L'\0';

            // make the callback.
            if (m_cordb->m_managedCallback)
            {
                // from the thread object get the appdomain object
                CordbAppDomain *pAppDomain = thread->m_pAppDomain;
                _ASSERTE (pAppDomain != NULL);

                m_cordb->m_managedCallback->LogMessage(
                                           (ICorDebugAppDomain*) pAppDomain,
                                           (ICorDebugThread*) thread,
                                           thread->m_iLogMsgLevel,
                                           thread->m_pstrLogSwitch,
                                           thread->m_pstrLogMsg);
            }


            thread->m_iLogMsgIndex = 0;
            thread->m_pstrLogSwitch = NULL;
            thread->m_pstrLogMsg = NULL;

            // free up the memory which was allocated
            delete [] thread->m_pstrLogSwitch;
            delete [] thread->m_pstrLogMsg;

            thread->m_pstrLogSwitch = NULL;
            thread->m_pstrLogMsg = NULL;
        }
        else
            Continue(FALSE);
    }
    else
        CORDBSetUnrecoverableError(this, E_FAIL, 0);

}


/* 
 * EnumerateAppDomains enumerates all app domains in the process.
 */
HRESULT CordbProcess::EnumerateAppDomains(ICorDebugAppDomainEnum **ppAppDomains)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppAppDomains, ICorDebugAppDomainEnum **);
    
    CordbHashTableEnum *e = new CordbHashTableEnum(&m_appDomains, 
                                                   IID_ICorDebugAppDomainEnum);
    if (e == NULL)
        return E_OUTOFMEMORY;

    *ppAppDomains = (ICorDebugAppDomainEnum*)e;
    e->AddRef();
    
#ifndef RIGHT_SIDE_ONLY
    e->m_enumerator.lsAppD.m_proc = this;
#endif

    return S_OK;
#endif
}

/*
 * GetObject returns the runtime process object.
 * Note: This method is not yet implemented.
 */
HRESULT CordbProcess::GetObject(ICorDebugValue **ppObject)
{
    VALIDATE_POINTER_TO_OBJECT(ppObject, ICorDebugObjectValue **);
	INPROC_LOCK();

	INPROC_UNLOCK();
    return E_NOTIMPL;
}


HRESULT inline CordbProcess::Attach(ULONG AppDomainId)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    HRESULT hr = S_OK;

    DebuggerIPCEvent *event = (DebuggerIPCEvent*) _alloca(CorDBIPC_BUFFER_SIZE);
    InitIPCEvent(event, DB_IPCE_ATTACH_TO_APP_DOMAIN, false, NULL);
    event->AppDomainData.id = AppDomainId;
    event->appDomainToken = NULL;

    hr = m_cordb->SendIPCEvent(this, event, CorDBIPC_BUFFER_SIZE);

    LOG((LF_CORDB, LL_INFO100, "[%x] CP::Attach: pProcess=%x sent.\n", 
         GetCurrentThreadId(), this));

    return hr;
#endif //RIGHT_SIDE_ONLY    
}

void CordbProcess::SetSynchronized(bool fSynch)
{
    m_synchronized = fSynch;
}

bool CordbProcess::GetSynchronized(void)
{
    return m_synchronized;
}

/* ------------------------------------------------------------------------- *
 * Runtime Controller Event Thread class
 * ------------------------------------------------------------------------- */

//
// Constructor
//
CordbRCEventThread::CordbRCEventThread(Cordb* cordb)
{
    _ASSERTE(cordb != NULL);
    
    m_cordb = cordb;
    m_thread = NULL;
    m_run = TRUE;
    m_threadControlEvent = NULL;
    m_processStateChanged = FALSE;

    _ASSERTE(g_pRSDebuggingInfo->m_RCET == NULL);
    g_pRSDebuggingInfo->m_RCET = this;
}


//
// Destructor. Cleans up all of the open handles and such.
// This expects that the thread has been stopped and has terminated
// before being called.
//
CordbRCEventThread::~CordbRCEventThread()
{
    if (m_threadControlEvent != NULL)
        CloseHandle(m_threadControlEvent);
    
    if (m_thread != NULL)
        CloseHandle(m_thread);

    _ASSERTE(g_pRSDebuggingInfo->m_RCET == this);
    g_pRSDebuggingInfo->m_RCET = NULL;
}

#ifndef RIGHT_SIDE_ONLY
// Some of this code is copied in CordbRCEventThead::ThreadProc
HRESULT CordbRCEventThread::VrpcToVrs(CordbProcess *process,
                                      DebuggerIPCEvent* event)
{
    HRESULT hr = S_OK;

    if (!process->m_initialized)
    {
        LOG((LF_CORDB, LL_INFO1000,"RCET::Vrpc: first inproc event\n"));
        
        hr = HandleFirstRCEvent(process);

        if (!SUCCEEDED(hr))
            goto LExit;
    }

    DebuggerIPCEvent *eventCopy;
    eventCopy = NULL;
    eventCopy = (DebuggerIPCEvent*) malloc(CorDBIPC_BUFFER_SIZE);

    if (eventCopy == NULL)
        CORDBSetUnrecoverableError(process, E_OUTOFMEMORY, 0);
    else
    {
        hr = ReadRCEvent(process, eventCopy);

        if (SUCCEEDED(hr))
        {
            process->Lock();
            HandleRCEvent(process, eventCopy);
            process->Unlock();
        }
        else
            free(eventCopy);
    }

LExit:
    return hr;
}
#endif //RIGHT_SIDE_ONLY
//
// Init sets up all the objects that the thread will need to run.
//
HRESULT CordbRCEventThread::Init(void)
{
    if (m_cordb == NULL)
        return E_INVALIDARG;
        
    NAME_EVENT_BUFFER;
    m_threadControlEvent = WszCreateEvent(NULL, FALSE, FALSE, NAME_EVENT(L"ThreadControlEvent"));
    
    if (m_threadControlEvent == NULL)
        return HRESULT_FROM_WIN32(GetLastError());

    return S_OK;
}


//
// HandleFirstRCEvent -- called to handle the very first IPC event from
// the runtime controller. The first event is special because at that point
// we don't know the handles for RSEA and RSER if we launched the process.
//
HRESULT CordbRCEventThread::HandleFirstRCEvent(CordbProcess* process)
{
    HRESULT hr = S_OK;    

#ifdef RIGHT_SIDE_ONLY
    BOOL succ;

    LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::HFRCE: first event...\n", GetCurrentThreadId()));

    if (!(process->m_IPCReader.IsPrivateBlockOpen())) 
    {
        // Open the shared memory segment which contains the control block.

        hr = process->m_IPCReader.OpenPrivateBlockOnPid(process->m_id);

        if (!SUCCEEDED(hr)) 
        {
            goto exit;
        }

        process->m_DCB = process->m_IPCReader.GetDebugBlock();      

        if (process->m_DCB == NULL)
        {
            hr = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
    }

    if ((process->m_DCB != NULL) && (process->m_DCB->m_rightSideProtocolCurrent == 0))
    {
        // Verify that the control block is valid. This is the create case. If we fail validation, then we need to send
        // up a DebuggerError with an hr of CORDBG_E_INCOMPATIBLE_PROTOCOL and kill the process.
        hr = process->VerifyControlBlock();

        if (FAILED(hr))
        {
            _ASSERTE(hr == CORDBG_E_INCOMPATIBLE_PROTOCOL);

            // Send up the DebuggerError event
            process->UnrecoverableError(hr, 0, NULL, 0);

            // Kill the process...
            TerminateProcess(process->m_handle, hr);

            return hr;
        }
    }

    // Dup our own process handle into the remote process.
    succ = DuplicateHandle(GetCurrentProcess(),
                           GetCurrentProcess(),
                           process->m_handle,
                           &(process->m_DCB->m_rightSideProcessHandle),
                           NULL, FALSE, DUPLICATE_SAME_ACCESS);

    if (!succ)
    {
        goto exit;
    }

    // Dup RSEA and RSER into this process.
    succ = DuplicateHandle(process->m_handle,
                           process->m_DCB->m_rightSideEventAvailable,
                           GetCurrentProcess(),
                           &(process->m_rightSideEventAvailable),
                           NULL, FALSE, DUPLICATE_SAME_ACCESS);

    if (!succ)
    {
        goto exit;
    }

    succ = DuplicateHandle(process->m_handle,
                           process->m_DCB->m_rightSideEventRead,
                           GetCurrentProcess(),
                           &(process->m_rightSideEventRead),
                           NULL, FALSE, DUPLICATE_SAME_ACCESS);

    if (!succ)
    {
        goto exit;
    }

    succ = DuplicateHandle(process->m_handle,
                           process->m_DCB->m_leftSideUnmanagedWaitEvent,
                           GetCurrentProcess(),
                           &(process->m_leftSideUnmanagedWaitEvent),
                           NULL, FALSE, DUPLICATE_SAME_ACCESS);

    if (!succ)
    {
        goto exit;
    }

    succ = DuplicateHandle(process->m_handle,
                           process->m_DCB->m_syncThreadIsLockFree,
                           GetCurrentProcess(),
                           &(process->m_syncThreadIsLockFree),
                           NULL, FALSE, DUPLICATE_SAME_ACCESS);

    if (!succ)
    {
        goto exit;
    }

#endif
    // Read the Runtime Offsets struct out of the debuggee.
    hr = process->GetRuntimeOffsets();

    if (SUCCEEDED(hr))
    {
        process->m_initialized = true;

#ifdef RIGHT_SIDE_ONLY
        process->m_DCB->m_rightSideIsWin32Debugger = 
            (process->m_state & process->PS_WIN32_ATTACHED) ? true : false;
#endif
        
        LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::HFRCE: ...went fine\n", GetCurrentThreadId()));
        
        return hr;
    }
    
#ifdef RIGHT_SIDE_ONLY
exit:
    if (process->m_rightSideEventAvailable != NULL)
    {
        CloseHandle(process->m_rightSideEventAvailable);
        process->m_rightSideEventAvailable = NULL;
    }

    if (process->m_rightSideEventRead != NULL)
    {
        CloseHandle(process->m_rightSideEventRead);
        process->m_rightSideEventRead = NULL;

    }

    if (process->m_leftSideUnmanagedWaitEvent != NULL)
    {
        CloseHandle(process->m_leftSideUnmanagedWaitEvent);
        process->m_leftSideUnmanagedWaitEvent = NULL;
    }

    if (process->m_syncThreadIsLockFree != NULL)
    {
        CloseHandle(process->m_syncThreadIsLockFree);
        process->m_syncThreadIsLockFree = NULL;
    }

    process->m_DCB = NULL;
    if (process->m_IPCReader.IsPrivateBlockOpen())
    {       
        process->m_IPCReader.ClosePrivateBlock();       
    }

    LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::HFRCE: ...failed\n", 
             GetCurrentThreadId()));
#endif

    hr = CORDBProcessSetUnrecoverableWin32Error(process, 0);
    return hr;
}


//
// ReadRCEvent -- read an IPC event sent by the runtime controller from the
// remote process.
//
HRESULT CordbRCEventThread::ReadRCEvent(CordbProcess* process,
                                        DebuggerIPCEvent* event)
{
    _ASSERTE(event != NULL);

    CopyRCEvent((BYTE*)process->m_DCB->m_sendBuffer, (BYTE*)event);
    
    return event->hr;
}

void inline CordbRCEventThread::CopyRCEvent(BYTE *src,
                                            BYTE *dst)
{
    memmove(dst, src, CorDBIPC_BUFFER_SIZE);
}

//
// SendIPCEvent -- send an IPC event to the runtime controller. All this
// really does is copy the event into the process's send buffer and sets
// the RSEA then waits on RSER.
//
// Note: when sending a two-way event (replyRequired = true), the
// eventSize must be large enough for both the event sent and the
// result event.
//
HRESULT CordbRCEventThread::SendIPCEvent(CordbProcess* process,
                                         DebuggerIPCEvent* event,
                                         SIZE_T eventSize)
{
#ifdef RIGHT_SIDE_ONLY
    // The Win32 event thread is pretty much the last thread you'd ever, ever want calling this method.
    _ASSERTE(!m_cordb->m_win32EventThread->IsWin32EventThread());

    CORDBRequireProcessStateOK(process);
#endif
    // Cache this process into the MRU so that we can find it if we're debugging in retail.
    g_pRSDebuggingInfo->m_MRUprocess = process;

    HRESULT hr = S_OK;
    BOOL succ = TRUE;

    _ASSERTE(event != NULL);
    
    // NOTE: the eventSize parameter is only so you can specify an event size that is SMALLER than the process send
    // buffer size!!
    if (eventSize > CorDBIPC_BUFFER_SIZE)
        return E_INVALIDARG;
    
    // Sending events to the left side must be synchronized on a per-process basis.
    process->LockSendMutex();

    if (process->m_terminated)
    {
        hr = CORDBG_E_PROCESS_TERMINATED;
        goto exit;
    }

    LOG((LF_CORDB, LL_INFO1000, "CRCET::SIPCE: sending %s to AD 0x%x, proc 0x%x(%d)\n", 
         IPCENames::GetName(event->type), event->appDomainToken, process->m_id, process->m_id));
    
    // Copy the event into the shared memory segment.
    memcpy(process->m_DCB->m_receiveBuffer, event, eventSize);

#ifdef RIGHT_SIDE_ONLY
    LOG((LF_CORDB,LL_INFO1000, "Set RSEA\n"));

    // Tell the runtime controller there is an event ready.
    succ = SetEvent(process->m_rightSideEventAvailable);

    if (succ)
    {
        LOG((LF_CORDB, LL_INFO1000, "CRCET::SIPCE: sent...\n"));
    
        // If this is an async send, then don't wait for the left side to acknowledge that its read the event.
        _ASSERTE(!event->asyncSend || !event->replyRequired);
        
        if (!event->asyncSend)
        {
            DWORD ret;
            
            LOG((LF_CORDB, LL_INFO1000,"CRCET::SIPCE: waiting for left side "
                "to read event. (on RSER)\n"));

            // Wait for the runtime controller to read the event.
            ret = WaitForSingleObject(process->m_rightSideEventRead, CordbGetWaitTimeout());

            if (process->m_terminated)
            {
                hr = CORDBG_E_PROCESS_TERMINATED;
            }
            else if (ret == WAIT_OBJECT_0)
            {
                LOG((LF_CORDB, LL_INFO1000, "CRCET::SIPCE: left side read the event.\n"));
            
                // If this was a two-way event, then the result is already ready for us. Simply copy the result back
                // over the original event that was sent. Otherwise, the left side has simply read the event and is
                // processing it...
                if (event->replyRequired)
                    memcpy(event, process->m_DCB->m_receiveBuffer, eventSize);
            }
            else if (ret == WAIT_TIMEOUT)
            {
                // If we timed out, check the left side to see if it is in the unrecoverable error mode. If it is,
                // return the HR from the left side that caused the error.  Otherwise, return that we timed out and that
                // we don't really know why.
                HRESULT realHR = HRESULT_FROM_WIN32(GetLastError());
        
                hr = process->CheckForUnrecoverableError();

                if (hr == S_OK)
                {
                    CORDBSetUnrecoverableError(process, realHR, 0);
                    hr = realHR;
                }
            }
            else
                hr = CORDBProcessSetUnrecoverableWin32Error(process, 0);
        }
    }
    else
        hr = CORDBProcessSetUnrecoverableWin32Error(process, 0);
#else
    // Make the call directly.
    hr = g_pDebugger->VrpcToVls(event);

    // We won't return until the other side is good and ready, so we don't have to wait.
    if (event->replyRequired)
    {
        memcpy(event, process->m_DCB->m_receiveBuffer, eventSize);
    }
    
#endif //RIGHT_SIDE_ONLY    

exit:
    process->UnlockSendMutex();
    
    return hr;
}


//
// FlushQueuedEvents flushes a process's event queue.
//
void CordbRCEventThread::FlushQueuedEvents(CordbProcess* process)
{
    LOG((LF_CORDB,LL_INFO10000, "CRCET::FQE: Beginning to flush queue\n"));

    // We should only call this is we already have queued events
    _ASSERTE(process->m_queuedEventList != NULL);
    
    //
    // Dispatch queued events so long as they keep calling Continue()
    // before returning from their callback. If they call Continue(),
    // process->m_synchronized will be false again and we know to
    // loop around and dispatch the next event.
    //
#ifdef _DEBUG
    // NOTE: the process lock should be held here...
    _ASSERTE(process->m_processMutexOwner == GetCurrentThreadId());
#endif //_DEBUG

    // If this is the first managed event, go ahead and
    // send the CreateProcess callback now that the
    // process is synchronized... the currently queued
    // events will prevent dispatch of any incoming
    // in-band unmanaged events, thus ensuring there will
    // be no race between sending this special
    // CreateProcess event and dispatching the unmanaged
    // events.
    if (process->m_firstManagedEvent)
    {
        LOG((LF_CORDB,LL_INFO10000, "CRCET::FQE: prep for FirstManagedEvent\n"));
        process->m_firstManagedEvent = false;
            
        process->m_createing = true;
        process->m_dispatchingEvent = true;

        process->m_stopCount++;
        process->Unlock();
                            
        m_cordb->m_managedCallback->CreateProcess((ICorDebugProcess*)process);

        process->Lock();

        // User must call Continue from within the CreateProcess
        // callback...
        _ASSERTE(process->m_createing == false);

        process->m_dispatchingEvent = false;
    }

    // There's a small chance that we asynchronously emptied our queue during 
    // the CreateProcess callback above (if the ls process terminated, ExitProcess
    // will delete all queued events).
    if (process->m_queuedEventList != NULL)
    {      

        // Main dispatch loop here. DispatchRCEvent will take events out of the
        // queue and invoke callbacks
        do
        {
            _ASSERTE(process->m_queuedEventList != NULL);

            process->SetSynchronized(true);
            process->DispatchRCEvent();
                
            LOG((LF_CORDB,LL_INFO10000, "CRCET::FQE: Finished w/ "
                 "DispatchRCEvent\n"));
        }
        while ((process->GetSynchronized() == false) &&
               (process->m_queuedEventList != NULL) &&
               (process->m_unrecoverableError == false));
    }
    
    //
    // If they returned from a callback without calling Continue() then
    // the process is still synchronized, so let the rc event thread
    // know that it need to update its process list and remove the
    // process's event.
    //
    if (process->GetSynchronized())
        ProcessStateChanged();

    // If we were waiting for the managed event queue to drain to
    // dispatch ExitProcess, go ahead and let it happen now.
    if (process->m_exiting)
    {
        LOG((LF_CORDB, LL_INFO1000,
             "CRCET::FQE: managed event queue drained for exit case.\n"));
        
        SetEvent(process->m_miscWaitEvent);
    }

    LOG((LF_CORDB,LL_INFO10000, "CRCET::FQE: finished\n"));
}


//
// HandleRCEvent -- handle an IPC event received from the runtime controller.
// This really just queues events where necessary and performs various
// DI-releated housekeeping for each event received. The events are
// dispatched via DispatchRCEvent.
//
void CordbRCEventThread::HandleRCEvent(CordbProcess* process,
                                       DebuggerIPCEvent* event)
{
    _ASSERTE(process->ThreadHoldsProcessLock());

    switch (event->type & DB_IPCE_TYPE_MASK)
    {
    case DB_IPCE_SYNC_COMPLETE:
        //
        // The RC has synchronized the process. Flush any queued events.
        //
        LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::HRCE: sync complete.\n",
             GetCurrentThreadId()));
        
        free(event);

        process->SetSynchronized(true);
        process->m_syncCompleteReceived = true;

        if (!process->m_stopRequested)
        {
#ifdef RIGHT_SIDE_ONLY
            // Note: we set the m_stopWaitEvent all the time and leave it high while we're stopped. Also note that we
            // can only do this after we've checked process->m_stopRequested!
            SetEvent(process->m_stopWaitEvent);
#endif //RIGHT_SIDE_ONLY            

            // Only dispatch managed events if the unmanaged event
            // queue is empty. If there are unmanaged events, then any
            // queued managed events will be dispatched via Continue
            // after the last unmanaged event is continued from.
            if ((process->m_unmanagedEventQueue == NULL) || !process->m_loaderBPReceived)
            {
                _ASSERTE( (process->m_queuedEventList != NULL) ||
                    !"Sync complete received with no queued managed events!");

                FlushQueuedEvents(process);
            }
#ifdef LOGGING
            else
            {
                LOG((LF_CORDB, LL_INFO1000,
                     "RCET::HRCE: skip flushing due to queued unmanaged "
                     "events.\n"));
            }
#endif            
        }
        else
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "[%x] RCET::HRCE: stop requested, setting event.\n", 
                 GetCurrentThreadId()));
            
#ifdef RIGHT_SIDE_ONLY
            SetEvent(process->m_stopWaitEvent);
#endif //RIGHT_SIDE_ONLY            

            LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::HRCE: set stop event.\n", 
                 GetCurrentThreadId()));
        }
                
        break;

    case DB_IPCE_THREAD_DETACH:
        {
            // Remember that we know the current thread has detached
            // so we won't try to work with it anymore. This prevents
            // people from making mistakes before draining an
            // ExitThread event.
            CordbThread *pThread =
                (CordbThread*)process->m_userThreads.GetBase(event->threadId);

            if (pThread != NULL)
                pThread->m_detached = true;
        }

        // Fall through...
    
    case DB_IPCE_BREAKPOINT:
    case DB_IPCE_USER_BREAKPOINT:
    case DB_IPCE_EXCEPTION:
    case DB_IPCE_STEP_COMPLETE:
    case DB_IPCE_THREAD_ATTACH:
    case DB_IPCE_LOAD_MODULE:
    case DB_IPCE_UNLOAD_MODULE:
    case DB_IPCE_LOAD_CLASS:
    case DB_IPCE_UNLOAD_CLASS:
    case DB_IPCE_FIRST_LOG_MESSAGE:
    case DB_IPCE_CONTINUED_LOG_MESSAGE:
    case DB_IPCE_LOGSWITCH_SET_MESSAGE:
    case DB_IPCE_CREATE_APP_DOMAIN:
    case DB_IPCE_EXIT_APP_DOMAIN:
    case DB_IPCE_LOAD_ASSEMBLY:
    case DB_IPCE_UNLOAD_ASSEMBLY:
    case DB_IPCE_FUNC_EVAL_COMPLETE:
    case DB_IPCE_NAME_CHANGE:
	case DB_IPCE_UPDATE_MODULE_SYMS:
	case DB_IPCE_CONTROL_C_EVENT:
    case DB_IPCE_ENC_REMAP:
    case DB_IPCE_BREAKPOINT_SET_ERROR:
        //
        // Queue all of these events.
        //

        LOG((LF_CORDB, LL_INFO1000, "[%x] RCET::HRCE: Queue event: %s\n", 
             GetCurrentThreadId(), IPCENames::GetName(event->type)));

        event->next = NULL;
        
        if (process->m_queuedEventList == NULL)
            process->m_queuedEventList = event;
        else
            process->m_lastQueuedEvent->next = event;

        process->m_lastQueuedEvent = event;

        break;

    default:
        LOG((LF_CORDB, LL_INFO1000,
             "[%x] RCET::HRCE: Unknown event: 0x%08x\n", 
             GetCurrentThreadId(), event->type));
    }
}

// We shouldn't get these events too much longer - this
// is here for the time between when the debugger says "detach",
// and the time that the left side removes all this AD's
// breakpoints.
//
// Return true if we should ignore the given event b/c we've already
// detatched from the relevant appdomain.  False means we should
// dispatch it.
//
// Please note that we assume that the process has been Lock()'d
// prior to this invocation.
bool CordbProcess::IgnoreRCEvent(DebuggerIPCEvent* event,
                                 CordbAppDomain **ppAppDomain)
{
    LOG((LF_CORDB,LL_INFO1000, "CP::IE: event %s\n", IPCENames::GetName(event->type)));
    _ASSERTE(ThreadHoldsProcessLock());

#ifdef _DEBUG
    _ASSERTE( m_processMutexOwner == GetCurrentThreadId());
#endif //_DEBUG

    CordbAppDomain *cad = NULL;
    
    // Get the appdomain
    switch(event->type)
    {
        case DB_IPCE_ENC_REMAP:
            // We'll arrive here if we've done an EnC on the process,
            // thus don't have a particular AD.  So we should dispatch it.
            cad =(CordbAppDomain*) m_appDomains.GetBase(
                    (ULONG)event->appDomainToken);
            if (cad == NULL)
                return false;
            break;
            
        case DB_IPCE_BREAKPOINT:
        case DB_IPCE_USER_BREAKPOINT:
        case DB_IPCE_EXCEPTION:
        case DB_IPCE_STEP_COMPLETE:
        case DB_IPCE_THREAD_ATTACH:
        case DB_IPCE_LOAD_MODULE:
        case DB_IPCE_UNLOAD_MODULE:
        case DB_IPCE_LOAD_CLASS:
        case DB_IPCE_UNLOAD_CLASS:
        case DB_IPCE_FIRST_LOG_MESSAGE:
        case DB_IPCE_CONTINUED_LOG_MESSAGE:
        case DB_IPCE_LOGSWITCH_SET_MESSAGE:
        case DB_IPCE_FUNC_EVAL_COMPLETE:
        case DB_IPCE_LOAD_ASSEMBLY:
        case DB_IPCE_UNLOAD_ASSEMBLY:
        case DB_IPCE_UPDATE_MODULE_SYMS:
        case DB_IPCE_BREAKPOINT_SET_ERROR:
        
            _ASSERTE(0 != (ULONG)event->appDomainToken);
            cad =(CordbAppDomain*) m_appDomains.GetBase(
                    (ULONG)event->appDomainToken);
            break;
            
            // We should never get this for an appdomain that we've detached from.
        case DB_IPCE_CREATE_APP_DOMAIN:
        case DB_IPCE_EXIT_APP_DOMAIN:
            // Annoyingly enough, we can get name change events before we get the create_app_domain event.  Other code
            // no-ops in that case.
        case DB_IPCE_NAME_CHANGE:
        case DB_IPCE_THREAD_DETACH:
		case DB_IPCE_CONTROL_C_EVENT:
            return false;
            break;
            
        default:
            _ASSERTE( !"We've gotten an unknown event to ignore" );
            break;
    }

    (*ppAppDomain) = cad;
    if (cad == NULL || !cad->m_fAttached)
    {
        LOG((LF_CORDB,LL_INFO1000, "CP::IE: event from appD %S should "
            "be ignored!\n", (cad!=NULL?cad->m_szAppDomainName:L"<None>")));

        // Some events may need some clean-up in order to properly ignore them.            
        switch (event->type)
        {
            case DB_IPCE_STEP_COMPLETE:
            {
                CordbThread* thread =
                    (CordbThread*) m_userThreads.GetBase(event->threadId);
                _ASSERTE(thread != NULL);

                CordbStepper *stepper = (CordbStepper *) 
                    thread->m_process->m_steppers.GetBase((unsigned long)
                    event->StepData.stepperToken);

                if (stepper != NULL)
                {
                    stepper->m_active = false;
                    thread->m_process->m_steppers.RemoveBase(stepper->m_id);
                }
                break;
            }
            
            case DB_IPCE_EXIT_APP_DOMAIN:
            {
                // If there were never any threads in it, remove it 
                // directly rather than waiting for a thread detach that 
                // we'll never get.
                if(cad != NULL &&
                   !cad->m_fHasAtLeastOneThreadInsideIt)
                {
                    LOG((LF_CORDB, LL_INFO100, "CP::IRCE: A.D. is "
                        "thread-less: Release now\n"));
                        
                    cad->m_pProcess->Release();
                    m_appDomains.RemoveBase(cad->m_id);
                }
                else
                {                  
                    LOG((LF_CORDB, LL_INFO100, "CP::IRCE: A.D. had at "
                        "least one thread - defer Release\n"));
                    if (cad != NULL)
                        cad->MarkForDeletion();
                }
                break;
            }
        }

        return true;
    }

    LOG((LF_CORDB,LL_INFO1000, "CP::IE: event from appD %S should "
        "be dispatched!\n", cad->m_szAppDomainName));
    return false;
}

//
// ProcessStateChanged -- tell the rc event thread that the ICorDebug's
// process list has changed by setting its flag and thread control event.
// This will cause the rc event thread to update its set of handles to wait
// on.
//
void CordbRCEventThread::ProcessStateChanged(void)
{
    m_cordb->LockProcessList();
    LOG((LF_CORDB, LL_INFO100000, "CRCET::ProcessStateChanged\n"));
    m_processStateChanged = TRUE;
#ifdef RIGHT_SIDE_ONLY
    SetEvent(m_threadControlEvent);
#endif
    m_cordb->UnlockProcessList();
}


//
// Primary loop of the Runtime Controller event thread.
//
// Some of this code is copied in CordbRCEventThead::VrpcToVrs
void CordbRCEventThread::ThreadProc(void)
{
    HANDLE        waitSet[MAXIMUM_WAIT_OBJECTS];
    CordbProcess* processSet[MAXIMUM_WAIT_OBJECTS];
    unsigned int  waitCount;

#ifdef _DEBUG
    memset(&processSet, NULL, MAXIMUM_WAIT_OBJECTS * sizeof(CordbProcess *));
    memset(&waitSet, NULL, MAXIMUM_WAIT_OBJECTS * sizeof(HANDLE));
#endif
    

    // First event to wait on is always the thread control event.
    waitSet[0] = m_threadControlEvent;
    processSet[0] = NULL;
    waitCount = 1;
    
    while (m_run)
    {
        BOOL ret = WaitForMultipleObjects(waitCount, waitSet, FALSE, 2000);
        if (ret == WAIT_FAILED)
        {
            DWORD dwErr = GetLastError();
            LOG((LF_CORDB, LL_INFO10000, "CordbRCEventThread::ThreadProc WaitFor"
                "MultipleObjects failed: 0x%x\n", dwErr));
        }
        else if ((ret != WAIT_TIMEOUT) && m_run)
        {
            // Got an event. Figure out which process it came from.
            unsigned int wn = ret - WAIT_OBJECT_0;

            LOG((LF_CORDB, LL_INFO1000, "RCET::TP: good event on %d\n", wn));
            
            if (wn != 0)
            {
                _ASSERTE(wn < MAXIMUM_WAIT_OBJECTS);
                CordbProcess* process = processSet[wn];
                _ASSERTE(process != NULL);

                HRESULT hr = S_OK;
            
                // Handle the first event from this process differently then all other events. The first event from the
                // process is special because it signals the first time that we know we can send events to the left side
                // if we actually launched this process.
                process->Lock();
                
                // Note: we also include a check of m_firstManagedEvent because m_initialized can go back to being false
                // during shutdown, even though we'll still be receiving some managed events (like module unloads, etc.)
                if (!process->m_firstManagedEvent && !process->m_initialized && CORDBCheckProcessStateOK(process))
                {
                    
                    LOG((LF_CORDB, LL_INFO1000, "RCET::TP: first event, pid 0x%x(%d)\n", wn, process->m_id, process->m_id));
                    
                    // This can fail with the incompatable version HR. The process has already been terminated if this
                    // is the case.
                    hr = HandleFirstRCEvent(process);

                    _ASSERTE(SUCCEEDED(hr) || (hr == CORDBG_E_INCOMPATIBLE_PROTOCOL));

                    if (SUCCEEDED(hr))
                    {
                        // Remember that we're processing the first managed event... this will be used in HandleRCEvent
                        // below once the new event gets queued.
                        process->m_firstManagedEvent = true;
                    }
                }

                if (CORDBCheckProcessStateOK(process) && SUCCEEDED(hr) && !process->m_exiting)
                {
                    LOG((LF_CORDB, LL_INFO1000, "RCET::TP: other event, pid 0x%x(%d)\n", process->m_id, process->m_id));
                    
                    // Got a real IPC event.
                    DebuggerIPCEvent* event;
                
                    event = (DebuggerIPCEvent*) malloc(CorDBIPC_BUFFER_SIZE);

                    if (event == NULL)
                        CORDBSetUnrecoverableError(process, E_OUTOFMEMORY, 0);
                    else
                    {
                        hr = ReadRCEvent(process, event);
                        SetEvent(process->m_leftSideEventRead);

                        if (SUCCEEDED(hr))
                        {
                            HandleRCEvent(process, event);
                        }
                        else
                        {
                            free(event);
                            CORDBSetUnrecoverableError(process, hr, 0);
                        }
                    }
                }

                process->Unlock();
            }
        }

        // Check a flag to see if we need to update our list of processes to wait on.
        if (m_processStateChanged)
        {
            LOG((LF_CORDB, LL_INFO1000, "RCET::TP: refreshing process list.\n"));

            // Pass 1: iterate the hash of all processes and collect the unsynchronized ones into the wait list.
            m_cordb->LockProcessList();
            m_processStateChanged = FALSE;

            unsigned int i;

            // free the old wait list first, though...
            for (i = 1; i < waitCount; i++)
                processSet[i]->Release();
            
            waitCount = 1;

            CordbHashTable* ph = &(m_cordb->m_processes);
            CordbBase* entry;
            HASHFIND find;

            for (entry =  ph->FindFirst(&find); entry != NULL; entry =  ph->FindNext(&find))
            {
                _ASSERTE(waitCount < MAXIMUM_WAIT_OBJECTS);
                
                CordbProcess* p = (CordbProcess*) entry;

                // Only listen to unsynchronized processes. Processes that are synchronized will not send events without
                // being asked by us first, so there is no need to async listen to them.
                //
                // Note: if a process is not synchronized then there is no way for it to transition to the syncrhonized
                // state without this thread receiving an event and taking action. So there is no need to lock the
                // per-process mutex when checking the process's synchronized flag here.
                if (!p->GetSynchronized() && CORDBCheckProcessStateOK(p))
				{
					LOG((LF_CORDB, LL_INFO1000, "RCET::TP: listening to process 0x%x(%d)\n", p->m_id, p->m_id));
                
					waitSet[waitCount] = p->m_leftSideEventAvailable;
					processSet[waitCount] = p;
					processSet[waitCount]->AddRef();

					waitCount++;
				}
            }

            m_cordb->UnlockProcessList();

            // Pass 2: for each process that we placed in the wait list, determine if there are any existing queued
            // events that need to be flushed.

            // Start i at 1 to skip the control event...
            i = 1;
            while(i < waitCount)            
            {
                CordbProcess *p = processSet[i];

                // Take the process lock so we can check the queue safely
                p->Lock();
                _ASSERTE(!p->GetSynchronized() || p->m_exiting);

                // Flush the queue if necessary. Note, we only do this if we've actually received a SyncComplete message
                // from this process. If we haven't received a SyncComplete yet, then we don't attempt to drain any
                // queued events yet. They'll be drained when the SyncComplete event is actually received.
                if ((p->m_syncCompleteReceived == true) &&
                    (p->m_queuedEventList != NULL) &&
                    !p->GetSynchronized())
				{
                    FlushQueuedEvents(p);
				}

                // Flushing could have left the process synchronized...
                if (p->GetSynchronized())
                {
                    // remove the process from the wait list by sucking all the other processes down one.
                    if ((i + 1) < waitCount)
                    {
                        memcpy(&processSet[i], &processSet[i+1], sizeof(processSet[0]) * (waitCount - i - 1));
                        memcpy(&waitSet[i], &waitSet[i+1], sizeof(waitSet[0]) * (waitCount - i - 1));
                    }

                    // drop the count of processes to wait on 
                    waitCount--;
                    
                    p->Unlock();

                    // make sure to release the reference we added when the process was added to the wait list.
                    p->Release();

                    // We don't have to increment i because we've copied the next element into
                    // the current value at i.                    
                }
                else
                {
                    // Even after flushing, its still not syncd, so leave it in the wait list.
                    p->Unlock();

                    // Increment i normally.
                    i++;
                }
            }
        }
    }
}


//
// This is the thread's real thread proc. It simply calls to the
// thread proc on the given object.
//
/*static*/ DWORD WINAPI CordbRCEventThread::ThreadProc(LPVOID parameter)
{
    CordbRCEventThread* t = (CordbRCEventThread*) parameter;
    t->ThreadProc();
    return 0;
}

//
// WaitForIPCEventFromProcess waits for an event from just the specified
// process. This should only be called when the process is in a synchronized
// state, which ensures that the RCEventThread isn't listening to the
// process's event, too, which would get confusing.
//
HRESULT CordbRCEventThread::WaitForIPCEventFromProcess(
                                                   CordbProcess* process,
                                                   CordbAppDomain *pAppDomain,
                                                   DebuggerIPCEvent* event)
{
    CORDBRequireProcessStateOKAndSync(process, pAppDomain);
    
    BOOL ret = WaitForSingleObject(process->m_leftSideEventAvailable,
                                   CordbGetWaitTimeout());

    if (process->m_terminated)
        return CORDBG_E_PROCESS_TERMINATED;
    
    if (ret == WAIT_OBJECT_0)
    {
        HRESULT hr = ReadRCEvent(process, event);
        SetEvent(process->m_leftSideEventRead);

        return hr;
    }
    else if (ret == WAIT_TIMEOUT)
    {
        //
        // If we timed out, check the left side to see if it is in the
        // unrecoverable error mode. If it is, return the HR from the
        // left side that caused the error. Otherwise, return that we timed
        // out and that we don't really know why.
        //
        HRESULT realHR = HRESULT_FROM_WIN32(GetLastError());
        
        HRESULT hr = process->CheckForUnrecoverableError();

        if (hr == S_OK)
        {
            CORDBSetUnrecoverableError(process, realHR, 0);
            return realHR;
        }
        else
            return hr;
    }
    else
        return CORDBProcessSetUnrecoverableWin32Error(process, 0);
}


//
// Start actually creates and starts the thread.
//
HRESULT CordbRCEventThread::Start(void)
{
    if (m_threadControlEvent == NULL)
        return E_INVALIDARG;

    DWORD dummy;
    m_thread = CreateThread(NULL, 0, CordbRCEventThread::ThreadProc,
                            (LPVOID) this, 0, &dummy);

    if (m_thread == NULL)
        return HRESULT_FROM_WIN32(GetLastError());

    return S_OK;
}


//
// Stop causes the thread to stop receiving events and exit. It
// waits for it to exit before returning.
//
HRESULT CordbRCEventThread::Stop(void)
{
    if (m_thread != NULL)
    {
        LOG((LF_CORDB, LL_INFO100000, "CRCET::Stop\n"));
        m_run = FALSE;
        SetEvent(m_threadControlEvent);

        DWORD ret = WaitForSingleObject(m_thread, INFINITE);
                
        if (ret != WAIT_OBJECT_0)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}


/* ------------------------------------------------------------------------- *
 * Win32 Event Thread class
 * ------------------------------------------------------------------------- */

enum
{
    W32ETA_NONE              = 0,
    W32ETA_CREATE_PROCESS    = 1,
    W32ETA_ATTACH_PROCESS    = 2,
    W32ETA_CONTINUE          = 3,
    W32ETA_DETACH            = 4
};


//
// Constructor
//
CordbWin32EventThread::CordbWin32EventThread(Cordb* cordb) :
    m_cordb(cordb), m_thread(NULL), m_threadControlEvent(NULL),
    m_actionTakenEvent(NULL), m_run(TRUE), m_action(W32ETA_NONE),
    m_waitCount(0), m_win32AttachedCount(0), m_waitTimeout(INFINITE)
{
    _ASSERTE(cordb != NULL);

    _ASSERTE(g_pRSDebuggingInfo->m_Win32ET == NULL);
    g_pRSDebuggingInfo->m_Win32ET = this;
}


//
// Destructor. Cleans up all of the open handles and such.
// This expects that the thread has been stopped and has terminated
// before being called.
//
CordbWin32EventThread::~CordbWin32EventThread()
{
    if (m_thread != NULL)
        CloseHandle(m_thread);

    if (m_threadControlEvent != NULL)
        CloseHandle(m_threadControlEvent);

    if (m_actionTakenEvent != NULL)
        CloseHandle(m_actionTakenEvent);

    DeleteCriticalSection(&m_sendToWin32EventThreadMutex);

    _ASSERTE(g_pRSDebuggingInfo->m_Win32ET == this);
    g_pRSDebuggingInfo->m_Win32ET = NULL;
}


//
// Init sets up all the objects that the thread will need to run.
//
HRESULT CordbWin32EventThread::Init(void)
{
    if (m_cordb == NULL)
        return E_INVALIDARG;
        

    InitializeCriticalSection(&m_sendToWin32EventThreadMutex);
    
    NAME_EVENT_BUFFER;
    m_threadControlEvent = WszCreateEvent(NULL, FALSE, FALSE, NAME_EVENT(L"ThreadControlEvent"));
    if (m_threadControlEvent == NULL)
        return HRESULT_FROM_WIN32(GetLastError());

    m_actionTakenEvent = WszCreateEvent(NULL, FALSE, FALSE, NAME_EVENT(L"ThreadControlEvent"));
    if (m_actionTakenEvent == NULL)
        return HRESULT_FROM_WIN32(GetLastError());

    // Adjust the permissions of this process to ensure that we have
    // the debugging privildge. If we can't make the adjustment, it
    // only means that we won't be able to attach to a service under
    // NT, so we won't treat that as a critical failure. This code was
    // taken directly from code in the Win32 debugger, given to us by
    // Matt Hendel.
    if (Cordb::m_runningOnNT)
    {
        HANDLE hToken;
        TOKEN_PRIVILEGES Privileges;
        BOOL fSucc;

        LUID SeDebugLuid = {0, 0};

        fSucc = LookupPrivilegeValueW(NULL, SE_DEBUG_NAME, &SeDebugLuid);

        if (fSucc)
        {
            // Retrieve a handle of the access token
            fSucc = OpenProcessToken(GetCurrentProcess(),
                                     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                     &hToken);

            if (fSucc)
            {
                Privileges.PrivilegeCount = 1;
                Privileges.Privileges[0].Luid = SeDebugLuid;
                Privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                AdjustTokenPrivileges(hToken,
                                      FALSE,
                                      &Privileges,
                                      sizeof(TOKEN_PRIVILEGES),
                                      (PTOKEN_PRIVILEGES) NULL,
                                      (PDWORD) NULL);
            
                // The return value of AdjustTokenPrivileges cannot be tested.
                if (GetLastError () != ERROR_SUCCESS)
                    LOG((LF_CORDB, LL_INFO1000,
                         "Unable to adjust permissions of this process to "
                         "include SE_DEBUG. Adjust failed %d\n",
                         GetLastError()));
                else
                    LOG((LF_CORDB, LL_INFO1000,
                         "Adjusted process permissions to include "
                         "SE_DEBUG.\n"));

                CloseHandle(hToken);
            }
            else
                LOG((LF_CORDB, LL_INFO1000,
                     "Unable to adjust permissions of this process to "
                     "include SE_DEBUG. OpenProcessToken failed %d\n",
                     GetLastError()));
        }
        else
            LOG((LF_CORDB, LL_INFO1000,
                 "Unable to adjust permissions of this process to "
                 "include SE_DEBUG. Lookup failed %d\n", GetLastError()));
    }
    
    return S_OK;
}


//
// Main function of the Win32 Event Thread
//
void CordbWin32EventThread::ThreadProc(void)
{
    // The first element in the wait set is always the thread control
    // event.
    m_waitSet[0] = m_threadControlEvent;
    m_processSet[0] = NULL;
    m_waitCount = 1;

    // Run the top-level event loop. 
    Win32EventLoop();
}

//
// Primary loop of the Win32 debug event thread.
//
void CordbWin32EventThread::Win32EventLoop(void)
{
    HRESULT hr = S_OK;
    
    // This must be called from the win32 event thread.
    _ASSERTE(IsWin32EventThread());

    LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: entered win32 event loop\n"));
    
    DEBUG_EVENT event;

    while (m_run)
    {
        BOOL eventAvailable = FALSE;

        // Wait for a Win32 debug event from any processes that we may be attached to as the Win32 debugger.
        //
        // Note: the timeout used may need some tuning. It determines the maximum rate at which we can respond
        // to an unmanaged continue request.
        if (m_win32AttachedCount != 0)
            eventAvailable = WaitForDebugEvent(&event, 50);

        // See if any process that we aren't attached to as the Win32 debugger have exited. (Note: this is a
        // polling action if we are also waiting for Win32 debugger events. We're also lookint at the thread
        // control event here, too, to see if we're supposed to do something, like attach.
        DWORD ret = WaitForMultipleObjects(m_waitCount, m_waitSet, FALSE, m_waitTimeout);
        _ASSERTE(ret == WAIT_TIMEOUT || ret < m_waitCount);
        LOG((LF_CORDB, LL_INFO100000, "W32ET::W32EL - got event , ret=%d, has w32 dbg event=%d", ret, eventAvailable));
        
        if (!m_run)
        {
            _ASSERTE(m_action == W32ETA_NONE);
            break;
        }
        
        // If we haven't timed out, or if it wasn't the thread control event that was set, then a process has
        // exited...
        if ((ret != WAIT_TIMEOUT) && (ret != WAIT_OBJECT_0))
        {
            // Grab the process that exited.
            unsigned int wn = ret - WAIT_OBJECT_0;
            _ASSERTE(wn > 0);
            _ASSERTE(wn < NumItems(m_processSet));
            CordbProcess *process = m_processSet[wn];

            ExitProcess(process, wn);
        }

        // Should we create a process?
        else if (m_action == W32ETA_CREATE_PROCESS)
            CreateProcess();

        // Should we attach to a process?
        else if (m_action == W32ETA_ATTACH_PROCESS)
            AttachProcess();

        // Should we detach from a process?
        else if (m_action == W32ETA_DETACH)
            ExitProcess(m_actionData.detachData.pProcess, CW32ET_UNKNOWN_PROCESS_SLOT);
            
        // Should we continue the process?
        else if (m_action == W32ETA_CONTINUE)
            HandleUnmanagedContinue();

        // Sweep over processes to ensure that any FCH threads are still running.
        SweepFCHThreads();
        
        // Only process an event if one is available.
        if (!eventAvailable)
            continue;

        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: got unmanaged event %d on thread 0x%x, proc 0x%x\n", 
             event.dwDebugEventCode, event.dwThreadId, event.dwProcessId));

        bool newEvent = true;

        // Find the process this event is for.
        m_cordb->LockProcessList();

        CordbProcess* process = (CordbProcess*) m_cordb->m_processes.GetBase(event.dwProcessId);
        _ASSERTE(process != NULL);
        g_pRSDebuggingInfo->m_MRUprocess = process;
        
        m_cordb->UnlockProcessList();

        // Mark the process as stopped.
        process->AddRef();
        process->Lock();
        process->m_state |= CordbProcess::PS_WIN32_STOPPED;

        CordbUnmanagedThread *ut = NULL;
        
        // Remember newly created threads.
        if (event.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT)
        {
            ut = process->HandleUnmanagedCreateThread(event.dwThreadId,
                                                      event.u.CreateProcessInfo.hThread,
                                                      event.u.CreateProcessInfo.lpThreadLocalBase);

            // We've received a CreateProcess event. If we're attaching to this process, let
            // DebugActiveProcess continue its good work and start trying to communicate with the process.
            if (process->m_sendAttachIPCEvent)
            {
                SetEvent(process->m_miscWaitEvent);
            }
        }
        else if (event.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT)
        {
            ut = process->HandleUnmanagedCreateThread(event.dwThreadId,
                                                      event.u.CreateThread.hThread,
                                                      event.u.CreateThread.lpThreadLocalBase);

            // See if we have the debugger control block yet...
            if (!(process->m_IPCReader.IsPrivateBlockOpen())) 
            {
                // Open the shared memory segment which contains the control block.
                hr = process->m_IPCReader.OpenPrivateBlockOnPid(process->m_id);

                if (SUCCEEDED(hr))
                    process->m_DCB = process->m_IPCReader.GetDebugBlock();
            }

            // If we have the debugger control block, and if that control block has the address of the thread proc for
            // the helper thread, then we're initialized enough on the Left Side to recgonize the helper thread based on
            // its thread proc's address.
            if ((process->m_DCB != NULL) && (process->m_DCB->m_helperThreadStartAddr != NULL) && (ut != NULL))
            {
                // Grab the thread's context.
                CONTEXT c;
                c.ContextFlags = CONTEXT_FULL;
                BOOL succ = ::GetThreadContext(event.u.CreateThread.hThread, &c);

                if (succ)
                {
                    // Eax is the address of the thread proc when you create a thread with CreateThread. If it
                    // matches the helper thread's thread proc address, then we'll call it the helper thread.
                    if (c.Eax == (DWORD)process->m_DCB->m_helperThreadStartAddr)
                    {
                        // Remeber the ID of the helper thread.
                        process->m_helperThreadId = event.dwThreadId;

                        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: Left Side Helper Thread is 0x%x\n", event.dwThreadId));
                    }
                }
            }
        }
        else
        {
            // Find the unmanaged thread that this event is for.
            ut = process->GetUnmanagedThread(event.dwThreadId);
        }
        
        // In retail, if there is no unmanaged thread then we just continue and loop back around. UnrecoverableError has
        // already been set in this case. Note: there is a bug in the Win32 debugging API that can cause duplicate
        // ExitThread events. We therefore must handle not finding an unmanaged thread gracefully.
        _ASSERTE((ut != NULL) || (event.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT));

        if (ut == NULL)
        {
            // Note: we use ContinueDebugEvent directly here since our continue is very simple and all of our other
            // continue mechanisms rely on having an UnmanagedThread object to play with ;)
            ContinueDebugEvent(process->m_id, event.dwThreadId, DBG_EXCEPTION_NOT_HANDLED);
            continue;
        }

        // Check to see if shutdown of the in-proc debugging services has begun. If it has, then we know we'll no longer
        // be running any managed code, and we know that we can stop hijacking threads. We remember this by setting
        // m_initialized to false, thus preventing most things from happening elsewhere.
        if ((process->m_DCB != NULL) && (process->m_DCB->m_shutdownBegun))
        {
            LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: shutdown begun...\n"));
            process->m_initialized = false;
        }

        // Lots of special cases for exception events. The vast majority of hybrid debugging work that takes
        // place is in response to exception events. The work below will consider certian exception events
        // special cases and rather than letting them be queued and dispatched, they will be handled right
        // here.
        if (event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
        {
            LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: unmanaged exception on "
                 "tid 0x%x, code 0x%08x, addr 0x%08x, chance %d\n",
                 event.dwThreadId,
                 event.u.Exception.ExceptionRecord.ExceptionCode,
                 event.u.Exception.ExceptionRecord.ExceptionAddress,
                 event.u.Exception.dwFirstChance));

#ifdef LOGGING            
            if (event.u.Exception.ExceptionRecord.ExceptionCode == STATUS_ACCESS_VIOLATION)
            {
                LOG((LF_CORDB, LL_INFO1000, "\t<%s> address 0x%08x\n",
                     event.u.Exception.ExceptionRecord.ExceptionInformation[0] ? "write to" : "read from",
                     event.u.Exception.ExceptionRecord.ExceptionInformation[1]));
            }
#endif            

            // We need to recgonize the load breakpoint specially. Managed event dispatch will be defered until the
            // loader BP is received. Otherwise, its processes just like a normal breakpoint event.
            if (!process->m_loaderBPReceived)
            {
                // If its a first chance breakpoint, and its the first one, then its the loader breakpoint.
                if (event.u.Exception.dwFirstChance &&
                    (event.u.Exception.ExceptionRecord.ExceptionCode == STATUS_BREAKPOINT))
                {
                    LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: loader breakpoint received.\n"));

                    // Remember that we've received the loader BP event.
                    process->m_loaderBPReceived = true;

                    // We have to make special consideration for interop attach here. In
                    // CordbProcess::DebugActiveProcess, we wait for the Win32 CreateProcess event to arrive before
                    // trying to communicate with the Left Side to initiate the managed async break. If the thread is
                    // delayed and we don't try to send to the Left Side before the loader BP event comes in, then the
                    // process will be frozen and we'll deadlock. process->m_sendAttachIPCEvent tells us we're in this
                    // case. If that is true here, then we'll unconditionally hijack the thread sending the loader BP
                    // and let the process slip. The thread will be held in the first chance hijack worker on the Left
                    // Side until the attach has proceeded far enough, at which time we'll receive the notification that
                    // the BP is not for the Runtime and we'll continue on as usual.
                    if (process->m_sendAttachIPCEvent)
                    {
                        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: special handling for loader BP while attaching\n"));
                        
                        // We should have runtime offsets. m_sendAttachIPCEvent is only true when we know that the Left
                        // Side debugging services are fully initialized, therefore m_runtimeOffsets should be valid. We
                        // have to force the runtime offsets struct to get read from the debuggee process now, though,
                        // instead of waiting for the first event from the Left Side.
                        hr = process->GetRuntimeOffsets();

                        if (FAILED(hr))
                            CORDBSetUnrecoverableError(process, hr, 0);

                        // Queue the event and thread.
                        process->QueueUnmanagedEvent(ut, &event);

                        // Hijack the little fella...
                        REMOTE_PTR EETlsValue = ut->GetEEThreadPtr();

                        hr = ut->SetupFirstChanceHijack(EETlsValue);

                        if (FAILED(hr))
                            CORDBSetUnrecoverableError(process, hr, 0);
                        
                        // Note: we shouldn't suspend any unmanaged threads until we're sync'd! This is because we'll
                        // end up suspending a thread that is trying to suspend the Runtime, and that's bad because it
                        // may mean the thread we just hijacked might be suspended by that thread with no way to wake
                        // up. What we really should do here is suspend all threads that are not known Runtime threads,
                        // since that's as much slip as we'd be able to prevent.
                        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: First chance hijack in place. Continuing...\n"));

                        // Let the process run free.
                        DoDbgContinue(process, ut->IBEvent(), DBG_EXCEPTION_NOT_HANDLED, false);

                        // This event is now queued, and we're waiting to find out who really owns it, so skip all
                        // further processing.
                        goto Done;
                    }
                }
            }
            
            // We only care about exception events if they are first chance events and if the Runtime is
            // initialized within the process. Otherwise, we don't do anything special with them.
            if (event.u.Exception.dwFirstChance && process->m_initialized)
            {
                DebuggerIPCRuntimeOffsets *pRO = &(process->m_runtimeOffsets);
                DWORD ec = event.u.Exception.ExceptionRecord.ExceptionCode;
                
                // Is this a breakpoint indicating that the Left Side is now synchronized?
                if ((ec == STATUS_BREAKPOINT) &&
                    (event.u.Exception.ExceptionRecord.ExceptionAddress == pRO->m_notifyRSOfSyncCompleteBPAddr))
                {
                    LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: received 'sync complete' flare.\n"));

                    // If we have the DebuggerAttachedEvent, then go ahead and set it. We've received a sync complete
                    // flare. That means that we've also received and queued at least one managed event. We can let any
                    // thread that is blocking because we're not fully attached yet go now. Such a thread would be
                    // blocked on the Left Side, in the FirstChanceHijackFilter.
                    if (process->m_debuggerAttachedEvent != NULL)
                        SetEvent(process->m_debuggerAttachedEvent);

                    // Are we waiting for any unmanaged threads to give us answers about unmanaged exception
                    // ownership?
                    if (process->m_awaitingOwnershipAnswer == 0)
                    {
                        // Nope, so suspend all unmanaged threads except this one.
                        //
                        // Note: we really don't need to be suspending Runtime threads that we know have tripped
                        // here. If we ever end up with a nice, quick way to know that about each unmanaged thread, then
                        // we should put that to good use here.
                        process->SuspendUnmanagedThreads(ut->m_id);

                        process->m_syncCompleteReceived = true;
                        
                        // If some thread is waiting for the process to sync, notify that it can go now.
                        if (process->m_stopRequested)
                        {
                            process->SetSynchronized(true);
                            SetEvent(process->m_stopWaitEvent);
                        }
                        else
                        {
                            // Note: we set the m_stopWaitEvent all the time and leave it high while we're stopped. This
                            // must be done after we've checked m_stopRequested.
                            SetEvent(process->m_stopWaitEvent);
                        
                            // Otherwise, simply mark that the state of the process has changed and let the
                            // managed event dispatch logic take over.
                            //
                            // Note: process->m_synchronized remains false, which indicates to the RC event
                            // thread that it can dispatch the next managed event.
                            m_cordb->ProcessStateChanged();
                        }

                        // Let the process run free.
                        ForceDbgContinue(process, ut, DBG_CONTINUE, false);

                        // At this point, all managed threads are stopped at safe places and all unmanaged
                        // threads are either suspended or hijacked. All stopped managed threads are also hard
                        // suspended (due to the call to SuspendUnmanagedThreads above) except for the thread
                        // that sent the sync complete flare.
                    }
                    else
                    {
                        LOG((LF_CORDB, LL_INFO1000,
                             "W32ET::W32EL: still waiting for ownership answers, delaying sync complete.\n"));
                        
                        // We're still waiting for some unmanaged threads to give us some info. Remember that
                        // we've received the sync complete flare, but don't let anyone know about it just
                        // yet.
                        process->m_state |= CordbProcess::PS_SYNC_RECEIVED;

                        // At this point, all managed threads are stopped at safe places, but there are some
                        // unmanaged threads that are still running free.
                        ForceDbgContinue(process, ut, DBG_CONTINUE, false);
                    }

                    // We've handled this exception, so skip all further processing.
                    goto Done;
                }
                else if ((ec == STATUS_BREAKPOINT) &&
                         (event.u.Exception.ExceptionRecord.ExceptionAddress == pRO->m_excepForRuntimeHandoffCompleteBPAddr))
                {
                    // This notification means that a thread that had been first-chance hijacked is now
                    // finally leaving the hijack.
                    LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: received 'first chance "
                         "hijack handoff complete' flare.\n"));

                    // Basically, all we do with this notification is turn off the flag that says we should be
                    // hiding the thread's first chance hijack state (since its leaving the hijack) and clear
                    // the debugger word (which was filled with the thread's context pointer.)
                    ut->ClearState(CUTS_HideFirstChanceHijackState);
                    
                    REMOTE_PTR EETlsValue = ut->GetEETlsValue();
                    hr = ut->SetEEThreadDebuggerWord(EETlsValue, 0);
                    _ASSERTE(SUCCEEDED(hr));

                    // Let the process run.
                    ForceDbgContinue(process, ut, DBG_CONTINUE, false);
                    
                    // We've handled this exception, so skip all further processing.
                    goto Done;
                }
                else if ((ut->m_id == process->m_DCB->m_helperThreadId) ||
                         (ut->m_id == process->m_DCB->m_temporaryHelperThreadId) ||
                         (ut->m_id == process->m_helperThreadId))
                {
                    // We ignore any first chance exceptions from the helper thread. There are lots of places
                    // on the left side where we attempt to dereference bad object refs and such that will be
                    // handled by exception handlers already in place.
                    //
                    // Note: we check this after checking for the sync complete notification, since that can
                    // come from the helper thread.
                    //
                    // Note: we do let single step and breakpoint exceptions go through to the debugger for processing.
                    if ((ec != STATUS_BREAKPOINT) && (ec != STATUS_SINGLE_STEP))
                    {
                        // Simply let the process run free without altering the state of the thread sending the
                        // exception.
                        ForceDbgContinue(process, ut, DBG_EXCEPTION_NOT_HANDLED, false);
                    
                        // We've handled this exception, so skip all further processing.
                        goto Done;
                    }
                    else
                    {
                        // These breakpoint and single step exceptions have to be dispatched to the debugger as
                        // out-of-band events. This tells the debugger that they must continue from these events
                        // immediatly, and that no interaction with the Left Side is allowed until they do so. This
                        // makes sense, since these events are on the helper thread.
                        goto OutOfBandEvent;
                    }
                }
                else if (ut->IsFirstChanceHijacked() &&
                         process->ExceptionIsFlare(ec, event.u.Exception.ExceptionRecord.ExceptionAddress))
                {
                    // If a thread has been first-chance hijacked, then the only exception we should receive
                    // from it is a flare regarding whether or not the exception belongs to the runtime. The
                    // call to FixupFromFirstChanceHijack below verifies this.
                    //
                    // Note: the original exception event is still enqueued, so below we'll handle this event,
                    // then make a decision about whether to dispatch the original event or not.
                    LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: received flare from first chance "
                         "hijacked thread...\n"));

                    // Is this a signal from a hijacked thread?
                    bool exceptionBelongsToRuntime;

                    hr = ut->FixupFromFirstChanceHijack(&(event.u.Exception.ExceptionRecord),
                                                        &exceptionBelongsToRuntime);

                    _ASSERTE(SUCCEEDED(hr));

                    // If the exception belongs to the runtime, then simply remove the event from the queue
                    // and drop it on the floor.
                    if (exceptionBelongsToRuntime)
                    {
                        process->DequeueUnmanagedEvent(ut);

                        // If the exception belongs to the Runtime, then we're gonna continue the process (one way or
                        // another) below. Regardless, the thread is no longer first chance hijacked.
                        ut->ClearState(CUTS_FirstChanceHijacked);
                    }
                    else if (ut->HasIBEvent() && ut->IBEvent()->IsExceptionCleared())
                    {
                        // If the exception does not belong to the runtime, and if ClearCurrentException has
                        // already been called for the event, then clear the debugger word now so that the
                        // original clear isn't lost. (Setting up and processing a first chance hijack messes
                        // with the debugger word, leaving it uncleared.)
                        //
                        // This can happen if you get an unmanaged event, clear the exception, then do
                        // something that causes the process to sync.
                        
                        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: propagating early clear.\n"));
                        
                        REMOTE_PTR EETlsValue = ut->GetEETlsValue();
                        hr = ut->SetEEThreadDebuggerWord(EETlsValue, 0);
                        _ASSERTE(SUCCEEDED(hr));
                    }
                    
                    // Are we still waiting for other threads to decide if an exception belongs to the Runtime
                    // or not?
                    if (process->m_awaitingOwnershipAnswer)
                    {
                        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: still awaiting %d ownership answers.\n",
                             process->m_awaitingOwnershipAnswer));
                        
                        // We are, so continue the process and wait for the other answers.
                        ForceDbgContinue(process, ut, DBG_CONTINUE, false);

                        // Skip all further processing now that we're done with this exception.
                        goto Done;
                    }
                    else
                    {
                        // No more outstanding ownership answer requests.

                        // If we have previously received a sync complete flare from the left side, go ahead
                        // and let others know about it now.
                        if (process->m_state & CordbProcess::PS_SYNC_RECEIVED)
                        {
                            // Note: this logic is very similar to what is done when a sync complete is
                            // received and there are no outstanding ownership answer requests.
                            process->m_state &= ~CordbProcess::PS_SYNC_RECEIVED;

                            // Suspend all unmanaged threads except this one.
                            //
                            // Note: we really don't need to be suspending Runtime threads that we know have tripped
                            // here. If we ever end up with a nice, quick way to know that about each unmanaged thread,
                            // then we should put that to good use here.
                            process->SuspendUnmanagedThreads(ut->m_id);

                            process->m_syncCompleteReceived = true;
                            
                            // If some thread is waiting for the process to sync, notify that it can go now.
                            if (process->m_stopRequested)
                            {
                                process->SetSynchronized(true);
                                SetEvent(process->m_stopWaitEvent);
                            }
                            else
                            {
                                // Note: we set the m_stopWaitEvent all the time and leave it high while we're
                                // stopped. This must be done after we've checked m_stopRequested.
                                SetEvent(process->m_stopWaitEvent);
                        
                                // Otherwise, simply mark that the state of the process has changed and let
                                // the managed event dispatch logic take over.
                                m_cordb->ProcessStateChanged();
                            }

                            // Let the process run free.
                            ForceDbgContinue(process, ut, DBG_CONTINUE, false);

                            // We're done with this exception, so skip all further processing.
                            goto Done;
                        }
                        else if (ut->IsHijackedForSync())
                        {
                            // The only reason this thread was hijacked was so that we could get the process
                            // to run free, so just continue now.
                            //
                            // Note: "hijacked for sync" is a bad term. The thread was really hijacked
                            // becuase there were other queued events. We now have it queued and hijacked as
                            // necessary, but I don't see how this is different from the case right below this
                            // were we mark that we don't have a newEvent and fall down to the rest of the
                            // logic?
                            ForceDbgContinue(process, ut, DBG_CONTINUE, false);

                            // Note: but if it turns out that we defered part of a true continue due to ownership waits,
                            // then go ahead and finish that up now.
                            if (process->m_deferContinueDueToOwnershipWait)
                            {
                                process->m_deferContinueDueToOwnershipWait = false;
                                UnmanagedContinue(process, false, false);
                            }

                            goto Done;
                        }
                        else if (exceptionBelongsToRuntime)
                        {
                            // Continue the process now. We yanked the exception off the queue above, and since there
                            // are no more outstanding ownership requests, and since there was no sync received then we
                            // can do a partial process continue here.
                            ForceDbgContinue(process, ut, DBG_CONTINUE, false);

                            // Skip all further processing now that we're done with this exception.
                            //
                            // Note: but if it turns out that we defered part of a true continue due to ownership waits,
                            // then go ahead and finish that up now.
                            if (process->m_deferContinueDueToOwnershipWait)
                            {
                                process->m_deferContinueDueToOwnershipWait = false;
                                UnmanagedContinue(process, false, true);
                            }
                            else
                            {
                                goto Done;
                            }
                        }
                        else
                        {
                            // We have all the answers now, so ignore this exception event since the real exception
                            // event this flare was telling us about is still queued.
                            newEvent = false;

                            // Pretend we never continued from the real event. We're about to dispatch it below, and
                            // we'll need to be able to continue for real on this thread, so if we pretend that we never
                            // continued this event then we'll get the real Win32 continue that we need later on...
                            _ASSERTE(ut->HasIBEvent());
                            ut->IBEvent()->ClearState(CUES_EventContinued);

                            // We need to remember that this is the last event that we did not continue from.  It might
                            // be a good idea to do what we're doing above. (Note: pretending that we've never continued
                            // from the queued event whenever we set m_lastIBStoppingEvent.)
                            process->m_lastIBStoppingEvent = ut->IBEvent();
                        }
                    }
                }
                else if (ut->IsGenericHijacked())
                {
                    if (process->ExceptionIsFlare(ec, event.u.Exception.ExceptionRecord.ExceptionAddress)) 
                    {
                        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: fixing up from generic hijack.\n"));

                        _ASSERTE(ec == STATUS_BREAKPOINT);

                        // Fixup the thread from the generic hijack.
                        ut->FixupFromGenericHijack();

                        // We force continue from this flare, since its only purpose was to notify us that we had to
                        // fixup the thread from a generic hijack.
                        ForceDbgContinue(process, ut, DBG_CONTINUE, false);
                        goto Done;
                    }
                    else
                    {
                        // If generichijacked and its not a flare, then we've got our special stack overflow case. Take
                        // off generic hijacked, mark that the helper thread is dead, throw this event on the floor, and
                        // pop anyone in SendIPCEvent out of their wait.
                        ut->ClearState(CUTS_GenericHijacked);
                        process->m_helperThreadDead = true;
                        SetEvent(process->m_rightSideEventRead);

                        // Note: we remember that this was a second chance event from one of the special stack overflow
                        // cases with CUES_ExceptionUnclearable. This tells us to force the process to terminate when we
                        // continue from the event. Since for some odd reason the OS decides to re-raise this exception
                        // (first chance then second chance) infinitely.
                        newEvent = false;
                        _ASSERTE(ut->HasIBEvent());
                        ut->IBEvent()->ClearState(CUES_EventContinued);
                        ut->IBEvent()->SetState(CUES_ExceptionUnclearable);
                        process->m_lastIBStoppingEvent = ut->IBEvent();
                    }
                }
                else if (ut->IsSecondChanceHijacked() &&
                         process->ExceptionIsFlare(ec, event.u.Exception.ExceptionRecord.ExceptionAddress))
	            {
                    LOG((LF_CORDB, LL_INFO1000,
                         "W32ET::W32EL: doing more second chance hijack.\n"));

                    _ASSERTE(ec == STATUS_BREAKPOINT);

                    // Fixup the thread from the generic hijack.
                    ut->DoMoreSecondChanceHijack();

                    // Let the process run free.
                    ForceDbgContinue(process, ut, DBG_CONTINUE, false);

                    goto Done;
                }
                else
                {
                    // Any first chance exception could belong to the Runtime, so long as the Runtime has actually been
                    // initialized. Here we'll setup a first-chance hijack for this thread so that it can give us the
                    // true answer that we need.

                    // But none of those exceptions could possibly be ours unless we have a managed thread to go with
                    // this unmanaged thread. A non-NULL EEThreadPtr tells us that there is indeed a managed thread for
                    // this unmanaged thread, even if the Right Side hasn't received a managed ThreadCreate message yet.
                    REMOTE_PTR EETlsValue = ut->GetEEThreadPtr();

                    if (EETlsValue != NULL)
                    {
                        // We have to be careful here. A Runtime thread may be in a place where we cannot let an
                        // unmanaged exception stop it. For instance, an unmanaged user breakpoint set on
                        // WaitForSingleObject will prevent Runtime threads from sending events to the Right Side. So at
                        // various points below, we check to see if this Runtime thread is in a place were we can't let
                        // it stop, and if so then we jump over to the out-of-band dispatch logic and treat this
                        // exception as out-of-band. The debugger is supposed to continue from the out-of-band event
                        // properly and help us avoid this problem altogether.

                        // Grab a few flags from the thread's state...
                        bool threadStepping = false;
                        bool specialManagedException = false;
                
                        ut->GetEEThreadState(EETlsValue, &threadStepping, &specialManagedException);

                        // If we've got a single step exception, and if the Left Side has indiacted that it was
                        // stepping the thread, then the exception is ours.
                        if (ec == STATUS_SINGLE_STEP)
                        {
                            if (threadStepping)
                            {
                                // Yup, its the Left Side that was stepping the thread...
                                LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: single step exception belongs to the runtime.\n"));

                                // Since this is our exception, we continue from it with DBG_EXCEPTION_NOT_HANDLED,
                                // i.e., simply pass it back to the Left Side so it can handle it.
                                ForceDbgContinue(process, ut, DBG_EXCEPTION_NOT_HANDLED, false);
                                
                                // Now that we're done with this event, skip all further processing.
                                goto Done;
                            }

                            // Any single step that is triggered when the thread's state doesn't indicate that
                            // we were stepping the thread automatically gets passed out as an unmanged event.
                            LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: single step exception "
                                 "does not belong to the runtime.\n"));

                            if (ut->GetEEThreadCantStop(EETlsValue))
                                goto OutOfBandEvent;
                            else
                                goto InBandEvent;
                        }

#ifdef CorDB_Short_Circuit_First_Chance_Ownership
                        // If the runtime indicates that this is a special exception being thrown within the runtime,
                        // then its ours no matter what.
                        else if (specialManagedException)
                        {
                            LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: exception belongs to the runtime due to "
                                 "special managed exception marking.\n"));

                            // Since this is our exception, we continue from it with DBG_EXCEPTION_NOT_HANDLED, i.e.,
                            // simply pass it back to the Left Side so it can handle it.
                            ForceDbgContinue(process, ut, DBG_EXCEPTION_NOT_HANDLED, false);
                                
                            // Now that we're done with this event, skip all further processing.
                            goto Done;
                        }
                        else if ((ec == pRO->m_EEBuiltInExceptionCode1) || (ec == pRO->m_EEBuiltInExceptionCode2))
                        {
                            LOG((LF_CORDB, LL_INFO1000,
                                 "W32ET::W32EL: exception belongs to Runtime due to match on built in exception code\n"));
                
                            // Since this is our exception, we continue from it with DBG_EXCEPTION_NOT_HANDLED, i.e.,
                            // simply pass it back to the Left Side so it can handle it.
                            ForceDbgContinue(process, ut, DBG_EXCEPTION_NOT_HANDLED, false);

                            // Now that we're done with this event, skip all further processing.
                            goto Done;
                        }
                        else if (ec == STATUS_BREAKPOINT)
                        {
                            // There are three cases here:
                            //
                            // 1. The breakpoint definetly belongs to the Runtime. (I.e., a BP in our patch table that
                            // is in managed code.) In this case, we continue the process with
                            // DBG_EXCEPTION_NOT_HANDLED, which lets the in-process exception logic kick in as if we
                            // weren't here.
                            //
                            // 2. The breakpoint is definetly not ours. (I.e., a BP that is not in our patch table.) We
                            // pass these up as regular exception events, doing the can't stop check as usual.
                            //
                            // 3. We're not sure. (I.e., a BP in our patch table, but set in unmangaed code.) In this
                            // case, we hijack as usual, also with can't stop check as usual.
                            bool patchFound = false;
                            bool patchIsUnmanaged = false;

                            hr = process->FindPatchByAddress(
                                                      PTR_TO_CORDB_ADDRESS(event.u.Exception.ExceptionRecord.ExceptionAddress),
                                                      &patchFound,
                                                      &patchIsUnmanaged);

                            if (SUCCEEDED(hr))
                            {
                                if (patchFound)
                                {
                                    // BP could be ours... if its unmanaged, then we still need to hijack, so fall
                                    // through to that logic. Otherwise, its ours.
                                    if (!patchIsUnmanaged)
                                    {
                                        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: breakpoint exception "
                                             "belongs to runtime due to patch table match.\n"));

                                        // Since this is our exception, we continue from it with
                                        // DBG_EXCEPTION_NOT_HANDLED, i.e., simply pass it back to the Left Side so it
                                        // can handle it.
                                        ForceDbgContinue(process, ut, DBG_EXCEPTION_NOT_HANDLED, false);
                                
                                        // Now that we're done with this event, skip all further processing.
                                        goto Done;
                                    }
                                    else
                                    {
                                        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: breakpoint exception "
                                             "matched in patch table, but its unmanaged so we'll hijack anyway.\n"));
                                    }
                                }
                                else
                                {
                                    if (ut->GetEEThreadCantStop(EETlsValue))
                                    {
                                        // If we're in a can't stop region, then its OOB no matter what at this point.
                                        goto OutOfBandEvent;
                                    }
                                    else
                                    {
                                        // We still need to hijack, even if we know the BP isn't ours if the thread has
                                        // preemptive GC disabled. The FirstChanceHijackFilter will help us out by
                                        // toggling the mode so we can sync.
                                        bool PGCDisabled = ut->GetEEThreadPGCDisabled(EETlsValue);

                                        if (!PGCDisabled)
                                        {
                                            // Bp is definitely not ours, and PGC is not disabled, so in-band exception.
                                            LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: breakpoint exception "
                                                 "does not belong to the runtime due to failed patch table match.\n"));

                                            goto InBandEvent;
                                        }
                                        else
                                        {
                                            LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: breakpoint exception "
                                                 "not matched in patch table, but PGC Disabled so we'll hijack anyway.\n"));
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (ut->GetEEThreadCantStop(EETlsValue))
                                {
                                    // If we're in a can't stop region, then its OOB no matter what at this point.
                                    goto OutOfBandEvent;
                                }
                            
                                // If we fail to lookup the patch by address, then just go ahead and hijack to get the
                                // proper answer.
                                LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: failed attempting to match breakpoint "
                                     "exception in patch table, so we'll hijack to get the correct answer.\n"));
                            }
                        }
#endif
                        // This exception could be ours, but we're not sure, so we hijack it and let the in-process
                        // logic figure it out.
                        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: exception could belong "
                             "to runtime, setting up first-chance hijack.\n"));

                        // Queue the event and thread.
                        process->QueueUnmanagedEvent(ut, &event);

                        // Hijack the little fella...
                        if (SUCCEEDED(ut->SetupFirstChanceHijack(EETlsValue)))
                        {
                            // Note: we shouldn't suspend any unmanaged threads until we're sync'd! This is because
                            // we'll end up suspending a thread that is trying to suspend the Runtime, and that's bad
                            // because it may mean the thread we just hijacked might be suspended by that thread with no
                            // way to wake up. What we really should do here is suspend all threads that are not known
                            // Runtime threads, since that's as much slip as we'd be able to prevent.
                            
                            LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: First chance hijack in place. Continuing...\n"));

                            // Let the process run free.
                            DoDbgContinue(process, ut->IBEvent(), DBG_EXCEPTION_NOT_HANDLED, false);

                            // This event is now queued, and we're waiting to find out who really owns it, so skip all
                            // further processing.
                            goto Done;
                        }
                    }
                }

                // At this point, any first-chance exceptions that could be special have been handled. Any
                // first-chance exception that we're still processing at this point is destined to be
                // dispatched as an unmanaged event.
            }
            else if (!event.u.Exception.dwFirstChance && process->m_initialized)
            {
                DWORD ec = event.u.Exception.ExceptionRecord.ExceptionCode;
                
                // Second chance exception, Runtime initialized. It could belong to the Runtime, so we'll check. If it
                // does, then we'll hijack the thread. Otherwise, well just fall through and let it get
                // dispatched. Note: we do this so that the CLR's unhandled exception logic gets a chance to run even
                // though we've got a win32 debugger attached. But the unhandled exception logic never touches
                // breakpoint or single step exceptions, so we ignore those here, too.

                // There are strange cases with stack overflow exceptions. If a dumb application catches a stack
                // overflow exception and handles it, without resetting the guard page, then the app will get an AV when
                // it blows the stack a second time. We will get the first chance AV, but when we continue from it the
                // OS won't run any SEH handlers, so our FCH won't actually work. Instead, we'll get the AV back on
                // second chance right away, and we'll end up right here.
                if (process->IsSpecialStackOverflowCase(ut, &event))
                {
                    // IsSpecialStackOverflowCase will queue the event for us, so its no longer a "new event". Setting
                    // newEvent = false here basically prevents us from playing with the event anymore and we fall down
                    // to the dispatch logic below, which will get our already queued first chance AV dispatched for
                    // this thread.
                    newEvent = false;
                }
                else if ((ut->m_id == process->m_DCB->m_helperThreadId) ||
                         (ut->m_id == process->m_DCB->m_temporaryHelperThreadId) ||
                         (ut->m_id == process->m_helperThreadId))
                {
                    // A second chance exception from the helper thread. This is pretty bad... we just force continue
                    // from them and hope for the best.
                    ForceDbgContinue(process, ut, DBG_EXCEPTION_NOT_HANDLED, false);
                    
                    // We've handled this exception, so skip all further processing.
                    goto Done;
                }
                else if ((ec != STATUS_BREAKPOINT) && (ec != STATUS_SINGLE_STEP))
                {
                    // Grab the EEThreadPtr to see if we have a managed thread.
                    REMOTE_PTR EETlsValue = ut->GetEEThreadPtr();

                    if (EETlsValue != NULL)
                    {
                        // We've got a managed thread, so lets see if we have a frame in place. If we do, then the
                        // second chance exception is ours.
                        bool threadHasFrame = ut->GetEEThreadFrame(EETlsValue);

                        if (threadHasFrame)
                        {
                            // Cool, the thread has a frame. Hijack it.
                            hr = ut->SetupSecondChanceHijack(EETlsValue);

                            if (SUCCEEDED(hr))
                                ForceDbgContinue(process, ut, DBG_CONTINUE, false);

                            goto Done;
                        }
                    }
                }
            }
            else
            {
                // An exception event, but the Runtime hasn't been initialize. I.e., its an exception event
                // that we will never try to hijack.
            }

            // Hijack in-band events (exception events, exit threads) if there is already an event at the head
            // of the queue or if the process is currently synchronized. Of course, we only do this if the
            // process is initialize.
            //
            // Note: we also hijack these left over in-band events if we're activley trying to send the
            // managed continue message to the Left Side. This is controlled by m_specialDeferment below.
        InBandEvent:
            if (newEvent && process->m_initialized && ((process->m_unmanagedEventQueue != NULL) ||
                                                       process->GetSynchronized() ||
                                                       process->m_specialDeferment))
            {
                LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: hijacking unmanaged exception due "
                     "to non-empty queue: %d %d %d\n",
                     process->m_unmanagedEventQueue != NULL,
                     process->GetSynchronized(),
                     process->m_specialDeferment));
            
                // Queue the event and thread
                process->QueueUnmanagedEvent(ut, &event);

                // If its a first-chance exception event, then we hijack it first chance, just like normal.
                if ((event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) && event.u.Exception.dwFirstChance)
                {
                    REMOTE_PTR EETlsValue = ut->GetEETlsValue();

                    hr = ut->SetupFirstChanceHijack(EETlsValue);

                    ut->SetState(CUTS_HijackedForSync);

                    if (SUCCEEDED(hr))
                    {
                        ResetEvent(process->m_leftSideUnmanagedWaitEvent);
                        DoDbgContinue(process, ut->IBEvent(), DBG_EXCEPTION_NOT_HANDLED, false);
                    }
                }
                else
                {
                    // Second chance exceptions must be generic hijacked.
                    hr = ut->SetupGenericHijack(event.dwDebugEventCode);

                    if (SUCCEEDED(hr))
                    {
                        ResetEvent(process->m_leftSideUnmanagedWaitEvent);
                        DoDbgContinue(process, ut->IBEvent(), DBG_CONTINUE, false);
                    }
                }

                // Since we've hijacked this event, we don't need to do any further processing.
                goto Done;
            }
        }
        else
        {
            
            // Not an exception event. At this time, all non-exception events (except EXIT_THREAD) are by
            // definition out-of-band events.
        OutOfBandEvent:
            // If this is an exit thread or exit process event, then we need to mark the unmanaged thread as
            // exited for later.
            if ((event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) ||
                (event.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT))
                ut->SetState(CUTS_Deleted);

            // If we get an exit process or exit thread event on the helper thread, then we know we're loosing
            // the Left Side, so go ahead and remember that the helper thread has died.
            if ((process->m_DCB != NULL) && ((ut->m_id == process->m_DCB->m_helperThreadId) ||
                                           (ut->m_id == process->m_DCB->m_temporaryHelperThreadId) ||
                                             (ut->m_id == process->m_helperThreadId)))
            {
                if ((event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) ||
                    (event.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT))
                {
                    process->m_helperThreadDead = true;
                }
            }
            
            // We're letting EXIT_THREAD be an in-band event to help work around problems in a higher level
            // debugger that shall remain nameless :)
            if (event.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT)
            {
                goto InBandEvent;
            }
            
            // Queue the current out-of-band event.
            process->QueueOOBUnmanagedEvent(ut, &event);

            // Go ahead and dispatch the event if its the first one.
            if (process->m_outOfBandEventQueue == ut->OOBEvent())
            {
                // Set this to true to indicate to Continue() that we're in the unamnaged callback.
                CordbUnmanagedEvent *ue = ut->OOBEvent();
                process->m_dispatchingOOBEvent = true;
                ue->SetState(CUES_Dispatched);

                process->Unlock();

                // This is insane. There is a bug with Win98 and VS7 that causes them to not register a handler early
                // enough. If we get here and there is no handler, we'll block until they register one.
                if (process->m_cordb->m_unmanagedCallback == NULL)
                {
                    DWORD ret = WaitForSingleObject(process->m_cordb->m_crazyWin98WorkaroundEvent, INFINITE);
                    _ASSERTE(ret == WAIT_OBJECT_0);
                }
                    
                // Call the callback with fIsOutOfBand = TRUE.
                process->m_cordb->m_unmanagedCallback->DebugEvent(&event, TRUE);

                process->Lock();

                // If m_dispatchingOOBEvent is false, that means that the user called Continue() from within
                // the callback. We know that we can go ahead and continue the process now.
                if (process->m_dispatchingOOBEvent == false)
                {
                    // Note: this call will dispatch more OOB events if necessary.
                    UnmanagedContinue(process, false, true);
                }
                else
                {
                    // We're not dispatching anymore, so set this back to false.
                    process->m_dispatchingOOBEvent = false;
                }
            }

            // We've handled this event. Skip further processing.
            goto Done;
        }

        // We've got an event that needs dispatching now.

        // If we've got a new event, queue it.
        if (newEvent)
            process->QueueUnmanagedEvent(ut, &event);

        // If the event that just came in is at the head of the queue, or if we don't have a new event but
        // there is a queued & undispatched event, go ahead and dispatch an event.
        if ((ut->IBEvent() == process->m_unmanagedEventQueue) || (!newEvent && (process->m_unmanagedEventQueue != NULL)))
            if (!process->m_unmanagedEventQueue->IsDispatched())
                process->DispatchUnmanagedInBandEvent();

        // If the queue is empty and we're marked as win32 stopped, let the process continue to run free.
        else if ((process->m_unmanagedEventQueue == NULL) && (process->m_state & CordbProcess::PS_WIN32_STOPPED))
            ForceDbgContinue(process, ut, DBG_CONTINUE, true);

        // Unlock and release our extra ref to the process.
    Done:
        process->Unlock();
        process->Release();

        LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: done processing event.\n"));
    }

    LOG((LF_CORDB, LL_INFO1000, "W32ET::W32EL: exiting event loop\n"));

    return;
}

//
// Returns true if the exception is a flare from the left side, false otherwise.
//
bool CordbProcess::ExceptionIsFlare(DWORD exceptionCode, void *exceptionAddress)
{
    // Can't have a flare if the left side isn't initialized
    if (m_initialized)
    {
        DebuggerIPCRuntimeOffsets *pRO = &m_runtimeOffsets;
        
        // All flares are breakpoints...
        if (exceptionCode == STATUS_BREAKPOINT)
        {
            // Does the breakpoint address match a flare address?
            if ((exceptionAddress == pRO->m_excepForRuntimeBPAddr) ||
                (exceptionAddress == pRO->m_excepForRuntimeHandoffStartBPAddr) ||
                (exceptionAddress == pRO->m_excepForRuntimeHandoffCompleteBPAddr) ||
                (exceptionAddress == pRO->m_excepNotForRuntimeBPAddr) ||
                (exceptionAddress == pRO->m_notifyRSOfSyncCompleteBPAddr) ||
                (exceptionAddress == pRO->m_notifySecondChanceReadyForData))
                return true;
        }
    }

    return false;
}

//
// Checks to see if the given second chance exception event actually signifies the death of the process due to a second
// stack overflow special case.
//
// There are strange cases with stack overflow exceptions. If a dumb application catches a stack overflow exception and
// handles it, without resetting the guard page, then the app will get an AV when it blows the stack a second time. We
// will get the first chance AV, but when we continue from it the OS won't run any SEH handlers, so our FCH won't
// actually work. Instead, we'll get the AV back on second chance right away.
//
bool CordbProcess::IsSpecialStackOverflowCase(CordbUnmanagedThread *pUThread, DEBUG_EVENT *pEvent)
{
    _ASSERTE(pEvent->dwDebugEventCode == EXCEPTION_DEBUG_EVENT);
    _ASSERTE(pEvent->u.Exception.dwFirstChance == 0);

    // If this is not an AV, it can't be our special case.
    if (pEvent->u.Exception.ExceptionRecord.ExceptionCode != STATUS_ACCESS_VIOLATION)
        return false;

    // If the thread isn't already first chance hijacked, it can't be our special case.
    if (!pUThread->IsFirstChanceHijacked())
        return false;

    // The first chance hijack didn't take, so we're not FCH anymore and we're not waiting for an answer
    // anymore... Note: by leaving this thread completely unhijacked, we'll report its true context, which is correct.
    pUThread->ClearState(CUTS_FirstChanceHijacked);

    _ASSERTE(m_awaitingOwnershipAnswer > 0);
    _ASSERTE(pUThread->IsAwaitingOwnershipAnswer());
    m_awaitingOwnershipAnswer--;
    pUThread->ClearState(CUTS_AwaitingOwnershipAnswer);

    // The process is techincally dead as a door nail here, so we'll mark that the helper thread is dead so our managed
    // API bails nicely.
    m_helperThreadDead = true;

    // Remember we're in our special case.
    pUThread->SetState(CUTS_HasSpecialStackOverflowCase);

    // Now, remember the second chance AV event in the second IB event slot for this thread and add it to the end of the
    // IB event queue.
    QueueUnmanagedEvent(pUThread, pEvent);
    
    // Note: returning true will ensure that the queued first chance AV for this thread is dispatched.
    return true;
}

void CordbWin32EventThread::SweepFCHThreads(void)
{
    CordbProcess *processSet[MAXIMUM_WAIT_OBJECTS];
    DWORD processCount = 0;
    CordbBase* entry;
    HASHFIND find;

    // We build a list of the processes that may be awaiting ownership answers while holding the process list
    // lock. Then, we release the lock and work on each process while holding each individual process lock. We have to
    // do this to respect the lock hierarchy, which is per-process lock first, process list lock second.
    m_cordb->LockProcessList();

    for (entry = m_cordb->m_processes.FindFirst(&find); entry != NULL; entry = m_cordb->m_processes.FindNext(&find))
    {
        // We can only have MAXIMUM_WAIT_OBJECTS processes at the maximum. This is enforced elsewhere, but we'll guard
        // against it here, just in case...
        _ASSERTE(processCount < MAXIMUM_WAIT_OBJECTS);

        if (processCount >= MAXIMUM_WAIT_OBJECTS)
            continue;
        
        CordbProcess* p = (CordbProcess*) entry;
        _ASSERTE(p != NULL);

        // Note, we can check p->m_awaitingOwnershipAnswer without taking the process lock because we know that it will
        // only be decremented on another thread. It is only ever incremented on this thread (the Win32 event thread.)
        if (p->m_awaitingOwnershipAnswer > 0)
        {
            processSet[processCount++] = p;
            p->AddRef();
        }
    }

    m_cordb->UnlockProcessList();

    // Now, sweep each individual process...
    for (DWORD i = 0; i < processCount; i++)
    {
        CordbProcess *p = processSet[i];
        
        p->Lock();

        // Re-check p->m_awaitingOwnershipAnswer now that we have the process lock to see if we really need to sweep...
        if (p->m_awaitingOwnershipAnswer > 0)
            p->SweepFCHThreads();
            
        p->Unlock();

        p->Release();
    }
}

void CordbProcess::SweepFCHThreads(void)
{
    _ASSERTE(ThreadHoldsProcessLock());

    // Iterate over all unmanaged threads...
    CordbBase* entry;
    HASHFIND find;

    for (entry = m_unmanagedThreads.FindFirst(&find); entry != NULL; entry =  m_unmanagedThreads.FindNext(&find))
    {
        CordbUnmanagedThread* ut = (CordbUnmanagedThread*) entry;

        // We're only interested in first chance hijacked threads that we're awaiting an ownership answer on. These
        // threads must be allowed to run, and cannot remain suspended.
        if (ut->IsFirstChanceHijacked() && ut->IsAwaitingOwnershipAnswer() && !ut->IsSuspended())
        {
            // Suspend the thread to get its _current_ suspend count.
            DWORD sres = SuspendThread(ut->m_handle);

            if (sres != -1)
            {
                // If we succeeded in suspending the thread, resume it to bring its suspend count back to the proper
                // value. SuspendThread returns the _previous_ suspend count...
                ResumeThread(ut->m_handle);

                // Finally, if the thread was suspended, then resume it until it is not suspended anymore.
                if (sres > 0)
                    while (sres--)
                        ResumeThread(ut->m_handle);
            }
        }
    }
}

void CordbWin32EventThread::HijackLastThread(CordbProcess *pProcess, CordbUnmanagedThread *ut)
{
    _ASSERTE(pProcess->ThreadHoldsProcessLock());
    
    _ASSERTE(ut != NULL);
    _ASSERTE(ut->HasIBEvent());

    HRESULT hr;
    CordbUnmanagedEvent *ue = ut->IBEvent();
    DEBUG_EVENT *event = &(ue->m_currentDebugEvent);

    LOG((LF_CORDB, LL_INFO1000, "W32ET::HLT: hijacking the last event.\n"));
    
    // For EXIT_THREAD, we can't hijack the thread, so just let the thread die and let the process get continued as if
    // it were hijacked.
    if (event->dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT)
    {
        LOG((LF_CORDB, LL_INFO1000, "W32ET::HLT: last event was an exit thread event.\n"));
        
        ResetEvent(pProcess->m_leftSideUnmanagedWaitEvent);
        DoDbgContinue(pProcess, ue, DBG_CONTINUE, false);

        return;
    }
    
    _ASSERTE(event->dwDebugEventCode == EXCEPTION_DEBUG_EVENT);
        
    if (event->u.Exception.dwFirstChance)
    {
        LOG((LF_CORDB, LL_INFO1000, "W32ET::HLT: first chance exception.\n"));
        
        REMOTE_PTR EETlsValue = ut->GetEETlsValue();
        
        hr = ut->SetupFirstChanceHijack(EETlsValue);

        ut->SetState(CUTS_HijackedForSync);

        if (SUCCEEDED(hr))
        {
            LOG((LF_CORDB, LL_INFO1000, "W32ET::HLT: hijack setup okay, continuing process.\n"));
        
            ResetEvent(pProcess->m_leftSideUnmanagedWaitEvent);
            DoDbgContinue(pProcess, ue, DBG_EXCEPTION_NOT_HANDLED, false);
        }
    }
    else
    {
        LOG((LF_CORDB, LL_INFO1000, "W32ET::HLT: second chance exception.\n"));
        
        hr = ut->SetupGenericHijack(event->dwDebugEventCode);

        if (SUCCEEDED(hr))
        {
            LOG((LF_CORDB, LL_INFO1000, "W32ET::HLT: generic hijack setup okay, continuing process.\n"));
        
            ResetEvent(pProcess->m_leftSideUnmanagedWaitEvent);
            DoDbgContinue(pProcess, ue, DBG_CONTINUE, false);
        }
    }

    LOG((LF_CORDB, LL_INFO1000, "W32ET::HLT: hijack last thread done.\n"));
}

//
// DoDbgContinue continues from a specific Win32 DEBUG_EVENT.
//
void CordbWin32EventThread::DoDbgContinue(CordbProcess *pProcess, CordbUnmanagedEvent *ue, DWORD contType, bool contProcess)
{
    _ASSERTE(pProcess->ThreadHoldsProcessLock());
    
    LOG((LF_CORDB, LL_INFO1000,
         "W32ET::DDC: continue with 0x%x (%s), contProcess=%d, tid=0x%x\n",
         contType,
         (contType == DBG_CONTINUE) ? "DBG_CONTINUE" : "DBG_EXCEPTION_NOT_HANDLED",
         contProcess,
         (ue != NULL) ? ue->m_owner->m_id: 0));

    if (contProcess)
    {
        if (pProcess->m_state & (CordbProcess::PS_SOME_THREADS_SUSPENDED | CordbProcess::PS_HIJACKS_IN_PLACE))
            pProcess->ResumeUnmanagedThreads(true);
        if (pProcess->m_leftSideUnmanagedWaitEvent)
            SetEvent(pProcess->m_leftSideUnmanagedWaitEvent);
    }

    if (ue && !ue->IsEventContinued())
    {
        _ASSERTE(pProcess->m_state & CordbProcess::PS_WIN32_STOPPED);

        ue->SetState(CUES_EventContinued);

        // Reset the last IB stopping event if we're continuing from it now.
        if (ue == pProcess->m_lastIBStoppingEvent)
            pProcess->m_lastIBStoppingEvent = NULL;

        // Remove the Win32 stopped flag if the OOB event queue is empty and either the IB event queue is empty or the
        // last IB event has been continued from.
        if ((pProcess->m_outOfBandEventQueue == NULL) &&
            ((pProcess->m_lastQueuedUnmanagedEvent == NULL) || pProcess->m_lastQueuedUnmanagedEvent->IsEventContinued()))
            pProcess->m_state &= ~CordbProcess::PS_WIN32_STOPPED;
        
        LOG((LF_CORDB, LL_INFO1000,
             "W32ET::DDC: calling ContinueDebugEvent(0x%x, 0x%x, 0x%x), process state=0x%x\n",
             pProcess->m_id, ue->m_owner->m_id, contType, pProcess->m_state));

        // If the exception is marked as unclearable, then make sure the continue type is correct and force the process
        // to terminate.
        if (ue->IsExceptionUnclearable())
        {
            TerminateProcess(pProcess->m_handle, ue->m_currentDebugEvent.u.Exception.ExceptionRecord.ExceptionCode);
            contType = DBG_EXCEPTION_NOT_HANDLED;
        }
        
        BOOL ret = ContinueDebugEvent(pProcess->m_id, ue->m_owner->m_id, contType);

        if (!ret)
        {
            _ASSERTE(!"ContinueDebugEvent failed!");
            CORDBProcessSetUnrecoverableWin32Error(pProcess, 0);
            LOG((LF_CORDB, LL_INFO1000, "W32ET::DDC: Last error after ContinueDebugEvent is %d\n", GetLastError()));
        }

        // If we just continued from an exit process event, then its time to do the exit processing.
        if (ue->m_currentDebugEvent.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
            ExitProcess(pProcess, 0);
    }
}

//
// ForceDbgContinue continues from the last Win32 DEBUG_EVENT on the given thread, no matter what it was.
//
void CordbWin32EventThread::ForceDbgContinue(CordbProcess *pProcess, CordbUnmanagedThread *ut, DWORD contType,
                                             bool contProcess)
{
    _ASSERTE(pProcess->ThreadHoldsProcessLock());
    _ASSERTE(ut != NULL);
    
    LOG((LF_CORDB, LL_INFO1000,
         "W32ET::FDC: force continue with 0x%x (%s), contProcess=%d, tid=0x%x\n",
         contType,
         (contType == DBG_CONTINUE) ? "DBG_CONTINUE" : "DBG_EXCEPTION_NOT_HANDLED",
         contProcess,
         ut->m_id));

    if (contProcess)
    {
        if (pProcess->m_state & (CordbProcess::PS_SOME_THREADS_SUSPENDED | CordbProcess::PS_HIJACKS_IN_PLACE))
            pProcess->ResumeUnmanagedThreads(true);

        if (pProcess->m_leftSideUnmanagedWaitEvent)
            SetEvent(pProcess->m_leftSideUnmanagedWaitEvent);
    }

    _ASSERTE(pProcess->m_state & CordbProcess::PS_WIN32_STOPPED);
        
    // Remove the Win32 stopped flag so long as the OOB event queue is empty. We're forcing a continue here, so by
    // definition this should be the case...
    _ASSERTE(pProcess->m_outOfBandEventQueue == NULL);

    pProcess->m_state &= ~CordbProcess::PS_WIN32_STOPPED;
            
    LOG((LF_CORDB, LL_INFO1000, "W32ET::FDC: calling ContinueDebugEvent(0x%x, 0x%x, 0x%x), process state=0x%x\n",
         pProcess->m_id, ut->m_id, contType, pProcess->m_state));
        
    BOOL ret = ContinueDebugEvent(pProcess->m_id, ut->m_id, contType);

    if (!ret)
    {
        _ASSERTE(!"ContinueDebugEvent failed!");
        CORDBProcessSetUnrecoverableWin32Error(pProcess, 0);
        LOG((LF_CORDB, LL_INFO1000, "W32ET::DDC: Last error after ContinueDebugEvent is %d\n", GetLastError()));
    }
}

//
// This is the thread's real thread proc. It simply calls to the
// thread proc on the given object.
//
/*static*/ DWORD WINAPI CordbWin32EventThread::ThreadProc(LPVOID parameter)
{
    CordbWin32EventThread* t = (CordbWin32EventThread*) parameter;
    t->ThreadProc();
    return 0;
}


//
// Send a CreateProcess event to the Win32 thread to have it create us
// a new process.
//
HRESULT CordbWin32EventThread::SendCreateProcessEvent(
                                  LPCWSTR programName,
                                  LPWSTR  programArgs,
                                  LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                  LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                  BOOL bInheritHandles,
                                  DWORD dwCreationFlags,
                                  PVOID lpEnvironment,
                                  LPCWSTR lpCurrentDirectory,
                                  LPSTARTUPINFOW lpStartupInfo,
                                  LPPROCESS_INFORMATION lpProcessInformation,
                                  CorDebugCreateProcessFlags corDebugFlags)
{
    HRESULT hr = S_OK;
    
    LockSendToWin32EventThreadMutex();
    
    m_actionData.createData.programName = programName;
    m_actionData.createData.programArgs = programArgs;
    m_actionData.createData.lpProcessAttributes = lpProcessAttributes;
    m_actionData.createData.lpThreadAttributes = lpThreadAttributes;
    m_actionData.createData.bInheritHandles = bInheritHandles;
    m_actionData.createData.dwCreationFlags = dwCreationFlags;
    m_actionData.createData.lpEnvironment = lpEnvironment;
    m_actionData.createData.lpCurrentDirectory = lpCurrentDirectory;
    m_actionData.createData.lpStartupInfo = lpStartupInfo;
    m_actionData.createData.lpProcessInformation = lpProcessInformation;
    m_actionData.createData.corDebugFlags = corDebugFlags;

    // m_action is set last so that the win32 event thread can inspect
    // it and take action without actually having to take any
    // locks. The lock around this here is simply to prevent multiple
    // threads from making requests at the same time.
    m_action = W32ETA_CREATE_PROCESS;

    BOOL succ = SetEvent(m_threadControlEvent);

    if (succ)
    {
        DWORD ret = WaitForSingleObject(m_actionTakenEvent, INFINITE);

        if (ret == WAIT_OBJECT_0)
            hr = m_actionResult;
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());
        
    UnlockSendToWin32EventThreadMutex();

    return hr;
}


//
// Create a new process. This is called in the context of the Win32
// event thread to ensure that if we're Win32 debugging the process
// that the same thread that waits for debugging events will be the
// thread that creates the process.
//
void CordbWin32EventThread::CreateProcess(void)
{
    m_action = W32ETA_NONE;
    HRESULT hr = S_OK;

    // Process information is passed in the action struct
    PROCESS_INFORMATION *pi =
        m_actionData.createData.lpProcessInformation;

    DWORD dwCreationFlags = m_actionData.createData.dwCreationFlags;

    // Ensure that any environment block actually contains CORDBG_ENABLE.
    BYTE *lpEnvironment = (BYTE*) m_actionData.createData.lpEnvironment;

    bool needToFreeEnvBlock = false;


    // We should have already verified that we can have another debuggee
    _ASSERTE(m_cordb->AllowAnotherProcess());
    

	bool fRemoveControlEnvVar = false;
    if (lpEnvironment != NULL)
    {
        if (dwCreationFlags & CREATE_UNICODE_ENVIRONMENT)
        {
            needToFreeEnvBlock = EnsureCorDbgEnvVarSet(
                                (WCHAR**)&lpEnvironment,
                                (WCHAR*) CorDB_CONTROL_ENV_VAR_NAMEL L"=",
                                true,
                                (DWORD)DBCF_GENERATE_DEBUG_CODE);
        }
        else
        {
            needToFreeEnvBlock = EnsureCorDbgEnvVarSet(
                                (CHAR**)&lpEnvironment,
                                (CHAR*) CorDB_CONTROL_ENV_VAR_NAME "=",
                                false,
                                (DWORD)DBCF_GENERATE_DEBUG_CODE);
        }
    }
    else 
    {
        // If an environment was not passed in, and CorDB_CONTROL_ENV_VAR_NAMEL
        // is not set, set it here.
        WCHAR buf[32];
        DWORD len = WszGetEnvironmentVariable(CorDB_CONTROL_ENV_VAR_NAMEL,
                                              buf, NumItems(buf));
        _ASSERTE(len < sizeof(buf));

        if (len > 0)
            LOG((LF_CORDB, LL_INFO10, "%S already set to %S\n",
                 CorDB_CONTROL_ENV_VAR_NAMEL, buf));
        else
        {
            BOOL succ = WszSetEnvironmentVariable(CorDB_CONTROL_ENV_VAR_NAMEL,
                                                  L"1");

            if (!succ)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto exit;
            }

            LOG((LF_CORDB, LL_INFO10, "Set %S to 1\n",
                 CorDB_CONTROL_ENV_VAR_NAMEL));
            
            fRemoveControlEnvVar = true;
        }

    }
    
    // If the creation flags has DEBUG_PROCESS in them, then we're
    // Win32 debugging this process. Otherwise, we have to create
    // suspended to give us time to setup up our side of the IPC
    // channel.
    BOOL clientWantsSuspend;
    clientWantsSuspend = (dwCreationFlags & CREATE_SUSPENDED);
    
    if (!(dwCreationFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)))
        dwCreationFlags |= CREATE_SUSPENDED;

    // Have Win32 create the process...
    BOOL ret;
    ret = WszCreateProcess(
                      m_actionData.createData.programName,
                      m_actionData.createData.programArgs,
                      m_actionData.createData.lpProcessAttributes,
                      m_actionData.createData.lpThreadAttributes,
                      m_actionData.createData.bInheritHandles,
                      dwCreationFlags,
                      lpEnvironment,
                      m_actionData.createData.lpCurrentDirectory,
                      m_actionData.createData.lpStartupInfo,
                      m_actionData.createData.lpProcessInformation);

    // If we set it earlier, remove it now
    if (fRemoveControlEnvVar)
    {
        BOOL succ = 
            WszSetEnvironmentVariable(CorDB_CONTROL_ENV_VAR_NAMEL, NULL);

        if (!succ)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }
    }


    

    if (ret)
    {
        // Create a process object to represent this process.
        CordbProcess* process = new CordbProcess(m_cordb,
                                                 pi->dwProcessId,
                                                 pi->hProcess);

        if (process != NULL)
        {
            process->AddRef();

            // Initialize the process. This will setup our half of the
            // IPC channel, too.
            hr = process->Init((dwCreationFlags &
                                (DEBUG_PROCESS |
                                 DEBUG_ONLY_THIS_PROCESS)) != 0);

            // Shouldn't happen on a create, only an attach
            _ASSERTE(hr != CORDBG_E_DEBUGGER_ALREADY_ATTACHED);

            // Remember the process in the global list of processes.
            if (SUCCEEDED(hr))
                hr = m_cordb->AddProcess(process);

            if (!SUCCEEDED(hr))
                process->Release();
        }
        else
            hr = E_OUTOFMEMORY;

        // If we're Win32 attached to this process, then increment the
        // proper count, otherwise add this process to the wait set
        // and resume the process's main thread.
        if (SUCCEEDED(hr))
        {
            if (dwCreationFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS))
            {
                // If we're Win32 attached to this process,
                // then increment the proper count.
                m_win32AttachedCount++;

                // We'll be waiting for win32 debug events most of the
                // time now, so only poll for non-win32 process exits.
                m_waitTimeout = 0;
            }
            else
            {
                // We're not Win32 attached, so we'll need to wait on
                // this process's handle to see when it exits. Add the
                // process and its handle into the wait set.
                _ASSERTE(m_waitCount >= 0 && m_waitCount < NumItems(m_waitSet));
                
                m_waitSet[m_waitCount] = process->m_handle;
                m_processSet[m_waitCount] = process;
                m_waitCount++;

                // Also, pretend that we've already received the loader breakpoint so that managed events will get
                // dispatched.
                process->m_loaderBPReceived = true;
                
                // If we need to, go ahead and launch corcdb to attach
                // to this process before resuming the primary
                // thread. This will give corcdb users a chance to get
                // attached early to the process.
                //
                // Note: this is only for internal debugging
                // purposes. It should not be in the final product.
                {
                    char buf[MAX_PATH];
                    DWORD len = GetEnvironmentVariableA("CORDBG_LAUNCH",
                                                        buf, sizeof(buf));
                    _ASSERTE(len < sizeof(buf));

                    if (len > 0)
                    {
                        Sleep(2000);
                        
                        char tmp[MAX_PATH];
                        sprintf(tmp, buf, pi->dwProcessId);

                        WCHAR tmp2[MAX_PATH];

                        for (int i = 0; i < MAX_PATH; i++)
                            tmp2[i] = tmp[i];

                        STARTUPINFOW startupInfo = {0};
                        startupInfo.cb = sizeof (STARTUPINFOW);
                        PROCESS_INFORMATION processInfo = {0};

                        fprintf(stderr, "Launching extra debugger: [%S]\n",
                                tmp2);
                    
                        BOOL ret = WszCreateProcess(
                                    NULL, tmp2, NULL, NULL, FALSE,
                                    CREATE_NEW_CONSOLE, NULL,
                                    m_actionData.createData.lpCurrentDirectory,
                                    &startupInfo, &processInfo);

                        if (!ret)
                            fprintf(stderr, "Failed to launch extra debugger: "
                                    "[%S], err=0x%x(%d)\n",
                                    tmp2, GetLastError(), GetLastError());
                    }
                }
                
                // Resume the process's main thread now that
                // everything is set up. But only resume if the user
                // didn't specify that they wanted the process created
                // suspended!
                if (!clientWantsSuspend)
                    ResumeThread(pi->hThread);
            }
        }
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

exit:

	// If we created this environment block, then free it.
    if (needToFreeEnvBlock)
        delete [] lpEnvironment;
    
    //
    // Signal the hr to the caller.
    //
    m_actionResult = hr;
    SetEvent(m_actionTakenEvent);
}


//
// Send a DebugActiveProcess event to the Win32 thread to have it attach to
// a new process.
//
HRESULT CordbWin32EventThread::SendDebugActiveProcessEvent(
                                                  DWORD pid, 
                                                  bool fWin32Attach,
                                                  CordbProcess *pProcess)
{
    HRESULT hr = S_OK;

    LockSendToWin32EventThreadMutex();
        
    m_actionData.attachData.processId = pid;
    m_actionData.attachData.fWin32Attach = fWin32Attach;
    m_actionData.attachData.pProcess = pProcess;

    // m_action is set last so that the win32 event thread can inspect
    // it and take action without actually having to take any
    // locks. The lock around this here is simply to prevent multiple
    // threads from making requests at the same time.
    m_action = W32ETA_ATTACH_PROCESS;

    BOOL succ = SetEvent(m_threadControlEvent);

    if (succ)
    {
        DWORD ret = WaitForSingleObject(m_actionTakenEvent, INFINITE);

        if (ret == WAIT_OBJECT_0)
            hr = m_actionResult;
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());
        
    UnlockSendToWin32EventThreadMutex();

    return hr;
}

//
// This function is used to close a handle that we've dup'd into another process. We duplicate the handle back to this
// process, telling DuplicateHandle to close the source handle. This closes the handle in the other process, leaving us
// to close the duplicate here.
//
void CordbProcess::CloseDuplicateHandle(HANDLE *pHandle)
{
    if (*pHandle != NULL)
    {
        HANDLE tmp;

        BOOL succ = DuplicateHandle(m_handle, *pHandle, GetCurrentProcess(), &tmp,
                                    NULL, FALSE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);
        
        if (succ)
        {
            CloseHandle(tmp);
            *pHandle = NULL;
        }
    }
}

//
// Cleans up the Left Side's DCB after a failed attach attempt.
//
void CordbProcess::CleanupHalfBakedLeftSide(void)
{
    if (m_DCB != NULL)
    {
        CloseDuplicateHandle(&(m_DCB->m_leftSideEventAvailable));
        CloseDuplicateHandle(&(m_DCB->m_leftSideEventRead));
        CloseDuplicateHandle(&(m_DCB->m_rightSideProcessHandle));

        m_DCB->m_rightSideIsWin32Debugger = false;
    }

    // We need to close the setup sync event if we still have it, since a) we shouldn't leak the handle and b) if the
    // debuggee doesn't have a CLR loaded into it, then it shouldn't have a setup sync event created! This was the cause
    // of bug 98348.
    if (m_SetupSyncEvent != NULL)
    {
        CloseHandle(m_SetupSyncEvent);
        m_SetupSyncEvent = NULL;
    }
}

//
// Attach to a process. This is called in the context of the Win32
// event thread to ensure that if we're Win32 debugging the process
// that the same thread that waits for debugging events will be the
// thread that attaches the process.
//
void CordbWin32EventThread::AttachProcess()
{
    CordbProcess* process = NULL;
    m_action = W32ETA_NONE;
    HRESULT hr = S_OK;


    // We should have already verified that we can have another debuggee
    _ASSERTE(m_cordb->AllowAnotherProcess());
    
    // We need to get a handle to the process.
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, m_actionData.attachData.processId);

    LOG((LF_CORDB, LL_INFO10000, "[%x] W32ET::TP: process handle 0x%08x\n", GetCurrentThreadId(), hProcess));
            
    if (hProcess != NULL)
    {
        // Create a process object to represent this process.
        process = new CordbProcess(m_cordb, m_actionData.attachData.processId, hProcess);

        if (process != NULL)
        {
            process->AddRef();
            
            // Initialize the process. This will setup our half of the IPC channel, too.
            hr = process->Init(m_actionData.attachData.fWin32Attach);

            // Remember the process in the global list of processes.
            if (SUCCEEDED(hr))
                hr = m_cordb->AddProcess(process);

            if (!SUCCEEDED(hr))
            {
                process->CleanupHalfBakedLeftSide();
                process->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            CloseHandle(hProcess);
        }

        // If we're Win32 attaching to this process, then increment
        // the proper count, otherwise add this process to the wait
        // set and resume the process's main thread.
        if (SUCCEEDED(hr))
        {
            if (m_actionData.attachData.fWin32Attach)
            {
                // Win32 attach to the process.
                BOOL succ =
                    DebugActiveProcess(m_actionData.attachData.processId);

                LOG((LF_CORDB, LL_INFO10000,
                     "[%x] W32ET::TP: DebugActiveProcess -- %d\n",
                     GetCurrentThreadId(), succ));

                if (succ)
                {
                    // Since we're Win32 attached to this process,
                    // increment the proper count.
                    m_win32AttachedCount++;

                    // We'll be waiting for win32 debug events most of
                    // the time now, so only poll for non-win32
                    // process exits.
                    m_waitTimeout = 0;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());

                    // Remove the process from the process hash and clean it up.
                    m_cordb->RemoveProcess(process);
                    process->CleanupHalfBakedLeftSide();

                    // Finally, destroy the dead process object.
                    process->Release();
                }
            }
            else
            {
                // We're not Win32 attached, so we'll need to wait on
                // this process's handle to see when it exits. Add the
                // process and its handle into the wait set.
                _ASSERTE(m_waitCount >= 0 && m_waitCount < NumItems(m_waitSet));
                
                m_waitSet[m_waitCount] = process->m_handle;
                m_processSet[m_waitCount] = process;
                m_waitCount++;

                // Also, pretend that we've already received the loader breakpoint so that managed events will get
                // dispatched.
                process->m_loaderBPReceived = true;
            }
        }
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    //
    // Signal the hr to the caller.
    //
    m_actionResult = hr;
    SetEvent(m_actionTakenEvent);
}

// Note that the actual 'DetachProcess' method is really ExitProcess with CW32ET_UNKNOWN_PROCESS_SLOT ==
// processSlot
HRESULT CordbWin32EventThread::SendDetachProcessEvent(CordbProcess *pProcess)
{
    LOG((LF_CORDB, LL_INFO1000, "W32ET::SDPE\n"));    
    HRESULT hr = S_OK;
    
    LockSendToWin32EventThreadMutex();
    
    m_actionData.detachData.pProcess = pProcess;

    // m_action is set last so that the win32 event thread can inspect it and take action without actually
    // having to take any locks. The lock around this here is simply to prevent multiple threads from making
    // requests at the same time.
    m_action = W32ETA_DETACH;

    BOOL succ = SetEvent(m_threadControlEvent);

    if (succ)
    {
        DWORD ret = WaitForSingleObject(m_actionTakenEvent, INFINITE);

        if (ret == WAIT_OBJECT_0)
            hr = m_actionResult;
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());
        
    UnlockSendToWin32EventThreadMutex();

    return hr;
}

//
// Send a UnmanagedContinue event to the Win32 thread to have it
// continue from an unmanged debug event.
//
HRESULT CordbWin32EventThread::SendUnmanagedContinue(CordbProcess *pProcess,
                                                     bool internalContinue,
                                                     bool outOfBandContinue)
{
    HRESULT hr = S_OK;
    
    LockSendToWin32EventThreadMutex();
    
    m_actionData.continueData.process = pProcess;
    m_actionData.continueData.internalContinue = internalContinue;
    m_actionData.continueData.outOfBandContinue = outOfBandContinue;

    // m_action is set last so that the win32 event thread can inspect
    // it and take action without actually having to take any
    // locks. The lock around this here is simply to prevent multiple
    // threads from making requests at the same time.
    m_action = W32ETA_CONTINUE;

    BOOL succ = SetEvent(m_threadControlEvent);

    if (succ)
    {
        DWORD ret = WaitForSingleObject(m_actionTakenEvent, INFINITE);

        if (ret == WAIT_OBJECT_0)
            hr = m_actionResult;
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());
        
    UnlockSendToWin32EventThreadMutex();

    return hr;
}


//
// Handle unmanaged continue. Continue an unmanaged debug
// event. Deferes to UnmanagedContinue. This is called in the context
// of the Win32 event thread to ensure that if we're Win32 debugging
// the process that the same thread that waits for debugging events
// will be the thread that continues the process.
//
void CordbWin32EventThread::HandleUnmanagedContinue(void)
{
    m_action = W32ETA_NONE;
    HRESULT hr = S_OK;

    // Continue the process
    CordbProcess *pProcess = m_actionData.continueData.process;

    pProcess->AddRef();
    pProcess->Lock();
    hr = UnmanagedContinue(pProcess,
                           m_actionData.continueData.internalContinue,
                           m_actionData.continueData.outOfBandContinue);
    pProcess->Unlock();
    pProcess->Release();

    // Signal the hr to the caller.
    m_actionResult = hr;
    SetEvent(m_actionTakenEvent);
}

//
// Continue an unmanaged debug event. This is called in the context of the Win32 Event thread to ensure that the same
// thread that waits for debug events will be the thread that continues the process.
//
HRESULT CordbWin32EventThread::UnmanagedContinue(CordbProcess *pProcess,
                                                 bool internalContinue,
                                                 bool outOfBandContinue)
{
    _ASSERTE(pProcess->ThreadHoldsProcessLock());
    
    HRESULT hr = S_OK;

    if (outOfBandContinue)
    {
        _ASSERTE(pProcess->m_outOfBandEventQueue != NULL);

        // Dequeue the OOB event.
        CordbUnmanagedEvent *ue = pProcess->m_outOfBandEventQueue;
        CordbUnmanagedThread *ut = ue->m_owner;
        pProcess->DequeueOOBUnmanagedEvent(ut);

        // Do a little extra work if that was an OOB exception event...
        HRESULT hr = ue->m_owner->FixupAfterOOBException(ue);
        _ASSERTE(SUCCEEDED(hr));

        // Continue from the event.
        DoDbgContinue(pProcess,
                      ue,
                      ue->IsExceptionCleared() ?
                       DBG_CONTINUE :
                       DBG_EXCEPTION_NOT_HANDLED,
                      false);

        // If there are more queued OOB events, dispatch them now.
        if (pProcess->m_outOfBandEventQueue != NULL)
            pProcess->DispatchUnmanagedOOBEvent();

        // Note: if we previously skipped letting the entire process go on an IB continue due to a blocking OOB event,
        // and if the OOB event queue is now empty, then go ahead and let the process continue now...
        if ((pProcess->m_doRealContinueAfterOOBBlock == true) &&
            (pProcess->m_outOfBandEventQueue == NULL))
            goto doRealContinue;
    }
    else if (internalContinue)
    {
        LOG((LF_CORDB, LL_INFO1000, "W32ET::UC: internal continue.\n"));

        if (!pProcess->GetSynchronized())
        {
            LOG((LF_CORDB, LL_INFO1000, "W32ET::UC: internal continue, !sync'd.\n"));
            
            pProcess->ResumeUnmanagedThreads(false);

            // Note: The process can be marked PS_WIN32_STOPPED because there is an outstanding OOB event that needs to
            // be continued from. This can't happen until we get out of here. We need to gate the process continue,
            // then, on both PS_WIN32_STOPPED _and_ the existence of an uncontinued IB stopping event.

            // We need to continue from the last queued inband event. However, sometimes the last queued IB event
            // isn't actually the last one we haven't continued from, so if m_lastIBStoppingEvent is set the prefer
            // it over the last queued event.
            CordbUnmanagedEvent *ue;
                
            if (pProcess->m_lastIBStoppingEvent != NULL)
                ue = pProcess->m_lastIBStoppingEvent;
            else
                ue = pProcess->m_lastQueuedUnmanagedEvent;

            
            if ((pProcess->m_state & CordbProcess::PS_WIN32_STOPPED) && (ue != NULL) && !ue->IsEventContinued())
            {
                LOG((LF_CORDB, LL_INFO1000, "W32ET::UC: internal continue, stopped.\n"));
            
                CordbUnmanagedThread *ut = ue->m_owner;
                
                // If the thread that last caused the stop is not hijacked, then hijack it now and do the proper
                // continue. Otherwise, do a normal DBG_CONTINUE.
                if (!ut->IsFirstChanceHijacked() && !ut->IsGenericHijacked() && !ut->IsSecondChanceHijacked())
                {
                    LOG((LF_CORDB, LL_INFO1000, "W32ET::UC: internal continue, needs hijack.\n"));
            
                    HijackLastThread(pProcess, ut); // Does the continue
                }
                else
                {
                    LOG((LF_CORDB, LL_INFO1000, "W32ET::UC: internal continue, no hijack needed.\n"));
            
                    DoDbgContinue(pProcess, ue, DBG_CONTINUE, false);
                }

                // The thread that caused the above to happen will send an async break message to the left side then
                // wait for the stop event to be set.
            }
        }
        
        LOG((LF_CORDB, LL_INFO1000, "W32ET::UC: internal continue, done.\n"));
    }
    else
    {
        // If we're here, then we know 100% for sure that we've successfully gotten the managed continue event to the
        // Left Side, so we can stop force hijacking left over in-band events now. Note: if we had hijacked any such
        // events, they'll be dispatched below since they're properly queued.
        pProcess->m_specialDeferment = false;
        
        // We don't actually do any work if there is an outstanding out-of-band event. When we do continue from the
        // out-of-band event, we'll do this work, too.
        if (pProcess->m_outOfBandEventQueue != NULL)
        {
            LOG((LF_CORDB, LL_INFO1000, "W32ET::UC: ignoring real continue due to block by out-of-band event(s).\n"));

            _ASSERTE(pProcess->m_doRealContinueAfterOOBBlock == false);
            pProcess->m_doRealContinueAfterOOBBlock = true;
        }
        else
        {
doRealContinue:
            _ASSERTE(pProcess->m_outOfBandEventQueue == NULL);
            
            pProcess->m_doRealContinueAfterOOBBlock = false;
            
            LOG((LF_CORDB, LL_INFO1000, "W32ET::UC: continuing the process.\n"));

            // Note: its possible to get here without a queued IB event. This can happen, for example, when doing the
            // win32 continue portion of continuing from a normal managed event.

            // Dequeue the first event on the unmanaged event queue if its already been dispatched. If not, then leave
            // it on there and let it get dispatched.
            CordbUnmanagedThread *ut = NULL;
            CordbUnmanagedEvent *ue = NULL;

            if ((pProcess->m_unmanagedEventQueue != NULL) && pProcess->m_unmanagedEventQueue->IsDispatched())
            {
                ue = pProcess->m_unmanagedEventQueue;
                ut = ue->m_owner;

                ut->AddRef(); // Keep ut alive after its dequeued...
                
                pProcess->DequeueUnmanagedEvent(ut);
            }

            // Dispatch any more queued in-band events, or if there are none then just continue the process.
            //
            // Note: don't dispatch more events if we've already sent up the ExitProcess event... those events are just
            // lost.
            if ((pProcess->m_unmanagedEventQueue != NULL) && (pProcess->m_exiting == false))
            {
                // Only dispatch if we're not waiting for any more ownership answers. Otherwise, defer the rest of the
                // work until all ownership questions have been decided.
                if (pProcess->m_awaitingOwnershipAnswer == 0)
                    pProcess->DispatchUnmanagedInBandEvent();
                else
                    pProcess->m_deferContinueDueToOwnershipWait = true;
            }
            else
            {
                DWORD contType = DBG_CONTINUE; // won't be used if not stopped.

                if (ue && !ue->IsEventContinued())
                    contType = (ue->IsExceptionCleared() | ut->IsFirstChanceHijacked()) ?
                        DBG_CONTINUE : DBG_EXCEPTION_NOT_HANDLED;
            
                // If the unmanaged event queue is empty now, and the process is synchronized, and there are queued
                // managed events, then go ahead and get more managed events dispatched.
                //
                // Note: don't dispatch more events if we've already sent up the ExitProcess event... those events are
                // just lost.
                if (pProcess->GetSynchronized() && (pProcess->m_queuedEventList != NULL) && (pProcess->m_exiting == false))
                {
                    // Continue just this unmanaged event.
                    DoDbgContinue(pProcess, ue, contType, false);

                    // Now, get more managed events dispatched.
                    pProcess->SetSynchronized(false);
                    pProcess->MarkAllThreadsDirty();
                    m_cordb->ProcessStateChanged();
                }
                else
                {
                    // Continue this unmanaged event, and the whole process.
                    DoDbgContinue(pProcess, ue, contType, true);
                }
            }

            if (ut)
                ut->Release();
        }
    }
    
    return hr;
}


//
// ExitProcess is called when a process exits. This does our final cleanup and removes the process from our
// wait sets.
//
void CordbWin32EventThread::ExitProcess(CordbProcess *process, unsigned int processSlot)
{
    LOG((LF_CORDB, LL_INFO1000,"W32ET::EP: begin ExitProcess, processSlot=%d\n", processSlot));
    
    // We're either here because we're detaching (fDetach == TRUE), or because the process has really exited,
    // and we're doing shutdown logic.
    BOOL fDetach = CW32ET_UNKNOWN_PROCESS_SLOT == processSlot;

    // Mark the process teminated. After this, the RCET will never call FlushQueuedEvents. It will
    // ignore all events it receives (including a SyncComplete) and the RCET also does not listen
    // to terminated processes (so ProcessStateChange() won't cause a FQE either).
    process->Terminating(fDetach);
    
    // Take care of the race where the process exits right after the user calls Continue() from the last
    // managed event but before the handler has actually returned.
    //
    // Also, To get through this lock means that either:
    // 1. FlushQueuedEvents is not currently executing and no one will call FQE. 
    // 2. FQE is exiting but is in the middle of a callback (so m_dispatchingEvent = true)
    // 
    process->Lock();

    process->m_exiting = true;
            
    if (fDetach)
        process->SetSynchronized(false);

    // Close off the handle to the setup sync event now, since we know that the pid could be reused at this
    // point (depending on how the exit occured.)
    if (process->m_SetupSyncEvent != NULL)
    {
        LOG((LF_CORDB, LL_INFO1000,"W32ET::EP: Shutting down setupsync event\n"));
        
        CloseHandle(process->m_SetupSyncEvent);
        process->m_SetupSyncEvent = NULL;

        process->m_DCB = NULL;

        if (process->m_IPCReader.IsPrivateBlockOpen())
        {           
            process->m_IPCReader.ClosePrivateBlock();
            LOG((LF_CORDB, LL_INFO1000,"W32ET::EP: Closing private block\n"));
        }

    }
    
    // If we are exiting, we *must* dispatch the ExitProcess callback, but we will delete all the events
    // in the queue and not bother dispatching anything else. If (and only if) we are currently dispatching
    // an event, then we will wait while that event is finished before invoking ExitProcess.
    // (Note that a dispatched event has already been removed from the queue)


    // Delete all queued events while under the lock
    LOG((LF_CORDB, LL_INFO1000, "W32ET::EP: Begin deleting queued events\n"));

    DebuggerIPCEvent* event = process->m_queuedEventList;
    while (event != NULL)
    {        
        LOG((LF_CORDB, LL_INFO1000, "W32ET::EP: Deleting queued event: '%s'\n", IPCENames::GetName(event->type)));

        DebuggerIPCEvent* next = event->next;                
        free(event);
        event = next;
    }    
    process->m_queuedEventList = NULL;
    
    LOG((LF_CORDB, LL_INFO1000, "W32ET::EP: Finished deleting queued events\n"));

        
    // Allow a concurrently executing callback to finish before invoke the ExitProcess callback
    // Note that we must check this flag before unlocking (to avoid a race)
    if (process->m_dispatchingEvent)
    {
        process->Unlock();
        LOG((LF_CORDB, LL_INFO1000, "W32ET::EP: event currently dispatching. Waiting for it to finish\n"));
        
        // This will be signaled by FlushQueuedEvents() when we return from the currently 
        // dispatched event
        DWORD ret = WaitForSingleObject(process->m_miscWaitEvent, INFINITE);

        LOG((LF_CORDB, LL_INFO1000, "W32ET::EP: event finished dispatching, ret = %d\n", ret));
    }
    else 
    {
        LOG((LF_CORDB, LL_INFO1000, "W32ET::EP: No event dispatching. Not waiting\n"));
        process->Unlock();
    }

        

    if (!fDetach)
    {
        LOG((LF_CORDB, LL_INFO1000,"W32ET::EP: ExitProcess callback\n"));

        process->Lock();

        // We're synchronized now, so mark the process as such.
        process->SetSynchronized(true);
        
        process->m_stopCount++;

        process->Unlock();

        // Invoke the ExitProcess callback. This is very important since the a shell
        // may rely on it for proper shutdown and may hang if they don't get it.
        if (m_cordb->m_managedCallback)
            m_cordb->m_managedCallback->ExitProcess((ICorDebugProcess*)process);

        LOG((LF_CORDB, LL_INFO1000,"W32ET::EP: returned from ExitProcess callback\n"));
    }
    
    // Remove the process from the global list of processes.
    m_cordb->RemoveProcess(process);

    // Release the process.
    process->Neuter();
    process->Release();

	// If it's a managed process, somewhere, go find it.
	if (fDetach)
	{
        LOG((LF_CORDB, LL_INFO1000,"W32ET::EP: Detach find proc!\n"));
	    _ASSERTE(CW32ET_UNKNOWN_PROCESS_SLOT == processSlot);

		processSlot = 0;

		for(unsigned int i = 0; i < m_waitCount; i++)
		{
			if (m_processSet[i] == process)
				processSlot = i;
		}
	}

    // Was this process in the non-Win32 attached wait list?
    if (processSlot > 0)
    {
        LOG((LF_CORDB, LL_INFO1000,"W32ET::EP: non Win32\n"));

        // Remove the process from the wait list by sucking all the other processes down one.
        if ((processSlot + 1) < m_waitCount)
        {
            LOG((LF_CORDB, LL_INFO1000,"W32ET::EP: Proc shuffle down!\n"));
        
            memcpy(&m_processSet[processSlot],
                   &m_processSet[processSlot+1],
                   sizeof(m_processSet[0]) * (m_waitCount - processSlot - 1));
            memcpy(&m_waitSet[processSlot], &m_waitSet[processSlot+1],
                   sizeof(m_waitSet[0]) * (m_waitCount - processSlot - 1));
        }

        // Drop the count of non-Win32 attached processes to wait on.
        m_waitCount--;
    }
    else
    {
        LOG((LF_CORDB, LL_INFO1000,"W32ET::EP: Win32 attached!\n"));
        
        // We were Win32 attached to this process, so drop the count.
        m_win32AttachedCount--;

        // If that was the last Win32 process, up the wait timeout
        // because we won't be calling WaitForDebugEvent anymore...
        if (m_win32AttachedCount == 0)
            m_waitTimeout = INFINITE;
    }

    if (fDetach)
    {
        // Signal the hr to the caller.
        LOG((LF_CORDB, LL_INFO1000,"W32ET::EP: Detach: send result back!\n"));
        
        m_actionResult = S_OK;
        SetEvent(m_actionTakenEvent);
    }    
}


//
// Start actually creates and starts the thread.
//
HRESULT CordbWin32EventThread::Start(void)
{
    if (m_threadControlEvent == NULL)
        return E_INVALIDARG;
    
    m_thread = CreateThread(NULL, 0, CordbWin32EventThread::ThreadProc,
                            (LPVOID) this, 0, &m_threadId);

    if (m_thread == NULL)
        return HRESULT_FROM_WIN32(GetLastError());

    return S_OK;
}


//
// Stop causes the thread to stop receiving events and exit. It
// waits for it to exit before returning.
//
HRESULT CordbWin32EventThread::Stop(void)
{
    HRESULT hr = S_OK;
    
    if (m_thread != NULL)
    {
        LockSendToWin32EventThreadMutex();
        m_action = W32ETA_NONE;
        m_run = FALSE;
        
        SetEvent(m_threadControlEvent);
        UnlockSendToWin32EventThreadMutex();

        DWORD ret = WaitForSingleObject(m_thread, INFINITE);
                
        if (ret != WAIT_OBJECT_0)
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}





/* ------------------------------------------------------------------------- *
 * AppDomain class methods
 * ------------------------------------------------------------------------- */
CordbAppDomain::CordbAppDomain(CordbProcess* pProcess, 
                               REMOTE_PTR pAppDomainToken,
                               ULONG id,
                               WCHAR *szName)

    : CordbBase((ULONG)pAppDomainToken, enumCordbAppDomain),
    m_pProcess(pProcess),
    m_AppDomainId(id),
    m_fAttached(FALSE),
    m_modules(17),
    m_breakpoints(17),
    m_assemblies(9),
    m_fMarkedForDeletion(FALSE),
    m_nameIsValid(false),
    m_synchronizedAD(false),
    m_fHasAtLeastOneThreadInsideIt(false)
{
#ifndef RIGHT_SIDE_ONLY
    m_assemblies.m_guid = IID_ICorDebugAssemblyEnum;
    m_assemblies.m_creator.lsAssem.m_appDomain = this;

    m_modules.m_guid = IID_ICorDebugModuleEnum;
    m_modules.m_creator.lsMod.m_proc = pProcess;
    m_modules.m_creator.lsMod.m_appDomain = this;
#endif //RIGHT_SIDE_ONLY

    // Make a copy of the name. 
    if (szName == NULL)
        szName = L"<UnknownName>";
    else
        m_nameIsValid = true; // We've been passed a good name.

    m_szAppDomainName = new WCHAR[wcslen(szName) + 1];

    if (m_szAppDomainName)
        wcscpy(m_szAppDomainName, szName);

    LOG((LF_CORDB,LL_INFO10000, "CAD::CAD: this:0x%x (void*)this:0x%x"
        "<%S>\n", this, (void *)this, m_szAppDomainName));
    
    InitializeCriticalSection (&m_hCritSect);
}

/*
    A list of which resources owened by this object are accounted for.

    RESOLVED:
        // AddRef() in CordbHashTable::GetBase for a special InProc case
        // AddRef() on the DB_IPCE_CREATE_APP_DOMAIN event from the LS
        // Release()ed in Neuter
        CordbProcess        *m_pProcess; 
        
        WCHAR               *m_szAppDomainName; // Deleted in ~CordbAppDomain
        
        // Cleaned up in Neuter
        CordbHashTable      m_assemblies;
        CordbHashTable      m_modules;
        CordbHashTable      m_breakpoints; // Disconnect()ed in ~CordbAppDomain

    private:
        CRITICAL_SECTION    m_hCritSect; // Deleted in ~CordbAppDomain
*/

CordbAppDomain::~CordbAppDomain()
{
    if (m_szAppDomainName)
        delete [] m_szAppDomainName;

#ifdef RIGHT_SIDE_ONLY
    //
    // Disconnect any active breakpoints
    //
    CordbBase* entry;
    HASHFIND find;

    for (entry =  m_breakpoints.FindFirst(&find);
         entry != NULL;
         entry =  m_breakpoints.FindNext(&find))
    {
        CordbStepper *breakpoint = (CordbStepper*) entry;
        breakpoint->Disconnect();
    }
#endif //RIGHT_SIDE_ONLY

    DeleteCriticalSection(&m_hCritSect);
}

// Neutered by process
void CordbAppDomain::Neuter()
{
    AddRef();
    {
        _ASSERTE(m_pProcess);
        m_pProcess->Release(); 

        NeuterAndClearHashtable(&m_assemblies);
        NeuterAndClearHashtable(&m_modules);
        NeuterAndClearHashtable(&m_breakpoints);

        CordbBase::Neuter();
    }        
    Release();
}


HRESULT CordbAppDomain::QueryInterface(REFIID id, void **ppInterface)
{
    if (id == IID_ICorDebugAppDomain)
        *ppInterface = (ICorDebugAppDomain*)this;
    else if (id == IID_ICorDebugController)
        *ppInterface = (ICorDebugController*)(ICorDebugAppDomain*)this;
    else if (id == IID_IUnknown)
        *ppInterface = (IUnknown*)(ICorDebugAppDomain*)this;
    else
    {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


HRESULT CordbAppDomain::Stop(DWORD dwTimeout)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    return (m_pProcess->StopInternal(dwTimeout, (void *)m_id));
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbAppDomain::Continue(BOOL fIsOutOfBand)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    return (m_pProcess->ContinueInternal(fIsOutOfBand, NULL)); //(void *)m_id));
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbAppDomain::IsRunning(BOOL *pbRunning)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(pbRunning, BOOL *);

    *pbRunning = !m_pProcess->GetSynchronized();

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbAppDomain::HasQueuedCallbacks(ICorDebugThread *pThread, BOOL *pbQueued)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pThread,ICorDebugThread *);
    VALIDATE_POINTER_TO_OBJECT(pbQueued,BOOL *);

    return m_pProcess->HasQueuedCallbacks (pThread, pbQueued);
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbAppDomain::EnumerateThreads(ICorDebugThreadEnum **ppThreads)
{
    VALIDATE_POINTER_TO_OBJECT(ppThreads,ICorDebugThreadEnum **);

    HRESULT hr = S_OK;
    CordbEnumFilter *pThreadEnum;

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessSynchronized(this->m_pProcess, this);
#endif //RIGHT_SIDE_ONLY

    CordbHashTableEnum *e = new CordbHashTableEnum(&m_pProcess->m_userThreads, 
                                                   IID_ICorDebugThreadEnum);
    if (e == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pThreadEnum = new CordbEnumFilter;
    if (pThreadEnum == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = pThreadEnum->Init (e, this);

    if (SUCCEEDED (hr))
    {
        *ppThreads = (ICorDebugThreadEnum *) pThreadEnum;
        pThreadEnum->AddRef();
    }
    else
        delete pThreadEnum;

Error:
    if (e != NULL)
        delete e;
    return hr;
}


HRESULT CordbAppDomain::SetAllThreadsDebugState(CorDebugThreadState state,
                                   ICorDebugThread *pExceptThisThread)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    return m_pProcess->SetAllThreadsDebugState(state, pExceptThisThread);
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbAppDomain::Detach()
{
    LOG((LF_CORDB, LL_INFO1000, "CAD::Detach - beginning\n"));
#ifndef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOK(m_pProcess);
    
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    CORDBRequireProcessStateOKAndSync(m_pProcess, NULL);
    
    HRESULT hr = S_OK;

    if (m_fAttached)
    {
        // Remember that we're no longer attached to this AD.
        m_fAttached = FALSE;

        // Tell the Left Side that we're no longer attached to this AD.
        DebuggerIPCEvent *event =
            (DebuggerIPCEvent*) _alloca(CorDBIPC_BUFFER_SIZE);
        m_pProcess->InitIPCEvent(event, 
                                 DB_IPCE_DETACH_FROM_APP_DOMAIN, 
                                 false, 
                                 (void *)m_id);
        event->AppDomainData.id = m_AppDomainId;
    
        hr = m_pProcess->m_cordb->SendIPCEvent(this->m_pProcess,
                                               event,
                                               CorDBIPC_BUFFER_SIZE);

        LOG((LF_CORDB, LL_INFO1000, "[%x] CAD::Detach: pProcess=%x sent.\n", 
             GetCurrentThreadId(), this));
    }

    LOG((LF_CORDB, LL_INFO10000, "CP::Detach - returning w/ hr=0x%x\n", hr));
    return hr;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbAppDomain::Terminate(unsigned int exitCode)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    return E_NOTIMPL;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT CordbAppDomain::CanCommitChanges(
    ULONG cSnapshots, 
    ICorDebugEditAndContinueSnapshot *pSnapshots[], 
    ICorDebugErrorInfoEnum **pError)
{    
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pSnapshots,
                                   ICorDebugEditAndContinueSnapshot *, 
                                   cSnapshots, 
                                   true, 
                                   true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pError,ICorDebugErrorInfoEnum **);
    
    return m_pProcess->CanCommitChangesInternal(cSnapshots, pSnapshots, pError, m_id);
#endif
}

HRESULT CordbAppDomain::CommitChanges(
    ULONG cSnapshots, 
    ICorDebugEditAndContinueSnapshot *pSnapshots[], 
    ICorDebugErrorInfoEnum **pError)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    LOG((LF_CORDB,LL_INFO10000, "CAD::CC: given 0x%x snapshots"
        "to commit\n", cSnapshots));
    
    VALIDATE_POINTER_TO_OBJECT_ARRAY(pSnapshots,
                                   ICorDebugEditAndContinueSnapshot *, 
                                   cSnapshots, 
                                   true, 
                                   true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pError,ICorDebugErrorInfoEnum **);
    
    return m_pProcess->CommitChangesInternal(cSnapshots, pSnapshots, pError, m_id);
#endif
}


/*      
 * GetProcess returns the process containing the app domain
 */
HRESULT CordbAppDomain::GetProcess(ICorDebugProcess **ppProcess)
{
    VALIDATE_POINTER_TO_OBJECT(ppProcess,ICorDebugProcess **);
    
    _ASSERTE (m_pProcess != NULL);

    *ppProcess = (ICorDebugProcess *)m_pProcess;
    (*ppProcess)->AddRef();

    return S_OK;
}

/*        
 * EnumerateAssemblies enumerates all assemblies in the app domain
 */
HRESULT CordbAppDomain::EnumerateAssemblies(ICorDebugAssemblyEnum **ppAssemblies)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppAssemblies,ICorDebugAssemblyEnum **);

    CordbHashTableEnum *e = new CordbHashTableEnum(&m_assemblies,
                                                   IID_ICorDebugAssemblyEnum);
    if (e == NULL)
        return E_OUTOFMEMORY;

    *ppAssemblies = (ICorDebugAssemblyEnum*)e;
    e->AddRef();

    return S_OK;
#endif
}


HRESULT CordbAppDomain::GetModuleFromMetaDataInterface(
                                                  IUnknown *pIMetaData,
                                                  ICorDebugModule **ppModule)
{
    IMetaDataImport *imi = NULL;

#ifdef RIGHT_SIDE_ONLY
    CORDBRequireProcessStateOKAndSync(this->m_pProcess, this);
#else 
    // For the Virtual Right Side (In-proc debugging), we'll
    // always be synched, but not neccessarily b/c we've
    // gotten a synch message.
    CORDBRequireProcessStateOK(this->m_pProcess);
#endif    
    VALIDATE_POINTER_TO_OBJECT(pIMetaData, IUnknown *);
    VALIDATE_POINTER_TO_OBJECT(ppModule, ICorDebugModule **);

	INPROC_LOCK();

    HRESULT hr = S_OK;
#ifndef RIGHT_SIDE_ONLY

    //Load the table in-proc.
    CordbHashTableEnum *e = new CordbHashTableEnum(&m_modules, 
                                                   IID_ICorDebugModuleEnum);
    if (e == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    ICorDebugThreadEnum *pThreads;
    hr = EnumerateThreads(&pThreads);
    if (FAILED(hr))
        goto exit;

    _ASSERTE(pThreads != NULL);

    e->m_enumerator.lsMod.m_enumThreads = pThreads;
    e->m_enumerator.lsMod.m_appDomain = this;

    ICorDebugModule *pModule;
    ULONG cElt;
    hr = e->Next(1, &pModule, &cElt);
    
    while(!FAILED(hr) && cElt == 1)
    {
        hr = e->Next(1, &pModule, &cElt);
    }
    
#endif //RIGHT_SIDE_ONLY
    
    // Grab the interface we need...
    hr = pIMetaData->QueryInterface(IID_IMetaDataImport,
                                            (void**)&imi);

    if (FAILED(hr))
    {
        hr =  E_INVALIDARG;
        goto exit;
    }
    
    // Get the mvid of the given module.
    GUID matchMVID;
    hr = imi->GetScopeProps(NULL, 0, 0, &matchMVID);

    if (FAILED(hr))
        goto exit;

    CordbBase* moduleentry;
    HASHFIND findmodule;

    for (moduleentry =  m_modules.FindFirst(&findmodule);
         moduleentry != NULL;
         moduleentry =  m_modules.FindNext(&findmodule))
    {
        CordbModule* m = (CordbModule*) moduleentry;

        // Get the mvid of this module
        GUID MVID;
        hr = m->m_pIMImport->GetScopeProps(NULL, 0, 0, &MVID);

        if (FAILED(hr))
            goto exit;

        if (MVID == matchMVID)
        {
            *ppModule = (ICorDebugModule*)m;
            (*ppModule)->AddRef();

            goto exit;
        }
    }

    hr = E_INVALIDARG;
    
exit:
	INPROC_UNLOCK();
    imi->Release();
    return hr;
}

HRESULT CordbAppDomain::ResolveClassByName(LPWSTR fullClassName,
                                           CordbClass **ppClass)
{
    CordbBase* moduleentry;
    HASHFIND findmodule;

    for (moduleentry =  m_modules.FindFirst(&findmodule);
         moduleentry != NULL;
         moduleentry =  m_modules.FindNext(&findmodule))
    {
        CordbModule* m = (CordbModule*) moduleentry;

        if (SUCCEEDED(m->LookupClassByName(fullClassName, ppClass)))
            return S_OK;
    }

    return E_FAIL;
}

CordbModule *CordbAppDomain::GetAnyModule(void)
{   
    // Get the first module in the assembly
    HASHFIND find;
    CordbModule *module = (CordbModule*) m_modules.FindFirst(&find);

    return module;
}


HRESULT CordbAppDomain::EnumerateBreakpoints(ICorDebugBreakpointEnum **ppBreakpoints)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppBreakpoints, ICorDebugBreakpointEnum **);

    CORDBRequireProcessSynchronized(this->m_pProcess, this);

    CordbHashTableEnum *e = new CordbHashTableEnum(&m_breakpoints, 
                                                   IID_ICorDebugBreakpointEnum);
    if (e == NULL)
        return E_OUTOFMEMORY;

    *ppBreakpoints = (ICorDebugBreakpointEnum*)e;
    e->AddRef();

    return S_OK;
#endif //RIGHT_SIDE_ONLY
}

HRESULT CordbAppDomain::EnumerateSteppers(ICorDebugStepperEnum **ppSteppers)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(ppSteppers,ICorDebugStepperEnum **);

    CORDBRequireProcessSynchronized(this->m_pProcess, this);

    //
    // !!! m_steppers may be modified while user is enumerating,
    // if steppers complete (if process is running)
    //

    CordbHashTableEnum *e = new CordbHashTableEnum(&(m_pProcess->m_steppers),
                                                   IID_ICorDebugStepperEnum);
    if (e == NULL)
        return E_OUTOFMEMORY;

    *ppSteppers = (ICorDebugStepperEnum*)e;
    e->AddRef();

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}


/*
 * IsAttached returns whether or not the debugger is attached to the 
 * app domain.  The controller methods on the app domain cannot be used
 * until the debugger attaches to the app domain.
 */
HRESULT CordbAppDomain::IsAttached(BOOL *pbAttached)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    VALIDATE_POINTER_TO_OBJECT(pbAttached, BOOL *);

    *pbAttached = m_fAttached;

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

HRESULT inline CordbAppDomain::Attach (void)
{
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    m_pProcess->Attach(m_AppDomainId);
    m_fAttached = TRUE;

    return S_OK;
#endif //RIGHT_SIDE_ONLY    
}

/*
 * GetName returns the name of the app domain. 
 */
HRESULT CordbAppDomain::GetName(ULONG32 cchName, 
                                ULONG32 *pcchName,
                                WCHAR szName[]) 
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY_OR_NULL(szName, WCHAR, cchName, true, true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pcchName, ULONG32 *);

	INPROC_LOCK();
	
    // send message across to the left side to get the app domain name
    SIZE_T iTrueLen;
    HRESULT hr = S_OK;

    // Some reasonable defaults
    if (szName)
        *szName = 0;

    if (pcchName)
        *pcchName = 0;
    
    // Get the name from the left side
    if (!m_nameIsValid)
    {
        // send message across to the left side to get the app domain name  
        DebuggerIPCEvent event;

        m_pProcess->InitIPCEvent(&event, 
                                 DB_IPCE_GET_APP_DOMAIN_NAME, 
                                 true,
                                 (void*)m_id);
        event.GetAppDomainName.id = m_AppDomainId;

        // Note: two-way event here...
        hr = m_pProcess->m_cordb->SendIPCEvent(m_pProcess, &event,
                                               sizeof(DebuggerIPCEvent));

        // Stop now if we can't even send the event.
        if (!SUCCEEDED(hr))
            goto LExit;

        _ASSERTE(event.type == DB_IPCE_APP_DOMAIN_NAME_RESULT);

        hr = event.hr;

        // delete the old cached name
        if (m_szAppDomainName)
            delete [] m_szAppDomainName;

        // true length of the name, includes null
        iTrueLen = wcslen(event.AppDomainNameResult.rcName) + 1;

        m_szAppDomainName = new WCHAR[iTrueLen];
        
        if (m_szAppDomainName)
            wcscpy(m_szAppDomainName, event.AppDomainNameResult.rcName);
        else
        {
            hr = E_OUTOFMEMORY;
            goto LExit;
		}
		
        m_nameIsValid = true;
    }
    else
        iTrueLen = wcslen(m_szAppDomainName) + 1; // includes null
    
    // If they provided a buffer, fill it in
    if (szName)
    {
        // Figure out the safe string length to copy
        SIZE_T iCopyLen = min(cchName, iTrueLen);

        // Do a safe buffer copy including null if there is room.
        wcsncpy(szName, m_szAppDomainName, iCopyLen);

        // Force a null no matter what, and return the count if desired.
        szName[iCopyLen-1] = 0;
    }

    if (pcchName)
        *pcchName = iTrueLen;
        
LExit:    
	INPROC_UNLOCK();
	
    return hr;
}

/*
 * GetObject returns the runtime app domain object. 
 * Note:   This method is not yet implemented.
 */
HRESULT CordbAppDomain::GetObject(ICorDebugValue **ppObject)
{
    VALIDATE_POINTER_TO_OBJECT(ppObject,ICorDebugObjectValue **);

    return E_NOTIMPL;
}

/*
 * Get the ID of the app domain.
 */
HRESULT CordbAppDomain::GetID (ULONG32 *pId)
{
    VALIDATE_POINTER_TO_OBJECT(pId, ULONG32 *);

    *pId = m_AppDomainId;

    return S_OK;
}

//
// LookupModule finds an existing CordbModule given the address of the
// corresponding DebuggerModule object on the RC-side.
//
CordbModule* CordbAppDomain::LookupModule(REMOTE_PTR debuggerModuleToken)
{
    CordbModule *pModule;

    // first, check to see if the module is present in this app domain
    pModule = (CordbModule*) m_modules.GetBase((ULONG) debuggerModuleToken);

    if (pModule == NULL)
    {
        // it is possible that this module is loaded as part of some other 
        // app domain. This can happen, for eg., when a thread in the debuggee
        // moves to a different app domain. so check all other app domains.


        HASHFIND findappdomain;
        CordbBase *appdomainentry;
        

        for (appdomainentry =  m_pProcess->m_appDomains.FindFirst(&findappdomain);
             appdomainentry != NULL;
             appdomainentry =  m_pProcess->m_appDomains.FindNext(&findappdomain))
        {
            CordbAppDomain* ad = (CordbAppDomain*) appdomainentry;
            if (ad == this)
                continue;

            pModule = (CordbModule*) ad->m_modules.GetBase((ULONG) debuggerModuleToken);

            if (pModule)
                break;
        }
    }

    return pModule;
}


/* ------------------------------------------------------------------------- *
 * Assembly class
 * ------------------------------------------------------------------------- */
CordbAssembly::CordbAssembly(CordbAppDomain* pAppDomain, 
                    REMOTE_PTR debuggerAssemblyToken, 
                    const WCHAR *szName,
                    BOOL fIsSystemAssembly)

    : CordbBase((ULONG)debuggerAssemblyToken, enumCordbAssembly),
      m_pAppDomain(pAppDomain),
      m_fIsSystemAssembly(fIsSystemAssembly)
{
    // Make a copy of the name. 
    if (szName == NULL)
        szName = L"<Unknown>";

    if (szName != NULL)
    {
        m_szAssemblyName = new WCHAR[wcslen(szName) + 1];
        if (m_szAssemblyName)
            wcscpy(m_szAssemblyName, szName);
    }
}

/*
    A list of which resources owened by this object are accounted for.

    public:
        CordbAppDomain      *m_pAppDomain; // Assigned w/o addRef(), Deleted in ~CordbAssembly
*/

CordbAssembly::~CordbAssembly()
{
    delete [] m_szAssemblyName;
}

HRESULT CordbAssembly::QueryInterface(REFIID id, void **ppInterface)
{
    if (id == IID_ICorDebugAssembly)
        *ppInterface = (ICorDebugAssembly*)this;
    else if (id == IID_IUnknown)
        *ppInterface = (IUnknown*)(ICorDebugAssembly*)this;
    else
    {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

// Neutered by AppDomain
void CordbAssembly::Neuter()
{
    AddRef();
    {
        CordbBase::Neuter();
    }
    Release();
}

/*      
 * GetProcess returns the process containing the assembly
 */
HRESULT CordbAssembly::GetProcess(ICorDebugProcess **ppProcess)
{
    VALIDATE_POINTER_TO_OBJECT(ppProcess, ICorDebugProcess **);

    return (m_pAppDomain->GetProcess (ppProcess));
}

/*      
 * GetAppDomain returns the app domain containing the assembly.
 * Returns null if this is the system assembly
 */
HRESULT CordbAssembly::GetAppDomain(ICorDebugAppDomain **ppAppDomain)
{
    VALIDATE_POINTER_TO_OBJECT(ppAppDomain, ICorDebugAppDomain **);

    if (m_fIsSystemAssembly == TRUE)
    {
        *ppAppDomain = NULL;
    }
    else
    {
        _ASSERTE (m_pAppDomain != NULL);

        *ppAppDomain = (ICorDebugAppDomain *)m_pAppDomain;
        (*ppAppDomain)->AddRef();
    }
    return S_OK;
}

/*        
 * EnumerateModules enumerates all modules in the assembly
 */
HRESULT CordbAssembly::EnumerateModules(ICorDebugModuleEnum **ppModules)
{    
#ifndef RIGHT_SIDE_ONLY
    return CORDBG_E_INPROC_NOT_IMPL;
#else
    HRESULT hr = S_OK;
    CordbEnumFilter *pModEnum;

    VALIDATE_POINTER_TO_OBJECT(ppModules, ICorDebugModuleEnum **);

    CORDBRequireProcessSynchronized(m_pAppDomain->m_pProcess, GetAppDomain());

    CordbHashTableEnum *e = new CordbHashTableEnum(&m_pAppDomain->m_modules, 
                                                   IID_ICorDebugModuleEnum);
    if (e == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pModEnum = new CordbEnumFilter;
    if (pModEnum == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = pModEnum->Init (e, this);

    if (SUCCEEDED (hr))
    {
        *ppModules = (ICorDebugModuleEnum *) pModEnum;
        pModEnum->AddRef();
    }
    else
        delete pModEnum;

Error:
    if (e != NULL)
        delete e;

    return hr;
#endif
}


/*
 * GetCodeBase returns the code base used to load the assembly
 */
HRESULT CordbAssembly::GetCodeBase(ULONG32 cchName, 
                    ULONG32 *pcchName,
                    WCHAR szName[])
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(szName, WCHAR, cchName, true, true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pcchName, ULONG32 *);
    
    return E_NOTIMPL;
}

/*
 * GetName returns the name of the assembly
 */
HRESULT CordbAssembly::GetName(ULONG32 cchName, 
                               ULONG32 *pcchName,
                               WCHAR szName[])
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY_OR_NULL(szName, WCHAR, cchName, true, true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pcchName, ULONG32 *);

    const WCHAR *szTempName = m_szAssemblyName;

    // In case we didn't get the name (most likely out of memory on ctor).
	if (!szTempName)
    	szTempName = L"<unknown>";

    // True length of the name, including NULL
    SIZE_T iTrueLen = wcslen(szTempName) + 1;

    if (szName)
    {
        // Do a safe buffer copy including null if there is room.
        SIZE_T iCopyLen = min(cchName, iTrueLen);
        wcsncpy(szName, szTempName, iCopyLen);

        // Force a null no matter what, and return the count if desired.
        szName[iCopyLen - 1] = 0;
    }
    
    if (pcchName)
        *pcchName = iTrueLen;

    return S_OK;
}


//****************************************************************************
//************ App Domain Publishing Service API Implementation **************
//****************************************************************************

// This function enumerates all the process in the system and returns
// their PIDs
BOOL GetAllProcessesInSystem(DWORD *ProcessId,
                             DWORD dwArraySize,
                             DWORD *pdwNumEntries)
{
    {
        // Load the dll "kernel32.dll". 
        HINSTANCE  hDll = WszLoadLibrary(L"kernel32");
        _ASSERTE(hDll != NULL);

        if (hDll == NULL)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "Unable to load the dll for enumerating processes. "
                 "LoadLibrary (kernel32.dll) failed.\n"));
            return FALSE;
        }

        // Create the Process' Snapshot
        // Get the pointer to the requested function
        FARPROC pProcAddr = GetProcAddress(hDll, "CreateToolhelp32Snapshot");

        // If the proc address was not found, return error
        if (pProcAddr == NULL)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "Unable to enumerate processes in the system. "
                 "GetProcAddr (CreateToolhelp32Snapshot) failed.\n"));

            // Free the module, since the NT4 way requires a different DLL
            FreeLibrary(hDll);

            // This failure will result if we're running on WinNT4. Therefore,
            // try to EnumProcess the NT4 way by loading PSAPI.dll
            goto TryNT4;    
        }

        typedef HANDLE CREATETOOLHELP32SNAPSHOT(DWORD, DWORD);

        HANDLE hSnapshot = 
                ((CREATETOOLHELP32SNAPSHOT *)pProcAddr)(TH32CS_SNAPPROCESS, NULL);

        if ((int)hSnapshot == -1)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "Unable to create snapshot of processes in the system. "
                 "CreateToolhelp32Snapshot() failed.\n"));
            FreeLibrary(hDll);
            return FALSE;
        }

        // Get the first process in the process list
        // Get the pointer to the requested function
        pProcAddr = GetProcAddress(hDll, "Process32First");

        // If the proc address was not found, return error
        if (pProcAddr == NULL)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "Unable to enumerate processes in the system. "
                 "GetProcAddr (Process32First) failed.\n"));
            FreeLibrary(hDll);
            return FALSE;
        }

        PROCESSENTRY32  PE32;

        // need to initialize the dwSize field before calling Process32First
        PE32.dwSize = sizeof (PROCESSENTRY32);

        typedef BOOL PROCESS32FIRST(HANDLE, LPPROCESSENTRY32);

        BOOL succ = 
                ((PROCESS32FIRST *)pProcAddr)(hSnapshot, &PE32);

        if (succ != TRUE)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "Unable to create snapshot of processes in the system. "
                 "Process32First() returned FALSE.\n"));
            FreeLibrary(hDll);
            return FALSE;
        }


        // Loop over and get all the remaining processes
        // Get the pointer to the requested function
        pProcAddr = GetProcAddress(hDll, "Process32Next");

        // If the proc address was not found, return error
        if (pProcAddr == NULL)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "Unable to enumerate processes in the system. "
                 "GetProcAddr (Process32Next) failed.\n"));
            FreeLibrary(hDll);
            return FALSE;
        }

        typedef BOOL PROCESS32NEXT(HANDLE, LPPROCESSENTRY32);

        int iIndex = 0;

        do 
        {
            ProcessId [iIndex++] = PE32.th32ProcessID;          
            
            succ = ((PROCESS32NEXT *)pProcAddr)(hSnapshot, &PE32);

        } while ((succ == TRUE) && (iIndex < (int)dwArraySize));

        // I would like to know if we're running more than 512 processes on Win95!!
        _ASSERTE (iIndex < (int)dwArraySize);

        *pdwNumEntries = iIndex;

        FreeLibrary(hDll);
        return TRUE;    
    }

TryNT4: 
    {
        // Load the NT resource dll "PSAPI.dll". 
        HINSTANCE  hDll = WszLoadLibrary(L"PSAPI");
        _ASSERTE(hDll != NULL);

        if (hDll == NULL)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "Unable to load the dll for enumerating processes. "
                 "LoadLibrary (psapi.dll) failed.\n"));
            return FALSE;
        }

        // Get the pointer to the requested function
        FARPROC pProcAddr = GetProcAddress(hDll, "EnumProcesses");

        // If the proc address was not found, return error
        if (pProcAddr == NULL)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "Unable to enumerate processes in the system. "
                 "GetProcAddr (EnumProcesses) failed.\n"));
            FreeLibrary(hDll);
            return FALSE;
        }

        typedef BOOL ENUMPROCESSES(DWORD *, DWORD, DWORD *);

        BOOL succ = ((ENUMPROCESSES *)pProcAddr)(ProcessId, 
                                            dwArraySize,
                                            pdwNumEntries);

        FreeLibrary(hDll);

        if (succ != 0)
        {
            *pdwNumEntries /= sizeof (DWORD);
            return TRUE;
        }

        *pdwNumEntries = 0;
        return FALSE;
    }
}

// ******************************************
// CorpubPublish
// ******************************************

CorpubPublish::CorpubPublish()
    : CordbBase(0),
      m_pProcess(NULL),
      m_pHeadIPCReaderList(NULL)
{
}

CorpubPublish::~CorpubPublish()
{
    // Release all the IPC readers.
    while (m_pHeadIPCReaderList != NULL)
    {
        IPCReaderInterface *pIPCReader = (IPCReaderInterface *)
                                            m_pHeadIPCReaderList->GetData();
        pIPCReader->ClosePrivateBlock();
        delete pIPCReader;

        EnumElement *pTemp = m_pHeadIPCReaderList;
        m_pHeadIPCReaderList = m_pHeadIPCReaderList->GetNext();
        delete pTemp;
    }

    // Release all the processes.
    while (m_pProcess)
    {
        CorpubProcess *pTmp = m_pProcess;
        m_pProcess = m_pProcess->GetNextProcess();
        pTmp->Release();
    }
}

COM_METHOD CorpubPublish::QueryInterface(REFIID id, void **ppInterface)
{
    if (id == IID_ICorPublish)
        *ppInterface = (ICorPublish*)this;
    else if (id == IID_IUnknown)
        *ppInterface = (IUnknown*)(ICorPublish*)this;
    else
    {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;

}


COM_METHOD CorpubPublish::EnumProcesses(COR_PUB_ENUMPROCESS Type,
                                        ICorPublishProcessEnum **ppIEnum)
{
    return EnumProcessesInternal(Type, 
                                 ppIEnum,
                                 0,
                                 NULL,
                                 FALSE);
}


HRESULT CorpubPublish::GetProcess(unsigned pid, 
                                  ICorPublishProcess **ppProcess)
{
    return EnumProcessesInternal(COR_PUB_MANAGEDONLY, 
                                 NULL,
                                 pid,
                                 ppProcess,
                                 TRUE);
}


// This method enumerates all/given process in the system If the flag
// "fOnlyOneProcess" is TRUE, then only the process with the given PID
// is evaluated and returned in ICorPublishProcess.  Otherwise all
// managed processes are evaluated and returned via
// ICorPublishProcessEnum.
HRESULT CorpubPublish::EnumProcessesInternal(
                                    COR_PUB_ENUMPROCESS Type,
                                    ICorPublishProcessEnum **ppIEnum,
                                    unsigned pid, 
                                    ICorPublishProcess **ppProcess,
                                    BOOL fOnlyOneProcess)
{
    HRESULT hr = S_OK;

    if (fOnlyOneProcess == FALSE)
    {
        _ASSERTE(ppIEnum != NULL);
        *ppIEnum = NULL;
    }
    else
    {
        _ASSERTE(ppProcess != NULL);
        *ppProcess = NULL;
    }

    // call function to get PIDs for all processes in the system
#define MAX_PROCESSES  512

    DWORD ProcessId[MAX_PROCESSES];
    DWORD dwNumProcesses;

    IPCReaderInterface  *pIPCReader = NULL;
    EnumElement *pCurIPCReader = NULL;

    BOOL fAllIsWell = FALSE;
    
    if (fOnlyOneProcess == FALSE)
    {
        fAllIsWell = GetAllProcessesInSystem(ProcessId,
                                             MAX_PROCESSES,
                                             &dwNumProcesses);
    }
    else
    {
        // first, check to see if a ICorPublishProcess object with the
        // requested process id already exists. This could happen if
        // the user calls EnumerateProcesses() before calling
        // GetProcess()
        CorpubProcess *pProcess = m_pProcess;
        
        while (pProcess != NULL)
        {
            if (pProcess->m_dwProcessId == pid)
            {
                return pProcess->QueryInterface(IID_ICorPublishProcess, 
                                                (void **) ppProcess);
            }

            pProcess = pProcess->GetNextProcess();
        }

        // Didn't find a match, so just pretend we have an array of
        // this one process.
        dwNumProcesses = 1;
        ProcessId[0] = pid;
        fAllIsWell = TRUE;
    }

    if (fAllIsWell)
    {
        CorpubProcess *pCurrent = NULL;

        DWORD pidSelf = GetCurrentProcessId();

        // iterate over all the processes to fetch all the managed processes 
        for (int i = 0; i < (int)dwNumProcesses; i++)
        {
            if (pIPCReader == NULL)
            {
                pIPCReader = new IPCReaderInterface;

                if (pIPCReader == NULL)
                {
                    LOG((LF_CORDB, LL_INFO100, "CP::EP: Failed to allocate memory for IPCReaderInterface.\n"));
                    hr = E_OUTOFMEMORY;

                    goto exit;
                }
            }
        
            // See if it is a managed process by trying to open the shared
            // memory block.
            hr = pIPCReader->OpenPrivateBlockOnPid(ProcessId[i]);

            if (FAILED(hr))
                continue;

            // Get the AppDomainIPCBlock
            AppDomainEnumerationIPCBlock *pAppDomainCB = pIPCReader->GetAppDomainBlock();

            _ASSERTE (pAppDomainCB != NULL);

            if (pAppDomainCB == NULL)
            {
                LOG((LF_CORDB, LL_INFO1000, "CP::EP: Failed to obtain AppDomainIPCBlock.\n"));

                pIPCReader->ClosePrivateBlock();

                hr = S_FALSE;
                continue;
            }

            // Get the process handle
            HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId[i]);

            _ASSERTE (hProcess != NULL);

            if (hProcess == NULL)
            {
                LOG((LF_CORDB, LL_INFO1000, "CP::EP: OpenProcess() returned NULL handle.\n"));

                pIPCReader->ClosePrivateBlock();

                hr = S_FALSE;
                continue;
            }

            // We need to wait for the data block to get filled in
            // properly. But we won't wait forever... two seconds here...
            HANDLE hMutex;

            for (int w = 0; (w < 100) && (pAppDomainCB->m_hMutex == NULL); w++)
                Sleep(20);

            // If the mutex was never filled in, then we most probably
            // lost a shutdown race.
            if (pAppDomainCB->m_hMutex == NULL)
            {
                LOG((LF_CORDB, LL_INFO1000, "CP::EP: IPC block was never properly filled in.\n"));

                pIPCReader->ClosePrivateBlock();

                hr = S_FALSE;
                continue;
            }
            
            // Dup the valid mutex handle into this process.
            BOOL succ = DuplicateHandle(hProcess,
                                        pAppDomainCB->m_hMutex,
                                        GetCurrentProcess(),
                                        &hMutex,
                                        NULL, FALSE, DUPLICATE_SAME_ACCESS);

            if (succ)
            {
                // Acquire the mutex. Again, only wait two seconds.
                DWORD dwRetVal = WaitForSingleObject(hMutex, 2000);

                if (dwRetVal == WAIT_OBJECT_0)
                {
                    // Make sure the mutex handle is still valid. If
                    // its not, then we lost a shutdown race.
                    if (pAppDomainCB->m_hMutex == NULL)
                    {
                        LOG((LF_CORDB, LL_INFO1000, "CP::EP: lost shutdown race, skipping...\n"));

                        ReleaseMutex(hMutex);
                        CloseHandle(hMutex);
                        succ = FALSE;
                    }
                }
                else
                {
                    // Again, landing here is most probably a shutdown race. Its okay, though...
                    LOG((LF_CORDB, LL_INFO1000, "CP::EP: failed to get IPC mutex.\n"));

                    if (dwRetVal == WAIT_ABANDONED)
                    {
                        ReleaseMutex(hMutex);
                    }
                    CloseHandle(hMutex);
                    succ = FALSE;
                }
            }

            if (!succ)
            {
                pIPCReader->ClosePrivateBlock();

                hr = S_FALSE;
                continue;
            }

            // If we get here, then hMutex is held by this process.

            // Now create the CorpubProcess object for the ProcessID
            pCurrent = new CorpubProcess(ProcessId[i],
                                         true,
                                         hProcess,
                                         hMutex,
                                         pAppDomainCB);

            // Release our lock on the IPC block.
            ReleaseMutex(hMutex);
            
            _ASSERTE (pCurrent != NULL);

            if (pCurrent == NULL)
            {
                hr = E_OUTOFMEMORY;                 
                goto exit;
            }

            // Keep a reference to each process.
            pCurrent->AddRef();

            // Save the IPCReaderInterface pointer
            pCurIPCReader = new EnumElement;
            
            if (pCurIPCReader == NULL)
            {
                hr = E_OUTOFMEMORY;                 
                goto exit;                  
            }

            pCurIPCReader->SetData((void *)pIPCReader);
            pIPCReader = NULL;

            pCurIPCReader->SetNext(m_pHeadIPCReaderList);
            m_pHeadIPCReaderList = pCurIPCReader;

            // Add the process to the list.
            pCurrent->SetNext(m_pProcess);
            m_pProcess = pCurrent;
        }

        if (fOnlyOneProcess == TRUE)
        {
            // If it's NULL here, then we weren't able to attach (target's dead?)
            if(pCurrent == NULL)
            {
                hr = E_FAIL;
                goto exit;
            }
            
            hr = pCurrent->QueryInterface(IID_ICorPublishProcess, 
                                          (void**)ppProcess);
        }
        else
        {
            // create and return the ICorPublishProcessEnum object
            CorpubProcessEnum *pTemp = new CorpubProcessEnum(m_pProcess);

            if (pTemp == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            hr = pTemp->QueryInterface(IID_ICorPublishProcessEnum, 
                                       (void**)ppIEnum);
        }
    }
    else
    {
        hr = E_FAIL;
        goto exit;
    }

exit:
    if (FAILED(hr))
    {
        if (fOnlyOneProcess)
            *ppProcess = NULL;
        else
            *ppIEnum = NULL;
    }

    return hr;
}



// ******************************************
// CorpubProcess
// ******************************************

// Constructor
CorpubProcess::CorpubProcess(DWORD dwProcessId,
                             bool fManaged,
                             HANDLE hProcess, 
                             HANDLE hMutex,
                             AppDomainEnumerationIPCBlock *pAD)
    : CordbBase(0, enumCorpubProcess),
      m_dwProcessId(dwProcessId),
      m_fIsManaged(fManaged),
      m_hProcess(hProcess),
      m_hMutex(hMutex),
      m_AppDomainCB(pAD),
      m_pNext(NULL),
      m_pAppDomain(NULL)
{
    // also fetch the process name from the AppDomainIPCBlock
    _ASSERTE (pAD->m_szProcessName != NULL);

    if (pAD->m_szProcessName == NULL)
        m_szProcessName = NULL;
    else
    {
        DWORD dwNumBytesRead;

        _ASSERTE(pAD->m_iProcessNameLengthInBytes > 0);

        // Note: this assumes we're reading the null terminator from
        // the IPC block.
        m_szProcessName = (WCHAR*) new char[pAD->m_iProcessNameLengthInBytes];
        
        if (m_szProcessName == NULL)
        {
            LOG((LF_CORDB, LL_INFO1000,
             "CP::CP: Failed to allocate memory for ProcessName.\n"));

            goto exit;          
        }

        BOOL bSucc = ReadProcessMemoryI(hProcess,
                                        pAD->m_szProcessName,
                                        m_szProcessName,
                                        pAD->m_iProcessNameLengthInBytes,
                                        &dwNumBytesRead);

        _ASSERTE (bSucc != 0);

        if ((bSucc == 0) ||
            (dwNumBytesRead < (DWORD)pAD->m_iProcessNameLengthInBytes))
        {
            LOG((LF_CORDB, LL_INFO1000,
             "CP::EAD: ReadProcessMemoryI (ProcessName) failed.\n"));
        }       
    }

exit:
    ;
}

CorpubProcess::~CorpubProcess()
{
    delete [] m_szProcessName;
    CloseHandle(m_hProcess);
    CloseHandle(m_hMutex);

    // Delete all the app domains in this process
    while (m_pAppDomain)
    {
        CorpubAppDomain *pTemp = m_pAppDomain;
        m_pAppDomain = m_pAppDomain->GetNextAppDomain();
        pTemp->Release();
    }
}



HRESULT CorpubProcess::QueryInterface(REFIID id, void **ppInterface)
{
    if (id == IID_ICorPublishProcess)
        *ppInterface = (ICorPublishProcess*)this;
    else if (id == IID_IUnknown)
        *ppInterface = (IUnknown*)(ICorPublishProcess*)this;
    else
    {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


HRESULT CorpubProcess::IsManaged(BOOL *pbManaged)
{
    *pbManaged = (m_fIsManaged == true) ? TRUE : FALSE;

    return S_OK;
}

//
// Enumerate the list of known application domains in the target process.
//
HRESULT CorpubProcess::EnumAppDomains(ICorPublishAppDomainEnum **ppIEnum)
{

    int i;
    CorpubAppDomain *pCurrent = NULL;

    HRESULT hr = S_OK;

    // Lock the IPC block:
    WaitForSingleObject(m_hMutex, INFINITE);

    int iAppDomainCount = 0;

    _ASSERTE(m_AppDomainCB->m_rgListOfAppDomains != NULL);
    _ASSERTE(m_AppDomainCB->m_iSizeInBytes > 0);

    // Allocate memory to read the remote process' memory into
    AppDomainInfo *pADI = (AppDomainInfo *) 
                                    new char[m_AppDomainCB->m_iSizeInBytes];

    _ASSERTE (pADI != NULL);

    if (pADI == NULL)
    {
        LOG((LF_CORDB, LL_INFO1000,
         "CP::EAD: Failed to allocate memory for AppDomainInfo.\n"));

        hr = E_OUTOFMEMORY;

        goto exit;
    }

    DWORD   dwNumBytesRead;

    // Need to read in the remote process' memory
    if (m_AppDomainCB->m_rgListOfAppDomains != NULL)
    {

        BOOL bSucc = ReadProcessMemoryI(m_hProcess,
                                        m_AppDomainCB->m_rgListOfAppDomains,
                                        pADI,
                                        m_AppDomainCB->m_iSizeInBytes,
                                        &dwNumBytesRead);
        _ASSERTE (bSucc != 0);

        if ((bSucc == 0) ||
            ((int)dwNumBytesRead < m_AppDomainCB->m_iSizeInBytes))
        {
            LOG((LF_CORDB, LL_INFO1000,
             "CP::EAD: ReadProcessMemoryI (AppDomainInfo) failed.\n"));

            hr = E_OUTOFMEMORY;

            goto exit;
        }
    }

    for (i = 0; i < m_AppDomainCB->m_iTotalSlots; i++)
    {
        if (!pADI[i].IsEmpty())
        {

            _ASSERTE(pADI[i].m_iNameLengthInBytes > 0);

            WCHAR *pAppDomainName =
                (WCHAR *) new char[pADI[i].m_iNameLengthInBytes];
            
            if (pAppDomainName == NULL)
            {
                LOG((LF_CORDB, LL_INFO1000,
                 "CP::EAD: Failed to allocate memory for AppDomainName.\n"));

                hr = E_OUTOFMEMORY;
                goto exit;
            }

            BOOL bSucc = ReadProcessMemoryI(m_hProcess,
                                            pADI[i].m_szAppDomainName,
                                            pAppDomainName,
                                            pADI[i].m_iNameLengthInBytes,
                                            &dwNumBytesRead);
            _ASSERTE (bSucc != 0);

            if ((bSucc == 0) ||
                (dwNumBytesRead < (DWORD)pADI[i].m_iNameLengthInBytes))
            {
                LOG((LF_CORDB, LL_INFO1000,
                 "CP::EAD: ReadProcessMemoryI (AppDomainName) failed.\n"));

                hr = E_FAIL;
                goto exit;
            }

            // create a new AppDomainObject
            CorpubAppDomain *pCurrent = new CorpubAppDomain(pAppDomainName, 
                                                            pADI[i].m_id);
            
            if (pCurrent == NULL)
            {
                LOG((LF_CORDB, LL_INFO1000,
                 "CP::EAD: Failed to allocate memory for CorpubAppDomain.\n"));

                hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Keep a reference to each app domain.
            pCurrent->AddRef();

            // Add the appdomain to the list.
            pCurrent->SetNext(m_pAppDomain);
            m_pAppDomain = pCurrent;

            if (++iAppDomainCount >= m_AppDomainCB->m_iNumOfUsedSlots)
                break;
        }
    }

    {
        _ASSERTE ((iAppDomainCount >= m_AppDomainCB->m_iNumOfUsedSlots)
                  && (i <= m_AppDomainCB->m_iTotalSlots));

        // create and return the ICorPublishAppDomainEnum object
        CorpubAppDomainEnum *pTemp = new CorpubAppDomainEnum(m_pAppDomain);

        if (pTemp == NULL)
        {
            hr = E_OUTOFMEMORY;
            *ppIEnum = NULL;
            goto exit;
        }

        hr = pTemp->QueryInterface(IID_ICorPublishAppDomainEnum,
                                   (void **)ppIEnum);
    }

exit:
    ReleaseMutex(m_hMutex);

    return hr;
}

/*
 * Returns the OS ID for the process in question.
 */
HRESULT CorpubProcess::GetProcessID(unsigned *pid)
{
    *pid = m_dwProcessId;

    return S_OK;
}

/*
 * Get the display name for a process.
 */
HRESULT CorpubProcess::GetDisplayName(ULONG32 cchName, 
                                      ULONG32 *pcchName,
                                      WCHAR szName[])
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY_OR_NULL(szName, WCHAR, cchName, true, true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pcchName, ULONG32 *);

    // Reasonable defaults
    if (szName)
        *szName = 0;

    if (pcchName)
        *pcchName = 0;
    
    SIZE_T      iCopyLen, iTrueLen;
    const WCHAR *szTempName = m_szProcessName;

    // In case we didn't get the name (most likely out of memory on ctor).
    if (!szTempName)
        szTempName = L"<unknown>";

    iTrueLen = wcslen(szTempName) + 1;  // includes null

    if (szName)
    {
        // Do a safe buffer copy including null if there is room.
        iCopyLen = min(cchName, iTrueLen);
        wcsncpy(szName, szTempName, iCopyLen);

        // Force a null no matter what, and return the count if desired.
        szName[iCopyLen - 1] = 0;
    }
    
    if (pcchName)
        *pcchName = iTrueLen;

    return S_OK;
}


// ******************************************
// CorpubAppDomain
// ******************************************

CorpubAppDomain::CorpubAppDomain (WCHAR *szAppDomainName, ULONG Id)
    : CordbBase (0, enumCorpubAppDomain),
    m_szAppDomainName (szAppDomainName),
    m_id (Id),
    m_pNext (NULL)
{
}

CorpubAppDomain::~CorpubAppDomain()
{
    delete [] m_szAppDomainName;
}

HRESULT CorpubAppDomain::QueryInterface (REFIID id, void **ppInterface)
{
    if (id == IID_ICorPublishAppDomain)
        *ppInterface = (ICorPublishAppDomain*)this;
    else if (id == IID_IUnknown)
        *ppInterface = (IUnknown*)(ICorPublishAppDomain*)this;
    else
    {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


/*
 * Get the name and ID for an application domain.
 */
HRESULT CorpubAppDomain::GetID (ULONG32 *pId)
{
    VALIDATE_POINTER_TO_OBJECT(pId, ULONG32 *);

    *pId = m_id;

    return S_OK;
}

/*
 * Get the name for an application domain.
 */
HRESULT CorpubAppDomain::GetName(ULONG32 cchName, 
                                ULONG32 *pcchName, 
                                WCHAR szName[])
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY_OR_NULL(szName, WCHAR, cchName, true, true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pcchName, ULONG32 *);
    
    const WCHAR *szTempName = m_szAppDomainName;

    // In case we didn't get the name (most likely out of memory on ctor).
    if (!szTempName)
        szTempName = L"<unknown>";

    SIZE_T iTrueLen = wcslen(szTempName) + 1;  // includes null

    if (szName)
    {
        // Do a safe buffer copy including null if there is room.
        SIZE_T iCopyLen = min(cchName, iTrueLen);
        wcsncpy(szName, szTempName, iCopyLen);

        // Force a null no matter what, and return the count if desired.
        szName[iCopyLen - 1] = 0;
    }
    
    if (pcchName)
        *pcchName = iTrueLen;

    return S_OK;
}



// ******************************************
// CorpubProcessEnum
// ******************************************

CorpubProcessEnum::CorpubProcessEnum (CorpubProcess *pFirst)
    : CordbBase (0, enumCorpubProcessEnum),
    m_pFirst (pFirst),
    m_pCurrent (pFirst)
{   
}


HRESULT CorpubProcessEnum::QueryInterface (REFIID id, void **ppInterface)
{
    if (id == IID_ICorPublishProcessEnum)
        *ppInterface = (ICorPublishProcessEnum*)this;
    else if (id == IID_IUnknown)
        *ppInterface = (IUnknown*)(ICorPublishProcessEnum*)this;
    else
    {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


HRESULT CorpubProcessEnum::Skip(ULONG celt)
{
	INPROC_LOCK();
	
	while ((m_pCurrent != NULL) && (celt-- > 0))
    {
        m_pCurrent = m_pCurrent->GetNextProcess();
    }

	INPROC_UNLOCK();
    return S_OK;
}

HRESULT CorpubProcessEnum::Reset()
{
    m_pCurrent = m_pFirst;

    return S_OK;
}

HRESULT CorpubProcessEnum::Clone(ICorPublishEnum **ppEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppEnum, ICorPublishEnum **);
    INPROC_LOCK();

    INPROC_UNLOCK();
    return E_NOTIMPL;
}

HRESULT CorpubProcessEnum::GetCount(ULONG *pcelt)
{
    VALIDATE_POINTER_TO_OBJECT(pcelt, ULONG *);

	INPROC_LOCK();
    
    CorpubProcess *pTemp = m_pFirst;

    *pcelt = 0;

    while (pTemp != NULL) 
    {
        (*pcelt)++;
        pTemp = pTemp->GetNextProcess();
    }

	INPROC_UNLOCK();

    return S_OK;
}

HRESULT CorpubProcessEnum::Next(ULONG celt,
                ICorPublishProcess *objects[],
                ULONG *pceltFetched)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(objects, ICorPublishProcess *, 
        celt, true, true);
    VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

	INPROC_LOCK();
    
    HRESULT hr = S_OK;

    *pceltFetched = 0;

    while ((m_pCurrent != NULL) && (*pceltFetched < celt))
    {
        hr = m_pCurrent->QueryInterface (IID_ICorPublishProcess,
                                        (void**)&objects [*pceltFetched]);

        if (hr != S_OK)
            break;

        (*pceltFetched)++;
        m_pCurrent = m_pCurrent->GetNextProcess();
    }

	INPROC_UNLOCK();

    return hr;
}

// ******************************************
// CorpubAppDomainEnum
// ******************************************
CorpubAppDomainEnum::CorpubAppDomainEnum (CorpubAppDomain *pFirst)
    : CordbBase (0, enumCorpubAppDomainEnum),
    m_pFirst (pFirst),
    m_pCurrent (pFirst)
{   
}


HRESULT CorpubAppDomainEnum::QueryInterface (REFIID id, void **ppInterface)
{
    if (id == IID_ICorPublishAppDomainEnum)
        *ppInterface = (ICorPublishAppDomainEnum*)this;
    else if (id == IID_IUnknown)
        *ppInterface = (IUnknown*)(ICorPublishAppDomainEnum*)this;
    else
    {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


HRESULT CorpubAppDomainEnum::Skip(ULONG celt)
{
	INPROC_LOCK();

	while ((m_pCurrent != NULL) && (celt-- > 0))
    {
        m_pCurrent = m_pCurrent->GetNextAppDomain();
    }

	INPROC_UNLOCK();

    return S_OK;
}

HRESULT CorpubAppDomainEnum::Reset()
{
	m_pCurrent = m_pFirst;

    return S_OK;
}

HRESULT CorpubAppDomainEnum::Clone(ICorPublishEnum **ppEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppEnum, ICorPublishEnum **);
	INPROC_LOCK();

	INPROC_UNLOCK();
    return E_NOTIMPL;
}

HRESULT CorpubAppDomainEnum::GetCount(ULONG *pcelt)
{
    VALIDATE_POINTER_TO_OBJECT(pcelt, ULONG *);

	INPROC_LOCK();
    
    CorpubAppDomain *pTemp = m_pFirst;

    *pcelt = 0;

    while (pTemp != NULL) 
    {
        (*pcelt)++;
        pTemp = pTemp->GetNextAppDomain();
    }

	INPROC_UNLOCK();

    return S_OK;
}

HRESULT CorpubAppDomainEnum::Next(ULONG celt,
                ICorPublishAppDomain *objects[],
                ULONG *pceltFetched)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(objects, ICorPublishProcess *, 
        celt, true, true);
    VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);
    
    HRESULT hr = S_OK;

    *pceltFetched = 0;

    while ((m_pCurrent != NULL) && (*pceltFetched < celt))
    {
        hr = m_pCurrent->QueryInterface (IID_ICorPublishAppDomain,
                                        (void **)&objects [*pceltFetched]);

        if (hr != S_OK)
            break;

        (*pceltFetched)++;
        m_pCurrent = m_pCurrent->GetNextAppDomain();
    }

    return hr;
}



//***********************************************************************
//              ICorDebugTMEnum (Thread and Module enumerator)
//***********************************************************************
CordbEnumFilter::CordbEnumFilter()
    : CordbBase (0),
    m_pFirst (NULL),
    m_pCurrent (NULL),
    m_iCount (0)
{
}

CordbEnumFilter::CordbEnumFilter(CordbEnumFilter *src) 
    : CordbBase (0),
    m_pFirst (NULL),
    m_pCurrent (NULL)
{
    int iCountSanityCheck = 0;
    EnumElement *pElementCur = NULL;
    EnumElement *pElementNew = NULL;
    EnumElement *pElementNewPrev = NULL;
    
    m_iCount = src->m_iCount;

    pElementCur = src->m_pFirst;

    while (pElementCur != NULL)
    {
        pElementNew = new EnumElement;
        if (pElementNew == NULL)
        {
            // Out of memory. Clean up and bail out.
            goto Error;
        }

        if (pElementNewPrev == NULL)
        {
            m_pFirst = pElementNew;
        }
        else
        {
            pElementNewPrev->SetNext(pElementNew);
        }

        pElementNewPrev = pElementNew;

        // Copy the element, including the AddRef part
        pElementNew->SetData(pElementCur->GetData());
        IUnknown *iu = (IUnknown *)pElementCur->GetData();
        iu->AddRef();

        if (pElementCur == src->m_pCurrent)
            m_pCurrent = pElementNew;
        
        pElementCur = pElementCur->GetNext();
        iCountSanityCheck++;
    }

    _ASSERTE(iCountSanityCheck == m_iCount);

    return;
Error:
    // release all the allocated memory before returning
    pElementCur = m_pFirst;

    while (pElementCur != NULL)
    {
        pElementNewPrev = pElementCur;
        pElementCur = pElementCur->GetNext();

        ((ICorDebugModule *)pElementNewPrev->GetData())->Release();
        delete pElementNewPrev;
    }
}

CordbEnumFilter::~CordbEnumFilter()
{
    EnumElement *pElement = m_pFirst;
    EnumElement *pPrevious = NULL;

    while (pElement != NULL)
    {
        pPrevious = pElement;
        pElement = pElement->GetNext();
        delete pPrevious;
    }
}



HRESULT CordbEnumFilter::QueryInterface(REFIID id, void **ppInterface)
{
    if (id == IID_ICorDebugModuleEnum)
        *ppInterface = (ICorDebugModuleEnum*)this;
    else if (id == IID_ICorDebugThreadEnum)
        *ppInterface = (ICorDebugThreadEnum*)this;
    else if (id == IID_IUnknown)
        *ppInterface = this;
    else
    {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbEnumFilter::Skip(ULONG celt)
{
	INPROC_LOCK();

	while (celt-- > 0 && m_pCurrent != NULL)
        m_pCurrent = m_pCurrent->GetNext();

	INPROC_UNLOCK();

    return S_OK;
}

HRESULT CordbEnumFilter::Reset()
{
	m_pCurrent = m_pFirst;
	
    return S_OK;
}

HRESULT CordbEnumFilter::Clone(ICorDebugEnum **ppEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppEnum, ICorDebugEnum **);

	INPROC_LOCK();
    
    CordbEnumFilter *clone = new CordbEnumFilter(this);

	INPROC_UNLOCK();

    if (NULL == clone)
        return E_OUTOFMEMORY;

    clone->AddRef();

    (*ppEnum) = (ICorDebugThreadEnum *)clone;
    
    return S_OK;
}

HRESULT CordbEnumFilter::GetCount(ULONG *pcelt)
{
    VALIDATE_POINTER_TO_OBJECT(pcelt, ULONG *);
    
    *pcelt = (ULONG)m_iCount;
    return S_OK;
}

HRESULT CordbEnumFilter::Next(ULONG celt,
                ICorDebugModule *objects[],
                ULONG *pceltFetched)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(objects, ICorDebugModule *, 
        celt, true, true);
    VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

	INPROC_LOCK();

    *pceltFetched = 0;
    while (celt-- > 0 && m_pCurrent != NULL)
    {
        objects [(*pceltFetched)++] = (ICorDebugModule *)m_pCurrent->GetData();
        m_pCurrent = m_pCurrent->GetNext();
    }

	INPROC_UNLOCK();

    return S_OK;
}


HRESULT CordbEnumFilter::Next(ULONG celt,
                ICorDebugThread *objects[],
                ULONG *pceltFetched)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(objects, ICorDebugThread *, 
        celt, true, true);
    VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

	INPROC_LOCK();

    *pceltFetched = 0;
    while (celt-- > 0 && m_pCurrent != NULL)
    {
        objects [(*pceltFetched)++] = (ICorDebugThread *)m_pCurrent->GetData();
        m_pCurrent = m_pCurrent->GetNext();
    }

	INPROC_UNLOCK();

    return S_OK;
}


HRESULT CordbEnumFilter::Init (ICorDebugModuleEnum *pModEnum, CordbAssembly *pAssembly)
{
    ICorDebugModule *pCorModule = NULL;
    CordbModule *pModule = NULL;
    ULONG ulDummy = 0;
    
    HRESULT hr = pModEnum->Next(1, &pCorModule, &ulDummy);
    if (FAILED (hr))
        return hr;

    EnumElement *pPrevious = NULL;
    EnumElement *pElement = NULL;

    while (ulDummy != 0)
    {   
        pModule = (CordbModule *)(ICorDebugModule *)pCorModule;
        // Is this module part of the assembly for which we're enumerating?
        if (pModule->m_pAssembly == pAssembly)
        {
            pElement = new EnumElement;
            if (pElement == NULL)
            {
                // Out of memory. Clean up and bail out.
                hr = E_OUTOFMEMORY;
                goto Error;
            }

            pElement->SetData ((void *)pCorModule);
            m_iCount++;

            if (m_pFirst == NULL)
            {
                m_pFirst = pElement;
            }
            else
            {
                _ASSERTE(pPrevious != NULL);
                pPrevious->SetNext (pElement);
            }
            pPrevious = pElement;
        }
        else
            ((ICorDebugModule *)pModule)->Release();

        hr = pModEnum->Next(1, &pCorModule, &ulDummy);
        if (FAILED (hr))
            goto Error;
    }

    m_pCurrent = m_pFirst;

    return S_OK;

Error:
    // release all the allocated memory before returning
    pElement = m_pFirst;

    while (pElement != NULL)
    {
        pPrevious = pElement;
        pElement = pElement->GetNext();

        ((ICorDebugModule *)pPrevious->GetData())->Release();
        delete pPrevious;
    }

    return hr;
}

HRESULT CordbEnumFilter::Init (ICorDebugThreadEnum *pThreadEnum, CordbAppDomain *pAppDomain)
{
    ICorDebugThread *pCorThread = NULL;
    CordbThread *pThread = NULL;
    ULONG ulDummy = 0;
    
    HRESULT hr = pThreadEnum->Next(1, &pCorThread, &ulDummy);
    if (FAILED (hr))
        return hr;

    EnumElement *pPrevious = NULL;
    EnumElement *pElement = NULL;

    while (ulDummy > 0)
    {   
        pThread = (CordbThread *)(ICorDebugThread *) pCorThread;

        // Is this module part of the appdomain for which we're enumerating?
        if (pThread->m_pAppDomain == pAppDomain)
        {
            pElement = new EnumElement;
            if (pElement == NULL)
            {
                // Out of memory. Clean up and bail out.
                hr = E_OUTOFMEMORY;
                goto Error;
            }

            pElement->SetData ((void *)pCorThread);
            m_iCount++;

            if (m_pFirst == NULL)
            {
                m_pFirst = pElement;
            }
            else
            {
                _ASSERTE(pPrevious != NULL);
                pPrevious->SetNext (pElement);
            }

            pPrevious = pElement;
        }
        else
            ((ICorDebugThread *)pThread)->Release();

        //  get the next thread in the thread list
        hr = pThreadEnum->Next(1, &pCorThread, &ulDummy);
        if (FAILED (hr))
            goto Error;
    }

    m_pCurrent = m_pFirst;

    return S_OK;

Error:
    // release all the allocated memory before returning
    pElement = m_pFirst;

    while (pElement != NULL)
    {
        pPrevious = pElement;
        pElement = pElement->GetNext();

        ((ICorDebugThread *)pPrevious->GetData())->Release();
        delete pPrevious;
    }

    return hr;
}

/***** CordbEnCErrorInfo *****/

CordbEnCErrorInfo::CordbEnCErrorInfo()
                                : CordbBase(0, enumCordbEnCErrorInfo)
{
    m_pModule = NULL;
    m_token = mdTokenNil;
    m_hr = S_OK;
    m_szError = NULL;
}

HRESULT CordbEnCErrorInfo::Init(CordbModule *pModule,
                                mdToken token,
                                HRESULT hr,
                                WCHAR *sz)
{
    m_pModule = pModule;
    m_token = token;
    m_hr = hr;
    
    ULONG szLen = wcslen(sz)+1;
    m_szError = new WCHAR[szLen];
    if (m_szError == NULL)
    {
        return E_OUTOFMEMORY;
    }

    wcscpy(m_szError, sz);
    AddRef();
    return S_OK;
}

CordbEnCErrorInfo::~CordbEnCErrorInfo()
{
    if (m_szError != NULL)
    {
        delete m_szError;
        m_szError = NULL;
    }
}

HRESULT CordbEnCErrorInfo::QueryInterface(REFIID riid, void **ppInterface)
{
#ifdef EDIT_AND_CONTINUE_FEATURE
    if (riid == IID_ICorDebugEditAndContinueErrorInfo)
        *ppInterface = (ICorDebugEditAndContinueErrorInfo*)this;
    else 
#endif    
    if (riid == IID_IErrorInfo)
        *ppInterface = (IErrorInfo*)this;
    else if (riid == IID_IUnknown)
        *ppInterface = this;
    else
    {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbEnCErrorInfo::GetDescription(BSTR  *pBstrDescription)
{ 
    return E_NOTIMPL;
}

HRESULT CordbEnCErrorInfo::GetGUID(GUID  *pGUID)
{ 
    return E_NOTIMPL;
}

HRESULT CordbEnCErrorInfo::GetHelpContext(DWORD  *pdwHelpContext)
{ 
    return E_NOTIMPL;
}

HRESULT CordbEnCErrorInfo::GetHelpFile(BSTR  *pBstrHelpFile)
{ 
    return E_NOTIMPL;
}

HRESULT CordbEnCErrorInfo::GetSource(BSTR  *pBstrSource)
{ 
    return E_NOTIMPL;
}

HRESULT CordbEnCErrorInfo::GetModule(ICorDebugModule **ppModule)
{
    VALIDATE_POINTER_TO_OBJECT(ppModule, ICorDebugModule **);

    (*ppModule) = (ICorDebugModule *)m_pModule;

    return S_OK;
}

HRESULT CordbEnCErrorInfo::GetToken(mdToken *pToken)
{
    VALIDATE_POINTER_TO_OBJECT(pToken, mdToken *);

    (*pToken) = m_token;

    return S_OK;
}

HRESULT CordbEnCErrorInfo::GetErrorCode(HRESULT *pHr)
{
    VALIDATE_POINTER_TO_OBJECT(pHr, HRESULT *);

    (*pHr) = m_hr;

    return S_OK;
}

HRESULT CordbEnCErrorInfo::GetString(ULONG32 cchString, 
					  	 ULONG32 *pcchString,
					     WCHAR szString[])
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY_OR_NULL(szString, WCHAR, 
        cchString, false, true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pcchString, ULONG32 *);
    
    if (!m_szError)
    {
        return E_OUTOFMEMORY;
    }

    ULONG32 len = min(cchString, wcslen(m_szError)+1);

    if (pcchString != NULL)
        (*pcchString) = len;

    if (szString != NULL)
    {
        wcsncpy(szString, m_szError, len);
        szString[len] = NULL; //
    }

    return S_OK;
}
					     
					     
/***** CordbEnCErrorInfoEnum *****/

CordbEnCErrorInfoEnum::CordbEnCErrorInfoEnum() :CordbBase(0, enumCordbEnCErrorInfoEnum)
{
    m_errors    = NULL;
    m_iCur      = 0;
    m_iCount    = 0;
}

CordbEnCErrorInfoEnum::~CordbEnCErrorInfoEnum()
{
    m_errors->Release();
}

HRESULT CordbEnCErrorInfoEnum::QueryInterface(REFIID riid, void **ppInterface)
{
    if (riid == IID_ICorDebugErrorInfoEnum)
        *ppInterface = (ICorDebugErrorInfoEnum*)this;
    else if (riid == IID_IUnknown)
        *ppInterface = this;
    else
    {
        *ppInterface = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CordbEnCErrorInfoEnum::Skip(ULONG celt)
{
    m_iCur = min(m_iCount, m_iCur+(USHORT)celt);
    return S_OK;
}

HRESULT CordbEnCErrorInfoEnum::Reset()
{
    m_iCur = 0;
    return S_OK;
}

HRESULT CordbEnCErrorInfoEnum::Clone(ICorDebugEnum **ppEnum)
{
    VALIDATE_POINTER_TO_OBJECT(ppEnum, ICorDebugEnum**);
    (*ppEnum) = NULL;

    CordbEnCErrorInfoEnum *pClone = new CordbEnCErrorInfoEnum();
    if (pClone == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pClone->Init(m_errors);

    (*ppEnum) = pClone;

    return S_OK;
}

HRESULT CordbEnCErrorInfoEnum::GetCount(ULONG *pcelt)
{
    VALIDATE_POINTER_TO_OBJECT(pcelt, ULONG*);
    
    (*pcelt) = (ULONG)m_iCount;
    return S_OK;
}

HRESULT CordbEnCErrorInfoEnum::Next(ULONG celt,
                                    ICorDebugEditAndContinueErrorInfo *objects[],
                ULONG *pceltFetched)
{
    VALIDATE_POINTER_TO_OBJECT_ARRAY(objects, ICorDebugEditAndContinueErrorInfo*, celt, false, true);
    VALIDATE_POINTER_TO_OBJECT_OR_NULL(pceltFetched, ULONG *);

    USHORT i = 0;
    HRESULT hr = S_OK;

    memset(objects, 0, sizeof(ICorDebugEditAndContinueErrorInfo*)*celt);
    
    while(i<celt && m_iCur<m_iCount && !FAILED(hr))
    {
        hr = m_errors->m_pCordbEnCErrors[m_iCur++].QueryInterface(IID_ICorDebugEditAndContinueErrorInfo,
            (void**)&(objects[i++]));
    }

	if (pceltFetched != NULL)
	{
		(*pceltFetched) = i;
	}

    return hr;
}

HRESULT CordbEnCErrorInfoEnum::Init(UnorderedEnCErrorInfoArrayRefCount 
                                        *refCountedArray)
{
    _ASSERTE(refCountedArray != NULL);

    HRESULT hr = S_OK;
    
    m_errors    = refCountedArray;
    m_iCur      = 0;
    m_iCount    = m_errors->m_pErrors->Count(); 
    
    if (m_iCount != 0)
    {
        if (m_errors->m_pCordbEnCErrors == NULL)
        {
            m_errors->m_pCordbEnCErrors = new CordbEnCErrorInfo[m_iCount];
            if (m_errors->m_pCordbEnCErrors == NULL)
                return E_OUTOFMEMORY;

            EnCErrorInfo *pCurRaw = m_errors->m_pErrors->Table();

            for(USHORT i=0; i< m_iCount; i++,pCurRaw++)
            {
                // Note that m_module was switched from a left-side
                // DebuggerModule * to a CordbModule in CordbProcess::
                // TranslateLSToRSTokens.
                if (FAILED(hr = (m_errors->m_pCordbEnCErrors[i]).Init(
                                                    (CordbModule*)pCurRaw->m_module,
                                                    pCurRaw->m_token,
                                                    pCurRaw->m_hr,
                                                    pCurRaw->m_sz)))
                {
                    goto LError;
                }
            }
        }
/*        else
        {
            for(USHORT i=0; i< m_iCount; i++)
            {
                m_errors->m_pCordbEnCErrors[i].AddRef();
            }
        }*/
    }
    
    m_errors->AddRef();
    AddRef();
LError:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\debugger.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: debugger.cpp
//
// Debugger runtime controller routines.
//
// @doc
//*****************************************************************************

#include "stdafx.h"
#include "ComSystem.h"
#include "DebugDebugger.h"
#include "IPCManagerInterface.h"
#include "..\inc\Common.h"
#include "COMString.h"
#include "corsvcpriv.h"
#include "PerfLog.h"
#include "EEconfig.h" // This is here even for retail & free builds...
#include "..\..\dlls\mscorrc\resource.h"
#include "remoting.h"
#include "Context.h"

#ifdef _DEBUG
#pragma optimize("agpstwy", off)        // turn off compiler optimization, to avoid compiler ASSERT
#endif

// On windows, we need to set the MB_SERVICE_NOTIFICATION bit on message
//  boxes, but that bit isn't defined under windows CE.  This bit of code
//  will provide '0' for the value, and if the value ever is defined, will
//  pick it up automatically.
#if defined(MB_SERVICE_NOTIFICATION)
 # define COMPLUS_MB_SERVICE_NOTIFICATION MB_SERVICE_NOTIFICATION
#else
 # define COMPLUS_MB_SERVICE_NOTIFICATION 0
#endif

#if 0

//
// Uncomment this to enable spew - LOG doesn't work very well from a 
// secondary DLL
//

#define LOG(X) dummylog2 X
void dummylog2(int x, int y, char *s, ...)
{
    va_list args;

    va_start(args, s);
    vprintf(s, args);
    va_end(args);
}

#endif

#ifdef _DEBUG
    char* g_ppszAttachStateToSZ[]=
    {
    "SYNC_STATE_0" , 
    "SYNC_STATE_1" , 
    "SYNC_STATE_2" , 
    "SYNC_STATE_3" , 
    "SYNC_STATE_10", 
    "SYNC_STATE_11", 
    "SYNC_STATE_20", 
    };    
#endif


/* ------------------------------------------------------------------------ *
 * Global variables
 * ------------------------------------------------------------------------ */

Debugger                *g_pDebugger = NULL;
EEDebugInterface        *g_pEEInterface = NULL;
DebuggerRCThread        *g_pRCThread = NULL;

const InteropSafe interopsafe;

#ifdef ENABLE_PERF_LOG
__int64 g_debuggerTotalCycles = 0;
__int64 g_symbolTotalCycles = 0;
__int64 g_symbolCreateTotalCycles = 0;
__int64 g_symbolReadersCreated = 0;
BOOL    g_fDbgPerfOn = false;

#define START_DBG_PERF() \
    LARGE_INTEGER __cdbgstart; \
    if (g_fDbgPerfOn) \
        QueryPerformanceCounter(&__cdbgstart);

#define STOP_DBG_PERF() \
    if (g_fDbgPerfOn) \
    { \
        LARGE_INTEGER cstop; \
        QueryPerformanceCounter(&cstop); \
        g_debuggerTotalCycles += (cstop.QuadPart - __cdbgstart.QuadPart); \
    }

#define START_SYM_PERF() \
    LARGE_INTEGER __csymstart; \
    if (g_fDbgPerfOn) \
        QueryPerformanceCounter(&__csymstart);

#define STOP_SYM_PERF() \
    if (g_fDbgPerfOn) \
    { \
        LARGE_INTEGER cstop; \
        QueryPerformanceCounter(&cstop); \
        g_symbolTotalCycles += (cstop.QuadPart - __csymstart.QuadPart); \
    }

#define START_SYM_CREATE_PERF() \
    LARGE_INTEGER __csymcreatestart; \
    if (g_fDbgPerfOn) \
        QueryPerformanceCounter(&__csymcreatestart);

#define STOP_SYM_CREATE_PERF() \
    if (g_fDbgPerfOn) \
    { \
        LARGE_INTEGER cstop; \
        QueryPerformanceCounter(&cstop); \
        g_symbolCreateTotalCycles += (cstop.QuadPart - __csymcreatestart.QuadPart); \
    }
#else
#define START_DBG_PERF()
#define STOP_DBG_PERF()
#define START_SYM_PERF()
#define STOP_SYM_PERF()
#define START_SYM_CREATE_PERF()
#define STOP_SYM_CREATE_PERF()
#endif

/* ------------------------------------------------------------------------ *
 * DLL export routine
 * ------------------------------------------------------------------------ */

//
// CorDBGetInterface is exported to the Runtime so that it can call
// the Runtime Controller.
//
extern "C"{
HRESULT __cdecl CorDBGetInterface(DebugInterface** rcInterface)
{
    HRESULT hr = S_OK;
    
    if (rcInterface != NULL)
    {
        if (g_pDebugger == NULL)
        {
            LOG((LF_CORDB, LL_INFO10,
                 "CorDBGetInterface: initializing debugger.\n"));
            
            g_pDebugger = new Debugger();
            TRACE_ALLOC(g_pDebugger);

            if (g_pDebugger == NULL)
                hr = E_OUTOFMEMORY;
        }
    
        *rcInterface = g_pDebugger;
    }

    return hr;
}
}


// Validate an object. Returns E_INVALIDARG or S_OK.
HRESULT ValidateObject(Object *objPtr)
{
    __try
    {
        // NULL is certinally valid...
        if (objPtr != NULL)
        {
            EEClass *objClass = objPtr->GetClass();
            MethodTable *pMT = objPtr->GetMethodTable();
        
            if (pMT != objClass->GetMethodTable())
            {
                LOG((LF_CORDB, LL_INFO10000, "GAV: MT's don't match.\n"));

                return E_INVALIDARG;
            }
        }
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        LOG((LF_CORDB, LL_INFO10000, "GAV: exception indicated ref is bad.\n"));
    
        return E_INVALIDARG;
    }
    return S_OK;
}   // ValidateObject

/* ------------------------------------------------------------------------ *
 * DebuggerPatchTable routines
 * ------------------------------------------------------------------------ */

void DebuggerPatchTable::ClearPatchesFromModule(Module *pModule)
{
    LOG((LF_CORDB, LL_INFO100000, "DPT::CPFM mod:0x%x (%S)\n",
        pModule, pModule->GetFileName()));

    HASHFIND f;
    for (DebuggerControllerPatch *patch = GetFirstPatch(&f);
         patch != NULL;
         patch = GetNextPatch(&f))
    {
        if (patch->dji != (DebuggerJitInfo*)DebuggerJitInfo::DJI_VERSION_INVALID && 
            patch->dji->m_fd->GetModule() == pModule)
        {
            LOG((LF_CORDB, LL_EVERYTHING, "Removing patch 0x%x\n", 
                patch));
            // we shouldn't be both hitting this patch AND
            // unloading hte module it belongs to.
            _ASSERTE(!patch->triggering);
            // Note that we don't DeactivatePatch since the
            // memory the patch was at has already gone away.
            RemovePatch(patch);
        }
    }
}


/* ------------------------------------------------------------------------ *
 * Debugger routines
 * ------------------------------------------------------------------------ */

//
// a Debugger object represents the global state of the debugger program.
//

//
// Constructor & Destructor
//

/******************************************************************************
 *
 ******************************************************************************/
Debugger::Debugger()
  : m_pRCThread(NULL),
    m_trappingRuntimeThreads(FALSE),
    m_stopped(FALSE),
    m_unrecoverableError(FALSE),
    m_ignoreThreadDetach(FALSE),
    m_eventHandlingEvent(NULL),
    m_syncingForAttach(SYNC_STATE_0),
    m_debuggerAttached(FALSE),
    m_attachingForException(FALSE),
    m_exAttachEvent(NULL),
    m_exAttachAbortEvent(NULL),
    m_runtimeStoppedEvent(NULL),
    m_exLock(0),
    m_threadsAtUnsafePlaces(0),
    m_LoggingEnabled(TRUE),
    m_pAppDomainCB(NULL),
    m_fGCPrevented(FALSE),
    m_pIDbgThreadControl(NULL),
    m_RCThreadHoldsThreadStoreLock(FALSE),
    m_pMemBlobs(NULL),
    m_pJitInfos(NULL),
    m_pModules(NULL),
    m_pPendingEvals(NULL),
    m_heap(NULL)
#ifdef _DEBUG
    ,m_mutexCount(0)
#endif //_DEBUG

{
    m_processId = GetCurrentProcessId();
}

/******************************************************************************
 *
 ******************************************************************************/
Debugger::~Debugger()
{
    HASHFIND info;

    if (m_pJitInfos != NULL)
    {
        for (DebuggerJitInfo *dji = m_pJitInfos->GetFirstJitInfo(&info);
         dji != NULL;
             dji = m_pJitInfos->GetNextJitInfo(&info))
    {
        LOG((LF_CORDB, LL_EVERYTHING, "D::~D: delete DJI 0x%x\n", dji));

        DebuggerJitInfo *djiPrev = NULL;

        while(dji != NULL)
        {
            djiPrev = dji->m_prevJitInfo;
            
            TRACE_FREE(dji);
                DeleteInteropSafe(dji);
            
            dji = djiPrev;
        }
    }

        DeleteInteropSafe(m_pJitInfos);
        m_pJitInfos = NULL;
    }

    if (m_pModules != NULL)
    {
        DeleteInteropSafe(m_pModules);
        m_pModules = NULL;
    }

    if (m_pPendingEvals)
    {
        DeleteInteropSafe(m_pPendingEvals);
        m_pPendingEvals = NULL;
    }

    if (m_pMemBlobs != NULL)
    {
        USHORT cBlobs = m_pMemBlobs->Count();
        BYTE **rgpBlobs = m_pMemBlobs->Table();

        for (int i = 0; i < cBlobs; i++)
        {
            ReleaseRemoteBuffer(rgpBlobs[i], false);            
        }

        DeleteInteropSafe(m_pMemBlobs);
    }
    
    if (m_eventHandlingEvent != NULL)
        CloseHandle(m_eventHandlingEvent);

    if (m_exAttachEvent != NULL)
        CloseHandle(m_exAttachEvent);

    if (m_CtrlCMutex != NULL)
        CloseHandle(m_CtrlCMutex);

    if (m_debuggerAttachedEvent != NULL)
        CloseHandle(m_debuggerAttachedEvent);

    if (m_exAttachAbortEvent != NULL)
        CloseHandle(m_exAttachAbortEvent);

    if (m_runtimeStoppedEvent != NULL)
        CloseHandle(m_runtimeStoppedEvent);

    DebuggerController::Uninitialize();

    DeleteCriticalSection(&m_jitInfoMutex);
    DeleteCriticalSection(&m_mutex);

    // Also clean up the AppDomain
    TerminateAppDomainIPC ();

    // Finally, destroy our heap...
    if (m_heap != NULL)
    {
        delete m_heap;
    }

    // Release any debugger thread control object we might be holding.
    // We leak this in V1
}

// Checks if the JitInfos table has been allocated, and if not does so.
HRESULT Debugger::CheckInitJitInfoTable()
{
    if (m_pJitInfos == NULL)
    {
        DebuggerJitInfoTable *pJitInfos = new (interopsafe) DebuggerJitInfoTable();
        _ASSERTE(pJitInfos);

        if (pJitInfos == NULL)
            return (E_OUTOFMEMORY);

        if (InterlockedCompareExchangePointer((PVOID *)&m_pJitInfos, (PVOID)pJitInfos, NULL) != NULL)
        {
            DeleteInteropSafe(pJitInfos);
        }
    }

    return (S_OK);
}

// Checks if the m_pModules table has been allocated, and if not does so.
HRESULT Debugger::CheckInitModuleTable()
{
    if (m_pModules == NULL)
    {
        DebuggerModuleTable *pModules = new (interopsafe) DebuggerModuleTable();
        _ASSERTE(pModules);

        if (pModules == NULL)
            return (E_OUTOFMEMORY);

        if (InterlockedCompareExchangePointer((PVOID *)&m_pModules, (PVOID)pModules, NULL) != NULL)
        {
            DeleteInteropSafe(pModules);
        }
    }

    return (S_OK);
}

// Checks if the m_pModules table has been allocated, and if not does so.
HRESULT Debugger::CheckInitPendingFuncEvalTable()
{
    if (m_pPendingEvals == NULL)
    {
        DebuggerPendingFuncEvalTable *pPendingEvals = new (interopsafe) DebuggerPendingFuncEvalTable();
        _ASSERTE(pPendingEvals);

        if (pPendingEvals == NULL)
            return (E_OUTOFMEMORY);

        if (InterlockedCompareExchangePointer((PVOID *)&m_pPendingEvals, (PVOID)pPendingEvals, NULL) != NULL)
        {
            DeleteInteropSafe(pPendingEvals);
        }
    }

    return (S_OK);
}

#ifdef _DEBUG_DJI_TABLE
// Returns the number of (official) entries in the table
ULONG DebuggerJitInfoTable::CheckDjiTable(void)
{
	USHORT cApparant = 0;
	USHORT cOfficial = 0;

    if (NULL != m_pcEntries)
    {
    	DebuggerJitInfoEntry *dcp;
    	int i = 0;
    	while (i++ <m_iEntries)
    	{
    		dcp = (DebuggerJitInfoEntry*)&(((DebuggerJitInfoEntry *)m_pcEntries)[i]);
            if(dcp->pFD != 0 && 
               dcp->pFD != (MethodDesc*)0xcdcdcdcd &&
               dcp->ji != NULL)
            {
                cApparant++;
                
                _ASSERTE( dcp->pFD == dcp->ji->m_fd );
				LOG((LF_CORDB, LL_INFO1000, "DJIT::CDT:Entry:0x%x ji:0x%x\nPrevs:\n",
					dcp, dcp->ji));
				DebuggerJitInfo *dji = dcp->ji->m_prevJitInfo;
				
				while(dji != NULL)
				{
					LOG((LF_CORDB, LL_INFO1000, "\t0x%x\n", dji));
					dji = dji->m_prevJitInfo;
				}
				dji = dcp->ji->m_nextJitInfo;
				
				LOG((LF_CORDB, LL_INFO1000, "Nexts:\n", dji));
				while(dji != NULL)
				{
					LOG((LF_CORDB, LL_INFO1000, "\t0x%x\n", dji));
					dji = dji->m_nextJitInfo;
				}
				
				LOG((LF_CORDB, LL_INFO1000, "DJIT::CDT:DONE\n",
					dcp, dcp->ji));
			}
        }

    	if (m_piBuckets == 0)
    	{
        	LOG((LF_CORDB, LL_INFO1000, "DJIT::CDT: The table is officially empty!\n"));
        	return cOfficial;
        }
        
		LOG((LF_CORDB, LL_INFO1000, "DJIT::CDT:Looking for official entries:\n"));

	    USHORT iNext = m_piBuckets[0];
		USHORT iBucket = 1;
        HASHENTRY   *psEntry = NULL;
        while (TRUE)
		{
        	while (iNext != 0xffff)
	        {
                cOfficial++;
	        
	            psEntry = EntryPtr(iNext);
				dcp = ((DebuggerJitInfoEntry *)psEntry);

				LOG((LF_CORDB, LL_INFO1000, "\tEntry:0x%x ji:0x%x @idx:0x%x @bucket:0x%x\n",
					dcp, dcp->ji, iNext, iBucket));

				iNext = psEntry->iNext;
			}

	        // Advance to the next bucket.
	        if (iBucket < m_iBuckets)
	            iNext = m_piBuckets[iBucket++];
	        else
	            break;
		}            

		LOG((LF_CORDB, LL_INFO1000, "DJIT::CDT:Finished official entries: ****************"));
    }

    return cOfficial;
}
#endif // _DEBUG_DJI_TABLE

//
// Startup initializes any necessary debugger objects, including creating
// and starting the Runtime Controller thread. Once the RC thread is started
// and we return successfully, the Debugger object can expect to have its
// event handlers called.
/*******************************************************************************/
HRESULT Debugger::Startup(void)
{
    HRESULT hr = S_OK;
    SECURITY_ATTRIBUTES *pSA = NULL;

    _ASSERTE(g_pEEInterface != NULL);

#ifdef ENABLE_PERF_LOG
    // Should we track perf info?
    char buf[32];
    g_fDbgPerfOn = GetEnvironmentVariableA("DBG_PERF_OUTPUT", buf, sizeof(buf));
#endif
    
    // First, initialize our heap.
    m_heap = new DebuggerHeap();

    if (m_heap != NULL)
    {
        m_heap->Init("Debugger Heap");
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // Must be done before the RC thread is initialized.
    // The helper thread will be able to determine if someone was trying
    // to attach before the runtime was loaded and set the appropriate
    // flags that will cause CORDebuggerAttached to return true
    if (CORLaunchedByDebugger())
        DebuggerController::Initialize();

    // We must initialize the debugger lock before kicking off the
    // helper thread. The helper thread will try to use the lock right
    // away to guard against certian race conditions.
    InitializeCriticalSection(&m_mutex);

#ifdef _DEBUG
    m_mutexOwner = 0;
#endif    

    // Create the runtime controller thread, a.k.a, the debug helper thread.
    m_pRCThread = new (interopsafe) DebuggerRCThread(this);
    TRACE_ALLOC(m_pRCThread);

    if (m_pRCThread != NULL)
    {
        hr = m_pRCThread->Init();

        if (SUCCEEDED(hr))
            hr = m_pRCThread->Start();

        if (!SUCCEEDED(hr))
        {
            TRACE_FREE(m_pRCThread);
            DeleteInteropSafe(m_pRCThread);
            m_pRCThread = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    NAME_EVENT_BUFFER;
    m_eventHandlingEvent = WszCreateEvent(NULL, FALSE, TRUE, NAME_EVENT(L"EventHandlingEvent"));
    if (m_eventHandlingEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }


    m_exAttachEvent = WszCreateEvent(NULL, TRUE, FALSE, NAME_EVENT(L"ExAttachEvent"));
    if (m_exAttachEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    m_exAttachAbortEvent = WszCreateEvent(NULL, TRUE, FALSE, NAME_EVENT(L"ExAttachAbortEvent"));
    if (m_exAttachAbortEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    m_runtimeStoppedEvent = WszCreateEvent(NULL, FALSE, FALSE, NAME_EVENT(L"RuntimeStoppedEvent"));
    if (m_runtimeStoppedEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    InitializeCriticalSection(&m_jitInfoMutex);

    m_CtrlCMutex = WszCreateEvent(NULL, FALSE, FALSE, NAME_EVENT(L"CtrlCMutex"));
    if (m_CtrlCMutex == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
    
    // Note: this one is only temporary. We would have rather added this event into the DCB or into the RuntimeOffsets
    // but we can't without that being a breaking change at this point (Fri Jul 13 15:17:20 2001). So we're using a
    // named event for now, and next time we change the struct we'll put it back in.
	WCHAR tmpName[256];

    if (RunningOnWinNT5())
        swprintf(tmpName, L"Global\\" CorDBDebuggerAttachedEvent, GetCurrentProcessId());
    else
        swprintf(tmpName, CorDBDebuggerAttachedEvent, GetCurrentProcessId());

    hr = g_pIPCManagerInterface->GetSecurityAttributes(GetCurrentProcessId(), &pSA);

    if (FAILED(hr))
        goto exit;
    
    LOG((LF_CORDB, LL_INFO10000, "DRCT::I: creating DebuggerAttachedEvent with name [%S]\n", tmpName));
    m_debuggerAttachedEvent = WszCreateEvent(pSA, TRUE, FALSE, tmpName);

    // Do not fail out from the failure of creating debuggerAttachedEvent
    
    m_DebuggerHandlingCtrlC = FALSE;

    // Also initialize the AppDomainEnumerationIPCBlock 
    m_pAppDomainCB = g_pIPCManagerInterface->GetAppDomainBlock();

    if (m_pAppDomainCB == NULL)
    {
       LOG((LF_CORDB, LL_INFO100,
             "D::S: Failed to get AppDomain IPC block from IPCManager.\n"));
       hr = E_FAIL;
       goto exit;
    }

    hr = InitAppDomainIPC();
    
    if (hr != S_OK)
    {
       LOG((LF_CORDB, LL_INFO100,
             "D::S: Failed to Initialize AppDomain IPC block.\n"));

       goto exit;
    }

    m_pMemBlobs = new (interopsafe) UnorderedBytePtrArray();
    
    if (m_pMemBlobs == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // We set m_debuggerAttachedEvent to indicate that a debugger is now attached to the process. This is used by the
    // interop debugging hijacks to ensure that a debugger is attached enough to the process to proceed through the
    // hijacks. We do this here when the process was launched by a debugger since we know 100% for sure that there is a
    // debugger attached now.
    if (CORLaunchedByDebugger() && m_debuggerAttachedEvent)
        VERIFY(SetEvent(m_debuggerAttachedEvent));
        
exit:
    g_pIPCManagerInterface->DestroySecurityAttributes(pSA);
    
    return hr;
}


/******************************************************************************
// Called to set the interface that the Runtime exposes to us.
 ******************************************************************************/
void Debugger::SetEEInterface(EEDebugInterface* i)
{
    g_pEEInterface = i;
}


/******************************************************************************
// Called to shut down the debugger. This stops the RC thread and cleans
// the object up.
 ******************************************************************************/
void Debugger::StopDebugger(void)
{
    if (m_pRCThread != NULL)
    {
        HRESULT hr = m_pRCThread->Stop();

        if (SUCCEEDED(hr))
        {
            TRACE_FREE(m_pRCThread);
            DeleteInteropSafe(m_pRCThread);
            m_pRCThread = NULL;
        }
    }

    delete this;

#ifdef ENABLE_PERF_LOG
    if (g_fDbgPerfOn)
    {
        LARGE_INTEGER cycleFreq;

        QueryPerformanceFrequency(&cycleFreq);

        double dtot, freq, stot, sctot;
        
        freq = (double)cycleFreq.QuadPart;
        dtot = (double)g_debuggerTotalCycles;
        stot = (double)g_symbolTotalCycles;
        sctot = (double)g_symbolCreateTotalCycles;

        WCHAR buf[1024];

#define SHOWINFOCYC(_b, _m, _d) \
        swprintf((_b), L"%-30s%12.3g cycles", (_m), (_d)); \
        fprintf(stderr, "%S\n", buf);
                                              
#define SHOWINFOSEC(_b, _m, _d) \
        swprintf((_b), L"%-30s%12.3g sec", (_m), (_d)); \
        fprintf(stderr, "%S\n", buf);
                                              
#define SHOWINFO(_b, _m, _d) \
        swprintf((_b), L"%-30s%12d", (_m), (_d)); \
        fprintf(stderr, "%S\n", buf);
                                              
        SHOWINFOCYC(buf, L"Debugger Tracking Cycles", (dtot - stot - sctot));
        SHOWINFOSEC(buf, L"Debugger Tracking Time", (dtot - stot - sctot)/freq);
        SHOWINFOCYC(buf, L"Symbol Store Cycles", stot);
        SHOWINFOSEC(buf, L"Symbol Store Time", stot/freq);
        SHOWINFOCYC(buf, L"Symbol Store Create Cycles", sctot);
        SHOWINFOSEC(buf, L"Symbol Store Create Time", sctot/freq);
        SHOWINFO(buf, L"Symbol readers created", g_symbolReadersCreated);
    }
#endif
}


/* ------------------------------------------------------------------------ *
 * JIT Interface routines
 * ------------------------------------------------------------------------ */

//
// This is only fur internal debugging.
//
#ifdef LOGGING
static void _dumpVarNativeInfo(ICorJitInfo::NativeVarInfo* vni)
{
    LOG((LF_CORDB, LL_INFO1000000, "Var %02d: 0x%04x-0x%04x vlt=",
            vni->varNumber,
            vni->startOffset, vni->endOffset,
            vni->loc.vlType));

    switch (vni->loc.vlType)
    {
    case ICorJitInfo::VLT_REG:
        LOG((LF_CORDB, LL_INFO1000000, "REG reg=%d\n", vni->loc.vlReg.vlrReg));
        break;
        
    case ICorJitInfo::VLT_STK:
        LOG((LF_CORDB, LL_INFO1000000, "STK reg=%d off=0x%04x (%d)\n",
             vni->loc.vlStk.vlsBaseReg,
             vni->loc.vlStk.vlsOffset,
             vni->loc.vlStk.vlsOffset));
        break;
        
    case ICorJitInfo::VLT_REG_REG:
        LOG((LF_CORDB, LL_INFO1000000, "REG_REG reg1=%d reg2=%d\n",
             vni->loc.vlRegReg.vlrrReg1,
             vni->loc.vlRegReg.vlrrReg2));
        break;
        
    case ICorJitInfo::VLT_REG_STK:
        LOG((LF_CORDB, LL_INFO1000000, "REG_STK reg=%d basereg=%d off=0x%04x (%d)\n",
             vni->loc.vlRegStk.vlrsReg,
             vni->loc.vlRegStk.vlrsStk.vlrssBaseReg,
             vni->loc.vlRegStk.vlrsStk.vlrssOffset,
             vni->loc.vlRegStk.vlrsStk.vlrssOffset));
        break;
        
    case ICorJitInfo::VLT_STK_REG:
        LOG((LF_CORDB, LL_INFO1000000, "STK_REG basereg=%d off=0x%04x (%d) reg=%d\n",
             vni->loc.vlStkReg.vlsrStk.vlsrsBaseReg,
             vni->loc.vlStkReg.vlsrStk.vlsrsOffset,
             vni->loc.vlStkReg.vlsrStk.vlsrsOffset,
             vni->loc.vlStkReg.vlsrReg));
        break;
        
    case ICorJitInfo::VLT_STK2:
        LOG((LF_CORDB, LL_INFO1000000, "STK_STK reg=%d off=0x%04x (%d)\n",
             vni->loc.vlStk2.vls2BaseReg,
             vni->loc.vlStk2.vls2Offset,
             vni->loc.vlStk2.vls2Offset));
        break;
        
    case ICorJitInfo::VLT_FPSTK:
        LOG((LF_CORDB, LL_INFO1000000, "FPSTK reg=%d\n",
             vni->loc.vlFPstk.vlfReg));
        break;

    case ICorJitInfo::VLT_FIXED_VA:
        LOG((LF_CORDB, LL_INFO1000000, "FIXED_VA offset=%d (%d)\n",
             vni->loc.vlFixedVarArg.vlfvOffset,
             vni->loc.vlFixedVarArg.vlfvOffset));
        break;
        
        
    default:
        LOG((LF_CORDB, LL_INFO1000000, "???\n"));
        break;
    }
}
#endif

/******************************************************************************
 *
 ******************************************************************************/
DebuggerJitInfo *Debugger::CreateJitInfo(MethodDesc *fd)
{
    //
    // Create a jit info struct to hold info about this function.
    //
//    CHECK_DJI_TABLE_DEBUGGER;

    //
    // @todo perf: creating these on the heap is slow. We should use a
    // pool and create them out of there since we never free them
    // until the very, very end.
    //
    DebuggerJitInfo *ji = new (interopsafe) DebuggerJitInfo(fd);

    TRACE_ALLOC(ji);

    if (ji != NULL )
    {
        //
        // Lock a mutex when changing the table.
        //
        //@TODO : _ASSERTE(EnC);
        HRESULT hr;
        hr =g_pDebugger->InsertAtHeadOfList( ji );

        if (FAILED(hr))
        {
            DeleteInteropSafe(ji);
            return NULL;
        }
    }

    return ji;
}

/******************************************************************************
 *
 ******************************************************************************/
void DebuggerJitInfo::SetVars(ULONG32 cVars, ICorDebugInfo::NativeVarInfo *pVars, bool fDelete)
{
    _ASSERTE(m_varNativeInfo == NULL);

    m_varNativeInfo = pVars;
    m_varNativeInfoCount = cVars;
    m_varNeedsDelete = fDelete;

    LOG((LF_CORDB, LL_INFO1000000, "D::sV: var count is %d\n",
         m_varNativeInfoCount));

#ifdef LOGGING    
    for (unsigned int i = 0; i < m_varNativeInfoCount; i++)
    {
        ICorJitInfo::NativeVarInfo* vni = &(m_varNativeInfo[i]);
        _dumpVarNativeInfo(vni);
    }
#endif    
}

/*
@class MapSortIL | A template class that will sort an array of <t DebuggerILToNativeMap>.  This class is intended to be instantiated on the stack / in temporary storage, and used to reorder the sequence map.
@base public | CQuickSort
 */
class MapSortIL : public CQuickSort<DebuggerILToNativeMap>
{
    //@access Public Members
  public:
    //@cmember Constructor
    MapSortIL(DebuggerILToNativeMap *map, 
              int count)
      : CQuickSort<DebuggerILToNativeMap>(map, count) {}

    //@cmember Comparison operator
    int Compare(DebuggerILToNativeMap *first, 
                DebuggerILToNativeMap *second) 
    {
        //PROLOGs go first
        if (first->ilOffset == ICorDebugInfo::MappingTypes::PROLOG
            && second->ilOffset == ICorDebugInfo::MappingTypes::PROLOG)
        {
            return 0;
        } else if (first->ilOffset == ICorDebugInfo::MappingTypes::PROLOG)
        {
            return -1;
        } else if (second->ilOffset == ICorDebugInfo::MappingTypes::PROLOG)
        {
            return 1;
        }
        //NO_MAPPING go last
        else if (first->ilOffset == ICorDebugInfo::MappingTypes::NO_MAPPING
            && second->ilOffset == ICorDebugInfo::MappingTypes::NO_MAPPING)
        {
            return 0;
        } else if (first->ilOffset == ICorDebugInfo::MappingTypes::NO_MAPPING)
        {
            return 1;
        } else if (second->ilOffset == ICorDebugInfo::MappingTypes::NO_MAPPING)
        {
            return -1;
        }
        //EPILOGs go next-to-last
        else if (first->ilOffset == ICorDebugInfo::MappingTypes::EPILOG
            && second->ilOffset == ICorDebugInfo::MappingTypes::EPILOG)
        {
            return 0;
        } else if (first->ilOffset == ICorDebugInfo::MappingTypes::EPILOG)
        {
            return 1;
        } else if (second->ilOffset == ICorDebugInfo::MappingTypes::EPILOG)
        {
            return -1;
        }
        //normal offsets compared otherwise
        else if (first->ilOffset < second->ilOffset)
            return -1;
        else if (first->ilOffset == second->ilOffset)
            return 0;
        else
            return 1;
    }
};

/*
@class MapSortNative | A template class that will sort an array of <t DebuggerILToNativeMap> by the nativeStartOffset field.  This class is intended to be instantiated on the stack / in temporary storage, and used to reorder the sequence map.
@base public | CQuickSort
*/
class MapSortNative : public CQuickSort<DebuggerILToNativeMap>
{
  public:
    //@cmember Constructor
    MapSortNative(DebuggerILToNativeMap *map,
                  int count) 
      : CQuickSort<DebuggerILToNativeMap>(map, count) {}

    //@cmember Returns -1,0,or 1 if first's nativeStartOffset is less than, equal to, or greater than second's
    int Compare(DebuggerILToNativeMap *first, 
                DebuggerILToNativeMap *second)
    {
        if (first->nativeStartOffset < second->nativeStartOffset)
            return -1;
        else if (first->nativeStartOffset == second->nativeStartOffset)
            return 0;
        else
            return 1;
    }
};

/******************************************************************************
 *
 ******************************************************************************/
HRESULT DebuggerJitInfo::SetBoundaries(ULONG32 cMap, ICorDebugInfo::OffsetMapping *pMap)
{
    _ASSERTE((cMap == 0) == (pMap == NULL));
    _ASSERTE(m_sequenceMap == NULL);

    SIZE_T ilLast = 0;
    HRESULT hr = S_OK;

#ifdef _DEBUG
    // We assume that the map is sorted by native offset
    {
        for(ICorDebugInfo::OffsetMapping * pEntry = pMap;
            pEntry < (pMap + cMap - 1); 
            pEntry++
        )
        {
        _ASSERTE(pEntry->nativeOffset <= (pEntry+1)->nativeOffset);
        }
    }
#endif //_DEBUG

    //
    // @todo perf: allocating these on the heap is slow. We could do
    // better knowing that these live for the life of the run, just
    // like the DebuggerJitInfo's.
    //
    m_sequenceMapCount = cMap;
    m_sequenceMap = (DebuggerILToNativeMap *)new (interopsafe) DebuggerILToNativeMap[m_sequenceMapCount];
    if (NULL == m_sequenceMap)
        return E_OUTOFMEMORY;
    
    DebuggerILToNativeMap *m = m_sequenceMap;
    
    // For the instrumented-IL case, we need to remove all duplicate entries. 
    // So we keep a record of the last old IL offset. If the current old IL
    // offset is the same as the last old IL offset, we remove it.
    // Pick a unique initial value (-10) so that the 1st doesn't accidentally match.
    int ilPrevOld = -10;
        
    //
    // @todo perf: we could do the vast majority of this
    // post-processing work the first time the sequence point map is
    // demanded. That would allow us to simply hold the raw array for
    // 95% of the functions jitted while debugging, and 100% of them
    // when just running/tracking.
    //    
    for(ULONG32 idxJitMap = 0; idxJitMap < cMap; idxJitMap++)
    {
        const ICorDebugInfo::OffsetMapping * const pMapEntry = &pMap[idxJitMap];
        _ASSERTE(m >= m_sequenceMap);
        _ASSERTE(m < m_sequenceMap + m_sequenceMapCount);

        ilLast = max( (int)ilLast, (int)pMapEntry->ilOffset );
            
        // Simply copy everything over, since we translate to
        // CorDebugMappingResults immediately prior to handing
        // back to user...
        m->nativeStartOffset    = pMapEntry->nativeOffset;
        m->ilOffset             = pMapEntry->ilOffset;
        m->source               = pMapEntry->source;
        
        // Keep in mind that if we have an instrumented code translation
        // table, we may have asked for completely different IL offsets
        // than the user thinks we did.....
        // If we did instrument, then we can't have any sequence points that
        // are "in-between" the old-->new map that the profiler gave us.
        // Ex, if map is:
        // (6 old -> 36 new)
        // (8 old -> 50 new)
        // And the jit gives us an entry for 44 new, that will map back to 6 old.
        // Since the map can only have one entry for 6 old, we remove 44 new.
        if (m_cInstrumentedILMap != 0)
        {
            int ilThisOld = TranslateToInstIL(pMapEntry->ilOffset, bInstrumentedToOriginal);
            
            if (ilThisOld == ilPrevOld)
            {
                // If this translated to the same old IL offset as the last entry,
                // then this is "in between". Skip it.                
                m_sequenceMapCount--; // one less seq point in the DJI's map
                continue;
            }            
            m->ilOffset = ilThisOld;
            ilPrevOld = ilThisOld;
        }

        if (m>m_sequenceMap && (m-1)->ilOffset == m->ilOffset)
        {
            // JIT gave us an extra entry (probably zero), so mush
            // it into the one we've already got.
            // @todo Why does this happen?
            m_sequenceMapCount--;
            continue;            
        }
        
        // Move to next entry in the debugger's table
        m++;        
    } // end for
    
    _ASSERTE(m == m_sequenceMap + m_sequenceMapCount);

    m_lastIL = ilLast;
    
    // Set nativeEndOffset in debugger's il->native map
    // Do this before we resort by IL.
    for(unsigned int i = 0; i < m_sequenceMapCount - 1; i++)
    {
        m_sequenceMap[i].nativeEndOffset = m_sequenceMap[i+1].nativeStartOffset;
    }
    m_sequenceMap[i].nativeEndOffset = 0;
    m_sequenceMap[i].source = (ICorDebugInfo::SourceTypes)
                ((DWORD)m->source | 
                (DWORD)ICorDebugInfo::NATIVE_END_OFFSET_UNKNOWN);

        
    // Now resort by IL.
    MapSortIL isort(m_sequenceMap, m_sequenceMapCount);

    isort.Sort();
      
    m_sequenceMapSorted = true;

    LOG((LF_CORDB, LL_INFO1000000, "D::sB: boundary count is %d\n",
         m_sequenceMapCount));

#ifdef LOGGING    
    for (unsigned int i = 0; i < m_sequenceMapCount; i++)
    {
        if( m_sequenceMap[i].ilOffset == 
            ICorDebugInfo::MappingTypes::PROLOG )
            LOG((LF_CORDB, LL_INFO1000000,
                 "D::sB: PROLOG               --> 0x%08x -- 0x%08x",
                 m_sequenceMap[i].nativeStartOffset,
                 m_sequenceMap[i].nativeEndOffset));
        else if ( m_sequenceMap[i].ilOffset == 
                  ICorDebugInfo::MappingTypes::EPILOG )
            LOG((LF_CORDB, LL_INFO1000000,
                 "D::sB: EPILOG              --> 0x%08x -- 0x%08x",
                 m_sequenceMap[i].nativeStartOffset,
                 m_sequenceMap[i].nativeEndOffset));
        else if ( m_sequenceMap[i].ilOffset == 
                  ICorDebugInfo::MappingTypes::NO_MAPPING )
            LOG((LF_CORDB, LL_INFO1000000,
                 "D::sB: NO MAP              --> 0x%08x -- 0x%08x",
                 m_sequenceMap[i].nativeStartOffset,
                 m_sequenceMap[i].nativeEndOffset));
        else
            LOG((LF_CORDB, LL_INFO1000000,
                 "D::sB: 0x%04x (Real:0x%04x) --> 0x%08x -- 0x%08x",
                 m_sequenceMap[i].ilOffset,
                 TranslateToInstIL(m_sequenceMap[i].ilOffset,
                                   bOriginalToInstrumented),
                 m_sequenceMap[i].nativeStartOffset,
                 m_sequenceMap[i].nativeEndOffset));

        LOG((LF_CORDB, LL_INFO1000000, " Src:0x%x\n", m_sequenceMap[i].source));
    }
#endif //LOGGING
    
    return S_OK;
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT DebuggerJitInfo::UpdateDeferedBreakpoints(DebuggerJitInfo *pDji,
                                                  Thread *pThread,
                                                  void *fp)
{
    LOG((LF_CORDB, LL_INFO1000000,"DJI::UDB: dji:0x%x\n"));
         
    _ASSERTE(this != NULL);

    if (m_pDcq == NULL || !m_encBreakpointsApplied)
        return S_OK;

    int cDc = m_pDcq->dcqGetCount();
    int iDc = 0; 
    
    while (iDc < cDc)
    {
        DebuggerController *dc = m_pDcq->dcqGetElement(iDc);

        dc->DoDeferedPatch(pDji, pThread, fp);

        iDc++;
    }

    iDc = 0;
    while (iDc < cDc)
    {
        m_pDcq->dcqDequeue();
        iDc++;
    }    

    return S_OK;
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT DebuggerJitInfo::AddToDeferedQueue(DebuggerController *dc)
{
    HRESULT hr = S_OK;

    LOG((LF_CORDB, LL_INFO1000000,"DJI::ATDQ: dji:0x%x dc:0x%x\n", this, dc));
    
    if (NULL == m_pDcq)
    {
        m_pDcq = new (interopsafe) DebuggerControllerQueue();
    }

    if (NULL == m_pDcq)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }
        
    if (!m_pDcq->dcqEnqueue(dc, TRUE))
        hr = E_OUTOFMEMORY;

LExit:
    return hr;
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT DebuggerJitInfo::RemoveFromDeferedQueue(DebuggerController *dc)
{
    LOG((LF_CORDB, LL_INFO1000000,"DJI::RFDQ: dji:0x%x dc:0x%x\n", this, dc));
    
    if (m_pDcq == NULL || !m_encBreakpointsApplied)
        return S_OK;

    int cDc = m_pDcq->dcqGetCount();
    int iDc = 0; 
    
    while (iDc < cDc)
    {
        if (m_pDcq->dcqGetElement(iDc) == dc)
            m_pDcq->dcqDequeue(iDc);
            
        iDc++;
    }    

    return S_OK;

}

/******************************************************************************
 *
 ******************************************************************************/
ICorDebugInfo::SourceTypes DebuggerJitInfo::GetSrcTypeFromILOffset(SIZE_T ilOffset)
{
    BOOL exact = FALSE;
    DebuggerILToNativeMap *pMap = MapILOffsetToMapEntry(ilOffset, &exact);

    LOG((LF_CORDB, LL_INFO100000, "DJI::GSTFILO: for il 0x%x, got entry 0x%x,"
        "(il 0x%x) nat 0x%x to 0x%x, exact:%x\n", ilOffset, pMap, 
        pMap->ilOffset, pMap->nativeStartOffset, pMap->nativeEndOffset, 
        exact));

    if (!exact)
    {
        return ICorDebugInfo::SOURCE_TYPE_INVALID;
    }
    
    return pMap->source;
}

/******************************************************************************
// @mfunc void|Debugger|JITBeginning| JITBeginning is called 
//  from vm/jitinterface.cpp when a JIT is about to occur for a given function,
// either if debug info needs to be tracked for the method, or if a debugger is attached.
//  Remember that this gets called before
//  the start address of the MethodDesc gets set, and so methods like
//  GetFunctionAddress & GetFunctionSize won't work.
// @parm MethodDesc*|fd|MethodDesc of the method about to be
//      JITted.
 ******************************************************************************/
void Debugger::JITBeginning(MethodDesc* fd, bool trackJITInfo)
{
    START_DBG_PERF();

    _ASSERTE(trackJITInfo || CORDebuggerAttached());
    if (CORDBUnrecoverableError(this) || !trackJITInfo)
        goto Exit;

    LOG((LF_CORDB,LL_INFO10000,"De::JITBeg: %s::%s\n", 
        fd->m_pszDebugClassName,fd->m_pszDebugMethodName));

    // We don't necc. want to create another DJI.  In particular, if
    // 1) we're reJITting pitched code then we don't want to create
    // yet another DJI.
    //
    // @todo perf: any way to avoid this GetJitInfo in the common,
    // non-pitching case? We've got the function
    // Debugger::PitchCode. We could set a global in that, then only
    // do this duplicate checking if that global is true. For a normal
    // JIT run, this part should never happen.
    //
    DebuggerJitInfo * prevJi;
    prevJi = GetJitInfo(fd, NULL);
    
#ifdef LOGGING      
    if (prevJi != NULL )
        LOG((LF_CORDB,LL_INFO10000,"De::JITBeg: Got DJI 0x%x, "
            "from 0x%x to 0x%x\n",prevJi, prevJi->m_addrOfCode, 
            prevJi->m_addrOfCode+prevJi->m_sizeOfCode));
#endif //LOGGING

    // If this is a re-JIT, then bail now before fresh or EnC stuff
    // If this is a JIT that has been begun by the profiler, then
    // don't create another one...
    if (!((prevJi != NULL) && ((prevJi->m_codePitched == true) ||
                               (prevJi->m_jitComplete == false))))
        CreateJitInfo(fd);

Exit:    
    STOP_DBG_PERF();
}   

/******************************************************************************
// @mfunc void |Debugger|JITComplete | JITComplete is called by 
// the jit interface when the JIT completes, either if debug info needs
// to be tracked for the method, or if a debugger is attached. If newAddress is 
// NULL then the JIT failed.  Remember that this gets called before
// the start address of the MethodDesc gets set, and so methods like
// GetFunctionAddress & GetFunctionSize won't work.
// @parm MethodDesc*|fd|MethodDesc of the code that's been JITted
// @parm BYTE*|newAddress|The address of that the method begins at
// @Todo If we're passed 0 for the 2nd two params, the jit has been
//      cancelled & should be undone.
 ******************************************************************************/
void Debugger::JITComplete(MethodDesc* fd, BYTE* newAddress, SIZE_T sizeOfCode, bool trackJITInfo)
{
    START_DBG_PERF();
    
    _ASSERTE(trackJITInfo || CORDebuggerAttached());
    if (CORDBUnrecoverableError(this))
        goto Exit;

    LOG((LF_CORDB, LL_INFO100000,
         "D::JitComplete: address of methodDesc 0x%x (%s::%s)"
         "jitted code is 0x%08x, Size::0x%x \n",fd,
         fd->m_pszDebugClassName,fd->m_pszDebugMethodName,
         newAddress, sizeOfCode));

    if (!trackJITInfo)
    {
        _ASSERTE(CORDebuggerAttached());
        HRESULT hr = MapAndBindFunctionPatches(NULL, fd, newAddress);
        _ASSERTE(SUCCEEDED(hr));
        goto Exit;
    }

    DebuggerJitInfo *ji;
    ji = GetJitInfo(fd,NULL);
    
    if (newAddress == 0 && sizeOfCode == 0)
    {
        // JIT is actually telling us that the JIT aborted -
        // toss the DJI
        _ASSERTE(ji != NULL); //must be something there.
        _ASSERTE(ji->m_jitComplete == false); //must have stopped 1/2 way through
        
        DeleteHeadOfList( fd );
        LOG((LF_CORDB, LL_INFO100000, "The JIT actually gave us"
            "an error result, so the version that hasn't been"
            " JITted properly has been ditched\n"));
        goto Exit;
    }

    if (ji == NULL)
    {
        // setBoundaries may run out of mem & eliminated the DJI
        LOG((LF_CORDB,LL_INFO10000,"De::JitCo:Got NULL Ptr - out of mem?\n"));
        goto Exit; 
    }
    else
    {
        ji->m_addrOfCode = PTR_TO_CORDB_ADDRESS(newAddress);
        ji->m_sizeOfCode = sizeOfCode;
        ji->m_jitComplete = true;
        ji->m_codePitched = false;
        
        LOG((LF_CORDB,LL_INFO10000,"De::JITCo:Got DJI 0x%x,"
            "from 0x%x to 0x%xvarCount=%d  seqCount=%d\n",ji,
            (ULONG)ji->m_addrOfCode, 
            (ULONG)ji->m_addrOfCode+(ULONG)ji->m_sizeOfCode,
            ji->m_varNativeInfoCount,
            ji->m_sequenceMapCount));
        
        HRESULT hr = S_OK;

        // Don't need to do this unless a debugger is attached.
        if (CORDebuggerAttached())
        {
            hr = MapAndBindFunctionPatches(ji, fd, newAddress);
            _ASSERTE(SUCCEEDED(hr));
        }

        if (SUCCEEDED(hr = CheckInitJitInfoTable()))
        {
            _ASSERTE(ji->m_fd != NULL);
            if (!m_pJitInfos->EnCRemapSentForThisVersion(ji->m_fd->GetModule(),
                                                         ji->m_fd->GetMemberDef(),
                                                         ji->m_nVersion))
            {
                LOG((LF_CORDB,LL_INFO10000,"De::JITCo: Haven't yet remapped this,"
                    "so go ahead & send the event\n"));
                LockAndSendEnCRemapEvent(fd, TRUE);
            }
        }
        else
            _ASSERTE(!"Error allocating jit info table");
    }

Exit:
    STOP_DBG_PERF();
}

/******************************************************************************
// @mfunc void|Debugger|FunctionStubInitialized|This is called by the JIT
//  into the debugger to tell the Debuger that the function stub has been
//  initialized.  This is called shortly after Debugger::JITComplete.
//  We use this opportunity to invoke BindFunctionPatches, which will 
//  ensure that any patches for this method bound by DebuggerFunctionKey
//  are rebound to an actual address.
//  Remember that this gets called before
//  the start address of the MethodDesc gets set, and so methods like
//  GetFunctionAddress & GetFunctionSize won't work.
// @parm MethodDesc *|fd|MethodDesc of the method that's been initialized
// @parm const BYTE *|code|Where the method was JITted to.
// @todo Remove this function, as it no longer server a purpose (it used
//      to server a purpose when there was interpreted code).
 ******************************************************************************/
void Debugger::FunctionStubInitialized(MethodDesc *fd, const BYTE *code)
{
    // Remember that there may not be a DJI for this method, if
    // earlier errors prevented us from allocating one.

    // Remember also that if we grab a lock here, we'll have to disable
    // cooperative GC beforehand (see JITBeginnging, JITComplete,etc)
}

/******************************************************************************
//@mfunc void|Debugger|PitchCode| This is called when the 
// FJIT tosses some code out - we should do all the work
// we need to in order to prepare the function to have
// it's native code removed
// @parm MethodDesc *|fd|MethodDesc of the method to be pitched
 ******************************************************************************/
void Debugger::PitchCode( MethodDesc *fd, const BYTE *pbAddr )
{
    _ASSERTE( fd != NULL );

    LOG((LF_CORDB,LL_INFO10000,"D:PC: Pitching method %s::%s 0x%x\n", 
        fd->m_pszDebugClassName, fd->m_pszDebugMethodName,fd ));
    
    //ask for the JitInfo no matter what it's state
    DebuggerJitInfo *ji = GetJitInfo( fd, pbAddr );
    
    if ( ji != NULL )
    {
        LOG((LF_CORDB,LL_INFO10000,"De::PiCo: For addr 0x%x, got "
            "DJI 0x%x, from 0x%x, size:0x%x\n",pbAddr, ji, 
            ji->m_addrOfCode, ji->m_sizeOfCode));
            
        DebuggerController::UnbindFunctionPatches( fd );
        ji->m_jitComplete = false;
        ji->m_codePitched = true;
        ji->m_addrOfCode = (CORDB_ADDRESS)NULL;
        ji->m_sizeOfCode = 0;
    }
}

/******************************************************************************
// @mfunc void|Debugger|MovedCode|This is called when the 
// code has been moved.  Currently, code that the FJIT doesn't
// pitch, it moves to another spot, and then tells us about here.
// This method should be called after the code has been copied
// over, but while the original code is still present, so we can
// change the original copy (removing patches & such).
// Note that since the code has already been moved, we need to 
// save the opcodes for the rebind.
// @parm MethodDesc *|fd|MethodDesc of the method to be pitched
// @parm const BYTE *|pbNewAddress|Address that it's being moved to
 ******************************************************************************/
void Debugger::MovedCode( MethodDesc *fd, const BYTE *pbOldAddress,
    const BYTE *pbNewAddress)
{
    _ASSERTE( fd != NULL );
    _ASSERTE( pbOldAddress != NULL );
    _ASSERTE( pbNewAddress != NULL );

    LOG((LF_CORDB, LL_INFO1000, "De::MoCo: %s::%s moved from 0x%8x to 0x%8x\n",
        fd->m_pszDebugClassName, fd->m_pszDebugMethodName,
        pbOldAddress, pbNewAddress ));

    DebuggerJitInfo *ji = GetJitInfo(fd, pbOldAddress);
    if( ji != NULL )
    {
        LOG((LF_CORDB,LL_INFO10000,"De::MoCo: For code 0x%x, got DJI 0x%x, "
            "from 0x%x to 0x%x\n", pbOldAddress, ji, ji->m_addrOfCode, 
            ji->m_addrOfCode+ji->m_sizeOfCode));

        ji->m_addrOfCode = PTR_TO_CORDB_ADDRESS(pbNewAddress);
    }
    
    //@todo EnC PITCH EnCMULTI This will have to change for multiple 
    //  versions, as we
    //  don't want to have unbind all patches on all methods.
    DebuggerController::UnbindFunctionPatches( fd, true);
    DebuggerController::BindFunctionPatches(fd, pbNewAddress);
}

/******************************************************************************
 *
 ******************************************************************************/
SIZE_T Debugger::GetArgCount(MethodDesc *fd,BOOL *fVarArg)
{
    // Create a MetaSig for the given method's sig. (Eaiser than
    // picking the sig apart ourselves.)
    PCCOR_SIGNATURE pCallSig = fd->GetSig();

    MetaSig *msig = new (interopsafe) MetaSig(pCallSig, g_pEEInterface->MethodDescGetModule(fd), MetaSig::sigMember);

    // Get the arg count.
    UINT32 NumArguments = msig->NumFixedArgs();

    // Account for the 'this' argument.
    if (!(g_pEEInterface->MethodDescIsStatic(fd)))
        NumArguments++;

    // Is this a VarArg's function?
    if (msig->IsVarArg() && fVarArg != NULL)
    {
        NumArguments++;
        *fVarArg = true;
    }
    
    // Destroy the MetaSig now that we're done using it.
    DeleteInteropSafe(msig);

    return NumArguments;
}

/******************************************************************************
    @mfunc DebuggerJitInfo * | Debugger | GetJitInfo | GetJitInfo
    will return a pointer to a <t DebuggerJitInfo>.  If the DJI
    doesn't exist, or it does exist, but the method has actually 
    been pitched (and the caller wants pitched methods filtered out),
    then we'll return NULL.

    @parm MethodDesc*|fd|MethodDesc for the method we're interested in.
    @parm const BYTE *|pbAddr|Address within the code, to indicate which
            version we want.  If this is NULL, then we want the
            head of the <t DebuggerJitInfo> list, whether it's been
            JITted or not.
 ******************************************************************************/
DebuggerJitInfo *Debugger::GetJitInfo(MethodDesc *fd, 
                                      const BYTE *pbAddr,
                                      bool fByVersion)
{
    DebuggerJitInfo *info = NULL;
    HRESULT hr = S_OK;

    LockJITInfoMutex();

//    CHECK_DJI_TABLE_DEBUGGER;
    
    if (m_pJitInfos != NULL)
        info = m_pJitInfos->GetJitInfo(fd);

    if (info == NULL)
    {
        if (fd != NULL)
        {
            if (g_pEEInterface->HasPrejittedCode(fd))
            {
                if (g_pEEInterface->GetFunctionAddress(fd) != NULL &&
                    g_pEEInterface->GetFunctionSize(fd) != 0)
                {
                    DebuggerJitInfo *newInfo = NULL;
                    
                    ULONG32 cMap;
                    ICorDebugInfo::OffsetMapping *pMap;

                    if (SUCCEEDED(g_pEEInterface->GetPrecompiledBoundaries(
                            fd, &cMap, &pMap)))
                    {                        
                        newInfo = CreateJitInfo(fd);
                        _ASSERTE(newInfo != NULL);
                        
                        if (newInfo != NULL)
                        {
                            hr = newInfo->SetBoundaries(cMap, pMap);
                        
                            if (!SUCCEEDED(hr))
                            {
                                DeleteHeadOfList(fd);
                                UnlockJITInfoMutex();
                                return NULL;
                            }
                        }
                        else
                        {
                            UnlockJITInfoMutex();
                            return NULL;
                        }
                    }
                    else
                    {
                        LOG((LF_CORDB,LL_INFO1000, "D:GJI: precompiled/"
                            "prejitted boundaries for %s::%s don't exist -"
                            "perhaps b/c we're not using a prejitted image\n",
                            fd->m_pszDebugClassName, fd->m_pszDebugMethodName));
                        UnlockJITInfoMutex();
                        return NULL;
                    }

                    ULONG32 cVars;
                    ICorDebugInfo::NativeVarInfo *pVars;

                    // This information may be ommitted if there are no variables, so
                    // don't remove it if this fails:
                    if (SUCCEEDED(g_pEEInterface->GetPrecompiledVars(fd,
                                                                     &cVars,
                                                                     &pVars)))
                    {
                        _ASSERTE(newInfo != NULL);
                        newInfo->SetVars(cVars, pVars, false);
                    }

                    _ASSERTE((BYTE*) g_pEEInterface->GetFunctionAddress(fd) != NULL);
                    _ASSERTE(g_pEEInterface->GetFunctionSize(fd) != 0);
                    JITComplete(fd, (BYTE*) g_pEEInterface->GetFunctionAddress(fd), 
                            g_pEEInterface->GetFunctionSize(fd), true);

                    info = newInfo;
        
//                    CHECK_DJI_TABLE_DEBUGGER;
                }
            }
#ifdef _DEBUG
            else
            {
                LOG((LF_CORDB, LL_INFO1000, "D:GJI: Prejitted code %s::%s "
                    "don't exist - perhaps b/c we're not using a prejitted image 2\n",
                    fd->m_pszDebugClassName, fd->m_pszDebugMethodName));
            }
#endif //_DEBUG

        }
    }

    if (fByVersion)
        info = info->GetJitInfoByVersionNumber((SIZE_T)pbAddr, GetVersionNumber(fd));
    else
    {
        if (pbAddr != NULL )
        {
            info = info->GetJitInfoByAddress(pbAddr);
            if (info == NULL) //may have been given address of a thunk
            {
                LOG((LF_CORDB,LL_INFO1000,"Couldn't find a DJI by address 0x%x, "
                    "so it might be a stub or thunk\n", pbAddr));
                TraceDestination trace;

                g_pEEInterface->TraceStub(pbAddr, &trace);
                if ((trace.type == TRACE_MANAGED) &&
                    (pbAddr != trace.address))
                {
                    LOG((LF_CORDB,LL_INFO1000,"Address thru thunk"
                        ": 0x%x\n", trace.address));
                    info = g_pDebugger->GetJitInfo(fd,trace.address);
                }
#ifdef LOGGING  
                else
                {
                    _ASSERTE( trace.type != TRACE_UNJITTED_METHOD ||
                            fd == (MethodDesc*)trace.address);
                    LOG((LF_CORDB,LL_INFO1000,"Address not thunked - "
                        "must be to unJITted method, or normal managed "
                        "method lacking a DJI!\n"));
                }
#endif //LOGGING
            }
            if (info ==NULL && 
                ( g_pEEInterface->GetEEState() &
                    EEDebugInterface::EE_STATE_CODE_PITCHING))
            {
                // Couldn't find info by address, but since ENC &&
                // pitching don't work together, we know that we'll
                // have only one version anyways.
                if (m_pJitInfos != NULL)
                    info = m_pJitInfos->GetJitInfo(fd);

                LOG((LF_CORDB, LL_INFO1000, "*** *** DJI not found, but we're "
                    "pitching, so use 0x%x as DJI\n", info ));

                _ASSERTE(info == NULL || fd == info->m_fd);
            }
        }
    }
    
    if (info != NULL)
    {
        info->SortMap();
        LOG((LF_CORDB,LL_INFO10000, "D::GJI: found dji 0x%x for %s::%s "
            "(start,size):(0x%x,0x%x) nVer:0x%x\n",
            info, info->m_fd->m_pszDebugClassName,
            info->m_fd->m_pszDebugMethodName,
            (ULONG)info->m_addrOfCode, 
            (ULONG)info->m_sizeOfCode, 
            (ULONG)info->m_nVersion));
    }   
    UnlockJITInfoMutex();

    return info;
}

/******************************************************************************
 * GetILToNativeMapping returns a map from IL offsets to native
 * offsets for this code. An array of COR_PROF_IL_TO_NATIVE_MAP
 * structs will be returned, and some of the ilOffsets in this array
 * may be the values specified in CorDebugIlToNativeMappingTypes.
 ******************************************************************************/
HRESULT Debugger::GetILToNativeMapping(MethodDesc *pMD, ULONG32 cMap,
                                       ULONG32 *pcMap, COR_DEBUG_IL_TO_NATIVE_MAP map[])
{
    // Get the JIT info by functionId
    DebuggerJitInfo *pDJI = GetJitInfo(pMD, NULL);

    // Dunno what went wrong
    if (pDJI == NULL)
        return (E_FAIL);

    // If they gave us space to copy into...
    if (map != NULL)
    {
        // Only copy as much as either they gave us or we have to copy.
        SIZE_T cpyCount = min(cMap, pDJI->m_sequenceMapCount);

        // Read the map right out of the Left Side.
        if (cpyCount > 0)
            ExportILToNativeMap(cpyCount,
                        map,
                        pDJI->m_sequenceMap,
                        pDJI->m_sizeOfCode);
    }
    
    // Return the true count of entries
    if (pcMap)
        *pcMap = pDJI->m_sequenceMapCount;
    
    return (S_OK);
}




/******************************************************************************
 *
 ******************************************************************************/
DebuggerJitInfo::~DebuggerJitInfo()
{
    TRACE_FREE(m_sequenceMap);
    if (m_sequenceMap != NULL)
    {
        DeleteInteropSafe(((BYTE *)m_sequenceMap));
    }

    TRACE_FREE(m_varNativeInfo);
    if (m_varNativeInfo != NULL && m_varNeedsDelete)
    {
        DeleteInteropSafe(m_varNativeInfo);
    }

    TRACE_FREE(m_OldILToNewIL);
    if (m_OldILToNewIL != NULL)
    {
        DeleteInteropSafe(m_OldILToNewIL);
    }

    if (m_rgInstrumentedILMap != NULL)
        CoTaskMemFree(m_rgInstrumentedILMap);

    if (m_pDcq != NULL)
    {
        DeleteInteropSafe(m_pDcq);
    }

    LOG((LF_CORDB,LL_EVERYTHING, "DJI::~DJI : deleted at 0x%x\n", this));
}

/******************************************************************************
 *
 ******************************************************************************/
void DebuggerJitInfo::SortMap()
{
    //
    // Note that this routine must be called inside of a mutex.
    //  
    if (!m_sequenceMapSorted)
    {
        if (m_sequenceMap != NULL)
        {
            //
            // Sort by native offset.
            //

            MapSortNative nsort(m_sequenceMap, m_sequenceMapCount);

            nsort.Sort();

            //
            // Now, fill in the end ranges.
            //

            DebuggerILToNativeMap *m = m_sequenceMap;
            DebuggerILToNativeMap *mEnd = m + m_sequenceMapCount;

            while (m < mEnd)
            {
                m->nativeEndOffset = (m+1)->nativeStartOffset;
                m++;
            }

            //
            // Now, sort by il offset.
            //

            MapSortIL isort(m_sequenceMap, m_sequenceMapCount);

            isort.Sort();
        }

        m_sequenceMapSorted = true;
    }
}

/******************************************************************************
 *
 ******************************************************************************/
void * Debugger::allocateArray(SIZE_T cBytes)
{
    START_DBG_PERF();
    void *ret;
    
    if (cBytes > 0)
        ret = (void *) new (interopsafe) byte [cBytes];
    else
        ret = NULL;
    
    STOP_DBG_PERF();

    return ret;
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::freeArray(void *array)
{
    START_DBG_PERF();

    if (array != NULL)
    {
        DeleteInteropSafe(array);
    }

    STOP_DBG_PERF();
}

/******************************************************************************
 *
 ******************************************************************************/
static LONG _getBoundariesFilter(LPEXCEPTION_POINTERS ep)
{
    LOG((LF_CORDB, LL_INFO10,
         "Unhandled exception in Debugger::getBoundaries\n"));

    static bool envChecked = false;
    static bool envFaultOK = false;

    if (!envChecked)
    {
        char buf[32];
        DWORD len = GetEnvironmentVariableA("CORDBG_PDB_FAULTS_ALLOWED",
                                            buf, sizeof(buf));
        _ASSERTE(len < sizeof(buf));
            
        if (len > 0)
            envFaultOK = true;
        
        envChecked = true;
    }

    if (envFaultOK)
        return EXCEPTION_EXECUTE_HANDLER;
    else
        return EXCEPTION_CONTINUE_SEARCH;
}


/******************************************************************************
// Use an ISymUnmanagedReader to get method sequence points.
 ******************************************************************************/
void Debugger::getBoundaries(CORINFO_METHOD_HANDLE ftn,
                             unsigned int *cILOffsets,
                             DWORD **pILOffsets,
                             ICorDebugInfo::BoundaryTypes *implicitBoundaries)
{
    START_DBG_PERF();

	*cILOffsets = 0;
	*pILOffsets = NULL;
	*implicitBoundaries = NO_BOUNDARIES;

    // If there has been an unrecoverable Left Side error, then we
    // just pretend that there are no boundaries.
    if (CORDBUnrecoverableError(this))
    {
        STOP_DBG_PERF();
        return;
    }

    MethodDesc *md = (MethodDesc*)ftn;

    // If JIT optimizations are allowed for the module this function
    // lives in, then don't grab specific boundaries from the symbol
    // store since any boundaries we give the JIT will be pretty much
    // ignored anyway.
    bool allowJITOpts =
        CORDebuggerAllowJITOpts(md->GetModule()->GetDebuggerInfoBits());
    
    if (allowJITOpts)
    {
        *implicitBoundaries  = BoundaryTypes(STACK_EMPTY_BOUNDARIES |
                                             CALL_SITE_BOUNDARIES);
        return;
    }

    // Grab the JIT info struct for this method.
    DebuggerJitInfo *ji = GetJitInfo(md, NULL);

    // This may be called before JITBeginning in a compilation domain
    if (ji == NULL)
        ji = CreateJitInfo(md);

    _ASSERTE(ji != NULL); // to pitch, must first jit ==> it must exist

    LOG((LF_CORDB,LL_INFO10000,"De::NGB: Got DJI 0x%x\n",ji));

    if (ji != NULL)
    {
        // @HACK HACK: temp hack to help us get around problems with
        // the PDB reader. We wrap all of this in an exception handler
        // and provide an option to ignore faults in here.
        __try
        {
            // Note: we need to make sure to enable preemptive GC here just in case we block in the symbol reader.
            bool disabled = g_pEEInterface->IsPreemptiveGCDisabled();

            if (disabled)
                g_pEEInterface->EnablePreemptiveGC();

            Module *pModule = ji->m_fd->GetModule();
            _ASSERTE(pModule != NULL);

            START_SYM_CREATE_PERF();
            ISymUnmanagedReader *pReader = pModule->GetISymUnmanagedReader();
            STOP_SYM_CREATE_PERF();
            
            // If we got a reader, use it.
            if (pReader != NULL)
            {
                // Grab the sym reader's method.
                ISymUnmanagedMethod *pISymMethod;

                START_SYM_PERF();
                
                HRESULT hr = pReader->GetMethod(ji->m_fd->GetMemberDef(),
                                                &pISymMethod);

                ULONG32 n = 0;
                
                if (SUCCEEDED(hr))
                {
                    // Get the count of sequence points.
                    hr = pISymMethod->GetSequencePointCount(&n);
                    _ASSERTE(SUCCEEDED(hr));

                    STOP_SYM_PERF();
                    
                    LOG((LF_CORDB, LL_INFO1000000,
                         "D::NGB: Reader seq pt count is %d\n", n));
                    
                    ULONG32 *p;

                    if (n > 0 
                        && (p = new (interopsafe) ULONG32 [n]) != NULL)
                    {
                        ULONG32 dummy;

                        START_SYM_PERF();
                        hr = pISymMethod->GetSequencePoints(n, &dummy,
                                                            p, NULL, NULL, NULL,
                                                            NULL, NULL);
                        STOP_SYM_PERF();
                        _ASSERTE(SUCCEEDED(hr));
                        _ASSERTE(dummy == n);
                                                            
                        *pILOffsets = (DWORD*)p;

                        // Translate the IL offets based on an
                        // instrumented IL map if one exists.
                        if (ji->m_cInstrumentedILMap > 0)
                        {
                            for (SIZE_T i = 0; i < n; i++)
                            {
                                long origOffset = *p;
                                
                                *p = ji->TranslateToInstIL(
                                                      origOffset,
                                                      bOriginalToInstrumented);

                                LOG((LF_CORDB, LL_INFO1000000,
                                     "D::NGB: 0x%04x (Real IL:0x%x)\n",
                                     origOffset, *p));

                                p++;
                            }
                        }
#ifdef LOGGING
                        else
                        {
                            for (SIZE_T i = 0; i < n; i++)
                            {
                                LOG((LF_CORDB, LL_INFO1000000,
                                     "D::NGB: 0x%04x \n", *p));
                                p++;
                            }
                        }
#endif                    
                    }
                    else
                        *pILOffsets = NULL;

                    pISymMethod->Release();
                }
                else
                {
                    STOP_SYM_PERF();
                    
                    *pILOffsets = NULL;

                    LOG((LF_CORDB, LL_INFO10000,
                         "De::NGB: failed to find method 0x%x in sym reader.\n",
                         ji->m_fd->GetMemberDef()));
                }

                *implicitBoundaries = CALL_SITE_BOUNDARIES;
                *cILOffsets = n;
            }
            else
            {
                LOG((LF_CORDB, LL_INFO1000000, "D::NGB: no reader.\n"));
                *implicitBoundaries  = BoundaryTypes(STACK_EMPTY_BOUNDARIES | CALL_SITE_BOUNDARIES);
            }

            // Re-disable preemptive GC if we enabled it above.
            if (disabled)
                g_pEEInterface->DisablePreemptiveGC();
        }
        __except(_getBoundariesFilter(GetExceptionInformation()))
        {
            LOG((LF_CORDB, LL_INFO10000,
                 "D::NGB: ****** exception trying to get boundaries!\n"));

            // Pretend there are no sequence points on an exception
            // from the symbol store, and just take stack empties.
            *implicitBoundaries  = BoundaryTypes(STACK_EMPTY_BOUNDARIES | CALL_SITE_BOUNDARIES);
            *cILOffsets = 0;
        }
    }
    
    LOG((LF_CORDB, LL_INFO1000000, "D::NGB: cILOffsets=%d\n", *cILOffsets));
    STOP_DBG_PERF();
}

/******************************************************************************
// @mfunc void | Debugger | setBoundaries | Called by JIT to tell the
// debugger what the IL to native map (the sequence map) is.  The
// information is stored in an array of <t DebuggerILToNativeMap>
// structures, which is stored in the <t DebuggerJitInfo> obtained
// from the <t DebuggerJitInfoTable>.  The <t DebuggerJitInfo> is placed
// there by the call to JitBeginning.
// @xref Debugger::getBoundaries, Debugger::JitBeginning, Debugger::JitComplete
 ******************************************************************************/
void Debugger::setBoundaries(CORINFO_METHOD_HANDLE ftn, ULONG32 cMap,
                             OffsetMapping *pMap)
{
    START_DBG_PERF();
    
    if (CORDBUnrecoverableError(this))
        goto Exit;

    LOG((LF_CORDB,LL_INFO10000,"D:sB:%s::%s MethodDef:0x%x\n\n",
        ((MethodDesc*)ftn)->m_pszDebugClassName, 
        ((MethodDesc*)ftn)->m_pszDebugMethodName,
        ((MethodDesc*)ftn)->GetMemberDef()));
    
    DebuggerJitInfo *ji;
    ji = GetJitInfo((MethodDesc*)ftn, NULL);
    LOG((LF_CORDB,LL_INFO10000,"De::sB: Got DJI 0x%x\n",ji));

    if (ji != NULL && ji->m_codePitched == false)
    {
        if (FAILED(ji->SetBoundaries(cMap, pMap)))
        {
            DeleteHeadOfList((MethodDesc*)ftn);
        }
    }

    if (cMap)
    {
        DeleteInteropSafe(pMap);
    }

Exit:
    STOP_DBG_PERF();
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::getVars(CORINFO_METHOD_HANDLE ftn, ULONG32 *cVars, ILVarInfo **vars, 
                       bool *extendOthers)
{
    START_DBG_PERF();
 
        // At worst return no information
    *cVars = 0;
    *vars = NULL;
    *extendOthers = false;
    
    if (CORDBUnrecoverableError(this))
        goto Exit;

    //
    // @todo perf: note, we don't actually use the DJI below, so
    // getting it (and lazily creating it) is a waste of time for this
    // function. Need to evaluate the effect of not creating it on
    // setVars below.
    //
    DebuggerJitInfo *ji;
    ji = GetJitInfo((MethodDesc*)ftn,NULL);

    // This may be called before JITBeginning in a compilation domain
    if (ji == NULL)
        ji = CreateJitInfo((MethodDesc*)ftn);

    _ASSERTE( ji != NULL ); // to pitch, must first jit ==> it must exist
    LOG((LF_CORDB,LL_INFO10000,"De::gV: Got DJI 0x%x\n",ji));

    if (ji != NULL)
    {
        // Just tell the JIT to extend everything.
        *extendOthers = true;

        // But, is this a vararg function?
        BOOL fVarArg = false;
        int argCount = GetArgCount((MethodDesc*)ftn, &fVarArg);
        
        if (fVarArg)
        {
            // It is, so we need to tell the JIT to give us the
            // varags handle.
            ILVarInfo *p = new (interopsafe) ILVarInfo[1];

            if (p != NULL)
            {
                COR_ILMETHOD_DECODER header(g_pEEInterface->MethodDescGetILHeader((MethodDesc*)ftn));
                unsigned int ilCodeSize = header.CodeSize;
                    
                p->startOffset = 0;
                p->endOffset = ilCodeSize;
                p->varNumber = ICorDebugInfo::VARARGS_HANDLE;

                *cVars = 1;
                *vars = p;
            }
        }
    }

    LOG((LF_CORDB, LL_INFO1000000, "D::gV: cVars=%d, extendOthers=%d\n",
         *cVars, *extendOthers));

Exit:
    STOP_DBG_PERF();
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::setVars(CORINFO_METHOD_HANDLE ftn, ULONG32 cVars, NativeVarInfo *vars)
{
    START_DBG_PERF();
    
    if (CORDBUnrecoverableError(this))
        goto Exit;

    _ASSERTE((cVars == 0) == (vars == NULL));

    DebuggerJitInfo *ji;
    ji = GetJitInfo((MethodDesc*)ftn, NULL);
    
    if ( ji == NULL )
    {
        // setBoundaries may run out of mem & eliminated the DJI
        LOG((LF_CORDB,LL_INFO10000,"De::sV:Got NULL Ptr - out of mem?\n"));
        goto Exit; 
    }

    LOG((LF_CORDB,LL_INFO10000,"De::sV: Got DJI 0x%x\n",ji));

    if (ji != NULL && ji->m_codePitched == false)
    {
        ji->SetVars(cVars, vars, true);
    }
    else
    {
        if (cVars)
        {
            DeleteInteropSafe(vars);
        }
    }

Exit:
    STOP_DBG_PERF();
}

// We want to keep the 'worst' HRESULT - if one has failed (..._E_...) & the
// other hasn't, take the failing one.  If they've both/neither failed, then
// it doesn't matter which we take.
// Note that this macro favors retaining the first argument
#define WORST_HR(hr1,hr2) (FAILED(hr1)?hr1:hr2)
/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::SetIP( bool fCanSetIPOnly, Thread *thread,Module *module, 
                         mdMethodDef mdMeth, DebuggerJitInfo* dji, 
                         SIZE_T offsetTo, BOOL fIsIL, void *firstExceptionHandler)
{
#ifdef _DEBUG
	static ConfigDWORD breakOnSetIP(L"DbgBreakOnSetIP", 0);
	if (breakOnSetIP.val()) _ASSERTE(!"DbgBreakOnSetIP");
#endif

#ifdef _X86_
    _ASSERTE( thread != NULL);
    _ASSERTE( module != NULL);
    _ASSERTE( mdMeth != mdMethodDefNil);

    HRESULT hr = S_OK;
    HRESULT hrAdvise = S_OK;
    
    MethodDesc *pFD = NULL;
    DWORD offIL;
    CorDebugMappingResult map;
    DWORD whichIgnore;
    
    ControllerStackInfo csi;
    CONTEXT  Ctx;
    CONTEXT  realCtx;           // in case actual context is needed
    
    BOOL exact;
    SIZE_T offNat;
    BOOL fSetIPOk = false;

    BYTE    *pbDest = NULL;
    BYTE    *pbBase = NULL;
    CONTEXT *pCtx   = NULL;
    DWORD    dwSize = 0;
    DWORD *rgVal1 = NULL;
    DWORD *rgVal2 = NULL;
    BYTE **pVCs   = NULL;
    
    LOG((LF_CORDB, LL_INFO1000, "D::SIP: In SetIP ==> fCanSetIPOnly:0x%x <==!\n", fCanSetIPOnly));  

    pCtx = g_pEEInterface->GetThreadFilterContext(thread);

    _ASSERTE(!(g_pEEInterface->GetThreadFilterContext(thread) && ISREDIRECTEDTHREAD(thread)));

    if (pCtx == NULL && ISREDIRECTEDTHREAD(thread))
    {
        RedirectedThreadFrame *pFrame = (RedirectedThreadFrame *) thread->GetFrame();
        pCtx = pFrame->GetContext();
    }

    if (pCtx == NULL)
    {
        realCtx.ContextFlags = CONTEXT_CONTROL;

        if (!GetThreadContext(thread->GetThreadHandle(), &realCtx))
            _ASSERTE(!"GetThreadContext failed.");

        pCtx = &realCtx;
    }

    // Implicit Caveat: We need to be the active frame.
    csi.GetStackInfo(thread, NULL, &Ctx, false);

    pFD = g_pEEInterface->LookupMethodDescFromToken(
        module,mdMeth);
    _ASSERTE( pFD != NULL );
    _ASSERTE( dji == NULL || dji->m_fd == pFD);

    if (dji == NULL )
    {
        dji = GetJitInfo( pFD, NULL );
        LOG((LF_CORDB, LL_INFO1000, "D::SIP:Not given token "
                "from right side - GJI returned 0x%x!\n", dji));
    }

    if (dji == NULL) //we don't have info about this method - attach scenario
    {
        if (fIsIL)
        {
            LOG((LF_CORDB, LL_INFO1000, "D::SIP:Couldn't obtain version info -"
            "SetIP by IL offset can't work\n"));
            hrAdvise = WORST_HR(hrAdvise, CORDBG_E_SET_IP_IMPOSSIBLE);
            goto LExit;
        }

        LOG((LF_CORDB, LL_INFO1000, "D::SIP:Couldn't obtain version info - "
                "SetIP by native offset proceeding via GetFunctionAddress\n"));
                
        pbBase = (BYTE*)g_pEEInterface->GetFunctionAddress(pFD);
        if (pbBase == NULL)
        {
            LOG((LF_CORDB, LL_INFO1000, "D::SIP:GetFnxAddr failed!\n"));
            hrAdvise = WORST_HR(hrAdvise, CORDBG_E_SET_IP_IMPOSSIBLE);
            goto LExit;
        }
        dwSize = (DWORD)g_pEEInterface->GetFunctionSize(pFD);
        
        offNat = offsetTo;
        pbDest = pbBase + offsetTo;
    }
    else
    {
        LOG((LF_CORDB, LL_INFO1000, "D::SIP:Got version info fine\n"));

        // Caveat: we need to start from a sequence point
        offIL = dji->MapNativeOffsetToIL(csi.m_activeFrame.relOffset,
                                         &map, &whichIgnore);
        if ( !(map & MAPPING_EXACT) )
        {
            LOG((LF_CORDB, LL_INFO1000, "D::SIP:Starting native offset is bad!\n"));
            hrAdvise = WORST_HR(hrAdvise, CORDBG_S_BAD_START_SEQUENCE_POINT);
        }
        else
        {   // exact IL mapping

            if (!(dji->GetSrcTypeFromILOffset(offIL) & ICorDebugInfo::STACK_EMPTY))
            {
                LOG((LF_CORDB, LL_INFO1000, "D::SIP:Starting offset isn't stack empty!\n"));
                hrAdvise = WORST_HR(hrAdvise, CORDBG_S_BAD_START_SEQUENCE_POINT);
            }
        }

        // Caveat: we need to go to a sequence point
        if (fIsIL )
        {
            offNat = dji->MapILOffsetToNative(offsetTo, &exact);
            if (!exact)
            {
                LOG((LF_CORDB, LL_INFO1000, "D::SIP:Dest (via IL offset) is bad!\n"));
                hrAdvise = WORST_HR(hrAdvise, CORDBG_S_BAD_END_SEQUENCE_POINT);
            }
        }
        else
        {
            offNat = offsetTo;
            LOG((LF_CORDB, LL_INFO1000, "D::SIP:Dest of 0x%x (via native "
                "offset) is fine!\n", offNat));
        }

        CorDebugMappingResult mapping;
        DWORD which;
        offsetTo = dji->MapNativeOffsetToIL(offNat, &mapping, &which);

        // We only want to perhaps return CORDBG_S_BAD_END_SEQUENCE_POINT if
        // we're not already returning CORDBG_S_BAD_START_SEQUENCE_POINT.
        if (hr != CORDBG_S_BAD_START_SEQUENCE_POINT && 
            (mapping != MAPPING_EXACT ||
             !(dji->GetSrcTypeFromILOffset(offIL) & ICorDebugInfo::STACK_EMPTY)))
        {
            LOG((LF_CORDB, LL_INFO1000, "D::SIP:Ending offset isn't a sequence"
                                        " point, or not stack empty!\n"));
            hrAdvise = WORST_HR(hrAdvise, CORDBG_S_BAD_END_SEQUENCE_POINT);
        }

        // Caveat: can't setip if there's no code
        if (dji->m_codePitched) 
        {
            LOG((LF_CORDB, LL_INFO1000, "D::SIP:Code has been pitched!\n"));
            hrAdvise = WORST_HR(hrAdvise, CORDBG_E_CODE_NOT_AVAILABLE);
            if (fCanSetIPOnly)
                goto LExit;
        }

        pbBase = (BYTE*)dji->m_addrOfCode;
        dwSize = (DWORD)dji->m_sizeOfCode;
        pbDest = (BYTE*)dji->m_addrOfCode + offNat;
        LOG((LF_CORDB, LL_INFO1000, "D::SIP:Dest is 0x%x\n", pbDest));
    }

    if (!fCanSetIPOnly)
    {
        hr = ShuffleVariablesGet(dji, 
                                 csi.m_activeFrame.relOffset, 
                                 pCtx,
                                 &rgVal1,
                                 &rgVal2,
                                 &pVCs);
        if (FAILED(hr))
        {
            // This will only fail fatally, so exit.
            hrAdvise = WORST_HR(hrAdvise, hr);
            goto LExit;
        }
    }

    hr =g_pEEInterface->SetIPFromSrcToDst(thread,
                                          csi.m_activeFrame.pIJM,
                                          csi.m_activeFrame.MethodToken,
                                          pbBase,
                                          csi.m_activeFrame.relOffset, 
                                          offNat,
                                          fCanSetIPOnly,
                                          &(csi.m_activeFrame.registers),
                                          pCtx,
                                          dwSize,
                                          firstExceptionHandler,
                                          (void *)dji);
    // Get the return code, if any                                          
    if (hr != S_OK)
    {
        hrAdvise = WORST_HR(hrAdvise, hr);
        goto LExit;
    }

    // If we really want to do this, we'll have to put the
    // variables into their new locations.
    if (!fCanSetIPOnly && !FAILED(hrAdvise))
    {
        ShuffleVariablesSet(dji, 
                            offNat, 
                            pCtx,
                            &rgVal1,
                            &rgVal2,
                            pVCs);

        _ASSERTE(pbDest != NULL);
        
        pCtx->Eip = (DWORD)pbDest;

        if (pCtx == &realCtx)
        {
            if (!SetThreadContext(thread->GetThreadHandle(), &realCtx))
                _ASSERTE(!"SetThreadContext failed.");
        }

        LOG((LF_CORDB, LL_INFO1000, "D::SIP:Set Eip to be 0x%x\n", pCtx->Eip));
    }

    
LExit:
    if (rgVal1 != NULL)
        delete [] rgVal1;
        
    if (rgVal2 != NULL)
        delete [] rgVal2;
        
    LOG((LF_CORDB, LL_INFO1000, "D::SIP:Returning 0x%x\n", hr));
    return hrAdvise;
    
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - SetIP (Debugger.cpp)");
    return E_FAIL;
#endif // _X86_
}

#include "NativeVarAccessors.h"

/******************************************************************************
 *
 ******************************************************************************/

HRESULT Debugger::ShuffleVariablesGet(DebuggerJitInfo  *dji, 
                                      SIZE_T            offsetFrom, 
                                      CONTEXT          *pCtx,
                                      DWORD           **prgVal1,
                                      DWORD           **prgVal2,
                                      BYTE           ***prgpVCs)
{
    _ASSERTE(dji != NULL);
    _ASSERTE(pCtx != NULL);
    _ASSERTE(prgVal1 != NULL);
    _ASSERTE(prgVal2 != NULL);
    _ASSERTE(dji->m_sizeOfCode >= offsetFrom);

    HRESULT hr = S_OK;
    DWORD *rgVal1 = new DWORD[dji->m_varNativeInfoCount];

    if (rgVal1 == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }


    DWORD *rgVal2 = new DWORD[dji->m_varNativeInfoCount];
    
    if (rgVal2 == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }
    
    GetVariablesFromOffset(dji->m_fd,
                           dji->m_varNativeInfoCount, 
                           dji->m_varNativeInfo,
                           offsetFrom,
                           pCtx, 
                           rgVal1,
                           rgVal2,
                           prgpVCs);
                                  
LExit:
    if (!FAILED(hr))
    {
        (*prgVal1) = rgVal1;
        (*prgVal2) = rgVal2;
    }
    else
    {
        LOG((LF_CORDB, LL_INFO100, "D::SVG: something went wrong hr=0x%x!", hr));

        (*prgVal1) = NULL;
        (*prgVal2) = NULL;
        
        if (rgVal1 != NULL)
            delete rgVal1;
        
        if (rgVal2 != NULL)
            delete rgVal2;
    }

    return hr;
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::ShuffleVariablesSet(DebuggerJitInfo  *dji, 
                                   SIZE_T            offsetTo, 
                                   CONTEXT          *pCtx,
                                   DWORD           **prgVal1,
                                   DWORD           **prgVal2,
                                   BYTE            **rgpVCs)
{
    _ASSERTE(dji != NULL);
    _ASSERTE(pCtx != NULL);
    _ASSERTE(prgVal1 != NULL);
    _ASSERTE(prgVal2 != NULL);
    _ASSERTE(dji->m_sizeOfCode >= offsetTo);

    SetVariablesAtOffset(dji->m_fd,
                         dji->m_varNativeInfoCount, 
                         dji->m_varNativeInfo,
                         offsetTo,
                         pCtx, 
                         *prgVal1,
                         *prgVal2,
                         rgpVCs);

    delete (*prgVal1);
    (*prgVal1) = NULL;
    delete (*prgVal2);
    (*prgVal2) = NULL;
}

// Helper method pair to grab all, then set all, variables at a given
// point in a routine. 
// It's assumed that varNativeInfo[i] is the ith variable of the method
// Note that GetVariablesFromOffset and SetVariablesAtOffset are 
// very similar - modifying one will probably need to be reflected in the other...
HRESULT Debugger::GetVariablesFromOffset(MethodDesc       *pMD,
                               UINT                        varNativeInfoCount, 
                               ICorJitInfo::NativeVarInfo *varNativeInfo,
                               SIZE_T                      offsetFrom, 
                               CONTEXT                    *pCtx,
                               DWORD                      *rgVal1,
                               DWORD                      *rgVal2,
                               BYTE                     ***rgpVCs)
{
        // if there are no locals, well, we are done!
    if (varNativeInfoCount == 0)
	{
		*rgpVCs = NULL;
		return S_OK;
	}

    _ASSERTE(varNativeInfo != NULL);
    _ASSERTE(rgVal1 != NULL);
    _ASSERTE(rgVal2 != NULL);
    
    LOG((LF_CORDB, LL_INFO10000, "D::GVFO: %s::%s, infoCount:0x%x, from:0x%x\n",
        pMD->m_pszDebugClassName, pMD->m_pszDebugMethodName, varNativeInfoCount,
        offsetFrom));

    HRESULT hr = S_OK;
    BOOL  res;
    unsigned i;
    BYTE **rgpValueClasses = NULL;
    MetaSig *pLocals = NULL;
    ULONG cValueClasses = 0;
    CorElementType cet = ELEMENT_TYPE_END;
    
    memset( rgVal1, 0, sizeof(DWORD)*varNativeInfoCount);
    memset( rgVal2, 0, sizeof(DWORD)*varNativeInfoCount);

    COR_ILMETHOD_DECODER decoderOldIL(pMD->GetILHeader());
    mdSignature mdLocalSig = (decoderOldIL.LocalVarSigTok)?(decoderOldIL.LocalVarSigTok):
                        (mdSignatureNil);

    // If there isn't a local sig, then there can't be any VCs
    BOOL fVCs = (mdLocalSig != mdSignatureNil);
    if (fVCs)
    {
        ULONG cbSig;
        PCCOR_SIGNATURE sig = pMD->GetModule()->GetMDImport()->GetSigFromToken(mdLocalSig, &cbSig);

        pLocals = new MetaSig(sig, pMD->GetModule(), FALSE, MetaSig::sigLocalVars);
        while((cet = pLocals->NextArg()) != ELEMENT_TYPE_END)
        {
            if (cet == ELEMENT_TYPE_VALUETYPE)
                cValueClasses++;
        }
        pLocals->Reset();
        if (cValueClasses > 0)
        {
            LOG((LF_CORDB, LL_INFO10000, "D::GVFO: 0x%x value types!\n", cValueClasses));

            rgpValueClasses = new BYTE *[cValueClasses];
            if (rgpValueClasses == NULL)
                goto LExit;
                
            memset(rgpValueClasses, 0, sizeof(BYTE *)*cValueClasses);
        }
        cValueClasses = 0; // now becomes a VC index
    }        
#ifdef _DEBUG
    else
    {
        LOG((LF_CORDB, LL_INFO100, "D::SVAO: No locals!"));
        _ASSERTE(cet != ELEMENT_TYPE_VALUETYPE);
    }
#endif //_DEBUG

    for (i = 0;i< varNativeInfoCount;i++)
    {
        if (fVCs)
            cet = pLocals->NextArg();
        
        if (varNativeInfo[i].startOffset <= offsetFrom &&
            varNativeInfo[i].endOffset >= offsetFrom &&
            varNativeInfo[i].loc.vlType != ICorDebugInfo::VarLocType::VLT_INVALID)
        {
            if (fVCs && 
                cet == ELEMENT_TYPE_VALUETYPE &&
                varNativeInfo[i].loc.vlType != ICorDebugInfo::VarLocType::VLT_REG &&
                varNativeInfo[i].loc.vlType != ICorDebugInfo::VarLocType::VLT_REG_REG &&
                varNativeInfo[i].loc.vlType != ICorDebugInfo::VarLocType::VLT_REG_STK &&
                varNativeInfo[i].loc.vlType != ICorDebugInfo::VarLocType::VLT_STK_REG
                )
            {
                SigPointer sp = pLocals->GetArgProps();
                
                CorElementType cet2 = sp.GetElemType();
                _ASSERTE(cet == cet2);
                mdToken token = sp.GetToken();
                
                EEClass *pClass = g_pEEInterface->FindLoadedClass(pMD->GetModule(),
                    token);
                _ASSERTE(pClass->IsValueClass());
                if (pClass->GetMethodTable()->GetNormCorElementType() != ELEMENT_TYPE_VALUETYPE)
                    goto DO_PRIMITIVE;
                
                _ASSERTE(varNativeInfo[i].loc.vlType == ICorDebugInfo::VarLocType::VLT_STK);
                SIZE_T cbClass = pClass->GetAlignedNumInstanceFieldBytes();
                
                LOG((LF_CORDB, LL_INFO10000, "D::GVFO: var 0x%x is a VC,"
                    " of type %s, size:0x%x\n",i, pClass->m_szDebugClassName,
                    cbClass));
                
                // Make space for it - note that it uses teh VC index,
                // NOT the variable index
                rgpValueClasses[cValueClasses] = new BYTE[cbClass];
                if (rgpValueClasses[cValueClasses] == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto LExit;
                }
                memmove(rgpValueClasses[cValueClasses], 
                    NativeVarStackAddr(varNativeInfo[i].loc, pCtx),
                    cbClass);
                
                // Move index up.                                                        
                cValueClasses++;
            }
            else
            {
DO_PRIMITIVE:
                // Note: negative variable numbers are possible for special cases (i.e., -2 for a value class return
                // buffer, etc.) so we filter those out here...
                //
                // Note: we case to (int) to ensure that we can do the negative number check.
                //
                // @todo: we should be checking against the JIT-defined constants VARG_ILNUM, RETBUF_ILNUM, and
                // UNKNOWN_ILNUM, but those are defined in JIT-only header file. Those defs should be pulled up into a
                // more common header file.
                if ((int)varNativeInfo[i].varNumber >= 0)
                {
                    //Xfer the variable from the old location to temp storage
                    res = GetNativeVarVal(varNativeInfo[i].loc, 
                                          pCtx, 
                                          &(rgVal1[varNativeInfo[i].varNumber]),
                                          &(rgVal2[varNativeInfo[i].varNumber]));
                    assert(res == TRUE);
                }
            }
        }
    }
    
LExit:
    if (FAILED(hr))
    {
        LOG((LF_CORDB, LL_INFO100, "D::GVFO: error:0x%x",hr));
        if (rgpValueClasses != NULL)
        {   // free any memory we allocated for VCs here
            while(cValueClasses > 0) 
            {
                --cValueClasses;
                delete rgpValueClasses[cValueClasses];  // OK to delete NULL
            }  
            delete rgpValueClasses;
            rgpValueClasses = NULL;
        }       
    }
    if (pLocals != NULL)
        delete pLocals;
    
    (*rgpVCs) = rgpValueClasses;
    return hr;
}

// Note that GetVariablesFromOffset and SetVariablesAtOffset are 
// very similar - modifying one will probably need to be reflected in the other...
void Debugger::SetVariablesAtOffset(MethodDesc       *pMD,
                          UINT                        varNativeInfoCount, 
                          ICorJitInfo::NativeVarInfo *varNativeInfo,
                          SIZE_T                      offsetTo, 
                          CONTEXT                    *pCtx,
                          DWORD                      *rgVal1,
                          DWORD                      *rgVal2,
                          BYTE                      **rgpVCs)
{
    _ASSERTE(varNativeInfoCount == 0 || varNativeInfo != NULL);
    _ASSERTE(pCtx != NULL);
    _ASSERTE(rgVal1 != NULL);
    _ASSERTE(rgVal2 != NULL);

    BOOL  res;
    unsigned i;
    CorElementType cet = ELEMENT_TYPE_END;
    MetaSig *pLocals = NULL;
    ULONG iVC = 0;    
    
    COR_ILMETHOD_DECODER decoderOldIL(pMD->GetILHeader());
    mdSignature mdLocalSig = (decoderOldIL.LocalVarSigTok)?(decoderOldIL.LocalVarSigTok):
                        (mdSignatureNil);

    // If there isn't a local sig, then there can't be any VCs
    BOOL fVCs = (mdLocalSig != mdSignatureNil);
    if (fVCs)
    {
        ULONG cbSig;
        PCCOR_SIGNATURE sig = pMD->GetModule()->GetMDImport()->GetSigFromToken(mdLocalSig, &cbSig);

        pLocals = new MetaSig(sig, pMD->GetModule(), FALSE, MetaSig::sigLocalVars);
    }        
#ifdef _DEBUG
    else   
    {
        LOG((LF_CORDB, LL_INFO100, "D::SVAO: No locals!"));
        _ASSERTE(cet != ELEMENT_TYPE_VALUETYPE);
    }
#endif //_DEBUG

    // Note that since we obtain all the variables in the first loop, we
    // can now splatter those variables into their new locations
    // willy-nilly, without the fear that variable locations that have
    // been swapped might accidentally overwrite a variable value.
    for (i = 0;i< varNativeInfoCount;i++)
    {
        if (fVCs)
            cet = pLocals->NextArg();
        
        LOG((LF_CORDB, LL_INFO100000, "SVAO: var 0x%x: offTo:0x%x "
            "range: 0x%x - 0x%x\n typ:0x%x", varNativeInfo[i].varNumber,
            offsetTo, varNativeInfo[i].startOffset,
            varNativeInfo[i].endOffset, varNativeInfo[i].loc.vlType));
        
        if (varNativeInfo[i].startOffset <= offsetTo &&
            varNativeInfo[i].endOffset >= offsetTo &&
            varNativeInfo[i].loc.vlType != ICorDebugInfo::VarLocType::VLT_INVALID)
        {
            _ASSERTE(varNativeInfo[i].loc.vlType
                != ICorDebugInfo::VarLocType::VLT_COUNT);
                
            if (fVCs && 
                cet == ELEMENT_TYPE_VALUETYPE &&
                varNativeInfo[i].loc.vlType != ICorDebugInfo::VarLocType::VLT_REG &&
                varNativeInfo[i].loc.vlType != ICorDebugInfo::VarLocType::VLT_REG_REG &&
                varNativeInfo[i].loc.vlType != ICorDebugInfo::VarLocType::VLT_REG_STK &&
                varNativeInfo[i].loc.vlType != ICorDebugInfo::VarLocType::VLT_STK_REG
                )
            {
                // @todo I"m assuming we can't have a VC split, say, 
                // across a reg & a stack location
                // Otherwise, must be on the stack
                SigPointer sp = pLocals->GetArgProps();
                
                CorElementType cet2 = sp.GetElemType();
                _ASSERTE(cet == cet2);
                mdToken token = sp.GetToken();
                
                EEClass *pClass = g_pEEInterface->FindLoadedClass(pMD->GetModule(),
                                                                 token);
                _ASSERTE(pClass->IsValueClass());
                if (pClass->GetMethodTable()->GetNormCorElementType() != ELEMENT_TYPE_VALUETYPE)
                    goto DO_PRIMITIVE;
                
                _ASSERTE(varNativeInfo[i].loc.vlType == ICorDebugInfo::VarLocType::VLT_STK);
                SIZE_T cbClass = pClass->GetAlignedNumInstanceFieldBytes();

                LOG((LF_CORDB, LL_INFO10000, "D::SVAO: var 0x%x is a VC,"
                    " of type %s, size:0x%x\n", i, pClass->m_szDebugClassName,
                    cbClass));

                // We'll always allocate enough ptrs for all the VC's.
                // However, if a VC comes into scope, we won't have gotten
                // memory for it back in GetVariablesFromOffset.
                // If it's a new variable, then just initialize it to 0 here.
                if (rgpVCs[iVC] != NULL)
                {
                    LOG((LF_CORDB, LL_INFO10000, "D::SVAO: moved 0x%x bytes to 0x%x"
                        " sample:0x%x 0x%x 0x%x 0x%x\n", cbClass, 
                        NativeVarStackAddr(varNativeInfo[i].loc, pCtx)));
                        
                    memmove(NativeVarStackAddr(varNativeInfo[i].loc, pCtx),
                            rgpVCs[iVC],
                            cbClass);

                    // Now get rid of the memory                            
                    delete rgpVCs[iVC];
                    rgpVCs[iVC] = NULL;
                }
                else
                {
                    LOG((LF_CORDB, LL_INFO10000, "D::SVAO: memset 0x%x bytes at 0x%x\n",
                        cbClass, NativeVarStackAddr(varNativeInfo[i].loc, pCtx)));
                        
                    memset(NativeVarStackAddr(varNativeInfo[i].loc, pCtx),
                           0,
                           cbClass);
                }
                iVC++;                            
            }
            else
            {
            DO_PRIMITIVE:
                // Note: negative variable numbers are possible for special cases (i.e., -2 for a value class return
                // buffer, etc.) so we filter those out here...
                //
                // Note: we case to (int) to ensure that we can do the negative number check.
                //
                // @todo: we should be checking against the JIT-defined constants VARG_ILNUM, RETBUF_ILNUM, and
                // UNKNOWN_ILNUM, but those are defined in JIT-only header file. Those defs should be pulled up into a
                // more common header file.
                if ((int)varNativeInfo[i].varNumber >= 0)
                {
                    res = SetNativeVarVal(varNativeInfo[i].loc, 
                                          pCtx,
                                          rgVal1[varNativeInfo[i].varNumber],
                                          rgVal2[varNativeInfo[i].varNumber]);
                    assert(res == TRUE);
                }
            }
        }
    }

    if (pLocals != NULL)
        delete pLocals;
    if (rgpVCs != NULL)
        delete rgpVCs;
}


DebuggerILToNativeMap *DebuggerJitInfo::MapILOffsetToMapEntry(SIZE_T offset, BOOL *exact)
{
    _ASSERTE(m_sequenceMapSorted);

    //
    // Binary search for matching map element.
    //

    DebuggerILToNativeMap *mMin = m_sequenceMap;
    DebuggerILToNativeMap *mMax = mMin + m_sequenceMapCount;

    _ASSERTE( mMin < mMax ); //otherwise we have no code

    if (exact)
        *exact = FALSE;
    while (mMin + 1 < mMax)
    {
        _ASSERTE(mMin>=m_sequenceMap);
        DebuggerILToNativeMap *mMid = mMin + ((mMax - mMin)>>1);
        _ASSERTE(mMid>=m_sequenceMap);
        
        if (offset == mMid->ilOffset) {
            if (exact)
                *exact = TRUE;
            return mMid;
        }
        else if (offset < mMid->ilOffset)
            mMax = mMid;
        else
            mMin = mMid;
    }

    if (exact && offset == mMin->ilOffset)
        *exact = TRUE;
    return mMin;
}


SIZE_T DebuggerJitInfo::MapILOffsetToNative(SIZE_T ilOffset, BOOL *exact)
{
    _ASSERTE(m_sequenceMapSorted);

    DebuggerILToNativeMap *map = MapILOffsetToMapEntry(ilOffset, exact);
        
    _ASSERTE( map != NULL );
    LOG((LF_CORDB, LL_INFO10000, "DJI::MILOTN: ilOff 0x%x to nat 0x%x pExact"
        ":0x%x (valu:0x%x)(Entry IL Off:0x%x)\n", ilOffset, map->nativeStartOffset, 
        exact, (exact?*exact:0), map->ilOffset));

    return map->nativeStartOffset;
}

bool DbgIsSpecialILOffset(DWORD offset)
{
    return (offset == ICorDebugInfo::MappingTypes::PROLOG ||
            offset == ICorDebugInfo::MappingTypes::EPILOG ||
            offset == ICorDebugInfo::MappingTypes::NO_MAPPING);
}

// @mfunc SIZE_T|DebuggerJitInfo|MapSpecialToNative|Maps something like
//      a prolog to a native offset.
// @field CordDebugMappingResult|mapping|Mapping type to be looking for.
// @field SIZE_T|which|Which one.  For now, set to zero.  @todo Later, we'll
//      change this to some value that we get back from MapNativeToILOffset
//      to indicate which of the (possibly multiple epilogs) that may 
//      be present.

SIZE_T DebuggerJitInfo::MapSpecialToNative(CorDebugMappingResult mapping, 
                                           SIZE_T which,
                                           BOOL *pfAccurate)
{
    LOG((LF_CORDB, LL_INFO10000, "DJI::MSTN map:0x%x which:0x%x\n", mapping, which));
    _ASSERTE(m_sequenceMapSorted);
    _ASSERTE(NULL != pfAccurate);
    
    bool fFound;
    SIZE_T  cFound = 0;
    
    DebuggerILToNativeMap *m = m_sequenceMap;
    DebuggerILToNativeMap *mEnd = m + m_sequenceMapCount;
    while( m < mEnd )
    {
        _ASSERTE(m>=m_sequenceMap);
        
        fFound = false;
        
        if (DbgIsSpecialILOffset(m->ilOffset))
            cFound++;
        
        if (cFound == which)
        {
            _ASSERTE( (mapping == MAPPING_PROLOG && 
                m->ilOffset == ICorDebugInfo::MappingTypes::PROLOG) ||
                      (mapping == MAPPING_EPILOG && 
                m->ilOffset == ICorDebugInfo::MappingTypes::EPILOG) ||
                      ((mapping == MAPPING_NO_INFO || mapping == MAPPING_UNMAPPED_ADDRESS) && 
                m->ilOffset == ICorDebugInfo::MappingTypes::NO_MAPPING)
                    );

            (*pfAccurate) = TRUE;                    
            LOG((LF_CORDB, LL_INFO10000, "DJI::MSTN found mapping to nat:0x%x\n",
                m->nativeStartOffset));
            return m->nativeStartOffset;
        }
        m++;
    }

    LOG((LF_CORDB, LL_INFO10000, "DJI::MSTN No mapping found :(\n"));
    (*pfAccurate) = FALSE;

    return 0;
}

// @mfunc void |  DebuggerJitInfo | MapILRangeToMapEntryRange | MIRTMER
// calls MapILOffsetToNative for the startOffset (putting the
// result into start), and the endOffset (putting the result into end).
// @access public
// @parm SIZE_T | startOffset | IL offset from beginning of function.
// @parm SIZE_T | endOffset | IL offset from beginngin of function,
// or zero to indicate that the end of the function should be used.
// @parm DebuggerILToNativeMap ** | start | Contains start & end
// native offsets that correspond to startOffset.  Set to NULL if
// there is no mapping info.
// @parm DebuggerILToNativeMap ** | end | Contains start & end native
// offsets that correspond to endOffset. Set to NULL if there
// is no mapping info.
void DebuggerJitInfo::MapILRangeToMapEntryRange(SIZE_T startOffset,
                                                SIZE_T endOffset,
                                                DebuggerILToNativeMap **start,
                                                DebuggerILToNativeMap **end)
{
    _ASSERTE(m_sequenceMapSorted);

    LOG((LF_CORDB, LL_INFO1000000,
         "DJI::MIRTMER: IL 0x%04x-0x%04x\n",
         startOffset, endOffset));

    if (m_sequenceMapCount == 0)
    {
        *start = NULL;
        *end = NULL;
        return;
    }

    *start = MapILOffsetToMapEntry(startOffset);

    //
    // end points to the last range that endOffset maps to, not past
    // the last range.
    // We want to return the last IL, and exclude the epilog
    if (endOffset == 0)
    {
        *end = m_sequenceMap + m_sequenceMapCount - 1;
        _ASSERTE(*end>=m_sequenceMap);
        
        while ( ((*end)->ilOffset == ICorDebugInfo::MappingTypes::EPILOG||
                (*end)->ilOffset == ICorDebugInfo::MappingTypes::NO_MAPPING)
               && (*end) > m_sequenceMap)
        {               
            (*end)--;
            _ASSERTE(*end>=m_sequenceMap);

        }
    }
    else
        *end = MapILOffsetToMapEntry(endOffset - 1);

    _ASSERTE(*end>=m_sequenceMap);


    LOG((LF_CORDB, LL_INFO1000000,
         "DJI::MIRTMER: IL 0x%04x-0x%04x --> 0x%04x 0x%08x-0x%08x\n"
         "                               --> 0x%04x 0x%08x-0x%08x\n",
         startOffset, endOffset,
         (*start)->ilOffset,
         (*start)->nativeStartOffset, (*start)->nativeEndOffset,
         (*end)->ilOffset,
         (*end)->nativeStartOffset, (*end)->nativeEndOffset));
}


// @mfunc SIZE_T | DebuggerJitInfo | MapNativeOffsetToIL | Given a native
//  offset for the <t DebuggerJitInfo>, compute
//  the IL offset from the beginning of the same method.
// @rdesc Offset of the IL instruction that contains
//  the native offset,
// @parm SIZE_T | nativeOffset | [IN] Native Offset
// @parm CorDebugMappingResult *| map | [OUT] explains the
//  quality of the matching & special cases
// @parm SIZE_T|which|It's possible to have multiple EPILOGs, or
//  multiple unmapped regions within a method.  This opaque value
//  specifies which special region we're talking about.  This
//  param has no meaning if map & (MAPPING_EXACT|MAPPING_APPROXIMATE)
//  Basically, this gets handed back to MapSpecialToNative, later.
DWORD DebuggerJitInfo::MapNativeOffsetToIL(DWORD nativeOffset, 
                                            CorDebugMappingResult *map,
                                            DWORD *which)
{
    _ASSERTE(m_sequenceMapSorted);
    _ASSERTE(map != NULL);
    _ASSERTE(which != NULL);

    (*which) = 0;
    DebuggerILToNativeMap *m = m_sequenceMap;
    DebuggerILToNativeMap *mEnd = m + m_sequenceMapCount;

    LOG((LF_CORDB,LL_INFO10000,"DJI::MNOTI: nativeOffset = 0x%x\n", nativeOffset));
    
    while (m < mEnd)
    {
        _ASSERTE(m>=m_sequenceMap);

#ifdef LOGGING
        if (m->ilOffset == ICorDebugInfo::MappingTypes::PROLOG )
            LOG((LF_CORDB,LL_INFO10000,"DJI::MNOTI: m->natStart:0x%x m->natEnd:0x%x il:PROLOG\n", m->nativeStartOffset, m->nativeEndOffset));
        else if (m->ilOffset == ICorDebugInfo::MappingTypes::EPILOG )
            LOG((LF_CORDB,LL_INFO10000,"DJI::MNOTI: m->natStart:0x%x m->natEnd:0x%x il:EPILOG\n", m->nativeStartOffset, m->nativeEndOffset));
        else if (m->ilOffset == ICorDebugInfo::MappingTypes::NO_MAPPING)
            LOG((LF_CORDB,LL_INFO10000,"DJI::MNOTI: m->natStart:0x%x m->natEnd:0x%x il:NO MAP\n", m->nativeStartOffset, m->nativeEndOffset));
        else
            LOG((LF_CORDB,LL_INFO10000,"DJI::MNOTI: m->natStart:0x%x m->natEnd:0x%x il:0x%x\n", m->nativeStartOffset, m->nativeEndOffset, m->ilOffset));
#endif LOGGING

        if (m->ilOffset == ICorDebugInfo::MappingTypes::PROLOG ||
            m->ilOffset == ICorDebugInfo::MappingTypes::EPILOG ||
            m->ilOffset == ICorDebugInfo::MappingTypes::NO_MAPPING)
        {
            (*which)++;
        }

        if (nativeOffset >= m->nativeStartOffset
            && ((m->nativeEndOffset == 0 && 
                m->ilOffset != ICorDebugInfo::MappingTypes::PROLOG)
                 || nativeOffset < m->nativeEndOffset))
        {
            SIZE_T ilOff = m->ilOffset;

            if( m->ilOffset == ICorDebugInfo::MappingTypes::PROLOG )
            {
                ilOff = 0;
                (*map) = MAPPING_PROLOG;
                LOG((LF_CORDB,LL_INFO10000,"DJI::MNOTI: MAPPING_PROLOG\n"));
                
            }
            else if (m->ilOffset == ICorDebugInfo::MappingTypes::NO_MAPPING)
            {
                ilOff = 0;
                (*map) = MAPPING_UNMAPPED_ADDRESS ;
                LOG((LF_CORDB,LL_INFO10000,"DJI::MNOTI:MAPPING_"
                    "UNMAPPED_ADDRESS\n"));
            }
            else if( m->ilOffset == ICorDebugInfo::MappingTypes::EPILOG )
            {
                ilOff = m_lastIL;
                (*map) = MAPPING_EPILOG;
                LOG((LF_CORDB,LL_INFO10000,"DJI::MNOTI:MAPPING_EPILOG\n"));
            }
            else if (nativeOffset == m->nativeStartOffset)
            {
                (*map) = MAPPING_EXACT;
                LOG((LF_CORDB,LL_INFO10000,"DJI::MNOTI:MAPPING_EXACT\n"));
            }
            else
            {
                (*map) = MAPPING_APPROXIMATE;
                LOG((LF_CORDB,LL_INFO10000,"DJI::MNOTI:MAPPING_"
                    "APPROXIMATE\n"));
            }
            
            return ilOff;
        }
        m++;
    }

    return 0;
}

DebuggerJitInfo *DebuggerJitInfo::GetJitInfoByVersionNumber(SIZE_T nVer,
                                                            SIZE_T nVerMostRecentlyEnC)
{
    DebuggerJitInfo *dji = this;
    DebuggerJitInfo *djiMostRecent = NULL;
    SIZE_T nVerMostRecent = DJI_VERSION_FIRST_VALID;

    while( dji != NULL )
    {
        if (dji->m_nVersion == nVer && nVer>=DJI_VERSION_FIRST_VALID)
        {
            // we've found the one we're after, so stop here
            LOG((LF_CORDB,LL_INFO10000, "DJI:GJIBVN: We've found an exact "
                "match for ver 0x%x\n", nVer));
            break;
        }

        if ((nVer==DJI_VERSION_MOST_RECENTLY_JITTED ||
             nVer==DJI_VERSION_MOST_RECENTLY_EnCED)
            && dji->m_nVersion >= nVerMostRecent)// &&dji->m_jitComplete==false
        {
            LOG((LF_CORDB,LL_INFO10000, "DJI:GJIBVN: Found a version, perhaps "
                "most recent?0x%x, ver:0x%x\n", dji, dji->m_nVersion));
            nVerMostRecent = dji->m_nVersion;
            djiMostRecent = dji;
        }
        dji = dji->m_prevJitInfo;
    }

    if (nVer==DJI_VERSION_MOST_RECENTLY_JITTED)
    {
        dji = djiMostRecent;
        LOG((LF_CORDB,LL_INFO10000, "DJI:GJIBVN: Asked for most recently JITted. "
            "Found 0x%x, Ver#:0x%x\n", dji, nVerMostRecent));
    }

    if (nVer==DJI_VERSION_MOST_RECENTLY_EnCED &&
        djiMostRecent != NULL &&
        nVerMostRecentlyEnC==djiMostRecent->m_nVersion)
    {
        dji = djiMostRecent;
        LOG((LF_CORDB,LL_INFO10000, "DJI:GJIBVN: Asked for most recently EnCd. "
            "Found 0x%x, Ver#:0x%x\n", dji, nVerMostRecent));
    }

#ifdef LOGGING
    if (dji == NULL)
    {
        LOG((LF_CORDB,LL_INFO10000, "DJI:GJIBVN couldn't find a "
            "DJI corresponding to ver 0x%x\n", nVer));
    }
#endif //LOGGING

    return dji;
}


DebuggerJitInfo *DebuggerJitInfo::GetJitInfoByAddress(const BYTE *pbAddr )
{
    DebuggerJitInfo *dji = this;

    // If it's not NULL, but not in the range m_addrOfCode to end of function,
    //  then get the previous one.
    while( dji != NULL && 
            !(dji->m_addrOfCode<=PTR_TO_CORDB_ADDRESS(pbAddr) && 
              PTR_TO_CORDB_ADDRESS(pbAddr)<(dji->m_addrOfCode+
                    PTR_TO_CORDB_ADDRESS(dji->m_sizeOfCode))))
    {
        LOG((LF_CORDB,LL_INFO10000,"DJI:GJIBA: pbAddr 0x%x is not in code "
            "0x%x (size:0x%x)\n", pbAddr, (ULONG)dji->m_addrOfCode,
            (ULONG)dji->m_sizeOfCode));
        dji = dji->m_prevJitInfo;
    }

#ifdef LOGGING
    if (dji == NULL)
    {
        LOG((LF_CORDB,LL_INFO10000,"DJI:GJIBA couldn't find a DJI "
            "corresponding to addr 0x%x\n", pbAddr));
    }
#endif //LOGGING
    return dji;
}


// @mfunc HRESULT|DebuggerJitInfo|LoadEnCILMap|Grabs the old il to
//  new IL map.  If this <t DebuggerJitInfo> already has an IL to IL map, 
//  then we must have been EnC'd twice without getting JITted, so we should
//  create a new DJI, load the EnCIL map into it, and then put it at the
//  head of the list (ie, in front of this DJI).
HRESULT DebuggerJitInfo::LoadEnCILMap(UnorderedILMap *ilMap)
{
    if (m_OldILToNewIL==NULL)
    {
        LOG((LF_CORDB,LL_INFO10000,"DJI::LEnCILM:Map for 0x%x!\n",this));
        
        _ASSERTE( m_cOldILToNewIL==0 );
        if (ilMap != NULL )
        {
            m_cOldILToNewIL = ilMap->cMap;
            m_OldILToNewIL = (DebuggerOldILToNewILMap*)new (interopsafe) DebuggerOldILToNewILMap[m_cOldILToNewIL];
            if (NULL == m_OldILToNewIL)
            {
                LOG((LF_CORDB,LL_INFO10000, "DJI::LEnCILM Not enough memory "
                    "to allocate EnC Map!\n"));
                return E_OUTOFMEMORY;
            }

            TRACE_ALLOC(m_OldILToNewIL);

            for (ULONG i = 0; i < m_cOldILToNewIL; i++)
            {
                m_OldILToNewIL[i].ilOffsetOld = ilMap->pMap[i].oldOffset;
                m_OldILToNewIL[i].ilOffsetNew = ilMap->pMap[i].newOffset;
                m_OldILToNewIL[i].fAccurate = ilMap->pMap[i].fAccurate;
            }
        }
        
        return S_OK;
    }
    else
    {  
        LOG((LF_CORDB,LL_INFO10000, "DJI::LEnCILM: Found existing "
            "map, extending chain after 0x%x\n", this));

        _ASSERTE( m_nextJitInfo == NULL );
        DebuggerJitInfo *dji = new (interopsafe) DebuggerJitInfo(m_fd);
        if (NULL == dji)
            return E_OUTOFMEMORY;

        HRESULT hr = dji->LoadEnCILMap( ilMap );
        if (FAILED(hr))
            return hr;
            
        hr = g_pDebugger->InsertAtHeadOfList( dji );
        _ASSERTE( m_nextJitInfo == dji);
        _ASSERTE( this == dji->m_prevJitInfo);
        return hr;
    }
}

// Translate between old & new offsets (w/ respect to Instrumented IL).


#if 1
// Don't interpolate
SIZE_T DebuggerJitInfo::TranslateToInstIL(SIZE_T offOrig, bool fOrigToInst)
{
    // some negative IL offsets have special meaning. Don't translate
    // those (just return as is). See ICorDebugInfo::MappingTypes
    if (m_cInstrumentedILMap == 0 || ((int) offOrig < 0)) 
            return offOrig; 

    // This assumes:
    // - map is sorted in increasing order by both old & new    
    // - round down. 
    if (fOrigToInst)
    {
        // Translate: old --> new
        for(SIZE_T iMap = 1; iMap < m_cInstrumentedILMap; iMap++)
        {
            if (offOrig < m_rgInstrumentedILMap[iMap].oldOffset)
                return m_rgInstrumentedILMap[iMap-1].newOffset;
        }
        return m_rgInstrumentedILMap[iMap - 1].newOffset;
    }
    else 
    {
        // Translate: new --> old
        for(SIZE_T iMap = 1; iMap < m_cInstrumentedILMap; iMap++)
        {
            if (offOrig < m_rgInstrumentedILMap[iMap].newOffset)
                return m_rgInstrumentedILMap[iMap-1].oldOffset;
        }
        return m_rgInstrumentedILMap[iMap - 1].oldOffset;
    }
}
#else
// Original version which interpolates
// We don't have enough information to interpolate, so this is bad.
SIZE_T DebuggerJitInfo::TranslateToInstIL(SIZE_T offOrig, bool fOrigToInst)
{
    if (m_cInstrumentedILMap == 0 || 
        ((int)offOrig < 0))
    {
        return offOrig;
    }
    else
    {
        _ASSERTE(m_rgInstrumentedILMap != NULL);
        
        // @todo If we access this in-order most of the time, we
        // could maintain a static pointer to where the last item
        // was found,and search forwards/backwards from there
        // Thus, TTIIL(5), TTIIL(7), TTIIL(9) would be O(1) time
        
        for (SIZE_T iMap = 0; iMap < m_cInstrumentedILMap; iMap++)
        {
            if( offOrig < (fOrigToInst?m_rgInstrumentedILMap[iMap].oldOffset:
                                      m_rgInstrumentedILMap[iMap].newOffset))
            {
                break;
            }
        }

        iMap--; // Either we went one beyond what we wanted, or one beyond
                // the end of the array.
        if( (int)iMap < 0)
            return offOrig;

        // Interpolate
        SIZE_T offOldCompare;
        SIZE_T offNewCompare;
        
        if (fOrigToInst)
        {
            offOldCompare = m_rgInstrumentedILMap[iMap].oldOffset;
            offNewCompare = m_rgInstrumentedILMap[iMap].newOffset;
        }
        else
        {
            offOldCompare = m_rgInstrumentedILMap[iMap].newOffset;
            offNewCompare = m_rgInstrumentedILMap[iMap].oldOffset;
        }

        if ((int)offOldCompare > (int)offOrig)
            return offOrig;

        SIZE_T offTo;
        if (offOrig == offOldCompare)
        {
            offTo = offNewCompare;
        }
        else
        {
            // Integer math so that negative numbers get handled correctly
            offTo = offOrig + ((int)offNewCompare - 
                        (int)offOldCompare);
        }
            
        return offTo;     
    }
}
#endif

BOOL IsDuplicatePatch(SIZE_T *rgEntries, USHORT cEntries,
                      SIZE_T Entry )
{
    for( int i = 0; i < cEntries;i++)
    {
        if (rgEntries[i] == Entry)
            return TRUE;
    }
    return FALSE;
}

/******************************************************************************
// @mfunc HRESULT|Debugger|MapAndBindFunctionBreakpoints|  For each breakpoint 
//      that we've set in any version of the existing function,
//      set a correponding breakpoint in the new function if we haven't moved
//      the patch to the new version already.
//
//      This must be done _AFTER_ the MethodDesc has been udpated 
//      with the new address (ie, when GetFunctionAddress pFD returns 
//      the address of the new EnC code)
//  @todo Replace array with hashtable for improved efficiency
//  @todo Need to factor code,so that we can selectively map forward DFK(ilOFfset) BPs
 ******************************************************************************/
HRESULT Debugger::MapAndBindFunctionPatches(DebuggerJitInfo *djiNew,
                                            MethodDesc * fd,
                                            BYTE * addrOfCode)
{
    _ASSERTE(!djiNew || djiNew->m_fd == fd);

    HRESULT     hr =                S_OK;
    HASHFIND    hf;
    SIZE_T      *pidTableEntry =    NULL;
    SIZE_T      pidInCaseTableMoves;
    Module      *pModule =          g_pEEInterface->MethodDescGetModule(fd);
    mdMethodDef md =                fd->GetMemberDef();

    LOG((LF_CORDB,LL_INFO10000,"D::MABFP: All BPs will be mapped to "
        "Ver:0x%04x (DJI:0x%08x)\n", djiNew?djiNew->m_nVersion:0, djiNew));

    // First lock the patch table so it doesn't move while we're
    //  examining it.
    LOG((LF_CORDB,LL_INFO10000, "D::MABFP: About to lock patch table\n"));
    DebuggerController::Lock();

    // Manipulate tables AFTER lock's been acquired.
    DebuggerPatchTable *pPatchTable = DebuggerController::GetPatchTable();
    m_BPMappingDuplicates.Clear(); //dups are tracked per-version

    DebuggerControllerPatch *dcp = pPatchTable->GetFirstPatch(&hf);

    while (!FAILED(hr) && dcp != NULL)
    {
        // If we're missing the {module,methodDef} key, then use the 
        // MethodDesc to ensure that we're only mapping BPs for the
        // method indicated by djiNew, and not any others....
        if (dcp->key.module == NULL || dcp->key.md == mdTokenNil)
        {
            _ASSERTE(dcp->address != NULL);
            
            if (g_pEEInterface->IsManagedNativeCode(dcp->address))
            {
                MethodDesc *patchFD = g_pEEInterface->GetNativeCodeMethodDesc(dcp->address);

                if (patchFD != fd)
                    goto LNextLoop;
            }
        }

        // Only copy over breakpoints that are in this method
        if (dcp->key.module != pModule || dcp->key.md != md)
        {
            goto LNextLoop;
        }

        // @todo EnC PITCH  Since EnC & Code pitching are exclusive,
        // if the dji was set to  DJI_VERSION_INVALID in 
        // UnbindFunctionPatches (which was called from PitchCode),
        // then must be equivalent to BindFunctionPatches (ie, bind the
        // patch into the current version regardless of type).
        // 
        // If this is an EnC patch, which we only want to map
        // over if the patch belongs to a DebuggerBreakpoint OR
        // DebuggerStepper
        //
        // If neither of these is true, then we're EnCing and looking at
        // a patch that we don't want to bind - skip this patch
        if (dcp->dji != (DebuggerJitInfo*)DebuggerJitInfo::DJI_VERSION_INVALID && 
            !(dcp->controller->GetDCType() == DEBUGGER_CONTROLLER_BREAKPOINT||
              dcp->controller->GetDCType() == DEBUGGER_CONTROLLER_STEPPER)
            )
        {
            LOG((LF_CORDB, LL_INFO100000, "Neither stepper nor BP, & valid"
                 "DJI! - getting next patch!\n"));
            goto LNextLoop;
        }

        // The patch is for a 'BindFunctionPatches' call, but it's already bound
        if (dcp->dji == (DebuggerJitInfo*)DebuggerJitInfo::DJI_VERSION_INVALID && 
            dcp->address != NULL )
        {
            goto LNextLoop;
        }

        if (djiNew == NULL)
        {
            _ASSERTE(dcp->controller->GetDCType() == DEBUGGER_CONTROLLER_BREAKPOINT ||
                     dcp->controller->GetDCType() == DEBUGGER_CONTROLLER_STEPPER);
            _ASSERTE(dcp->native && dcp->offset == 0);

            DebuggerController::g_patches->BindPatch(dcp, addrOfCode);
            DebuggerController::ActivatePatch(dcp);
            goto LNextLoop;
        }

        if (dcp->controller->GetDCType() == DEBUGGER_CONTROLLER_STEPPER)
        {
			// Update the stepping patches if we have a new version of
			// the method being stepped
			DebuggerStepper * stepper = (DebuggerStepper*)dcp->controller;

			if (stepper->IsSteppedMethod(djiNew->m_fd))
				stepper->MoveToCurrentVersion(djiNew);
        }

        pidInCaseTableMoves = dcp->pid;
        
        // If we've already mapped this one to the current version,
        //  don't map it again.
        LOG((LF_CORDB,LL_INFO10000,"D::MABFP: Checking if 0x%x is a dup...", 
            pidInCaseTableMoves));
            
        if ( IsDuplicatePatch( m_BPMappingDuplicates.Table(), 
                              m_BPMappingDuplicates.Count(),
                              pidInCaseTableMoves) )
        {
            LOG((LF_CORDB,LL_INFO10000,"it is!\n"));
            goto LNextLoop;
        }
        LOG((LF_CORDB,LL_INFO10000,"nope!\n"));
        
        // Attempt mapping from patch to new version of code, and
        // we don't care if it turns out that there isn't a mapping.
        // @todo-postponed: EnC: Make sure that this doesn't cause
        // the patch-table to shift.
        hr = MapPatchToDJI( dcp, djiNew );
        if (CORDBG_E_CODE_NOT_AVAILABLE == hr )
            hr = S_OK;

        if (FAILED(hr))
            break;

        //Remember the patch id to prevent duplication later
        pidTableEntry = m_BPMappingDuplicates.Append();
        if (NULL == pidTableEntry)
            hr = E_OUTOFMEMORY;

        *pidTableEntry = pidInCaseTableMoves;
        LOG((LF_CORDB,LL_INFO10000,"D::MABFP Adding 0x%x to list of "
            "already mapped patches\n", pidInCaseTableMoves));
LNextLoop:
        dcp = pPatchTable->GetNextPatch( &hf );
    }

    // Lastly, unlock the patch table so it doesn't move while we're
    //  examining it.
    DebuggerController::Unlock();
    LOG((LF_CORDB,LL_INFO10000, "D::MABFP: Unlocked patch table\n"));

    return hr;
}

/******************************************************************************
// @mfunc HRESULT|Debugger|MapPatchToDJI|Maps the given
//  patch to the corresponding location at the new address.
//  We assume that the new code has been JITTed.
// @rdesc CORDBG_E_CODE_NOT_AVAILABLE|Indicates that a mapping wasn't
//  available, and thus no patch was placed.  The caller may or may
//  not care.
 ******************************************************************************/
HRESULT Debugger::MapPatchToDJI( DebuggerControllerPatch *dcp,DebuggerJitInfo *djiTo)
{
    _ASSERTE( djiTo->m_jitComplete == true );

    HRESULT hr = S_OK;
    BOOL fMappingForwards; //'forwards' mean from an earlier version to a more
        //recent version, ie, from a lower version number towards a higher one.
    
    SIZE_T ilOffsetOld;
    SIZE_T ilOffsetNew;
    SIZE_T natOffsetNew;

    DebuggerJitInfo *djiCur; //for walking the list

    bool fNormalMapping = true;
    CorDebugMappingResult mapping;
    SIZE_T which;
    BOOL irrelevant2;

    // If it's hashed by address, then there should be an opcode
    // Otherwise, don't do anything with it, since it isn't valid
    _ASSERTE( dcp->opcode == 0 || dcp->address != NULL);
    if (dcp->address != 0 && dcp->opcode == 0)
    {
        return S_OK;
    }

    // Grab the version it actually belongs to, then bring it forward
    djiCur = dcp->dji;

    if (djiCur == NULL) //then the BP has been mapped forwards into the
    {   // current version, or we're doing a BindFunctionPatches.  Either
        // way, we simply want the most recent version
        djiCur = g_pDebugger->GetJitInfo( djiTo->m_fd, NULL);
        dcp->dji = djiCur;
    }
    
    _ASSERTE( NULL != djiCur );

    // If the source and destination is the same, then this method
    // decays into BindFunctionPatch's BindPatch function
    if (djiCur == djiTo )
    {
        if (DebuggerController::BindPatch(dcp, 
                                          (const BYTE*)djiTo->m_addrOfCode, 
                                          NULL))
        {
            DebuggerController::ActivatePatch(dcp);
            LOG((LF_CORDB, LL_INFO1000, "Application went fine!\n" ));
            return S_OK;
        }
        else
        {
            LOG((LF_CORDB, LL_INFO1000, "Didn't apply for some reason!\n"));

            // Send an event to the Right Side so we know this patch didn't bind...
            LockAndSendBreakpointSetError(dcp);
            
            return CORDBG_E_CODE_NOT_AVAILABLE;
        }
    }
    
    LOG((LF_CORDB,LL_INFO10000,"D::MPTDJI: From pid 0x%x, "
        "Ver:0x%04x (DJI:0x%08x) to Ver:0x%04x (DJI:0x%08x)\n", 
        dcp->pid, djiCur->m_nVersion,djiCur,djiTo->m_nVersion, djiTo));

    // Grab the original IL offset
    if (dcp->native == TRUE)
    {
        ilOffsetOld = djiCur->MapNativeOffsetToIL(dcp->offset,&mapping,
                            &which);
        LOG((LF_CORDB,LL_INFO10000, "D::MPTDJI: offset is native0x%x, "
            "mapping to IL 0x%x mapping:0x%x, which:0x%x\n", 
            dcp->offset, ilOffsetOld, mapping, which));
    }
    else
    {
        ilOffsetOld = dcp->offset; 
        mapping = MAPPING_EXACT;
        LOG((LF_CORDB,LL_INFO10000, "D::MPTDJI: offset is IL 0x%x\n",
            ilOffsetOld));
    }               

    fMappingForwards = (djiCur->m_nVersion<djiTo->m_nVersion)?(TRUE):(FALSE);
#ifdef LOGGING
    if (fMappingForwards)
        LOG((LF_CORDB,LL_INFO1000,"D::MPTDJI: Mapping forwards from 0x%x to 0x%x!\n", 
            djiCur->m_nVersion,djiTo->m_nVersion));
    else
        LOG((LF_CORDB,LL_INFO1000,"D::MPTDJI: Mapping backwards from 0x%x to 0x%x!\n", 
            djiCur->m_nVersion,djiTo->m_nVersion));
#endif //LOGGING

    ilOffsetNew = ilOffsetOld;
    
    // Translate it to the new IL offset (through multiple versions, if needed)
    fNormalMapping = (mapping&(MAPPING_EXACT|MAPPING_APPROXIMATE))!=0;
    if ( fNormalMapping )
    {
        BOOL fAccurateIgnore; // @todo Debugger will eventuall do this for us.
        MapThroughVersions( ilOffsetOld, 
                            djiCur,
                            &ilOffsetNew, 
                            djiTo, 
                            fMappingForwards,
                            &fAccurateIgnore);
        djiCur = djiTo;
    }
    
    // Translate IL --> Native, if we want to
    if (!FAILED(hr))
    {
        if (fNormalMapping)
        {
            natOffsetNew = djiTo->MapILOffsetToNative(ilOffsetNew, &irrelevant2);
            LOG((LF_CORDB,LL_INFO10000, "D::MPTDJI: Mapping IL 0x%x (ji:0x%08x) "
                "to native offset 0x%x\n", ilOffsetNew, djiCur, natOffsetNew));
        }
        else
        {
            natOffsetNew = djiTo->MapSpecialToNative(mapping, which, &irrelevant2);
            LOG((LF_CORDB,LL_INFO10000, "D::MPTDJI: Mapping special 0x%x (ji:0x%8x) "
                "to native offset 0x%x\n", mapping, djiCur, natOffsetNew));
        }

        DebuggerBreakpoint *dbp = (DebuggerBreakpoint*)dcp->controller;
        //!!! TYPECAST ONLY WORKS B/C OF PRIOR TYPE CHECK, ABOVE!!!

        LOG((LF_CORDB,LL_INFO10000,"Adding patch to existing BP 0x%x\n",dbp));

        // Note that we don't want to create a new breakpoint, we just want
        // to put another patch down (in the new version) for the existing breakpoint
        // This will allow BREAKPOINT_REMOVE to continue to work.
        DebuggerController::AddPatch(dbp, 
                                     djiTo->m_fd, 
                                     true, 
                                     (const BYTE*)djiTo->m_addrOfCode+natOffsetNew, 
                                     dcp->fp,
                                     djiTo, 
                                     dcp->pid,
                                     natOffsetNew);

        // @todo When we combine BindFunctionPatches with this, we should
        // remove the below line.
//        _ASSERTE( dcp->fSaveOpcode == false );

        LOG((LF_CORDB,LL_INFO10000, "D::MPTDJI: Copied bp\n"));
    }

    return hr;
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::MapThroughVersions( SIZE_T fromIL, 
    DebuggerJitInfo *djiFrom,  
    SIZE_T *toIL, 
    DebuggerJitInfo *djiTo, 
    BOOL fMappingForwards,
    BOOL *fAccurate)
{
#ifdef LOGGING
    if (fMappingForwards)
        LOG((LF_CORDB,LL_INFO1000000, "D:MTV: From 0x%x (ver:0x%x) forwards to"
            " ver 0x%x\n", fromIL, djiFrom->m_nVersion, djiTo->m_nVersion));
    else
        LOG((LF_CORDB,LL_INFO1000000, "D:MTV: From 0x%x (ver:0x%x) backwards to"
            " ver 0x%x\n", fromIL, djiFrom->m_nVersion, djiTo->m_nVersion));
#endif //LOGGING

    _ASSERTE(fAccurate != NULL);
    
    DebuggerJitInfo *djiCur = djiFrom;
    HRESULT hr = S_OK;
    (*fAccurate) = TRUE;
    BOOL fAccurateTemp = TRUE;
    *toIL = fromIL; 
    
    while (djiCur != djiTo && djiCur != NULL)
    {
        hr = g_pDebugger->MapOldILToNewIL(fMappingForwards,
                                          djiCur->m_OldILToNewIL,
            djiCur->m_OldILToNewIL+djiCur->m_cOldILToNewIL,
                                          fromIL, 
                                          toIL,
                                          &fAccurateTemp);      
        if (!fAccurateTemp)
            (*fAccurate) = FALSE;
        
        if (FAILED(hr))
        {
            hr = CORDBG_E_CODE_NOT_AVAILABLE;
            break;
        }
        
        LOG((LF_CORDB,LL_INFO10000, "D::MPTDJI: Mapping IL 0x%x (ji:0x%08x) "
            "to IL 0x%x (ji:0x%08x)\n", fromIL, djiCur, *toIL, 
            djiCur->m_nextJitInfo));
            
        fromIL = *toIL;

        if (fMappingForwards)
            djiCur = djiCur->m_nextJitInfo;
        else
            djiCur = djiCur->m_prevJitInfo;
    }
    return hr;
}
/******************************************************************************
// @mfunc HRESULT|DebuggerJitInfo|MapOldILToNewIL|Maps oldIL to the
//      corresponding newIL offset.  E_FAIL is returned if not matching
//      offset could be found.  
// @parm BOOL|fOldToNew|If TRUE then we map from old to new.  Otherwise,
//      map from new to old
// @parm DebuggerOldILToNewILMap *|max|This should be the 
//      DebuggerOldILToNewILMap element that's actually one beyond
//      the last valid map entry.  That way our binary search algorithm
//      will check the 'topmost' element if it has to.
 ******************************************************************************/
HRESULT Debugger::MapOldILToNewIL( BOOL fOldToNew, 
        DebuggerOldILToNewILMap *min, 
        DebuggerOldILToNewILMap *max, 
        SIZE_T oldIL, 
        SIZE_T *newIL,
        BOOL *fAccurate )
{
    _ASSERTE( newIL != NULL );
    _ASSERTE( fAccurate != NULL );
    if (min == NULL)
    {
        _ASSERTE( max==NULL );
        *newIL = oldIL;
        return S_OK;
    }       
    
    _ASSERTE( max!=NULL );
    _ASSERTE( min!=NULL );

    DebuggerOldILToNewILMap *mid = min + ((max - min)>>1);

    while (min + 1 < max)
    {

        if ( (fOldToNew && oldIL == mid->ilOffsetOld) ||
             (!fOldToNew && oldIL == mid->ilOffsetNew))
        {
            if (fOldToNew)
                *newIL = mid->ilOffsetNew;
            else
                *newIL = mid->ilOffsetOld;
            
            LOG((LF_CORDB,LL_INFO10000, "DJI::MOILTNIL map oldIL:0x%x "
                "to newIL:0x%x fAcc:0x%x\n", oldIL, 
                mid->ilOffsetNew,
                mid->fAccurate));
            (*fAccurate) = mid->fAccurate;
            
            return S_OK;
        }
        else if (oldIL < mid->ilOffsetOld)
            max = mid;
        else
            min = mid;
            
        mid = min + ((max - min)>>1);
    }

    if (fOldToNew)
    {
        _ASSERTE(oldIL >= min->ilOffsetOld);
        *newIL = min->ilOffsetNew + (oldIL - min->ilOffsetOld);

        // If we're not exact, then the user should check the result
        (*fAccurate) = (oldIL == min->ilOffsetOld)?min->fAccurate:FALSE; 
        
        LOG((LF_CORDB,LL_INFO10000, "DJI::MOILTNIL forwards oldIL:0x%x min->old:0x%x"
            "min->new:0x%x to newIL:0x%x fAcc:FALSE\n", oldIL, min->ilOffsetOld, 
            mid->ilOffsetNew, *newIL));
            
        return S_OK;
    }

    if (!fOldToNew)
    {
        _ASSERTE(oldIL >= min->ilOffsetNew);
        *newIL = min->ilOffsetOld + (oldIL - min->ilOffsetNew);
        
        // If we're not exact, then the user should check the result
        (*fAccurate) = (oldIL == min->ilOffsetOld)?min->fAccurate:FALSE; 

        LOG((LF_CORDB,LL_INFO10000, "DJI::MOILTNIL backwards oldIL:0x%x min->old:0x%x"
            "min->new:0x%x to newIL:0x%x fAcc:FALSE\n", oldIL, 
            min->ilOffsetOld, 
            mid->ilOffsetNew, 
            *newIL));
        return S_OK;
    }

    LOG((LF_CORDB,LL_INFO10000, "DJI::MOILTNIL unable to match "
        "oldIL of 0x%x!\n", oldIL));
    _ASSERTE( !"DJI::MOILTNIL We'll never get here unless we're FUBAR");
    
    return E_FAIL;
}

/* ------------------------------------------------------------------------ *
 * EE Interface routines
 * ------------------------------------------------------------------------ */

//
// DisableEventHandling ensures that only the calling Runtime thread
// is able to handle a debugger event. When it returns, the calling
// thread may take an action that could cause an IPC event to be sent
// to the Right Side. While event handling is "disabled", other
// Runtime threads will block.
//
void Debugger::DisableEventHandling(void)
{
    LOG((LF_CORDB,LL_INFO1000,"D::DEH about to wait\n"));

    if (!g_fProcessDetach)
    {
    rewait:
        // If there is an IDbgThreadControl interface, then someone wants
        // notification if this thread is going to block waiting to take
        // the lock.  So wait for 1 second and then if we timeout notify
        // the client.  If there is no client, wait without timeout.
        DWORD dwRes = WaitForSingleObject(
            m_eventHandlingEvent, m_pIDbgThreadControl ? 1000 : INFINITE);

        switch (dwRes)
        {
        case WAIT_TIMEOUT:
            _ASSERTE(m_pIDbgThreadControl);

            // If there is a IDebuggerThreadControl client, notify them of the
            // fact that the thread is blocking because of the debugger.
            m_pIDbgThreadControl->ThreadIsBlockingForDebugger();

            // When it returns, need to re-attempt taking of the lock, and
            // if it still takes a while, will re-notify the client.
            goto rewait;

            _ASSERTE(!"D::DEH - error, should not be here.");
            break;

        // Got the lock, so proceed as normal
        case WAIT_OBJECT_0:
            break;

#ifdef _DEBUG
        // Error case
        case WAIT_ABANDONED:
            _ASSERTE(!"D::DEH::WaitForSingleObject failed!");

        // Should never get here
        default:
            _ASSERTE(!"D::DEH reached default case in error.");
#endif
        }
    }

    LOG((LF_CORDB,LL_INFO1000,"D::DEH finished wait\n"));
}


//
// EnableEventHandling allows other Runtime threads to handle a
// debugger event. This funciton only enables event handling if the
// process is not stopped. If the process is stopped, then other
// Runtime threads should block instead of sending IPC events to the
// Right Side.
//
// STRONG NOTE: you better know exactly what the heck you're doing if
// you ever call this function with forceIt = true.
//
void Debugger::EnableEventHandling(bool forceIt)
{
    LOG((LF_CORDB,LL_INFO1000,"D::EEH about to signal forceIt:0x%x\n"
        ,forceIt));
        
    if (!g_fProcessDetach)
    {
        _ASSERTE(ThreadHoldsLock());

        if (!m_stopped || forceIt)
        {
            VERIFY(SetEvent(m_eventHandlingEvent));
        }
#ifdef LOGGING
        else
            LOG((LF_CORDB, LL_INFO10000,
                 "D::EEH: skipping enable event handling due to m_stopped\n"));
#endif                
    }
}

//
// SendSyncCompleteIPCEvent sends a Sync Complete event to the Right Side.
//
void Debugger::SendSyncCompleteIPCEvent()
{
    _ASSERTE(ThreadHoldsLock());

    LOG((LF_CORDB, LL_INFO10000, "D::SSCIPCE: sync complete.\n"));

    // We had better be trapping Runtime threads and not stopped yet.
    _ASSERTE(!m_stopped && m_trappingRuntimeThreads);

    // Okay, we're stopped now.
    m_stopped = TRUE;
    g_fRelaxTSLRequirement = true;

    // If we're attaching, then this is the first time that all the
    // threads in the process have synchronized. Before sending the
    // sync complete event, we send back events telling the Right Side
    // which modules have already been loaded.
    if (m_syncingForAttach == SYNC_STATE_1)
    {
        LOG((LF_CORDB, LL_INFO10000, "D::SSCIPCE: syncing for attach, sending "
             "current module set.\n"));

        HRESULT hr;
        BOOL fAtleastOneEventSent = FALSE;

        hr = IterateAppDomainsForAttach(ONLY_SEND_APP_DOMAIN_CREATE_EVENTS,
                                        &fAtleastOneEventSent, TRUE);
        _ASSERTE (fAtleastOneEventSent == TRUE || FAILED(hr));

        // update the state
        m_syncingForAttach = SYNC_STATE_2;
        LOG((LF_CORDB, LL_INFO10000, "Attach state is now %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));
    }

    if (m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_rightSideIsWin32Debugger)
    {

        // If the Right Side is the win32 debugger of this process, then we need to throw a special breakpoint exception
        // here instead of sending the sync complete event. The Right Side treats this the same as a sync complete
        // event, but its also able to suspend unmanaged threads quickly.
        //
        // Note: we reset the syncThreadIsLockFree event before sending the sync complete flare. This thread will set
        // this event once its released the debugger lock. This will prevent the Right Side from suspending this thread
        // until it has released the debugger lock.
        VERIFY(ResetEvent(m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_syncThreadIsLockFree));
        Debugger::NotifyRightSideOfSyncComplete();
    }
    else
    {
        // Send the Sync Complete event to the Right Side
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, DB_IPCE_SYNC_COMPLETE);
        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
    }

    // This thread has sent a sync complete event. Now, its simply
    // going to go and wait for a Continue message (essentially.)
    // However, if the helper thread isn't started up yet, then there
    // will be a problem: no Continue event will ever be received. So,
    // if there is no helper thread, then we need to do temporary
    // helper thread duty now.
    if (!m_pRCThread->IsRCThreadReady())
    {
        DoHelperThreadDuty(true);
    }
}


//
// TrapAllRuntimeThreads causes every Runtime thread that is executing
// in the EE to trap and send the at safe point event to the RC thread as
// soon as possible. It also sets the EE up so that Runtime threads that
// are outside of the EE will trap when they try to re-enter.
//
BOOL Debugger::TrapAllRuntimeThreads(AppDomain *pAppDomain, BOOL fHoldingThreadStoreLock)
{
    //@todo APPD if we want true isolation, remove this & finish the work
    pAppDomain = NULL;
    BOOL ret = FALSE;
    
    _ASSERTE(ThreadHoldsLock());

    // Only try to start trapping if we're not already trapping.
    if (m_trappingRuntimeThreads == FALSE)
    {
        LOG((LF_CORDB, LL_INFO10000,
             "D::TART: Trapping all Runtime threads.\n"));

        // There's no way that we should be stopped and still trying to call this function.
        _ASSERTE(!m_stopped);

        // Mark that we're trapping now.
        m_trappingRuntimeThreads = TRUE;

        // Take the thread store lock if we need to.
        if (!fHoldingThreadStoreLock)
        {
            LOG((LF_CORDB,LL_INFO1000, "About to lock thread Store\n"));
            ThreadStore::LockThreadStore(GCHeap::SUSPEND_FOR_DEBUGGER, FALSE);
            LOG((LF_CORDB,LL_INFO1000, "Locked thread store\n"));
        }

        // At this point, we know we have the thread store lock. We can therefore reset m_runtimeStoppedEvent, which may
        // have never been waited on. (If a Runtime thread trips in RareEnablePreemptiveGC, it will grab the thread
        // store lock but not call BlockAndReleaseTSLIfNecessary, which means the event remains high going into the new
        // trapping.) This can accidently let a thread release the TSL in BlockAndReleaseTSLIfNecessary prematurely.
        VERIFY(ResetEvent(m_runtimeStoppedEvent));
        
        // If all threads sync'd right away, go ahead and send now.
        if (g_pEEInterface->StartSuspendForDebug(pAppDomain, fHoldingThreadStoreLock))
        {
            LOG((LF_CORDB,LL_INFO1000, "Doin' the sync-complete!\n"));
            // Sets m_stopped = true...
            SendSyncCompleteIPCEvent();

            // Tell the caller that they own the thread store lock
            ret = TRUE;
        }
        else
        {
            LOG((LF_CORDB,LL_INFO1000, "NOT Doing' the sync thing\n"));
          
            // Otherwise, we are waiting for some number of threads to synchronize. Some of these threads will be
            // running in jitted code that is not interruptable. So we tell the RC Thread to check for such threads now
            // and then and help them get synchronized. (This is similar to what is done when suspending threads for GC
            // with the HandledJITCase() function.)
            m_pRCThread->WatchForStragglers();

            // Note, the caller shouldn't own the thread store lock in this case since the helper thread will need to be
            // able to take it to sweep threads.
            if (!fHoldingThreadStoreLock)
            {
                LOG((LF_CORDB,LL_INFO1000, "About to unlock thread store!\n"));
                ThreadStore::UnlockThreadStore();
                LOG((LF_CORDB,LL_INFO1000, "TART: Unlocked thread store!\n"));
            }
        }
    }

    return ret;
}


//
// ReleaseAllRuntimeThreads releases all Runtime threads that may be
// stopped after trapping and sending the at safe point event.
//
void Debugger::ReleaseAllRuntimeThreads(AppDomain *pAppDomain)
{
    //@todo APPD if we want true isolation, remove this & finish the work
    pAppDomain = NULL;
    
    // Make sure that we were stopped...
    _ASSERTE(m_trappingRuntimeThreads && m_stopped);
    _ASSERTE(ThreadHoldsLock());

    LOG((LF_CORDB, LL_INFO10000, "D::RART: Releasing all Runtime threads"
        "for AppD 0x%x.\n", pAppDomain));

    // Mark that we're on our way now...
    m_trappingRuntimeThreads = FALSE;
    m_stopped = FALSE;

    // Go ahead and resume the Runtime threads.
    g_pEEInterface->ResumeFromDebug(pAppDomain);
}


/******************************************************************************
 *
 ******************************************************************************/
bool Debugger::FirstChanceNativeException(EXCEPTION_RECORD *exception,
                                          CONTEXT *context, 
                                          DWORD code,
                                          Thread *thread)
{
    if (!CORDBUnrecoverableError(this))
        return DebuggerController::DispatchNativeException(exception, context, 
                                                           code, thread);
    else
        return false;
}

//bool Debugger::InterpretedBreak(Thread *thread, const BYTE *ip)
//{
//    if (!CORDBUnrecoverableError(this))
//        return (bool)DebuggerController::DispatchPatchOrSingleStep(thread, NULL, ip);
//    else
//        return false;
//}

/******************************************************************************
 *
 ******************************************************************************/
DWORD Debugger::GetPatchedOpcode(const BYTE *ip)
{
    if (!CORDBUnrecoverableError(this))
        return DebuggerController::GetPatchedOpcode(ip);
    else
        return 0;
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::TraceCall(const BYTE *code)
{
    if (!CORDBUnrecoverableError(this))
        DebuggerController::DispatchTraceCall(g_pEEInterface->GetThread(), code);
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::PossibleTraceCall(UMEntryThunk *pUMEntryThunk, Frame *pFrame)
{
    if (!CORDBUnrecoverableError(this))
        DebuggerController::DispatchPossibleTraceCall(g_pEEInterface->GetThread(), pUMEntryThunk, pFrame);
}

/******************************************************************************
 *
 ******************************************************************************/
bool Debugger::ThreadsAtUnsafePlaces(void)
{
    return (m_threadsAtUnsafePlaces != 0);
}

//
// SendBreakpoint is called by Runtime threads to send that they've
// hit a breakpoint to the Right Side.
//
void Debugger::SendBreakpoint(Thread *thread, CONTEXT *context, 
                              DebuggerBreakpoint *breakpoint)
{
    if (CORDBUnrecoverableError(this))
        return;

    LOG((LF_CORDB, LL_INFO10000, "D::SB: breakpoint BP:0x%x\n", breakpoint));

    _ASSERTE((g_pEEInterface->GetThread() &&
             !g_pEEInterface->GetThread()->m_fPreemptiveGCDisabled) ||
             g_fInControlC);

    _ASSERTE(ThreadHoldsLock());

    // Send a breakpoint event to the Right Side
    DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
    InitIPCEvent(ipce, 
                 DB_IPCE_BREAKPOINT, 
                 thread->GetThreadId(),
                 (void*) thread->GetDomain());
    ipce->BreakpointData.breakpointToken = breakpoint;
    _ASSERTE( breakpoint->m_pAppDomain == ipce->appDomainToken);

    m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
}

//
// SendRawUserBreakpoint is called by Runtime threads to send that
// they've hit a user breakpoint to the Right Side. This is the event
// send only part, since it can be called from a few different places.
//
void Debugger::SendRawUserBreakpoint(Thread *thread)
{
    if (CORDBUnrecoverableError(this))
        return;

    LOG((LF_CORDB, LL_INFO10000, "D::SRUB: user breakpoint\n"));

    _ASSERTE(!g_pEEInterface->IsPreemptiveGCDisabled());
    _ASSERTE(ThreadHoldsLock());

    // Send a breakpoint event to the Right Side
    DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
    InitIPCEvent(ipce, 
                 DB_IPCE_USER_BREAKPOINT, 
                 thread->GetThreadId(),
                 thread->GetDomain());

    m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
}

//
// SendStep is called by Runtime threads to send that they've
// completed a step to the Right Side.
//
void Debugger::SendStep(Thread *thread, CONTEXT *context, 
                        DebuggerStepper *stepper,
                        CorDebugStepReason reason)
{
    if (CORDBUnrecoverableError(this))
        return;
    
    LOG((LF_CORDB, LL_INFO10000, "D::SS: step:token:0x%x reason:0x%x\n",
        stepper, reason));

    _ASSERTE((g_pEEInterface->GetThread() &&
             !g_pEEInterface->GetThread()->m_fPreemptiveGCDisabled) ||
             g_fInControlC);

    _ASSERTE(ThreadHoldsLock());

    // Send a step event to the Right Side
    DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
    InitIPCEvent(ipce, 
                 DB_IPCE_STEP_COMPLETE, 
                 thread->GetThreadId(),
                 thread->GetDomain());
    ipce->StepData.stepperToken = stepper;
    ipce->StepData.reason = reason;
    m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

    stepper->Delete();
}

void Debugger::SendEncRemapEvents(UnorderedEnCRemapArray *pEnCRemapInfo)
{                            
    LOG((LF_CORDB, LL_INFO10000, "D::SEnCRE: pEnCRemapInfo:0x%x\n", pEnCRemapInfo));

    if (CORDBUnrecoverableError(this))
        return;

    _ASSERTE(ThreadHoldsLock());

    USHORT cEvents = pEnCRemapInfo->Count();
    EnCRemapInfo *rgRemap = pEnCRemapInfo->Table();
    DebuggerIPCEvent* ipce = NULL;
    
    for (USHORT i = 0; i < cEvents; i++)
    {
        DebuggerModule *pDM = (DebuggerModule *)rgRemap[i].m_debuggerModuleToken;
        MethodDesc* pFD = g_pEEInterface->LookupMethodDescFromToken(
                pDM->m_pRuntimeModule, 
                rgRemap[i].m_funcMetadataToken);
        _ASSERTE(pFD != NULL);
        SIZE_T nVersionCur = GetVersionNumber(pFD);

        if (m_pJitInfos != NULL && !m_pJitInfos->EnCRemapSentForThisVersion(pFD->GetModule(),
                                                    pFD->GetMemberDef(), 
                                                    nVersionCur))
        {
            ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
            InitIPCEvent(ipce, 
                         DB_IPCE_ENC_REMAP,
                         rgRemap[i].m_threadId,
                         rgRemap[i].m_pAppDomainToken);

            ipce->EnCRemap.fAccurate = rgRemap[i].m_fAccurate;
            ipce->EnCRemap.funcMetadataToken = rgRemap[i].m_funcMetadataToken ;
            ipce->EnCRemap.debuggerModuleToken = rgRemap[i].m_debuggerModuleToken;
            ipce->EnCRemap.RVA = rgRemap[i].m_RVA;
            ipce->EnCRemap.localSigToken = rgRemap[i].m_localSigToken;

            LOG((LF_CORDB, LL_INFO10000, "D::SEnCRE: Sending remap for "
                "unjitted %s::%s MD:0x%x, debuggermodule:0x%x nVerCur:0x%x\n", 
                pFD->m_pszDebugClassName, pFD->m_pszDebugMethodName,
                ipce->EnCRemap.funcMetadataToken, 
                ipce->EnCRemap.debuggerModuleToken,
                nVersionCur));
            
     
            m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
            // Ignore the return value, I guess...
            // @todo Should we make this into an actual continue if we 
            // can't send messages? Does it matter - will it get better, later?

            // Remember not to send this event again if we can help it...
            m_pJitInfos->SetVersionNumberLastRemapped(pFD->GetModule(),
                                                    pFD->GetMemberDef(),
                                                    nVersionCur);
        }
    }

    pEnCRemapInfo->Clear();
    
    LOG((LF_CORDB, LL_INFO10000, "D::SEnCRE: Cleared queue, sending"
        "SYNC_COMPLETE\n"));
    
    ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
    InitIPCEvent(ipce, DB_IPCE_SYNC_COMPLETE);
    m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
}

void Debugger::LockAndSendEnCRemapEvent(MethodDesc *pFD,
                                        BOOL fAccurate)
{
    if (CORDBUnrecoverableError(this))
        return;
    
    LOG((LF_CORDB, LL_INFO10000, "D::LASEnCRE:\n"));

    bool disabled;
    
    disabled =  g_pEEInterface->IsPreemptiveGCDisabled();

    if (disabled)
        g_pEEInterface->EnablePreemptiveGC();

    // Prevent other Runtime threads from handling events.
    BOOL threadStoreLockOwner = FALSE;
    
    LockForEventSending();
    
    if (CORDebuggerAttached())
    {
        // Send an EnC remap event to the Right Side.
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        Thread *thread = g_pEEInterface->GetThread();
        InitIPCEvent(ipce, 
                     DB_IPCE_ENC_REMAP,
                     GetCurrentThreadId(),
                     (void *) thread->GetDomain());
        ipce->EnCRemap.fAccurate = fAccurate;
        ipce->EnCRemap.funcMetadataToken = pFD->GetMemberDef();
        ipce->EnCRemap.localSigToken;

        Module *pRuntimeModule = pFD->GetModule();

        ipce->EnCRemap.debuggerModuleToken = g_pDebugger->LookupModule(
                                                pRuntimeModule,
                                                thread->GetDomain());

        // lotsa' args, just to get the local signature token, in case
        // we have to create the CordbFunction object on the right side.
        MethodDesc *pFDTemp;
        BYTE  *codeStartIgnore;
        unsigned int codeSizeIgnore;
        
        HRESULT hr = GetFunctionInfo(
             pRuntimeModule,
             ipce->EnCRemap.funcMetadataToken,
             &pFDTemp,
             &(ipce->EnCRemap.RVA),
             &codeStartIgnore,
             &codeSizeIgnore,
             &(ipce->EnCRemap.localSigToken) );

        _ASSERTE(pFD == pFDTemp);
        
        LOG((LF_CORDB, LL_INFO10000, "D::LASEnCRE: %s::%s fAcc:0x%x"
            "dmod:0x%x, methodDef:0x%x localsigtok:0x%x RVA:0x%x\n",
            pFD->m_pszDebugClassName, pFD->m_pszDebugMethodName,
            ipce->EnCRemap.fAccurate, ipce->EnCRemap.debuggerModuleToken,
            ipce->EnCRemap.funcMetadataToken, ipce->EnCRemap.localSigToken,
            ipce->EnCRemap.RVA));

        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(thread->GetDomain());
    }
    
    // Let other Runtime threads handle their events.
    UnlockFromEventSending();

    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);

    g_pEEInterface->DisablePreemptiveGC();

    if (!disabled)
        g_pEEInterface->EnablePreemptiveGC();
}

//
// Send a BreakpointSetError event to the Right Side if the given patch is for a breakpoint. Note: we don't care if this
// fails, there is nothing we can do about it anyway, and the breakpoint just wont hit.
//
void Debugger::LockAndSendBreakpointSetError(DebuggerControllerPatch *patch)
{
    if (CORDBUnrecoverableError(this))
        return;

    // Only do this for breakpoint controllers
    DebuggerController *controller = patch->controller;

    if (controller->GetDCType() != DEBUGGER_CONTROLLER_BREAKPOINT)
        return;
    
    LOG((LF_CORDB, LL_INFO10000, "D::LASBSE:\n"));

    bool disabled;
    
    disabled =  g_pEEInterface->IsPreemptiveGCDisabled();

    if (disabled)
        g_pEEInterface->EnablePreemptiveGC();

    // Prevent other Runtime threads from handling events.
    BOOL threadStoreLockOwner = FALSE;
    
    LockForEventSending();    
    
    if (CORDebuggerAttached())   
    {
        // Send a breakpoint set error event to the Right Side.
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        Thread *thread = g_pEEInterface->GetThread();
        InitIPCEvent(ipce, DB_IPCE_BREAKPOINT_SET_ERROR, GetCurrentThreadId(), (void *) thread->GetDomain());

        ipce->BreakpointSetErrorData.breakpointToken = controller;

        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(thread->GetDomain());
    } 
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::LASBSE: Skipping SendIPCEvent because RS detached."));
    }

    // Let other Runtime threads handle their events.
    UnlockFromEventSending();

    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);

    g_pEEInterface->DisablePreemptiveGC();

    if (!disabled)
        g_pEEInterface->EnablePreemptiveGC();
}

//
// Called from the controller to lock the debugger for event
// sending. This is called before controller events are sent, like
// breakpoint, step complete, and thread started.
//
// Note that it's possible that the debugger detached (and destroyed our IPC
// events) while we're waiting for our turn. 
// So Callers should check for that case.
void Debugger::LockForEventSending(BOOL fNoRetry)
{
    // Any thread that has locked for event sending can't be interrupted by breakpoints or exceptions when were interop
    // debugging. SetDebugCantStop(true) helps us remember that. This is removed in BlockAndReleaseTSLIfNecessary.
    if (g_pEEInterface->GetThread())
        g_pEEInterface->GetThread()->SetDebugCantStop(true);
    
retry:

    // Prevent other Runtime threads from handling events.
    DisableEventHandling();
    Lock();

    if (m_stopped && !fNoRetry)
    {
        Unlock();
        goto retry;
    }
}

//
// Called from the controller to unlock the debugger from event
// sending. This is called after controller events are sent, like
// breakpoint, step complete, and thread started.
//
void Debugger::UnlockFromEventSending()
{
    // Let other Runtime threads handle their events.
    EnableEventHandling();
    Unlock();
}

//
// Called by threads that are holding the thread store lock. We'll block until the Runtime is resumed, then release the
// thread store lock.
//
void Debugger::BlockAndReleaseTSLIfNecessary(BOOL fHoldingThreadStoreLock)
{
    // Do nothing if we're not holding the thread store lock.
    if (fHoldingThreadStoreLock)
    {
        // We set the syncThreadIsLockFree event here. If we're in this call, with fHoldingThreadStoreLock true, then it
        // means that we're on the thread that sent up the sync complete flare, and we've released the debuger lock. By
        // setting this event, we allow the Right Side to suspend this thread now. (Note: this is all for Win32
        // debugging support.)
        if (m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_rightSideIsWin32Debugger)
            VERIFY(SetEvent(m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_syncThreadIsLockFree));
        
        // If the debugger wants notification of when a thread is going to block than this is
        // also a place where we should notify it.
        // NOTE: if the debugger chooses not to return control of the thread when we've give a
        //       ReleaseAllRuntimeThreads callback then the runtime will hang because this thread
        //       holds the ThreadStore lock.
        IDebuggerThreadControl *pDbgThreadControl = CorHost::GetDebuggerThreadControl();

        if (pDbgThreadControl)
            pDbgThreadControl->ThreadIsBlockingForDebugger();

        // Wait for the Runtime to be resumed.
        WaitForSingleObject(m_runtimeStoppedEvent, INFINITE);

        // Release the thread store lock.
        ThreadStore::UnlockThreadStore();
    }

    // Any thread that has locked for event sending can't be interrupted by breakpoints or exceptions when were interop
    // debugging. SetDebugCantStop helps us remember that. This was set in LockForEventSending.
    if (g_pEEInterface->GetThread())
        g_pEEInterface->GetThread()->SetDebugCantStop(false);
}

//
// Called from the controller after all events have been sent for a
// thread to sync the process.
//
BOOL Debugger::SyncAllThreads()
{
    if (CORDBUnrecoverableError(this))
        return FALSE;
    
    LOG((LF_CORDB, LL_INFO10000, "D::SAT: sync all threads.\n"));

    Thread *pThread = g_pEEInterface->GetThread();
    _ASSERTE((pThread &&
             !pThread->m_fPreemptiveGCDisabled) ||
              g_fInControlC);

    _ASSERTE(ThreadHoldsLock());
    
    // Stop all Runtime threads
    return TrapAllRuntimeThreads(pThread->GetDomain());
}

/******************************************************************************
 *
 ******************************************************************************/
SIZE_T Debugger::GetVersionNumber(MethodDesc *fd)
{
    LockJITInfoMutex();

    SIZE_T ver;
    if (m_pJitInfos != NULL && 
        fd != NULL)
        ver = m_pJitInfos->GetVersionNumber(fd->GetModule(), fd->GetMemberDef());
    else
        ver = DebuggerJitInfo::DJI_VERSION_FIRST_VALID;

    UnlockJITInfoMutex();

    return ver;
}

/******************************************************************************
 * If nVersionRemapped == DJI_VERSION_INVALID (0), then we'll set the 
 * last remapped version to whatever the current version number is.
 ******************************************************************************/
void Debugger::SetVersionNumberLastRemapped(MethodDesc *fd, SIZE_T nVersionRemapped)
{
    _ASSERTE(nVersionRemapped >=  DebuggerJitInfo::DJI_VERSION_FIRST_VALID);
    if (fd == NULL)
        return;

    LockJITInfoMutex();
    VERIFY(SUCCEEDED(CheckInitJitInfoTable()));
    _ASSERTE(m_pJitInfos != NULL);
    m_pJitInfos->SetVersionNumberLastRemapped(fd->GetModule(), 
                                            fd->GetMemberDef(), 
                                            nVersionRemapped);
    UnlockJITInfoMutex();
}

/******************************************************************************
 * 
 ******************************************************************************/
HRESULT Debugger::IncrementVersionNumber(Module *pModule, mdMethodDef token)
{
    LOG((LF_CORDB,LL_INFO10000,"D::INV:About to increment version number\n"));

    LockJITInfoMutex();
    HRESULT hr = m_pJitInfos->IncrementVersionNumber(pModule, token);
    UnlockJITInfoMutex();

    return hr;
}


/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::LaunchDebuggerForUser (void)
{
    LOG((LF_CORDB, LL_INFO10000, "D::LDFU: Attaching Debugger.\n"));

    // Should we ask the user if they want to attach here?

    return(AttachDebuggerForBreakpoint(g_pEEInterface->GetThread(),
                                       L"Launch for user"));
}

/******************************************************************************
 *
 ******************************************************************************/
WCHAR *Debugger::GetDebuggerLaunchString(void)
{
    WCHAR *cmd = NULL;
    DWORD len;

    // First, try the environment...
    len = WszGetEnvironmentVariable(CorDB_ENV_DEBUGGER_KEY, NULL, 0);

    if (len > 0)
    {
        // Len includes the terminating null. Note: using (interopsafe) because we may be out of other memory, not
        // because we're on the helper thread.
        cmd = new (interopsafe) WCHAR[len];
            
        if (cmd)
        {
            DWORD newlen = WszGetEnvironmentVariable(CorDB_ENV_DEBUGGER_KEY, cmd, len);

            if (newlen == 0 || newlen > len) 
            {
                DeleteInteropSafe(cmd);
                cmd = NULL;
            }
        }
    }
    
    // Get the debugger string to launch out of the registry.
    if (cmd == NULL)
    {
        HKEY key;
        
        LONG result = WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, CorDB_REG_KEY, 0, KEY_READ, &key);

        if (result == ERROR_SUCCESS)
        {
            DWORD type;
            
            result = WszRegQueryValueEx(key, CorDB_REG_DEBUGGER_KEY, NULL, &type, NULL, &len);

            if ((result == ERROR_SUCCESS) && ((type == REG_SZ) || (type == REG_EXPAND_SZ)))
            {
                // Len includes the terminating null. Note: using (interopsafe) because we may be out of other memory,
                // not because we're on the helper thread.
                cmd = new (interopsafe) WCHAR[len];
            
                if (cmd)
                {
                    result = WszRegQueryValueEx(key, CorDB_REG_DEBUGGER_KEY, NULL, &type, (BYTE*)cmd, &len);

                    if (result != ERROR_SUCCESS)
                    {
                        DeleteInteropSafe(cmd);
                        cmd = NULL;
                    }
                }
            }

            RegCloseKey(key);
        }
    }

    return cmd;
}

//-----------------------------------------------------------------------------
// Is the guard page missing on this thread?
// Should only be called for managed threads handling a managed exception.
// If we're handling a stack overflow (ie, missing guard page), then another
// stack overflow will instantly terminate the process. In that case, do stack
// intensive stuff on the helper thread (which has lots of stack space). Only 
// problem is that if the faulting thread has a lock, the helper thread may
// get stuck.
// Serves as a hint whether we want to do a favor on the 
// faulting thread (preferred) or the helper thread (if low stack).
// See whidbey bug 127436.
//-----------------------------------------------------------------------------
bool IsGuardPageGone()
{    
    Thread * pThread = g_pEEInterface->GetThread();
    _ASSERTE(pThread != NULL); // This had better not be the helper thread either.

    // We're not going to be called for a unmanaged exception.
    // Should always have a managed thread, but just in case something really 
    // crazy happens, it's not worth an AV. (since this is just being used as a hint)
    if (pThread == NULL) 
        return false;    

    // Don't use pThread->IsGuardPageGone(), it's not accurate here.
    bool fGuardPageGone = (pThread->GuardPageOK() == 0);
    LOG((LF_CORDB, LL_INFO1000000, "D::IsGuardPageGone=%d\n", fGuardPageGone));  
    return fGuardPageGone;
}

// Proxy code for EDA
struct EnsureDebuggerAttachedParams
{
    Debugger*                   m_pThis;
    AppDomain *                 m_pAppDomain;
    LPWSTR                      m_wszAttachReason;
    HRESULT                     m_retval;
    EnsureDebuggerAttachedParams() : 
        m_pThis(NULL), m_pAppDomain(NULL), m_wszAttachReason(NULL), m_retval(E_FAIL) {}
};

// This is called by the helper thread
void EDAHelperStub(EnsureDebuggerAttachedParams * p)
{
    p->m_retval = p->m_pThis->EDAHelper(p->m_pAppDomain, p->m_wszAttachReason);
}

// This gets called just like the normal version, but it sends the call over to the helper thread
HRESULT Debugger::EDAHelperProxy(AppDomain *pAppDomain, LPWSTR wszAttachReason)
{
    if (!IsGuardPageGone())
        return EDAHelper(pAppDomain, wszAttachReason);

    EnsureDebuggerAttachedParams p;
    p.m_pThis = this;
    p.m_pAppDomain= pAppDomain;
    p.m_wszAttachReason = wszAttachReason;

    LOG((LF_CORDB, LL_INFO1000000, "D::EDAHelperProxy\n"));    
    m_pRCThread->DoFavor((DebuggerRCThread::FAVORCALLBACK) EDAHelperStub, &p);
    LOG((LF_CORDB, LL_INFO1000000, "D::EDAHelperProxy return\n"));    
    
    return p.m_retval;
}

// We can't have the helper thread execute all of EDA because it will deadlock.
// EDA will wait on m_exAttachEvent, which can only be set by the helper thread
// processing DB_IPCE_CONTINUE. But if the helper is stuck waiting in EDA, it
// can't handle the event and we deadlock.

// So, we factor out the stack intensive portion (CreateProcess & MessageBox)
// of EnsureDebuggerAttached. Conviently, this portion doesn't block 
// and so won't cause any deadlock.
HRESULT Debugger::EDAHelper(AppDomain *pAppDomain, LPWSTR wszAttachReason)
{
    HRESULT hr = S_OK;
    
    LOG((LF_CORDB, LL_INFO10000,
         "D::EDA: first process, initiating send\n"));

    DWORD pid = GetCurrentProcessId();

    // We provide a default debugger command, just for grins...
    WCHAR *defaultDbgCmd = L"cordbg.exe !a 0x%x";

    LOG((LF_CORDB, LL_INFO10000, "D::EDA: thread 0x%x is launching the debugger.\n", GetCurrentThreadId()));
    
    // Get the debugger to launch. realDbgCmd will point to a buffer that was allocated with (interopsafe) if
    // there is a user-specified debugger command string.
    WCHAR *realDbgCmd = GetDebuggerLaunchString();
    
    // Grab the ID for this appdomain.
    ULONG appId = pAppDomain->GetId();

    // Launch the debugger.
    DWORD len;
    
    if (realDbgCmd != NULL)
        len = wcslen(realDbgCmd)
              + 10                        // 10 for pid
              + 10                        // 10 for appid
              + wcslen(wszAttachReason)   // size of exception name
              + 10                        // 10 for handle value
              + 1;                        // 1 for null
    else
        len = wcslen(defaultDbgCmd) + 10 + 1;

    //
    // Note: We're using (interopsafe) allocations here not because the helper thread will ever run this code,
    // but because we may get here in low memory cases where our interop safe heap may still have a little room.
    //
    WCHAR *argsBuf = new (interopsafe) WCHAR[len];

    BOOL ret;
    STARTUPINFOW startupInfo = {0};
    startupInfo.cb = sizeof(STARTUPINFOW);
    PROCESS_INFORMATION processInfo = {0};

    if (argsBuf) 
    {

        if (realDbgCmd != NULL)
        {
            swprintf(argsBuf, realDbgCmd, pid, appId, wszAttachReason, m_exAttachAbortEvent);
        }
        else
            swprintf(argsBuf, defaultDbgCmd, pid, appId, wszAttachReason, m_exAttachAbortEvent);

        LOG((LF_CORDB, LL_INFO10000, "D::EDA: launching with command [%S]\n", argsBuf));

        // Grab the current directory.
        WCHAR *currentDir = NULL; // no current dir if this fails...
        WCHAR *currentDirBuf = new (interopsafe) WCHAR[MAX_PATH];
        
        if (currentDirBuf)
        {
            DWORD currentDirResult = WszGetCurrentDirectory(MAX_PATH, currentDirBuf);            
            // currentDirResult > MAX_PATH means buffer is not large enough
            if (currentDirResult && currentDirResult <= MAX_PATH) 
                currentDir = currentDirBuf;            
            
            // Create the debugger process
            ret = WszCreateProcess(NULL, argsBuf,
                                   NULL, NULL, false, 
                                   CREATE_NEW_CONSOLE,
                                   NULL, currentDir, 
                                   &startupInfo,
                                   &processInfo);
        } else {
            ret = FALSE;
        }

        DeleteInteropSafe(currentDirBuf);

    }
    else
    {
        ret = FALSE;
    }
    
    if (ret)
    {
        LOG((LF_CORDB, LL_INFO10000,
             "D::EDA: debugger launched successfully.\n"));

        // We don't need a handle to the debugger process.
        CloseHandle(processInfo.hProcess);
    }
    else
    {
        DWORD err = GetLastError();
        
        int result = CorMessageBox(NULL, IDS_DEBUG_JIT_DEBUGGER_UNAVAILABLE, IDS_DEBUG_NO_DEBUGGER_FOUND,
                                   MB_RETRYCANCEL | MB_ICONEXCLAMATION | COMPLUS_MB_SERVICE_NOTIFICATION,
                                   TRUE, err, err, argsBuf);
        
        // If the user wants to attach a debugger manually (they press Retry), then pretend as if the launch
        // succeeded.
        if (result == IDRETRY)
            hr = S_OK;
        else
            hr = E_ABORT;
    }

    DeleteInteropSafe(argsBuf);     // DeleteInteropSafe does handle NULL safely.
    DeleteInteropSafe(realDbgCmd);  // ditto.

    if (FAILED(hr))
    {
        LOG((LF_CORDB, LL_INFO10000,
             "D::EDA: debugger did not launch successfully.\n"));

        // Make sure that any other threads that entered leave
        VERIFY(SetEvent(m_exAttachAbortEvent));
    }

    return hr;
}


/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::EnsureDebuggerAttached(AppDomain *pAppDomain,
                                         LPWSTR wszAttachReason)
{    
    // We have a race in here between reseting the manual AttachEvent and waiting on it.
    // Auto events solve this problem. But we can't use an auto-event because we may
    // have multiple threads waiting on the same event.
    
    // @todo - m_exAttachAbortEvent should be a local variable in this function, 
    // not a field.
    
    LOG( (LF_CORDB,LL_INFO10000,"D::EDA\n") );

    HRESULT hr = S_OK;

    Lock();
    
    if (!m_debuggerAttached)
    {        

        // Remember that an exception is causing the attach.
        m_attachingForException = TRUE;

        // Only one thread throwing an exception when there is no
        // debugger attached should launch the debugger...
        m_exLock++;

        if (m_exLock == 1)
            hr = EDAHelperProxy(pAppDomain, wszAttachReason);

        if (SUCCEEDED(hr))
        {
            // Wait for the debugger to begin attaching to us.
            LOG((LF_CORDB, LL_INFO10000, "D::EDA: waiting on m_exAttachEvent "
                 "and m_exAttachAbortEvent\n"));

            HANDLE arrHandles[2] = {m_exAttachEvent, m_exAttachAbortEvent};

            // Let other threads in now
            Unlock();

            // Wait for one or the other to be set
            DWORD res = WaitForMultipleObjects(2, arrHandles, FALSE, INFINITE);

            // Finish up with lock
            Lock();

            // Indicate to the caller that the attach was aborted
            if (res == WAIT_OBJECT_0 + 1)
            {
                LOG((LF_CORDB, LL_INFO10000,
                     "D::EDA: m_exAttachAbortEvent set\n"));

                hr = E_ABORT;
            }

            // Otherwise, attach was successful
            else
            {
                _ASSERTE(res == WAIT_OBJECT_0 &&
                         "WaitForMultipleObjects failed!");

                // We can't reset the event here because some threads may 
                // be just about to wait on it. If we reset it before the 
                // other threads hit the wait, they'll block.

                // We have an innate race here that can't easily fix. The best
                // we can do is have a super small window (by moving the reset as
                // far out this making it very unlikely that a thread will 
                // hit the window.                

                LOG((LF_CORDB, LL_INFO10000, "D::EDA: m_exAttachEvent set\n"));
            }
        }

        // If this is the last thread, then reset the attach logic.
        m_exLock--;

        if (m_exLock == 0 && hr == E_ABORT)
        {
            // Reset the attaching logic.
            m_attachingForException = FALSE;
            VERIFY(ResetEvent(m_exAttachAbortEvent));
        }
        
    }
    else
    {
        hr = S_FALSE;
    }

    Unlock();

    LOG( (LF_CORDB, LL_INFO10000, "D::EDA:Leaving\n") );
    return hr;
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::FinishEnsureDebuggerAttached()
{
    HRESULT hr = S_OK;

    LOG( (LF_CORDB,LL_INFO10000,"D::FEDA\n") );
    if (!m_debuggerAttached)
    {
        LOG((LF_CORDB, LL_INFO10000, "D::SE: sending sync complete.\n"));
        
        _ASSERTE(m_syncingForAttach != SYNC_STATE_0);
        
        // Send the Sync Complete event next...
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, DB_IPCE_SYNC_COMPLETE);
        hr = m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
        LOG( (LF_CORDB,LL_INFO10000,"D::FEDA: just sent SYNC_COMPLETE\n") );

        // Attach is complete now.
        LOG((LF_CORDB, LL_INFO10000, "D::FEDA: Attach Complete!"));
        g_pEEInterface->MarkDebuggerAttached();
        m_syncingForAttach = SYNC_STATE_0;
        LOG((LF_CORDB, LL_INFO10000, "Attach state is now %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));

        m_debuggerAttached = TRUE;
        m_attachingForException = FALSE;
    }
    LOG( (LF_CORDB,LL_INFO10000,"D::FEDA leaving\n") );

    _ASSERTE(SUCCEEDED(hr) && "FinishEnsureDebuggerAttached failed.");
    return (hr);
}

//
// SendException is called by Runtime threads to send that they've hit an exception to the Right Side.
//
HRESULT Debugger::SendException(Thread *thread, bool firstChance, bool continuable, bool fAttaching)
{
    LOG((LF_CORDB, LL_INFO10000, "D::SendException\n"));

    if (CORDBUnrecoverableError(this))
        return (E_FAIL);

    // Mark if we're at an unsafe place.
    bool atSafePlace = g_pDebugger->IsThreadAtSafePlace(thread);

    if (!atSafePlace)
        g_pDebugger->IncThreadsAtUnsafePlaces();

    // Is preemptive GC disabled on entry here?
    bool disabled = g_pEEInterface->IsPreemptiveGCDisabled();

    // We can only access the exception object while preemptive GC is disabled, so disable it if we need to.
    if (!disabled)
        g_pEEInterface->DisablePreemptiveGC();

    // Grab the exception name from the current exception object to pass to the JIT attach.
    OBJECTHANDLE *h = g_pEEInterface->GetThreadException(thread);
    OBJECTREF *o = *((OBJECTREF**)h);
    LPWSTR exceptionName;

    LPWSTR buf = new (interopsafe) WCHAR[MAX_CLASSNAME_LENGTH];
    
    if (o != NULL && *o != NULL && buf)
    {
        EEClass *c = (*o)->GetMethodTable()->GetClass();
        exceptionName = c->_GetFullyQualifiedNameForClass(buf, MAX_CLASSNAME_LENGTH);
    }
    else
        exceptionName = L"<Unknown exception>";

    // We have to send enabled, so enable now.
    g_pEEInterface->EnablePreemptiveGC();
    
    // If no debugger is attached, then launch one to attach to us.  Ignore hr: if EDA fails, app suspends in EDA &
    // waits for a debugger to attach to us.

    // For V2, we'll want to get this call to EDA out of here and move it up to where
    // we decide we're attaching.
    HRESULT hr = S_FALSE; // Return value of EDA if debugger already attached
    
    if (fAttaching)
    {
        hr = EnsureDebuggerAttached(thread->GetDomain(), exceptionName);
    }

    exceptionName = NULL;               // We can delete the buffer now.
    DeleteInteropSafe(buf);             

    BOOL threadStoreLockOwner = FALSE;
    
    if (SUCCEEDED(hr))
    {
        // Prevent other Runtime threads from handling events.

        // NOTE: if EnsureDebuggerAttached returned S_FALSE, this means that a debugger was already attached and
        // LockForEventSending should behave as normal.  If there was no debugger attached, then we have a special case
        // where this event is a part of debugger attaching and we've previously sent a sync complete event which means
        // that LockForEventSending will retry until a continue is called - however, with attaching logic the previous
        // continue didn't enable event handling and didn't continue the process - it's waiting for this event to be
        // sent, so we do so even if the process appears to be stopped.
        LockForEventSending(hr == S_OK);

        // In the JITattach case, an exception may be sent before the debugger is fully attached.        
        if (CORDebuggerAttached() || fAttaching)   
        {

            // Send an exception event to the Right Side
            DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
            InitIPCEvent(ipce, DB_IPCE_EXCEPTION, thread->GetThreadId(), (void*) thread->GetDomain());
            ipce->Exception.exceptionHandle = (void *) g_pEEInterface->GetThreadException(thread);
            ipce->Exception.firstChance = firstChance;
            ipce->Exception.continuable = continuable;

            LOG((LF_CORDB, LL_INFO10000, "D::SE: sending exception event from "
                "Thread:0x%x AD 0x%x.\n", ipce->threadId, ipce->appDomainToken));
            hr = m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

            if (SUCCEEDED(hr))
            {
                // Stop all Runtime threads
                threadStoreLockOwner = TrapAllRuntimeThreads(thread->GetDomain());

                // If we're still syncing for attach, send sync complete now and mark that the debugger has completed
                // attaching.
                if (fAttaching) 
                {
                    hr = FinishEnsureDebuggerAttached();
                }
            }

            _ASSERTE(SUCCEEDED(hr) && "D::SE: Send exception event failed.");

        }
        else 
        {
            LOG((LF_CORDB,LL_INFO1000, "D:SE: Skipping SendIPCEvent because RS detached."));
        }
        
        // Let other Runtime threads handle their events.
        UnlockFromEventSending();
    }

    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
    // Disable PGC
    g_pEEInterface->DisablePreemptiveGC();

    // If we weren't at a safe place when we enabled PGC, then go ahead and unmark that fact now that we've successfully
    // disabled.
    if (!atSafePlace)
        g_pDebugger->DecThreadsAtUnsafePlaces();

    //
    // Note: if there is a filter context installed, we may need remove it, do the eval, then put it back. I'm not 100%
    // sure which yet... it kinda depends on whether or not we really need the filter context updated due to a
    // collection during the func eval...
    //
    // If we need to do a func eval on this thread, then there will be a pending eval registered for this thread. We'll
    // loop so long as there are pending evals registered. We block in FuncEvalHijackWorker after sending up the
    // FuncEvalComplete event, so if the user asks for another func eval then there will be a new pending eval when we
    // loop and check again.
    //
    DebuggerPendingFuncEval *pfe;
    bool needRethrow = false;
    
    while (m_pPendingEvals != NULL && (pfe = m_pPendingEvals->GetPendingEval(thread)) != NULL)
    {
        DebuggerEval *pDE = pfe->pDE;

        _ASSERTE(pDE->m_evalDuringException);

        // Remove the pending eval from the hash. This ensures that if we take a first chance exception during the eval
        // that we can do another nested eval properly.
        m_pPendingEvals->RemovePendingEval(thread);

        // Go ahead and do the pending func eval.
        void *ret = Debugger::FuncEvalHijackWorker(pDE);

        // The return value should be NULL when FuncEvalHijackWorker is called as part of an exception.
        _ASSERTE(ret == NULL);

        // If this eval ended in a ThreadAbortException, remember that we need to rethrow it after all evals are done.
        needRethrow |= pDE->m_rethrowAbortException;
    }

    // If we need to re-throw a ThreadAbortException, go ahead and do it now.
    if (needRethrow)
        thread->UserAbort(NULL);

    if (!disabled)
        g_pEEInterface->EnablePreemptiveGC();

    return (hr);
}


//
// FirstChanceManagedException is called by Runtime threads when an exception is first detected, but before any filters have
// been run.
//
bool Debugger::FirstChanceManagedException(bool continuable, CONTEXT *pContext)
{
    LOG((LF_CORDB, LL_INFO10000, "D::FCE: First chance exception, continuable:0x%x\n", continuable));

    Thread *thread = g_pEEInterface->GetThread();

#ifdef _DEBUG
    static ConfigDWORD d_fce(L"D::FCE", 0);
	if (d_fce.val())
        _ASSERTE(!"Stop in Debugger::FirstChanceManagedException?");
#endif

    SendException(thread, true, continuable, FALSE);
    
    if (continuable && g_pEEInterface->IsThreadExceptionNull(thread))
        return true;

    return false;
}

//
// ExceptionFilter is called by the Runtime threads when an exception
// is being processed.
//
void Debugger::ExceptionFilter(BYTE *pStack, MethodDesc *fd, SIZE_T offset)
{
    LOG((LF_CORDB,LL_INFO10000, "D::EF: pStack:0x%x MD: %s::%s, offset:0x%x\n",
        pStack, fd->m_pszDebugClassName, fd->m_pszDebugMethodName, offset));

    //
    // !!! Need to think through logic for when to step through filter code - 
    // perhaps only during a "step in".
    //

    // 
    // !!! Eventually there may be some weird mechanics introduced for
    // returning from the filter that we have to understand.  For now we should
    // be able to proceed normally.
    // 
    
    DebuggerController::DispatchUnwind(g_pEEInterface->GetThread(), 
                                       fd, offset, pStack, STEP_EXCEPTION_FILTER);
    
}


//
// ExceptionHandle is called by Runtime threads when an exception is
// being handled.
//
void Debugger::ExceptionHandle(BYTE *pStack, MethodDesc *fd, SIZE_T offset)
{   
    
    DebuggerController::DispatchUnwind(g_pEEInterface->GetThread(), 
                                       fd, offset, pStack, STEP_EXCEPTION_HANDLER);
    
}

//
// ExceptionCLRCatcherFound() is called by Runtime when we determine that we're crossing back into unmanaged code and
// we're going to turn an exception in a HR.
//
void Debugger::ExceptionCLRCatcherFound()
{
    DebuggerController::DispatchCLRCatch(g_pEEInterface->GetThread());
}

/******************************************************************************
 *
 ******************************************************************************/
LONG Debugger::LastChanceManagedException(EXCEPTION_RECORD *pExceptionRecord, 
                                          CONTEXT *pContext,
                                          Thread *pThread,
                                          UnhandledExceptionLocation location)
{
    LOG((LF_CORDB, LL_INFO10000, "D::LastChanceManagedException\n"));

    if (CORDBUnrecoverableError(this))
        return ExceptionContinueSearch;

    // We don't do anything on the second pass
    if ((pExceptionRecord->ExceptionFlags & EXCEPTION_UNWINDING) != 0)
        return ExceptionContinueSearch;

    // Let the controllers have a chance at it - this may be the only handler which can catch the exception if this is a
    // native patch.
   
    if (pThread != NULL && m_debuggerAttached && DebuggerController::DispatchNativeException(pExceptionRecord, pContext, 
                                                                                             pExceptionRecord->ExceptionCode, 
                                                                                             pThread))
        return ExceptionContinueExecution;

    // If this is a non-EE exception, don't do anything.
    if (pThread == NULL || g_pEEInterface->IsThreadExceptionNull(pThread))
        return ExceptionContinueSearch;

    // Otherwise, run our last chance exception logic
    ATTACH_ACTION action = ATTACH_NO;

    if (location & DefaultDebuggerAttach)
    {
        // Supress the display of the unmanaged unhandled exception dialog now. 
        // When we return from this function into EE code, the EE will pass the 
        // exception onto the OS last chance exception handler. We don't what that 
        // to display a dialogue because we decide in this function, via the registry
        // or a pop-up, what to do. We don't want to have the user prompted again
        // after we decide what to do here.
        SetErrorMode(SEM_NOGPFAULTERRORBOX);            
    }

    if (m_debuggerAttached || ((action = ShouldAttachDebuggerProxy(false, location)) == ATTACH_YES))
    {
        LOG((LF_CORDB, LL_INFO10000, "D::BEH ... debugger attached.\n"));

        Thread *thread = g_pEEInterface->GetThread();

        // ExceptionFlags is 0 for continuable, EXCEPTION_NONCONTINUABLE otherwise
        bool continuable = (pExceptionRecord->ExceptionFlags == 0);

        LOG((LF_CORDB, LL_INFO10000, "D::BEH ... sending exception.\n"));

        // We pass the attaching status to SendException so that it knows
        // whether to attach a debugger or not. We should really do the 
        // attach stuff out here and not bother with the flag.
        SendException(thread, false, continuable, action == ATTACH_YES);

        if (continuable && g_pEEInterface->IsThreadExceptionNull(thread))
            return ExceptionContinueExecution;
    }
    else
    {
        // Note: we don't do anything on NO or TERMINATE. We just return to the exception logic, which will abort the
        // app or not depending on what the CLR impl decides is appropiate.
        _ASSERTE(action == ATTACH_TERMINATE || action == ATTACH_NO);
    }

    return ExceptionContinueSearch;
}



// This function checks the registry for the debug launch setting upon encountering an exception or breakpoint.
DebuggerLaunchSetting Debugger::GetDbgJITDebugLaunchSetting(void)
{
    // Query for the value "DbgJITDebugLaunchSetting"
    DWORD dwSetting = REGUTIL::GetConfigDWORD(CorDB_REG_QUESTION_KEY, 0);

    DebuggerLaunchSetting ret = (DebuggerLaunchSetting)dwSetting;
    
    return ret;
}


//
// NotifyUserOfFault notifies the user of a fault (unhandled exception
// or user breakpoint) in the process, giving them the option to
// attach a debugger or terminate the application.
//
int Debugger::NotifyUserOfFault(bool userBreakpoint, DebuggerLaunchSetting dls)
{
    LOG((LF_CORDB, LL_INFO1000000, "D::NotifyUserOfFault\n"));

    int result = IDCANCEL;

    if (!m_debuggerAttached)
    {
        DWORD pid;
        DWORD tid;
        
        pid = GetCurrentProcessId();
        tid = GetCurrentThreadId();

        // We don't want to popup the message box if we're running as a service that's not allowed to interact with the
        // desktop. If that's the case, we'll just leave MB_SERVICE_NOTIFICATION out of the flags. This will cause
        // WszMessageBoxInternal to log the message to the NT event log and return IDABORT. Note: we go ahead and popup
        // the dialog box, however, if the user has specified that we should ask even when its a service.
        DWORD flags = 0;
        
        if (RunningInteractive() || (dls & DLS_ASK_WHEN_SERVICE))
            flags = COMPLUS_MB_SERVICE_NOTIFICATION;
        
        if (userBreakpoint)
        {
            result = CorMessageBox(NULL, IDS_DEBUG_USER_BREAKPOINT_MSG, IDS_DEBUG_SERVICE_CAPTION,
                                   MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION | flags, TRUE, pid, pid, tid, tid);
        }
        else
        {
            result = CorMessageBox(NULL, IDS_DEBUG_UNHANDLED_EXCEPTION_MSG, IDS_DEBUG_SERVICE_CAPTION,
                                   MB_OKCANCEL | MB_ICONEXCLAMATION | flags, TRUE, pid, pid, tid, tid);
        }
    }

    LOG((LF_CORDB, LL_INFO1000000, "D::NotifyUserOfFault left\n"));
    return result;
}


// Proxy for ShouldAttachDebugger
struct ShouldAttachDebuggerParams {
    Debugger*                   m_pThis;
    bool                        m_fIsUserBreakpoint;
    UnhandledExceptionLocation  m_location;
    Debugger::ATTACH_ACTION     m_retval;
};

// This is called by the helper thread
void ShouldAttachDebuggerStub(ShouldAttachDebuggerParams * p)
{
    p->m_retval = p->m_pThis->ShouldAttachDebugger(p->m_fIsUserBreakpoint, p->m_location);
}

// This gets called just like the normal version, but it sends the call over to the helper thread
Debugger::ATTACH_ACTION Debugger::ShouldAttachDebuggerProxy(bool fIsUserBreakpoint, UnhandledExceptionLocation location)
{
    if (!IsGuardPageGone())
        return ShouldAttachDebugger(fIsUserBreakpoint, location);

    ShouldAttachDebuggerParams p;
    p.m_pThis = this;
    p.m_fIsUserBreakpoint = fIsUserBreakpoint;
    p.m_location = location;

    LOG((LF_CORDB, LL_INFO1000000, "D::SADProxy\n"));
    m_pRCThread->DoFavor((DebuggerRCThread::FAVORCALLBACK) ShouldAttachDebuggerStub, &p);
    LOG((LF_CORDB, LL_INFO1000000, "D::SADProxy return %d\n", p.m_retval));
    
    return p.m_retval;
}

// Returns true if the debugger is not attached and DbgJITDebugLaunchSetting is set to either ATTACH_DEBUGGER or
// ASK_USER and the user request attaching.
Debugger::ATTACH_ACTION Debugger::ShouldAttachDebugger(bool fIsUserBreakpoint, UnhandledExceptionLocation location)
{
    LOG((LF_CORDB, LL_INFO1000000, "D::SAD\n"));

    // If the debugger is already attached, not necessary to re-attach
    if (m_debuggerAttached)
        return ATTACH_NO;

    // Check if the user has specified a seting in the registry about what he wants done when an unhandled exception
    // occurs.
    DebuggerLaunchSetting dls = GetDbgJITDebugLaunchSetting();   

    // First, we just don't attach if the location of the exception doesn't fit what the user is looking for. Note: a
    // location of 0 indicates none specified, in which case we only let locations specified in DefaultDebuggerAttach
    // through. This is for backward compatability and convience.
    UnhandledExceptionLocation userLoc = (UnhandledExceptionLocation)(dls >> DLS_LOCATION_SHIFT);

    if ((userLoc == 0) && !(location & DefaultDebuggerAttach))
    {
        return ATTACH_NO;
    }
    else if ((userLoc != 0) && !(userLoc & location))
    {
        return ATTACH_NO;
    }

    // Now that we've passed the location test, how does the user want to attach?
    if (dls & DLS_ATTACH_DEBUGGER)
    {
        // Attach without asking the user...
        return ATTACH_YES;
    }
    else if (dls & DLS_TERMINATE_APP)
    {
        // We just want to ignore user breakpoints if the registry says to "terminate" the app.
        if (fIsUserBreakpoint)
            return ATTACH_NO;
        else
            return ATTACH_TERMINATE;
    }
    else
    {
        // Only ask the user once if they wish to attach a debugger.  This is because LastChanceManagedException can be called
        // twice, which causes ShouldAttachDebugger to be called twice, which causes the user to have to answer twice.
        static BOOL s_fHasAlreadyAsked = FALSE;
        static ATTACH_ACTION s_action;

        // This lock is also part of the above hack.
        Lock();

        // We always want to ask about user breakpoints!
        if (!s_fHasAlreadyAsked || fIsUserBreakpoint)
        {
            if (!fIsUserBreakpoint)
                s_fHasAlreadyAsked = TRUE;
            
            // Ask the user if they want to attach
            int iRes = NotifyUserOfFault(fIsUserBreakpoint, dls);

            // If it's a user-defined breakpoint, they must hit Retry to launch
            // the debugger.  If it's an unhandled exception, user must press
            // Cancel to attach the debugger.
            if ((iRes == IDCANCEL) || (iRes == IDRETRY))
                s_action = ATTACH_YES;

            else if ((iRes == IDABORT) || (iRes == IDOK))
                s_action = ATTACH_TERMINATE;

            else
                s_action = ATTACH_NO;
        }

        Unlock();

        return s_action;
    }
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::FixupEnCInfo(EnCInfo *info, 
                            UnorderedEnCErrorInfoArray *pEnCError)
{
    LOG((LF_CORDB, LL_INFO1000000, "D::FEnCI\n"));

    TranslateDebuggerTokens(info, pEnCError);

    FixupILMapPointers(info, pEnCError);
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::FixupILMapPointers(EnCInfo *info, 
                                  UnorderedEnCErrorInfoArray *pEnCError)
{
    LOG((LF_CORDB,LL_INFO100000, "D:FILMP: given 0x%x snapshots\n",
        info->count));

    EnCEntry *rgEntry = (EnCEntry *)((BYTE*)info + sizeof(EnCInfo));

    for(size_t iSnapshot = 0; iSnapshot < info->count; iSnapshot++)
    {
        int cILMaps;
        UnorderedILMap *rgILMapEntry = NULL;  

        // Get the array of UnorderedILMap tuples for this snapshot
        rgILMapEntry = (UnorderedILMap *)
            ((BYTE*)info + rgEntry[iSnapshot].offset +
             rgEntry[iSnapshot].peSize +
             rgEntry[iSnapshot].symSize +
             sizeof(int));

        // The count is right behind it in memory
        cILMaps = *(int*)( ((BYTE*)rgILMapEntry) - sizeof(int) );

        // pbCur will point to the next actual IL map, which occurs in memory
        // immediately after the array, in the same order as the array 
        // entries.
        BYTE *pbCur = (BYTE *)rgILMapEntry + sizeof(UnorderedILMap)*cILMaps;

        LOG((LF_CORDB,LL_INFO100000, "D:FILMP:0x%x IL Maps\n", cILMaps));
            
        for( int iILMap = 0; iILMap < cILMaps; iILMap++)
        {
            LOG((LF_CORDB,LL_INFO100000, "D:FILMP:IL Map 0x%x, starts at "
                "0x%x\n", iILMap, pbCur));
                
            rgILMapEntry[iILMap].pMap = (COR_IL_MAP *)pbCur;
            pbCur += rgILMapEntry[iILMap].cMap * sizeof(COR_IL_MAP);

            //while we're at it, double check that this thing is sorted.
            _ASSERTE( (iILMap>0)?
                      (rgILMapEntry[iILMap].mdMethod > rgILMapEntry[iILMap-1].mdMethod):
                      (true) );
        }
    }
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::TranslateDebuggerTokens(EnCInfo *info, 
                                       UnorderedEnCErrorInfoArray *pEnCError)
{
    SIZE_T i;
    EnCEntry *entries;
    
    entries = (EnCEntry *)(info + 1);

    for(i = 0; i < info->count; i++)
    {
        // Get the current DebuggerModule.
        DebuggerModule *dbgtoken = entries[i].dbgmodule;

        // Set the according VM Module entry.
        entries[i].module = dbgtoken->m_pRuntimeModule;
        _ASSERTE(entries[i].module);
    }
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::AttachDebuggerForBreakpoint(Thread *thread,
                                              WCHAR *wszLaunchReason)
{
    // Mark if we're at an unsafe place.
    bool atSafePlace = g_pDebugger->IsThreadAtSafePlace(thread);

    if (!atSafePlace)
        g_pDebugger->IncThreadsAtUnsafePlaces();

    // Enable preemptive GC...
    bool disabled = g_pEEInterface->IsPreemptiveGCDisabled();

    if (disabled)
        g_pEEInterface->EnablePreemptiveGC();
    
    // If no debugger is attached, then launch one to attach to us.
    HRESULT hr = EnsureDebuggerAttached(thread->GetDomain(), wszLaunchReason);

    BOOL threadStoreLockOwner = FALSE;
    
    if (SUCCEEDED(hr))
    {
        // Prevent other Runtime threads from handling events.\

        // NOTE: if EnsureDebuggerAttached returned S_FALSE, this means that
        // a debugger was already attached and LockForEventSending should
        // behave as normal.  If there was no debugger attached, then we have
        // a special case where this event is a part of debugger attaching and
        // we've previously sent a sync complete event which means that
        // LockForEventSending will retry until a continue is called - however,
        // with attaching logic the previous continue didn't enable event
        // handling and didn't continue the process - it's waiting for this
        // event to be sent, so we do so even if the process appears to be
        // stopped.

        LockForEventSending(hr == S_OK);
        
        // Send a user breakpoint event to the Right Side
        SendRawUserBreakpoint(thread);

        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(thread->GetDomain());

        // If we're still syncing for attach, send sync complete now and
        // mark that the debugger has completed attaching.
        hr = FinishEnsureDebuggerAttached();
        
        // Let other Runtime threads handle their events.
        UnlockFromEventSending();
    }

    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
    // Set back to disabled GC
    g_pEEInterface->DisablePreemptiveGC();

    if (!disabled)
        g_pEEInterface->EnablePreemptiveGC();

    if (!atSafePlace)
        g_pDebugger->DecThreadsAtUnsafePlaces();

    return (hr);
}


//
// SendUserBreakpoint is called by Runtime threads to send that they've hit
// a user breakpoint to the Right Side.
//
void Debugger::SendUserBreakpoint(Thread *thread)
{
    if (CORDBUnrecoverableError(this))
        return;

    // Ask the user if they want to attach the debugger
    ATTACH_ACTION dbgAction;
    
    // If user wants to attach the debugger, do so
    if (m_debuggerAttached || ((dbgAction = ShouldAttachDebugger(true, ProcessWideHandler)) == ATTACH_YES))
    {
        _ASSERTE(g_pEEInterface->GetThreadFilterContext(thread) == NULL);
        _ASSERTE(!ISREDIRECTEDTHREAD(thread));

        if (m_debuggerAttached)
        {
            // A debugger is already attached, so setup a DebuggerUserBreakpoint controller to get us out of the helper
            // that got us here. The DebuggerUserBreakpoint will call AttachDebuggerForBreakpoint for us when we're out
            // of the helper. The controller will delete itself when its done its work.
            DebuggerUserBreakpoint *ub = new (interopsafe) DebuggerUserBreakpoint(thread);
        }
        else
        {
            // No debugger attached, so go ahead and just try to send the user breakpoint
            // event. AttachDebuggerForBreakpoint will ensure that the debugger is attached before sending the event.
            HRESULT hr = AttachDebuggerForBreakpoint(thread, L"Launch for user");
            _ASSERTE(SUCCEEDED(hr) || hr == E_ABORT);
        }
    }
    else if (dbgAction == ATTACH_TERMINATE)
    {
        // ATTACH_TERMINATE indicates the the user wants to terminate the app.
        LOG((LF_CORDB, LL_INFO10000, "D::SUB: terminating this process due to user request\n"));

        TerminateProcess(GetCurrentProcess(), 0);
        _ASSERTE(!"Should never reach this point.");
    }
    else
    {
        _ASSERTE(dbgAction == ATTACH_NO);
    }
}


// @mfunc void|Debugger|ThreadCreated| ThreadCreated is called when 
// a new Runtime thread has been created, but before its ever seen 
// managed code.  This is a callback invoked by the EE into the Debugger.
// This will create a DebuggerThreadStarter patch, which will set
// a patch at the first instruction in the managed code.  When we hit
// that patch, the DebuggerThreadStarter will invoke ThreadStarted, below.
//
// @parm Thread*|pRuntimeThread|The EE Thread object representing the
//      runtime thread that has just been created.
void Debugger::ThreadCreated(Thread* pRuntimeThread)
{
    if (CORDBUnrecoverableError(this))
        return;

    LOG((LF_CORDB, LL_INFO100, "D::TC: thread created for 0x%x. ******\n",
         pRuntimeThread->GetThreadId()));

    // Create a thread starter and enable its WillEnterManaged code
    // callback. This will cause the starter to trigger once the
    // thread has hit managed code, which will cause
    // Debugger::ThreadStarted() to be called.  NOTE: the starter will
    // be deleted automatically when its done its work.
    DebuggerThreadStarter *starter = new (interopsafe) DebuggerThreadStarter(pRuntimeThread);

    if (!starter)
    {
        CORDBDebuggerSetUnrecoverableWin32Error(this, 0, false);
        return;
    }
    
    starter->EnableTraceCall(NULL);
}

    
// @mfunc void|Debugger|ThreadStarted|ThreadStarted is called when 
// a new Runtime thread has reached its first managed code. This is
// called by the DebuggerThreadStarter patch's SendEvent method.
//
// @parm Thread*|pRuntimeThread|The EE Thread object representing the
//      runtime thread that has just hit managed code.
void Debugger::ThreadStarted(Thread* pRuntimeThread,
                             BOOL fAttaching)
{
    if (CORDBUnrecoverableError(this))
        return;

    LOG((LF_CORDB, LL_INFO100, "D::TS: thread attach : ID=%#x AD:%#x isAttaching:%d.\n",
         pRuntimeThread->GetThreadId(), pRuntimeThread->GetDomain(), fAttaching));

    //
    // If we're attaching, then we only need to send the event. We
    // don't need to disable event handling or lock the debugger
    // object.
    //
#ifdef _DEBUG
    if (!fAttaching)
    {
        _ASSERTE((g_pEEInterface->GetThread() &&
                 !g_pEEInterface->GetThread()->m_fPreemptiveGCDisabled) ||
                 g_fInControlC);
        _ASSERTE(ThreadHoldsLock());
    }
#endif

    DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
    InitIPCEvent(ipce, 
                 DB_IPCE_THREAD_ATTACH, 
                 pRuntimeThread->GetThreadId(),
                 (void *) pRuntimeThread->GetDomain());
    ipce->ThreadAttachData.debuggerThreadToken = (void*) pRuntimeThread;
    ipce->ThreadAttachData.threadHandle = pRuntimeThread->GetThreadHandle();
    ipce->ThreadAttachData.firstExceptionHandler = (void *)pRuntimeThread->GetTEB();
    ipce->ThreadAttachData.stackBase = pRuntimeThread->GetCachedStackBase();
    ipce->ThreadAttachData.stackLimit = pRuntimeThread->GetCachedStackLimit();
    m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

    if (!fAttaching)
    {
        //
        // Well, if this thread got created _after_ we started sync'ing
        // then its Runtime thread flags don't have the fact that there
        // is a debug suspend pending. We need to call over to the
        // Runtime and set the flag in the thread now...
        //
        if (m_trappingRuntimeThreads)
            g_pEEInterface->MarkThreadForDebugSuspend(pRuntimeThread);
    }
}

// DetachThread is called by Runtime threads when they are completing
// their execution and about to be destroyed.
//
void Debugger::DetachThread(Thread *pRuntimeThread, BOOL fHoldingThreadstoreLock)
{
    if (CORDBUnrecoverableError(this))
        return;

    if (m_ignoreThreadDetach)
        return;

    // At this point, we should never be called while holding the thread store lock. This parameter should be removed in
    // Beta 2.
    //
    // -- Fri Oct 13 11:10:23 2000
    _ASSERTE(!fHoldingThreadstoreLock);
    _ASSERTE (pRuntimeThread != NULL);

    if (!g_fEEShutDown && !IsDebuggerAttachedToAppDomain(pRuntimeThread))
        return;

    LOG((LF_CORDB, LL_INFO100, "D::DT: thread detach : ID=%#x AD:%#x.\n",
         pRuntimeThread->GetThreadId(), pRuntimeThread->GetDomain()));

    bool disabled = g_pEEInterface->IsPreemptiveGCDisabled();

    if (disabled)
        g_pEEInterface->EnablePreemptiveGC();

    // Prevent other Runtime threads from handling events.
    BOOL threadStoreLockOwner = FALSE;
    
    LockForEventSending();
    
    if (CORDebuggerAttached()) 
    {
        // Send a detach thread event to the Right Side.
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, 
                     DB_IPCE_THREAD_DETACH, 
                     pRuntimeThread->GetThreadId(),
                     (void *) pRuntimeThread->GetDomain());
        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(pRuntimeThread->GetDomain(), fHoldingThreadstoreLock);

        // This prevents a race condition where we blocked on the Lock()
        // above while another thread was sending an event and while we
        // were blocked the debugger suspended us and so we wouldn't be
        // resumed after the suspension about to happen below.
        pRuntimeThread->ResetThreadStateNC(Thread::TSNC_DebuggerUserSuspend);
    } 
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::DT: Skipping SendIPCEvent because RS detached."));
    }
    
    // Let other Runtime threads handle their events.
    UnlockFromEventSending();
    
    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
    g_pEEInterface->DisablePreemptiveGC();

    if (!disabled)
        g_pEEInterface->EnablePreemptiveGC();
}


//
// SuspendComplete is called when the last Runtime thread reaches a safe point in response to having its trap flags set.
//
BOOL Debugger::SuspendComplete(BOOL fHoldingThreadstoreLock)
{
    _ASSERTE((!g_pEEInterface->GetThread() || !g_pEEInterface->GetThread()->m_fPreemptiveGCDisabled) || g_fInControlC);

    LOG((LF_CORDB, LL_INFO10000, "D::SC: suspension complete\n"));

    // Prevent other Runtime threads from handling events.
    LockForEventSending();

    // We're stopped now...
    _ASSERTE(!m_stopped && m_trappingRuntimeThreads);

    // We have to grab the thread store lock now so this thread can hold it during this stopping.
    if (!fHoldingThreadstoreLock)
        ThreadStore::LockThreadStore(GCHeap::SUSPEND_FOR_DEBUGGER, FALSE);
    
    // Send the sync complete event to the Right Side.
    SendSyncCompleteIPCEvent(); // sets m_stopped = true...

    // Unlock the debugger mutex. This will let the RCThread handle
    // requests from the Right Side. But we do _not_ re-enable the
    // handling of events. Runtime threads that were not counted in
    // the suspend count (because they were outside the Runtime when
    // the suspension started) may actually be trying to handle their
    // own Runtime events, say, trying to hit a breakpoint. By not
    // re-enabling event handling, we prevent those threads from
    // sending their events to the Right Side and effectivley queue
    // them up.
    //
    // Event handling is re-enabled by the RCThread in response to a
    // continue message from the Right Side.
    Unlock();

    // We set the syncThreadIsLockFree event here. This thread just sent up the sync complete flare, and we've released
    // the debuger lock. By setting this event, we allow the Right Side to suspend this thread now. (Note: this is all
    // for Win32 debugging support.)
    if (m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_rightSideIsWin32Debugger)
        VERIFY(SetEvent(m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_syncThreadIsLockFree));

    // Any thread that has locked for event sending can't be interrupted by breakpoints or exceptions when were interop
    // debugging. SetDebugCantStop helps us remember that. This was set in LockForEventSending.
    if (g_pEEInterface->GetThread())
        g_pEEInterface->GetThread()->SetDebugCantStop(false);
    
    
    // We unconditionally grab the thread store lock, so return that we're holding it.
    return TRUE;
}

ULONG inline Debugger::IsDebuggerAttachedToAppDomain(Thread *pThread)
{
    _ASSERTE(pThread != NULL);
    
    AppDomain *pAppDomain = pThread->GetDomain();
    
    if (pAppDomain != NULL)
        return pAppDomain->IsDebuggerAttached();
    else
    {
        _ASSERTE (g_fEEShutDown);
        return 0;
    }
}


//
// SendCreateAppDomainEvent is called when a new AppDomain gets created.
//
void Debugger::SendCreateAppDomainEvent(AppDomain* pRuntimeAppDomain,
                                        BOOL fAttaching)
{
    if (CORDBUnrecoverableError(this))
        return;
    
    LOG((LF_CORDB, LL_INFO100, "D::SCADE: Create AppDomain 0x%08x (0x%08x) (Attaching: %s).\n",
        pRuntimeAppDomain, pRuntimeAppDomain->GetId(),
        fAttaching?"TRUE":"FALSE"));

    bool disabled;

    //
    // If we're attaching, then we only need to send the event. We
    // don't need to disable event handling or lock the debugger
    // object.
    //
    if (!fAttaching)
    {
        disabled =  g_pEEInterface->IsPreemptiveGCDisabled();

        if (disabled)
            g_pEEInterface->EnablePreemptiveGC();

        // Prevent other Runtime threads from handling events.
        LockForEventSending();
    }

    // We may have detached while waiting in LockForEventSending, 
    // in which case we can't send the event. 
    // Note that CORDebuggerAttached() wont return true until we're finished
    // the attach, but if fAttaching, then there's a debugger listening
    if (CORDebuggerAttached() || fAttaching)
    {
        // Send a create appdomain event to the Right Side.
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(
            IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, 
                     DB_IPCE_CREATE_APP_DOMAIN,
                     GetCurrentThreadId(),
                     (void *) pRuntimeAppDomain);

        ipce->AppDomainData.id = pRuntimeAppDomain->GetId();
        WCHAR *pszName = (WCHAR *)pRuntimeAppDomain->GetFriendlyName();
        if (pszName != NULL)
            wcscpy ((WCHAR *)ipce->AppDomainData.rcName, pszName);
        else
            wcscpy ((WCHAR *)ipce->AppDomainData.rcName, L"<UnknownName>");

        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
    } 
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::SCADE: Skipping SendIPCEvent because RS detached."));
    }
    
    if (!fAttaching)
    {
        // Stop all Runtime threads if we actually sent an event
        BOOL threadStoreLockOwner = FALSE;
        if (CORDebuggerAttached())
        {
            threadStoreLockOwner = TrapAllRuntimeThreads(pRuntimeAppDomain);
        }

        // Let other Runtime threads handle their events.
        UnlockFromEventSending();

        BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
        g_pEEInterface->DisablePreemptiveGC();

        if (!disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }
}


//
// SendExitAppDomainEvent is called when an app domain is destroyed.
//
void Debugger::SendExitAppDomainEvent(AppDomain* pRuntimeAppDomain)
{
    if (CORDBUnrecoverableError(this))
        return;
    
    LOG((LF_CORDB, LL_INFO100, "D::EAD: Exit AppDomain 0x%08x.\n",
        pRuntimeAppDomain));

    bool disabled = true;
    if (GetThread() != NULL)
    {
        disabled =  g_pEEInterface->IsPreemptiveGCDisabled();

        if (disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }
    
    // Prevent other Runtime threads from handling events.
    BOOL threadStoreLockOwner = FALSE;
    
    LockForEventSending();
    
    if (CORDebuggerAttached())   
    {
        
        // Send the exit appdomain event to the Right Side.
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, 
                     DB_IPCE_EXIT_APP_DOMAIN,
                     GetCurrentThreadId(),
                     (void *) pRuntimeAppDomain);
        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
        
        // Delete any left over modules for this appdomain.
        if (m_pModules != NULL)
            m_pModules->RemoveModules(pRuntimeAppDomain);
        
        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(pRuntimeAppDomain);
    } 
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::EAD: Skipping SendIPCEvent because RS detached."));
    }
    
    // Let other Runtime threads handle their events.
    UnlockFromEventSending();
    
    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);

    if (GetThread() != NULL)
    {
        g_pEEInterface->DisablePreemptiveGC();

        if (!disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }
}


//
// LoadAssembly is called when a new Assembly gets loaded.
//
void Debugger::LoadAssembly(AppDomain* pRuntimeAppDomain, 
                            Assembly *pAssembly,
                            BOOL fIsSystemAssembly,
                            BOOL fAttaching)
{
    if (CORDBUnrecoverableError(this))
        return;
        
    LOG((LF_CORDB, LL_INFO100, "D::LA: Load Assembly Asy:%#08x AD:%#08x %s\n", 
        pAssembly, pRuntimeAppDomain, (pAssembly->GetName()?pAssembly->GetName():"Unknown name") ));

    bool disabled;
    
    //
    // If we're attaching, then we only need to send the event. We
    // don't need to disable event handling or lock the debugger
    // object.
    //
    if (!fAttaching)
    {
        disabled =  g_pEEInterface->IsPreemptiveGCDisabled();

        if (disabled)
            g_pEEInterface->EnablePreemptiveGC();

        // Prevent other Runtime threads from handling events.
        LockForEventSending();
    }

    if (CORDebuggerAttached() || fAttaching)
    {
        // Send a load assembly event to the Right Side.
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, 
                     DB_IPCE_LOAD_ASSEMBLY,
                     GetCurrentThreadId(),
                     (void *) pRuntimeAppDomain);

        ipce->AssemblyData.debuggerAssemblyToken = (void *) pAssembly;
        ipce->AssemblyData.fIsSystemAssembly =  fIsSystemAssembly;

        // Use the filename from the module that holds the assembly so
        // that we have the full path to the assembly and not just some
        // simple name.
        wcscpy ((WCHAR *)ipce->AssemblyData.rcName,
                pAssembly->GetSecurityModule()->GetFileName());

        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
    } 
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::LA: Skipping SendIPCEvent because RS detached."));
    }
    
    if (!fAttaching)
    {
        // Stop all Runtime threads
        BOOL threadStoreLockOwner = FALSE;
        
        if (CORDebuggerAttached())
        {
            threadStoreLockOwner = TrapAllRuntimeThreads(pRuntimeAppDomain);
        }

        // Let other Runtime threads handle their events.
        UnlockFromEventSending();

        BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
        g_pEEInterface->DisablePreemptiveGC();

        if (!disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }
}


//
// UnloadAssembly is called when a Runtime thread unloads an assembly.
//
// !!WARNING: The assembly object has already been deleted before this 
// method is called. So do not call any methods on the pAssembly object!!
void Debugger::UnloadAssembly(AppDomain *pAppDomain, 
                              Assembly* pAssembly)
{        
    if (CORDBUnrecoverableError(this))
        return;
    
    LOG((LF_CORDB, LL_INFO100, "D::UA: Unload Assembly Asy:%#08x AD:%#08x which:0x%x %s\n", 
         pAssembly, pAppDomain, (pAssembly->GetName()?pAssembly->GetName():"Unknown name") ));
        
    bool disabled = true;
    if (GetThread() != NULL)
    {
        disabled =  g_pEEInterface->IsPreemptiveGCDisabled();

        if (disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }
    
    // Prevent other Runtime threads from handling events.
    BOOL threadStoreLockOwner = FALSE;
    LockForEventSending();
    
    if (CORDebuggerAttached())   
    {
        // Send the unload assembly event to the Right Side.
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
       
        InitIPCEvent(ipce, 
                     DB_IPCE_UNLOAD_ASSEMBLY,
                     GetCurrentThreadId(),
                     (void *) pAppDomain);
        ipce->AssemblyData.debuggerAssemblyToken = (void *) pAssembly;

        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
        
        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(pAppDomain);

    }
    else
    {
        LOG((LF_CORDB,LL_INFO1000, "D::UA: Skipping SendIPCEvent because RS detached."));
    }
    
    // Let other Runtime threads handle their events.
    UnlockFromEventSending();
    
    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);

    if (GetThread() != NULL)
    {
        g_pEEInterface->DisablePreemptiveGC();

        if (!disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }
}

// Create a new module
DebuggerModule* Debugger::AddDebuggerModule(Module* pRuntimeModule,
                                    AppDomain *pAppDomain)
{
    DebuggerModule*  module = new (interopsafe) DebuggerModule(pRuntimeModule, pAppDomain);
    TRACE_ALLOC(module);

    _ASSERTE (module != NULL);

    if (FAILED(CheckInitModuleTable()))
        return (NULL);

    m_pModules->AddModule(module);

    return module;
}

// Return an existing module
DebuggerModule* Debugger::GetDebuggerModule(Module* pRuntimeModule,
                                    AppDomain *pAppDomain)
{
    if (FAILED(CheckInitModuleTable()))
        return (NULL);

    return m_pModules->GetModule(pRuntimeModule, pAppDomain);
}

//
// LoadModule is called when a Runtime thread loads a new module.
//
void Debugger::LoadModule(Module* pRuntimeModule,
                          IMAGE_COR20_HEADER* pCORHeader,
                          VOID* baseAddress,
                          LPCWSTR pszModuleName,
                          DWORD dwModuleName,
                          Assembly *pAssembly,
                          AppDomain *pAppDomain,
                          BOOL fAttaching)
{
    if (CORDBUnrecoverableError(this))
        return;
    
    BOOL disabled = FALSE;
    BOOL threadStoreLockOwner = FALSE;
    
    //
    // If we're attaching, then we only need to send the event. We
    // don't need to disable event handling or lock the debugger
    // object.
    //
    if (!fAttaching)
    {
        disabled =  g_pEEInterface->IsPreemptiveGCDisabled();

        if (disabled)
            g_pEEInterface->EnablePreemptiveGC();

        // Prevent other Runtime threads from handling events.
        LockForEventSending();
    }

    // We don't actually want to get the symbol reader, we just 
    // want to make sure that the .pdbs have been copied into 
    // the fusion cache.
    // CAVEAT: If the symbols were updated (eg, recompiled) after the process
    // began using the module, the debugger will get a symbol mismatch error.
    // A fix is to run the program in debug mode.
    pRuntimeModule->GetISymUnmanagedReader();

    DebuggerModule *module = GetDebuggerModule(pRuntimeModule,pAppDomain);

    // Don't create new record if already loaded. We do still want to send the ModuleLoad event, however.
    // The RS has logic to ignore duplicate ModuleLoad events. We have to send what could possibly be a dup, though,
    // due to some really nasty issues with getting proper assembly and module load events from the loader when dealing
    // with shared assemblies.
    if (module)
    {
        LOG((LF_CORDB, LL_INFO100, "D::LM: module already loaded Mod:%#08x "
            "Asy:%#08x AD:%#08x isDynamic:0x%x runtimeMod:%#08x ModName:%ls\n",
             module, pAssembly, pAppDomain, pRuntimeModule->IsReflection(), pRuntimeModule, pszModuleName));
    }
    else
    {
        module = AddDebuggerModule(pRuntimeModule, pAppDomain);

        LOG((LF_CORDB, LL_INFO100, "D::LM: load module Mod:%#08x "
             "Asy:%#08x AD:%#08x isDynamic:0x%x runtimeMod:%#08x ModName:%ls\n",
             module, pAssembly, pAppDomain, pRuntimeModule->IsReflection(), pRuntimeModule, pszModuleName));
    }
    
    // Send a load module event to the Right Side.
    DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
    InitIPCEvent(ipce,DB_IPCE_LOAD_MODULE, GetCurrentThreadId(), (void *) pAppDomain);
    ipce->LoadModuleData.debuggerModuleToken = (void*) module;
    ipce->LoadModuleData.debuggerAssemblyToken = (void *) pAssembly;
    ipce->LoadModuleData.pPEBaseAddress = (void *) baseAddress;

    if (pRuntimeModule->IsPEFile())
    {
        // Get the PEFile structure.
        PEFile *pPEFile = pRuntimeModule->GetPEFile();

        _ASSERTE(pPEFile->GetNTHeader() != NULL);
        _ASSERTE(pPEFile->GetNTHeader()->OptionalHeader.SizeOfImage != 0);

        ipce->LoadModuleData.nPESize = pPEFile->GetNTHeader()->OptionalHeader.SizeOfImage;
    }
    else
        ipce->LoadModuleData.nPESize = 0;

    if ((pszModuleName == NULL) || (*pszModuleName == L'\0'))
        ipce->LoadModuleData.fInMemory = TRUE;
    else
        ipce->LoadModuleData.fInMemory = FALSE;
        
    ipce->LoadModuleData.fIsDynamic = pRuntimeModule->IsReflection();

    if (!ipce->LoadModuleData.fIsDynamic)
    {
        ipce->LoadModuleData.pMetadataStart =
            (LPVOID)((size_t)pCORHeader->MetaData.VirtualAddress + (size_t)baseAddress);
        ipce->LoadModuleData.nMetadataSize = pCORHeader->MetaData.Size;
    }
    else
    {
        BYTE *rgb;
        DWORD cb;
        HRESULT hr = ModuleMetaDataToMemory( pRuntimeModule, &rgb, &cb);
        if (!FAILED(hr))
        {
            ipce->LoadModuleData.pMetadataStart = rgb; //get this
            ipce->LoadModuleData.nMetadataSize = cb;
        }
        else
        {
            ipce->LoadModuleData.pMetadataStart = 0; //get this
            ipce->LoadModuleData.nMetadataSize = 0;
        }
        LOG((LF_CORDB,LL_INFO10000, "D::LM: putting dynamic, new mD at 0x%x, "
            "size 0x%x\n",ipce->LoadModuleData.pMetadataStart,
            ipce->LoadModuleData.nMetadataSize));

        // Dynamic modules must receive ClassLoad callbacks in order to receive metadata updates as the module
        // evolves. So we force this on here and refuse to change it for all dynamic modules.
        module->EnableClassLoadCallbacks(TRUE);
    }

    // Never give an empty module name...
    const WCHAR *moduleName;

    if (dwModuleName > 0)
        moduleName = pszModuleName;
    else
    {
        if (pRuntimeModule->IsReflection())
        {
            ReflectionModule *rm = pRuntimeModule->GetReflectionModule();
            moduleName = rm->GetFileName();

            if (moduleName)
            {
                dwModuleName = wcslen(moduleName);
            }
            else
            {
                moduleName = L"<Unknown or dynamic module>";
                dwModuleName = wcslen(moduleName);
            }
        }
        else
        {
            moduleName = L"<Unknown or dynamic module>";
            dwModuleName = wcslen(moduleName);
        }
    }
    
    DWORD length = dwModuleName < MAX_PATH ? dwModuleName : MAX_PATH;
    memcpy(ipce->LoadModuleData.rcName, moduleName, length*sizeof(WCHAR));
    ipce->LoadModuleData.rcName[length] = L'\0';

    m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

    if (fAttaching)
    {
        UpdateModuleSyms(pRuntimeModule,
                         pAppDomain,
                         fAttaching);
    }
    else // !fAttaching
    {
        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(pAppDomain);
    }

    if (!fAttaching)
    {
        // Let other Runtime threads handle their events.
        UnlockFromEventSending();

        BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
        g_pEEInterface->DisablePreemptiveGC();

        if (!disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }
}

//
// UpdateModuleSyms is called when the symbols for a module need to be
// sent to the Right Side because they've changed.
//
void Debugger::UpdateModuleSyms(Module* pRuntimeModule,
                                AppDomain *pAppDomain,
                                BOOL fAttaching)
{
    DebuggerIPCEvent* ipce = NULL;

    if (CORDBUnrecoverableError(this))
        return;
    
    CGrowableStream *pStream = pRuntimeModule->GetInMemorySymbolStream();

    LOG((LF_CORDB, LL_INFO10000, "D::UMS: update module syms "
         "RuntimeModule:0x%08x CGrowableStream:0x%08x\n",
         pRuntimeModule, pStream));
         
    DebuggerModule* module = LookupModule(pRuntimeModule, pAppDomain);
    _ASSERTE(module != NULL);

   if (pStream == NULL || module->GetHasLoadedSymbols())
    {
        // No symbols to update (eg, symbols are on-disk),
        // or the symbols have already been sent.
        LOG((LF_CORDB, LL_INFO10000, "D::UMS: no in-memory symbols, or "
            "symbols already loaded!\n"));
        return;
    }
    
    STATSTG SizeData = {0};
    DWORD streamSize = 0;
    BYTE *pStreamCopy = NULL;
    HRESULT hr = S_OK;
    
    hr = pStream->Stat(&SizeData, STATFLAG_NONAME);
    
    streamSize = SizeData.cbSize.LowPart;
    if (FAILED(hr))
    {
        goto LExit;
    }

    if (SizeData.cbSize.HighPart > 0)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    bool disabled;

    if (!fAttaching && GetThread() != NULL)
    {
        disabled =  g_pEEInterface->IsPreemptiveGCDisabled();

        if (disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }

    if (!fAttaching)
    {
        // Prevent other Runtime threads from handling events.
        LockForEventSending();
    }
    
    if (CORDebuggerAttached() || fAttaching)
    {
        // Send a update module syns event to the Right Side.
        ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, DB_IPCE_UPDATE_MODULE_SYMS,
                     GetCurrentThreadId(),
                     (void *) pAppDomain);
        ipce->UpdateModuleSymsData.debuggerModuleToken = (void*) module;
        ipce->UpdateModuleSymsData.debuggerAppDomainToken = (void *) pAppDomain;
        ipce->UpdateModuleSymsData.pbSyms = (BYTE *)pStream->GetBuffer();
        ipce->UpdateModuleSymsData.cbSyms = streamSize;
        ipce->UpdateModuleSymsData.needToFreeMemory = false;
        
        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
    } 
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::UMS: Skipping SendIPCEvent because RS detached."));
    }
    
    // We used to set HasLoadedSymbols here, but we don't really want
    // to do that in the face of the same module being in multiple app
    // domains.

    if(!fAttaching)
    {
        // Stop all Runtime threads if we sent a message
        BOOL threadStoreLockOwner = FALSE;
        
        if (CORDebuggerAttached())
        {
            threadStoreLockOwner = TrapAllRuntimeThreads(pAppDomain);
        }

        // Let other Runtime threads handle their events.
        UnlockFromEventSending();

        BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);

        if (GetThread() != NULL)
        {
            g_pEEInterface->DisablePreemptiveGC();
        
            if (!disabled)
                g_pEEInterface->EnablePreemptiveGC();
        }
    }
LExit:
    ; // Debugger must free buffer using RELEASE_BUFFER message!
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::ModuleMetaDataToMemory(Module *pMod, BYTE **prgb, DWORD *pcb)
{
    IMetaDataEmit *pIMDE = pMod->GetEmitter();
    HRESULT hr;

    hr = pIMDE->GetSaveSize(cssQuick, pcb);
    if (FAILED(hr))
    {
        *pcb = 0;
        return hr;
    }
    
    (*prgb) = new (interopsafe) BYTE[*pcb];
    if (NULL == (*prgb))
    {
        *pcb = 0;
        return E_OUTOFMEMORY;
    }

    hr = pIMDE->SaveToMemory((*prgb), *pcb);
    if (FAILED(hr))
    {
        *pcb = 0;
        return hr;
    }

    pIMDE = NULL; // note that the emiiter SHOULD NOT be released

    LOG((LF_CORDB,LL_INFO1000, "D::MMDTM: Saved module 0x%x MD to 0x%x "
        "(size:0x%x)\n", pMod, *prgb, *pcb));

    return S_OK;
}

//
// UnloadModule is called when a Runtime thread unloads a module.
//
void Debugger::UnloadModule(Module* pRuntimeModule, 
                            AppDomain *pAppDomain)
{
    if (CORDBUnrecoverableError(this))
        return;
    
    

    LOG((LF_CORDB, LL_INFO100, "D::UM: unload module Mod:%#08x AD:%#08x runtimeMod:%#08x modName:%ls\n", 
         LookupModule(pRuntimeModule, pAppDomain), pAppDomain, pRuntimeModule, pRuntimeModule->GetFileName()));
        
    BOOL disabled =true;
    BOOL threadStoreLockOwner = FALSE;
    
    if (GetThread() != NULL)
    {
        disabled =  g_pEEInterface->IsPreemptiveGCDisabled();

        if (disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }
    
    // Prevent other Runtime threads from handling events.
    LockForEventSending();
    
    if (CORDebuggerAttached())   
    {
        
        DebuggerModule* module = LookupModule(pRuntimeModule, pAppDomain);
        if (module == NULL)
        {
            LOG((LF_CORDB, LL_INFO100, "D::UM: module already unloaded AD:%#08x runtimeMod:%#08x modName:%ls\n", 
                 pAppDomain, pRuntimeModule, pRuntimeModule->GetFileName()));
            goto LExit;
        }
        _ASSERTE(module != NULL);

        // Note: the appdomain the module was loaded in must match the appdomain we're unloading it from. If it doesn't,
        // then we've either found the wrong DebuggerModule in LookupModule or we were passed bad data.
        _ASSERTE(!module->m_fDeleted);
        _ASSERTE(module->m_pAppDomain == pAppDomain);

        // Send the unload module event to the Right Side.
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, DB_IPCE_UNLOAD_MODULE, GetCurrentThreadId(), (void*) pAppDomain);
        ipce->UnloadModuleData.debuggerModuleToken = (void*) module;
        ipce->UnloadModuleData.debuggerAssemblyToken = (void*) pRuntimeModule->GetClassLoader()->GetAssembly();
        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

        // Delete the Left Side representation of the module.
        if (m_pModules != NULL)
            m_pModules->RemoveModule(pRuntimeModule, pAppDomain);
        
        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(pAppDomain);
    } 
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::UM: Skipping SendIPCEvent because RS detached."));
    }
    
LExit:
    // Let other Runtime threads handle their events.
    UnlockFromEventSending();
    
    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);

    if (GetThread() != NULL)
    {
        g_pEEInterface->DisablePreemptiveGC();

        if (!disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }
}

void Debugger::DestructModule(Module *pModule)
{
    // We want to remove all references to the module from the various 
    // tables.  It's not just possible, but probable, that the module
    // will be re-loaded at the exact same address, and in that case,
    // we'll have piles of entries in our DJI table that mistakenly
    // match this new module.
    // Note that this doesn't apply to shared assemblies, that only
    // get unloaded when the process dies.  We won't be reclaiming their
    // DJIs/patches b/c the process is going to die, so we'll reclaim
    // the memory when the various hashtables are unloaded.  
    
    if (DebuggerController::g_patches != NULL)
    {
        // Note that we'll explicitly NOT delete DebuggerControllers, so that
        // the Right Side can delete them later.
        Lock();
        DebuggerController::g_patches->ClearPatchesFromModule(pModule);
        Unlock();
    }

    
    if (m_pJitInfos != NULL)
    {
        LockJITInfoMutex();
        m_pJitInfos->ClearMethodsOfModule(pModule);
        UnlockJITInfoMutex();
    }
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::SendClassLoadUnloadEvent (mdTypeDef classMetadataToken,
                                         DebuggerModule *classModule,
                                         Assembly *pAssembly,
                                         AppDomain *pAppDomain,
                                         BOOL fIsLoadEvent)
{
    LOG((LF_CORDB,LL_INFO10000, "D::SCLUE: Tok:0x%x isLoad:0x%x Mod:%#08x AD:%#08x %ls\n",
        classMetadataToken, fIsLoadEvent, classModule, pAppDomain, pAppDomain->GetFriendlyName(FALSE)));

    DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
    if (fIsLoadEvent == TRUE)
    {
        BOOL isReflection = classModule->m_pRuntimeModule->IsReflection();

        // If this is a reflection module, send the message to update
        // the module symbols before sending the class load event.
        if (isReflection)
            // We're not actually attaching, but it's behaviourly identical
            UpdateModuleSyms(classModule->m_pRuntimeModule, pAppDomain, TRUE);
        
        InitIPCEvent(ipce, 
                     DB_IPCE_LOAD_CLASS,
                     GetCurrentThreadId(),
                     (void*) pAppDomain);
        ipce->LoadClass.classMetadataToken = classMetadataToken;
        ipce->LoadClass.classDebuggerModuleToken = (void*) classModule;
        ipce->LoadClass.classDebuggerAssemblyToken =
                            (void*) pAssembly;

        if (isReflection)
        {
            HRESULT hr;
            hr = ModuleMetaDataToMemory(classModule->m_pRuntimeModule,
                &(ipce->LoadClass.pNewMetaData),
                &(ipce->LoadClass.cbNewMetaData));
            _ASSERTE(!FAILED(hr));
        }
    }
    else
    {
        InitIPCEvent(ipce, 
                     DB_IPCE_UNLOAD_CLASS,
                     GetCurrentThreadId(),
                     (void*) pAppDomain);
        ipce->UnloadClass.classMetadataToken = classMetadataToken;
        ipce->UnloadClass.classDebuggerModuleToken = (void*) classModule;
        ipce->UnloadClass.classDebuggerAssemblyToken =
                            (void*) pAssembly;
    }

    m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
}



/******************************************************************************
 *
 ******************************************************************************/
BOOL Debugger::SendSystemClassLoadUnloadEvent(mdTypeDef classMetadataToken,
                                              Module *classModule,
                                              BOOL fIsLoadEvent)
{
    BOOL fRetVal = FALSE;
    Assembly *pAssembly = classModule->GetAssembly();

    if (!m_pAppDomainCB->Lock())
        return (FALSE);

    AppDomainInfo *pADInfo = m_pAppDomainCB->FindFirst();

    while (pADInfo != NULL)
    {
        AppDomain *pAppDomain = pADInfo->m_pAppDomain;
        _ASSERTE(pAppDomain != NULL);

        if ((pAppDomain->IsDebuggerAttached() || (pAppDomain->GetDebuggerAttached() & AppDomain::DEBUGGER_ATTACHING_THREAD)) &&
            (pAppDomain->ContainsAssembly(pAssembly) || pAssembly->IsSystem()) &&
			!(fIsLoadEvent && pAppDomain->IsUnloading()) )
        {
            // Find the Left Side module that this class belongs in.
            DebuggerModule* pModule = LookupModule(classModule, pAppDomain);
            //_ASSERTE(pModule != NULL);
                
            // Only send a class load event if they're enabled for this module.
            if (pModule && pModule->ClassLoadCallbacksEnabled())
            {
                SendClassLoadUnloadEvent(classMetadataToken,
                                         pModule,
                                         pAssembly,
                                         pAppDomain,
                                         fIsLoadEvent);
                fRetVal = TRUE;
            }
        }

        pADInfo = m_pAppDomainCB->FindNext(pADInfo);
    } 

    m_pAppDomainCB->Unlock();

    return fRetVal;
}


//
// LoadClass is called when a Runtime thread loads a new Class.
// Returns TRUE if an event is sent, FALSE otherwise
BOOL  Debugger::LoadClass(EEClass   *pRuntimeClass,
                          mdTypeDef  classMetadataToken,
                          Module    *classModule,
                          AppDomain *pAppDomain,
                          BOOL fSendEventToAllAppDomains,
                          BOOL fAttaching)
{
    BOOL fRetVal = FALSE;
    BOOL threadStoreLockOwner = FALSE;
    
    if (CORDBUnrecoverableError(this))
        return FALSE;

    LOG((LF_CORDB, LL_INFO10000, "D::LC: load class Tok:%#08x Mod:%#08x AD:%#08x classMod:%#08x modName:%ls\n", 
         classMetadataToken, LookupModule(classModule, pAppDomain), pAppDomain, classModule, classModule->GetFileName()));

    //
    // If we're attaching, then we only need to send the event. We
    // don't need to disable event handling or lock the debugger
    // object.
    //
    bool disabled = false;
    
    if (!fAttaching)
    {
        // Enable preemptive GC...
        disabled = g_pEEInterface->IsPreemptiveGCDisabled();

        if (disabled)
            g_pEEInterface->EnablePreemptiveGC();

        // Prevent other Runtime threads from handling events.
        LockForEventSending();
    }

    if (CORDebuggerAttached() || fAttaching) 
    {
        fRetVal = SendSystemClassLoadUnloadEvent(classMetadataToken, classModule, TRUE);
               
        if (fRetVal == TRUE)
        {    
            // Stop all Runtime threads
            threadStoreLockOwner = TrapAllRuntimeThreads(pAppDomain);
        }
    }
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::LC: Skipping SendIPCEvent because RS detached."));
    }
    
    if (!fAttaching)
    {
        // Let other Runtime threads handle their events.
        UnlockFromEventSending();
        
        BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
        g_pEEInterface->DisablePreemptiveGC();
        
        if (!disabled)
            g_pEEInterface->EnablePreemptiveGC();
    }

    return fRetVal;
}


//
// UnloadClass is called when a Runtime thread unloads a Class.
//
void Debugger::UnloadClass(mdTypeDef classMetadataToken,
                           Module *classModule,
                           AppDomain *pAppDomain,
                           BOOL fSendEventToAllAppDomains)
{
    BOOL fRetVal = FALSE;
        
    if (CORDBUnrecoverableError(this))
        return;
    
    LOG((LF_CORDB, LL_INFO10000, "D::UC: unload class Tok:0x%08x Mod:%#08x AD:%#08x runtimeMod:%#08x modName:%ls\n", 
         classMetadataToken, LookupModule(classModule, pAppDomain), pAppDomain, classModule, classModule->GetFileName()));

    bool toggleGC = false;
    if (GetThread() != NULL)
    {
        toggleGC =  g_pEEInterface->IsPreemptiveGCDisabled();

        if (toggleGC)
            g_pEEInterface->EnablePreemptiveGC();
    }
    
    // Prevent other Runtime threads from handling events.
    BOOL threadStoreLockOwner = FALSE;
    
    LockForEventSending();
    if (CORDebuggerAttached())
    {
        Assembly *pAssembly = classModule->GetClassLoader()->GetAssembly();
        DebuggerModule *pModule = LookupModule(classModule, pAppDomain);
        if (pModule != NULL)
        {
        _ASSERTE(pAppDomain != NULL && pAssembly != NULL && pModule != NULL);

        SendClassLoadUnloadEvent(classMetadataToken, pModule, pAssembly, pAppDomain, FALSE);
        fRetVal = TRUE;
        }

        if (fRetVal == TRUE)
        {    
            // Stop all Runtime threads
            threadStoreLockOwner = TrapAllRuntimeThreads(pAppDomain);
        }
    }
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::UC: Skipping SendIPCEvent because RS detached."));
    }
    
    // Let other Runtime threads handle their events.
    UnlockFromEventSending();

    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
    if (GetThread() != NULL && toggleGC)
        g_pEEInterface->DisablePreemptiveGC();
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::FuncEvalComplete(Thread* pThread, DebuggerEval *pDE)
{
    if (CORDBUnrecoverableError(this))
        return;
    
    LOG((LF_CORDB, LL_INFO10000, "D::FEC: func eval complete pDE:%08x evalType:%d %s %s\n",
        pDE, pDE->m_evalType, pDE->m_successful ? "Success" : "Fail", pDE->m_aborted ? "Abort" : "Completed"));

    _ASSERTE(pDE->m_completed);
    _ASSERTE((g_pEEInterface->GetThread() && !g_pEEInterface->GetThread()->m_fPreemptiveGCDisabled) || g_fInControlC);

    _ASSERTE(ThreadHoldsLock());

    // Get the domain that the result is valid in. The RS will cache this in the ICorDebugValue
    AppDomain * pDomain = (pDE->m_debuggerModule == NULL) ? 
        pThread->GetDomain() : 
        pDE->m_debuggerModule->GetAppDomain();
    
    // Send a func eval complete event to the Right Side.
    DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
    InitIPCEvent(ipce, DB_IPCE_FUNC_EVAL_COMPLETE, pThread->GetThreadId(), pDomain);
    ipce->FuncEvalComplete.funcEvalKey = pDE->m_funcEvalKey;
    ipce->FuncEvalComplete.successful = pDE->m_successful;
    ipce->FuncEvalComplete.aborted = pDE->m_aborted;
    ipce->FuncEvalComplete.resultAddr = &(pDE->m_result);
    ipce->FuncEvalComplete.resultType = pDE->m_resultType;

    if (pDE->m_resultModule != NULL)
    {
        ipce->FuncEvalComplete.resultDebuggerModuleToken =
            (void*) LookupModule(pDE->m_resultModule, (AppDomain *)ipce->appDomainToken);
    }
    else
    {
        ipce->FuncEvalComplete.resultDebuggerModuleToken = NULL;
    }

    m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
}

/* ------------------------------------------------------------------------ *
 * Right Side Interface routines
 * ------------------------------------------------------------------------ */

//
// GetFunctionInfo returns various bits of function information given
// a module and a token. The info will come from a MethodDesc, if
// one exists (and the fd will be returned) or the info will come from
// metadata.
//
HRESULT Debugger::GetFunctionInfo(Module *pModule, mdToken functionToken,
                                  MethodDesc **ppFD,
                                  ULONG *pRVA,
                                  BYTE  **pCodeStart,
                                  unsigned int *pCodeSize,
                                  mdToken *pLocalSigToken)
{
    HRESULT hr = S_OK;

    // First, lets see if we've got a MethodDesc for this function.
    MethodDesc* pFD =
        g_pEEInterface->LookupMethodDescFromToken(pModule, functionToken);

    if (pFD != NULL)
    {
        LOG((LF_CORDB, LL_INFO10000, "D::GFI: fd found.\n"));

        // If this is not IL, then this function was called in error.
        if(!pFD->IsIL())
            return(CORDBG_E_FUNCTION_NOT_IL);

        COR_ILMETHOD_DECODER header(g_pEEInterface->MethodDescGetILHeader(pFD));
        
        *ppFD = pFD;
        *pRVA = g_pEEInterface->MethodDescGetRVA(pFD);
        *pCodeStart = const_cast<BYTE*>(header.Code);
        *pCodeSize = header.CodeSize;
        // I don't see why COR_ILMETHOD_DECODER doesn't simply set this field to 
        // be mdSignatureNil in the absence of a local signature, but since it sets
        // LocalVarSigTok to zero, we have to set it to what we expect - mdSignatureNil.
        *pLocalSigToken = (header.LocalVarSigTok)?(header.LocalVarSigTok):(mdSignatureNil);
    }
    else
    {
        LOG((LF_CORDB, LL_INFO10000, "D::GFI: fd not found.\n"));

        *ppFD = NULL; // no MethodDesc yet...

        DWORD implFlags;

        // Get the RVA and impl flags for this method.
        hr = g_pEEInterface->GetMethodImplProps(pModule,
                                                functionToken,
                                                pRVA,
                                                &implFlags);

        if (SUCCEEDED(hr))
        {
            // If the RVA is 0 or it's native, then the method is not IL
            if (*pRVA == 0 || IsMiNative(implFlags))
                return (CORDBG_E_FUNCTION_NOT_IL);

            // The IL Method Header is at the given RVA in this module.
            COR_ILMETHOD *ilMeth = (COR_ILMETHOD*) pModule->ResolveILRVA(*pRVA, FALSE);
            COR_ILMETHOD_DECODER header(ilMeth);

            // Snagg the IL code info.
            *pCodeStart = const_cast<BYTE*>(header.Code);
            *pCodeSize = header.CodeSize;

            if (header.LocalVarSigTok != NULL)
                *pLocalSigToken = header.LocalVarSigTok;
            else
                *pLocalSigToken = mdSignatureNil;
        }
    }
    
    return hr;
}


/******************************************************************************
 *
 ******************************************************************************/
bool Debugger::ResumeThreads(AppDomain* pAppDomain)
{
    // Okay, mark that we're not stopped anymore and let the
    // Runtime threads go...
    ReleaseAllRuntimeThreads(pAppDomain);

    // If we have any thread blocking while holding the thread store lock (see BlockAndReleaseTSLIfNecessary), release
    // it now. Basically, there will be some thread holding onto the thread store lock for us if the RC Thread is not
    // holding the thread store lock.
    if (!m_RCThreadHoldsThreadStoreLock)
        VERIFY(SetEvent(m_runtimeStoppedEvent));
    
    // We no longer need to relax the thread store lock requirement.
    g_fRelaxTSLRequirement = false;
    
    // Re-enable event handling here. Event handling was left disabled after sending a sync complete event to the Right
    // Side. This prevents more events being sent while the process is synchronized. Re-enabling here allows any Runtime
    // threads that were queued waiting to send to actually go ahead and send.
    EnableEventHandling();

    // Return that we've continued the process.
    return true;
}

//
// HandleIPCEvent is called by the RC thread in response to an event
// from the Debugger Interface. No other IPC events, nor any Runtime
// events will come in until this method returns. Returns true if this
// was a Continue event.
//
bool Debugger::HandleIPCEvent(DebuggerIPCEvent* event, IpcTarget iWhich)
{
    bool ret = false;
    HRESULT hr = S_OK;
    
    LOG((LF_CORDB, LL_INFO10000, "D::HIPCE: got %s\n", IPCENames::GetName(event->type)));

    //
    // Lock the debugger mutex around the handling of all Right Side
    // events. This allows Right Side events to be handled safely
    // while the process is unsynchronized.
    //
    
    Lock();
    
    switch (event->type & DB_IPCE_TYPE_MASK)
    {
    case DB_IPCE_ASYNC_BREAK:
        // Simply trap all Runtime threads if we're not already trying to.
        if (!m_trappingRuntimeThreads)
        {
            m_RCThreadHoldsThreadStoreLock = TrapAllRuntimeThreads((AppDomain*)event->appDomainToken);

            // We set the syncThreadIsLockFree event here since the helper thread will never be suspended by the Right
            // Side.  (Note: this is all for Win32 debugging support.)
            if (m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_rightSideIsWin32Debugger)
                VERIFY(SetEvent(m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_syncThreadIsLockFree));
        }
        
        break;

    case DB_IPCE_CONTINUE:
        _ASSERTE(iWhich != IPC_TARGET_INPROC); //inproc should never go anywhere
    
        // We had better be stopped...
        _ASSERTE(m_stopped);

        // if we receive IPCE_CONTINUE and m_syncingForAttach is != SYNC_STATE_0,
        // we send loaded assembly, modules, classes and started threads, and finally 
        // another sync event. We _do_not_ release the threads in this case.

        // Here's how the attach logic works:
        // 1. Set m_syncingForAttach to SYNC_STATE_1
        // 2. Send all CreateAppDomain events to the right side
        // 3. Set m_syncingForAttach to SYNC_STATE_2
        // 4. The right side sends AttachToAppDomain events for every app domain
        //    that it wishes to attach to. Then the right side sends IPCE_CONTINUE
        // 5. Upon receiving IPCE_CONTINUE, m_syncingForAttach is SYNC_STATE_2. This
        //    indicates that we should send all the Load Assembly and Load Module 
        //    events to the right side for all the app domains to which the debugger
        //    is attaching.
        // 6. Set m_syncingForAttach to SYNC_STATE_3
        // 7. Upon receiving IPCE_CONTINUE when m_syncingForAttach is in SYNC_STATE_3,
        //    send out all the LoadClass events for all the modules which the right 
        //    side is interested in.
        // 8. Set m_syncingForAttach to SYNC_STATE_0. This indicates that the 
        //    attach has completed!!
        if (m_syncingForAttach != SYNC_STATE_0)
        {
            _ASSERTE (m_syncingForAttach != SYNC_STATE_1);
            LOG((LF_CORDB, LL_INFO10, "D::HIPCE: Got DB_IPCE_CONTINUE.  Attach state is currently %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));

            HRESULT hr;
            BOOL fAtleastOneEventSent = FALSE;

            if (m_syncingForAttach == SYNC_STATE_20)
            {
                SendEncRemapEvents(&m_EnCRemapInfo);
                
                m_syncingForAttach = SYNC_STATE_0;
                LOG((LF_CORDB, LL_INFO10, "D::HIPCE: Attach state is now %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));
                
                break; // out of "event->type & DB_IPCE_TYPE_MASK" switch
            }

        syncForAttachRetry:
            if ((m_syncingForAttach == SYNC_STATE_2) ||
                (m_syncingForAttach == SYNC_STATE_10))
            {
                    hr = IterateAppDomainsForAttach(DONT_SEND_CLASS_EVENTS,
                                                    &fAtleastOneEventSent,
                                                    TRUE);

                    // This is for the case that we're attaching at a point where
                    // only an AppDomain is loaded, so we can't send any
                    // assembly load events but it's valid and so we should just
                    // move on to SYNC_STATE_3 and retry this stuff.  This
                    // happens in particular when we are trying to use the
                    // service to do a synchronous attach at runtime load.
                    if (FAILED(hr) || !fAtleastOneEventSent)
                    {
                        m_syncingForAttach = SYNC_STATE_3;
                        LOG((LF_CORDB, LL_INFO10, "D::HIPCE: Attach state is now %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));
                        goto syncForAttachRetry;
                    }
            }
            else
            {
                _ASSERTE ((m_syncingForAttach == SYNC_STATE_3) ||
                          (m_syncingForAttach == SYNC_STATE_11));

                hr = IterateAppDomainsForAttach(ONLY_SEND_CLASS_EVENTS,
                                                &fAtleastOneEventSent,
                                                TRUE);
                
                // Send thread attaches...
                if (m_syncingForAttach == SYNC_STATE_3)
                    hr = g_pEEInterface->IterateThreadsForAttach(
                                                 &fAtleastOneEventSent,
                                                 TRUE);

                // Change the debug state of all attaching app domains to attached
                MarkAttachingAppDomainsAsAttachedToDebugger();
            }

            // If we're attaching due to an exception, set
            // exAttachEvent, which will let all excpetion threads
            // go. They will send their events as normal, and will
            // also cause the sync complete to be sent to complete the
            // attach. Therefore, we don't need to do this here.
            if (m_attachingForException && 
                (m_syncingForAttach == SYNC_STATE_3))
            {
                LOG((LF_CORDB, LL_INFO10000,
                     "D::HIPCE: Calling SetEvent on m_exAttachEvent= %x\n",
                     m_exAttachEvent));

                // Note: we have to force enable event handling right
                // here to be sure that at least one thread that is
                // blocked waiting for the attach to complete will be
                // able to send its exception or user breakpoint
                // event.
                EnableEventHandling(true);
                
                VERIFY(SetEvent(m_exAttachEvent));
            }
            else
            {
                if (fAtleastOneEventSent == TRUE)
                {
                    // Send the Sync Complete event next...
                    DebuggerIPCEvent* ipce = 
                        m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
                    InitIPCEvent(ipce, DB_IPCE_SYNC_COMPLETE);
                    m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
                }

                if ((m_syncingForAttach == SYNC_STATE_3) ||
                    (m_syncingForAttach == SYNC_STATE_11))
                {
                    // Attach is complete now.
                    LOG((LF_CORDB, LL_INFO10000, "D::HIPCE: Attach Complete!\n"));
                    g_pEEInterface->MarkDebuggerAttached();
                    m_syncingForAttach = SYNC_STATE_0;
                    LOG((LF_CORDB, LL_INFO10, "D::HIPCE: Attach state is now %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));

                    m_debuggerAttached = TRUE; //No-op for INPROC
                }
                else
                {
                    _ASSERTE ((m_syncingForAttach == SYNC_STATE_2) ||
                              (m_syncingForAttach == SYNC_STATE_10));

                    if (m_syncingForAttach == SYNC_STATE_2)
                    {
                        m_syncingForAttach = SYNC_STATE_3;
                        LOG((LF_CORDB, LL_INFO10, "D::HIPCE: Attach state is now %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));
                    }
                    else
                    {
                        m_syncingForAttach = SYNC_STATE_11;
                        LOG((LF_CORDB, LL_INFO10, "D::HIPCE: Attach state is now %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));
                    }
                }

                if (fAtleastOneEventSent == FALSE)
                    goto LetThreadsGo;
            }
        }
        else
        {
LetThreadsGo:
            ret = ResumeThreads((AppDomain*)event->appDomainToken);

            // If the helper thread is the owner of the thread store lock, then it got it via an async break, an attach,
            // or a successful sweeping. Go ahead and release it now that we're continuing. This ensures that we've held
            // the thread store lock the entire time the Runtime was just stopped.
            if (m_RCThreadHoldsThreadStoreLock)
            {
                m_RCThreadHoldsThreadStoreLock = FALSE;
                ThreadStore::UnlockThreadStore();
            }
        }

        break;

    case DB_IPCE_BREAKPOINT_ADD:
        {
            //
            // Currently, we can't create a breakpoint before a 
            // function desc is available.
            // Also, we can't know if a breakpoint is ok
            // prior to the method being JITted.
            //
            
            _ASSERTE(hr == S_OK);
            DebuggerBreakpoint *bp;
            bp = NULL;

            DebuggerModule *module;
            module = (DebuggerModule *) 
              event->BreakpointData.funcDebuggerModuleToken;

            if (m_pModules->IsDebuggerModuleDeleted(module))
            {
                LOG((LF_CORDB, LL_INFO1000000,"D::HIPCE: BP: Tried to set a bp"
                    " in a module that's been unloaded\n"));
                hr = CORDBG_E_MODULE_NOT_LOADED;
            }
            else
            {
                MethodDesc *pFD = g_pEEInterface->LookupMethodDescFromToken(
                        module->m_pRuntimeModule, 
                        event->BreakpointData.funcMetadataToken);

                DebuggerJitInfo *pDji = NULL;
                if ( NULL != pFD )
                    pDji = GetJitInfo(pFD, NULL );

                if (pDji != NULL && 
                    pDji->m_encBreakpointsApplied)
                {
                    LOG((LF_CORDB, LL_INFO1000000,"D::HIPCE: BP after EnC: "
                        "dji:0x%x\n", pDji));
                    BOOL fSucceed;
                
                    // If this method has been EnC'd, then subsequent
                    // applications want to be applied to the NEXT version,
                    // not the current version, which hasn't actually been
                    // updated, yet.
                    bp = new (interopsafe) DebuggerBreakpoint(module->m_pRuntimeModule,
                                   event->BreakpointData.funcMetadataToken,
                                   (AppDomain *)event->appDomainToken,
                                   event->BreakpointData.offset,  
                                   !event->BreakpointData.isIL, 
                                   pDji,
                                   &fSucceed,
                                   TRUE);
                    TRACE_ALLOC(bp);

                    if (bp != NULL && !fSucceed)
                    {
                        hr = CORDBG_E_UNABLE_TO_SET_BREAKPOINT;
                        DeleteInteropSafe(bp);
                        bp = NULL;
                    } 
                    else if (bp != NULL)
                    {
                        if (FAILED(pDji->AddToDeferedQueue(bp)))
                        {
                            hr = CORDBG_E_UNABLE_TO_SET_BREAKPOINT;
                            DeleteInteropSafe(bp);
                            bp = NULL;
                        }
                    }
                }
                else
                {
                    BOOL fSucceed;
                    // If we haven't been either JITted or EnC'd yet, then
                    // we'll put a patch in by offset, implicitly relative
                    // to the first version of the code.

                    bp = new (interopsafe) DebuggerBreakpoint(module->m_pRuntimeModule,
                                           event->BreakpointData.funcMetadataToken,
                                           (AppDomain *)event->appDomainToken,
                                           event->BreakpointData.offset,  
                                           !event->BreakpointData.isIL, 
                                           pDji,
                                           &fSucceed,
                                           FALSE);
                    TRACE_ALLOC(bp); 
                    if (bp != NULL && !fSucceed)
                    {
                        DeleteInteropSafe(bp);
                        bp = NULL;
                        hr = CORDBG_E_UNABLE_TO_SET_BREAKPOINT;
                    } 
                }

                if(NULL == bp && !FAILED(hr))
                {
                    hr = E_OUTOFMEMORY;
                }
                
                LOG((LF_CORDB,LL_INFO10000,"\tBP Add: DJI:0x%x BPTOK:"
                    "0x%x, tok=0x%08x, offset=0x%x, isIL=%d\n", pDji, bp,
                     event->BreakpointData.funcMetadataToken,
                     event->BreakpointData.offset,  
                     event->BreakpointData.isIL));
            }
            
            //
            // We're using a two-way event here, so we place the
            // result event into the _receive_ buffer, not the send
            // buffer.
            //
            
            _ASSERTE( iWhich != IPC_TARGET_INPROC );
            DebuggerIPCEvent *result = m_pRCThread->GetIPCEventReceiveBuffer(
                iWhich);
            InitIPCEvent(result, 
                         DB_IPCE_BREAKPOINT_ADD_RESULT,
                         GetCurrentThreadId(),
                         event->appDomainToken);
            result->BreakpointData.breakpoint =
                event->BreakpointData.breakpoint;
            result->BreakpointData.breakpointToken = bp;
            result->hr = hr;

            m_pRCThread->SendIPCReply(iWhich);
        }
        break;

    case DB_IPCE_STEP:
        {
            LOG((LF_CORDB,LL_INFO10000, "D::HIPCE: stepIn:0x%x frmTok:0x%x"
                "StepIn:0x%x RangeIL:0x%x RangeCount:0x%x MapStop:0x%x "
                "InterceptStop:0x%x AppD:0x%x\n",
                event->StepData.stepIn,
                event->StepData.frameToken, 
                event->StepData.stepIn,
                event->StepData.rangeIL, 
                event->StepData.rangeCount,
                event->StepData.rgfMappingStop, 
                event->StepData.rgfInterceptStop,
                event->appDomainToken));

            // @todo memory allocation - bad if we're synced
            Thread *thread = (Thread *) event->StepData.threadToken;
            AppDomain *pAppDomain;
            pAppDomain = (AppDomain*)event->appDomainToken;

            DebuggerStepper *stepper = new (interopsafe) DebuggerStepper(thread,
                                            event->StepData.rgfMappingStop,
                                            event->StepData.rgfInterceptStop,
                                            pAppDomain);
            if (!stepper)
            {
                DebuggerIPCEvent *result = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);

                InitIPCEvent(result, 
                             DB_IPCE_STEP_RESULT,
                             thread->GetThreadId(),
                             event->appDomainToken);
                result->hr = E_OUTOFMEMORY;                             

                m_pRCThread->SendIPCReply(iWhich);

                break;
            }
            TRACE_ALLOC(stepper);

            unsigned int cRanges = event->StepData.totalRangeCount;

            
            // @todo memory allocation = bad
            COR_DEBUG_STEP_RANGE *ranges = new (interopsafe) COR_DEBUG_STEP_RANGE [cRanges+1];
            if (!ranges)
            {
                DebuggerIPCEvent *result = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);

                InitIPCEvent(result, 
                             DB_IPCE_STEP_RESULT,
                             thread->GetThreadId(),
                             event->appDomainToken);
                result->hr = E_OUTOFMEMORY;                             

                m_pRCThread->SendIPCReply(iWhich);

                delete stepper;
                break;
            }
            
                // The "+1"is for internal use, when we need to 
                // set an intermediate patch in pitched code.  Isn't
                // used unless the method is pitched & a patch is set
                // inside it.  Thus we still pass cRanges as the
                // range count.
                
            TRACE_ALLOC(ranges);
            // !!! failure

            if (cRanges > 0)
            {
                COR_DEBUG_STEP_RANGE *r = ranges;
                COR_DEBUG_STEP_RANGE *rEnd = r + cRanges;

                while (r < rEnd)
                {
                    COR_DEBUG_STEP_RANGE *rFrom = &event->StepData.range;
                    COR_DEBUG_STEP_RANGE *rFromEnd = rFrom +
                        event->StepData.rangeCount;

                    while (rFrom < rFromEnd)
                        *r++ = *rFrom++;
                }

                stepper->Step(event->StepData.frameToken,
                              event->StepData.stepIn,
                              ranges, cRanges,
                              event->StepData.rangeIL);
            }
            else
                stepper->Step(event->StepData.frameToken,
                              event->StepData.stepIn, ranges, 0, FALSE);

            _ASSERTE( iWhich != IPC_TARGET_INPROC );
            DebuggerIPCEvent *result = m_pRCThread->GetIPCEventReceiveBuffer(
                iWhich);
            InitIPCEvent(result, 
                         DB_IPCE_STEP_RESULT,
                         thread->GetThreadId(),
                         event->appDomainToken);
            result->StepData.stepper = event->StepData.stepper;
            result->StepData.stepperToken = stepper;

            LOG((LF_CORDB, LL_INFO10000, "Stepped stepper 0x%x | R: 0x%x "
                "E: 0x%x\n", stepper, result->StepData.stepper, event->StepData.stepper));

            m_pRCThread->SendIPCReply(iWhich);
        }
        break;

    case DB_IPCE_STEP_OUT:
        {
            // @todo memory allocation - bad if we're synced
            Thread *thread = (Thread *) event->StepData.threadToken;
            AppDomain *pAppDomain;
            pAppDomain = (AppDomain*)event->appDomainToken;
            
            DebuggerStepper *stepper = new (interopsafe) DebuggerStepper(thread,
                                            event->StepData.rgfMappingStop,
                                            event->StepData.rgfInterceptStop,
                                            pAppDomain);

            if (!stepper)
            {
                DebuggerIPCEvent *result = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);

                InitIPCEvent(result, 
                             DB_IPCE_STEP_RESULT,
                             thread->GetThreadId(),
                             pAppDomain);
                result->hr = E_OUTOFMEMORY;                             

                m_pRCThread->SendIPCReply(iWhich);

                break;
            }
                                                        
            TRACE_ALLOC(stepper);

            stepper->StepOut(event->StepData.frameToken);

            _ASSERTE( iWhich != IPC_TARGET_INPROC );
            DebuggerIPCEvent *result = m_pRCThread->GetIPCEventReceiveBuffer(
                iWhich);
            InitIPCEvent(result, 
                         DB_IPCE_STEP_RESULT,
                         thread->GetThreadId(),
                         pAppDomain);
            result->StepData.stepper = event->StepData.stepper;
            result->StepData.stepperToken = stepper;

            m_pRCThread->SendIPCReply(iWhich);
        }
        break;

    case DB_IPCE_BREAKPOINT_REMOVE:
        {
            // @todo memory allocation - bad if we're synced

            DebuggerBreakpoint *bp 
              = (DebuggerBreakpoint *) event->BreakpointData.breakpointToken;
            
            bp->Delete();
        }
        break;

    case DB_IPCE_STEP_CANCEL:
        {
            // @todo memory allocation - bad if we're synced
            LOG((LF_CORDB,LL_INFO10000, "D:HIPCE:Got STEP_CANCEL for stepper "
                "0x%x\n",(DebuggerStepper *) event->StepData.stepperToken));
            DebuggerStepper *stepper 
              = (DebuggerStepper *) event->StepData.stepperToken;
            
            stepper->Delete();
        }
        break;

    case DB_IPCE_STACK_TRACE:
        {
            Thread* thread =
                (Thread*) event->StackTraceData.debuggerThreadToken;

            //
            // @todo handle error.
            //
            LOG((LF_CORDB,LL_INFO1000, "Stack trace to :iWhich:0x%x\n",iWhich));
                        
            HRESULT hr =
                DebuggerThread::TraceAndSendStack(thread, m_pRCThread, iWhich);
        }
        break;

    case DB_IPCE_SET_DEBUG_STATE:
        {
            Thread* thread = (Thread*) event->SetDebugState.debuggerThreadToken;
            CorDebugThreadState debugState = event->SetDebugState.debugState;

            LOG((LF_CORDB,LL_INFO10000,"HandleIPCE:SetDebugState: thread 0x%x (ID:0x%x) to state 0x%x\n",
                thread,thread->GetThreadId(), debugState));

            g_pEEInterface->SetDebugState(thread, debugState);
            
            LOG((LF_CORDB,LL_INFO10000,"HandleIPC: Got 0x%x back from SetDebugState\n", hr));

            _ASSERTE( iWhich != IPC_TARGET_INPROC );
            DebuggerIPCEvent *result = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
            InitIPCEvent(result, DB_IPCE_SET_DEBUG_STATE_RESULT, 0, NULL);
            result->hr = S_OK;
            
            m_pRCThread->SendIPCReply(iWhich);
                
        }
        break;
        
    case DB_IPCE_SET_ALL_DEBUG_STATE:
        {
            Thread* et = (Thread*) event->SetAllDebugState.debuggerExceptThreadToken;
            CorDebugThreadState debugState = event->SetDebugState.debugState;

            LOG((LF_CORDB,LL_INFO10000,"HandleIPCE: SetAllDebugState: except thread 0x%08x (ID:0x%x) to state 0x%x\n",
                et, et != NULL ? et->GetThreadId() : 0, debugState));

            if (!g_fProcessDetach)
                g_pEEInterface->SetAllDebugState(et, debugState);
            
            LOG((LF_CORDB,LL_INFO10000,"HandleIPC: Got 0x%x back from SetAllDebugState\n", hr));

            _ASSERTE(iWhich != IPC_TARGET_INPROC);

            // Just send back an HR.
            DebuggerIPCEvent *result = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
            InitIPCEvent(result, DB_IPCE_SET_DEBUG_STATE_RESULT, 0, NULL);
            result->hr = S_OK;
            m_pRCThread->SendIPCReply(iWhich);
        }
        break;
        
    case DB_IPCE_GET_FUNCTION_DATA:
        {
            //
            // @todo handle error.
            //
            _ASSERTE(!m_pModules->IsDebuggerModuleDeleted(
                (DebuggerModule *)event->GetFunctionData.funcDebuggerModuleToken));
                
            HRESULT hr = GetAndSendFunctionData(
                               m_pRCThread,
                               event->GetFunctionData.funcMetadataToken,
                               event->GetFunctionData.funcDebuggerModuleToken,
                               event->GetFunctionData.nVersion,
                               iWhich);
        }
        break;
        
    case DB_IPCE_GET_OBJECT_INFO:
        {
            //
            // @todo handle error.
            //
            HRESULT hr = GetAndSendObjectInfo(
                               m_pRCThread,
                               (AppDomain *)event->appDomainToken,
                               event->GetObjectInfo.objectRefAddress,
                               event->GetObjectInfo.objectRefInHandle,

                               event->GetObjectInfo.objectRefIsValue,
                               event->GetObjectInfo.objectType,
                               event->GetObjectInfo.makeStrongObjectHandle,
                               iWhich != IPC_TARGET_INPROC, //make a handle only in out-of-proc case
                               iWhich);
        }
        break;

    case DB_IPCE_VALIDATE_OBJECT:
        {
            LOG((LF_CORDB,LL_INFO1000, "HandleIPCEvent:DB_IPCE_VALIDATE_OBJECT\n"));
        
            HRESULT hr = GetAndSendObjectInfo(
                               m_pRCThread,
                               (AppDomain *)event->appDomainToken,
                               event->ValidateObject.objectToken,
                               true, // In handle
                               true, // Is the value itself
                               event->ValidateObject.objectType,
                               false, 
                               false,
                               iWhich); //don't make a handle
            break;
        }

    case DB_IPCE_DISCARD_OBJECT:
        {
            if (iWhich != IPC_TARGET_INPROC)
            {
            g_pEEInterface->DbgDestroyHandle( 
                (OBJECTHANDLE)event->DiscardObject.objectToken, 
                event->DiscardObject.fStrong);
            }
            break;
        }

    case DB_IPCE_GET_CLASS_INFO:
        {
            //
            // @todo handle error.
            //
            _ASSERTE(!m_pModules->IsDebuggerModuleDeleted(
                (DebuggerModule *)event->GetClassInfo.classDebuggerModuleToken));

            HRESULT hr = GetAndSendClassInfo(
                               m_pRCThread,
                               event->GetClassInfo.classDebuggerModuleToken,
                               event->GetClassInfo.classMetadataToken,
                               (AppDomain *)event->appDomainToken,
                               mdFieldDefNil,
                               NULL,
                               iWhich);
        }
        break;

    case DB_IPCE_GET_SPECIAL_STATIC:
        {
            HRESULT hr = GetAndSendSpecialStaticInfo(
                               m_pRCThread,
                               event->GetSpecialStatic.fldDebuggerToken,
                               event->GetSpecialStatic.debuggerThreadToken,
                               iWhich);
        }
        break;

    case DB_IPCE_GET_JIT_INFO:
        {
            //
            // @todo handle error.
            //
            _ASSERTE(!m_pModules->IsDebuggerModuleDeleted(
                (DebuggerModule *)event->GetJITInfo.funcDebuggerModuleToken));

            HRESULT hr = GetAndSendJITInfo(
                               m_pRCThread,
                               event->GetJITInfo.funcMetadataToken,
                               event->GetJITInfo.funcDebuggerModuleToken,
                               (AppDomain *)event->appDomainToken,
                               iWhich);
        }
        break;
        
    case DB_IPCE_GET_FLOAT_STATE:
        {
            Thread* thread =
                (Thread*) event->GetFloatState.debuggerThreadToken;

            //
            // @todo handle error.
            //
            HRESULT hr = DebuggerThread::GetAndSendFloatState(thread,
                                                              m_pRCThread,
                                                              iWhich);
        }
        break;
        
    case DB_IPCE_GET_CODE:
        {
            MethodDesc *fd = NULL;
            ULONG RVA;
            const BYTE *code;
            unsigned int codeSize;
            mdToken localSigToken;
            BOOL fSentEvent = FALSE;
            void *appDomainToken = event->appDomainToken;

            DebuggerModule* pDebuggerModule =
                (DebuggerModule*) event->GetCodeData.funcDebuggerModuleToken;

            if (m_pModules->IsDebuggerModuleDeleted(pDebuggerModule))
                hr = CORDBG_E_MODULE_NOT_LOADED;
            else
            {

                // get all the info about the function using metadata as a key.
                HRESULT hr = GetFunctionInfo(
                                     pDebuggerModule->m_pRuntimeModule,
                                     event->GetCodeData.funcMetadataToken,
                                     (MethodDesc**) &fd, &RVA,
                                     (BYTE**) &code, &codeSize,
                                     &localSigToken);

                if (SUCCEEDED(hr))
                {
                    DebuggerJitInfo *ji = (DebuggerJitInfo *)
                                            event->GetCodeData.CodeVersionToken;

                    // No DJI? Lets see if one has been created since the
                    // original data was sent to the Right Side...
                    if (ji == NULL)
                        ji = GetJitInfo( 
                            fd, 
                            (const BYTE*)DebuggerJitInfo::DJI_VERSION_FIRST_VALID, 
                            true );

                    // If the code has been pitched, then we simply tell
                    // the Right Side we can't get the code.
                    if (ji != NULL && ji->m_codePitched)
                    {
                        _ASSERTE( ji->m_prevJitInfo == NULL );
                        
                        // The code that the right side is asking for has
                        // been pitched since the last time it was referenced.
                        DebuggerIPCEvent *result =
                            m_pRCThread->GetIPCEventSendBuffer(iWhich);
                            
                        InitIPCEvent(result, 
                                     DB_IPCE_GET_CODE_RESULT,
                                     GetCurrentThreadId(),
                                     appDomainToken);
                        result->hr = CORDBG_E_CODE_NOT_AVAILABLE;
                        
                        fSentEvent = TRUE; //The event is 'sent' in-proc AND oop
                        if (iWhich ==IPC_TARGET_OUTOFPROC)
                        {
                            m_pRCThread->SendIPCEvent(iWhich);
                        }
                    } 
                    else
                    {
                        if (!event->GetCodeData.il)
                        {
                            _ASSERTE(fd != NULL);

                            // Grab the function address from the most
                            // reasonable place.
                            if ((ji != NULL) && ji->m_jitComplete)
                                code = (const BYTE*)ji->m_addrOfCode;
                            else
                                code = g_pEEInterface->GetFunctionAddress(fd);
                            
                            _ASSERTE(code != NULL);
                        }
                        
                        const BYTE *cStart = code + event->GetCodeData.start;
                        const BYTE *c = cStart;
                        const BYTE *cEnd = code + event->GetCodeData.end;

                        _ASSERTE(c < cEnd);

                        DebuggerIPCEvent *result = NULL;
                        DebuggerIPCEvent *resultT = NULL;

                        while (c < cEnd && 
                            (!result || result->hr != E_OUTOFMEMORY))
                        {
                            if (c == cStart || iWhich == IPC_TARGET_OUTOFPROC)
                                resultT = result = m_pRCThread->GetIPCEventSendBuffer(iWhich);
                            else
                            {
                                resultT = m_pRCThread->
                                    GetIPCEventSendBufferContinuation(result);
                                if (resultT != NULL)
                                    result = resultT;
                            }
                            
                            if (resultT == NULL)
                            {
                                result->hr = E_OUTOFMEMORY;
                            }
                            else
                            {
                                InitIPCEvent(result, 
                                             DB_IPCE_GET_CODE_RESULT,
                                             GetCurrentThreadId(),
                                             appDomainToken);
                                result->GetCodeData.start = c - code;
                            
                                BYTE *p = &result->GetCodeData.code;
                                BYTE *pMax = ((BYTE *) result) + CorDBIPC_BUFFER_SIZE;

                                SIZE_T size = pMax - p;

                                if ((SIZE_T)(cEnd - c) < size)
                                    size = cEnd - c;

                                result->GetCodeData.end = result->GetCodeData.start + size;

                                memcpy(p, c, size);
                                c += size;

                                DebuggerController::UnapplyPatchesInCodeCopy(
                                                     pDebuggerModule->m_pRuntimeModule,
                                                     event->GetCodeData.funcMetadataToken,
                                                     ji,
                                                     fd,
                                                     !event->GetCodeData.il,
                                                     p,
                                                     result->GetCodeData.start,
                                                     result->GetCodeData.end);
                            }
                            
                            fSentEvent = TRUE; //The event is 'sent' in-proc AND oop
                            if (iWhich ==IPC_TARGET_OUTOFPROC)
                            {
                                LOG((LF_CORDB,LL_INFO10000, "D::HIPCE: Get code sending"
                                    "to LS addr:0x%x\n", c));
                                m_pRCThread->SendIPCEvent(iWhich);
                                LOG((LF_CORDB,LL_INFO10000, "D::HIPCE: Code Sent\n"));
                            }
                        }
                    }
                }
            }
            
            // Something went wrong, so tell the right side so it's not left
            // hanging.
            if (!fSentEvent)
            {
                LOG((LF_CORDB,LL_INFO100000, "D::HIPCE: Get code failed!\n"));
            
                // Send back something that makes sense.
                if (hr == S_OK)
                    hr = E_FAIL;
            
                // failed to get any function info, so couldn't send
                // code. Send back the hr.
                DebuggerIPCEvent *result =
                    m_pRCThread->GetIPCEventSendBuffer(iWhich);
                    
                InitIPCEvent(result, 
                             DB_IPCE_GET_CODE_RESULT,
                             GetCurrentThreadId(),
                             appDomainToken);
                result->hr = hr;

                if (iWhich ==IPC_TARGET_OUTOFPROC)
                    m_pRCThread->SendIPCEvent(iWhich);
            }
        }
        
        LOG((LF_CORDB,LL_INFO10000, "D::HIPCE: Finished sending code!\n"));
        break;

    case DB_IPCE_GET_BUFFER:
        {
            _ASSERTE( iWhich != IPC_TARGET_INPROC );
        
            GetAndSendBuffer(m_pRCThread, event->GetBuffer.bufSize);
        }
        break;
    
    case DB_IPCE_RELEASE_BUFFER:
        {
            _ASSERTE( iWhich != IPC_TARGET_INPROC );
            
            SendReleaseBuffer(m_pRCThread, (BYTE *)event->ReleaseBuffer.pBuffer);
        }
        break;

    case DB_IPCE_COMMIT:
        {
            _ASSERTE( iWhich != IPC_TARGET_INPROC );
            //
            // @todo handle error.
            //
            HRESULT hr = CommitAndSendResult(m_pRCThread,
                                             (BYTE *)event->Commit.pData,
                                             event->Commit.checkOnly);
        }
        break;
        
    case DB_IPCE_SET_CLASS_LOAD_FLAG:
        {
            DebuggerModule *pModule =
                    (DebuggerModule*) event->SetClassLoad.debuggerModuleToken;
            _ASSERTE(pModule != NULL);
            if (!m_pModules->IsDebuggerModuleDeleted(pModule))
            {
                LOG((LF_CORDB, LL_INFO10000,
                     "D::HIPCE: class load flag is %d for module 0x%08x\n",
                     event->SetClassLoad.flag, pModule));
                
                pModule->EnableClassLoadCallbacks((BOOL)event->SetClassLoad.flag);
            }
        }
        break;
        
    case DB_IPCE_CONTINUE_EXCEPTION:
        {
            Thread *thread =
                (Thread *) event->ClearException.debuggerThreadToken;

            g_pEEInterface->ClearThreadException(thread);
        }
        break;
        
    case DB_IPCE_ATTACHING:
        // Perform some initialization necessary for debugging
        LOG((LF_CORDB,LL_INFO10000, "D::HIPCE: Attach begins!\n"));

        DebuggerController::Initialize();

        // Remember that we're attaching now...
        m_syncingForAttach = SYNC_STATE_1;
        LOG((LF_CORDB, LL_INFO10000, "Attach state is now %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));
        
        // Simply trap all Runtime threads...
        // This is an 'attach to process' msg, so it's not
        // unreasonable that we stop all the appdomains
        if (!m_trappingRuntimeThreads)
        {
            // Need to take the event handling lock so no other threads
            // try and send an event while we're sync'd, which can happen
            // if we successfully suspend all threads on the first pass.
            // i.e., a threads could have PGC enabled, and then come into
            // the runtime and send an event when we weren't expecting it
            // since event handling was not disabled.
            DisableEventHandling();

            m_RCThreadHoldsThreadStoreLock = TrapAllRuntimeThreads(NULL);

            // We set the syncThreadIsLockFree event here since the helper thread will never be suspended by the Right
            // Side.  (Note: this is all for Win32 debugging support.)
            if (m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_rightSideIsWin32Debugger)
                VERIFY(SetEvent(m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_syncThreadIsLockFree));
            
            // This will only enable event handling if TrapAllRuntimeThreads
            // successfully stopped all threads on the first pass.
            EnableEventHandling();
        }

        break;

    case DB_IPCE_GET_RO_DATA_RVA:
    case DB_IPCE_GET_RW_DATA_RVA:
        {
            DebuggerModule* pDebuggerModule =
                (DebuggerModule*) event->GetDataRVA.debuggerModuleToken;
            SIZE_T dataRVA;

            if (m_pModules->IsDebuggerModuleDeleted(pDebuggerModule))
            {
                hr = CORDBG_E_MODULE_NOT_LOADED;
                dataRVA = 0;
            }
            else
            {
                Module *pModule = pDebuggerModule->m_pRuntimeModule;

                LOG((LF_CORDB, LL_INFO100000, "D::HIPCE: get ro/rw RVA:debMod:0x%x"
                    "Module:0x%x\n", pDebuggerModule, pModule));
            
                if ( (event->type & DB_IPCE_TYPE_MASK) == DB_IPCE_GET_RO_DATA_RVA)
                    hr = g_pEEInterface->GetRoDataRVA(pModule, &dataRVA);
                else
                    hr = g_pEEInterface->GetRwDataRVA(pModule, &dataRVA);
            }
            
            // This is a synchronous event (reply required)
            event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
            InitIPCEvent(event, DB_IPCE_GET_DATA_RVA_RESULT);
            event->GetDataRVAResult.hr = hr;
            event->GetDataRVAResult.dataRVA = dataRVA;

            LOG((LF_CORDB, LL_INFO100000, "D::HIPCE: get ro/rw RVA:hr:0x%x"
                "dataRVA:0x%x\n",hr, dataRVA));
        
            // Send the result
            m_pRCThread->SendIPCReply(iWhich);
        }
        break;

    case DB_IPCE_IS_TRANSITION_STUB:

        GetAndSendTransitionStubInfo((const BYTE*)event->IsTransitionStub.address,
                                     iWhich);
        break;

    case DB_IPCE_MODIFY_LOGSWITCH:
        g_pEEInterface->DebuggerModifyingLogSwitch (
                            event->LogSwitchSettingMessage.iLevel,
                            &event->LogSwitchSettingMessage.Dummy[0]);

        break;

    case DB_IPCE_ENABLE_LOG_MESSAGES:
        {
            bool fOnOff = event->LogSwitchSettingMessage.iLevel ? true:false;
            EnableLogMessages (fOnOff);
        }
        break;
        
    case DB_IPCE_SET_IP:
            // This is a synchronous event (reply required)
            _ASSERTE( iWhich != IPC_TARGET_INPROC );
            _ASSERTE( event->SetIP.firstExceptionHandler != NULL);
        
            event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
            Module *pModule;
            pModule = ((DebuggerModule*)(event->SetIP.debuggerModule))
                ->m_pRuntimeModule;

            // Don't have an explicit reply msg                
            InitIPCEvent(event, 
                         DB_IPCE_SET_IP,
                         event->threadId,
                         (void *)event->appDomainToken);
            
            if (!g_fProcessDetach)
            {
                event->hr = SetIP(  event->SetIP.fCanSetIPOnly,
                                    (Thread*)event->SetIP.debuggerThreadToken,
                                    pModule,
                                    event->SetIP.mdMethod,
                                    (DebuggerJitInfo*)event->SetIP.versionToken,
                                    event->SetIP.offset, 
                                    event->SetIP.fIsIL,
                                    event->SetIP.firstExceptionHandler);
            }
            else
                event->hr = S_OK;
            // Send the result
            m_pRCThread->SendIPCReply(iWhich);
        break;

    case DB_IPCE_ATTACH_TO_APP_DOMAIN:
        // Mark that we need to attach to a specific app domain (state
        // 10), but only if we're not already attaching to the process
        // as a whole (state 2).
        if (m_syncingForAttach != SYNC_STATE_2)
        {
            m_syncingForAttach = SYNC_STATE_10;
            LOG((LF_CORDB, LL_INFO10000, "Attach state is now %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));
        }
        
        // Simply trap all Runtime threads...
        if (!m_trappingRuntimeThreads)
        {
            m_RCThreadHoldsThreadStoreLock = TrapAllRuntimeThreads(NULL);

            // We set the syncThreadIsLockFree event here since the helper thread will never be suspended by the Right
            // Side.  (Note: this is all for Win32 debugging support.)
            if (m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_rightSideIsWin32Debugger)
                VERIFY(SetEvent(m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_syncThreadIsLockFree));
        }

        event->hr = AttachDebuggerToAppDomain(event->AppDomainData.id);
        break;

    case DB_IPCE_DETACH_FROM_APP_DOMAIN:
        AppDomain *ad;

        hr = DetachDebuggerFromAppDomain(event->AppDomainData.id, &ad);
		if (FAILED(hr) )
		{
			event->hr = hr;
			break;
		}	
        
        if (ad != NULL)
        {
            LOG((LF_CORDB, LL_INFO10000, "Detaching from AppD:0x%x\n", ad));
        
            ClearAppDomainPatches(ad);
        }

        break;

    case DB_IPCE_DETACH_FROM_PROCESS:
        LOG((LF_CORDB, LL_INFO10000, "Detaching from process!\n"));

        // See EnsureDebuggerAttached for why we reset this here.
        // We reset it here because detach is the longest possible time 
        // after attach, and that makes the window really small.
        VERIFY(ResetEvent(m_exAttachEvent));

        // At this point, all patches should have been removed
        // by detaching from the appdomains.

        // Commented out for hotfix bug 94625.  Should be re-enabled at some point.
        //_ASSERTE(DebuggerController::GetNumberOfPatches() == 0);

        g_pEEInterface->MarkDebuggerUnattached();
        m_debuggerAttached = FALSE;

        // Need to close it before we recreate it.
        if (m_pRCThread->m_SetupSyncEvent == NULL)
        {
            hr = m_pRCThread->CreateSetupSyncEvent();
            if (FAILED(hr))
            {
                event->hr = hr;
                break;
            }
        }

        VERIFY(SetEvent(m_pRCThread->m_SetupSyncEvent));
        
        m_pRCThread->RightSideDetach();

        // Clean up the hash of DebuggerModules
        // This method is overridden to also free all DebuggerModule objects
        if (m_pModules != NULL)
            m_pModules->Clear();

        // Reply to the detach message before we release any Runtime threads. This ensures that the debugger will get
        // the detach reply before the process exits if the main thread is near exiting.
        m_pRCThread->SendIPCReply(iWhich);

        // Let the process run free now... there is no debugger to bother it anymore.
        ret = ResumeThreads(NULL);

        // If the helper thread is the owner of the thread store lock, then it got it via an async break, an attach, or
        // a successful sweeping. Go ahead and release it now that we're continuing. This ensures that we've held the
        // thread store lock the entire time the Runtime was just stopped.
        if (m_RCThreadHoldsThreadStoreLock)
        {
            m_RCThreadHoldsThreadStoreLock = FALSE;
            ThreadStore::UnlockThreadStore();
        }
        
        break;

    case DB_IPCE_FUNC_EVAL:
        {
            // This is a synchronous event (reply required)
            _ASSERTE( iWhich != IPC_TARGET_INPROC );
            _ASSERTE(!m_pModules->IsDebuggerModuleDeleted(
                (DebuggerModule *)event->FuncEval.funcDebuggerModuleToken));
                
            event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
            Thread *pThread;
            pThread = (Thread*)(event->FuncEval.funcDebuggerThreadToken);

            InitIPCEvent(event, DB_IPCE_FUNC_EVAL_SETUP_RESULT, pThread->GetThreadId(), pThread->GetDomain());

            BYTE *argDataArea = NULL;
            void *debuggerEvalKey = NULL;
            
            event->hr = FuncEvalSetup(&(event->FuncEval), &argDataArea, &debuggerEvalKey);
      
            // Send the result of how the func eval setup went.
            event->FuncEvalSetupComplete.argDataArea = argDataArea;
            event->FuncEvalSetupComplete.debuggerEvalKey = debuggerEvalKey;
            
            m_pRCThread->SendIPCReply(iWhich);
        }

        break;

    case DB_IPCE_SET_REFERENCE:
            // This is a synchronous event (reply required)
            _ASSERTE( iWhich != IPC_TARGET_INPROC );
            event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
            InitIPCEvent(event, 
                         DB_IPCE_SET_REFERENCE_RESULT, 
                         event->threadId,
                         (void *)event->appDomainToken);
            
            event->hr = SetReference(event->SetReference.objectRefAddress,
                                     event->SetReference.objectRefInHandle,
                                     event->SetReference.newReference);
      
            // Send the result of how the set reference went.
            m_pRCThread->SendIPCReply(iWhich);

        break;

    case DB_IPCE_SET_VALUE_CLASS:
            // This is a synchronous event (reply required)
            _ASSERTE(iWhich != IPC_TARGET_INPROC);
            event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
            
            InitIPCEvent(event, DB_IPCE_SET_VALUE_CLASS_RESULT, event->threadId, (void *)event->appDomainToken);
            
            event->hr = SetValueClass(event->SetValueClass.oldData,
                                      event->SetValueClass.newData,
                                      event->SetValueClass.classMetadataToken,
                                      event->SetValueClass.classDebuggerModuleToken);
      
            // Send the result of how the set reference went.
            m_pRCThread->SendIPCReply(iWhich);

        break;

    case DB_IPCE_GET_APP_DOMAIN_NAME:
        {
            WCHAR *pszName = NULL;
            AppDomain *pAppDomain = (AppDomain *)event->appDomainToken;

            // This is a synchronous event (reply required)
            event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
            InitIPCEvent(event, 
                         DB_IPCE_APP_DOMAIN_NAME_RESULT, 
                         event->threadId, // ==> don't change it.
                         event->appDomainToken);
                         
            pszName = (WCHAR *)pAppDomain->GetFriendlyName();
            if (pszName != NULL)
                wcscpy ((WCHAR *)event->AppDomainNameResult.rcName, 
                    pszName);
            else
                wcscpy ((WCHAR *)event->AppDomainNameResult.rcName, 
                    L"<UnknownName>");

            event->hr = S_OK;
            m_pRCThread->SendIPCReply(iWhich);
        }

        break;

    case DB_IPCE_FUNC_EVAL_ABORT:
        LOG((LF_CORDB, LL_INFO1000, "D::HIPCE: Got FuncEvalAbort for pDE:%08x\n",
            event->FuncEvalAbort.debuggerEvalKey));

        // This is a synchronous event (reply required)
        _ASSERTE( iWhich != IPC_TARGET_INPROC );
        
        event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
        InitIPCEvent(event, 
                     DB_IPCE_FUNC_EVAL_ABORT_RESULT, 
                     event->threadId,
                     event->appDomainToken);

        event->hr = FuncEvalAbort(event->FuncEvalAbort.debuggerEvalKey);
      
        m_pRCThread->SendIPCReply(iWhich);

        break;

    case DB_IPCE_FUNC_EVAL_CLEANUP:

        // This is a synchronous event (reply required)
        _ASSERTE(iWhich != IPC_TARGET_INPROC);
        
        event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
        InitIPCEvent(event, 
                     DB_IPCE_FUNC_EVAL_CLEANUP_RESULT, 
                     event->threadId,
                     event->appDomainToken);

        event->hr = FuncEvalCleanup(event->FuncEvalCleanup.debuggerEvalKey);
      
        m_pRCThread->SendIPCReply(iWhich);

        break;

    case DB_IPCE_GET_THREAD_OBJECT:
        {
            // This is a synchronous event (reply required)
            Thread *pRuntimeThread =
                (Thread *)event->ObjectRef.debuggerObjectToken;
            _ASSERTE(pRuntimeThread != NULL);
            
            event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
            InitIPCEvent(event, 
                         DB_IPCE_THREAD_OBJECT_RESULT, 
                         0,
                         (void *)(pRuntimeThread->GetDomain()));

            Thread::ThreadState ts = pRuntimeThread->GetSnapshotState();

            if ((ts & Thread::ThreadState::TS_Dead) ||
                (ts & Thread::ThreadState::TS_Unstarted) ||
                (ts & Thread::ThreadState::TS_Detached) ||
                g_fProcessDetach)
            {
                event->hr =  CORDBG_E_BAD_THREAD_STATE;
            }
            else
            {    
                event->ObjectRef.managedObject = (void *)
                    pRuntimeThread->GetExposedObjectHandleForDebugger();

                event->hr = S_OK;
            }
            m_pRCThread->SendIPCReply(iWhich);
        }
        break;

    case DB_IPCE_CHANGE_JIT_DEBUG_INFO:
        {
            Module *module = NULL;
            DWORD dwBits = 0;
            DebuggerModule *deModule = (DebuggerModule *) 
                event->JitDebugInfo.debuggerModuleToken;

            if (m_pModules->IsDebuggerModuleDeleted(deModule))
            {
                hr = CORDBG_E_MODULE_NOT_LOADED;
            }
            else
            {
                module = deModule->m_pRuntimeModule;
                _ASSERTE(NULL != module);


                if (event->JitDebugInfo.fTrackInfo)
                    dwBits |= DACF_TRACK_JIT_INFO;

                if (event->JitDebugInfo.fAllowJitOpts)
                    dwBits |= DACF_ALLOW_JIT_OPTS;
                else
                    dwBits |= DACF_ENC_ENABLED;

                // Settings from the debugger take precedence over all
                // other settings.
                dwBits |= DACF_USER_OVERRIDE;
            }
            
            event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
            InitIPCEvent(event, DB_IPCE_CHANGE_JIT_INFO_RESULT, 0, NULL);

            if (FAILED(hr))
            {
                event->hr = hr;
            }
            else
            {
                _ASSERTE(module != NULL);
                if (module->GetZapBase() == NULL)
                {
                    module->SetDebuggerInfoBits((DebuggerAssemblyControlFlags)dwBits);
                    event->hr = S_OK;
                }
                else
                    event->hr = CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE;
            }
            
            m_pRCThread->SendIPCReply(iWhich);
        }
        break;

    case DB_IPCE_CONTROL_C_EVENT_RESULT:
        if (event->hr == S_OK)
            m_DebuggerHandlingCtrlC = TRUE;
        else
            m_DebuggerHandlingCtrlC = FALSE;
        VERIFY(SetEvent(m_CtrlCMutex));

        break;

    case DB_IPCE_GET_SYNC_BLOCK_FIELD:
        GetAndSendSyncBlockFieldInfo(event->GetSyncBlockField.debuggerModuleToken,
                                     event->GetSyncBlockField.classMetadataToken,
                                     (Object *)event->GetSyncBlockField.pObject,
                                     event->GetSyncBlockField.objectType,
                                     event->GetSyncBlockField.offsetToVars,
                                     event->GetSyncBlockField.fldToken,
                                     (BYTE *)event->GetSyncBlockField.staticVarBase,
                                     m_pRCThread,
                                     iWhich);
       break;                                     
    
    default:
        LOG((LF_CORDB, LL_INFO10000, "Unknown event type: 0x%08x\n",
             event->type));
    }

    Unlock();

    return ret;
}

//
// After a class has been loaded, if a field has been added via EnC'd, 
// we'll have to jump through some hoops to get at it.
//
HRESULT Debugger::GetAndSendSyncBlockFieldInfo(void *debuggerModuleToken,
                                               mdTypeDef classMetadataToken,
                                               Object *pObject,
                                               CorElementType objectType,
                                               SIZE_T offsetToVars,
                                               mdFieldDef fldToken,
                                               BYTE *staticVarBase,
                                               DebuggerRCThread* rcThread,
                                               IpcTarget iWhich)
{
    LOG((LF_CORDB, LL_INFO100000, "D::GASSBFI: dmtok:0x%x Obj:0x%x, objType"
        ":0x%x, offset:0x%x\n", debuggerModuleToken, pObject, objectType,
        offsetToVars));

    DebuggerModule *dm;
    EditAndContinueModule *eacm;
    
    dm = (DebuggerModule *)(debuggerModuleToken);
    eacm = (EditAndContinueModule *)dm->m_pRuntimeModule;
     
    HRESULT hr = S_OK;

    // We'll wrap this in an SEH handler, even though we should
    // never actually get whacked by this - the CordbObject should
    // validate the pointer first.
    __try
    {
        FieldDesc *pFD = NULL;

        // Note that GASCI will scribble over both the data in the incoming
        // mesage, and the outgoing message, so don't bother to prep the reply
        // before calling this.
        hr = GetAndSendClassInfo(rcThread,
                                 debuggerModuleToken,
                                 classMetadataToken,
                                 dm->m_pAppDomain,
                                 fldToken,
                                 &pFD, //OUT
                                 iWhich);
        DebuggerIPCEvent *result = rcThread->GetIPCEventReceiveBuffer(
            iWhich);
        InitIPCEvent(result, 
                     DB_IPCE_GET_SYNC_BLOCK_FIELD_RESULT);
                     
        if (pFD == NULL)
        {
            result->hr = CORDBG_E_ENC_HANGING_FIELD;

            return rcThread->SendIPCReply(iWhich);
        }
            
        _ASSERTE(pFD->IsEnCNew()); // Shouldn't be here if it wasn't added to an
            //already loaded class.

        EnCFieldDesc *pEnCFD = (EnCFieldDesc *)pFD;
                     
        // If it hasn't been fixed up yet, then we're screwed.            
        if (pEnCFD->NeedsFixup())
        {
            result->hr = CORDBG_E_ENC_HANGING_FIELD;

            return rcThread->SendIPCReply(iWhich);
        }
        
        OBJECTREF or = ObjectToOBJECTREF(pObject);
        const BYTE *pORField = eacm->ResolveField(or, 
                                                  pEnCFD,
                                                  FALSE);
                                                  
        // The field could be absent b/c the code hasn't
        // accessed it yet, and we're not going to add it in just
        // to look at the blank field.  (If we did, ResolveField might
        // throw an Out of Memory exception, which is hideous bad here
        // on the debugger RC thread.
        if (pORField == NULL)
        {
            result->hr = CORDBG_E_ENC_HANGING_FIELD;

            return rcThread->SendIPCReply(iWhich);
        }

        result->GetSyncBlockFieldResult.fStatic = pEnCFD->IsStatic(); 
        DebuggerIPCE_FieldData *currentFieldData = 
            &(result->GetSyncBlockFieldResult.fieldData);
       
        currentFieldData->fldDebuggerToken = (void*)pFD;
        currentFieldData->fldIsTLS = (pFD->IsThreadStatic() == TRUE);
        currentFieldData->fldMetadataToken = pFD->GetMemberDef();
        currentFieldData->fldIsRVA = (pFD->IsRVA() == TRUE);
        currentFieldData->fldIsContextStatic = (pFD->IsContextStatic() == TRUE);


        // We'll get the sig out of the metadata on the right side
        currentFieldData->fldFullSigSize = 0;
        currentFieldData->fldFullSig = NULL;
        
        PCCOR_SIGNATURE pSig = NULL;
        DWORD cSig = 0;

        g_pEEInterface->FieldDescGetSig(pFD, &pSig, &cSig);
        _ASSERTE(*pSig == IMAGE_CEE_CS_CALLCONV_FIELD);
        ++pSig;
        
        ULONG cb = _skipFunkyModifiersInSignature(pSig);
        pSig = &pSig[cb];
        
        currentFieldData->fldType = (CorElementType) *pSig;

        if (pEnCFD->IsStatic())
        {
            if (pFD->IsThreadStatic())
            {
                // fldOffset is used to store the pointer directly, so that
                // we can get it out in the right side.
                currentFieldData->fldOffset = (SIZE_T)pORField;
            }
            else if (pFD->IsContextStatic())
            {
                // @todo::
                // fill in this
                _ASSERTE(!"NYI!");
            }
            else
            {
                // fldOffset is computed to work correctly with GetStaticFieldValue
                // which computes:
                // addr of pORField = staticVarBase + offsetToFld
                currentFieldData->fldOffset = pORField - staticVarBase;
            }
        }
        else
        {
            // fldOffset is computed to work correctly with GetFieldValue
            // which computes:
            // addr of pORField = object + offsetToVars + offsetToFld
            currentFieldData->fldOffset = pORField - ((BYTE *)pObject + offsetToVars);
        }
        return rcThread->SendIPCReply(iWhich);
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER :
             EXCEPTION_CONTINUE_SEARCH)
    {
        _ASSERTE(!"Given a bad ref to GASSBFI for!");
        hr = CORDBG_E_BAD_REFERENCE_VALUE;
    }

    return hr;
}

//
// GetAndSendFunctionData gets the necessary data for a function and
// sends it back to the right side.
//
HRESULT Debugger::GetAndSendFunctionData(DebuggerRCThread* rcThread,
                                         mdMethodDef funcMetadataToken,
                                         void* funcDebuggerModuleToken,
                                         SIZE_T nVersion,
                                         IpcTarget iWhich)
{
    LOG((LF_CORDB, LL_INFO10000, "D::GASFD: getting function data for "
         "0x%08x 0x%08x.\n", funcMetadataToken, funcDebuggerModuleToken));

    // Make sure we've got good data from the right side.
    _ASSERTE(funcDebuggerModuleToken != NULL);
    _ASSERTE(funcMetadataToken != NULL);

    DebuggerModule* pDebuggerModule =
        (DebuggerModule*) funcDebuggerModuleToken;
    _ASSERTE(pDebuggerModule->m_pRuntimeModule != NULL);

    BaseDomain *bd = pDebuggerModule->m_pRuntimeModule->GetDomain();
    // Setup the event that we'll be sending the results in.
    DebuggerIPCEvent* event = rcThread->GetIPCEventReceiveBuffer(iWhich);
    InitIPCEvent(event, 
                 DB_IPCE_FUNCTION_DATA_RESULT, 
                 0,
                 (void *)(AppDomain *)bd);
    event->FunctionDataResult.funcMetadataToken = funcMetadataToken;
    event->FunctionDataResult.funcDebuggerModuleToken =
        funcDebuggerModuleToken;
    event->FunctionDataResult.funcRVA = 0;
    event->FunctionDataResult.classMetadataToken = mdTypeDefNil;
    event->FunctionDataResult.ilStartAddress = NULL;
    event->FunctionDataResult.ilSize = 0;
    event->FunctionDataResult.ilnVersion = DJI_VERSION_INVALID;
    event->FunctionDataResult.nativeStartAddressPtr = NULL;
    event->FunctionDataResult.nativeSize = 0;
    event->FunctionDataResult.nativenVersion = DJI_VERSION_INVALID;
    event->FunctionDataResult.CodeVersionToken = NULL;
    event->FunctionDataResult.nVersionMostRecentEnC = DJI_VERSION_INVALID;
    
#ifdef DEBUG
    event->FunctionDataResult.nativeOffset = 0xdeadbeef;
        // Since Populate doesn't create a CordbNativeFrame, we don't
        // need the nativeOffset field to contain anything valid...
#endif //DEBUG
    event->FunctionDataResult.localVarSigToken = mdSignatureNil;
    event->FunctionDataResult.ilToNativeMapAddr = NULL;
    event->FunctionDataResult.ilToNativeMapSize = 0;

    MethodDesc *pFD=NULL;

    // @todo we're assuming this is IL code. This will need minor
    // mods for native managed code.
    HRESULT hr = GetFunctionInfo(
          pDebuggerModule->m_pRuntimeModule,
         funcMetadataToken, &pFD,
         &event->FunctionDataResult.funcRVA,
         (BYTE**) &event->FunctionDataResult.ilStartAddress,
         (unsigned int *) &event->FunctionDataResult.ilSize,
         &event->FunctionDataResult.localVarSigToken);

    
    if (SUCCEEDED(hr))
    {
        if (pFD != NULL)
        {
            DebuggerJitInfo *ji = GetJitInfo(pFD, (const BYTE*)nVersion, true);
            
            if (ji != NULL && ji->m_jitComplete)
            {
                LOG((LF_CORDB, LL_INFO10000, "EE:D::GASFD: JIT info found.\n"));
                
                // Send over the native info
                // Note that m_addrOfCode may be NULL (if the code was pitched)
                event->FunctionDataResult.nativeStartAddressPtr = 
                    &(ji->m_addrOfCode);

                // We should use the DJI rather than GetFunctionSize because
                // LockAndSendEnCRemapEvent will stop us at a point
                // that's prior to the MethodDesc getting updated, so it will
                // look as though the method hasn't been JITted yet, even
                // though we may get the LockAndSendEnCRemapEvent as a result
                // of a JITComplete callback
                event->FunctionDataResult.nativeSize = ji->m_sizeOfCode;

                event->FunctionDataResult.nativenVersion = ji->m_nVersion;
                event->FunctionDataResult.CodeVersionToken = (void*)ji;

                // Pass back the pointers to the sequence point map so
                // that the RIght Side can copy it out if needed.
                _ASSERTE(ji->m_sequenceMapSorted);
                
                event->FunctionDataResult.ilToNativeMapAddr =
                    ji->m_sequenceMap;
                event->FunctionDataResult.ilToNativeMapSize =
                    ji->m_sequenceMapCount;
            }
            else
            {
                event->FunctionDataResult.CodeVersionToken = NULL;
            }

            SIZE_T nVersionMostRecentlyEnCd = GetVersionNumber(pFD);
    
            event->FunctionDataResult.nVersionMostRecentEnC = nVersionMostRecentlyEnCd;

            // There's no way to do an EnC on a method with an IL body without 
            // providing IL, so either we can't get the IL, or else the version
            // number of the IL is the same as the most recently EnC'd version.
            event->FunctionDataResult.ilnVersion = nVersionMostRecentlyEnCd;

            // Send back the typeDef token for the class that this
            // function belongs to.
            event->FunctionDataResult.classMetadataToken =
                pFD->GetClass()->GetCl();

            LOG((LF_CORDB, LL_INFO10000, "D::GASFD: function is class. "
                 "0x%08x\n",
                 event->FunctionDataResult.classMetadataToken));
        }
        else
        {
            // No MethodDesc, so the class hasn't been loaded yet.
            // Get the class this method is in.
            mdToken tkParent;
            
            hr = g_pEEInterface->GetParentToken(
                                          pDebuggerModule->m_pRuntimeModule,
                                          funcMetadataToken,
                                          &tkParent);

            if (SUCCEEDED(hr))
            {
                _ASSERTE(TypeFromToken(tkParent) == mdtTypeDef);
            
                event->FunctionDataResult.classMetadataToken = tkParent;

                LOG((LF_CORDB, LL_INFO10000, "D::GASFD: function is class. "
                     "0x%08x\n",
                     event->FunctionDataResult.classMetadataToken));
            }
        }
    }

    // If we didn't get the MethodDesc, then we didn't get the version
    // number b/c it was never set (the DJI tables are indexed by MethodDesc)
    if (pFD == NULL)
    {
        event->FunctionDataResult.nVersionMostRecentEnC = DebuggerJitInfo::DJI_VERSION_FIRST_VALID;
        event->FunctionDataResult.ilnVersion = DebuggerJitInfo::DJI_VERSION_FIRST_VALID;
    }
    
    event->hr = hr;
    
    LOG((LF_CORDB, LL_INFO10000, "D::GASFD: sending result->nSAP:0x%x\n",
            event->FunctionDataResult.nativeStartAddressPtr));

    // Send off the data to the right side.
    hr = rcThread->SendIPCReply(iWhich);
    
    return hr;
}


// If the module lookup for (*pobjClassDebuggerModuleToken) failed 
// and we're in-process debugging, assume it's an inmemory module and 
// that it needs to be added. 
void Debugger::EnsureModuleLoadedForInproc(
    void ** pobjClassDebuggerModuleToken, // in-out
    EEClass *objClass, // in
    AppDomain *pAppDomain, // in
    IpcTarget iWhich // in
)
{
    _ASSERTE(pobjClassDebuggerModuleToken != NULL);
    
    if (*pobjClassDebuggerModuleToken == NULL && iWhich == IPC_TARGET_INPROC)
    {
        // Get the module for the class (it should be in-memory)
        Module *pMod = objClass->GetModule();
        _ASSERTE(pMod != NULL);

        // Add the module and get a DebuggerModule back
        DebuggerModule *pDMod = AddDebuggerModule(pMod, pAppDomain);
        _ASSERTE(pDMod != NULL);
        _ASSERTE(LookupModule(objClass->GetModule(), pAppDomain) != NULL);

        // Now set the token
        *pobjClassDebuggerModuleToken = (void*)pDMod;
            (void*) LookupModule(objClass->GetModule(), pAppDomain);
    }
    _ASSERTE (*pobjClassDebuggerModuleToken != NULL);
}

//
// GetAndSendObjectInfo gets the necessary data for an object and
// sends it back to the right side.
//
HRESULT Debugger::GetAndSendObjectInfo(DebuggerRCThread* rcThread,
                                       AppDomain *pAppDomain,
                                       void* objectRefAddress,
                                       bool objectRefInHandle,
                                       bool objectRefIsValue,
                                       CorElementType objectType,
                                       bool fStrongNewRef,
                                       bool fMakeHandle,
                                       IpcTarget iWhich)
{
    LOG((LF_CORDB, LL_INFO10000, "D::GASOI: getting info for "
         "0x%08x %d %d.\n", objectRefAddress, objectRefInHandle,
         objectRefIsValue));

    Object *objPtr;
    void *objRef;
        
    // Setup the event that we'll be sending the results in.
    DebuggerIPCEvent* event = rcThread->GetIPCEventReceiveBuffer(iWhich);
    InitIPCEvent(event, 
                 DB_IPCE_GET_OBJECT_INFO_RESULT, 
                 0,
                 (void *)pAppDomain);

    DebuggerIPCE_ObjectData *oi = &(event->GetObjectInfoResult);
    oi->objRef = NULL;
    oi->objRefBad = false;
    oi->objSize = 0;
    oi->objOffsetToVars = 0;
    oi->objectType = objectType;
    oi->objClassMetadataToken = mdTypeDefNil;
    oi->objClassDebuggerModuleToken = NULL;
    oi->nstructInfo.size = 0;
    oi->nstructInfo.ptr = NULL;
    oi->objToken = NULL;

    bool badRef = false;
    
    // We wrap this in SEH just in case the object reference is bad.
    // We can trap the access violation and return a reasonable result.
    __try
    {
        // We use this method for getting info about TypedByRef's,
        // too. But they're somewhat different than you're standard
        // object ref, so we special case here.
        if (objectType == ELEMENT_TYPE_TYPEDBYREF)
        {
            // The objectRefAddress really points to a TypedByRef struct.
            TypedByRef *ra = (TypedByRef*) objectRefAddress;

            // Grab the class. This will be NULL if its an array ref type.
            EEClass *cl = ra->type.AsClass();
            if (cl != NULL)
            {
                // If we have a non-array class, pass back the class
                // token and module.
                oi->objClassMetadataToken = cl->GetCl();
                oi->objClassDebuggerModuleToken =
                    (void*) LookupModule(cl->GetModule(), pAppDomain);
                _ASSERTE (oi->objClassDebuggerModuleToken != NULL);
            }

            // The reference to the object is in the data field of the TypedByRef.
            oi->objRef = ra->data;
        
            LOG((LF_CORDB, LL_INFO10000, "D::GASOI: sending REFANY result: "
                 "ref=0x%08x, cls=0x%08x, mod=0x%08x\n",
                 oi->objRef,
                 oi->objClassMetadataToken,
                 oi->objClassDebuggerModuleToken));

            // Send off the data to the right side.
            return rcThread->SendIPCReply(iWhich);
        }
    
        // Grab the pointer to the object.
        if (objectRefIsValue)
            objRef = objectRefAddress;
        else
            objRef = *((void**)objectRefAddress);
    
        MethodTable *pMT = NULL;
    
        if (objectRefInHandle)
        {
            OBJECTHANDLE oh = (OBJECTHANDLE) objRef;

            if (oh != NULL)
                objPtr = (Object*) g_pEEInterface->GetObjectFromHandle(oh);
            else
            {
                LOG((LF_CORDB, LL_INFO10000,
                     "D::GASOI: bad ref due to null object handle.\n"));
                
                objPtr = NULL;
                badRef = true;
                __leave;
            }
        }
        else
            objPtr = (Object*) objRef;
        
        // Pass back the object pointer.
        oi->objRef = objPtr;

        // Shortcut null references now...
        if (objPtr == NULL)
        {
            LOG((LF_CORDB, LL_INFO10000, "D::GASOI: ref is NULL.\n"));

            badRef = true;
            __leave;
        }
        
        EEClass *objClass = objPtr->GetClass();
        pMT = objPtr->GetMethodTable();

        // Try to verify the integrity of the object. This is not fool proof.
        if (pMT != objClass->GetMethodTable())
        {
            LOG((LF_CORDB, LL_INFO10000, "D::GASOI: MT's don't match.\n"));

            badRef = true;
            __leave;
        }

        // Save basic object info.
        oi->objSize = objPtr->GetSize();
        oi->objOffsetToVars =
            (UINT_PTR)((Object*)objPtr)->GetData() - (UINT_PTR)objPtr;

        // If this is a string object, set the type to ELEMENT_TYPE_STRING.
        if (g_pEEInterface->IsStringObject((Object*)objPtr))
            oi->objectType = ELEMENT_TYPE_STRING;
        else
        {
            if (objClass->IsArrayClass())
            {
                // If this is an array object, set its type appropiatley.
                ArrayClass *ac = (ArrayClass*)objClass;

                //
                // @todo when SDARRAY and MDARRAY are fully
                // deprecated, and when the debuggers can handle it,
                // switch SDARRAY->SZARRAY and MDARRAY->ARRAY. No
                // other change is required other than changing the
                // name of the element type.
                //
                // -- Tue May 25 10:54:06 1999
                //
                if (ac->GetRank() == 1)
                    oi->objectType = ELEMENT_TYPE_SZARRAY;
                else
                    oi->objectType = ELEMENT_TYPE_ARRAY;
            }
            else
            {
                // Its not an array class... but if the element type
                // indicates array, then we have an Object in place of
                // an Array, so we need to change the element type
                // appropiatley.
                if ((oi->objectType == ELEMENT_TYPE_ARRAY) ||
                    (oi->objectType == ELEMENT_TYPE_SZARRAY))
                {
                    oi->objectType = ELEMENT_TYPE_CLASS;
                }
                else if (oi->objectType == ELEMENT_TYPE_STRING)
                {
                    // Well, we thought we had a string, but it turns
                    // out its not an array, nor is it a string. So
                    // we'll just assume the basic object and go from
                    // there.
                    oi->objectType = ELEMENT_TYPE_CLASS;
                }
            }
        }
        
        switch (oi->objectType)
        {
        case ELEMENT_TYPE_STRING:
            {
                LOG((LF_CORDB, LL_INFO10000, "D::GASOI: its a string.\n"));

                StringObject *so = (StringObject*)objPtr;

//                (void*) LookupModule(objClass->GetModule(), pAppDomain);
                oi->stringInfo.length =
                    g_pEEInterface->StringObjectGetStringLength(so);
                oi->stringInfo.offsetToStringBase =
                    (UINT_PTR) g_pEEInterface->StringObjectGetBuffer(so) -
                    (UINT_PTR) objPtr;

                // Pass back the object's class
                oi->objClassMetadataToken = objClass->GetCl();
                oi->objClassDebuggerModuleToken =
                    (void*) LookupModule(objClass->GetModule(), pAppDomain);

                EnsureModuleLoadedForInproc(&oi->objClassDebuggerModuleToken, 
                    objClass, pAppDomain, iWhich);
            }

            break;

        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_OBJECT:
            // Pass back the object's class
            oi->objClassMetadataToken = objClass->GetCl();
            oi->objClassDebuggerModuleToken =
                (void*) LookupModule(objClass->GetModule(), pAppDomain);

            EnsureModuleLoadedForInproc(&oi->objClassDebuggerModuleToken, 
                objClass, pAppDomain, iWhich);
            
            break;

        //
        // @todo replace MDARRAY with ARRAY when the time comes.
        //
        case ELEMENT_TYPE_SZARRAY:
        case ELEMENT_TYPE_ARRAY:
            {
                if (!pMT->IsArray())
                {
                    LOG((LF_CORDB, LL_INFO10000,
                         "D::GASOI: object should be an array.\n"));

                    badRef = true;
                    __leave;
                }

                ArrayBase *arrPtr = (ArrayBase*)objPtr;
                
                oi->arrayInfo.componentCount = arrPtr->GetNumComponents();
                oi->arrayInfo.offsetToArrayBase =
                    (UINT_PTR)arrPtr->GetDataPtr() - (UINT_PTR)arrPtr;

                if (arrPtr->IsMultiDimArray())
                {
                    oi->arrayInfo.offsetToUpperBounds =
                        (UINT_PTR)arrPtr->GetBoundsPtr() - (UINT_PTR)arrPtr;

                    oi->arrayInfo.offsetToLowerBounds =
                        (UINT_PTR)arrPtr->GetLowerBoundsPtr() - (UINT_PTR)arrPtr;
                }
                else
                {
                    oi->arrayInfo.offsetToUpperBounds = 0;
                    oi->arrayInfo.offsetToLowerBounds = 0;
                }
                
                oi->arrayInfo.rank = arrPtr->GetRank();
                oi->arrayInfo.elementSize =
                    arrPtr->GetMethodTable()->GetComponentSize();
                oi->arrayInfo.elementType =
                    g_pEEInterface->ArrayGetElementType(arrPtr);

                // If the element type is a value type, then we have
                // an array of value types. Adjust the element's class
                // accordingly.
                if (oi->arrayInfo.elementType == ELEMENT_TYPE_VALUETYPE)
                {
                    // For value class elements, we must pass the
                    // exact class of the elements back to the
                    // Right Side for proper dereferencing.
                    EEClass *cl = arrPtr->GetElementTypeHandle().GetClass();

                    oi->objClassMetadataToken = cl->GetCl();
                    oi->objClassDebuggerModuleToken = (void*) LookupModule(
                                                                cl->GetModule(),
                                                                pAppDomain);

                    EnsureModuleLoadedForInproc(&oi->objClassDebuggerModuleToken, 
                        cl, pAppDomain, iWhich);
                }
                
                LOG((LF_CORDB, LL_INFO10000, "D::GASOI: array info: "
                     "baseOff=%d, lowerOff=%d, upperOff=%d, cnt=%d, rank=%d, "
                     "eleSize=%d, eleType=0x%02x\n",
                     oi->arrayInfo.offsetToArrayBase,
                     oi->arrayInfo.offsetToLowerBounds,
                     oi->arrayInfo.offsetToUpperBounds,
                     oi->arrayInfo.componentCount,
                     oi->arrayInfo.rank,
                     oi->arrayInfo.elementSize,
                     oi->arrayInfo.elementType));
            }
        
            break;
            
        default:
            ASSERT(!"Invalid object type!");
        }
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER :
             EXCEPTION_CONTINUE_SEARCH)
    {
        LOG((LF_CORDB, LL_INFO10000,
             "D::GASOI: exception indicated ref is bad.\n"));

        badRef = true;
    }

    if (fMakeHandle)
    {
        if(badRef || objPtr ==NULL)
        {
            oi->objToken = NULL;
        }
        else
        {
            oi->objToken = g_pEEInterface->GetHandleFromObject(objPtr, fStrongNewRef, pAppDomain);
        }
    }
    else
    {
        LOG((LF_CORDB, LL_INFO1000, "D::GASOI: WON'T create a new, "
            "handle!\n"));
            
        // This implies that we got here through a DB_IPCE_VALIDATE_OBJECT
        // message.
        oi->objToken = objectRefAddress;
    }


    oi->objRefBad = badRef;

    LOG((LF_CORDB, LL_INFO10000, "D::GASOI: sending result.\n"));

    // Send off the data to the right side.
    return rcThread->SendIPCReply(iWhich);
}

//
// GetAndSendClassInfo gets the necessary data for an Class and
// sends it back to the right side.
//
// This method operates in one of two modes - the "send class info"
// mode, and "find me the field desc" mode, which is used by 
// GetAndSendSyncBlockFieldInfo to get a FieldDesc for a specific
// field.  If fldToken is mdFieldDefNil, then we're in 
// the first mode, if not, then we're in the FieldDesc mode.  
//  FIELD DESC MODE: We DON'T send message in the FieldDesc mode.  
//      We indicate success by setting *pFD to nonNULL, failure by
//      setting *pFD to NULL.
//
HRESULT Debugger::GetAndSendClassInfo(DebuggerRCThread* rcThread,
                                      void* classDebuggerModuleToken,
                                      mdTypeDef classMetadataToken,
                                      AppDomain *pAppDomain,
                                      mdFieldDef fldToken,
                                      FieldDesc **pFD, //OUT
                                      IpcTarget iWhich)
{
    LOG((LF_CORDB, LL_INFO10000, "D::GASCI: getting info for 0x%08x 0x%0x8.\n",
         classDebuggerModuleToken, classMetadataToken));

    HRESULT hr = S_OK;

    _ASSERTE( fldToken == mdFieldDefNil || pFD != NULL);

    BOOL fSendClassInfoMode = fldToken == mdFieldDefNil;

#ifdef _DEBUG
    if (!fSendClassInfoMode)
    {
        _ASSERTE(pFD != NULL);
        (*pFD) = NULL;
    }
#endif //_DEBUG

    // Setup the event that we will return the results in
    DebuggerIPCEvent* event= rcThread->GetIPCEventSendBuffer(iWhich);
    InitIPCEvent(event, DB_IPCE_GET_CLASS_INFO_RESULT, 0, pAppDomain);
    
    // Find the class given its module and token. The class must be loaded.
    DebuggerModule *pDebuggerModule = (DebuggerModule*) classDebuggerModuleToken;
    
    EEClass *pClass = g_pEEInterface->FindLoadedClass(pDebuggerModule->m_pRuntimeModule, classMetadataToken);

    // If we can't find the class, return the proper HR to the right side. Note: if the class is not a value class and
    // the class is also not restored, then we must pretend that the class is still not loaded. We are gonna let
    // unrestored value classes slide, though, and special case access to the class's parent below.
    if ((pClass == NULL) || (!pClass->IsValueClass() && !pClass->IsRestored()))
    {
        LOG((LF_CORDB, LL_INFO10000, "D::GASCI: class isn't loaded.\n"));
        
        event->hr = CORDBG_E_CLASS_NOT_LOADED;
        
        if (iWhich == IPC_TARGET_OUTOFPROC && fSendClassInfoMode)
            return rcThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
        else
            return S_OK;
    }
    
    // Count the instance and static fields for this class.
    unsigned int parentIFCount = 0;

    // Note: don't try to access the parent if this is an unrestored value class. The parent doesn't have any fields to
    // contribute in such a case anyway...
    if (!pClass->IsValueClass() || pClass->IsRestored())
        if (pClass->GetParentClass() != NULL)
            parentIFCount = pClass->GetParentClass()->GetNumInstanceFields();

    unsigned int IFCount = pClass->GetNumInstanceFields() - parentIFCount;
    unsigned int SFCount = pClass->GetNumStaticFields();
    unsigned int totalFields = IFCount + SFCount;
    unsigned int fieldCount = 0;

    event->GetClassInfoResult.isValueClass = (pClass->IsValueClass() != 0);
    event->GetClassInfoResult.objectSize = pClass->GetNumInstanceFieldBytes();

    if (classMetadataToken == COR_GLOBAL_PARENT_TOKEN)
    {
        // The static var base for the global class in a module is really just the Module's base address.
        event->GetClassInfoResult.staticVarBase = pClass->GetModule()->GetPEFile()->GetBase();
    }
    else if (pClass->IsShared())
    {
        // For shared classes, we have to lookup the static var base for the app domain that we're currently working in.
        DomainLocalClass *pLocalClass = pClass->GetDomainLocalClassNoLock(pDebuggerModule->m_pAppDomain);

        if (pLocalClass)
            event->GetClassInfoResult.staticVarBase = pLocalClass->GetStaticSpace();
        else
            event->GetClassInfoResult.staticVarBase = NULL;
    }
    else
    {
        // For normal, non-shared classes, the static var base if just the class's vtable. Note: the class must be
        // restored for its statics to be available!
        if (pClass->IsRestored())
            event->GetClassInfoResult.staticVarBase = pClass->GetVtable();
        else
            event->GetClassInfoResult.staticVarBase = NULL;
    }
    
    event->GetClassInfoResult.instanceVarCount = IFCount;
    event->GetClassInfoResult.staticVarCount = SFCount;
    event->GetClassInfoResult.fieldCount = 0;

    DebuggerIPCE_FieldData *currentFieldData = &(event->GetClassInfoResult.fieldData);
    unsigned int eventSize = (UINT_PTR)currentFieldData - (UINT_PTR)event;
    unsigned int eventMaxSize = CorDBIPC_BUFFER_SIZE;
    
    LOG((LF_CORDB, LL_INFO10000, "D::GASCI: total fields=%d.\n", totalFields));
    
    FieldDescIterator fdIterator(pClass, FieldDescIterator::INSTANCE_FIELDS | FieldDescIterator::STATIC_FIELDS);
    FieldDesc* fd;

    while ((fd = fdIterator.Next()) != NULL)
    {
        if (!fSendClassInfoMode)
        {
            // We're looking for a specific fieldDesc, see if we got it.
            if (fd->GetMemberDef() == fldToken)
            {
                (*pFD) = fd;
                return S_OK;
            }
            else
                continue;
        }
        
        currentFieldData->fldIsStatic = (fd->IsStatic() == TRUE);
        currentFieldData->fldIsPrimitive = (fd->IsPrimitive() == TRUE);
        
        // If the field was newly introduced via EnC, and hasn't yet
        // been fixed up, then we'll send back a marker indicating
        // that it isn't yet available.
        if (fd->IsEnCNew() && ((EnCFieldDesc *)fd)->NeedsFixup())
        {
            currentFieldData->fldDebuggerToken = (void*)fd;
            currentFieldData->fldMetadataToken = fd->GetMemberDef();
            currentFieldData->fldType = ELEMENT_TYPE_MAX;  // This is what
                    //that tells the right side the field is unavailable.
            currentFieldData->fldOffset = -1;
            currentFieldData->fldIsTLS = FALSE;
            currentFieldData->fldIsRVA = FALSE;
            currentFieldData->fldIsContextStatic = FALSE;

        }
        else if (fd->IsEnCNew()) //  Is EnC'd, but has been fixed up - 
            // Check and see if there's a sync block entry for it.
        {
            //EnCFieldDesc *pEnCFd = (EnCFieldDesc *)fd;

            currentFieldData->fldDebuggerToken = (void*)fd;
            currentFieldData->fldMetadataToken = fd->GetMemberDef();
            currentFieldData->fldType = ELEMENT_TYPE_MAX;  // This is what
                    //that tells the right side the field is unavailable.
            currentFieldData->fldOffset = -1;
            currentFieldData->fldIsTLS = FALSE;
            currentFieldData->fldIsRVA = FALSE;
            currentFieldData->fldIsContextStatic = FALSE;
        }
        else
        {
            // Otherwise, we'll simply grab the info & send it back.
            
            currentFieldData->fldDebuggerToken = (void*)fd;
            currentFieldData->fldOffset = fd->GetOffset();
            currentFieldData->fldIsTLS = (fd->IsThreadStatic() == TRUE);
            currentFieldData->fldMetadataToken = fd->GetMemberDef();
            currentFieldData->fldIsRVA = (fd->IsRVA() == TRUE);
            currentFieldData->fldIsContextStatic = (fd->IsContextStatic() == TRUE);

            PCCOR_SIGNATURE pSig = NULL;
            DWORD cSig = 0;

            g_pEEInterface->FieldDescGetSig(fd, &pSig, &cSig);
            _ASSERTE(*pSig == IMAGE_CEE_CS_CALLCONV_FIELD);
            ++pSig;
            
            ULONG cb = _skipFunkyModifiersInSignature(pSig);
            pSig = &pSig[cb];
            
            currentFieldData->fldType = (CorElementType) *pSig;
        }
        
        _ASSERTE( currentFieldData->fldType != ELEMENT_TYPE_CMOD_REQD);

        // Bump our counts and pointers for the next event.
        event->GetClassInfoResult.fieldCount++;
        fieldCount++;
        currentFieldData++;
        eventSize += sizeof(DebuggerIPCE_FieldData);

        // If that was the last field that will fit, send the event now and prep the next one.
        if ((eventSize + sizeof(DebuggerIPCE_FieldData)) >= eventMaxSize)
        {
            LOG((LF_CORDB, LL_INFO10000, "D::GASCI: sending a result, fieldCount=%d, totalFields=%d\n",
                 event->GetClassInfoResult.fieldCount, totalFields));

            if (iWhich == IPC_TARGET_OUTOFPROC)
            {
                hr = rcThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
            }
            else
            {
                DebuggerIPCEvent *newEvent = m_pRCThread->GetIPCEventSendBufferContinuation(event);

                if (newEvent != NULL)
                {
                    InitIPCEvent(newEvent, DB_IPCE_GET_CLASS_INFO_RESULT, 0, pAppDomain);
                    newEvent->GetClassInfoResult.isValueClass = event->GetClassInfoResult.isValueClass;
                    newEvent->GetClassInfoResult.objectSize = event->GetClassInfoResult.objectSize;
                    newEvent->GetClassInfoResult.staticVarBase = event->GetClassInfoResult.staticVarBase;
                    newEvent->GetClassInfoResult.instanceVarCount = event->GetClassInfoResult.instanceVarCount;
                    newEvent->GetClassInfoResult.staticVarCount = event->GetClassInfoResult.staticVarCount;

                    event = newEvent;
                }
                else
                    return E_OUTOFMEMORY;
            }   
            
            event->GetClassInfoResult.fieldCount = 0;
            currentFieldData = &(event->GetClassInfoResult.fieldData);
            eventSize = (UINT_PTR)currentFieldData - (UINT_PTR)event;
        }
    }

    _ASSERTE(!fSendClassInfoMode || 
             fieldCount == totalFields);

    if (fSendClassInfoMode && 
         (event->GetClassInfoResult.fieldCount > 0 || totalFields == 0))
    {
        LOG((LF_CORDB, LL_INFO10000, "D::GASCI: sending final result, fieldCount=%d, totalFields=%d\n",
             event->GetClassInfoResult.fieldCount, totalFields));

        if (iWhich == IPC_TARGET_OUTOFPROC)
            hr = rcThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
        else
            hr = S_OK;
    }
    
    return hr;
}


//
// GetAndSendClassInfo gets the necessary data for an Class and
// sends it back to the right side.
//
HRESULT Debugger::GetAndSendSpecialStaticInfo(DebuggerRCThread* rcThread,
                                              void *fldDebuggerToken,
                                              void *debuggerThreadToken,
                                              IpcTarget iWhich)
{
    LOG((LF_CORDB, LL_INFO10000, "D::GASSSI: getting info for "
         "0x%08x 0x%0x8.\n", fldDebuggerToken, debuggerThreadToken));

    HRESULT hr = S_OK;

    // Setup the event that we'll be sending the results in.
    DebuggerIPCEvent* event = rcThread->GetIPCEventReceiveBuffer(iWhich);
    InitIPCEvent(event, 
                 DB_IPCE_GET_SPECIAL_STATIC_RESULT, 
                 0, NULL);

    // Find out where the field is living...
    Thread *pRuntimeThread = (Thread*)debuggerThreadToken;
    FieldDesc *pField = (FieldDesc*)fldDebuggerToken;

    if (pField->IsThreadStatic())
    {
        event->GetSpecialStaticResult.fldAddress =
            pRuntimeThread->GetStaticFieldAddrForDebugger(pField);
    }
    else if (pField->IsContextStatic())
    {
        event->GetSpecialStaticResult.fldAddress = Context::GetStaticFieldAddrForDebugger(pRuntimeThread, pField);
    }
    else
    {
        // In case, we have more special cases added. You will never know!
        _ASSERTE(!"NYI");
    }

    // Send off the data to the right side.
    hr = rcThread->SendIPCReply(iWhich);
    
    return hr;
}


//
// GetAndSendJITInfo gets the necessary JIT data for a function and
// sends it back to the right side.
//
HRESULT Debugger::GetAndSendJITInfo(DebuggerRCThread* rcThread,
                                    mdMethodDef funcMetadataToken,
                                    void *funcDebuggerModuleToken,
                                    AppDomain *pAppDomain,
                                    IpcTarget iWhich)
{
    LOG((LF_CORDB, LL_INFO10000, "D::GASJI: getting info for "
         "0x%08x 0x%08x\n", funcMetadataToken, funcDebuggerModuleToken));
    
    unsigned int totalNativeInfos = 0;
    unsigned int argCount = 0;

    HRESULT hr = S_OK;

    DebuggerModule *pDebuggerModule =
        (DebuggerModule*) funcDebuggerModuleToken;
    
    MethodDesc* pFD = g_pEEInterface->LookupMethodDescFromToken(
                                          pDebuggerModule->m_pRuntimeModule,
                                          funcMetadataToken);

    DebuggerJitInfo *pJITInfo = NULL;

    //
    // Find the JIT info for this function.
    //
    // @todo ENC We need to be given the version number to look for.
    if (pFD != NULL)
        pJITInfo = GetJitInfo(pFD, NULL);
    else
        LOG((LF_CORDB, LL_INFO10000, "D::GASJI: no fd found...\n"));

    if ((pJITInfo != NULL) && (pJITInfo->m_jitComplete))
    {
        argCount = GetArgCount(pFD);
        totalNativeInfos = pJITInfo->m_varNativeInfoCount;
    }
    else
    {
        pJITInfo = NULL;
        LOG((LF_CORDB, LL_INFO10000, "D::GASJI: no JIT info found...\n"));
    }
    
    //
    // Prepare the result event.
    //
    DebuggerIPCEvent* event = rcThread->GetIPCEventSendBuffer(iWhich);
    InitIPCEvent(event, 
                 DB_IPCE_GET_JIT_INFO_RESULT, 
                 0,
                 pAppDomain);
    event->GetJITInfoResult.totalNativeInfos = totalNativeInfos;
    event->GetJITInfoResult.argumentCount = argCount;
    event->GetJITInfoResult.nativeInfoCount = 0;
    if (pJITInfo == NULL)
    {
        event->GetJITInfoResult.nVersion = DebuggerJitInfo::DJI_VERSION_INVALID;
    }
    else
    {
        event->GetJITInfoResult.nVersion = pJITInfo->m_nVersion;
    }

    ICorJitInfo::NativeVarInfo *currentNativeInfo =
        &(event->GetJITInfoResult.nativeInfo);
    unsigned int eventSize = (UINT_PTR)currentNativeInfo - (UINT_PTR)event;
    unsigned int eventMaxSize = CorDBIPC_BUFFER_SIZE;

    unsigned int nativeInfoCount = 0;
    
    while (nativeInfoCount < totalNativeInfos)
    {
        *currentNativeInfo = pJITInfo->m_varNativeInfo[nativeInfoCount];

        //
        // Bump our counts and pointers for the next event.
        //
        event->GetJITInfoResult.nativeInfoCount++;
        nativeInfoCount++;
        currentNativeInfo++;
        eventSize += sizeof(*currentNativeInfo);

        //
        // If that was the last field that will fit, send the event now
        // and prep the next one.
        //
        if ((eventSize + sizeof(*currentNativeInfo)) >= eventMaxSize)
        {
            LOG((LF_CORDB, LL_INFO10000, "D::GASJI: sending a result\n"));

            if (iWhich == IPC_TARGET_OUTOFPROC)
            {
                hr = rcThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
            }
            else
            {
                _ASSERTE( iWhich == IPC_TARGET_INPROC);
                event = rcThread->GetIPCEventSendBufferContinuation(event);
                if (NULL == event)
                    return E_OUTOFMEMORY;

                InitIPCEvent(event, 
                             DB_IPCE_GET_JIT_INFO_RESULT, 
                             0,
                             pAppDomain);
                event->GetJITInfoResult.totalNativeInfos = totalNativeInfos;
                event->GetJITInfoResult.argumentCount = argCount;
            }
            
            event->GetJITInfoResult.nativeInfoCount = 0;
            currentNativeInfo = &(event->GetJITInfoResult.nativeInfo);
            eventSize = (UINT_PTR)currentNativeInfo - (UINT_PTR)event;
        }
    }

    if (((event->GetJITInfoResult.nativeInfoCount > 0) ||
         (totalNativeInfos == 0)) && (iWhich ==IPC_TARGET_OUTOFPROC))
    {
        LOG((LF_CORDB, LL_INFO10000, "D::GASJI: sending final result\n"));
                 
        hr = rcThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
    }
    
    return hr;
}

//
// GetAndSendTransitionStubInfo figures out if an address is a stub
// address and sends the result back to the right side.
//
void Debugger::GetAndSendTransitionStubInfo(const BYTE *stubAddress, IpcTarget iWhich)
{
    LOG((LF_CORDB, LL_INFO10000, "D::GASTSI: IsTransitionStub. Addr=0x%08x\n", stubAddress));
            
    bool result = false;
    
    __try
    {
        // Try to see if this address is for a stub. If the address is
        // completely bogus, then this might fault, so we protect it
        // with SEH.
        result = g_pEEInterface->IsStub(stubAddress);
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        LOG((LF_CORDB, LL_INFO10000, "D::GASTSI: exception indicated addr is bad.\n"));

        result = false;
    }

    // We control excluding the CLR from the calculation based on a reg key. This lets CLR devs override the check and
    // step through the CLR codebase.
    static DWORD excludeCLR = 0;
    static bool  excludeCLRInited = false;

    if (!excludeCLRInited)
    {
        excludeCLR = REGUTIL::GetConfigDWORD(L"DbgCLRDEV", 0);
        excludeCLRInited = true;
    }
    
    // If its not a stub, then maybe its an address in mscoree?
    if ((result == false) && (excludeCLR == 0))
        result = (IsIPInModule(g_pMSCorEE, (BYTE*)stubAddress) == TRUE);
    
    // This is a synchronous event (reply required)
    DebuggerIPCEvent *event = m_pRCThread->GetIPCEventReceiveBuffer(iWhich);
    InitIPCEvent(event, DB_IPCE_IS_TRANSITION_STUB_RESULT, 0, NULL);
    event->IsTransitionStubResult.isStub = result;
        
    // Send the result
    m_pRCThread->SendIPCReply(iWhich);
}

/*
 * A generic request for a buffer
 *
 * This is a synchronous event (reply required).
 */
HRESULT Debugger::GetAndSendBuffer(DebuggerRCThread* rcThread, ULONG bufSize)
{
    // This is a synchronous event (reply required)
    DebuggerIPCEvent* event = rcThread->GetIPCEventReceiveBuffer(IPC_TARGET_OUTOFPROC);
    InitIPCEvent(event, DB_IPCE_GET_BUFFER_RESULT, 0, NULL);

    // Allocate the buffer
    event->GetBufferResult.pBuffer = new (interopsafe) BYTE[bufSize];

    LOG((LF_CORDB, LL_EVERYTHING, "D::GASB: new'd 0x%x\n", event->GetBufferResult.pBuffer));

    // Check for out of memory error
    if (event->GetBufferResult.pBuffer == NULL)
        event->GetBufferResult.hr = E_OUTOFMEMORY;
    else
    {
        _ASSERTE(m_pMemBlobs != NULL);
        BYTE **ppNextBlob = m_pMemBlobs->Append();
        (*ppNextBlob) = (BYTE *)event->GetBufferResult.pBuffer;
        
        event->GetBufferResult.hr = S_OK;
    }
    
    // Send the result
    return rcThread->SendIPCReply(IPC_TARGET_OUTOFPROC);
}

/*
 * Used to release a previously-requested buffer
 *
 * This is a synchronous event (reply required).
 */
HRESULT Debugger::SendReleaseBuffer(DebuggerRCThread* rcThread, BYTE *pBuffer)
{
    LOG((LF_CORDB,LL_INFO10000, "D::SRB for buffer 0x%x\n", pBuffer));

    // This is a synchronous event (reply required)
    DebuggerIPCEvent* event = rcThread->GetIPCEventReceiveBuffer(IPC_TARGET_OUTOFPROC);
    InitIPCEvent(event, DB_IPCE_RELEASE_BUFFER_RESULT, 0, NULL);

    _ASSERTE(pBuffer != NULL);

    // Free the memory
    ReleaseRemoteBuffer(pBuffer, true);

    // Indicate success in reply
    event->ReleaseBufferResult.hr = S_OK;
    
    // Send the result
    return rcThread->SendIPCReply(IPC_TARGET_OUTOFPROC);
}


//
// Used to delete the buffer previously-requested  by the right side.
// We've factored the code since both the ~Debugger and SendReleaseBuffer
// methods do this.
//
HRESULT Debugger::ReleaseRemoteBuffer(BYTE *pBuffer, bool removeFromBlobList)
{
    LOG((LF_CORDB, LL_EVERYTHING, "D::RRB: Releasing RS-alloc'd buffer 0x%x\n", pBuffer));

    // Remove the buffer from the blob list if necessary.
    if (removeFromBlobList && (m_pMemBlobs != NULL))
    {
        USHORT cBlobs = m_pMemBlobs->Count();
        BYTE **rgpBlobs = m_pMemBlobs->Table();

        for (USHORT i = 0; i < cBlobs; i++)
        {
            if (rgpBlobs[i] == pBuffer)
            {
                m_pMemBlobs->DeleteByIndex(i);
                break;
            }
        }
    }

    // Delete the buffer.
    DeleteInteropSafe(pBuffer);

    return S_OK;
}

//
// SendUpdateFunctionBuf allocates the necessary storage for the new
// il code and passes the address back to the right side to copy into.
//
HRESULT Debugger::CommitAndSendResult(DebuggerRCThread* rcThread, 
                                      BYTE *pData,
                                      BOOL checkOnly)
{
    HRESULT hr = S_OK;

    LOG((LF_CORDB, LL_INFO1000, "Debugger::CommitAndSendResult\n"));

    // This is a synchronous event (reply required)
    DebuggerIPCEvent* event = rcThread->GetIPCEventReceiveBuffer(
        IPC_TARGET_OUTOFPROC);
    InitIPCEvent(event, 
                 DB_IPCE_COMMIT_RESULT, 
                 NULL,
                 NULL);

    UnorderedEnCErrorInfoArray *errors = new (interopsafe) UnorderedEnCErrorInfoArray();

    // If we're in 'Commit' mode, 
    if (errors == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    // Perform the commit operation
    if (!FAILED(hr))
    {
        // This will translate the debugger tokens into VM Module pointers,
        // then fix up the (internal) pointers so that we can access the
        // UnorderedILMap entries as if they are in a CBinarySearch object,
        // which they are.
        FixupEnCInfo((EnCInfo *)pData, errors);
        
        hr = g_pEEInterface->EnCCommit((EnCInfo *)pData, 
            errors, 
            &m_EnCRemapInfo,
            checkOnly);
    }
    
    ULONG32 cbErr = 0;
    void *errTable = NULL;
    if(errors==NULL ||errors->Count()==0)
    {
        cbErr = 0;
        DeleteInteropSafe(errors);
        errors = NULL;
    }
    else
    {
        // Note that this DOESN'T include the CUnordered array's fields!!
        cbErr = (errors->Count() * sizeof(*(errors->Table())));
        errTable = errors->Table();
    }   
    event->CommitResult.hr = hr;
    event->CommitResult.pErrorArr = (const BYTE *)errors;
    event->CommitResult.cbErrorData = cbErr;

    // Send the result
    return rcThread->SendIPCReply(IPC_TARGET_OUTOFPROC);
}

//
// UnrecoverableError causes the Left Side to enter a state where no more
// debugging can occur and we leave around enough information for the
// Right Side to tell what happened.
//
void Debugger::UnrecoverableError(HRESULT errorHR,
                                  unsigned int errorCode,
                                  const char *errorFile,
                                  unsigned int errorLine,
                                  bool exitThread)
{
    LOG((LF_CORDB, LL_INFO10,
         "Unrecoverable error: hr=0x%08x, code=%d, file=%s, line=%d\n",
         errorHR, errorCode, errorFile, errorLine));
        
    //
    // Setting this will ensure that not much else happens...
    //
    m_unrecoverableError = TRUE;
    
    //
    // Fill out the control block with the error.
    //
    DebuggerIPCControlBlock *pDCB = m_pRCThread->GetDCB(
        IPC_TARGET_OUTOFPROC); // in-proc will find out when the
            // function fails

    pDCB->m_errorHR = errorHR;
    pDCB->m_errorCode = errorCode;

    //
    // Let an unmanaged debugger know that we're here...
    //
    DebugBreak();
    
    //
    // If we're told to, exit the thread.
    //
    if (exitThread)
    {
        LOG((LF_CORDB, LL_INFO10,
             "Thread exiting due to unrecoverable error.\n"));
        ExitThread(errorHR);
    }
}

//
// Callback for IsThreadAtSafePlace's stack walk.
//
StackWalkAction Debugger::AtSafePlaceStackWalkCallback(CrawlFrame *pCF,
                                                       VOID* data)
{
    bool *atSafePlace = (bool*)data;

    if (pCF->IsFrameless() && pCF->IsActiveFunc())
        if (g_pEEInterface->CrawlFrameIsGcSafe(pCF))
            *atSafePlace = true;

    return SWA_ABORT;
}

//
// Determine, via a quick one frame stack walk, if a given thread is
// in a gc safe place.
//
bool Debugger::IsThreadAtSafePlace(Thread *thread)
{
    bool atSafePlace = false;
    
    // Setup our register display.
    REGDISPLAY rd;
    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
    CONTEXT ctx;        
    
    _ASSERTE(!(g_pEEInterface->GetThreadFilterContext(thread) && ISREDIRECTEDTHREAD(thread)));

    if (context != NULL)
        g_pEEInterface->InitRegDisplay(thread, &rd, context, TRUE);
    else if (ISREDIRECTEDTHREAD(thread))
        thread->GetFrame()->UpdateRegDisplay(&rd);
    else
    {        
        ctx.Eip = 0;
        rd.pPC = (SLOT*)&(ctx.Eip);
    }

    // Do the walk. If it fails, we don't care, because we default
    // atSafePlace to false.
    StackWalkAction res = g_pEEInterface->StackWalkFramesEx(
                                 thread,
                                 &rd,
                                 Debugger::AtSafePlaceStackWalkCallback,
                                 (VOID*)(&atSafePlace),
                                 QUICKUNWIND | HANDLESKIPPEDFRAMES);

#ifdef LOGGING
    if (!atSafePlace)
        LOG((LF_CORDB | LF_GC, LL_INFO1000,
             "Thread 0x%x is not at a safe place.\n",
             thread->GetThreadId()));
#endif    
    
    return atSafePlace;
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::GetVarInfo(MethodDesc *       fd,   // [IN] method of interest
                    void *DebuggerVersionToken,    // [IN] which edit version
                    SIZE_T *           cVars,      // [OUT] size of 'vars'
                    const NativeVarInfo **vars     // [OUT] map telling where local vars are stored
                    )
{
    DebuggerJitInfo * ji = (DebuggerJitInfo *)DebuggerVersionToken;

    if (ji == NULL)
    {
        ji = GetJitInfo(fd, NULL);
    }

    _ASSERTE(ji);

    *vars = ji->m_varNativeInfo;
    *cVars = ji->m_varNativeInfoCount;
}

#include "openum.h"

/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::UpdateFunction(MethodDesc* pFD, 
                                 const UnorderedILMap *ilMap,
                                 UnorderedEnCRemapArray *pEnCRemapInfo,
                                 UnorderedEnCErrorInfoArray *pEnCError)
{
#ifdef LOGGING
    if( ilMap == NULL )
    {
        LOG((LF_CORDB,LL_INFO10000, "D::UF: Given NULL IL map!\n"));
    }
    else
    {
        LOG((LF_CORDB,LL_INFO10000, "D::UF: cElts:0x%x\n",
            ilMap->cMap));

        COR_IL_MAP *temp = ilMap->pMap;

        for (unsigned i = 0; i < ilMap->cMap;i++,temp++)
        {
            LOG((LF_CORDB,LL_INFO10000, "D::UF:\told:0x%x to new:0x%x (fAcc:0x%x)\n",
                temp->oldOffset, temp->newOffset, temp->fAccurate));
        }
    }
#endif //LOGGING    

    LOG((LF_CORDB, LL_INFO10000, "D::UF: updating for for "
         "%s::%s 0x%08x\n", pFD->m_pszDebugClassName,
         pFD->m_pszDebugMethodName, ilMap));

    // Grab the jit info for this method.
    DebuggerJitInfo *pJitInfo = GetJitInfo(pFD, 
        (const BYTE*)DebuggerJitInfo::DJI_VERSION_MOST_RECENTLY_JITTED,
        true);

#ifdef LOGGING
    if (pJitInfo == NULL )
        LOG((LF_CORDB,LL_INFO10000,"Unable to get DJI by recently "
            "JITted version number (it hasn't been jitted yet),"
            "which is fine\n"));
#endif //LOGGING

    if (!pJitInfo)
    {
        // We'll stash the info for the events & send the events
        // themselves later.
        EnCRemapInfo *pRemap = pEnCRemapInfo->Append();
        if (NULL == pRemap)
            return E_OUTOFMEMORY;

        pRemap->m_funcMetadataToken = pFD->GetMemberDef();
        Module *pRuntimeModule = pFD->GetModule();

        pRemap->m_threadId = GetCurrentThreadId(); // This will be called
            //from the RC Thread, mind you, so it's not managed...
            pRemap->m_pAppDomainToken = pRuntimeModule->GetDomain();
        
        pRemap->m_debuggerModuleToken = g_pDebugger->LookupModule(
                                            pRuntimeModule,
                                            (AppDomain *)pRuntimeModule->GetDomain());

        pRemap->m_fAccurate = TRUE; 

        LOG((LF_CORDB, LL_INFO10000, "D::UF: Will send remap immediately\n"));


        // lotsa' args, just to get the local signature token, in case
        // we have to create the CordbFunction object on the right side.
        MethodDesc *pFDTemp;
        BYTE  *codeStartIgnore;
        unsigned int codeSizeIgnore;
        
        HRESULT hr = GetFunctionInfo(
             pRuntimeModule,
             pRemap->m_funcMetadataToken,
             &pFDTemp,
             &(pRemap->m_RVA),
             &codeStartIgnore,
             &codeSizeIgnore,
             &(pRemap->m_localSigToken) );
        if (FAILED(hr))
        {
            EnCErrorInfo *pError = pEnCError->Append();

            ADD_ENC_ERROR_ENTRY(pError, 
                            hr, 
                            NULL, //we'll fill these in later
                            pRemap->m_funcMetadataToken);
                            
            return E_FAIL;
        }
        
        _ASSERTE(pFD == pFDTemp);
        _ASSERTE(m_syncingForAttach == SYNC_STATE_0 ||
                 m_syncingForAttach == SYNC_STATE_20);

        m_syncingForAttach = SYNC_STATE_20;
        LOG((LF_CORDB, LL_INFO10000, "Attach state is now %s\n", g_ppszAttachStateToSZ[m_syncingForAttach]));
    }
    else if (!pJitInfo->m_encBreakpointsApplied)
    {
        // We only place the patches if we have jit info for this
        // function, i.e., its already been jitted. Otherwise, the EE will
        // pickup the new method on the next JIT anyway.

        // We want to filter out bad sequence points, if they
        // try to change the exception handling structure.
        // Unfortunately, the code for that is in excep.cpp, so
        // we'll call into the EE to do this.
        COR_ILMETHOD_DECODER decoder(g_pEEInterface->MethodDescGetILHeader(pFD));
        g_pEEInterface->FilterEnCBreakpointsByEH(pJitInfo->m_sequenceMap,
                                                 pJitInfo->m_sequenceMapCount,
                                                 &decoder,
                                                 pJitInfo->m_addrOfCode,
                                                 (METHODTOKEN)pFD,
                                                 pJitInfo->m_sizeOfCode);

        pJitInfo->m_codePitched = false;
        
        Module *pModule = g_pEEInterface->MethodDescGetModule(pFD);
        _ASSERTE(pModule != NULL);

        mdMethodDef md = pFD->GetMemberDef();
        ICorDebugInfo::SourceTypes src;

        // For each offset in the IL->Native map, go ahead and set a
        // new E&C breakpoint there.
        for (unsigned int i = 0; i < pJitInfo->m_sequenceMapCount; i++)
        {
            SIZE_T offset = pJitInfo->m_sequenceMap[i].nativeStartOffset;

            if (DbgIsSpecialILOffset(pJitInfo->m_sequenceMap[i].ilOffset))
            {
                LOG((LF_CORDB, LL_INFO10000,
                     "D::UF: not placing E&C breakpoint at special offset 0x%x\n", offset));
                continue;
            }

            if (i >=1 && offset == pJitInfo->m_sequenceMap[i-1].nativeStartOffset)
            {
                LOG((LF_CORDB, LL_INFO10000,
                     "D::UF: not placing redundant E&C "
                     "breakpoint at duplicate offset 0x%x\n",offset));
                continue;
            }

            src = pJitInfo->m_sequenceMap[i].source;
            if (!(src & ICorDebugInfo::STACK_EMPTY))
            {
                LOG((LF_CORDB, LL_INFO10000,
                     "D::UF: not placing E&C breakpoint at offset "
                     "0x%x b/c not STACK_EMPTY:it's 0x%x\n",offset, src));
                continue;
            }
            
            LOG((LF_CORDB, LL_INFO10000,
                 "D::UF: placing E&C breakpoint at native offset 0x%x\n",
                 offset));
        
            DebuggerEnCBreakpoint *bp =
                new (interopsafe) DebuggerEnCBreakpoint(pModule, 
                                          md, 
                                          offset, 
                                          true,
                                          pJitInfo,
                                          (AppDomain *)pModule->GetDomain());
            
            _ASSERTE(bp != NULL);
        }

        pJitInfo->m_encBreakpointsApplied = true;
    }

    // The max version number was bumped up before we entered this method

    // Store the Old IL to new IL map ("Transition map") now.
    pJitInfo = GetJitInfo(pFD, NULL);
    
    if (pJitInfo != NULL )
        // Now tack this map onto the end of the list.  The list may
        // be zero length.
        // @todo OPT Would walking down the list be quicker?
        pJitInfo->LoadEnCILMap((UnorderedILMap *)ilMap);
    else
    {
        if (ilMap != NULL)
        {
            // Note that if we didn't find a previously JITted version, then
            // we don't need to keep track of the IL map, since that means it's
            // never been jitted.
            MapForwardsCurrentBreakpoints((UnorderedILMap *)ilMap, pFD);
        }
    }

    return S_OK;
}

// NOTE similarities to MapAndBindFunctionPatches.  Used to shuffle
// IL offset BPs forwards during an EnC, _before_ we've JITted anything.
// Note that since this is only called when there's no currently jitted
// code, we don't have to worry about a stepper's BP being inside of it.
// Essentially, it's code to handle a special case.
// @todo IF we only map forwards Breakpoints, and this version won't otherwise
// be used, why not eliminate the other patches?
void Debugger::MapForwardsCurrentBreakpoints(UnorderedILMap *ilMapReal, MethodDesc *pFD)
{
    _ASSERTE( ilMapReal != NULL );
    _ASSERTE( pFD != NULL );

    HRESULT hr = S_OK;
    
    Module *pModule = g_pEEInterface->MethodDescGetModule(pFD); 
    mdMethodDef md = pFD->GetMemberDef();

    LOG((LF_CORDB,LL_INFO10000, "D::MFCBP: About to lock patch table\n"));
    DebuggerController::Lock();
    DebuggerPatchTable *pPatchTable = DebuggerController::GetPatchTable();
        
    HASHFIND hf;
    DebuggerControllerPatch *dcp = pPatchTable->GetFirstPatch( &hf );

    SIZE_T ilOffsetNew;

    while ( !FAILED(hr) && dcp != NULL )
    {
        // Only copy over breakpoints that are in this method
        if ( dcp->controller->GetDCType() != DEBUGGER_CONTROLLER_BREAKPOINT ||
             (!(dcp->key.module == pModule && dcp->key.md==md) &&
                dcp->key.module != NULL && dcp->key.md !=mdTokenNil)
            )
        {
            goto LNextLoop;
        }
        
        // Attempt mapping from patch to new version of code, and
        // we don't care if it turns out that there isn't a mapping.
        _ASSERTE( dcp->native == false );

        _ASSERTE(offsetof(DebuggerOldILToNewILMap,ilOffsetOld) == 
                    offsetof(COR_IL_MAP, oldOffset));
        _ASSERTE(offsetof(DebuggerOldILToNewILMap,ilOffsetNew) == 
                    offsetof(COR_IL_MAP, newOffset));

        BOOL fAccurateIgnore;
        if (FAILED( hr = g_pDebugger->MapOldILToNewIL( TRUE, 
                (DebuggerOldILToNewILMap *)ilMapReal->pMap,
                (DebuggerOldILToNewILMap *)(ilMapReal->pMap+ilMapReal->cMap),
                dcp->offset, 
                &ilOffsetNew,
                &fAccurateIgnore)))
        {

            // At this point, we actually have to remove the patch, since
            // it would otherwise be assumed to be in the most recent version
            // @Todo MEMory leak if this is the last patch for the breakpoint? 
            pPatchTable->RemovePatch( dcp );
            // The line went away, ignore it & continue....
            goto LNextLoop;
        }

        dcp->offset = ilOffsetNew;

        if (FAILED(hr))
            break;
LNextLoop:
        dcp = pPatchTable->GetNextPatch( &hf );
    }

    // Lastly, unlock the patch table so it doesn't move while we're
    //  examining it.
    DebuggerController::Unlock();
    LOG((LF_CORDB,LL_INFO10000, "D::MB: Unlocked patch table\n"));
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::MapILInfoToCurrentNative(MethodDesc *PFD,
                                           SIZE_T ilOffset, 
                                           UINT mapType, 
                                           SIZE_T which, 
                                           SIZE_T *nativeFnxStart,
                                           SIZE_T *nativeOffset, 
                                           void *DebuggerVersionToken,
                                           BOOL *fAccurate)
{
    _ASSERTE( nativeOffset != NULL);
    _ASSERTE( PFD != NULL );
    _ASSERTE( nativeFnxStart != NULL );

    LOG((LF_CORDB, LL_INFO1000000, "D::MILITCN: %s::%s ilOff:0x%x, mapType:0x%x"
        "wh:0x%x, natFnx:0x%x dji:0x%x\n", PFD->m_pszDebugClassName,
        PFD->m_pszDebugMethodName, ilOffset, mapType, which, nativeFnxStart,
        DebuggerVersionToken));

    *nativeOffset = 0;
    CorDebugMappingResult mapping = (CorDebugMappingResult)mapType;

    DebuggerJitInfo *djiTo = GetJitInfo( PFD, (const BYTE *)nativeFnxStart);
    if (djiTo == NULL)
        return E_FAIL;

    DebuggerJitInfo *djiFrom = (DebuggerJitInfo *)DebuggerVersionToken;

    if (mapping & (MAPPING_EXACT|MAPPING_APPROXIMATE))
    {
        g_pDebugger->MapThroughVersions(ilOffset, 
                                        djiFrom, 
                                        &ilOffset,
                                        djiTo, 
               (djiFrom->m_nVersion<djiTo->m_nVersion)?(TRUE):(FALSE),
                                        fAccurate);

        *nativeOffset = djiTo->MapILOffsetToNative(ilOffset);
    }
    else
    {
        // Are we in, say, the epilog?
        *nativeOffset = djiTo->MapSpecialToNative(mapping, 
                                                  which,
                                                  fAccurate);
    }
    
    return S_OK;
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::DoEnCDeferedWork(MethodDesc *pMd, 
                                   BOOL fAccurateMapping)
{
    HRESULT hr = S_OK;
    ControllerStackInfo csi;
    CONTEXT Ctx;

    LOG((LF_CORDB, LL_INFO1000000,"D::DEnCDW: MethodDesc:0x%x\n", pMd));

    LockAndSendEnCRemapEvent(pMd, fAccurateMapping);

    Lock();

    Thread *thread = g_pEEInterface->GetThread();
    csi.GetStackInfo(thread, 0, &Ctx, FALSE);

    //Apply any defered breakpoints now, if there are any
    DebuggerJitInfo *djiNew = GetJitInfo(pMd, NULL);
    _ASSERTE(djiNew != NULL);
    
    DebuggerJitInfo *djiPrev = djiNew->m_prevJitInfo;
    // @todo We need to move forwards through multiple versions

    if (djiPrev != NULL)
        hr = djiPrev->UpdateDeferedBreakpoints(djiNew,
                                               thread,
                                               csi.m_activeFrame.fp);

    Unlock();

    return hr;
}

//*****************************************************************************
//
// APSfEnC is called from ResumeInUpdateFunction - it's purpose is to skip
// over any breakpoints that may be present in the next version of a function.
// We _don't_ want to skip any patches if the patches are for our internal
// use.
//
//*****************************************************************************
HRESULT Debugger::ActivatePatchSkipForEnc(CONTEXT *pCtx,
                                          MethodDesc *pMd,
                                          BOOL fShortCircuit)
{
    HRESULT hr = S_OK;
    
    _ASSERTE(pCtx != NULL);
#ifdef _X86_
    _ASSERTE(pCtx->Eip != NULL);
    
    DebuggerControllerPatch *dcpEnC = NULL;
    DebuggerJitInfo *dji = GetJitInfo(pMd, NULL);

    // What'll happen after this:
    // Remap DC's patch will be hit, we'll stop, synch, send the event, the right
    // side will do whatever, then we'll resume.  We've got this rigged up so that
    // we'll ONLY trigger this one event when we get there, so we won't send
    // breakpoints twice, etc.
    // If we want to preserve the 'single-step state' of the CPU (ie, we single-stepped
    // into the new version, the remapper will EnableSingleStep when it sends the event.
    // At that point, one of two things will be true: 
    // a]   There will be no (other) patches, and we'll single-step like normal
    // b]   There will be other patches, but ActivatePatchSkip will skip over them (so
    //      we don't send breakpoints twice), and APS will EnableSingleStep as a 
    //      byproducts of it's action.
    

    // This used to be more complicated - don't delete this quite yet.  
    dcpEnC = DebuggerController::IsXXXPatched((const BYTE *)pCtx->Eip,
                                              DEBUGGER_CONTROLLER_ENC);

    LOG((LF_CORDB, LL_INFO1000, "D::APSFEnC: dcpEnC:0x%x "
        "fShortCircuit:0x%x\n", dcpEnC, fShortCircuit));
                                                   
    if (dcpEnC == NULL)
    {            
        if (fShortCircuit)
        {
            const BYTE *pbCode = NULL;
            DebuggerPatchSkip *skip = NULL;
                skip = DebuggerController::ActivatePatchSkip(GetThread(), 
                    (const BYTE *)pCtx->Eip,
                    TRUE);

#ifdef _DEBUG
            if(skip != NULL)
            {
                pbCode = skip->GetBypassAddress();
                
                // The DebuggerPatchSkip ctor should be getting the same context
                // that we've been given - this will assert that
                _ASSERTE(pCtx->Eip == (DWORD)pbCode);
                
                LOG((LF_CORDB,LL_INFO1000, "D::APSFEnC: Eip is 0x%x\n", pCtx->Eip));
            }
#endif //_DEBUG
        }
    
        if(DebuggerController::IsSingleStepEnabled(GetThread()))
        {
            DebuggerEnCPatchToSkip *pEnCSkip = new (interopsafe) DebuggerEnCPatchToSkip((const BYTE *)pCtx->Eip,
                            NULL,
                            false,
                            TRACE_OTHER, 
                            dji,
                            GetThread());
        }    
    }
    else // we've got an internal patch that we want to hit
    {
        ;
    } 
    
#else // _X86_
    _ASSERTE( !"Debugger::ActivatePatchSkipForEnc not impl for nonX86" );
#endif //_X86_

    // in the event of out-of-memory, we'll simply hit an 
    // extra breakpoint.  Oh well.
    return hr;
}


//
// This is the handler function that is put in place of a thread's top-most SEH handler function when it is hijacked by
// the Right Side during an unmanaged first chance exception.
//
typedef EXCEPTION_DISPOSITION (__cdecl *SEHHandler)(EXCEPTION_RECORD *pExceptionRecord,
                             EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                             CONTEXT *pContext,
                             void *DispatcherContext);
#define DOSPEW 0

#if DOSPEW
#define SPEW(s) s
#else
#define SPEW(s)
#endif

EXCEPTION_DISPOSITION __cdecl Debugger::FirstChanceHijackFilter(EXCEPTION_RECORD *pExceptionRecord,
                             EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                             CONTEXT *pContext,
                             void *DispatcherContext)
{
#if DOSPEW
    DWORD tid = GetCurrentThreadId();
#endif

    SPEW(fprintf(stderr, "0x%x D::FCHF: in first chance hijack filter.\n", tid));
    SPEW(fprintf(stderr, "0x%x D::FCHF: pExceptionRecord=0x%08x (%d), pEstabilsherFrame=0x%08x (%d), pContext=0x%08x (%d),"
                 "dispatcherContext=0x%08x\n", tid, pExceptionRecord, sizeof(EXCEPTION_RECORD),
                 pEstablisherFrame, sizeof(EXCEPTION_REGISTRATION_RECORD), pContext, sizeof(CONTEXT),
                 DispatcherContext));
    SPEW(fprintf(stderr, "0x%x D::FCHF: code=0x%08x, addr=0x%08x, Eip=0x%08x, Esp=0x%08x, EFlags=0x%08x\n",
                 tid, pExceptionRecord->ExceptionCode, pExceptionRecord->ExceptionAddress, pContext->Eip, pContext->Esp,
                 pContext->EFlags));

    // Get the current runtime thread. This is only an optimized TLS access.
    Thread *pEEThread = g_pEEInterface->GetThread();

    // Is that really a ptr to a Thread? If the low bit is set or it its NULL then we don't have an EE Thread. If we
    // have a EE Thread, then we know the original handler now. If not, we have to wait for the Right Side to fixup our
    // handler chain once we've notified it that the exception does not belong to the runtime. Note: if we don't have an
    // EE thread, then the exception never belongs to the Runtime.
    SEHHandler origHandler = NULL;
    bool hasEEThread = false;
        
    if ((pEEThread != NULL) && !(((UINT_PTR)pEEThread) & 0x01))
    {
        hasEEThread = true;
        
        // We've got a Thread ptr, so get the original handler out of the thread's debugger word.
        origHandler = (SEHHandler) g_pEEInterface->GetThreadDebuggerWord(pEEThread);

        SPEW(fprintf(stderr, "0x%x D::FCHF: orig/current handler = 0x%08x/0x%08x\n",
                     tid, origHandler, pEstablisherFrame->Handler));

        // Fixup the handler chain.
        pEstablisherFrame->Handler = origHandler;
    }
    
    // Does this exception belong to the Runtime? 
    bool belongsToRuntime = false;
    bool managedToUnmanagedHandoff = false;

#ifndef _ALPHA_
    // If we're on Win9x, adjust the IP in the context to point to the break instruction instead of after it. Note: we
    // have to fix this up on the way out of here.  @todo port
    if (DebuggerController::g_runningOnWin95 && (pExceptionRecord->ExceptionCode == STATUS_BREAKPOINT))
        pContext->Eip--;
#endif // !_ALPHA_
    
    // If we have an EE Thread then it could be ours.
    if (hasEEThread)
    {
        // @todo need to check the concurrent collector.

        // If its the CLR Exception code, then of course its ours.
        if ((pExceptionRecord->ExceptionCode == EXCEPTION_COMPLUS) ||
            (pExceptionRecord->ExceptionCode == EXCEPTION_MSVC) ||
            pEEThread->m_StateNC & Thread::TSNC_DebuggerIsManagedException)
        {
#ifdef CorDB_Short_Circuit_First_Chance_Ownership
            _ASSERTE(!"FCH Case #1 (interop debugging) should never happen with FCH short circuit enabled!");
#endif            
            belongsToRuntime = true;
            goto decided;
        }

        // Is it in managed code? If so, then its ours, no matter what type of exception it is.
        SPEW(fprintf(stderr, "0x%x D::FCHF: %s[%d]\n", tid, __FILE__, __LINE__));
            
        if (g_pEEInterface->IsManagedNativeCode((BYTE*) pExceptionRecord->ExceptionAddress))
        {
            belongsToRuntime = true;
            goto decided;
        }

        // If this is a breakpoint exception, then if its in our patch table its ours.
        if ((pExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) && (DebuggerController::g_patchTableValid == TRUE))
        {
            SPEW(fprintf(stderr, "0x%x D::FCHF: %s[%d]\n", tid, __FILE__, __LINE__));
            
            DebuggerPatchTable *pt = DebuggerController::GetPatchTable();
            _ASSERTE(pt != NULL);

            DebuggerControllerPatch *p = pt->GetPatch((BYTE*) pExceptionRecord->ExceptionAddress);

            if (p != NULL)
            {
                belongsToRuntime = true;

                // So, we've found a patch in the patch table. Does this patch represent a breakpoint that signals the
                // handoff for a managed->unmanaged step transition?  If so, then we need to take some special care
                // below...
                if (p->trace.type == TRACE_UNMANAGED)
                {
                    SPEW(fprintf(stderr, "0x%x D::FCHF: Handoff start!\n", tid));
                    
                    managedToUnmanagedHandoff = true;
                }

                goto decided;
            }
        }

        SPEW(fprintf(stderr, "0x%x D::FCHF: %s[%d]\n", tid, __FILE__, __LINE__));

        // @todo: really should be checking to see if the Thread's top Frame is something that would indicate that this
        // exception will still be caught by the Runtime and converted to something useful. This is needed to catch
        // faults out of FCalls and the like.
    }

decided:
    if (belongsToRuntime)
    {
        SPEW(fprintf(stderr, "0x%x D::FCHF: exception belongs to the Runtime (m->um handoff=%d)\n",
                     tid, managedToUnmanagedHandoff));

#ifndef _ALPHA_
        // If we adjusted the IP before, put it back now.
        // @todo port
        if (DebuggerController::g_runningOnWin95 && (pExceptionRecord->ExceptionCode == STATUS_BREAKPOINT))
            pContext->Eip++;
#endif // !_ALPHA_
            
        EXCEPTION_DISPOSITION ret;
        
        if (!managedToUnmanagedHandoff)
        {
            // Signal the Right Side that this exception belongs to us.
            SPEW(fprintf(stderr, "0x%x D::FCHF: %s[%d]\n", tid, __FILE__, __LINE__));
            
            ExceptionForRuntime();

            // Return whatever the original handler returns.
            SPEW(fprintf(stderr, "0x%x D::FCHF: %s[%d]\n", tid, __FILE__, __LINE__));
        
            ret = origHandler(pExceptionRecord, pEstablisherFrame, pContext, DispatcherContext);

            SPEW(fprintf(stderr, "0x%x D::FCHF: %s[%d] ret=%d\n", tid, __FILE__, __LINE__, ret));
        }
        else
        {
            // Placing pContext into the debugger word gives the Right Side access to the thread's context at the fault
            // point. This will be used by Get/SetThreadContext on the Right Side to present the proper illusion to the
            // debugger.
            _ASSERTE(hasEEThread);
            
            _ASSERTE(!ISREDIRECTEDTHREAD(pEEThread));
            g_pEEInterface->SetThreadDebuggerWord(pEEThread, (DWORD) pContext);
            g_pEEInterface->SetThreadFilterContext(pEEThread, pContext);
            
            // Signal the Right Side that this exception belongs to us and that its the start of a managed->unmangaed
            // handoff.
            SPEW(fprintf(stderr, "0x%x D::FCHF: %s[%d]\n", tid, __FILE__, __LINE__));

            ExceptionForRuntimeHandoffStart();
            
            // Shortcut right to our dispatch native exception logic, there may be no COMPlusFrameHandler in place!
            SPEW(fprintf(stderr, "0x%x D::FCHF: %s[%d]\n", tid, __FILE__, __LINE__));
        
            bool okay = g_pDebugger->FirstChanceNativeException(pExceptionRecord,
                                             pContext,
                                             pExceptionRecord->ExceptionCode,
                                             pEEThread);
            _ASSERTE(okay == true);
            ret = ExceptionContinueExecution;

            // Tell the Right Side that its over.
            SPEW(fprintf(stderr, "0x%x D::FCHF: %s[%d]\n", tid, __FILE__, __LINE__));
            
            ExceptionForRuntimeHandoffComplete();
            
            _ASSERTE(!ISREDIRECTEDTHREAD(pEEThread));
            g_pEEInterface->SetThreadDebuggerWord(pEEThread, NULL);
            g_pEEInterface->SetThreadFilterContext(pEEThread, NULL);
            
            SPEW(fprintf(stderr, "0x%x D::FCHF: %s[%d]\n", tid, __FILE__, __LINE__));
        }
        
        return ret;
    }
    else
    {
        SPEW(fprintf(stderr, "0x%x D::FCHF: exception does not belong to the Runtime, hasEEThread=%d, pContext=0x%08x\n",
                     tid, hasEEThread, pContext));

        // Wait here if there is no managed debugger even trying to attach to this process yet. We do this to handle a
        // special race condition when doing an interop attach. If the Right Side receives the loader BP event, then it
        // will hijack the event and we'll end up here. We need to delay telling the Right Side that the exception does
        // not belong to the Runtime until we've received the attach message from a different thread on the Right
        // Side. So we wait on m_debuggerAttachedEvent, which is set when a debugger starts to attach and remains high
        // for the life of the run.
        if (g_pDebugger->m_debuggerAttached == FALSE && g_pDebugger->m_debuggerAttachedEvent)
        {
            SPEW(fprintf(stderr, "0x%x D::FCHF: Waiting before notifing about NFR.\n", tid));

            // Note: we time out after 10 seconds here on purpose. There are a number of races that we're trying to work
            // around here at the end of RTM. I believe I've got them all worked out. This event is now set from the
            // Right Side after receiving the first SyncComplete flare. However, if I've missed another case, at least
            // we'll be able to break the deadlock and keep going. That way, people using V1 will at least be able to
            // make progress. Its always the case that when we deadlock waiting on this event that we in fact can
            // proceed, its just that we don't know it. This is pretty lame, but we're getting desperate here.
            DWORD ret = WaitForSingleObject(g_pDebugger->m_debuggerAttachedEvent, 10000);

            if (ret != WAIT_OBJECT_0)
            {
                SPEW(fprintf(stderr, "0x%x D::FCHF: wait failed: %d\n", tid, ret));
            }
        
            SPEW(fprintf(stderr, "0x%x D::FCHF: Done waiting before notifing about NFR.\n", tid));
        }
        
        // When you hit an int 3 and you get a Win32 DEBUG_EVENT for the exception, Eip points _past_ the int 3, not at
        // it. This is clearly different from every other exception, but it is the case, so we have to mimic this
        // strange behavior. We'll bump Eip up here so the context looks right while we've got the thread stopped.
        //
        // Note: we never put Eip back. One of two things will happen: 1) the debugger will simply continue from the
        // exception, telling us to ignore it. In that case, we're supposed to continue after the int 3 anyway, so Eip
        // will be correct now. Or, case 2) the debugger will alter Eip in the thread's context and continue, in which
        // case we don't want to screw with Eip anyway.
        if (pExceptionRecord->ExceptionCode == STATUS_BREAKPOINT)
            pContext->Eip++;

        SPEW(fprintf(stderr, "0x%x D::FCHF: addr=0x%08x, Eip=0x%08x, Esp=0x%08x, EFlags=0x%08x\n",
                     tid, pExceptionRecord->ExceptionAddress, pContext->Eip, pContext->Esp, pContext->EFlags));
        
        // Placing pContext into the debugger word gives the Right Side access to the thread's context at the fault
        // point. This will be used by Get/SetThreadContext on the Right Side to present the proper illusion to the
        // debugger.
        DebuggerIPCFirstChanceData fcd;
        
        if (hasEEThread)
        {
            _ASSERTE(!ISREDIRECTEDTHREAD(pEEThread));
            g_pEEInterface->SetThreadDebuggerWord(pEEThread, (DWORD) pContext);
            g_pEEInterface->SetThreadFilterContext(pEEThread, pContext);
        }
        else
        {
            // At this point, if we didn't have an EE Thread for this thread, then we need to let the Right Side know a
            // good place to write the address of the original handler. We also need to pass over the pointer to the
            // context on this side. Tell the Right Side both by passing over the address of the fcd above and filling
            // it in appropiatley. The Right Side will fill in the original handler when it gets the
            // ExceptionNotForRuntime flare below.
            fcd.pLeftSideContext = pContext;

            _ASSERTE(origHandler == NULL);
            fcd.pOriginalHandler = &origHandler;
            
            // Place the address of the FCD into the debugger word for the Right Side to read.
            SPEW(fprintf(stderr, "0x%x: D::FCHF: &fcd=0x%08x, fcd.pLeftSideContext=0x%08x, fcd.pOriginalHandler=0x%08x\n",
                         tid, &fcd, fcd.pLeftSideContext, fcd.pOriginalHandler));
            
            g_pEEInterface->SetEEThreadPtr((VOID*)(((size_t)&fcd) | 0x01));
        }
        
        // Signal the Right Side that this exception does not belong to us, and also that our context ptr is in the
        // debugger word.
        ExceptionNotForRuntime();

        if (!hasEEThread)
        {
            // Finally, if we had no ee thread, fixup or SEH chain!
            SPEW(fprintf(stderr, "0x%x D::FCHF: orig/current handler (no EE Thread) = 0x%08x/0x%08x\n",
                         tid, origHandler, pEstablisherFrame->Handler));

            _ASSERTE(origHandler != NULL);
            pEstablisherFrame->Handler = origHandler;
        }
        
        // If this thread has an EE thread and that EE thread has preemptive gc disabled, then mark that there is a
        // thread at an unsafe place and enable pgc. This will allow us to sync even with this thread hijacked.
        bool disabled = false;

        if (hasEEThread)
        {
            // Threads can't be interrupted by breakpoints or exceptions when were interop debugging during the next
            // section of code. SetDebugCantStop helps us remember that.
            pEEThread->SetDebugCantStop(true);
            
            disabled = g_pEEInterface->IsPreemptiveGCDisabled();

            if (disabled)
            {
                SPEW(fprintf(stderr, "0x%x D::FCHF: enable pgc.\n", tid));
                
                // If PGC is disabled, then that means we're stopping in unmanaged code that is in the Runtime. (PGC is
                // enabled whenever we leave the Runtime.) We need to remember this so we can do our best to fixup the
                // managed stack trace to include an unmanaged transition chain.
                pEEThread->SetThreadStateNC(Thread::TSNC_DebuggerStoppedInRuntime);
                
                g_pDebugger->IncThreadsAtUnsafePlaces();
                g_pEEInterface->EnablePreemptiveGC();
            }
        }
        
        // Wait for the continue.
        SPEW(fprintf(stderr, "0x%x D::FCHF: waiting for continue.\n", tid));

        DWORD ret = WaitForSingleObject(g_pDebugger->m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_leftSideUnmanagedWaitEvent,
                                        INFINITE);

        if (ret != WAIT_OBJECT_0)
        {
            SPEW(fprintf(stderr, "0x%x D::FCHF: wait failed!\n", tid));
        }
        
        // Get the continue type. Non-zero means that the exception was not cleared by the Right Side and therefore has
        // not been handled. Zero means that the exception has been cleared. (Presumably, the debugger altered the
        // thread's context before clearing the exception, so continuing will give a different result.)
        DWORD continueType;

        if (hasEEThread)
        {
            // Threads can't be interrupted by breakpoints or exceptions when were interop debugging during the previous
            // section of code. SetDebugCantStop helped us remember that.
            pEEThread->SetDebugCantStop(false);
            
            continueType = g_pEEInterface->GetThreadDebuggerWord(pEEThread);
            _ASSERTE(!ISREDIRECTEDTHREAD(pEEThread));
            g_pEEInterface->SetThreadFilterContext(pEEThread, NULL);
        }
        else
        {
            continueType = (DWORD) g_pEEInterface->GetThread();

            // If we got a continue flag out of the EE's Thread TLS slot, then we know that there really isn't an EE
            // Thread for this thread, so we need to set it back to NULL.
            if (continueType)
                g_pEEInterface->SetEEThreadPtr(NULL);
        }

        SPEW(fprintf(stderr, "0x%x D::FCHF: continued with %d (0x%08x).\n", tid, continueType, continueType));

        if (hasEEThread && disabled)
        {
            SPEW(fprintf(stderr, "0x%x D::FCHF: disable pgc.\n", tid));
                
            g_pEEInterface->DisablePreemptiveGC();
            g_pDebugger->DecThreadsAtUnsafePlaces();

            // Undo the marking we made above when we realized we'd stopped in unmanaged Runtime impl.
            pEEThread->ResetThreadStateNC(Thread::TSNC_DebuggerStoppedInRuntime);
        }
        
        if (continueType)
        {
            SPEW(fprintf(stderr, "0x%x D::FCHF: calling orig hanlder\n", tid));
            SPEW(fprintf(stderr, "0x%x D::FCHF: addr=0x%08x, Eip=0x%08x, Esp=0x%08x, EFlags=0x%08x\n",
                         tid, pExceptionRecord->ExceptionAddress, pContext->Eip, pContext->Esp, pContext->EFlags));
        
            EXCEPTION_DISPOSITION d = origHandler(pExceptionRecord, pEstablisherFrame, pContext, DispatcherContext);

            SPEW(fprintf(stderr, "0x%x D::FCHF: orig handler returned %d\n", tid, d));
            return d;
        }
        else
        {
            SPEW(fprintf(stderr, "0x%x D::FCHF: returning continue (%d)\n", tid, ExceptionContinueExecution));
            SPEW(fprintf(stderr, "0x%x D::FCHF: addr=0x%08x, Eip=0x%08x, Esp=0x%08x, EFlags=0x%08x\n",
                         tid, pExceptionRecord->ExceptionAddress, pContext->Eip, pContext->Esp, pContext->EFlags));
            return ExceptionContinueExecution;
        }
    }

    _ASSERTE(!"Should never get here!");
}

//
// This is the function that a thread is hijacked to by the Right Side during a variety of debug events. This function
// must be naked.
//
#ifndef _ALPHA_ // Alpha Doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
void Debugger::GenericHijackFunc(void)
{
#ifdef _X86_
    _asm
    {
        push ebp
        mov  ebp,esp
        sub  esp,__LOCAL_SIZE
    }
#endif // _X86_
    
    {
#if DOSPEW
        DWORD tid = GetCurrentThreadId();
#endif
        
        SPEW(fprintf(stderr, "0x%x D::GHF: in generic hijack.\n", tid));

        // There is no need to setup any context pointer or interact with the Right Side in anyway. We simply wait for
        // the continue event to be set.
        SPEW(fprintf(stderr, "0x%x D::GHF: waiting for continue.\n", tid));

        // If this thread has an EE thread and that EE thread has preemptive gc disabled, then mark that there is a
        // thread at an unsafe place and enable pgc. This will allow us to sync even with this thread hijacked.
        bool disabled = false;

        Thread *pEEThread = g_pEEInterface->GetThread();

        if (pEEThread != NULL)
        {
            pEEThread->SetDebugCantStop(true);

            disabled = g_pEEInterface->IsPreemptiveGCDisabled();

            if (disabled)
            {
                SPEW(fprintf(stderr, "0x%x D::GHF: enable pgc.\n", tid));
                
                // If PGC is disabled, then that means we're stopping in unmanaged code that is in the Runtime. (PGC is
                // enabled whenever we leave the Runtime.) We need to remember this so we can do our best to fixup the
                // managed stack trace to include an unmanaged transition chain.
                pEEThread->SetThreadStateNC(Thread::TSNC_DebuggerStoppedInRuntime);
                
                g_pDebugger->IncThreadsAtUnsafePlaces();
                g_pEEInterface->EnablePreemptiveGC();
            }
        }
        
        DWORD ret = WaitForSingleObject(g_pDebugger->m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_leftSideUnmanagedWaitEvent,
                                        INFINITE);

        if (ret != WAIT_OBJECT_0)
        {
            SPEW(fprintf(stderr, "0x%x D::GHF: wait failed!\n", tid));
        }

        // Get the continue type. Non-zero means that the exception was not cleared by the Right Side and therefore has
        // not been handled. Zero means that the exception has been cleared. (Presumably, the debugger altered the
        // thread's context before clearing the exception, so continuing will give a different result.)
        DWORD continueType = 0;
        
        pEEThread = g_pEEInterface->GetThread();

        if (((UINT_PTR)pEEThread) & 0x01)
        {
            // There is no EE Thread for this thread, so we null out the TLS word so we don't confuse the Runtime.
            continueType = 1;
            g_pEEInterface->SetEEThreadPtr(NULL);
            pEEThread = NULL;
        }
        else if (pEEThread)
        {
            // We've got a Thread ptr, so get the continue type out of the thread's debugger word.
            continueType = g_pEEInterface->GetThreadDebuggerWord(pEEThread);
        }

        SPEW(fprintf(stderr, "0x%x D::GHF: continued with %d.\n", tid, continueType));

        if (continueType)
        {
            SPEW(fprintf(stderr, "0x%x D::GHF: calling ExitProcess\n", tid));

            // Continuing from a second chance exception without clearing the exception causes the process to
            // exit. Note: the continue type will only be non-zero if this hijack was setup for a second chance
            // exception. If the hijack was setup for another type of debug event, then we'll never get here.
            TerminateProcess(GetCurrentProcess(), 0);
        }

        if (pEEThread)
        {
            pEEThread->SetDebugCantStop(false);

            if (disabled)
            {
                SPEW(fprintf(stderr, "0x%x D::GHF: disable pgc.\n", tid));
                
                g_pEEInterface->DisablePreemptiveGC();
                g_pDebugger->DecThreadsAtUnsafePlaces();

                // Undo the marking we made above when we realized we'd stopped in unmanaged Runtime impl.
                pEEThread->ResetThreadStateNC(Thread::TSNC_DebuggerStoppedInRuntime);
            }
        }
        
        SPEW(fprintf(stderr, "0x%x D::GHF: signaling continue...\n", tid));
    }

#ifdef _X86_
    _asm
    {
        mov esp,ebp
        pop ebp
    }
#endif // _X86_
    
    // This signals the Right Side that this thread is ready to have its context restored.
    ExceptionNotForRuntime();

    _ASSERTE(!"Should never get here (Debugger::GenericHijackFunc)");
}

//
// This is the function that a thread is hijacked to by the Right Side during a second chance exception that we know
// belongs to the Runtime. This function must be naked.
//
#ifndef _ALPHA_ // Alpha Doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
void Debugger::SecondChanceHijackFunc(void)
{
#ifdef _X86_
    _asm
    {
        push ebp
        mov  ebp,esp
        sub  esp,__LOCAL_SIZE
    }
#endif // _X86_
    
    {
#if DOSPEW
        DWORD tid = GetCurrentThreadId();
#endif
        
        SPEW(fprintf(stderr, "0x%x D::SCHF: in second chance hijack.\n", tid));

        // Snag the Runtime thread.
        Thread *pEEThread = g_pEEInterface->GetThread();

        // We better have a Runtime thread!
        _ASSERTE(!((UINT_PTR)pEEThread & 0x01) && (pEEThread != NULL));

        // Here is some space for the data we need from the Right Side.
        DebuggerIPCSecondChanceData scd;

        // Place the addre of the SCD into the debugger word for the
        // Right Side to read.
        g_pEEInterface->SetThreadDebuggerWord(pEEThread, (DWORD) &scd);

        SPEW(fprintf(stderr, "0x%x D::SCHF: debugger word = 0x%08x\n", tid, &scd));
        
        // Stop here and let the Right Side fill in the SCD.
        NotifySecondChanceReadyForData();

        // Send the managed exception event over to the Right Side.
        SPEW(fprintf(stderr, "0x%x D::SCHF: sending managed exception event.\n", tid));
        
        // Set the filter context, because this is only ever called from a filter and we're about to send out a
        // last-chance exception event. Otherwise, the stack trace won't be right.
        _ASSERTE(!ISREDIRECTEDTHREAD(pEEThread));
        g_pEEInterface->SetThreadFilterContext(pEEThread, &scd.threadContext);
        
        g_pDebugger->SendException(pEEThread, false, false, FALSE);

        g_pEEInterface->SetThreadFilterContext(pEEThread, NULL);
        
        SPEW(fprintf(stderr, "0x%x D::SCHF: calling TerminateProcess\n", tid));

        // Continuing from a second chance managed exception causes the process to exit.
        TerminateProcess(GetCurrentProcess(), 0);
    }

#ifdef _X86_
    _asm
    {
        mov esp,ebp
        pop ebp
    }
#endif // _X86_
    
    _ASSERTE(!"Should never get here (Debugger::SecondChanceHijackFunc)");
}

//
// This is the function that is called when we determine that a first chance exception really belongs to the
// Runtime. This notifies the Right Side of this and the Right Side fixes up the thread's execution state from there.
//
#ifndef _ALPHA_ // Alpha doesn't understand naked
__declspec(naked)
#endif // !_ALPHA_
void Debugger::ExceptionForRuntime(void)
{
#ifdef _X86_
    __asm int 3;
    __asm ret;
#else // _X86_
    DebugBreak();
#endif // _X86_
}

//
// This is the function that is called when we determine that a first chance exception really belongs to the Runtime,
// and that that exception is due to a managed->unmanaged transition. This notifies the Right Side of this and the Right
// Side fixes up the thread's execution state from there, making sure to remember that it needs to continue to hide the
// hijack state of the thread.
//
#ifndef _ALPHA_ // Alpha Doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
void Debugger::ExceptionForRuntimeHandoffStart(void)
{
#ifdef _X86_
    __asm int 3;
    __asm ret;
#else // _X86_
    DebugBreak();
#endif // _X86_
}

//
// This is the function that is called when the original handler returns after we've determined that an exception was
// due to a managed->unmanaged transition. This notifies the Right Side of this and the Right Side fixes up the thread's
// execution state from there, making sure to turn off its flag indicating that the thread's hijack state should still
// be hidden.
//
#ifndef _ALPHA_ // Alpha Doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
void Debugger::ExceptionForRuntimeHandoffComplete(void)
{
#ifdef _X86_
    __asm int 3;
    __asm ret;
#else // _X86_
    DebugBreak();
#endif // _X86_
}

//
// This is the function that is called when we determine that a first chance exception does not belong to the
// Runtime. This notifies the Right Side of this and the Right Side fixes up the thread's execution state from there.
//
#ifndef _ALPHA_ // Alpha Doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
void Debugger::ExceptionNotForRuntime(void)
{
#ifdef _X86_
    __asm int 3;
    __asm ret;
#else // _X86_
    DebugBreak();
#endif // _X86_
}

//
// This is the function that is called when we want to send a sync complete event to the Right Side when it is the Win32
// debugger of this process. This notifies the Right Side of this and the Right Side fixes up the thread's execution
// state from there.
//
#ifndef _ALPHA_ // Alpha Doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
void Debugger::NotifyRightSideOfSyncComplete(void)
{
#ifdef _X86_
    __asm int 3;
    __asm ret;
#else // _X86_
    DebugBreak();
#endif // _X86_
}

//
// This is the function that is called when we want to tell the Right Side that the second chance exception hijack is
// ready to receive its data.
//
#ifndef _ALPHA_ // Alpha Doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
void Debugger::NotifySecondChanceReadyForData(void)
{
#ifdef _X86_
    __asm int 3;
    __asm ret;
#else // _X86_
    DebugBreak();
#endif // _X86_
}

/******************************************************************************
 *
 ******************************************************************************/
bool Debugger::GetILOffsetFromNative (MethodDesc *pFunc, const BYTE *pbAddr,
                                      DWORD nativeOffset, DWORD *ilOffset)
{
    DebuggerJitInfo *jitInfo = 
            g_pDebugger->GetJitInfo(pFunc,
                                    (const BYTE*)pbAddr);

    if (jitInfo != NULL)
    {
        CorDebugMappingResult map;    
        DWORD whichIDontCare;

        *ilOffset = jitInfo->MapNativeOffsetToIL(
                                        nativeOffset,
                                        &map,
                                        &whichIDontCare);

        return true;
    }

    return false;
}

/******************************************************************************
 *
 ******************************************************************************/
DWORD Debugger::GetHelperThreadID(void )
{
    return m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)
        ->m_temporaryHelperThreadId;
}

// @mfunc HRESULT|Debugger|DeleteHeadOfList|Removes the
//  current head of the list, and repl
//
HRESULT Debugger::DeleteHeadOfList( MethodDesc *pFD )
{
  LOG((LF_CORDB,LL_INFO10000,"D:DHOL for %s::%s\n",
            pFD->m_pszDebugClassName,
            pFD->m_pszDebugMethodName));

  LockJITInfoMutex();

  if (m_pJitInfos != NULL && pFD != NULL)
    m_pJitInfos->RemoveJitInfo( pFD);
  
  UnlockJITInfoMutex();
  
  LOG((LF_CORDB,LL_INFO10000,"D:DHOL: Finished removing head of the list"));

  return S_OK;
}

// @mfunc HRESULT|Debugger|InsertAtHeadOfList|Make sure
//  that there's only one head of the the list of DebuggerJitInfos
//  for the (implicitly) given MethodDesc.
HRESULT 
Debugger::InsertAtHeadOfList( DebuggerJitInfo *dji )
{
    LOG((LF_CORDB,LL_INFO10000,"D:IAHOL: dji:0x%08x\n", dji));

    HRESULT hr = S_OK;

    _ASSERTE(dji != NULL);

    LockJITInfoMutex();

//    CHECK_DJI_TABLE_DEBUGGER;

    hr = CheckInitJitInfoTable();

    if (FAILED(hr))
        return (hr);

    DebuggerJitInfo *djiPrev = m_pJitInfos->GetJitInfo(dji->m_fd);
    LOG((LF_CORDB,LL_INFO10000,"D:IAHOL: current head of dji list:0x%08x\n",djiPrev));
    _ASSERTE(djiPrev == NULL || dji->m_fd == djiPrev->m_fd);
        
    dji->m_nVersion = GetVersionNumber(dji->m_fd);

    if (djiPrev != NULL)
    {
        dji->m_prevJitInfo = djiPrev;
        djiPrev->m_nextJitInfo = dji;
        
        _ASSERTE(dji->m_fd != NULL);
        hr = m_pJitInfos->OverwriteJitInfo(dji->m_fd->GetModule(), 
                                         dji->m_fd->GetMemberDef(), 
                                         dji, 
                                         FALSE);

        LOG((LF_CORDB,LL_INFO10000,"D:IAHOL: DJI version 0x%04x for %s\n", 
            dji->m_nVersion,dji->m_fd->m_pszDebugMethodName));
    }
    else
    {
        hr = m_pJitInfos->AddJitInfo(dji->m_fd, dji, dji->m_nVersion);
    }
#ifdef _DEBUG
    djiPrev = m_pJitInfos->GetJitInfo(dji->m_fd);
    LOG((LF_CORDB,LL_INFO10000,"D:IAHOL: new head of dji list:0x%08x\n",
        djiPrev));
#endif //_DEBUG        
    UnlockJITInfoMutex();

    return hr;
}


// This method sends a log message over to the right side for the debugger to log it.
void Debugger::SendLogMessage(int iLevel, WCHAR *pCategory, int iCategoryLen,
                              WCHAR *pMessage, int iMessageLen)
{
    DebuggerIPCEvent* ipce;
    int iBytesToCopy;
    bool disabled;
    HRESULT hr = S_OK;

    LOG((LF_CORDB, LL_INFO10000, "D::SLM: Sending log message.\n"));

    // Send the message only if the debugger is attached to this appdomain.
    // Note the the debugger may detach at any time, so we'll have to check
    // this again after we get the lock.
    AppDomain *pAppDomain = g_pEEInterface->GetThread()->GetDomain();
    
    if (!pAppDomain->IsDebuggerAttached())
        return;

    disabled = g_pEEInterface->IsPreemptiveGCDisabled();

    if (disabled)
        g_pEEInterface->EnablePreemptiveGC();

    // EnsureDebuggerAttached is going to trigger a bunch of messages going back
    // and forth. If we lock before it, we'll block those messages.
    // If we lock after it, it's _possible_ that the debugger may detach 
    // before we get to the lock.
    
    // If panic message & no debugger is attached, then launch one to attach to us.
    if (iLevel == PanicLevel)
        hr = EnsureDebuggerAttached(g_pEEInterface->GetThread()->GetDomain(),
                                    L"Log message");

    BOOL threadStoreLockOwner = FALSE;

    if (SUCCEEDED(hr))
    {
        // Prevent other Runtime threads from handling events.

        // NOTE: if EnsureDebuggerAttached returned S_FALSE, this means that
        // a debugger was already attached and LockForEventSending should
        // behave as normal.  If there was no debugger attached, then we have
        // a special case where this event is a part of debugger attaching and
        // we've previously sent a sync complete event which means that
        // LockForEventSending will retry until a continue is called - however,
        // with attaching logic the previous continue didn't enable event
        // handling and didn't continue the process - it's waiting for this
        // event to be sent, so we do so even if the process appears to be
        // stopped.

        LockForEventSending(hr == S_OK);

        // It's possible that the debugger dettached while we were waiting
        // for our lock. Check again and abort the event if it did.
        if (pAppDomain->IsDebuggerAttached())
        {
            ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);

            // Check if the whole message will fit in one SendBuffer or
            // if we need to send multiple send buffers.
            // (the category string should always fit in the first message.
            _ASSERTE ((iCategoryLen >= 0) && (((iCategoryLen * sizeof (WCHAR)) +
                        (int)(((char*)&ipce->FirstLogMessage.Dummy[0] - 
                        (char*)ipce + 
                        (char*)LOG_MSG_PADDING))) < CorDBIPC_BUFFER_SIZE));

            bool fFirstMsg = true;
            bool fMore = false;
            int iMsgIndex = 0;

            if ((int)((iCategoryLen+iMessageLen) * sizeof (WCHAR)) > 
                (CorDBIPC_BUFFER_SIZE - (int)((char*)&ipce->FirstLogMessage.Dummy[0] -
                                        (char*)ipce +
                                        (char*)LOG_MSG_PADDING)))
            {
                fMore = true;
            }
            do
            {

                if (fFirstMsg)
                {
                    fFirstMsg = false;

                    // Send a LogMessage event to the Right Side
                    InitIPCEvent(ipce, 
                                 DB_IPCE_FIRST_LOG_MESSAGE, 
                                 g_pEEInterface->GetThread()->GetThreadId(),
                                 g_pEEInterface->GetThread()->GetDomain());

                    ipce->FirstLogMessage.fMoreToFollow = fMore;
                    ipce->FirstLogMessage.iLevel = iLevel;
                    ipce->FirstLogMessage.iCategoryLength = iCategoryLen;
                    ipce->FirstLogMessage.iMessageLength = iMessageLen;

                    wcsncpy (&ipce->FirstLogMessage.Dummy[0], pCategory, iCategoryLen);
                    ipce->FirstLogMessage.Dummy [iCategoryLen] = L'\0';

                    // We have already calculated whether or not the message string
                    // will fit in this buffer.
                    if (fMore)
                    {
                        iBytesToCopy = (CorDBIPC_BUFFER_SIZE - (
                                        (int)((char*)&ipce->FirstLogMessage.Dummy[0] - 
                                        (char*)ipce + 
                                        (char*)LOG_MSG_PADDING) 
                                        + (iCategoryLen * sizeof (WCHAR)))) / sizeof (WCHAR);

                        wcsncpy (&ipce->FirstLogMessage.Dummy [iCategoryLen+1], 
                                        pMessage, iBytesToCopy);

                        iMessageLen -= iBytesToCopy;

                        iMsgIndex += iBytesToCopy;
                    }
                    else
                    {
                        wcsncpy (&ipce->FirstLogMessage.Dummy [iCategoryLen+1],
                                        pMessage, iMessageLen);
                    }
                }
                else
                {
                    _ASSERTE (iMessageLen > 0);

                    iBytesToCopy = (CorDBIPC_BUFFER_SIZE - 
                                    (int)((char*)&ipce->ContinuedLogMessage.Dummy[0] - 
                                    (char*)ipce)) / sizeof (WCHAR);

                    if (iBytesToCopy >= iMessageLen)
                    {
                        iBytesToCopy = iMessageLen;
                        fMore = false;
                    }
                    else
                        iMessageLen -= iBytesToCopy;

                    ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
                    InitIPCEvent(ipce, 
                                 DB_IPCE_CONTINUED_LOG_MESSAGE, 
                                 g_pEEInterface->GetThread()->GetThreadId(),
                                 g_pEEInterface->GetThread()->GetDomain());

                    ipce->ContinuedLogMessage.fMoreToFollow = fMore;
                    ipce->ContinuedLogMessage.iMessageLength = iBytesToCopy;

                    wcsncpy (&ipce->ContinuedLogMessage.Dummy[0], &pMessage [iMsgIndex],
                                                iBytesToCopy);
                    iMsgIndex += iBytesToCopy;
                }

                m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);


            } while (fMore == true);

            if (iLevel == PanicLevel)
            {
                // Send a user breakpoint event to the Right Side
                DebuggerIPCEvent* ipce = m_pRCThread
                    ->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
                InitIPCEvent(ipce, 
                             DB_IPCE_USER_BREAKPOINT, 
                             g_pEEInterface->GetThread()->GetThreadId(),
                             g_pEEInterface->GetThread()->GetDomain());

                LOG((LF_CORDB, LL_INFO10000,
                     "D::SLM: sending user breakpoint event.\n"));
                m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);
            }   

            threadStoreLockOwner = TrapAllRuntimeThreads(pAppDomain);

            // If we're still syncing for attach, send sync complete now and
            // mark that the debugger has completed attaching.

            if (iLevel == PanicLevel)
                FinishEnsureDebuggerAttached();

        }
        else 
        {
            LOG((LF_CORDB,LL_INFO1000, "D::SLM: Skipping SendIPCEvent because RS detached."));
        }
        
        UnlockFromEventSending();
    }

    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
    g_pEEInterface->DisablePreemptiveGC();
    
    if (!disabled)
        g_pEEInterface->EnablePreemptiveGC();
}


// This function sends a message to the right side informing it about
// the creation/modification of a LogSwitch
void Debugger::SendLogSwitchSetting(int iLevel, int iReason, 
                                    WCHAR *pLogSwitchName, WCHAR *pParentSwitchName)
{
    LOG((LF_CORDB, LL_INFO1000, "D::SLSS: Sending log switch message switch=%S parent=%S.\n",
        pLogSwitchName, pParentSwitchName));

    // Send the message only if the debugger is attached to this appdomain.
    AppDomain *pAppDomain = g_pEEInterface->GetThread()->GetDomain();

    if (!pAppDomain->IsDebuggerAttached())
        return;

    bool disabled = g_pEEInterface->IsPreemptiveGCDisabled();

    if (disabled)
        g_pEEInterface->EnablePreemptiveGC();

    // Prevent other Runtime threads from handling events.
    BOOL threadStoreLockOwner = FALSE;
    
    LockForEventSending();
    
    if (pAppDomain->IsDebuggerAttached()) 
    {
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, 
                     DB_IPCE_LOGSWITCH_SET_MESSAGE, 
                     g_pEEInterface->GetThread()->GetThreadId(),
                     g_pEEInterface->GetThread()->GetDomain());

        ipce->LogSwitchSettingMessage.iLevel = iLevel;
        ipce->LogSwitchSettingMessage.iReason = iReason;

        wcscpy (&ipce->LogSwitchSettingMessage.Dummy [0], pLogSwitchName);

        if (pParentSwitchName == NULL)
            pParentSwitchName = L"";

        wcscpy (&ipce->LogSwitchSettingMessage.Dummy [wcslen(pLogSwitchName)+1],
                pParentSwitchName);

        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(pAppDomain);
    } 
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::SLSS: Skipping SendIPCEvent because RS detached."));
    }

    UnlockFromEventSending();

    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
    g_pEEInterface->DisablePreemptiveGC();

    if (!disabled)
        g_pEEInterface->EnablePreemptiveGC();
}

/******************************************************************************
 * Add the AppDomain to the list stored in the IPC block.
 ******************************************************************************/
HRESULT Debugger::AddAppDomainToIPC(AppDomain *pAppDomain)
{
    HRESULT hr = S_OK;
    LPCWSTR szName = NULL;

    LOG((LF_CORDB, LL_INFO100, "D::AADTIPC: Executing AADTIPC for AppDomain 0x%08x (0x%x).\n",
        pAppDomain,
        pAppDomain->GetId()));

    _ASSERTE(m_pAppDomainCB->m_iTotalSlots > 0);
    _ASSERTE(m_pAppDomainCB->m_rgListOfAppDomains != NULL);

    // Lock the list
    if (!m_pAppDomainCB->Lock())
        return E_FAIL;
    
    // Get a free entry from the list
    AppDomainInfo *pADInfo = m_pAppDomainCB->GetFreeEntry();

    // Function returns NULL if the list is full and a realloc failed.
    if (!pADInfo)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }

    // copy the ID
    pADInfo->m_id = pAppDomain->GetId();

    // Now set the AppDomainName. 
    szName = pAppDomain->GetFriendlyName();
    pADInfo->SetName(szName);

    // Save on to the appdomain pointer
    pADInfo->m_pAppDomain = pAppDomain;

    // bump the used slot count
    m_pAppDomainCB->m_iNumOfUsedSlots++;

ErrExit:
    // UnLock the list
    m_pAppDomainCB->Unlock();

    // Send event to debugger if one is attached.  Don't send the event if a debugger is already attached to
    // the domain, since the debugger could have attached to the process and domain in the time it takes
    // between creating the domain and when we notify the debugger.
    if (m_debuggerAttached && !pAppDomain->IsDebuggerAttached())
        SendCreateAppDomainEvent(pAppDomain, FALSE);
    
    return hr;
}

    
/******************************************************************************
 * Remove the AppDomain from the list stored in the IPC block.
 ******************************************************************************/
HRESULT Debugger::RemoveAppDomainFromIPC (AppDomain *pAppDomain)
{

    HRESULT hr = E_FAIL;

    LOG((LF_CORDB, LL_INFO100, "D::RADFIPC: Executing RADFIPC for AppDomain 0x%08x (0x%x).\n",
        pAppDomain,
        pAppDomain->GetId()));

    // if none of the slots are occupied, then simply return.
    if (m_pAppDomainCB->m_iNumOfUsedSlots == 0)
        return hr;

    // Lock the list
    if (!m_pAppDomainCB->Lock())
        return (E_FAIL);


    // Look for the entry
    AppDomainInfo *pADInfo = m_pAppDomainCB->FindEntry(pAppDomain);

    // Shouldn't be trying to remove an appdomain that was never added
    if (!pADInfo)
    {
        // We'd like to assert this, but there is a small window where we may have
        // called AppDomain::Init (and so it's fair game to call Stop, and hence come here),
        // but not yet published the app domain. 
        // _ASSERTE(!"D::RADFIPC: trying to remove an AppDomain that was never added");
        hr = (E_FAIL);
        goto ErrExit;
    }

    // Release the entry
    m_pAppDomainCB->FreeEntry(pADInfo);
    
ErrExit:
    // UnLock the list
    m_pAppDomainCB->Unlock();

    // send event to debugger if one is attached
    if (m_debuggerAttached)
        SendExitAppDomainEvent(pAppDomain);
    
    return hr;
}

/******************************************************************************
 * Update the AppDomain in the list stored in the IPC block.
 ******************************************************************************/
HRESULT Debugger::UpdateAppDomainEntryInIPC(AppDomain *pAppDomain)
{
    HRESULT hr = S_OK;
    LPCWSTR szName = NULL;

    LOG((LF_CORDB, LL_INFO100,
         "D::UADEIIPC: Executing UpdateAppDomainEntryInIPC ad:0x%x.\n", 
         pAppDomain));

    // if none of the slots are occupied, then simply return.
    if (m_pAppDomainCB->m_iNumOfUsedSlots == 0)
        return (E_FAIL);

    // Lock the list
    if (!m_pAppDomainCB->Lock())
        return (E_FAIL);

    // Look up the info entry
    AppDomainInfo *pADInfo = m_pAppDomainCB->FindEntry(pAppDomain);

    if (!pADInfo)
    {
        hr = E_FAIL;
        goto ErrExit;
    }

    // Update the name only if new name is non-null
    szName = pADInfo->m_pAppDomain->GetFriendlyName();
    pADInfo->SetName(szName);

    LOG((LF_CORDB, LL_INFO100,
         "D::UADEIIPC: New name:%ls (AD:0x%x)\n", pADInfo->m_szAppDomainName,
         pAppDomain));
         
ErrExit:
    // UnLock the list
    m_pAppDomainCB->Unlock();

    return hr;
}

/******************************************************************************
 * When attaching to a process, this is called to enumerate all of the
 * AppDomains currently in the process and communicate that information to the
 * debugger.
 ******************************************************************************/
HRESULT Debugger::IterateAppDomainsForAttach(
    AttachAppDomainEventsEnum EventsToSend, 
    BOOL *fEventSent, BOOL fAttaching)
{
    static const char *(ev[]) = {"all", "app domain create", "don't send class events", "only send class events"};
    LOG((LF_CORDB, LL_INFO100, "EEDII::IADFA: Entered function IterateAppDomainsForAttach() isAttaching:%d Events:%s\n", fAttaching, ev[EventsToSend]));
    HRESULT hr = S_OK;

    int flags;
    switch (EventsToSend)
    {
    case SEND_ALL_EVENTS:
        flags = ATTACH_ALL;
        break;
    case ONLY_SEND_APP_DOMAIN_CREATE_EVENTS:
        flags = 0;
        break;
    case DONT_SEND_CLASS_EVENTS:
        flags = ATTACH_ASSEMBLY_LOAD | ATTACH_MODULE_LOAD;
        break;
    case ONLY_SEND_CLASS_EVENTS:
        flags = ATTACH_CLASS_LOAD;
        break;
    default:
        _ASSERTE(!"unknown enum");
    }

    // Lock the list
    if (!m_pAppDomainCB->Lock())
        return (E_FAIL);

    // Iterate through the app domains
    AppDomainInfo *pADInfo = m_pAppDomainCB->FindFirst();

    while (pADInfo)
    {
        LOG((LF_CORDB, LL_INFO100, "EEDII::IADFA: Iterating over domain %#08x AD:%#08x %ls\n", pADInfo->m_pAppDomain->GetId(), pADInfo->m_pAppDomain, pADInfo->m_szAppDomainName));

        // Send CreateAppDomain events for each app domain
        if (EventsToSend == ONLY_SEND_APP_DOMAIN_CREATE_EVENTS)
        {
            LOG((LF_CORDB, LL_INFO100, "EEDII::IADFA: Sending AppDomain Create Event for 0x%08x\n",pADInfo->m_pAppDomain->GetId()));
            g_pDebugInterface->SendCreateAppDomainEvent(
                pADInfo->m_pAppDomain, fAttaching);

            *fEventSent = TRUE;
        }
        else
        {
            DWORD dwFlags = pADInfo->m_pAppDomain->GetDebuggerAttached();

            if ((dwFlags == AppDomain::DEBUGGER_ATTACHING) ||
                (dwFlags == AppDomain::DEBUGGER_ATTACHING_THREAD && 
                    EventsToSend == ONLY_SEND_CLASS_EVENTS))
            {
                LOG((LF_CORDB, LL_INFO100, "EEDII::IADFA: Mark as attaching thread for 0x%08x\n",pADInfo->m_pAppDomain->GetId()));

                // Send Load events for the assemblies, modules, and/or classes
                // We have to remember if any event needs it's 'synch complete'
                // msg to be sent later.
                *fEventSent = pADInfo->m_pAppDomain->
                    NotifyDebuggerAttach(flags, fAttaching) || *fEventSent;

                pADInfo->m_pAppDomain->SetDebuggerAttached(
                    AppDomain::DEBUGGER_ATTACHING_THREAD);

                hr = S_OK;
            }
            else
            {
                LOG((LF_CORDB, LL_INFO100, "EEDII::IADFA: Doing nothing for 0x%08x\n",pADInfo->m_pAppDomain->GetId()));
            }
        }

        // Get the next appdomain in the list
        pADInfo = m_pAppDomainCB->FindNext(pADInfo);
    }           

    // Unlock the list
    m_pAppDomainCB->Unlock();

    LOG((LF_CORDB, LL_INFO100, "EEDII::IADFA: Exiting function IterateAppDomainsForAttach\n"));
    
    return hr;
}

/******************************************************************************
 * Attach the debugger to a specific appdomain given its id.
 ******************************************************************************/
HRESULT Debugger::AttachDebuggerToAppDomain(ULONG id)
{
    LOG((LF_CORDB, LL_INFO1000, "EEDII:ADTAD: Entered function AttachDebuggerToAppDomain 0x%08x()\n", id));

    HRESULT hr = S_OK;

    // Lock the list
    if (!m_pAppDomainCB->Lock())
        return (E_FAIL);

    // Iterate through the app domains
    AppDomainInfo *pADInfo = m_pAppDomainCB->FindFirst();

    hr = E_FAIL;
    
    while (pADInfo)
    {
        if (pADInfo->m_pAppDomain->GetId() == id)
        {
            LOG((LF_CORDB, LL_INFO1000, "EEDII:ADTAD: Marked AppDomain 0x%08x as attaching\n", id));
            pADInfo->m_pAppDomain->SetDebuggerAttached(AppDomain::DEBUGGER_ATTACHING);
            
            hr = S_OK;  
            break;
        }

        // Get the next appdomain in the list
        pADInfo = m_pAppDomainCB->FindNext(pADInfo);
    }           

    // Unlock the list
    m_pAppDomainCB->Unlock();

    return hr;
}


/******************************************************************************
 * Mark any appdomains that we are in the process of attaching to as attached
 ******************************************************************************/
HRESULT Debugger::MarkAttachingAppDomainsAsAttachedToDebugger(void)
{
    LOG((LF_CORDB, LL_INFO1000, "EEDII:MAADAATD: Entered function MarkAttachingAppDomainsAsAttachedToDebugger\n"));

    HRESULT hr = S_OK;

    // Lock the list
    if (!m_pAppDomainCB->Lock())
        return (E_FAIL);

    // Iterate through the app domains
    AppDomainInfo *pADInfo = m_pAppDomainCB->FindFirst();

    hr = E_FAIL;
    
    while (pADInfo)
    {
        if (pADInfo->m_pAppDomain->GetDebuggerAttached() == AppDomain::DEBUGGER_ATTACHING_THREAD)
        {
            pADInfo->m_pAppDomain->SetDebuggerAttached(AppDomain::DEBUGGER_ATTACHED);

            LOG((LF_CORDB, LL_INFO10000, "EEDII:MAADAATD: AppDomain 0x%08x (0x%x) marked as attached\n",
                pADInfo->m_pAppDomain,
                pADInfo->m_pAppDomain->GetId()));            
        }

        // Get the next appdomain in the list
        pADInfo = m_pAppDomainCB->FindNext(pADInfo);
    }           

    // Unlock the list
    m_pAppDomainCB->Unlock();

    return hr;
}


/******************************************************************************
 * Detach the debugger from a specific appdomain given its id.
 ******************************************************************************/
HRESULT Debugger::DetachDebuggerFromAppDomain(ULONG id, AppDomain **ppAppDomain)
{
    HRESULT hr = S_OK;

    // Lock the list
    if (!m_pAppDomainCB->Lock())
        return (E_FAIL);

    // Iterate through the app domains
    AppDomainInfo *pADInfo = m_pAppDomainCB->FindFirst();

    while (pADInfo)
    {
        if (pADInfo->m_pAppDomain->GetId() == id)
        {
            pADInfo->m_pAppDomain->SetDebuggerAttached(AppDomain::DEBUGGER_NOT_ATTACHED);
            (*ppAppDomain) = pADInfo->m_pAppDomain;
            break;
        }

        // Get the next appdomain in the list
        pADInfo = m_pAppDomainCB->FindNext(pADInfo);
    }           

    // Unlock the list
    m_pAppDomainCB->Unlock();

    return hr;
}


/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::InitAppDomainIPC(void)
{
    HRESULT hr = S_OK;
    DWORD dwStrLen = 0;
    WCHAR szExeName[MAX_PATH];
    int i;
    NAME_EVENT_BUFFER;

    m_pAppDomainCB->m_iNumOfUsedSlots = 0;
    m_pAppDomainCB->m_iLastFreedSlot = 0;
    m_pAppDomainCB->m_iTotalSlots = 0;
    m_pAppDomainCB->m_szProcessName = NULL;
    m_pAppDomainCB->m_fLockInvalid = FALSE;

    // Create a mutex to allow the Left and Right Sides to properly
    // synchronize. The Right Side will spin until m_hMutex is valid,
    // then it will acquire it before accessing the data.
    m_pAppDomainCB->m_hMutex = WszCreateMutex(NULL, TRUE/*held*/, NAME_EVENT(L"pAppDomainCB->m_hMutex"));
    _ASSERTE(m_pAppDomainCB->m_hMutex != NULL);
    if (m_pAppDomainCB->m_hMutex == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    m_pAppDomainCB->m_iSizeInBytes = INITIAL_APP_DOMAIN_INFO_LIST_SIZE * 
                                                sizeof (AppDomainInfo);

    // Number of slots in AppDomainListElement array
    m_pAppDomainCB->m_rgListOfAppDomains =
        (AppDomainInfo *) malloc(m_pAppDomainCB->m_iSizeInBytes);

    if (m_pAppDomainCB->m_rgListOfAppDomains == NULL)
    {
        LOG((LF_CORDB, LL_INFO100,
             "D::IADIPC: Failed to allocate memory for  AppDomainInfo.\n"));

        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_pAppDomainCB->m_iTotalSlots = INITIAL_APP_DOMAIN_INFO_LIST_SIZE;

    // Initialize each AppDomainListElement
    for (i = 0; i < INITIAL_APP_DOMAIN_INFO_LIST_SIZE; i++)
    {
        m_pAppDomainCB->m_rgListOfAppDomains[i].FreeEntry();
    }

    // also initialize the process name
    dwStrLen = WszGetModuleFileName(WszGetModuleHandle(NULL),
                                    szExeName,
                                    MAX_PATH);

    // If we couldn't get the name, then use a nice default.
    if (dwStrLen == 0)
    {
        wcscpy(szExeName, L"<NoProcessName>");
        dwStrLen = wcslen(szExeName);
    }

    // If we got the name, copy it into a buffer. dwStrLen is the
    // count of characters in the name, not including the null
    // terminator.
    m_pAppDomainCB->m_szProcessName = new WCHAR[dwStrLen + 1];
        
    if (m_pAppDomainCB->m_szProcessName == NULL)
    {
        LOG((LF_CORDB, LL_INFO100,
             "D::IADIPC: Failed to allocate memory for ProcessName.\n"));

        hr = E_OUTOFMEMORY;

        goto exit;
    }

    wcscpy(m_pAppDomainCB->m_szProcessName, szExeName);

    // Add 1 to the string length so the Right Side will copy out the
    // null terminator, too.
    m_pAppDomainCB->m_iProcessNameLengthInBytes =
        (dwStrLen + 1) * sizeof(WCHAR);

exit:
    if (m_pAppDomainCB->m_hMutex != NULL)
        m_pAppDomainCB->Unlock();
    
    return hr;
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::TerminateAppDomainIPC(void)
{
    HRESULT hr = S_OK;

    // Lock the list
    if (!m_pAppDomainCB->Lock())
        return (E_FAIL);

    // The shared IPC segment could still be around after the debugger
    // object has been destroyed during process shutdown. So, reset
    // the UsedSlots count to 0 so that any out of process clients
    // enumeratingthe app domains in this process see 0 AppDomains.
    m_pAppDomainCB->m_iNumOfUsedSlots = 0;
    m_pAppDomainCB->m_iTotalSlots = 0;

    // Now delete the memory alloacted for AppDomainInfo  array
    free(m_pAppDomainCB->m_rgListOfAppDomains);
    m_pAppDomainCB->m_rgListOfAppDomains = NULL;

    delete [] m_pAppDomainCB->m_szProcessName;
    m_pAppDomainCB->m_szProcessName = NULL;
    m_pAppDomainCB->m_iProcessNameLengthInBytes = 0;

    // We're done. Set the mutex handle to NULL, release and close the
    // mutex. If the Right Side acquires the mutex, it will verify
    // that the handle is still not NULL. If it is, then it knows it
    // really lost.
    HANDLE m = m_pAppDomainCB->m_hMutex;
    m_pAppDomainCB->m_hMutex = NULL;

    VERIFY(ReleaseMutex(m));
    CloseHandle(m);

    return hr;
}



/* ------------------------------------------------------------------------ *
 * Func Eval stuff 
 * ------------------------------------------------------------------------ */

//
// Small method to setup a DebuggerFuncEvalComplete. We do this because we can't make a new object in
// FuncEvalHijackWorker due to odd C++ rules about SEH.
//
static void SetupDebuggerFuncEvalComplete(Thread *pThread, void *dest)
{
    DebuggerFuncEvalComplete *comp = new (interopsafe) DebuggerFuncEvalComplete(pThread, dest);
    _ASSERTE(comp != NULL);
}

//
// Given a register, return the value.
//
static DWORD GetRegisterValue(DebuggerEval *pDE, CorDebugRegister reg, void *regAddr)
{
    DWORD ret = 0;

#ifdef _X86_    
    // A non-NULL register address indicates the value of the register was pushed because we're not on the leaf frame,
    // so we use the address of the register given to us instead of the register value in the context.
    if (regAddr != NULL)
    {
        ret = *((DWORD*)regAddr);
    }
    else
    {
        switch (reg)
        {
        case REGISTER_X86_EAX:
            ret = pDE->m_context.Eax;
            break;
        
        case REGISTER_X86_ECX:
            ret = pDE->m_context.Ecx;
            break;
        
        case REGISTER_X86_EDX:
            ret = pDE->m_context.Edx;
            break;
        
        case REGISTER_X86_EBX:
            ret = pDE->m_context.Ebx;
            break;
        
        case REGISTER_X86_ESP:
            ret = pDE->m_context.Esp;
            break;
        
        case REGISTER_X86_EBP:
            ret = pDE->m_context.Ebp;
            break;
        
        case REGISTER_X86_ESI:
            ret = pDE->m_context.Esi;
            break;
        
        case REGISTER_X86_EDI:
            ret = pDE->m_context.Edi;
            break;
        
        default:
            _ASSERT(!"Invalid register number!");
        
        }
    }
#endif

    return ret;
}

//
// Given a register, set its value.
//
static void SetRegisterValue(DebuggerEval *pDE, CorDebugRegister reg, void *regAddr, DWORD newValue)
{
#ifdef _X86_    
    // A non-NULL register address indicates the value of the register was pushed because we're not on the leaf frame,
    // so we use the address of the register given to us instead of the register value in the context.
    if (regAddr != NULL)
    {
        *((DWORD*)regAddr) = newValue;
    }
    else
    {
        switch (reg)
        {
        case REGISTER_X86_EAX:
            pDE->m_context.Eax = newValue;
            break;
        
        case REGISTER_X86_ECX:
            pDE->m_context.Ecx = newValue;
            break;
        
        case REGISTER_X86_EDX:
            pDE->m_context.Edx = newValue;
            break;
        
        case REGISTER_X86_EBX:
            pDE->m_context.Ebx = newValue;
            break;
        
        case REGISTER_X86_ESP:
            pDE->m_context.Esp = newValue;
            break;
        
        case REGISTER_X86_EBP:
            pDE->m_context.Ebp = newValue;
            break;
        
        case REGISTER_X86_ESI:
            pDE->m_context.Esi = newValue;
            break;
        
        case REGISTER_X86_EDI:
            pDE->m_context.Edi = newValue;
            break;
        
        default:
            _ASSERT(!"Invalid register number!");
        
        }
    }
#endif
}

//
// Given info about an argument, place its value on the stack, even if
// enregistered. Homes enregistered byrefs into either the
// PrimitiveByRefArg or ObjectRefByRefArg arrays if necessary.
// argSigType is the type for this argument described in signature.
//
static void GetArgValue(DebuggerEval *pDE,
                        DebuggerIPCE_FuncEvalArgData *pFEAD,
                        bool isByRef,
                        bool fNeedBoxOrUnbox,
                        TypeHandle argTH,
                        CorElementType byrefArgSigType,
                        BYTE *pStack,
                        INT64 *pPrimitiveArg,
                        OBJECTREF *pObjectRefArg,
                        CorElementType argSigType)
{
    THROWSCOMPLUSEXCEPTION();

    switch (pFEAD->argType)
    {
    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
    case ELEMENT_TYPE_R8:
        // 64bit values
        if (pFEAD->argAddr != NULL)
        {
            if (!isByRef)
                *((INT64*)pStack) = *(INT64*)(pFEAD->argAddr);
            else
                *((INT32*)pStack) = (INT32)pFEAD->argAddr;
        }
        else if (pFEAD->argIsLiteral)
        {
            _ASSERTE(sizeof(pFEAD->argLiteralData) >= sizeof(INT64));

            // If this is a literal arg, then we just copy the data onto the stack.
            if (!isByRef)
            {
                memcpy(pStack, pFEAD->argLiteralData, sizeof(INT64));
            }
            else
            {
                // If this is a byref literal arg, then we copy the data into the primitive arg array as if this were an
                // enregistered value.
                *((INT32*)pStack) = (INT32)pPrimitiveArg;
                INT64 v = 0;
                memcpy(&v, pFEAD->argLiteralData, sizeof(v));
                *pPrimitiveArg = v;
            }
        }
        else
        {
            // RAK_REG is the only 4 byte type, all others are 8 byte types.
            _ASSERTE(pFEAD->argHome.kind != RAK_REG);

            INT64 bigVal = 0;
            DWORD *pHigh = (DWORD*)(&bigVal);
            DWORD *pLow  = pHigh + 1;

            switch (pFEAD->argHome.kind)
            {
            case RAK_REGREG:
                *pHigh = GetRegisterValue(pDE, pFEAD->argHome.reg2, pFEAD->argHome.reg2Addr);
                *pLow = GetRegisterValue(pDE, pFEAD->argHome.reg1, pFEAD->argHome.reg1Addr);
                break;
                
            case RAK_MEMREG:
                *pHigh = GetRegisterValue(pDE, pFEAD->argHome.reg1, pFEAD->argHome.reg1Addr);
                *pLow = *((DWORD*)pFEAD->argHome.addr);
                break;

            case RAK_REGMEM:
                *pHigh = *((DWORD*)pFEAD->argHome.addr);
                *pLow = GetRegisterValue(pDE, pFEAD->argHome.reg1, pFEAD->argHome.reg1Addr);
                break;
            }

            if (!isByRef)
                *((INT64*)pStack) = bigVal;
            else
            {
                *((INT32*)pStack) = (INT32)pPrimitiveArg;
                *pPrimitiveArg = bigVal;
            }
        }
        break;
        
    case ELEMENT_TYPE_VALUETYPE:
        {
            DWORD       v;
            LPVOID      pAddr = NULL;
            if (pFEAD->argAddr != NULL)
            {
                pAddr = pFEAD->argAddr;
            }
            else if (pFEAD->argHome.kind == RAK_REG)
            {
                // Simply grab the value out of the proper register.
                v = GetRegisterValue(pDE, pFEAD->argHome.reg1, pFEAD->argHome.reg1Addr);
                pAddr = &v;
            }
            else
            {
                COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");
            }

            _ASSERTE(pAddr);

            // Grab the class of this value type.
            EEClass *pBase = argTH.GetClass();

            if (!isByRef && !fNeedBoxOrUnbox)
            {
                _ASSERTE(pBase);
                CopyValueClassUnchecked(pStack, pAddr, pBase->GetMethodTable());
            }
            else
            {
                if (fNeedBoxOrUnbox)
                {
                    // Grab the class of this value type.
                    DebuggerModule *pDebuggerModule = (DebuggerModule*) pFEAD->GetClassInfo.classDebuggerModuleToken;

                    EEClass *pClass = g_pEEInterface->FindLoadedClass(pDebuggerModule->m_pRuntimeModule,
                                                                      pFEAD->GetClassInfo.classMetadataToken);
                    MethodTable * pMT = pClass->GetMethodTable();
                    // We have to keep byref values in a seperate array that is GCPROTECT'd.
                    *pObjectRefArg = pMT->Box(pAddr, TRUE);
                    *((INT32*)pStack) = (INT32)ObjToInt64(*pObjectRefArg);
                }
                else
                {
                    if (pFEAD->argAddr)
                        *((INT32*)pStack) = (INT32)pAddr;
                    else
                    {
                        // The argument is the address of where we're holding the primitive in the PrimitiveArg array. We
                        // stick the real value from the register into the PrimitiveArg array.
                        *((INT32*)pStack) = (INT32)pPrimitiveArg;
                        *pPrimitiveArg = (INT64)v;
                    }
                }
            }
        }
        break;
    
    default:
        // 32bit values
        if (pFEAD->argAddr != NULL)
        {
            if (!isByRef)
                if (pFEAD->argRefsInHandles)
                {
                    OBJECTHANDLE oh = *((OBJECTHANDLE*)(pFEAD->argAddr));
                    *((INT32*)pStack) = (INT32)g_pEEInterface->GetObjectFromHandle(oh);
                }
                else
                    *((INT32*)pStack) = *(DWORD*)(pFEAD->argAddr); 
            else
                if (pFEAD->argRefsInHandles)
                {
                    *((INT32*)pStack) = *(DWORD*)(pFEAD->argAddr);
                }
                else
                {
                    // We have a 32bit parameter, but if we're passing it byref to a function that's expecting a 64bit
                    // param then we need to copy the 32bit param to the PrimitiveArray and pass the address of its
                    // location in the PrimitiveArray. If we don't do this, then we'll be bashing memory right next to
                    // the 32bit value as the function being called acts upon a 64bit value.
                    if ((byrefArgSigType == ELEMENT_TYPE_I8) ||
                        (byrefArgSigType == ELEMENT_TYPE_U8) ||
                        (byrefArgSigType == ELEMENT_TYPE_R8))
                    {
                        *((INT32*)pStack) = (INT32)pPrimitiveArg;
                        *pPrimitiveArg = (INT64)(*(INT32*)pFEAD->argAddr);
                    }
                    else
                        *((INT32*)pStack) = (INT32)pFEAD->argAddr;
                }
        }
        else if (pFEAD->argIsLiteral)
        {
            _ASSERTE(sizeof(pFEAD->argLiteralData) >= sizeof(INT32));

            if (!isByRef)
            {
                // If this is a literal arg, then we just copy the data onto the stack.
                memcpy(pStack, pFEAD->argLiteralData, sizeof(INT32));
            }
            else
            {
                // The argument passed is to be a ByRef E_T_CLASS, it cannot be passed as Literal and expected to be updated.
                // if (pFEAD->argType == ELEMENT_TYPE_CLASS)
                //     COMPlusThrow(kArgumentException);

                // If this is a byref literal arg, then we copy the data into the primitive arg array as if this were an
                // enregistered value.
                *((INT32*)pStack) = (INT32)pPrimitiveArg;
                INT32 v = 0;
                memcpy(&v, pFEAD->argLiteralData, sizeof(v));
                *pPrimitiveArg = (INT64)v;
            }
        }
        else
        {
            // RAK_REG is the only valid 4 byte type.
            _ASSERTE(pFEAD->argHome.kind == RAK_REG);

            // Simply grab the value out of the proper register.
            DWORD v = GetRegisterValue(pDE, pFEAD->argHome.reg1, pFEAD->argHome.reg1Addr);

            if (!isByRef)
                *((INT32*)pStack) = v;
            else
            {
                // Do we have a something that needs to be GC protected?
                if (pFEAD->argType == ELEMENT_TYPE_CLASS)
                {
                    // We have to keep byref values in a seperate array that is GCPROTECT'd.
                    *((INT32*)pStack) = (INT32)pObjectRefArg;
                    *pObjectRefArg = Int64ToObj((INT64)v);
                }
                else
                {
                    // The argument is the address of where we're holding the primitive in the PrimitiveArg array. We
                    // stick the real value from the register into the PrimitiveArg array.
                    *((INT32*)pStack) = (INT32)pPrimitiveArg;
                    *pPrimitiveArg = (INT64)v;
                }
            }
        }

        // If we need to unbox, then unbox the arg now.
        if (fNeedBoxOrUnbox)
        {
            if (!isByRef)
            {
                // Take the ObjectRef off the stack.
                INT64 oi1 = (INT64)*((INT32*)pStack);
                if (oi1 == 0)
                    COMPlusThrow(kArgumentException, L"ArgumentNull_Obj");
                OBJECTREF o1 = Int64ToObj(oi1);

                _ASSERTE(o1->GetClass()->IsValueClass());

                // Unbox the little fella to get a pointer to the raw data.
                void *pData = o1->UnBox();
            
                // Its not ByRef, so we need to copy the value class onto the stack.
                CopyValueClassUnchecked(pStack, pData, o1->GetMethodTable());
            }
            else
            {
                // Grab the ObjectRef off the stack via the pointer on the stack. Note: the stack has a pointer to the
                // ObjectRef since the arg was specified as byref.
                OBJECTREF* op1 = *((OBJECTREF**)pStack);
                if (op1 == NULL || (*op1) == NULL)
                    COMPlusThrow(kArgumentException, L"ArgumentNull_Obj");

                OBJECTREF o1 = *op1;
                _ASSERTE(o1->GetClass()->IsValueClass());

                // Unbox the little fella to get a pointer to the raw data.
                void *pData = o1->UnBox();
            
                // If it is ByRef, then we just replace the ObjectRef with a pointer to the data.
                *((void**)pStack) = pData;
            }
        }

        // Validate any objectrefs that are supposed to be on the stack.
        // @TODO: Move this to before the boxing/unboxing above
        if (!fNeedBoxOrUnbox)
        {
			Object *objPtr;
			if (!isByRef)
			{
                if ((argSigType == ELEMENT_TYPE_CLASS) ||
                    (argSigType == ELEMENT_TYPE_OBJECT) ||
                    (argSigType == ELEMENT_TYPE_STRING) ||
                    (argSigType == ELEMENT_TYPE_SZARRAY) || 
                    (argSigType == ELEMENT_TYPE_ARRAY)) 
                {
				    // validate the integrity of the object
				    objPtr = *((Object**)pStack);
                    if (FAILED(ValidateObject(objPtr)))
                        COMPlusThrow(kArgumentException, L"Argument_BadObjRef");
                }
			}
			else
			{
                _ASSERTE(argSigType == ELEMENT_TYPE_BYREF);
                if ((byrefArgSigType == ELEMENT_TYPE_CLASS) ||
                    (byrefArgSigType == ELEMENT_TYPE_OBJECT) ||
                    (byrefArgSigType == ELEMENT_TYPE_STRING) ||
                    (byrefArgSigType == ELEMENT_TYPE_SZARRAY) || 
                    (byrefArgSigType == ELEMENT_TYPE_ARRAY)) 
                {
				    objPtr = **((Object***)pStack);
                    if (FAILED(ValidateObject(objPtr)))
                        COMPlusThrow(kArgumentException, L"Argument_BadObjRef");
                }
			}
        }
    }
}

//
// Given info about a byref argument, retrieve the current value from
// either the PrimitiveByRefArg or the ObjectRefByRefArg arrays and
// place it back into the proper register.
//
static void SetByRefArgValue(DebuggerEval *pDE,
                             DebuggerIPCE_FuncEvalArgData *pFEAD,
                             CorElementType byrefArgSigType,
                             INT64 primitiveByRefArg,
                             OBJECTREF objectRefByRegArg)
{
    switch (pFEAD->argType)
    {
    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
    case ELEMENT_TYPE_R8:
        // 64bit values
        {
            if (pFEAD->argIsLiteral)
            {
                // If this was a literal arg, then copy the updated primitive back into the literal.
                memcpy(pFEAD->argLiteralData, &primitiveByRefArg, sizeof(pFEAD->argLiteralData));
            }
            else if (pFEAD->argAddr != NULL)
            {
                // Don't copy 64bit values back if the value wasn't enregistered...
                return;
            }
            else
            {
                // RAK_REG is the only 4 byte type, all others are 8 byte types.
                _ASSERTE(pFEAD->argHome.kind != RAK_REG);

                DWORD *pHigh = (DWORD*)(&primitiveByRefArg);
                DWORD *pLow  = pHigh + 1;

                switch (pFEAD->argHome.kind)
                {
                case RAK_REGREG:
                    SetRegisterValue(pDE, pFEAD->argHome.reg2, pFEAD->argHome.reg2Addr, *pHigh);
                    SetRegisterValue(pDE, pFEAD->argHome.reg1, pFEAD->argHome.reg1Addr, *pLow);
                    break;
                
                case RAK_MEMREG:
                    SetRegisterValue(pDE, pFEAD->argHome.reg1, pFEAD->argHome.reg1Addr, *pHigh);
                    *((DWORD*)pFEAD->argHome.addr) = *pLow;
                    break;

                case RAK_REGMEM:
                    *((DWORD*)pFEAD->argHome.addr) = *pHigh;
                    SetRegisterValue(pDE, pFEAD->argHome.reg1, pFEAD->argHome.reg1Addr, *pLow);
                    break;
                }
            }
        }
        break;
        
    default:
        // 32bit values
        {
            if (pFEAD->argIsLiteral)
            {
                // If this was a literal arg, then copy the updated primitive back into the literal.
                memcpy(pFEAD->argLiteralData, &primitiveByRefArg, sizeof(pFEAD->argLiteralData));
            }
            else if (pFEAD->argAddr == NULL)
            {
                // If the 32bit value is enregistered, copy it back to the proper regs.
                
                // RAK_REG is the only valid 4 byte type.
                _ASSERTE(pFEAD->argHome.kind == RAK_REG);

                // Shove the result back into the proper register.
                if (pFEAD->argType == ELEMENT_TYPE_CLASS)
                    SetRegisterValue(pDE, pFEAD->argHome.reg1, pFEAD->argHome.reg1Addr, (DWORD)ObjToInt64(objectRefByRegArg));
                else
                    SetRegisterValue(pDE, pFEAD->argHome.reg1, pFEAD->argHome.reg1Addr, (DWORD)primitiveByRefArg);
            }
            else
            {
                // If the value wasn't enregistered, then we still need to check to see if we need to put a 32bit value
                // back from where we may have moved it into the primitive array. (Right now we only do this when you
                // pass a 32bit value as a byref when a 64bit byref value was expected.
                if ((byrefArgSigType == ELEMENT_TYPE_I8) ||
                    (byrefArgSigType == ELEMENT_TYPE_U8) ||
                    (byrefArgSigType == ELEMENT_TYPE_R8))
                {
                    *(INT32*)pFEAD->argAddr = (INT32)primitiveByRefArg;
                }
            }
        }
    }
}

//
// Perform the bulk of the work of a function evaluation. Sets up
// arguments, palces the call, and process any changed byrefs and the
// return value, if any.
//
static void DoNormalFuncEval(DebuggerEval *pDE)
{
    THROWSCOMPLUSEXCEPTION();
    
#if 0
    //
    // This is just some code I use to help me debug. Leave it here under the #ifdef 0 so I can use it later.
    //
    // -- Sun Jan 14 14:30:51 2001
    //
    if (REGUTIL::GetConfigDWORD(L"func_eval1",0))
    {
        fprintf(stderr, "Func eval of %s::%s\n", pDE->m_md->m_pszDebugClassName, pDE->m_md->m_pszDebugMethodName);
        //WCHAR wzBuf[200];
        //_snwprintf(wzBuf, lengthof(wzBuf), L"Func eval of %hs::%hs\n", pDE->m_md->m_pszDebugClassName, pDE->m_md->m_pszDebugMethodName);
        //WszOutputDebugString(wzBuf);
    }
    if (REGUTIL::GetConfigDWORD(L"func_eval2",0))
    {
        LPWSTR specific = REGUTIL::GetConfigString(L"func_eval3");

        if (specific)
        {
            MAKE_UTF8PTR_FROMWIDE(specific8, specific);

            if (!strcmp(specific8, pDE->m_md->m_pszDebugMethodName))
            {
                _ASSERTE(!"Attach for func eval arg setup here.");
            }
            
            REGUTIL::FreeConfigString(specific);
        }
        else
        {
            _ASSERTE(!"Attach for func eval arg setup here.");
        }
    }
#endif

    // We'll need to know if this is a static method or not.
    BOOL staticMethod = pDE->m_md->IsStatic();

    // Grab the signature of the method we're working on.
    MetaSig mSig(pDE->m_md->GetSig(), pDE->m_md->GetModule());
    
    BYTE callingconvention = mSig.GetCallingConvention();
    if (!isCallConv(callingconvention, IMAGE_CEE_CS_CALLCONV_DEFAULT))
    {
        // We don't support calling vararg!
        COMPlusThrow(kArgumentException, L"Argument_CORDBBadVarArgCallConv");
    }

    // How much stack do we need?
    UINT stackSize = mSig.SizeOfVirtualFixedArgStack(staticMethod);

    _ASSERTE((pDE->m_evalType == DB_IPCE_FET_NORMAL) || !staticMethod);

    // If necessary, create a new object.
    OBJECTREF newObj = NULL;
    GCPROTECT_BEGIN(newObj);

    SIZE_T allocArgCnt = 0;
    
    if (pDE->m_evalType == DB_IPCE_FET_NEW_OBJECT)
    {
        newObj = AllocateObject(pDE->m_md->GetMethodTable());

        // Note: we account for an extra argument in the count passed
        // in. We use this to increase the space allocated for args,
        // and we use it to control the number of args copied into
        // those arrays below. Note: stackSize already includes space
        // for this.
        allocArgCnt = pDE->m_argCount + 1;
    }
    else
        allocArgCnt = pDE->m_argCount;
    
    // Validate the argument count with mSig.
    if (allocArgCnt != (mSig.NumFixedArgs() + (staticMethod ? 0 : 1)))
        COMPlusThrow(kTargetParameterCountException, L"Arg_ParmCnt");

    // Make some room for the stack.
    BYTE *pStack = (BYTE*)_alloca(stackSize);

    LOG((LF_CORDB, LL_INFO100000,
         "Func eval for %s::%s: stackSize=%d, pStack=0x%08x\n",
         pDE->m_md->m_pszDebugClassName,
         pDE->m_md->m_pszDebugMethodName,
         stackSize,
         pStack));

    // An array to hold primitive args for the byref case. If there is
    // an enregistered primitive, we'll copy it to this array and
    // place a ptr to it onto the stack.
    INT64 *pPrimitiveArgs = (INT64*)_alloca(sizeof(INT64) * allocArgCnt);

    // An array to hold object ref args. This is both for the byref
    // case, just like for the pPrimitiveArgs, and as a holding area
    // while we're building the stack. This array is protected from
    // GC's.
    OBJECTREF *pObjectRefArgs = 
        (OBJECTREF*)_alloca(sizeof(OBJECTREF) * allocArgCnt);
    memset(pObjectRefArgs, 0, sizeof(OBJECTREF) * allocArgCnt);
    GCPROTECT_ARRAY_BEGIN(*pObjectRefArgs, allocArgCnt);

    // We start at the end of the stack.
    BYTE *pCurrent = pStack + stackSize; 
        
    // Special handling for functions that return value classes.
    EEClass *pRetClass = NULL;
    BYTE    *pRetValueClass = NULL;
    bool    hasHiddenParam = false;
    
    if (mSig.HasRetBuffArg())
    {
        hasHiddenParam = true;
        pRetClass = mSig.GetRetTypeHandle().GetClass();
        _ASSERTE(pRetClass->IsValueClass());

        pRetValueClass =
            (BYTE*)_alloca(pRetClass->GetAlignedNumInstanceFieldBytes());
        memset(pRetValueClass, 0,
               pRetClass->GetAlignedNumInstanceFieldBytes());

        pCurrent -= StackElemSize(sizeof(void*));

        *((BYTE**)pCurrent) = pRetValueClass;
    }
    else if (mSig.GetReturnType() == ELEMENT_TYPE_VALUETYPE && mSig.GetReturnType() != mSig.GetReturnTypeNormalized())
    {
        // This is the case where return type is really a VALUETYPE but our calling convention is
        // treating it as primitive. We just need to remember the pretValueClass so that we will box it properly
        // on our way out.
        //
        pRetClass = mSig.GetRetTypeHandle().GetClass();
        _ASSERTE(pRetClass->IsValueClass());
    }
    
    DebuggerIPCE_FuncEvalArgData *argData =
        (DebuggerIPCE_FuncEvalArgData*) pDE->m_argData;
        
    if (pDE->m_argCount > 0)
    {
        // For non-static methods, 'this' is always the first arg in
        // the array. All other args are put in in reverse order.
        unsigned int i;
        unsigned int j;

        // For static methods, there is no 'this' in the given arg
        // list (indexed by i.) This is also true when creating a new
        // object.
        if (staticMethod || (pDE->m_evalType == DB_IPCE_FET_NEW_OBJECT))
            i = 0;
        else
            i = 1;

        bool fNeedBoxOrUnbox;
        
        for (j = allocArgCnt - 1; i < pDE->m_argCount; i++, j--)
        {
            DebuggerIPCE_FuncEvalArgData *pFEAD = &argData[i];
            
            // Move to the next arg in the signature.
            CorElementType argSigType = mSig.NextArgNormalized();
            _ASSERTE(argSigType != ELEMENT_TYPE_END);

            // If this arg is a byref arg, then we'll need to know what type we're referencing for later...
            EEClass *byrefClass = NULL;
            CorElementType byrefArgSigType = ELEMENT_TYPE_END;

            if (argSigType == ELEMENT_TYPE_BYREF)
                byrefArgSigType = mSig.GetByRefType(&byrefClass);
            
            // Point to the proper place on the stack.
            UINT argSize = StackElemSize(mSig.GetLastTypeSize());
            pCurrent -= argSize;

            LOG((LF_CORDB, LL_INFO100000,
                 "i=%d, j=%d: pCurrent=0x%08x, argSigType=0x%x, argSize=%d, byrefArgSigType=0x%0x, inType=0x%0x\n",
                 i, j, pCurrent, argSigType, argSize, byrefArgSigType, pFEAD->argType));

            // If the sig says class but we've got a value class parameter, then remember that we need to box it.  If
            // the sig says value class, but we've got a boxed value class, then remember that we need to unbox it.
            fNeedBoxOrUnbox = ((argSigType == ELEMENT_TYPE_CLASS) && (pFEAD->argType == ELEMENT_TYPE_VALUETYPE)) ||
                ((argSigType == ELEMENT_TYPE_VALUETYPE) && ((pFEAD->argType == ELEMENT_TYPE_CLASS) || (pFEAD->argType == ELEMENT_TYPE_OBJECT)) ||
                // This is when method signature is expecting a BYREF ValueType, yet we recieve the boxed valuetype's handle. 
                (pFEAD->argAddr && pFEAD->argType == ELEMENT_TYPE_CLASS && argSigType == ELEMENT_TYPE_BYREF && byrefArgSigType == ELEMENT_TYPE_VALUETYPE));
            
            GetArgValue(pDE,
                        pFEAD,
                        argSigType == ELEMENT_TYPE_BYREF,
                        fNeedBoxOrUnbox,
                        mSig.GetTypeHandle(),
                        byrefArgSigType,
                        pCurrent,
                        &pPrimitiveArgs[j],
                        &pObjectRefArgs[j],
                        argSigType);
        }

        // Place 'this' first in the array for non-static methods.
        if (!staticMethod && (pDE->m_evalType != DB_IPCE_FET_NEW_OBJECT))
        {
            // We should be back at the beginning by now.
            pCurrent -= sizeof(OBJECTREF);
            _ASSERTE(pCurrent == pStack);
            TypeHandle dummyTH;
            bool isByRef = false;
            fNeedBoxOrUnbox = false;

            // We had better have an object for a 'this' argument!
            CorElementType et = argData[0].argType;

            if (!((et == ELEMENT_TYPE_CLASS) || (et == ELEMENT_TYPE_STRING) || (et == ELEMENT_TYPE_OBJECT) ||
                  (et == ELEMENT_TYPE_VALUETYPE) || (et == ELEMENT_TYPE_SZARRAY) || (et == ELEMENT_TYPE_ARRAY)))
                COMPlusThrow(kArgumentOutOfRangeException, L"ArgumentOutOfRange_Enum");
            
            if (pDE->m_md->GetClass()->IsValueClass())
            {
				// if the MethodDesc is an unboxing stub, we should not unbox the this parameter.
                if (!pDE->m_md->IsUnboxingStub())
                {
                    // For value classes, the 'this' parameter is always passed by reference.
                    isByRef = true;

                    // Remember if we need to unbox this parameter, though.
                    if ((et == ELEMENT_TYPE_CLASS) || (et == ELEMENT_TYPE_OBJECT))
                        fNeedBoxOrUnbox = true;
                }
            }
            else if (et == ELEMENT_TYPE_VALUETYPE)
            {
                // When the method that we invoking is defined on non value type and we receive the ValueType as input,
                // we are calling methods on System.Object. In this case, we need to box the input ValueType.
                fNeedBoxOrUnbox = true;
            }

            GetArgValue(pDE,
                        &argData[0],
                        isByRef,
                        fNeedBoxOrUnbox,                          
                        dummyTH,
                        ELEMENT_TYPE_CLASS,
                        pCurrent,
                        &pPrimitiveArgs[0],
                        &pObjectRefArgs[0],
                        ELEMENT_TYPE_OBJECT);

            // We need to check 'this' for a null ref ourselves... NOTE: only do this if we put an object reference on
            // the stack. If we put a byref for a value type, then we don't need to do this!
            if (!isByRef)
            {
                // The this pointer is not a unboxed value type. 

                INT64 oi1 = (INT64)*((INT32*)pStack);   
                OBJECTREF o1 = Int64ToObj(oi1);

                if (o1 == NULL)
                    COMPlusThrow(kNullReferenceException, L"NullReference_This");

                // For interface method, we have already done the check early on.
                if (!pDE->m_md->IsInterface())
                {
                    // We also need to make sure that the method that we are invoking is either defined on this object or the direct/indirect
                    // base objects.
                    Object  *objPtr = *((Object**) ((BYTE *)pStack));
                    MethodTable *pMT = objPtr->GetMethodTable();
                    if (!pMT->IsArray() && !pMT->IsTransparentProxyType())
                    {
                        TypeHandle thFrom = TypeHandle(pMT);
                        TypeHandle thTarget = TypeHandle(pDE->m_md->GetMethodTable());
                        if (!thFrom.CanCastTo(thTarget))
                            COMPlusThrow(kArgumentException, L"Argument_CORDBBadMethod");

                    }
                }
            }
        }
    }

    // If this is a new object op, then we need to fill in the 0'th
    // arg slot with the 'this' ptr.
    if (pDE->m_evalType == DB_IPCE_FET_NEW_OBJECT)
    {
        *((OBJECTREF*)pStack) = newObj;
        pCurrent -= sizeof(OBJECTREF);

        // If we are invoking a function on a value class, but we have a boxed VC for 'this', then go ahead and unbox it
        // and leave a ref to the vc on the stack as 'this'.
        if (pDE->m_md->GetClass()->IsValueClass())
        {
            INT64 oi1 = (INT64)*((INT32*)pStack);
            OBJECTREF o1 = Int64ToObj(oi1);
            _ASSERTE(o1->GetClass()->IsValueClass());
            void *pData = o1->UnBox();
            *((void**)pStack) = pData;
        }
    }

    // We should be back down to the beginning of the stack now after
    // loading it with args.
    _ASSERTE(pCurrent == pStack);

    // Do a Call on the MethodDesc to execute the method.  If the object was a COM object,
    // then we may not be able to fully resolve the MethodDesc, and so we do a
    // CallOnInterface
    if (pDE->m_md->IsInterface())
        pDE->m_result = pDE->m_md->CallOnInterface(pStack, &mSig);

    // Otherwise, make a call on a regular runtime MethodDesc, which we are guaranteed we
    // can fully resolve since the original object is a runtime object.
    else 
        pDE->m_result = pDE->m_md->CallDebugHelper(pStack, &mSig);
    
    // Ah, but if this was a new object op, then the result is really
    // the object we allocated above...
    if (pDE->m_evalType == DB_IPCE_FET_NEW_OBJECT)
        pDE->m_result = ObjToInt64(newObj);
    else if (pRetClass != NULL)
    {
     
        // Create an object from the return buffer.
        OBJECTREF retObject = AllocateObject(pRetClass->GetMethodTable());
        if (hasHiddenParam)
        {
            _ASSERTE(pRetValueClass != NULL);

            // box the object
            CopyValueClass(retObject->UnBox(), pRetValueClass,
                           pRetClass->GetMethodTable(), 
                           retObject->GetAppDomain());

        }
        else
        {
            _ASSERTE(pRetValueClass == NULL);

            // box the primitive returned
            CopyValueClass(retObject->UnBox(), &(pDE->m_result),
                           pRetClass->GetMethodTable(), 
                           retObject->GetAppDomain());

        }
        pDE->m_result = ObjToInt64(retObject);
    }
    
    // No exception, so it worked as far as we're concerned.
    pDE->m_successful = true;

    // To pass back the result to the right side, we need the basic
    // element type of the result and the module that the signature is
    // valid id (the function's module).
    pDE->m_resultModule = pDE->m_md->GetModule();

    if ((pRetClass != NULL) || (pDE->m_evalType == DB_IPCE_FET_NEW_OBJECT))
    {
        // We always return value classes boxed, and constructors called during a new object operation
        // always return an object...
        pDE->m_resultType = ELEMENT_TYPE_CLASS;
    }
    else
        pDE->m_resultType = mSig.GetReturnTypeNormalized();

    // If the result is an object, then place the object
    // reference into a strong handle and place the handle into the
    // pDE to protect the result from a collection.
    if ((pDE->m_resultType == ELEMENT_TYPE_CLASS) ||
        (pDE->m_resultType == ELEMENT_TYPE_SZARRAY) ||
        (pDE->m_resultType == ELEMENT_TYPE_OBJECT) ||
        (pDE->m_resultType == ELEMENT_TYPE_ARRAY) ||
        (pDE->m_resultType == ELEMENT_TYPE_STRING))
    {
        OBJECTHANDLE oh = pDE->m_thread->GetDomain()->CreateStrongHandle(Int64ToObj(pDE->m_result));
        pDE->m_result = (INT64)oh;
    }
    

    // Update any enregistered byrefs with their new values from the
    // proper byref temporary array.
    if (pDE->m_argCount > 0)
    {
        mSig.Reset();
        
        // For non-static methods, 'this' is always the first arg in
        // the array. All other args are put in in reverse order.
        unsigned int i;
        unsigned int j;

        if (staticMethod)
            i = 0;
        else
            i = 1;
            
        for (j = allocArgCnt - 1; i < pDE->m_argCount; i++, j--)
        {
            CorElementType argSigType = mSig.NextArgNormalized();
            _ASSERTE(argSigType != ELEMENT_TYPE_END);

            if (argSigType == ELEMENT_TYPE_BYREF)
            {
                EEClass *byrefClass = NULL;
                CorElementType byrefArgSigType = mSig.GetByRefType(&byrefClass);
            
                SetByRefArgValue(pDE, &argData[i], byrefArgSigType, pPrimitiveArgs[j], pObjectRefArgs[j]);
            }
        }
    }

    GCPROTECT_END();
    GCPROTECT_END();
}


//
// FuncEvalHijackWroker is the function that managed threads start executing in order to perform a function
// evaluation. Control is transfered here on the proper thread by hijacking that that's IP to this method in
// Debugger::FuncEvalSetup. This function can also be called directly by a Runtime thread that is stopped sending a
// first or second chance exception to the Right Side.
//
void *Debugger::FuncEvalHijackWorker(DebuggerEval *pDE)
{
    LOG((LF_CORDB, LL_INFO100000, "D:FEHW for pDE:%08x evalType:%d\n", pDE, pDE->m_evalType));

#ifdef _X86_ // reliance on context.Eip

    // Preemptive GC is disabled at the start of this method.
    _ASSERTE(g_pEEInterface->IsPreemptiveGCDisabled());

    // If we've got a filter context still installed, then remove it while we do the work...
    CONTEXT *filterContext = g_pEEInterface->GetThreadFilterContext(pDE->m_thread);

    if (filterContext)
    {
        _ASSERTE(pDE->m_evalDuringException);
        g_pEEInterface->SetThreadFilterContext(pDE->m_thread, NULL);
    } 

    // Push our FuncEvalFrame. The return address is equal to the IP in the saved context in the DebuggerEval. The
    // m_Datum becomes the ptr to the DebuggerEval.
    FuncEvalFrame FEFrame(pDE, (void*)pDE->m_context.Eip);
    FEFrame.Push();
    
    // Special handling for a re-abort eval. We don't setup a COMPLUS_TRY or try to lookup a function to call. All we do
    // is have this thread abort itself.
    if (pDE->m_evalType == DB_IPCE_FET_RE_ABORT)
    {
        pDE->m_thread->UserAbort(NULL);
        _ASSERTE(!"Should not return from UserAbort here!");
        return NULL;
    }

    // The method may be in a different AD than the thread. 
    // The RS already verified that all of the arguments are in the same appdomain as the function
    // (because we can't verify it here).
    // Now make sure this thread is in the right AppDomain; switch if needed.    
    Thread *pThread = GetThread();    
    AppDomain * pDomainThread = pThread->GetDomain();
    AppDomain * pDomainMethod = (pDE->m_debuggerModule == NULL) ? 
        pDomainThread : 
        pDE->m_debuggerModule->GetAppDomain();

    const bool fSwitchAppDomain = (pDomainMethod != pDomainThread);

    ContextTransitionFrame frameChangeCtx;
    
    if (fSwitchAppDomain)
    {   
        _ASSERTE(pDomainMethod != NULL);
        pThread->EnterContext(pDomainMethod->GetDefaultContext(), &frameChangeCtx, TRUE);
    }
    
    // Wrap everything in a COMPLUS_TRY so we catch any exceptions that could be thrown.
    COMPLUS_TRY
    {
        switch (pDE->m_evalType)
        {
        case DB_IPCE_FET_NORMAL:
        case DB_IPCE_FET_NEW_OBJECT:
            {
                OBJECTREF Throwable = NULL;
                GCPROTECT_BEGIN(Throwable);
        
                // Find the proper MethodDesc that we need to call.
                HRESULT hr = EEClass::GetMethodDescFromMemberRef(pDE->m_debuggerModule->m_pRuntimeModule,
                                                           pDE->m_methodToken,
                                                           &(pDE->m_md),
                                                           &Throwable);

                if (FAILED(hr))
                    COMPlusThrow(Throwable);
                                      
                // We better have a MethodDesc at this point.
                _ASSERTE(pDE->m_md != NULL);

                IMDInternalImport   *pInternalImport = pDE->m_md->GetMDImport();
                DWORD       dwAttr = pInternalImport->GetMethodDefProps(pDE->m_methodToken);

                if (dwAttr & mdRequireSecObject)
                {
                    // command window cannot evaluate a function with mdRequireSecObject is turned on because
                    // this is expecting to put a security object into caller's frame which we don't have.
                    //
                    COMPlusThrow(kArgumentException,L"Argument_CantCallSecObjFunc");
                }


                // If this is a method on an interface, we have to resolve that down to the method on the class of the
                // 'this' parameter.
                if (pDE->m_md->GetClass()->IsInterface())
                {
                    MethodDesc *pMD = NULL;

                    // Assuming that a constructor can't be an interface method...
                    _ASSERTE(pDE->m_evalType == DB_IPCE_FET_NORMAL);

                    // We need to go grab the 'this' argument to figure out what class we're headed for...
                    _ASSERTE(pDE->m_argCount > 0);
                    DebuggerIPCE_FuncEvalArgData *argData = (DebuggerIPCE_FuncEvalArgData*) pDE->m_argData;

                    // Assume we can only have this for real objects, not value classes...
                    _ASSERTE((argData[0].argType == ELEMENT_TYPE_OBJECT) || (argData[0].argType == ELEMENT_TYPE_CLASS));

                    // We should have a valid this pointer. 
                    // @todo: But the check should cover the register kind as well!
                    if (argData[0].argHome.kind == RAK_NONE && argData[0].argAddr == NULL)
                        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");
    
                    // Suck out the first arg. We're gonna trick GetArgValue by passing in just our object ref as the
                    // stack.
                    TypeHandle	dummyTH;
                    OBJECTREF	or = NULL;
                    Object		*objPtr;

                    // Note that we are passing ELEMENT_TYPE_END in the last parameter because we want to supress the the valid object ref
                    // check since it will be done properly in DoNormalFuncEval.
                    //
                    GetArgValue(pDE, &(argData[0]), false, false, dummyTH, ELEMENT_TYPE_CLASS, (BYTE*)&or, NULL, NULL, ELEMENT_TYPE_END);
                    objPtr = *((Object**) ((BYTE *)&or));
                    if (FAILED(ValidateObject(objPtr)))
                        COMPlusThrow(kArgumentException, L"Argument_BadObjRef");

                    // Null isn't valid in this case!
                    if (objPtr == NULL)
                        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

                    // Now, find the proper MethodDesc for this interface method based on the object we're invoking the
                    // method on.
                    pMD = g_pEEInterface->GetVirtualMethod(pDE->m_debuggerModule->m_pRuntimeModule,
                                                                 OBJECTREFToObject(or),
                                                                 pDE->m_methodToken);
					if (pMD == NULL)
					{
						if  (OBJECTREFToObject(or)->GetMethodTable()->IsThunking())
						{
							// give it another try. It can be a proxy object
							if (OBJECTREFToObject(or)->GetMethodTable()->IsTransparentProxyType())
							{	
                                // Make sure the proxied object is loaded.
                                CRemotingServices::GetClass(or);
                                pMD = OBJECTREFToObject(or)->GetMethodTable()->GetMethodDescForInterfaceMethod(pDE->m_md, or);
							}
						}
                        if (pMD) 
                            pDE->m_md = pMD;
                        else
                            COMPlusThrow(kArgumentException, L"Argument_CORDBBadInterfaceMethod");
					}
                    else 
                        pDE->m_md = pMD;

                    _ASSERTE(pDE->m_md);

                    _ASSERTE(!pDE->m_md->GetClass()->IsInterface()
                             || OBJECTREFToObject(or)->GetMethodTable()->IsComObjectType());
                }

                // If this is a new object operation, then we should have a .ctor.
                if ((pDE->m_evalType == DB_IPCE_FET_NEW_OBJECT) && !pDE->m_md->IsCtor())
                    COMPlusThrow(kArgumentException, L"Argument_MissingDefaultConstructor");
                
                // Run the Class Init for this class, if necessary.
                if (!pDE->m_md->GetMethodTable()->CheckRunClassInit(&Throwable))
                    COMPlusThrow(Throwable);

                GCPROTECT_END();
        
                // Do the bulk of the calling work.
                DoNormalFuncEval(pDE);
                break;
            }
        
        case DB_IPCE_FET_NEW_OBJECT_NC:
            {
                OBJECTREF Throwable = NULL;
                GCPROTECT_BEGIN(Throwable);

                // Find the class.
                pDE->m_class = g_pEEInterface->LoadClass(pDE->m_debuggerModule->m_pRuntimeModule,
                                                         pDE->m_classToken);

                if (pDE->m_class == NULL)
                    COMPlusThrow(kArgumentNullException, L"ArgumentNull_Type");

                // Run the Class Init for this class, if necessary.
                if (!pDE->m_class->GetMethodTable()->CheckRunClassInit(&Throwable))
                    COMPlusThrow(Throwable);

                GCPROTECT_END();
        
                // Create a new instance of the class
                OBJECTREF newObj = NULL;
                GCPROTECT_BEGIN(newObj);

                newObj = AllocateObject(pDE->m_class->GetMethodTable());

                // No exception, so it worked.
                pDE->m_successful = true;

                // Result module is easy.
                pDE->m_resultModule = pDE->m_class->GetModule();

                // So is the result type.
                pDE->m_resultType = ELEMENT_TYPE_CLASS;

                // Make a strong handle for the result.
                OBJECTHANDLE oh = pDE->m_thread->GetDomain()->CreateStrongHandle(newObj);
                pDE->m_result = (INT64)oh;
                GCPROTECT_END();
                
                break;
            }
        
        case DB_IPCE_FET_NEW_STRING:
            {
                // Create the string. m_argData is null terminated...
                STRINGREF sref = COMString::NewString((WCHAR*)pDE->m_argData);
                GCPROTECT_BEGIN(sref);

                // No exception, so it worked.
                pDE->m_successful = true;

                // No module needed since the result type is a string.
                pDE->m_resultModule = NULL;

                // Result type is, of course, a string.
                pDE->m_resultType = ELEMENT_TYPE_STRING;

                // Place the result in a strong handle to protect it from a collection.
                OBJECTHANDLE oh = pDE->m_thread->GetDomain()->CreateStrongHandle((OBJECTREF) sref);
                pDE->m_result = (INT64)oh;
                GCPROTECT_END();
                
                break;
            }
        
        case DB_IPCE_FET_NEW_ARRAY:
            {
                OBJECTREF arr = NULL;
                GCPROTECT_BEGIN(arr);
                
                // @todo: We're only gonna handle SD arrays for right now.
                if (pDE->m_arrayRank > 1)
                    COMPlusThrow(kRankException, L"Rank_MultiDimNotSupported");

                // Gotta be a primitive, class, or System.Object.
                if (((pDE->m_arrayElementType < ELEMENT_TYPE_BOOLEAN) || (pDE->m_arrayElementType > ELEMENT_TYPE_R8)) &&
                    (pDE->m_arrayElementType != ELEMENT_TYPE_CLASS) &&
                    (pDE->m_arrayElementType != ELEMENT_TYPE_OBJECT))
                    COMPlusThrow(kArgumentOutOfRangeException, L"ArgumentOutOfRange_Enum");

                // Grab the dims from the arg/data area.
                SIZE_T *dims;
                dims = (SIZE_T*)pDE->m_argData;

                if (pDE->m_arrayElementType == ELEMENT_TYPE_CLASS)
                {
                    // Find the class we want to make the array elements out of.
                    pDE->m_class = g_pEEInterface->LoadClass(pDE->m_arrayClassDebuggerModuleToken->m_pRuntimeModule,
                                                             pDE->m_arrayClassMetadataToken);

                    arr = AllocateObjectArray(dims[0], TypeHandle(pDE->m_class->GetMethodTable()));
                }
                else if (pDE->m_arrayElementType == ELEMENT_TYPE_OBJECT)
                {
                    // We want to just make an array of System.Objects, so we don't require the user to pass in a
                    // specific class.
                    pDE->m_class = g_pObjectClass->GetClass();

                    arr = AllocateObjectArray(dims[0], TypeHandle(pDE->m_class->GetMethodTable()));
                }
                else
                {
                    // Create a simple array. Note: we can only do this type of create here due to the checks above.
                    arr = AllocatePrimitiveArray(pDE->m_arrayElementType, dims[0]);
                }
                
                    // No exception, so it worked.
                pDE->m_successful = true;

                // Use the module that the array belongs in.
                pDE->m_resultModule = arr->GetMethodTable()->GetModule();

                // Result type is, of course, the type of the array.
                pDE->m_resultType = arr->GetMethodTable()->GetNormCorElementType();

                // Place the result in a strong handle to protect it from a collection.
                OBJECTHANDLE oh = pDE->m_thread->GetDomain()->CreateStrongHandle(arr);
                pDE->m_result = (INT64)oh;
                GCPROTECT_END();
                
                break;
            }

        default:
            _ASSERTE(!"Invalid eval type!");
        }
    }
    COMPLUS_CATCH
    {
        // Note: a fault in here makes things go poorly. The fault will be essentially ignored, and will cause this
        // catch handler to be essentially ingored by our exception system, making it seem as if this catch isn't
        // working.
        
        // We got an exception. Grab the exception object and make that into our result.
        pDE->m_successful = false;

        // Grab the exception.
        OBJECTREF ppException = GETTHROWABLE();
        GCPROTECT_BEGIN(ppException);
        
        // If this is a thread stop exception, and we tried to abort this eval, then the exception is ours.
        if (IsExceptionOfType(kThreadStopException, &ppException) && pDE->m_aborting)
        {
            pDE->m_result = NULL;
            pDE->m_resultType = ELEMENT_TYPE_VOID;
            pDE->m_resultModule = NULL;
            pDE->m_aborted = true;

            // Since we threw that thread stop exception, we need to reset the request to have it thrown.
            pDE->m_thread->ResetStopRequest();
        }   
        else
        {
            // Special handling for thread abort exceptions. We need to explicitly reset the abort request on the EE
            // thread, then make sure to place this thread on a thunk that will re-raise the exception when we continue
            // the process. Note: we still pass this thread abort exception up as the result of the eval.
            if (IsExceptionOfType(kThreadAbortException, &ppException))
            {
                // Reset the abort request and remember that we need to rethrow it.
                pDE->m_thread->UserResetAbort();
                pDE->m_rethrowAbortException = true;
            }   

            // The result is the exception object.
            pDE->m_result = ObjToInt64(ppException);

            if (pDE->m_md)
                pDE->m_resultModule = pDE->m_md->GetModule();
            else
                pDE->m_resultModule = NULL;
        
            pDE->m_resultType = ELEMENT_TYPE_CLASS;
            OBJECTHANDLE oh = pDE->m_thread->GetDomain()->CreateStrongHandle(Int64ToObj(pDE->m_result));
            pDE->m_result = (INT64)oh;
        }
        GCPROTECT_END();
    }
    COMPLUS_END_CATCH

    // The func-eval is now completed, successfully or with failure, aborted or run-to-completion.
    pDE->m_completed = true;

    // Codepitching can hijack our frame's return address. That means that we'll need to update EIP in our saved context
    // so that when its restored, its like we've returned to the codepitching hijack. At this point, the old value of
    // EIP is worthless anyway.
    if (!pDE->m_evalDuringException)
        pDE->m_context.Eip = (DWORD)FEFrame.GetReturnAddress();


    // Restore context
    if (fSwitchAppDomain)
    {
        pThread->ReturnToContext(&frameChangeCtx, TRUE);
    }
    
    // Pop the FuncEvalFrame now that we're pretty much done.
    FEFrame.Pop();

    if (!pDE->m_evalDuringException)
    {
        // Signal to the helper thread that we're done with our func eval.  Start by creating a DebuggerFuncEvalComplete
        // object. Give it an address at which to create the patch, which is a chunk of memory inside of our
        // DebuggerEval big enough to hold a breakpoint instruction.
        void *dest = &(pDE->m_breakpointInstruction);

        // Here is kind of a cheat... we make sure that the address that we patch and jump to is actually also the ptr
        // to our DebuggerEval. This works because m_breakpointInstruction is the first field of the DebuggerEval
        // struct.
        _ASSERTE(dest == pDE);

        SetupDebuggerFuncEvalComplete(pDE->m_thread, dest);
    
        return dest;
    }
    else
    {
        // We don't have to setup any special hijacks to return from here when we've been processing during an
        // exception. We just go ahead and send the FuncEvalComplete event over now. Don't forget to enable/disable PGC
        // around the call...
        _ASSERTE(g_pEEInterface->IsPreemptiveGCDisabled());

        if (filterContext != NULL)
            g_pEEInterface->SetThreadFilterContext(pDE->m_thread, filterContext);
        
        g_pEEInterface->EnablePreemptiveGC();

        BOOL threadStoreLockOwner = FALSE;
        g_pDebugger->LockForEventSending();

        if (CORDebuggerAttached()) {
            g_pDebugger->FuncEvalComplete(pDE->m_thread, pDE);

            threadStoreLockOwner = g_pDebugger->SyncAllThreads();
        }
        
        g_pDebugger->UnlockFromEventSending();

        g_pDebugger->BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
        g_pEEInterface->DisablePreemptiveGC();
        
        return NULL;
    }
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - FuncEvalHijackWorker (Debugger.cpp)");
    return NULL;
#endif // _X86_
}

//
// This is the method that we hijack a thread running managed code. It calls FuncEvalHijackWorker, which actually
// performs the func eval, then jumps to the patch address so we can complete the cleanup.
//
#ifndef _ALPHA_ // Alpha doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
void Debugger::FuncEvalHijack(void)
{
#ifdef _X86_
    __asm
    {
        push eax                    ;; eax holds the ptr to the DebuggerEval
        call Debugger::FuncEvalHijackWorker
        jmp eax                     ;; return is the patch address to jmp to
    }
#else // _X86_
    _ASSERTE(!"@TODO Alpha - FuncEvalHijack (Debugger.cpp)");
#endif

    _ASSERTE(!"FuncEvalHijack should never return!");
}

//
// FuncEvalSetup sets up a function evaluation for the given method on the given thread.
//
HRESULT Debugger::FuncEvalSetup(DebuggerIPCE_FuncEvalInfo *pEvalInfo,
                                BYTE **argDataArea,
                                void **debuggerEvalKey)
{
    Thread *pThread = (Thread*)pEvalInfo->funcDebuggerThreadToken;
    bool fInException = pEvalInfo->evalDuringException;
    
    // If TS_StopRequested (which may have been set by a pending FuncEvalAbort),
    // we will not be able to do a new func-eval
    // @TODO: Remember the current value of m_State, reset m_State as appropriate,
    // do the new func-eval, and then set m_State to the original value
    if (pThread->m_State & Thread::TS_StopRequested)
        return CORDBG_E_FUNC_EVAL_BAD_START_POINT;

    if (g_fProcessDetach)
        return CORDBG_E_FUNC_EVAL_BAD_START_POINT;
    
#ifdef _X86_ // reliance on filterContext->Eip & Eax

    // The thread has to be at a GC safe place for now, just in case the func eval causes a collection. Processing an
    // exception also counts as a "safe place." Eventually, we'd like to have to avoid this check and eval anyway, but
    // that's a way's off...
    if (!fInException && !g_pDebugger->IsThreadAtSafePlace(pThread))
        return CORDBG_E_FUNC_EVAL_BAD_START_POINT;

    _ASSERTE(!(g_pEEInterface->GetThreadFilterContext(pThread) && ISREDIRECTEDTHREAD(pThread)));
    
    // For now, we assume that the target thread must be stopped in managed code due to a single step or a
    // breakpoint. Being stopped while sending a first or second chance exception is also valid, and there may or may
    // not be a filter context when we do a func eval from such places. This will loosen over time, eventually allowing
    // threads that are stopped anywhere in managed code to perform func evals.
    CONTEXT *filterContext = g_pEEInterface->GetThreadFilterContext(pThread);

    // If the thread is redirected, then we can also perform a FuncEval with it since we now have all the necessary
    // frames set up to protect the managed stack at the point the thread was suspended.
    if (filterContext == NULL && ISREDIRECTEDTHREAD(pThread))
    {
        RedirectedThreadFrame *pFrame = (RedirectedThreadFrame *) pThread->GetFrame();
        filterContext = pFrame->GetContext();
    }
    
    if (filterContext == NULL && !fInException)
        return CORDBG_E_FUNC_EVAL_BAD_START_POINT;

    // Create a DebuggerEval to hold info about this eval while its in progress. Constructor copies the thread's
    // CONTEXT.
    DebuggerEval *pDE = new (interopsafe) DebuggerEval(filterContext, pEvalInfo, fInException);

    if (pDE == NULL)
        return E_OUTOFMEMORY;

    SIZE_T argDataAreaSize = 0;
    
    if ((pEvalInfo->funcEvalType == DB_IPCE_FET_NORMAL) ||
        (pEvalInfo->funcEvalType == DB_IPCE_FET_NEW_OBJECT) ||
        (pEvalInfo->funcEvalType == DB_IPCE_FET_NEW_OBJECT_NC))
        argDataAreaSize = pEvalInfo->argCount * sizeof(DebuggerIPCE_FuncEvalArgData);
    else if (pEvalInfo->funcEvalType == DB_IPCE_FET_NEW_STRING)
        argDataAreaSize = pEvalInfo->stringSize;
    else if (pEvalInfo->funcEvalType == DB_IPCE_FET_NEW_ARRAY)
        argDataAreaSize = pEvalInfo->arrayDataLen;

    if (argDataAreaSize > 0)
    {
        pDE->m_argData = new (interopsafe) BYTE[argDataAreaSize];

        if (pDE->m_argData == NULL)
        {
            DeleteInteropSafe(pDE);
            return E_OUTOFMEMORY;
        }

        // Pass back the address of the argument data area so the right side can write to it for us.
        *argDataArea = pDE->m_argData;
    }
    
    // Set the thread's IP (in the filter context) to our hijack function if we're stopped due to a breakpoint or single
    // step.
    if (!fInException)
    {
        _ASSERTE(filterContext != NULL);
        
        filterContext->Eip = (DWORD)Debugger::FuncEvalHijack;

        // Don't be fooled into thinking you can push things onto the thread's stack now. If the thread is stopped at a
        // breakpoint or from a single step, then its really suspended in the SEH filter. ESP in the thread's CONTEXT,
        // therefore, points into the middle of the thread's current stack. So we pass things we need in the hijack in
        // the thread's registers.

        // Set EAX to point to the DebuggerEval.
        filterContext->Eax = (DWORD)pDE;
    }
    else
    {
        HRESULT hr = CheckInitPendingFuncEvalTable();
        _ASSERTE(SUCCEEDED(hr));

        if (FAILED(hr))
            return (hr);

        // If we're in an exception, then add a pending eval for this thread. This will cause us to perform the func
        // eval when the user continues the process after the current exception event.
        g_pDebugger->m_pPendingEvals->AddPendingEval(pDE->m_thread, pDE);
    }

    // Return that all went well. Tracing the stack at this point should not show that the func eval is setup, but it
    // will show a wrong IP, so it shouldn't be done.
    *debuggerEvalKey = (void*)pDE;
    
    LOG((LF_CORDB, LL_INFO100000, "D:FES for pDE:%08x evalType:%d on thread %#x, id=0x%x\n",
        pDE, pDE->m_evalType, pThread, pThread->GetThreadId()));

    return S_OK;
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - FuncEvalSetup (Debugger.cpp)");
    return E_FAIL;
#endif // _X86_
}

//
// FuncEvalSetupReAbort sets up a function evaluation specifically to rethrow a ThreadAbortException on the given
// thread.
//
HRESULT Debugger::FuncEvalSetupReAbort(Thread *pThread)
{
    LOG((LF_CORDB, LL_INFO1000,
            "D::FESRA: performing reabort on thread %#x, id=0x%x\n",
            pThread, pThread->GetThreadId()));

#ifdef _X86_ // reliance on filterContext->Eip & Eax

    // The thread has to be at a GC safe place. It should be, since this is only done in response to a previous eval
    // completing with a ThreadAbortException.
    if (!g_pDebugger->IsThreadAtSafePlace(pThread))
        return CORDBG_E_FUNC_EVAL_BAD_START_POINT;
    
    _ASSERTE(!(g_pEEInterface->GetThreadFilterContext(pThread) && ISREDIRECTEDTHREAD(pThread)));

    // Grab the filter context.
    CONTEXT *filterContext = g_pEEInterface->GetThreadFilterContext(pThread);
    
    // If the thread is redirected, then we can also perform a FuncEval with it since we now have all the necessary
    // frames set up to protect the managed stack at the point the thread was suspended.
    if (filterContext == NULL && ISREDIRECTEDTHREAD(pThread))
    {
        RedirectedThreadFrame *pFrame = (RedirectedThreadFrame *) pThread->GetFrame();
        filterContext = pFrame->GetContext();
    }
    
    if (filterContext == NULL)
        return CORDBG_E_FUNC_EVAL_BAD_START_POINT;

    // Create a DebuggerEval to hold info about this eval while its in progress. Constructor copies the thread's
    // CONTEXT.
    DebuggerEval *pDE = new (interopsafe) DebuggerEval(filterContext, pThread);

    if (pDE == NULL)
        return E_OUTOFMEMORY;

    // Set the thread's IP (in the filter context) to our hijack function.
    _ASSERTE(filterContext != NULL);
        
    filterContext->Eip = (DWORD)Debugger::FuncEvalHijack;

    // Set EAX to point to the DebuggerEval.
    filterContext->Eax = (DWORD)pDE;

    // Now clear the bit requesting a re-abort
    pThread->ResetThreadStateNC(Thread::TSNC_DebuggerReAbort);

    // Return that all went well. Tracing the stack at this point should not show that the func eval is setup, but it
    // will show a wrong IP, so it shouldn't be done.
    
    return S_OK;
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - FuncEvalSetup (Debugger.cpp)");
    return E_FAIL;
#endif // _X86_
}

//
// FuncEvalAbort aborts a function evaluation already in progress.
//
HRESULT Debugger::FuncEvalAbort(void *debuggerEvalKey)
{
    DebuggerEval *pDE = (DebuggerEval*) debuggerEvalKey;

    if (pDE->m_aborting == false)
    {
        // Remember that we're aborting this func eval.
        pDE->m_aborting = true;
    
        LOG((LF_CORDB, LL_INFO1000,
             "D::FEA: performing UserStopForDebugger on thread %#x, id=0x%x\n",
             pDE->m_thread, pDE->m_thread->GetThreadId()));

        if (!g_fProcessDetach && !pDE->m_completed)
        {
            // Perform a user stop on the thread that the eval is running on.
            // This will cause a ThreadStopException to be thrown on the thread.
            // @TODO: Use UserInterrupt() to abort blocked func-evals
            
            if (m_stopped)
                pDE->m_thread->SetStopRequest(); // Queue a stop-request for whenever the thread is resumed
            else
                pDE->m_thread->UserStopForDebugger(); // Try to stop the running thread now
        }
        LOG((LF_CORDB, LL_INFO1000, "D::FEA: UserStopForDebugger complete.\n"));
    }

    return S_OK;
}

//
// FuncEvalCleanup cleans up after a function evaluation is released.
//
HRESULT Debugger::FuncEvalCleanup(void *debuggerEvalKey)
{
    DebuggerEval *pDE = (DebuggerEval*) debuggerEvalKey;

    _ASSERTE(pDE->m_completed);

    LOG((LF_CORDB, LL_INFO1000, "D::FEC: pDE:%08x 0x%08x, id=0x%x\n",
         pDE, pDE->m_thread, pDE->m_thread->GetThreadId()));

    DeleteInteropSafe(pDE);

    return S_OK;
}


unsigned FuncEvalFrame::GetFrameAttribs()
{
    if (((DebuggerEval*)m_Datum)->m_evalDuringException)
        return FRAME_ATTR_NONE;
    else
        return FRAME_ATTR_RESUMABLE;    // Treat the next frame as the top frame.
}


LPVOID FuncEvalFrame::GetReturnAddress()
{
    if (((DebuggerEval*)m_Datum)->m_evalDuringException)
        return NULL;
    else
        return m_ReturnAddress;
}

//
// This updates the register display for a FuncEvalFrame.
//
void FuncEvalFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    DebuggerEval *pDE = (DebuggerEval*)GetDebuggerEval();

    // No context to update if we're doing a func eval from within exception processing.
    if (pDE->m_evalDuringException)
        return;
    
#ifdef _X86_
    // Reset pContext; it's only valid for active (top-most) frame.
    pRD->pContext = NULL;

    // Update all registers in the reg display from the CONTEXT we stored when the thread was hijacked for this func
    // eval. We have to update all registers, not just the callee saved registers, because we can hijack a thread at any
    // point for a func eval, not just at a call site.
    pRD->pEdi = &(pDE->m_context.Edi);
    pRD->pEsi = &(pDE->m_context.Esi);
    pRD->pEbx = &(pDE->m_context.Ebx);
    pRD->pEdx = &(pDE->m_context.Edx);
    pRD->pEcx = &(pDE->m_context.Ecx);
    pRD->pEax = &(pDE->m_context.Eax);
    pRD->pEbp = &(pDE->m_context.Ebp);
    pRD->Esp  =   pDE->m_context.Esp;
    pRD->pPC  = (SLOT*)GetReturnAddressPtr();

#else // _X86_
    _ASSERTE(!"@TODO Alpha - UpdateRegDisplay (Debugger.cpp)");
#endif
}


//
// SetReference sets an object reference for the Right Side,
// respecting the write barrier for references that are in the heap.
//
HRESULT Debugger::SetReference(void *objectRefAddress,
                               bool  objectRefInHandle,
                               void *newReference)
{
    HRESULT     hr = S_OK;

    // If the object ref isn't in a handle, then go ahead and use
    // SetObjectReference.
    if (!objectRefInHandle)
    {
        OBJECTREF *dst = (OBJECTREF*)objectRefAddress;
        OBJECTREF  src = *((OBJECTREF*)&newReference);

        SetObjectReferenceUnchecked(dst, src);
    }
    else
    {
        hr = ValidateObject((Object *)newReference);

        if (SUCCEEDED(hr))
        {
            // If the object reference to set is inside of a handle, then
            // fixup the handle.
            OBJECTHANDLE h = *((OBJECTHANDLE*)objectRefAddress);
            OBJECTREF  src = *((OBJECTREF*)&newReference);
            HndAssignHandle(h, src);
        }
    }
    
    return hr;
}

//
// SetValueClass sets a value class for the Right Side, respecting the write barrier for references that are embedded
// within in the value class.
//
HRESULT Debugger::SetValueClass(void *oldData, void *newData, mdTypeDef classMetadataToken, void *classDebuggerModuleToken)
{
    HRESULT hr = S_OK;

    // Find the class given its module and token. The class must be loaded.
    DebuggerModule *pDebuggerModule = (DebuggerModule*) classDebuggerModuleToken;
    EEClass *pClass = g_pEEInterface->FindLoadedClass(pDebuggerModule->m_pRuntimeModule, classMetadataToken);

    if (pClass == NULL)
        return CORDBG_E_CLASS_NOT_LOADED;

    // Update the value class.
    CopyValueClassUnchecked(oldData, newData, pClass->GetMethodTable());
    
    // Free the buffer that is holding the new data. This is a buffer that was created in response to a GET_BUFFER
    // message, so we release it with ReleaseRemoteBuffer.
    ReleaseRemoteBuffer((BYTE*)newData, true);
    
    return hr;
}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::SetILInstrumentedCodeMap(MethodDesc *fd,
                                           BOOL fStartJit,
                                           ULONG32 cILMapEntries,
                                           COR_IL_MAP rgILMapEntries[])
{
    if (fStartJit == TRUE)
        JITBeginning(fd, true);

    DebuggerJitInfo *dji = GetJitInfo(fd,NULL);

    _ASSERTE(dji != NULL);

    if (dji->m_rgInstrumentedILMap != NULL)
    {
        CoTaskMemFree(dji->m_rgInstrumentedILMap);
    }
    
    dji->m_cInstrumentedILMap = cILMapEntries;
    dji->m_rgInstrumentedILMap =  rgILMapEntries;
    
    return S_OK;
}

//
// EarlyHelperThreadDeath handles the case where the helper
// thread has been ripped out from underneath of us by
// ExitProcess or TerminateProcess. These calls are pure evil, wacking
// all threads except the caller in the process. This can happen, for
// instance, when an app calls ExitProcess. All threads are wacked,
// the main thread calls all DLL main's, and the EE starts shutting
// down in its DLL main with the helper thread nuked.
//
void Debugger::EarlyHelperThreadDeath(void)
{
    if (m_pRCThread)    
        m_pRCThread->EarlyHelperThreadDeath();
}

//
// This tells the debugger that shutdown of the in-proc debugging services has begun. We need to know this during
// managed/unmanaged debugging so we can stop doing certian things to the process (like hijacking threads.)
//
void Debugger::ShutdownBegun(void)
{
    if (m_pRCThread != NULL)
    {
        DebuggerIPCControlBlock *dcb = m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC);

        if ((dcb != NULL) && (dcb->m_rightSideIsWin32Debugger))
            dcb->m_shutdownBegun = true;
    }
}

#include "CorPub.h"
#include "Cordb.h"


/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::SetCurrentPointerForDebugger( void *ptr,PTR_TYPE ptrType)
{
    _ASSERTE(m_pRCThread->m_cordb != NULL);

    INPROC_LOCK();

    CordbBase *b = m_pRCThread->m_cordb->m_processes.GetBase(
        GetCurrentProcessId());

    _ASSERTE( b != NULL );
    CordbProcess *p = (CordbProcess *)b;
    b = p->m_userThreads.GetBase(GetCurrentThreadId());
    CordbThread *t = (CordbThread *)b;
    
    // Current proc can't be NULL, thread might not have started.
    // @todo Can other, non runtime threads call this fnx?
    if (t == NULL)         
    {
        LOG((LF_CORDB, LL_INFO10000, "D::SCPFD: thread is null!\n"));

        INPROC_UNLOCK();
        return CORDBG_E_BAD_THREAD_STATE;
    }
    
    switch(ptrType)
    {
        case PT_MODULE:
#ifdef _DEBUG
            _ASSERTE((!t->m_pModuleSpecial ^ !ptr) ||
                      t->m_pModuleSpecial == ptr);
#endif //_DEBUG
            LOG((LF_CORDB, LL_INFO10000, "D::SCPFD: PT_MODULE:0x%x\n",ptr));
            t->m_pModuleSpecial = (Module *)ptr;
            break;            

        case PT_ASSEMBLY:
            LOG((LF_CORDB, LL_INFO10000, "D::SCPFD: PT_ASSEMBLY:0x%x\n",ptr));
            if (ptr == NULL)
            {
#ifdef _DEBUG
                _ASSERTE(t->m_pAssemblySpecialCount > 0);
#endif
                t->m_pAssemblySpecialCount--;
            }
            else
            {
                if (t->m_pAssemblySpecialCount == t->m_pAssemblySpecialAlloc)
                {
                    Assembly **pOldStack;
                    USHORT newAlloc;
                    if (t->m_pAssemblySpecialAlloc == 1)
                    {
                        // Special case - size one stack doesn't allocate
                        pOldStack = &t->m_pAssemblySpecial;
                        newAlloc = 5;
                    }
                    else
                    {
                        pOldStack = t->m_pAssemblySpecialStack;
                        newAlloc = t->m_pAssemblySpecialAlloc*2;
                    }

                    Assembly **pNewStack = 
                      new Assembly* [newAlloc];
                    
                    memcpy(pNewStack, pOldStack, 
                           t->m_pAssemblySpecialCount * sizeof(Assembly*));
                    if (pOldStack != &t->m_pAssemblySpecial)
                        delete [] pOldStack;

                    t->m_pAssemblySpecialAlloc = newAlloc;
                    t->m_pAssemblySpecialStack = pNewStack;
                }

                if (t->m_pAssemblySpecialAlloc == 1)
                    t->m_pAssemblySpecial = (Assembly*)ptr;
                else
                    t->m_pAssemblySpecialStack[t->m_pAssemblySpecialCount] 
                      = (Assembly*)ptr;

                t->m_pAssemblySpecialCount++;
            }
            break;            
        
        default:
            _ASSERTE( !"Debugger::SetCurrentPointerForDebugger given invalid type!\n");
    }

    INPROC_UNLOCK();
    return S_OK;

}

/******************************************************************************
 *
 ******************************************************************************/
HRESULT Debugger::GetInprocICorDebug( IUnknown **iu, bool fThisThread)
{
    _ASSERTE(m_pRCThread != NULL && m_pRCThread->m_cordb != NULL);

    if (fThisThread)
    {
        INPROC_LOCK();

        CordbBase *b = m_pRCThread->m_cordb->m_processes.GetBase(
            GetCurrentProcessId());

        // Current proc can't be NULL
        _ASSERTE( b != NULL );
        CordbProcess *p = (CordbProcess *)b;
        b = p->m_userThreads.GetBase(GetCurrentThreadId());
        CordbThread *t = (CordbThread *)b;

        INPROC_UNLOCK();
        
        if (t != NULL)         
        {
            return  t->QueryInterface(IID_IUnknown, (void**)iu);
        }
        else
        {
            // If we weren't able to find it, it's because it's not a managed
            // thread.  Perhaps it hasn't started, perhaps it's 'dead', perhaps
            // we're the concurrent GC thread.
            return CORPROF_E_NOT_MANAGED_THREAD;
        }
    }
    else
    {
        return m_pRCThread->m_cordb->QueryInterface(IID_IUnknown, (void**)iu);;
    }
}

/****************************************************************************/
HRESULT Debugger::SetInprocActiveForThread(BOOL fIsActive)
{
    INPROC_LOCK();

    CordbBase *b = m_pRCThread->m_cordb->m_processes.GetBase(GetCurrentProcessId());

    // Current proc can't be NULL
    _ASSERTE( b != NULL );
    CordbProcess *p = (CordbProcess *)b;

    // Get this thread's object
    b = p->m_userThreads.GetBase(GetCurrentThreadId());
    _ASSERTE(b != NULL);

    CordbThread *t = (CordbThread *)b;

    // Set the value
    t->m_fThreadInprocIsActive = fIsActive;

    // Always set the framesFresh to false
    t->m_framesFresh = false;

    INPROC_UNLOCK();

    return (S_OK);
}

/****************************************************************************/
BOOL Debugger::GetInprocActiveForThread()
{
    INPROC_LOCK();

    CordbBase *b = m_pRCThread->m_cordb->m_processes.GetBase(GetCurrentProcessId());

    // Current proc can't be NULL
    _ASSERTE( b != NULL );
    CordbProcess *p = (CordbProcess *)b;

    // Get this thread's object
    b = p->m_userThreads.GetBase(GetCurrentThreadId());
    _ASSERTE(b != NULL);

    CordbThread *t = (CordbThread *)b;

    // Make sure that we're not re-entering the 
    BOOL fIsActive = t->m_fThreadInprocIsActive;

    INPROC_UNLOCK();

    return (fIsActive);
}

/****************************************************************************/
void Debugger::InprocOnThreadDestroy(Thread *pThread)
{
    CordbProcess *pdbProc = (CordbProcess *) m_pRCThread->m_cordb->m_processes.GetBase(GetCurrentProcessId());
    _ASSERTE(pdbProc != NULL);

    CordbThread *pdbThread = (CordbThread *) pdbProc->m_userThreads.GetBase(pThread->GetThreadId(), FALSE);

    if (pdbThread != NULL)
    {
        pdbThread = (CordbThread *) pdbProc->m_userThreads.RemoveBase(pThread->GetThreadId());
        _ASSERTE(pdbThread != NULL);
    }
}

/****************************************************************************
 * This will perform the duties of the helper thread if none already exists.
 * This is called in the case that the loader lock is held and so no new
 * threads can be spun up to be the helper thread, so the existing thread
 * must be the helper thread until a new one can spin up.
 ***************************************************************************/
void Debugger::DoHelperThreadDuty(bool temporaryHelp)
{
    _ASSERTE(ThreadHoldsLock());

    LOG((LF_CORDB, LL_INFO1000,
         "D::SSCIPCE: helper thread is not ready, doing helper "
         "thread duty...\n"));

    // We're the temporary helper thread now.
    m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_temporaryHelperThreadId =
        GetCurrentThreadId();

    // Make sure the helper thread has something to wait on while
    // we're trying to be the helper thread.
    VERIFY(ResetEvent(m_pRCThread->GetHelperThreadCanGoEvent()));

    // Release the debugger lock.
    Unlock();

    // We set the syncThreadIsLockFree event here. If we're in this call, then it means that we're on the thread that
    // sent up the sync complete flare, and we've released the debuger lock. By setting this event, we allow the Right
    // Side to suspend this thread now. (Note: this is all for Win32 debugging support.)
    if (m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_rightSideIsWin32Debugger)
        VERIFY(SetEvent(m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_syncThreadIsLockFree));
    
    // Do helper thread duty. We pass true to it knows that we're
    // the temporary helper thread.
    m_pRCThread->MainLoop(temporaryHelp);

    // Re-lock the debugger.
    Lock();

    LOG((LF_CORDB, LL_INFO1000,
         "D::SSCIPCE: done doing helper thread duty. "
         "Current helper thread id=0x%x\n",
         m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_helperThreadId));

    // We're not the temporary helper thread anymore.
    m_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC)->m_temporaryHelperThreadId = 0;

    // Let the helper thread go if its waiting on us.
    VERIFY(SetEvent(m_pRCThread->GetHelperThreadCanGoEvent()));
}

// Some of this code is copied in DebuggerRCEventThead::Mainloop
HRESULT Debugger::VrpcToVls(DebuggerIPCEvent *event)
{
    // Make room for any Right Side event on the stack.
    DebuggerIPCEvent *e =
        (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);

    memcpy(e, 
           m_pRCThread->GetIPCEventReceiveBuffer(IPC_TARGET_INPROC), 
           CorDBIPC_BUFFER_SIZE);

    bool fIrrelevant;
    fIrrelevant = HandleIPCEvent(e, IPC_TARGET_INPROC);

    return S_OK;
}


// This function is called from the EE to notify the right side
// whenever the name of a thread or AppDomain changes
HRESULT Debugger::NameChangeEvent(AppDomain *pAppDomain, Thread *pThread)
{
    // Don't try to send one of these if the thread really isn't setup
    // yet. This can happen when initially setting up an app domain,
    // before the appdomain create event has been sent. Since the app
    // domain create event hasn't been sent yet in this case, its okay
    // to do this...
    if (g_pEEInterface->GetThread() == NULL)
        return S_OK;
    
    LOG((LF_CORDB, LL_INFO1000, "D::NCE: Sending NameChangeEvent 0x%x 0x%x\n",
        pAppDomain, pThread));

    bool disabled = g_pEEInterface->IsPreemptiveGCDisabled();

    if (disabled)
        g_pEEInterface->EnablePreemptiveGC();

    // Prevent other Runtime threads from handling events.
    BOOL threadStoreLockOwner = FALSE;
    
    LockForEventSending();
    
    if (CORDebuggerAttached())
    {

        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, 
                     DB_IPCE_NAME_CHANGE, 
                     g_pEEInterface->GetThread()->GetThreadId(),
                     (void *)(g_pEEInterface->GetThread()->GetDomain()));


        if (pAppDomain)
        {
            ipce->NameChange.eventType = APP_DOMAIN_NAME_CHANGE;
            ipce->NameChange.debuggerAppDomainToken = (void *)pAppDomain;
        }
        else
        {
            ipce->NameChange.eventType = THREAD_NAME_CHANGE;
            _ASSERTE (pThread);
            ipce->NameChange.debuggerThreadToken = pThread->GetThreadId();
        }

        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(g_pEEInterface->GetThread()->GetDomain());
    } 
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::NCE: Skipping SendIPCEvent because RS detached."));
    }
    
    UnlockFromEventSending();

    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
    g_pEEInterface->DisablePreemptiveGC();

    if (!disabled)
        g_pEEInterface->EnablePreemptiveGC();

    return S_OK;

}

/******************************************************************************
 *
 ******************************************************************************/
BOOL Debugger::SendCtrlCToDebugger(DWORD dwCtrlType)
{    
    LOG((LF_CORDB, LL_INFO1000, "D::SCCTD: Sending CtrlC Event 0x%x\n",
        dwCtrlType));

    // Prevent other Runtime threads from handling events.
    BOOL threadStoreLockOwner = FALSE;
    
    LockForEventSending();
    
    if (CORDebuggerAttached())
    {
        DebuggerIPCEvent* ipce = m_pRCThread->GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);
        InitIPCEvent(ipce, 
                     DB_IPCE_CONTROL_C_EVENT, 
                     GetCurrentThreadId(),
                     NULL);

        ipce->Exception.exceptionHandle = (void *)dwCtrlType;

        m_pRCThread->SendIPCEvent(IPC_TARGET_OUTOFPROC);

        // Stop all Runtime threads
        threadStoreLockOwner = TrapAllRuntimeThreads(NULL);
    }
    else 
    {
        LOG((LF_CORDB,LL_INFO1000, "D::SCCTD: Skipping SendIPCEvent because RS detached."));
    }
    
    UnlockFromEventSending();

    // now wait for notification from the right side about whether or not
    // the out-of-proc debugger is handling ControlC events.
    WaitForSingleObject(m_CtrlCMutex, INFINITE);

    BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
    
    return m_DebuggerHandlingCtrlC;
}

/******************************************************************************
 *
 ******************************************************************************/
DebuggerModule *Debugger::TranslateRuntimeModule(Module *pModule)
{
    _ASSERTE(pModule != NULL);
    _ASSERTE(pModule->GetAssembly() != NULL);
    _ASSERTE(pModule->GetAssembly()->Parent() != NULL);

    BaseDomain *bd = pModule->GetAssembly()->Parent();
    return LookupModule(pModule, (AppDomain *)bd);
}

/******************************************************************************
 *
 ******************************************************************************/
void Debugger::ClearAppDomainPatches(AppDomain *pAppDomain)
{
    LOG((LF_CORDB, LL_INFO10000, "D::CADP\n"));

    _ASSERTE(pAppDomain != NULL);
    
    Lock();

    DebuggerController::DeleteAllControllers(pAppDomain);

    Unlock();
}

// Allows the debugger to keep an up to date list of special threads
HRESULT Debugger::UpdateSpecialThreadList(DWORD cThreadArrayLength,
                                        DWORD *rgdwThreadIDArray)
{
    _ASSERTE(g_pRCThread != NULL);
    
    DebuggerIPCControlBlock *pIPC = g_pRCThread->GetDCB(IPC_TARGET_OUTOFPROC);
    _ASSERTE(pIPC);

    if (!pIPC)
        return (E_FAIL);

    // Save the thread list information, and mark the dirty bit so
    // the right side knows.
    pIPC->m_specialThreadList = rgdwThreadIDArray;
    pIPC->m_specialThreadListLength = cThreadArrayLength;
    pIPC->m_specialThreadListDirty = true;

    return (S_OK);
}

// Updates the pointer for the debugger services
void Debugger::SetIDbgThreadControl(IDebuggerThreadControl *pIDbgThreadControl)
{
    if (m_pIDbgThreadControl)
        m_pIDbgThreadControl->Release();

    m_pIDbgThreadControl = pIDbgThreadControl;

    if (m_pIDbgThreadControl)
        m_pIDbgThreadControl->AddRef();
}

//
// If a thread is Win32 suspended right after hitting a breakpoint instruction, but before the OS has transitioned the
// thread over to the user-level exception dispatching logic, then we may see the IP pointing after the breakpoint
// instruction. There are times when the Runtime will use the IP to try to determine what code as run in the prolog or
// epilog, most notably when unwinding a frame. If the thread is suspended in such a case, then the unwind will believe
// that the instruction that the breakpoint replaced has really been executed, which is not true. This confuses the
// unwinding logic. This function is called from Thread::HandledJITCase() to help us recgonize when this may have
// happened and allow us to skip the unwind and abort the HandledJITCase.
//
// The criteria is this:
//
// 1) If a debugger is attached.
//
// 2) If the instruction 1 byte before the IP is a breakpoint instruction.
//
// 3) If the IP is in the prolog or epilog of a managed function.
//
BOOL Debugger::IsThreadContextInvalid(Thread *pThread)
{
    BOOL invalid = FALSE;

#ifdef _X86_
    // Get the thread context.
    CONTEXT ctx;
    ctx.ContextFlags = CONTEXT_CONTROL;
    BOOL success = ::GetThreadContext(pThread->GetThreadHandle(), &ctx);

    if (success)
    {
        BYTE inst;
        
        __try
        {
            // Grab Eip - 1
            inst = *(((BYTE*)ctx.Eip) - 1);
        }
        __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            // If we fault trying to read the byte before EIP, then we know that its not a breakpoint.
            inst = 0;
        }

        // Is it a breakpoint?
        if (inst == 0xcc)
        {
            size_t prologSize; // Unused...

            if (g_pEEInterface->IsInPrologOrEpilog((BYTE*)ctx.Eip, &prologSize))
            {
                LOG((LF_CORDB, LL_INFO1000, "D::ITCI: thread is after a BP and in prolog or epilog.\n"));
                invalid = TRUE;
            }
        }
    }
    else
    {
        // If we can't get the context, then its definetly invalid... ;)
        LOG((LF_CORDB, LL_INFO1000, "D::ITCI: couldn't get thread's context!\n"));
        invalid = TRUE;
    }
#endif // _X86_

    return invalid;
}

/* ------------------------------------------------------------------------ *
 * DebuggerHeap impl
 * ------------------------------------------------------------------------ */

DebuggerHeap::~DebuggerHeap()
{
    if (m_heap != NULL)
    {
        delete m_heap;
        m_heap = NULL;

        DeleteCriticalSection(&m_cs);
    }
}

HRESULT DebuggerHeap::Init(char *name)
{
    // Allocate a new heap object.
    m_heap = new gmallocHeap();

    if (m_heap != NULL)
    {
        // Init the heap
        HRESULT hr = m_heap->Init(name);

        if (SUCCEEDED(hr))
        {
            // Init the critical section we'll use to lock the heap.
            InitializeCriticalSection(&m_cs);

            return S_OK;
        }
        else
        {
            // Init failed, so delete the heap.
            delete m_heap;
            m_heap = NULL;
            
            return hr;
        }
    }
    else
        return E_OUTOFMEMORY;
}

void *DebuggerHeap::Alloc(DWORD size)
{
    void *ret;

    _ASSERTE(m_heap != NULL);
    
    EnterCriticalSection(&m_cs);
    ret = m_heap->Alloc(size);
    LeaveCriticalSection(&m_cs);

    return ret;
}

void *DebuggerHeap::Realloc(void *pMem, DWORD newSize)
{
    void *ret;

    _ASSERTE(m_heap != NULL);
    
    EnterCriticalSection(&m_cs);
    ret = m_heap->ReAlloc(pMem, newSize);
    LeaveCriticalSection(&m_cs);
    
    return ret;
}

void DebuggerHeap::Free(void *pMem)
{
    if (pMem != NULL)
    {
        _ASSERTE(m_heap != NULL);
    
        EnterCriticalSection(&m_cs);
        m_heap->Free(pMem);
        LeaveCriticalSection(&m_cs);
    }
}

/******************************************************************************
 *
 ******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\controller.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: controller.h
//
// Debugger control flow object
//
// @doc
//*****************************************************************************

#ifndef CONTROLLER_H_
#define CONTROLLER_H_

/* ========================================================================= */

#include "frameinfo.h"

/* ------------------------------------------------------------------------- *
 * Forward declarations
 * ------------------------------------------------------------------------- */

class DebuggerPatchSkip;
class DebuggerController;
class DebuggerControllerQueue;
/* ------------------------------------------------------------------------- *
 * ControllerStackInfo utility
 * ------------------------------------------------------------------------- *
 * @class ControllerStackInfo | <t ControllerStackInfo> is a class designed
 *  to simply obtain a two-frame stack trace: it will obtain the bottommost
 *  framepointer (m_bottomFP), a given target frame (m_activeFrame), and the 
 *  frame above the target frame (m_returnFrame).  Note that the target frame
 *  may be the bottommost, 'active' frame, or it may be a frame higher up in
 *  the stack.  <t ControllerStackInfo> accomplishes this by starting at the 
 *  bottommost frame and walking upwards until it reaches the target frame,
 *  whereupon it records the m_activeFrame info, gets called once more to
 *  fill in the m_returnFrame info, and thereafter stops the stack walk.
 *
 *  @access public
 *  @field void *|m_bottomFP| Frame pointer for the 
 * 		bottommost (most active)
 *		frame.  We can add more later, if we need it.  Currently just used in
 *		TrapStep.  NULL indicates an uninitialized value.
 * 
 *  @field void	*|m_targetFP|The frame pointer to the frame
 *  	that we actually want the info of.
 *
 *  @field 	bool|m_targetFrameFound|Set to true if
 *		WalkStack finds the frame indicated by targetFP handed to GetStackInfo
 *      false otherwise.
 *
 *  @field FrameInfo|m_activeFrame| A <t FrameInfo>
 *      describing the target frame.  This should always be valid after a
 *      call to GetStackInfo.
 * 
 *  @field FrameInfo|m_returnFrame| A <t FrameInfo>
 *      describing the frame above the target frame, if  target's
 *      return frame were found (call HasReturnFrame() to see if this is
 *      valid). Otherwise, this will be the same as m_activeFrame, above
 *
 * @access private
 * @field bool|m_activeFound|Set to true if we found the target frame.
 * @field bool|m_returnFound|Set to true if we found the target's return frame.
 */
class ControllerStackInfo
{
public:
	void				   *m_bottomFP;  
	void				   *m_targetFP; 
	bool					m_targetFrameFound;
	
	FrameInfo				m_activeFrame;
	FrameInfo				m_returnFrame;

    CorDebugChainReason     m_specialChainReason;

    // @mfunc static StackWalkAction|ControllerStackInfo|WalkStack| The
    //      callback that will be invoked by the DebuggerWalkStackProc.
    //      Note that the data argument is the "this" pointer to the <t  
    //      ControllerStackInfo>.
	static StackWalkAction WalkStack(FrameInfo *pInfo, void *data)
	{
		ControllerStackInfo *i = (ControllerStackInfo *) data;

		//save this info away for later use
		if (i->m_bottomFP == NULL)
			i->m_bottomFP = pInfo->fp;

		//have we reached the correct frame yet?
		if (!i->m_targetFrameFound && i->m_targetFP <= pInfo->fp)
			i->m_targetFrameFound = true;
			
		if (i->m_targetFrameFound )
		{
			if (i->m_activeFound )
			{
                if (pInfo->chainReason == CHAIN_CLASS_INIT)
                    i->m_specialChainReason = pInfo->chainReason;

                if (pInfo->fp != i->m_activeFrame.fp) // avoid dups
                {
                    i->m_returnFrame = *pInfo;
                    i->m_returnFound = true;
                    
                    return SWA_ABORT;
                }
			}
			else
			{
				i->m_activeFrame = *pInfo;
				i->m_activeFound = true;

                return SWA_CONTINUE;
			}
		}

		return SWA_CONTINUE;
	}

    //@mfunc void|ControllerStackInfo| GetStackInfo| GetStackInfo
    //      is invoked by the user to trigger the stack walk.  This will
    //      cause the stack walk detailed in the class description to happen.
    // @parm Thread*|thread|The thread to do the stack walk on.
    // @parm void*|targetFP|Can be either NULL (meaning that the bottommost
    //      frame is the target), or an frame pointer, meaning that the
    //      caller wants information about a specific frame.
    // @parm CONTEXT*|pContext|A pointer to a CONTEXT structure.  CANNOT be
    //      NULL
    // @parm BOOL|contextValid|True if the pContext arg points to a valid
    //      context.  Since the stack trace will obtain a valid context if it
    //      needs to, one shouldn't worry about getting a valid context.  If
    //      you happen to have one lying around, though, that would be great.
	void GetStackInfo(Thread *thread, void *targetFP,
					  CONTEXT *pContext, BOOL contextValid)
	{
		m_activeFound = false;
		m_returnFound = false;
		m_bottomFP = NULL;
		m_targetFP = targetFP;
		m_targetFrameFound = (m_targetFP ==NULL);
        m_specialChainReason = CHAIN_NONE;

        int result = DebuggerWalkStack(thread, 
                                       NULL, 
                                       pContext, 
                                       contextValid, 
                                       WalkStack, 
                                       (void *) this,
                                       FALSE);

		_ASSERTE(m_activeFound); // All threads have at least one unmanaged frame

		if (result == SWA_DONE)
		{
			_ASSERTE(!m_returnFound);
			m_returnFrame = m_activeFrame;
		}
	}

    //@mfunc bool |ControllerStackInfo|HasReturnFrame|Returns
    //      true if m_returnFrame is valid.  Returns false
    //      if m_returnFrame is set to m_activeFrame
	bool HasReturnFrame() { return m_returnFound; }

private:
	bool					m_activeFound;
	bool					m_returnFound;
};

/* ------------------------------------------------------------------------- *
 * DebuggerController routines
 * ------------------------------------------------------------------------- */

#ifdef _X86_
#define MAX_INSTRUCTION_LENGTH 4+2+1+1+4+4
#else
#define MAX_INSTRUCTION_LENGTH	sizeof(long)*2 // need something real here
#endif

// @struct DebuggerFunctionKey | Provides a means of hashing unactivated
// breakpoints, it's used mainly for the case where the function to put
// the breakpoint in hasn't been JITted yet.
// @field Module*|module|Module that the method belongs to.
// @field mdMethodDef|md|meta data token for the method.
struct DebuggerFunctionKey
{
    Module					*module; 
    mdMethodDef				md;
};

// @struct DebuggerControllerPatch | An entry in the patch (hash) table,
// this should contain all the info that's needed over the course of a
// patch's lifetime.
//
// @field FREEHASHENTRY|entry|Three USHORTs, this is required
//      by the underlying hashtable implementation
// @field DWORD|opcode|A nonzero opcode && address field means that
//		the patch has been applied to something.
//		A patch with a zero'd opcode field means that the patch isn't
//		actually tracking a valid break opcode.  See DebuggerPatchTable
//		for more details.
// @field DebuggerController *|controller|The controller that put this
//		patch here.  
// @field boolean|fSaveOpcode|If true, then unapply patch will save
//      a copy of the opcode in opcodeSaved, and apply patch will
//      copy opcodeSaved to opcode rather than grabbing the opcode 
//      from the instruction.  This is useful mainly when the JIT
//      has moved code, and we don't want to erroneously pick up the
//      user break instruction.
//      Full story: 
//      FJIT moves the code.  Once that's done, it calls Debugger->MoveCode(MethodDesc
//      *) to let us know the code moved.  At that point, unbind all the breakpoints 
//      in the method.  Then we whip over all the patches, and re-bind all the 
//      patches in the method.  However, we can't guarantee that the code will exist 
//      in both the old & new locations exclusively of each other (the method could 
//      be 0xFF bytes big, and get moved 0x10 bytes in one direction), so instead of 
//      simply re-using the unbind/rebind logic as it is, we need a special case 
//      wherein the old method isn't valid.  Instead, we'll copy opcode into 
//      opcodeSaved, and then zero out opcode (we need to zero out opcode since that 
//      tells us that the patch is invalid, if the right side sees it).  Thus the run-
//      around.
// @field DWORD|opcodeSaved|Contains an opcode if fSaveOpcode == true
// @field SIZE_T|nVersion|If the patch is stored by IL offset, then we
//		must also store the version ID so that we know which version
//		this is supposed to be applied to.  Note that this will only
//		be set for DebuggerBreakpoints & DebuggerEnCBreakpoints.  For
//		others, it should be set to DJI_VERSION_INVALID.  For constants,
//		see DebuggerJitInfo
// @field DebuggerJitInfo|dji|A pointer to the debuggerJitInfo that describes
//      the method (and version) that this patch is applied to.  This field may
//      also have the value DebuggerJitInfo::DJI_VERSION_INVALID

// @field SIZE_T|pid|Within a given patch table, all patches have a
//		semi-unique ID.  There should be one and only 1 patch for a given
//		{pid,nVersion} tuple, thus ensuring that we don't duplicate
//		patches from multiple, previous versions.
// @field AppDomain *|pAppDomain|Either NULL (patch applies to all appdomains
//      that the debugger is attached to)
//      or contains a pointer to an AppDomain object (patch applies only to
//      that A.D.)
struct DebuggerControllerPatch
{
	FREEHASHENTRY			entry; 
	DebuggerController		*controller;
	DebuggerFunctionKey		key;
	SIZE_T					offset;
	const BYTE				*address;
	void					*fp;
	DWORD					opcode;
	boolean					fSaveOpcode;
	DWORD					opcodeSaved;
	boolean					native;
	boolean					managed;
    TraceDestination        trace;
	boolean					triggering;
	boolean					deleted;
	DebuggerJitInfo		   *dji;
	SIZE_T					pid;
    AppDomain              *pAppDomain;
};

/* @class DebuggerPatchTable | This is the table that contains
 *  information about the patches (breakpoints) maintained by the
 *  debugger for a variety of purposes.
 *  @comm The only tricky part is that
 *  patches can be hashed either by the address that they're applied to,
 *  or by <t DebuggerFunctionKey>.  If address is equal to zero, then the
 *  patch is hashed by <t DebuggerFunctionKey>
 *
 *  Patch table inspection scheme:
 *
 *  We have to be able to inspect memory (read/write) from the right
 *  side w/o the help of the left side.  When we do unmanaged debugging,
 *  we need to be able to R/W memory out of a debuggee s.t. the debugger
 *  won't see our patches.  So we have to be able to read our patch table
 *  from the left side, which is problematic since we know that the left
 *  side will be arbitrarily frozen, but we don't know where.
 *   
 *  So our scheme is this:
 *  we'll send a pointer to the g_patches table over in startup,
 *  and when we want to inspect it at runtime, we'll freeze the left side,
 *  then read-memory the "data" (m_pcEntries) array over to the right.  We'll
 *  iterate through the array & assume that anything with a non-zero opcode
 *  and address field is valid.  To ensure that the assumption is ok, we
 *  use the zeroing allocator which zeros out newly created space, and
 *  we'll be very careful about zeroing out the opcode field during the
 *  Unapply operation
 *
 * NOTE: Don't mess with the memory protections on this while the
 * left side is frozen (ie, no threads are executing). 
 * WriteMemory depends on being able to write the patchtable back
 * if it was read successfully.
 * @base private | CHashTableAndData\<CNewZeroData\>
 * @xref <t DebuggerFunctionKey>
 */
#define DPT_INVALID_SLOT (0xFFFF)
class DebuggerPatchTable : private CHashTableAndData<CNewZeroData>
{
    //@access Private Members:
private:
	//@cmember incremented so that we can get DPT-wide unique PIDs.
	// pid = Patch ID.
	SIZE_T m_pid;

    //@cmember  Given a patch, retrieves the correct key
	BYTE *Key(DebuggerControllerPatch *patch) 
	{
		if (patch->address == NULL)
			return (BYTE *) &patch->key;
		else
			return (BYTE *) patch->address;
	}

	//@cmember Given two <t DebuggerControllerPatch>es, tells
    // whether they are equal or not.  Does this by comparing the correct
    // key.
    //@parm BYTE* | pc1 | If <p pc2> is hashed by address,
    //  <p pc1> is an address.  If
    //  <p pc2> is hashed by <t DebuggerFunctionKey>,
    //  <p pc1> is a <t DebuggerFunctionkey>
    //@rdesc True if the two patches are equal, false otherwise
	BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
	{
		if (((DebuggerControllerPatch *) pc2)->address == NULL)
		{
			DebuggerFunctionKey *k2 = &((DebuggerControllerPatch *) pc2)->key;
			DebuggerFunctionKey *k1 = (DebuggerFunctionKey *) pc1;

			return k1->module != k2->module || k1->md != k2->md;
		}
		else
			return ((DebuggerControllerPatch *) pc2)->address != pc1;
	}

	//@cmember Computes a hash value based on an address
	USHORT HashAddress(const BYTE *address)
	  { return (USHORT) (((SIZE_T)address) ^ (((SIZE_T)address)>>16)); } 

    //@cmember Computes a hash value based on a <t DebuggerFunctionKey>
	USHORT HashKey(DebuggerFunctionKey *key)
	  { return (USHORT) HashBytes((BYTE *) key, sizeof(key)); }

    //@cmember Computes a hash value from a patch, using the address field
    // if the patch is hashed by address, using the <t DebuggerFunctionKey>
    // otherwise
	USHORT Hash(DebuggerControllerPatch *patch) 
	{ 
		if (patch->address == NULL)
			return HashKey(&patch->key);
		else
			return HashAddress(patch->address);
	}
    //@access Public Members
  public:
	enum {
		DCP_PID_INVALID,
		DCP_PID_FIRST_VALID,
	};

	DebuggerPatchTable() : CHashTableAndData<CNewZeroData>(1) { }

    // This is a sad legacy hack. The patch table (implemented as this 
    // class) is shared across process. We publish the runtime offsets of
    // some key fields. Since those fields are private, we have to provide 
    // accessors here. So if you're not using these functions, don't start.
    // We can hopefully remove them.
    static SIZE_T GetOffsetOfEntries()
    {
        // assert that we the offsets of these fields in the base class is
        // the same as the offset of this field in this class.
        _ASSERTE((void*)(DebuggerPatchTable*)NULL == (void*)(CHashTableAndData<CNewZeroData>*)NULL);
        return helper_GetOffsetOfEntries();
    }

    static SIZE_T GetOffsetOfCount()
    {
        _ASSERTE((void*)(DebuggerPatchTable*)NULL == (void*)(CHashTableAndData<CNewZeroData>*)NULL);
        return helper_GetOffsetOfCount();
    }

	HRESULT Init() 
	{ 
		m_pid = DCP_PID_FIRST_VALID;
		return NewInit(17, sizeof(DebuggerControllerPatch), 101); 
	}

    // Assuming that the chain of patches (as defined by all the
    // GetNextPatch from this patch) are either sorted or NULL, take the given
    // patch (which should be the first patch in the chain).  This
    // is called by AddPatch to make sure that the order of the
    // patches is what we want for things like E&C, DePatchSkips,etc.
    void SortPatchIntoPatchList(DebuggerControllerPatch **ppPatch);

    void SpliceOutOfList(DebuggerControllerPatch *patch);
    
    void SpliceInBackOf(DebuggerControllerPatch *patchAppend,
                        DebuggerControllerPatch *patchEnd);

   	// 
	// Note that patches may be reallocated - do not keep a pointer to a patch.
	// 
    DebuggerControllerPatch *AddPatch(DebuggerController *controller, 
                                      Module *module, 
                                      mdMethodDef md, 
                                      size_t offset, 
                                      bool native,
                                      void *fp,
                                      AppDomain *pAppDomain,
                                      DebuggerJitInfo *dji = NULL, 
                                      SIZE_T pid = DCP_PID_INVALID)
    { 
        LOG( (LF_CORDB,LL_INFO10000,"DCP:AddPatchVer unbound "
            "relative in methodDef 0x%x with dji 0x%x "
            "controller:0x%x AD:0x%x\n", md, 
            dji, controller, pAppDomain));

    	DebuggerFunctionKey key;

    	key.module = module;
    	key.md = md;
    	
    	DebuggerControllerPatch *patch = 
    	  (DebuggerControllerPatch *) Add(HashKey(&key));

        //zero this out just to be sure.  See lengthy comment above
        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
        patch->opcode = 0;
    	patch->controller = controller;
    	patch->key.module = module;
    	patch->key.md = md;
    	patch->offset = offset;
    	patch->address = NULL;
    	patch->fp = fp;
    	patch->native = native;
    	patch->managed = true;
    	patch->triggering = false;
    	patch->deleted = false;
    	patch->fSaveOpcode = false;
        patch->pAppDomain = pAppDomain;
    	if (pid == DCP_PID_INVALID)
    		patch->pid = m_pid++;
    	else
    		patch->pid = pid;
    		
    	patch->dji = dji;

    	if (dji == NULL)
    		LOG((LF_CORDB,LL_INFO10000,"AddPatch w/ version "
    			"DJI_VERSION_INVALID, pid:0x%x\n",patch->pid));
    	else
    	{
    		LOG((LF_CORDB,LL_INFO10000,"AddPatch w/ version 0x%04x, "
    			"pid:0x%x\n", dji->m_nVersion,patch->pid));

#ifdef _DEBUG
            MethodDesc *pFD = g_pEEInterface->LookupMethodDescFromToken(
                                                    module,
                                                    md);
            _ASSERTE( pFD == dji->m_fd );
#endif //_DEBUG            
        }

    	return patch;
    }
    
    #define DPT_DEFAULT_TRACE_TYPE TRACE_OTHER
    DebuggerControllerPatch *AddPatch(DebuggerController *controller, 
    								  MethodDesc *fd, 
                                      size_t offset, 
    								  bool native, 
                                      bool managed,
    								  const BYTE *address, 
                                      void *fp,
                                      AppDomain *pAppDomain,
    								  DebuggerJitInfo *dji = NULL, 
    								  SIZE_T pid = DCP_PID_INVALID,
                                      TraceType traceType = DPT_DEFAULT_TRACE_TYPE)
    { 
    	LOG((LF_CORDB,LL_INFO10000,"DCP:AddPatch bound "
            "absolute to 0x%x with dji 0x%x (mdDef:0x%x) "
            "controller:0x%x AD:0x%x\n", 
            address, dji, (fd!=NULL?fd->GetMemberDef():0), controller,
            pAppDomain));

    	DebuggerControllerPatch *patch = 
    	  (DebuggerControllerPatch *) Add(HashAddress(address));

        //zero this out just to be sure.  See lengthy comment above
        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
        patch->opcode = 0;
    	patch->controller = controller;

    	if (fd == NULL)
    	{
    		patch->key.module = NULL;
    		patch->key.md = mdTokenNil;
    	}
    	else
    	{
    		patch->key.module = g_pEEInterface->MethodDescGetModule(fd); 
    		patch->key.md = fd->GetMemberDef();
    	}

    	patch->offset = offset;
    	patch->address = address;
    	patch->fp = fp;
    	patch->native = native;
    	patch->managed = managed;
        patch->trace.type = traceType;
    	patch->triggering = false;
    	patch->deleted = false;
    	patch->fSaveOpcode = false;
        patch->pAppDomain = pAppDomain;
    	if (pid == DCP_PID_INVALID)
    		patch->pid = m_pid++;
    	else
    		patch->pid = pid;
    		
    	patch->dji = dji;

    	if (dji == NULL)
    		LOG((LF_CORDB,LL_INFO10000,"AddPatch w/ version "
    			"DJI_VERSION_INVALID, pid:0x%x\n", patch->pid));
    	else
    	{
    		LOG((LF_CORDB,LL_INFO10000,"AddPatch w/ version 0x%04x, "
    			"pid:0x%x\n", dji->m_nVersion, patch->pid));
    			
            _ASSERTE( fd==NULL || fd == dji->m_fd );
        }

        SortPatchIntoPatchList(&patch);

    	return patch;
    }

	void BindPatch(DebuggerControllerPatch *patch, const BYTE *address)
	{
		patch->address = address;
		
        //Since the actual patch doesn't move, we don't have to worry about
        //zeroing out the opcode field (see lenghty comment above)
		CHashTable::Delete(HashKey(&patch->key), 
						   ItemIndex((HASHENTRY*)patch));
		CHashTable::Add(HashAddress(address), ItemIndex((HASHENTRY*)patch));

        SortPatchIntoPatchList(&patch);
	}

	void UnbindPatch(DebuggerControllerPatch *patch)
	{
		//@todo We're hosed if the patch hasn't been primed with 
		// this info & we can't get it...
		if (patch->key.module == NULL ||
			patch->key.md == mdTokenNil)
		{
			MethodDesc *fd = g_pEEInterface->GetNativeCodeMethodDesc(
								patch->address);
			_ASSERTE( fd != NULL );
			patch->key.module = g_pEEInterface->MethodDescGetModule(fd); 
			patch->key.md = fd->GetMemberDef();
		}

        //Since the actual patch doesn't move, we don't have to worry about
        //zeroing out the opcode field (see lenghty comment above)
		CHashTable::Delete( HashAddress(patch->address),
						    ItemIndex((HASHENTRY*)patch));
		CHashTable::Add( HashKey(&patch->key),
						 ItemIndex((HASHENTRY*)patch));
	}
	
	// @cmember GetPatch will find the first  patch in the hash table 
	//		that is hashed by matching the {Module,mdMethodDef} to the
	//		patch's <t DebuggerFunctionKey>.  This will NOT find anything
	//		hashed by address, even if that address is within the 
	//		method specified.
	DebuggerControllerPatch *GetPatch(Module *module, mdMethodDef md)
    { 
		DebuggerFunctionKey key;

		key.module = module;
		key.md = md;

		DebuggerControllerPatch *patch 
		  = (DebuggerControllerPatch *) Find(HashKey(&key), (BYTE *) &key);

		return patch;
	}

	// @cmember GetPatch will translate MethodDesc into {Module,mdMethodDef},
	//		and find the first  patch in the hash table that is hashed by
	//		matching <t DebuggerFunctionKey>.  This will NOT find anything
	//		hashed by address, even if that address is within the MethodDesc.
	DebuggerControllerPatch *GetPatch(MethodDesc *fd)
    { 
		DebuggerFunctionKey key;

		key.module = g_pEEInterface->MethodDescGetModule(fd); 
		key.md = fd->GetMemberDef();

		DebuggerControllerPatch *patch 
		  = (DebuggerControllerPatch *) Find(HashKey(&key), (BYTE *) &key);

		return patch;
	}

	// @cmember GetPatch will translate find the first  patch in the hash 
	// 		table that is hashed by address.  It will NOT find anything hashed
	//		by {Module,mdMethodDef}, or by MethodDesc.
	DebuggerControllerPatch *GetPatch(const BYTE *address)
    { 
		DebuggerControllerPatch *patch 
		  = (DebuggerControllerPatch *) 
			Find(HashAddress(address), (BYTE *) address); 

		return patch;
	}

	DebuggerControllerPatch *GetNextPatch(DebuggerControllerPatch *prev)
    { 
        USHORT iNext;
        HASHENTRY *psEntry;

        // Start at the next entry in the chain.
        iNext = EntryPtr(ItemIndex((HASHENTRY*)prev))->iNext;

        // Search until we hit the end.
        while (iNext != 0xffff)
        {
            // Compare the keys.
            psEntry = EntryPtr(iNext);

            // Careful here... we can hash the entries in this table
            // by two types of keys. In this type of search, the type
            // of the second key (psEntry) does not necessarily
            // indicate the type of the first key (prev), so we have
            // to check for sure.
            DebuggerControllerPatch *pc2 = (DebuggerControllerPatch*)psEntry;

            if (((pc2->address == NULL) && (prev->address == NULL)) ||
                ((pc2->address != NULL) && (prev->address != NULL)))
                if (!Cmp(Key(prev), psEntry))
                    return pc2;

            // Advance to the next item in the chain.
            iNext = psEntry->iNext;
        }

        return NULL;
	}

	void RemovePatch(DebuggerControllerPatch *patch)
    {
		//
		// Because of the implementation of CHashTable, we can safely
		// delete elements while iterating through the table.  This
		// behavior is relied upon - do not change to a different
		// implementation without considering this fact.
		//
        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
		Delete(Hash(patch),  (HASHENTRY *) patch);
		//it's very important to zero out the opcode field, as it 
		//is used by the right side to determine if a patch is
		//valid or not
        //@todo we should be able to _ASSERTE that opcode ==0
        //we should figure out why we can't
        patch->opcode = 0;
        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
	}

	// @cmember Find the first patch in the patch table, and store
	//		index info in info.  Along with GetNextPatch, this can 
	//		iterate through the whole patch table.  Note that since the
	//		hashtable operates via iterating through all the contents
	//		of all the buckets, if you add an entry while iterating
	//		through the table, you  may or may not iterate across 
	//		the new entries.  You will iterate through all the entries
	//		that were present at the beginning of the run.  You
	//		safely delete anything you've already iterated by, anything
	//		else is kinda risky.
	DebuggerControllerPatch *GetFirstPatch(HASHFIND *info)
    { 
		return (DebuggerControllerPatch *) FindFirstEntry(info);
	}

	// @cmember Along with GetFirstPatch, this can 	iterate through 
	//		the whole patch table.  See GetFirstPatch for more info
	//		on the rules of iterating through the table.
	DebuggerControllerPatch *GetNextPatch(HASHFIND *info)
    { 
		return (DebuggerControllerPatch *) FindNextEntry(info);
	}

	// @cmember Used by DebuggerController to translate an index 
	//		of a patch into a direct pointer.
    inline HASHENTRY *GetEntryPtr(USHORT iEntry)
    {
       	return EntryPtr(iEntry);
    }
    
	// @cmember Used by DebuggerController to grab indeces of patches
	// 	rather than holding direct pointers to them.
    inline USHORT GetItemIndex( HASHENTRY *p)
    {
        return ItemIndex(p);
    }

    void ClearPatchesFromModule(Module *pModule);

#ifdef _DEBUG_PATCH_TABLE
public:
	// @cmember:DEBUG An internal debugging routine, it iterates
	//		through the hashtable, stopping at every
	//		single entry, no matter what it's state.  For this to
	//		compile, you're going to have to add friend status
	//		of this class to CHashTableAndData in 
	//		to $\Com99\Src\inc\UtilCode.h
	void CheckPatchTable()
	{
		if (NULL != m_pcEntries)
		{
			DebuggerControllerPatch *dcp;
			int i = 0;
			while (i++ <m_iEntries)
			{
				dcp = (DebuggerControllerPatch*)&(((DebuggerControllerPatch *)m_pcEntries)[i]);
				if (dcp->opcode != 0 )
				{
					LOG((LF_CORDB,LL_INFO1000, "dcp->addr:0x%8x "
						"mdMD:0x%8x, offset:0x%x, native:%d\n",
						dcp->address, dcp->key.md, dcp->offset,
						dcp->native));
				}
				// YOUR CHECK HERE
			}
		}
	}

#endif _DEBUG_PATCH_TABLE

    // @cmember: Count how many patches are in the table.
    // Use for asserts
    int GetNumberOfPatches()
    {
        int total = 0;
        
        if (NULL != m_pcEntries)
        {
            DebuggerControllerPatch *dcp;
            int i = 0;
            
            while (i++ <m_iEntries)
            {
                dcp = (DebuggerControllerPatch*)&(((DebuggerControllerPatch *)m_pcEntries)[i]);
                
                if (dcp->opcode != 0 || dcp->triggering)
                    total++;
            }
        }
        return total;
    }

};

// @mstruct DebuggerControllerPage|Will eventually be used for 
// 		'break when modified' behaviour'
typedef struct DebuggerControllerPage
{
	DebuggerControllerPage	*next;
	const BYTE				*start, *end;
	DebuggerController		*controller;
	bool					readable;
} DebuggerControllerPage;

// @enum DEBUGGER_CONTROLLER_TYPE|Identifies the type of the controller.
// It exists b/c we have RTTI turned off.
// Note that the order of these is important - SortPatchIntoPatchList
// relies on this ordering.
//
// @emem DEBUGGER_CONTROLLER_STATIC|Base class response.  Should never be
//      seen, since we shouldn't be asking the base class about this.
// @emem DEBUGGER_CONTROLLER_BREAKPOINT|DebuggerBreakpoint
// @emem DEBUGGER_CONTROLLER_STEPPER|DebuggerStepper
// @emem DEBUGGER_CONTROLLER_THREAD_STARTER|DebuggerThreadStarter
// @emem DEBUGGER_CONTROLLER_ENC|DebuggerEnCBreakpoint
// @emem DEBUGGER_CONTROLLER_PATCH_SKIP|DebuggerPatchSkip
enum DEBUGGER_CONTROLLER_TYPE
{
    DEBUGGER_CONTROLLER_THREAD_STARTER,
    DEBUGGER_CONTROLLER_ENC,
    DEBUGGER_CONTROLLER_ENC_PATCH_TO_SKIP, // At any one address, 
    									   // There can be only one!
    DEBUGGER_CONTROLLER_PATCH_SKIP,
    DEBUGGER_CONTROLLER_BREAKPOINT,         
    DEBUGGER_CONTROLLER_STEPPER,
    DEBUGGER_CONTROLLER_FUNC_EVAL_COMPLETE,
    DEBUGGER_CONTROLLER_USER_BREAKPOINT,
    DEBUGGER_CONTROLLER_STATIC,
};

enum TP_RESULT
{
    TPR_TRIGGER,            // This controller wants to SendEvent
    TPR_IGNORE,             // This controller doesn't want to SendEvent
    TPR_TRIGGER_ONLY_THIS,  // This, and only this controller, should be triggered.
                            // Right now, only the DebuggerEnCRemap controller
                            // returns this, the remap patch should be the first
                            // patch in the list.
    TPR_TRIGGER_ONLY_THIS_AND_LOOP,
                            // This, and only this controller, should be triggered.
                            // Right now, only the DebuggerEnCRemap controller
                            // returns this, the remap patch should be the first
                            // patch in the list.
                            // After triggering this, DPOSS should skip the
                            // ActivatePatchSkip call, so we hit the other
                            // breakpoints at this location.
    TPR_IGNORE_STOP,        // Don't SendEvent, and stop asking other
                            // controllers if they want to.
                            // Service any previous triggered controllers.
};

enum SCAN_TRIGGER
{
    ST_PATCH        = 0x1,  // Only look for patches
    ST_SINGLE_STEP  = 0x2,  // Look for patches, and single-steps.
} ;

enum TRIGGER_WHY
{
    TY_NORMAL       = 0x0,
    TY_SHORT_CIRCUIT= 0x1,  // EnC short circuit - see DispatchPatchOrSingleStep
} ;

// @class DebuggerController| <t DebuggerController> serves
// both as a static class that dispatches exceptions coming from the
// EE, and as an abstract base class for the five classes that derrive
// from it.
class DebuggerController 
{
	friend DebuggerPatchSkip;
    friend DebuggerRCThread; //so we can get offsets of fields the
    //right side needs to read
    friend Debugger; // So Debugger can lock, use, unlock the patch
    	// table in MapAndBindFunctionBreakpoints
    friend void DebuggerPatchTable::ClearPatchesFromModule(Module *pModule);
    friend void Debugger::UnloadModule(Module* pRuntimeModule, 
                            AppDomain *pAppDomain);
    
	//
	// Static functionality
	//

  public:

    static HRESULT Initialize();
    static void Uninitialize();
    static void DeleteAllControllers(AppDomain *pAppDomain);

	//
	// global event dispatching functionality
	//

	static bool DispatchNativeException(EXCEPTION_RECORD *exception,
										CONTEXT *context,
										DWORD code,
										Thread *thread);
	static bool DispatchUnwind(Thread *thread,
							   MethodDesc *newFD, SIZE_T offset, 
							   const BYTE *frame,
                               CorDebugStepReason unwindReason);

    static bool DispatchCLRCatch(Thread *thread);
    
	static bool DispatchTraceCall(Thread *thread, 
								  const BYTE *address);
	static bool DispatchPossibleTraceCall(Thread *thread,
                                          UMEntryThunk *pUMEntryThunk,
                                          Frame *pFrame);

	static DWORD GetPatchedOpcode(const BYTE *address);
	static void BindFunctionPatches(MethodDesc *fd, const BYTE *code);
	static void UnbindFunctionPatches(MethodDesc *fd, bool fSaveOpcodes=false );
	

    static BOOL DispatchPatchOrSingleStep(Thread *thread, 
                                          CONTEXT *context, 
                                          const BYTE *ip,
                                          SCAN_TRIGGER which);
                                          
    static DebuggerControllerPatch *IsXXXPatched(const BYTE *eip,
            DEBUGGER_CONTROLLER_TYPE dct);

    static BOOL IsJittedMethodEnCd(const BYTE *address);
    
    static BOOL ScanForTriggers(const BYTE *address,
                                Thread *thread,
                                CONTEXT *context,
                                DebuggerControllerQueue *pDcq,
                                SCAN_TRIGGER stWhat,
                                TP_RESULT *pTpr);

    static void UnapplyPatchesInCodeCopy(Module *module, 
                                         mdMethodDef md, 
                                         DebuggerJitInfo *dji,
                                         MethodDesc *fd,
                                         bool native, 
                                         BYTE *code, 
                                         SIZE_T startOffset, 
                                         SIZE_T endOffset);

    static void UnapplyPatchesInMemoryCopy(BYTE *memory, CORDB_ADDRESS start, 
                                           CORDB_ADDRESS end);

    static bool ReapplyPatchesInMemory(CORDB_ADDRESS start, CORDB_ADDRESS end );

	static void AddPatch(DebuggerController *dc,
	                     MethodDesc *fd, 
	                     bool native, 
						 const BYTE *address, 
						 void *fp,
						 DebuggerJitInfo *dji, 
						 SIZE_T pid, 
						 SIZE_T natOffset);

    static DebuggerPatchSkip *ActivatePatchSkip(Thread *thread, 
                                                const BYTE *eip,
                                                BOOL fForEnC);

    static int GetNumberOfPatches() 
    {
        if (g_patches == NULL) 
            return 0;
        
        return g_patches->GetNumberOfPatches();
    }

  private:

	static bool MatchPatch(Thread *thread, CONTEXT *context, 
						   DebuggerControllerPatch *patch);
	static BOOL DispatchAccessViolation(Thread *thread, CONTEXT *context,
										const BYTE *ip, const BYTE *address, 
										bool read);

	// Returns TRUE if we should continue to dispatch after this exception
	// hook.
	static BOOL DispatchExceptionHook(Thread *thread, CONTEXT *context,
									  EXCEPTION_RECORD *exception);

protected:
	static void Lock()
	{ 
		LOCKCOUNTINCL("Lock in Controller.h");

		EnterCriticalSection(&g_criticalSection);
	}

    static void Unlock()
	{ 
		LeaveCriticalSection(&g_criticalSection); 
		LOCKCOUNTDECL("UnLock in Controller.h");

	}

public:    
	static bool g_runningOnWin95;

private:

	static DebuggerPatchTable *g_patches;
    static BOOL g_patchTableValid;
	static DebuggerControllerPage *g_protections;
	static DebuggerController *g_controllers;
	static CRITICAL_SECTION g_criticalSection;

	static bool BindPatch(DebuggerControllerPatch *patch, 
	                      const BYTE *code,
	                      BOOL *pFailedBecauseOfInvalidOffset);
	static bool ApplyPatch(DebuggerControllerPatch *patch);
	static bool UnapplyPatch(DebuggerControllerPatch *patch);
	static void UnapplyPatchAt(DebuggerControllerPatch *patch, BYTE *address);
	static bool IsPatched(const BYTE *address, BOOL native);

	static void ActivatePatch(DebuggerControllerPatch *patch);
	static void DeactivatePatch(DebuggerControllerPatch *patch);
	
	static void ApplyTraceFlag(Thread *thread);
	static void UnapplyTraceFlag(Thread *thread);

  public:
	static const BYTE *g_pMSCorEEStart, *g_pMSCorEEEnd;

	static const BYTE *GetILPrestubDestination(const BYTE *prestub);
	static const BYTE *GetILFunctionCode(MethodDesc *fd);

	//
	// Non-static functionality
	//

  public:

	DebuggerController(Thread *thread, AppDomain *pAppDomain);
	virtual ~DebuggerController();
	void Delete();
	bool IsDeleted() { return m_deleted; }

	// @cmember Return the pointer g_patches.
    // Access to patch table for the RC threads (EE,DI)
	// Why: The right side needs to know the address of the patch
	// table (which never changes after it gets created) so that ReadMemory,
	// WriteMemory can work from out-of-process.  This should only be used in
	// when the Runtime Controller is starting up, and not thereafter.
	// How:return g_patches;
    static DebuggerPatchTable *GetPatchTable() { return g_patches; }
    static BOOL *GetPatchTableValidAddr() { return &g_patchTableValid; }

	// @cmember Is there a patch at addr?  
	// We sometimes want to use this version of the method 
	// (as opposed to IsPatched) because there is
	// a race condition wherein a patch can be added to the table, we can
	// ask about it, and then we can actually apply the patch.
	// How: If the patch table contains a patch at that address, there
	// is.
	// @access public
    static bool IsAddressPatched(const BYTE *address)
    {
        return (g_patches->GetPatch(address) != NULL);
    }
    
	//
	// Event setup
	//

	Thread *GetThread() { return m_thread; }

    BOOL AddPatch(Module *module, 
                  mdMethodDef md,
                  SIZE_T offset, 
                  bool native, 
                  void *fp,
                  DebuggerJitInfo *dji,
                  BOOL fStrict);
                  
    void AddPatch(MethodDesc *fd,
                  SIZE_T offset, 
                  bool native, 
                  void *fp,
                  BOOL fAttemptBind, 
                  DebuggerJitInfo *dji,
                  SIZE_T pid);
                  
    void AddPatch(MethodDesc *fd,
                  SIZE_T offset, 
                  bool native, 
                  void *fp,
                  DebuggerJitInfo *dji,
                  AppDomain *pAppDomain);
                  
                  
    // This version is particularly useful b/c it doesn't assume that the
    // patch is inside a managed method.
    DebuggerControllerPatch *AddPatch(const BYTE *address, 
                                      void *fp, 
                                      bool managed,
                                      TraceType traceType, 
                                      DebuggerJitInfo *dji,
                                      AppDomain *pAppDomain);

    bool PatchTrace(TraceDestination *trace, void *fp, bool fStopInUnmanaged);

    void AddProtection(const BYTE *start, const BYTE *end, bool readable);
    void RemoveProtection(const BYTE *start, const BYTE *end, bool readable);

	static BOOL IsSingleStepEnabled(Thread *pThread);
    void EnableSingleStep();
    static void EnableSingleStep(Thread *pThread);

    void DisableSingleStep();

    void EnableExceptionHook();
    void DisableExceptionHook();

    void    EnableUnwind(void *frame);
    void    DisableUnwind();
    void*   GetUnwind();

    void EnableTraceCall(void *fp);
    void DisableTraceCall();

    void DisableAll();

    virtual DEBUGGER_CONTROLLER_TYPE GetDCType( void ) 
        { return DEBUGGER_CONTROLLER_STATIC; }
    
    void Enqueue();
    void Dequeue();

    virtual void DoDeferedPatch(DebuggerJitInfo *pDji,
                                Thread *pThread,
                                void *fp);
    
  private:
    void AddPatch(DebuggerControllerPatch *patch);
    void RemovePatch(DebuggerControllerPatch *patch);

  protected:

	//
	// Target event handlers
	//

	virtual TP_RESULT TriggerPatch(DebuggerControllerPatch *patch,
                              Thread *thread, 
							  Module *module, 
							  mdMethodDef md, 
							  SIZE_T offset, 
							  BOOL managed,
							  TRIGGER_WHY tyWhy);
	virtual bool TriggerSingleStep(Thread *thread, const BYTE *ip);
	virtual bool TriggerPageProtection(Thread *thread, 
									   const BYTE *ip, const BYTE *address, 
									   bool read);
	virtual void TriggerUnwind(Thread *thread, MethodDesc *desc, 
							   SIZE_T offset, const BYTE *frame,
                               CorDebugStepReason unwindReason);
	virtual void TriggerTraceCall(Thread *thread, const BYTE *ip);
	virtual TP_RESULT TriggerExceptionHook(Thread *thread, 
									  EXCEPTION_RECORD *exception);

	virtual void SendEvent(Thread *thread);

    AppDomain           *m_pAppDomain;

  private:

	Thread				*m_thread;
	DebuggerController	*m_next;
	bool				m_singleStep;
	bool				m_exceptionHook;
	bool				m_traceCall;
	void 				*m_traceCallFP;
	void				*m_unwindFP;
	int					m_eventQueuedCount;
	bool				m_deleted;
};

/* ------------------------------------------------------------------------- *
 * DebuggerPatchSkip routines
 * ------------------------------------------------------------------------- */

//@class DebuggerPatchSkip|Dunno what this does
//@base public|DebuggerController
class DebuggerPatchSkip : public DebuggerController
{
    friend DebuggerController;

    DebuggerPatchSkip(Thread *thread, 
                      DebuggerControllerPatch *patch,
                      AppDomain *pAppDomain);
                      
    bool TriggerSingleStep(Thread *thread,
                           const BYTE *ip);
    
    TP_RESULT TriggerExceptionHook(Thread *thread, 
                              EXCEPTION_RECORD *exception);

    TP_RESULT TriggerPatch(DebuggerControllerPatch *patch,
                              Thread *thread, 
                              Module *module, 
                              mdMethodDef md, 
                              SIZE_T offset, 
                              BOOL managed,
                              TRIGGER_WHY tyWhy);
                              
    virtual DEBUGGER_CONTROLLER_TYPE GetDCType(void) 
        { return DEBUGGER_CONTROLLER_PATCH_SKIP; }

    void CopyInstructionBlock(BYTE *to, 
                              const BYTE* from, 
                              SIZE_T len);

public:
    const BYTE *GetBypassAddress() { return m_patchBypass; }

private:

    void DecodeInstruction(const BYTE *code);

    const BYTE             *m_address;
    BYTE                    m_patchBypass[MAX_INSTRUCTION_LENGTH];
    boolean                 m_isCall;
    boolean                 m_isAbsoluteBranch;
};

/* ------------------------------------------------------------------------- *
 * DebuggerBreakpoint routines
 * ------------------------------------------------------------------------- */

// @class DebuggerBreakpoint |
// DBp represents a user-placed breakpoint, and when Triggered, will
// always want to be activated, whereupon it will inform the right side of
// being hit.
// @base public|DebuggerController
class DebuggerBreakpoint : public DebuggerController
{
public:
    DebuggerBreakpoint(Module *module, 
                       mdMethodDef md, 
                       AppDomain *pAppDomain, 
                       SIZE_T m_offset, 
                       bool m_native,
                       DebuggerJitInfo *dji,
                       BOOL *pSucceed,
                       BOOL fDeferBinding);

    virtual DEBUGGER_CONTROLLER_TYPE GetDCType( void ) 
    	{ return DEBUGGER_CONTROLLER_BREAKPOINT; }

    virtual void DoDeferedPatch(DebuggerJitInfo *pDji,
                                Thread *pThread,
                                void *fp);

private:
    // The following are used in case the breakpoint is to be
    // defered until after the EnC takes place.
    Module              *m_module;
    mdMethodDef         m_md;
    SIZE_T              m_offset;
    bool                m_native; 
    DebuggerJitInfo     *m_dji;

	TP_RESULT TriggerPatch(DebuggerControllerPatch *patch,
                      Thread *thread, 
                      Module *module, 
					  mdMethodDef md, 
					  SIZE_T offset, 
					  BOOL managed,
					  TRIGGER_WHY tyWhy);
	void SendEvent(Thread *thread);
};

// * ------------------------------------------------------------------------ *
// * DebuggerStepper routines
// * ------------------------------------------------------------------------ *
// 

//  @class DebuggerStepper | This subclass of DebuggerController will
//  be instantiated to create a "Step" operation, meaning that execution
//  should continue until a range of IL code is exited.
//  @base public | DebuggerController
class DebuggerStepper : public DebuggerController
{
public:
	DebuggerStepper(Thread *thread,
                    CorDebugUnmappedStop rgfMappingStop,
                    CorDebugIntercept interceptStop,
                    AppDomain *appDomain);
	~DebuggerStepper();

	void Step(void *fp, bool in,
			  COR_DEBUG_STEP_RANGE *range, SIZE_T cRange, bool rangeIL);
	void StepOut(void *fp);

    virtual DEBUGGER_CONTROLLER_TYPE GetDCType( void ) 
        { return DEBUGGER_CONTROLLER_STEPPER; }

	bool IsSteppedMethod(MethodDesc * methDesc)
		{ return (m_djiVersion && m_djiVersion->m_fd == methDesc); }

    //@cmember MoveToCurrentVersion makes sure that the stepper is prepared to
    //  operate within the version of the code specified by djiNew.  
    //  Currently, this means to map the ranges into the ranges of the djiNew.
    //  Idempotent.
    void MoveToCurrentVersion( DebuggerJitInfo *djiNew);

    virtual void DoDeferedPatch(DebuggerJitInfo *pDji,
                                Thread *pThread,
                                void *fp);    

private:
    bool TrapStepInto(ControllerStackInfo *info, 
                      const BYTE *ip,
                      TraceDestination *pTD);
                      
    bool TrapStep(ControllerStackInfo *info, bool in);
    void TrapStepOut(ControllerStackInfo *info);
    
    bool IsAddrWithinMethod(DebuggerJitInfo *dji, MethodDesc *pMD, const BYTE *addr);
    
    //@cmember ShouldContinue returns false if the DebuggerStepper should stop
    // execution and inform the right side.  Returns true if the next
    // breakpointexecution should be set, and execution allowed to continue
    bool ShouldContinueStep( ControllerStackInfo *info, SIZE_T nativeOffset );

    //@cmember IsInRange returns true if the given IL offset is inside of
    // any of the COR_DEBUG_STEP_RANGE structures given by range.
	bool IsInRange(SIZE_T offset, COR_DEBUG_STEP_RANGE *range, SIZE_T rangeCount);

    //@cmember DetectHandleInterceptors will figure out if the current
    // frame is inside an interceptor, and if we're not interested in that
    // interceptor, it will set a breakpoint outside it so that we can
    // run to after the interceptor.
    bool DetectHandleInterceptors(ControllerStackInfo *info);

	TP_RESULT TriggerPatch(DebuggerControllerPatch *patch,
                      Thread *thread, 
                      Module *module, 
                      mdMethodDef md, 
					  SIZE_T offset, 
					  BOOL managed,
					  TRIGGER_WHY tyWhy);
	bool TriggerSingleStep(Thread *thread, const BYTE *ip);
	void TriggerUnwind(Thread *thread, MethodDesc *desc,
                      SIZE_T offset, const BYTE *frame,
                      CorDebugStepReason unwindReason);
	void TriggerTraceCall(Thread *thread, const BYTE *ip);
	void SendEvent(Thread *thread);    

    void ResetRange();    

private:
	bool					m_stepIn;
	CorDebugStepReason		m_reason; // @cmember Why did we stop?
	void *                  m_fpStepInto; // if we get a trace call
	                            //callback, we may end up completing
	                            // a step into.  If fp is less than th is
	                            // when we stop,
	                            // then we're actually in a STEP_CALL
    
    CorDebugIntercept       m_rgfInterceptStop; // @cmember  If we hit a
    // frame that's an interceptor (internal or otherwise), should we stop?
    
    CorDebugUnmappedStop    m_rgfMappingStop; // @cmember  If we hit a frame
    // that's at an interesting mapping point (prolog, epilog,etc), should 
    // we stop?
    
    DebuggerJitInfo *       m_djiVersion; //@cmember This can be NULL 
    // (esp. if we've attached)
	COR_DEBUG_STEP_RANGE *  m_range; // Ranges for active steppers are always 
    // in native offsets.
	SIZE_T					m_rangeCount;
	SIZE_T					m_realRangeCount;

	void *					m_fp;
    //@cmember m_fpException is 0 if we haven't stepped into an exception, 
    //  and is ignored.  If we get a TriggerUnwind while mid-step, we note
    //  the value of frame here, and use that to figure out if we should stop.
    void *                  m_fpException;
    MethodDesc *            m_fdException;

    // EnC Defered info:
    COR_DEBUG_STEP_RANGE *  m_rgStepRanges; // If we attempt to step
            // within a function that's been EnC'd, and we don't complete
            // the step before we switch over to the new version, then
            // we'll have to re-compute the step.
    SIZE_T                  m_cStepRanges;
    void *                  m_fpDefered;
    bool                    m_in;
    bool                    m_rangeIL;
    DebuggerJitInfo *       m_djiSource; // If we complete, we'll remove ourselves from
                                         // this queue.
};

/* ------------------------------------------------------------------------- *
 * DebuggerThreadStarter routines
 * ------------------------------------------------------------------------- */
// @class DebuggerThreadStarter | Once triggered, it sends the thread attach
// message to the right side (where the CreateThread managed callback
// gets called).  It then promptly disappears, as it's only purpose is to
// alert the right side that a new thread has begun execution.
// @base public|DebuggerController
class DebuggerThreadStarter : public DebuggerController
{
public:
	DebuggerThreadStarter(Thread *thread);

    virtual DEBUGGER_CONTROLLER_TYPE GetDCType( void ) 
    	{ return DEBUGGER_CONTROLLER_THREAD_STARTER; }

private:
	TP_RESULT TriggerPatch(DebuggerControllerPatch *patch,
                      Thread *thread, 
                      Module *module, 
					  mdMethodDef md, 
					  SIZE_T offset, 
					  BOOL managed,
					  TRIGGER_WHY tyWhy);
	void TriggerTraceCall(Thread *thread, const BYTE *ip);
	void SendEvent(Thread *thread);
};

/* ------------------------------------------------------------------------- *
 * DebuggerUserBreakpoint routines
 * ------------------------------------------------------------------------- */
class DebuggerUserBreakpoint : public DebuggerStepper
{
public:
	DebuggerUserBreakpoint(Thread *thread);

    virtual DEBUGGER_CONTROLLER_TYPE GetDCType( void ) 
    	{ return DEBUGGER_CONTROLLER_USER_BREAKPOINT; }

private:
	TP_RESULT TriggerPatch(DebuggerControllerPatch *patch,
                      Thread *thread, 
                      Module *module, 
					  mdMethodDef md, 
					  SIZE_T offset, 
					  BOOL managed,
					  TRIGGER_WHY tyWhy);
	void SendEvent(Thread *thread);
};

/* ------------------------------------------------------------------------- *
 * DebuggerFuncEvalComplete routines
 * ------------------------------------------------------------------------- */
class DebuggerFuncEvalComplete : public DebuggerController
{
public:
	DebuggerFuncEvalComplete(Thread *thread, 
	                         void *dest);

    virtual DEBUGGER_CONTROLLER_TYPE GetDCType( void ) 
    	{ return DEBUGGER_CONTROLLER_FUNC_EVAL_COMPLETE; }

private:
	TP_RESULT TriggerPatch(DebuggerControllerPatch *patch,
                      Thread *thread, 
                      Module *module, 
					  mdMethodDef md, 
					  SIZE_T offset, 
					  BOOL managed,
					  TRIGGER_WHY tyWhy);
	void SendEvent(Thread *thread);
};

/* ------------------------------------------------------------------------- *
 * DebuggerEnCBreakpoint routines
 * ------------------------------------------------------------------------- *
 *
 * @class DebuggerEnCBreakpoint | Implementation of EnC support uses this.
 * @base public|DebuggerController
 */
class DebuggerEnCBreakpoint : public DebuggerController
{
public:
    DebuggerEnCBreakpoint(Module *module, 
                          mdMethodDef md,
                          SIZE_T m_offset, 
                          bool m_native,
                          DebuggerJitInfo *jitInfo,
                          AppDomain *pAppDomain);

    virtual DEBUGGER_CONTROLLER_TYPE GetDCType( void ) 
        { return DEBUGGER_CONTROLLER_ENC; }

	BOOL		     m_fShortCircuit;
private:
    TP_RESULT TriggerPatch(DebuggerControllerPatch *patch,
                      Thread *thread, 
                      Module *module, 
    				  mdMethodDef md, 
    				  SIZE_T offset, 
    				  BOOL managed,
    				  TRIGGER_WHY tyWhy);

    DebuggerJitInfo *m_jitInfo;
};

/* ------------------------------------------------------------------------- *
 * DebuggerEnCPatchToSkip routines
 * ------------------------------------------------------------------------- *
 *
 * @class DebuggerEnCPatchToSkip | When an EnC update of a method happens,
 * we disappear into ResumeInUpdatedFunction, never to return.  Unfortunately,
 * we also don't keep the EFLAGs register from the thread filter context 
 * intact, we when we want to SS past the first instruction of the new
 * version of the method, we'll use this.
 * @base public|DebuggerController
 */
class DebuggerEnCPatchToSkip : public DebuggerController
{
public:
    DebuggerEnCPatchToSkip(const BYTE *address, 
                           void *fp, 
                           bool managed,
                           TraceType traceType, 
                           DebuggerJitInfo *dji,
                           Thread *pThread);

    virtual DEBUGGER_CONTROLLER_TYPE GetDCType( void ) 
        { return DEBUGGER_CONTROLLER_ENC_PATCH_TO_SKIP; }

private:
	virtual TP_RESULT TriggerExceptionHook(Thread *thread, 
									  EXCEPTION_RECORD *exception);

    DebuggerJitInfo *m_jitInfo;
};

/* ========================================================================= */

enum
{
    EVENTS_INIT_ALLOC = 5
};

class DebuggerControllerQueue
{
    DebuggerController **m_events;
    int m_eventsCount;
    int m_eventsAlloc;
    int m_newEventsAlloc;

public:
    DebuggerControllerQueue()
        : m_events(NULL), 
          m_eventsCount(0), 
          m_eventsAlloc(0), 
          m_newEventsAlloc(0)
    {  
    }


    ~DebuggerControllerQueue()
    {
        if (m_events != NULL)
            free(m_events);
    }
    
    BOOL dcqEnqueue(DebuggerController *dc, BOOL fSort)
    {
        LOG((LF_CORDB, LL_INFO100000,"DCQ::dcqE\n"));    

        _ASSERTE( dc != NULL );
    
        if (m_eventsCount == m_eventsAlloc)
        {
            if (m_events == NULL)
            	m_newEventsAlloc = EVENTS_INIT_ALLOC;
            else
            	m_newEventsAlloc = m_eventsAlloc<<1;

            DebuggerController **newEvents = (DebuggerController **)
                malloc(sizeof(*m_events) * m_newEventsAlloc);

            if (newEvents == NULL)
                return FALSE;

            if (m_events != NULL)
            	memcpy(newEvents, m_events, 
            		   sizeof(*m_events) * m_eventsAlloc);

            m_events = newEvents;
            m_eventsAlloc = m_newEventsAlloc;
        }

        dc->Enqueue();

        // Make sure to place high priority patches into
        // the event list first. This ensures, for
        // example, that thread startes fire before
        // breakpoints.
        if (fSort && (m_eventsCount > 0))
        {   
            int i = 0;
            for (i = 0; i < m_eventsCount; i++)
            {
                _ASSERTE(m_events[i] != NULL);
                
                if (m_events[i]->GetDCType() > dc->GetDCType())
                {
                    memmove(&m_events[i+1], &m_events[i], sizeof(DebuggerController*)* (m_eventsCount - i));
                    m_events[i] = dc;
                    break;
                }
            }

            if (i == m_eventsCount)
                m_events[m_eventsCount] = dc;

            m_eventsCount++;
        }
        else
        	m_events[m_eventsCount++] = dc;

        return TRUE;
    }

    int dcqGetCount(void)
    {
        return m_eventsCount;
    }

    DebuggerController *dcqGetElement(int iElement)
    {
        LOG((LF_CORDB, LL_INFO100000,"DCQ::dcqGE\n"));    
        
        DebuggerController *dcp = NULL;
    
        _ASSERTE(iElement < m_eventsCount);
        if (iElement < m_eventsCount)
        {
            dcp = m_events[iElement];
        }

        _ASSERTE(dcp != NULL);
        return dcp;
    }

    // Kinda wacked, but this actually releases stuff in FILO order, not
    // FIFO order.  If we do this in an extra loop, then the perf
    // is better than sliding everything down one each time.
    void dcqDequeue(int i = 0xFFffFFff)
    {
        if (i == 0xFFffFFff)
        {
            i = (m_eventsCount - 1);
        }
        
        LOG((LF_CORDB, LL_INFO100000,"DCQ::dcqD element index "
            "0x%x of 0x%x\n", i, m_eventsCount));
        
        _ASSERTE(i < m_eventsCount);
        
        m_events[i]->Dequeue();

		// Note that if we're taking the element off the end (m_eventsCount-1),
		// the following will no-op.
        memmove(&(m_events[i]), 
                &(m_events[i+1]), 
                sizeof(DebuggerController*)*(m_eventsCount-i-1));

        m_eventsCount--;
    }
}; 

#endif /*  CONTROLLER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\controller.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ****************************************************************************
// File: controller.cpp
//
// controller.cpp: Debugger execution control routines
//
// @doc
// ****************************************************************************
// Putting code & #includes, #defines, etc, before the stdafx.h will
// cause the code,etc, to be silently ignored
#include "stdafx.h"
#include "openum.h"
#include "..\inc\common.h"
#include "eeconfig.h"

#if 0

//
// Uncomment this to enable spew - LOG doesn't work very well from a 
// secondary DLL
//

#define LOG(X) dummylog X
void dummylog(int x, int y, char *s, ...)
{
    va_list args;

    va_start(args, s);
    vprintf(s, args);
    va_end(args);
}

#endif

#ifdef LOGGING
const char *GetTType( TraceType tt)
{
    switch( tt )
    {
        case TRACE_STUB:
            return "TRACE_STUB";
            break;
        case TRACE_UNMANAGED:
            return "TRACE_UNMANAGED";
            break;
        case TRACE_MANAGED:
            return "TRACE_MANAGED";
            break;
        case TRACE_FRAME_PUSH:
            return "TRACE_FRAME_PUSH";
            break;
        case TRACE_MGR_PUSH:
            return "TRACE_MGR_PUSH";
            break;
        case TRACE_OTHER:
            return "TRACE_OTHER";
            break;
    }
    return "TRACE_REALLY_WACKED";
}
#endif //LOGGING

// Define to zero to disable stepping to unmanaged code
#define WIN9X_NONWRITABLE_ADDRESS(addr) (((DWORD)(addr))>=0x80000000 && ((DWORD)(addr)) <=0xBFFFFFFF)

// -------------------------------------------------------------------------
//  DebuggerController routines
// -------------------------------------------------------------------------

bool                            DebuggerController::g_runningOnWin95;
DebuggerController             *DebuggerController::g_controllers = NULL;
DebuggerPatchTable             *DebuggerController::g_patches = NULL;
BOOL                            DebuggerController::g_patchTableValid = FALSE;
DebuggerControllerPage         *DebuggerController::g_protections = NULL;
CRITICAL_SECTION                DebuggerController::g_criticalSection;

static bool g_uninitializing = false;

void DebuggerPatchTable::SortPatchIntoPatchList(DebuggerControllerPatch **ppPatch)
{
#ifdef _DEBUG
    DebuggerControllerPatch *patchFirst 
        = (DebuggerControllerPatch *) Find(Hash((*ppPatch)), Key((*ppPatch)));
    _ASSERTE(patchFirst == (*ppPatch));
    _ASSERTE((*ppPatch)->controller->GetDCType() != DEBUGGER_CONTROLLER_STATIC);
#endif //_DEBUG

    DebuggerControllerPatch *patchNext = GetNextPatch((*ppPatch));

    //List contains one, (sorted) element
    if (patchNext == NULL)
    {
        LOG((LF_CORDB, LL_INFO10000,
             "DPT::SPIPL: Patch 0x%x is a sorted singleton\n", (*ppPatch)));
        return;
    }

    // If we decide to reorder the list, we'll need to keep the element
    // indexed by the hash function as the (sorted)first item.  Everything else
    // chains off this element, can can thus stay put.
    // Thus, either the element we just added is already sorted, or else we'll
    // have to move it elsewhere in the list, meaning that we'll have to swap
    // the second item & the new item, so that the index points to the proper
    // first item in the list.
    DebuggerControllerPatch *patchSecond 
        = (DebuggerControllerPatch *) GetNextPatch((*ppPatch));
    _ASSERTE( patchSecond == GetNextPatch(patchFirst));

    //use Cur ptr for case where patch gets appended to list
    DebuggerControllerPatch *patchCur = patchNext; 
    
    while (patchNext != NULL &&
            ((*ppPatch)->controller->GetDCType() > 
             patchNext->controller->GetDCType()) )
    {
        patchCur = patchNext;
        patchNext = GetNextPatch(patchNext);
    }

    if (patchNext == GetNextPatch((*ppPatch)))
    {
        LOG((LF_CORDB, LL_INFO10000,
             "DPT::SPIPL: Patch 0x%x is already sorted\n", (*ppPatch)));
        return; //already sorted
    }
    
    LOG((LF_CORDB, LL_INFO10000,
         "DPT::SPIPL: Patch 0x%x will be moved \n", (*ppPatch)));

    //remove it from the list
    SpliceOutOfList((*ppPatch)); 

    // the kinda cool thing is: since we put it originally at the front of the list, 
    // and it's not in order, then it must be behind another element of this list,
    // so we don't have to write any 'SpliceInFrontOf' code.
    
    _ASSERTE(patchCur != NULL);
    SpliceInBackOf((*ppPatch), patchCur);
    
    LOG((LF_CORDB, LL_INFO10000,
         "DPT::SPIPL: Patch 0x%x is now sorted\n", (*ppPatch)));
}

// This can leave the list empty, so don't do this unless you put
// the patch back somewhere else.
void DebuggerPatchTable::SpliceOutOfList(DebuggerControllerPatch *patch)
{
    // We need to get iHash, the index of the ptr within
    // m_piBuckets, ie it's entry in the hashtable.
    USHORT iHash = Hash(patch) % m_iBuckets;
    USHORT iElement = m_piBuckets[iHash];
    DebuggerControllerPatch *patchFirst 
        = (DebuggerControllerPatch *) EntryPtr(iElement);

    // Fix up pointers to chain
    if (patchFirst == patch)
    {
        // The first patch shouldn't have anything behind it.
        _ASSERTE(patch->entry.iPrev == DPT_INVALID_SLOT);

        if (patch->entry.iNext != DPT_INVALID_SLOT)
        {
            m_piBuckets[iHash] = patch->entry.iNext;
        }
        else
        {
            m_piBuckets[iHash] = DPT_INVALID_SLOT;
        }
    }

    if (patch->entry.iNext != DPT_INVALID_SLOT)
    {
        EntryPtr(patch->entry.iNext)->iPrev = patch->entry.iPrev;
    }

    if (patch->entry.iPrev != DPT_INVALID_SLOT)
    {
        EntryPtr(patch->entry.iNext)->iNext = patch->entry.iNext;
    }

    patch->entry.iNext = DPT_INVALID_SLOT;
    patch->entry.iPrev = DPT_INVALID_SLOT;
}

// The cutter cuts in line ahead of the cuttee.  See also SpliceInBackOf.
// Anybody with a better pair of names should feel free to rename these.
//void DebuggerPatchTable::SpliceInFrontOf(DebuggerControllerPatch *patchCutter,
//                                         DebuggerControllerPatch *patchCuttee)
//{
//  // We assume that the Cutter has previously been removed from the list by
//  // SpliceOutOfList, above.
//    _ASSERTE(patchCutter->entry.iPrev == DPT_INVALID_SLOT);
//  _ASSERTE(patchCutter->entry.iNext == DPT_INVALID_SLOT);
//
//    USHORT iCutter = ItemIndex((HASHENTRY*)patchCutter);
//    USHORT iCuttee = ItemIndex((HASHENTRY*)patchCuttee);
//
//  USHORT iHash = Hash(patchCuttee) % m_iBuckets;
//
//    DebuggerControllerPatch *patchFirst 
//        = (DebuggerControllerPatch *) EntryPtr(iHash);
//
//    // Fix up pointers to chain
//    if (patchFirst == patchCuttee)
//    {
//        m_piBuckets[iHash] = iCutter;
//        _ASSERTE(patchCuttee->entry.iPrev == DPT_INVALID_SLOT);
//    }
//
//    patchCutter->entry.iPrev = patchCuttee->entry.iPrev;
//
//    // Remember to only set the cuttee's field to the cutter's if
//    // the cutter's fields are valid
//    if (patchCuttee->entry.iPrev != DPT_INVALID_SLOT)
//    {
//      _ASSERTE(patchCuttee != patchFirst);
//        EntryPtr(patchCuttee->entry.iPrev)->iNext = iCutter;
//    }
//    
//    patchCutter->entry.iNext = iCuttee;
//    patchCuttee->entry.iPrev = iCutter;
//}
//
void DebuggerPatchTable::SpliceInBackOf(DebuggerControllerPatch *patchAppend,
                                        DebuggerControllerPatch *patchEnd)
{
    USHORT iAppend = ItemIndex((HASHENTRY*)patchAppend);
    USHORT iEnd = ItemIndex((HASHENTRY*)patchEnd);

    patchAppend->entry.iPrev = iEnd;
    patchAppend->entry.iNext = patchEnd->entry.iNext;

    if (patchAppend->entry.iNext != DPT_INVALID_SLOT)
        EntryPtr(patchAppend->entry.iNext)->iPrev = iAppend;
    
    patchEnd->entry.iNext = iAppend;
}

//@mfunc void |DebuggerController|Initialize |Sets up the static 
// variables for the static <t DebuggerController class>.
// How: Sets g_runningOnWin95, initializes the critical section
// @access public
HRESULT DebuggerController::Initialize()
{
    if (g_patches == NULL)
    {
        InitializeCriticalSection(&g_criticalSection);

        g_runningOnWin95 = RunningOnWin95() ? true : false;

        g_patches = new (interopsafe) DebuggerPatchTable();
        _ASSERTE(g_patches != NULL);

        if (g_patches == NULL)
            return (E_OUTOFMEMORY);

        HRESULT hr = g_patches->Init();

        if (FAILED(hr))
        {
            DeleteInteropSafe(g_patches);
            return (hr);
        }

        g_patchTableValid = TRUE;
        TRACE_ALLOC(g_patches);
    }
    _ASSERTE(g_patches != NULL);

    return (S_OK);
}

//@mfunc void |DebuggerController|Uninitialize| Does all the work
// involved in shutting down the static DebuggerController class.
// Deletes the patch table & all associated controllers that are
// still hanging around.
// Sets g_uninitializing to true (so other parts know we're
// shutting down), invoke Delete() on any remaining DebuggerController
// instances we've got, free the DebuggerPatchTable, and delete the
// critical section
// @access public
void DebuggerController::Uninitialize()
{
    // Remember that we're uninitializing so that we don't try to
    // touch parts of the Runtime that have gone away.
    g_uninitializing = true;
    g_patchTableValid = FALSE;
    
#if _DEBUG
    //
    // Suppress leaked controllers. (e.g. steppers which haven't completed)
    //

    while (g_controllers != NULL)
    {
        // Force the queued event count down to 0 here. We do this so
        // we're sure that the controllers will really be deleted by
        // the Delete() call. The only time this would happen would be
        // if the debuggee process is being killed abnormally, which
        // can occur when its stopped and has an event dispatched,
        // with the queued event count above zero. If you don't do
        // this, you get an infinite loop here.
        LOG((LF_CORDB, LL_INFO10000, "DC: 0x%x m_eventQueuedCount to 0 - DC::Unint !\n", g_controllers));
        g_controllers->m_eventQueuedCount = 0;
        g_controllers->Delete();
    }
#endif

    if (g_patches != NULL)
    {
        DeleteCriticalSection(&g_criticalSection);

        TRACE_FREE(g_patches);
        DeleteInteropSafe(g_patches);
    }
}

DebuggerController::DebuggerController(Thread *thread, AppDomain *pAppDomain)
  : m_thread(thread), m_singleStep(false), m_exceptionHook(false),
    m_traceCall(0), m_traceCallFP(FRAME_TOP), m_unwindFP(NULL), 
    m_eventQueuedCount(0), m_deleted(false), m_pAppDomain(pAppDomain)
{
    LOG((LF_CORDB, LL_INFO10000, "DC: 0x%x m_eventQueuedCount to 0 - DC::DC\n", this));
    Lock();
    {
        m_next = g_controllers;
        g_controllers = this;
    }
    Unlock();
}

void DebuggerController::DeleteAllControllers(AppDomain *pAppDomain)
{
    Lock();
    DebuggerController *dc = g_controllers;
    DebuggerController *dcNext = NULL;
    while (dc != NULL)
    {
        dcNext = dc->m_next;
        if (dc->m_pAppDomain == pAppDomain ||
            dc->m_pAppDomain == NULL)
        {
            dc->Delete();
        }            
        dc = dcNext;
    }
    Unlock();
}

DebuggerController::~DebuggerController()
{
    Lock();

    _ASSERTE(m_eventQueuedCount == 0);

    DisableAll();

    //
    // Remove controller from list
    //

    DebuggerController **c;

    c = &g_controllers;
    while (*c != this)
        c = &(*c)->m_next;

    *c = m_next;

    Unlock();
}

// @mfunc void | DebuggerController | Delete |
// What: Marks an instance as deletable.  If it's ref count
// (see Enqueue, Dequeue) is currently zero, it actually gets deleted
// How: Set m_deleted to true.  If m_eventQueuedCount==0, delete this
void DebuggerController::Delete()
{
    if (m_eventQueuedCount == 0)
    {
        LOG((LF_CORDB, LL_INFO100000, "DC::Delete: actual delete of this:0x%x!\n", this));
        TRACE_FREE(this);
        DeleteInteropSafe(this);
    }
    else
    {
        LOG((LF_CORDB, LL_INFO100000, "DC::Delete: marked for "
            "future delete of this:0x%x!\n", this));
        LOG((LF_CORDB, LL_INFO10000, "DC:0x%x m_eventQueuedCount at 0x%x\n", 
            this, m_eventQueuedCount));
        m_deleted = true;
    }
}

// @mfunc void | DebuggerController | DisableAll | DisableAll removes
// all control from the controller.  This includes all patches & page
// protection.  This will invoke Disable* for unwind,singlestep,
// exceptionHook, and tracecall.  It will also go through the patch table &
// attempt to remove any and all patches that belong to this controller.
// If the patch is currently triggering, then a Dispatch* method expects the
// patch to be there after we return, so we instead simply mark the patch
// itself as deleted.
void DebuggerController::DisableAll()
{
    LOG((LF_CORDB,LL_INFO1000, "DC::DisableAll\n"));
    _ASSERTE(g_patches != NULL);

    Lock();
    {
        //
        // Remove controller's patches from list.
        //

        HASHFIND f;
        for (DebuggerControllerPatch *patch = g_patches->GetFirstPatch(&f);
             patch != NULL;
             patch = g_patches->GetNextPatch(&f))
        {
            if (patch->controller == this)
            {
                if (patch->triggering)
                    patch->deleted = true;
                else
                {
                    DeactivatePatch(patch);
                    g_patches->RemovePatch(patch);
                }
            }
        }

        if (m_singleStep)
            DisableSingleStep();
        if (m_exceptionHook)
            DisableExceptionHook();
        if (m_unwindFP != NULL)
            DisableUnwind();
        if (m_traceCall)
            DisableTraceCall();
    }
    Unlock();
}

//@mfunc void | DebuggerController | Enqueue |  What: Does
// reference counting so we don't toast a
// DebuggerController while it's in a Dispatch queue.
// Why: In DispatchPatchOrSingleStep, we can't hold locks when going
// into PreEmptiveGC mode b/c we'll create a deadlock.
// So we have to UnLock() prior to
// EnablePreEmptiveGC().  But somebody else can show up and delete the
// DebuggerControllers since we no longer have the lock.  So we have to
// do this reference counting thing to make sure that the controllers
// don't get toasted as we're trying to invoke SendEvent on them.  We have to
// reaquire the lock before invoking Dequeue because Dequeue may
// result in the controller being deleted, which would change the global
// controller list.
// How: InterlockIncrement( m_eventQueuedCount )
void DebuggerController::Enqueue()
{
    m_eventQueuedCount++;
    LOG((LF_CORDB, LL_INFO10000, "DC::Enq DC:0x%x m_eventQueuedCount at 0x%x\n", 
        this, m_eventQueuedCount));
}

//@mfunc void | DebuggerController | Dequeue | What: Does
// reference counting so we don't toast a
// DebuggerController while it's in a Dispatch queue.
// How: InterlockDecrement( m_eventQueuedCount ), delete this if
// m_eventQueuedCount == 0 AND m_deleted has been set to true
void DebuggerController::Dequeue()
{
    LOG((LF_CORDB, LL_INFO10000, "DC::Deq DC:0x%x m_eventQueuedCount at 0x%x\n", 
        this, m_eventQueuedCount));
    if (--m_eventQueuedCount == 0)
    {
        if (m_deleted)
        {
            TRACE_FREE(this);
            DeleteInteropSafe(this);
        }
    }
}


// @mfunc bool|DebuggerController|BindPatch|If the method has 
// been JITted and isn't hashed by address already, then hash 
// it into the hashtable by address and not DebuggerFunctionKey.
// If the patch->address field is nonzero, we're done.
// Otherwise ask g_pEEInterface to LookupMethodDescFromToken, then
// GetFunctionAddress of the method, if the method is in IL,
// MapILOffsetToNative.  If everything else went Ok, we can now invoke
// g_patches->BindPatch.
// Returns: false if we know that we can't bind the patch immediately.
//      true if we either can bind the patch right now, or can't right now,
//      but might be able to in the future (eg, the method hasn't been JITted)

// Have following outcomes:
// 1) Succeeded in binding the patch to a raw address. patch->address is set.
// (Note we still must apply the patch to put the int 3 in.)
// returns true, *pFail = false
// 
// 2) Fails to bind, but a future attempt may succeed. Obvious ex, for an IL-only 
// patch on an unjitted method.
// returns false, *pFail = false
//
// 3) Fails to bind because something's wrong. Ex: bad IL offset, no DJI to do a
// mapping with. Future calls will fail too.
// returns false, *pFail = true
bool DebuggerController::BindPatch(DebuggerControllerPatch *patch, 
                                   const BYTE *code,
                                   BOOL *pFailedBecauseOfInvalidOffset)
{
    BOOL fStrict = patch->controller->GetDCType() == DEBUGGER_CONTROLLER_BREAKPOINT;
    if (pFailedBecauseOfInvalidOffset)
        *pFailedBecauseOfInvalidOffset = FALSE;
    // 
    // Translate patch to address, if it hasn't been already.
    //

    if (patch->address == NULL)
    {
        MethodDesc *fd = g_pEEInterface->
          LookupMethodDescFromToken(patch->key.module, 
                                      patch->key.md);

        if (fd == NULL)
        {
            // 
            // The function desc has not been created yet, thus
            // the code cannot be available to patch yet.
            //

            return false;
        }

        if (code == NULL)
        {
            code = g_pEEInterface->GetFunctionAddress(fd);
        }
        
        if (code != NULL)
        {
            _ASSERTE(!g_pEEInterface->IsStub(code));

            // If we've jitted, map to a native offset.
            DebuggerJitInfo *info = g_pDebugger->GetJitInfo(fd, code);

            if (info != NULL)
            {
                // There is a strange case with prejitted code and unjitted trace patches. We can enter this function
                // with no DebuggerJitInfo created, then have the call just above this actually create the
                // DebuggerJitInfo, which causes JitComplete to be called, which causes all patches to be bound! If this
                // happens, then we don't need to continue here (its already been done recursivley) and we don't need to
                // re-active the patch, so we return false from right here. We can check this by seeing if we suddently
                // have the address in the patch set.
                if (patch->address != NULL)
                {
                    LOG((LF_CORDB,LL_INFO10000, "DC::BindPa: patch bound recursivley by GetJitInfo, bailing...\n"));
                    return false;
                }
                
                LOG((LF_CORDB,LL_INFO10000, "DC::BindPa: For code 0x%x, got DJI "
                    "0x%x, from 0x%x size: 0x%x\n",code, info, info->m_addrOfCode, 
                    info->m_sizeOfCode));
                
                if (info->m_codePitched)
                {
                    LOG((LF_CORDB,LL_INFO1000,"DC::BindPatch in pitched code!\n\n\n"));
                    return false;
                }   
            }
#ifdef LOGGING
            else
            {
                LOG((LF_CORDB,LL_INFO10000, "DC::BindPa: For code 0x%x, "
                    "didn't find a DJI\n",code));                
            }
#endif //LOGGING

            if (!patch->native)
            {
                if(info == NULL)    // This had better be true, 
                {
                    // If it's already jitted as non-debuggable, we don't have a mapping
                    // and we won't ever get one.                     
                    _ASSERTE(code != NULL); // jitted b/c we have address of code.
                    _ASSERTE(info == NULL); // but it's non-debuggable since we have no DJI

                    // So we never bound this, and it won't ever get bound,
                    // so we need to do a real failure.
                    if (pFailedBecauseOfInvalidOffset)
                        *pFailedBecauseOfInvalidOffset = TRUE;
                        
                    return false;    // otherwise we can't do the mapping
                }

                BOOL fExact;
                SIZE_T offsetT = info->MapILOffsetToNative(patch->offset, &fExact);

                // We special case offset 0, which is when a breakpoint is set
                // at the beginning of a method that hasn't been jitted yet.  In
                // that case it's possible that offset 0 has been optimized out,
                // but we still want to set the closest breakpoint to that.

                if (!fExact && fStrict && (patch->offset != 0))
                {
                    if (pFailedBecauseOfInvalidOffset)
                        *pFailedBecauseOfInvalidOffset = TRUE;

                    return false; // Don't want to bind to something random
                }

                patch->offset = offsetT;
                patch->native = true;
            }

            _ASSERTE(g_patches != NULL);
            g_patches->BindPatch(patch, code + patch->offset);

            LOG((LF_CORDB, LL_INFO10000, 
                 "DC::BP:Binding patch at 0x%x(off:%x) in %s::%s\n",
                 code + patch->offset, patch->offset,
                 fd->m_pszDebugClassName,fd->m_pszDebugMethodName));
        }
        else 
        {
            //
            // Code is not available yet to patch.  The prestub should
            // notify us when it is executed.
            //

            LOG((LF_CORDB, LL_INFO10000, 
                 "DC::BP:Patch at 0x%x not bindable yet.\n", patch->offset));

            return false;
        }
    }

    return true;
}

// @mfunc bool |DebuggerController|CopyOpcodeFromAddrToPatch | CopyOpcodeFromAddrToPatch
// applies 
// the patch described to the code, and
// remembers the replaced opcode.  Note that the same address
// cannot be patched twice at the same time.
// Grabs the opcode & stores in patch, then sets a break
// instruction for either native or IL.
// VirtualProtect & some macros.  Returns false if anything
// went bad.
// @access private
// @parm DebuggerControllerPatch *|patch| The patch, indicates where
//      to set the INT3 instruction
// @rdesc Returns true if the user break instruction was successfully
//      placed into the code-stream, false otherwise
bool DebuggerController::ApplyPatch(DebuggerControllerPatch *patch)
{
    _ASSERTE(patch->address != NULL);

    //
    // Apply the patch.
    //
    _ASSERTE(!(g_pConfig->GetGCStressLevel() & EEConfig::GCSTRESS_INSTR) && "Debugger does not work with GCSTRESS 4");

    if (patch->native)
    {
        
        if (patch->fSaveOpcode)
        {   
            // We only used SaveOpcode for when we've moved code, so
            // the patch should already be there.
            patch->opcode = patch->opcodeSaved;
            _ASSERTE( patch->opcode == 0 || patch->address != NULL);
#ifdef _X86_
            _ASSERTE( *(BYTE *)patch->address == 0xCC );
#endif //_X86_
            return true;
        }
        
        DWORD oldProt;

        if (!VirtualProtect((void *) patch->address, 
                            CORDbg_BREAK_INSTRUCTION_SIZE, 
                            PAGE_EXECUTE_READWRITE, &oldProt))
        {
            _ASSERTE(!"VirtualProtect of code page failed");
            return false;
        }

        patch->opcode = 
            (unsigned int) CORDbgGetInstruction(patch->address);

        _ASSERTE( patch->opcode == 0 || patch->address != NULL);

        CORDbgInsertBreakpoint(patch->address);

        if (!VirtualProtect((void *) patch->address, 
                            CORDbg_BREAK_INSTRUCTION_SIZE, oldProt, &oldProt))
        {
            _ASSERTE(!"VirtualProtect of code page failed");
            return false;
        }
    }
    else
    {
        DWORD oldProt;

        // 
        // !!! IL patch logic assumes reference insruction encoding
        //

        if (!VirtualProtect((void *) patch->address, 2, 
                            PAGE_EXECUTE_READWRITE, &oldProt))
        {
            _ASSERTE(!"VirtualProtect of code page failed");
            return false;
        }

        patch->opcode = 
          (unsigned int) *(unsigned short*)(patch->address+1);

        _ASSERTE(patch->opcode != CEE_BREAK);
        _ASSERTE( patch->opcode == 0 || patch->address != NULL);

        *(unsigned short *) (patch->address+1) = CEE_BREAK;

        if (!VirtualProtect((void *) patch->address, 2, oldProt, &oldProt))
        {
            _ASSERTE(!"VirtualProtect of code page failed");
            return false;
        }
    }

    return true;
}

// @mfunc bool|DebuggerController|CopyOpcodeFromPatchToAddr|
// UnapplyPatch removes the patch described by the patch.  
// (CopyOpcodeFromAddrToPatch, in reverse.)
// Looks a lot like CopyOpcodeFromAddrToPatch, except that we use a macro to
// copy the instruction back to the code-stream & immediately set the
// opcode field to 0 so ReadMemory,WriteMemory will work right.
// NO LOCKING
// @access private
// @parm DebuggerControllerPatch *|patch|Patch to remove
// @rdesc true if the patch was unapplied, false otherwise
bool DebuggerController::UnapplyPatch(DebuggerControllerPatch *patch)
{
    _ASSERTE(patch->address != NULL);

    LOG((LF_CORDB,LL_INFO1000, "DC::UP unapply patch at addr 0x%x\n", 
        patch->address));

    if (patch->native)
    {
        if (patch->fSaveOpcode)
        {
            // We're doing this for MoveCode, and we don't want to 
            // overwrite something if we don't get moved far enough.
            patch->opcodeSaved = patch->opcode;
            
            //VERY IMPORTANT to zero out opcode, else we might mistake
            //this patch for an active on on ReadMem/WriteMem (see
            //header file comment)
            patch->opcode = 0;
            _ASSERTE( patch->opcode == 0 || patch->address != NULL);
            return true;
        }
        
        DWORD oldProt;

        if (!VirtualProtect((void *) patch->address, 
                            CORDbg_BREAK_INSTRUCTION_SIZE, 
                            PAGE_EXECUTE_READWRITE, &oldProt))
        {
            //
            // We may be trying to remove a patch from memory
            // which has been unmapped. We can ignore the  
            // error in this case.
            //
            if (!g_uninitializing)
                _ASSERTE(!"VirtualProtect of code page failed");
            return false;
        }

        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
        CORDbgSetInstruction(patch->address, patch->opcode);
        
        //VERY IMPORTANT to zero out opcode, else we might mistake
        //this patch for an active on on ReadMem/WriteMem (see
        //header file comment)
        patch->opcode = 0;
        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
        
        if (!VirtualProtect((void *) patch->address, 
                            CORDbg_BREAK_INSTRUCTION_SIZE, oldProt, &oldProt))
        {
            _ASSERTE(!"VirtualProtect of code page failed");
            return false;
        }
    }
    else
    {
        DWORD oldProt;

        if (!VirtualProtect((void *) patch->address, 2, 
                            PAGE_EXECUTE_READWRITE, &oldProt))
        {
            //
            // We may be trying to remove a patch from memory
            // which has been unmapped. We can ignore the  
            // error in this case.
            //
            if (!g_uninitializing)
                _ASSERTE(!"VirtualProtect of code page failed");
            return false;
        }

        // 
        // !!! IL patch logic assumes reference encoding
        //

        _ASSERTE(*(unsigned short*)(patch->address+1) == CEE_BREAK);

        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
        *(unsigned short *) (patch->address+1) 
          = (unsigned short) patch->opcode;
        //VERY IMPORTANT to zero out opcode, else we might mistake
        //this patch for an active on on ReadMem/WriteMem (see
        //header file comment
        patch->opcode = 0;
        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
        
        if (!VirtualProtect((void *) patch->address, 2, oldProt, &oldProt))
        {
            _ASSERTE(!"VirtualProtect of code page failed");
            return false;
        }
    }

    return true;
}

// @mfunc void|DebuggerController|UnapplyPatchAt|
// NO LOCKING
// UnapplyPatchAt removes the patch from a copy of the patched code.
// Like UnapplyPatch, except that we don't bother checking
// memory permissions, but instead replace the breakpoint instruction
// with the opcode at an arbitrary memory address.
// @access private
void DebuggerController::UnapplyPatchAt(DebuggerControllerPatch *patch, 
                                        BYTE *address)
{
    _ASSERTE(patch->address != NULL);
        
    if (patch->native)
    {
        CORDbgSetInstruction(address, patch->opcode);
        //note that we don't have to zero out opcode field
        //since we're unapplying at something other than
        //the original spot. We assert this is true:
        _ASSERTE( patch->address != address );
        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
    }
    else
    {
        // 
        // !!! IL patch logic assumes reference encoding
        //

        _ASSERTE(*(unsigned short*)(address+1) == CEE_BREAK);

        *(unsigned short *) (address+1) 
          = (unsigned short) patch->opcode;
        _ASSERTE( patch->address != address );        
        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
    }
}

// @mfunc bool|DebuggerController|IsPatched|Is there a patch at addr?
// How: if fNative && the instruction at addr is the break
// instruction for this platform.
// @access private
// @xref DebuggerController::IsAddressPatched
bool DebuggerController::IsPatched(const BYTE *address, BOOL native)
{
#if _X86_
    if (native)
        return CORDbgGetInstruction(address) == 0xCC;
    else
        return false;
#else
    // !!! add logic for other processors
    return false;
#endif
}

// @mfunc DWORD|DebuggerController|GetPatchedOpcode|Gets the opcode 
// at addr, 'looking underneath' any patches if needed.
// GetPatchedInstruction is a function for the EE to call to "see through"
// a patch to the opcodes which was patched.
// How: Lock() grab opcode directly unless there's a patch, in
// which case grab it out of the patch table.
// @access public
// @parm const BYTE *|address|The address that we want to 'see through'
// @rdesc DWORD value, that is the opcode that should really be there,
//      if we hadn't placed a patch there.  If we haven't placed a patch
//      there, then we'll see the actual opcode at that address.
DWORD DebuggerController::GetPatchedOpcode(const BYTE *address)
{
    _ASSERTE(g_patches != NULL);
    DWORD opcode;

    Lock();

    //
    // Look for a patch at the address
    //

    DebuggerControllerPatch *patch = g_patches->GetPatch(address);

    if (patch != NULL)
    {
        opcode = patch->opcode;
        _ASSERTE( patch->opcode == 0 || patch->address != NULL);
    }
    else
    {
        //
        // Patch was not found - it either is not our patch, or it has
        // just been removed. In either case, just return the current
        // opcode.
        //

        if (g_pEEInterface->IsManagedNativeCode(address))
        {
            opcode = CORDbgGetInstruction(address);
        }
        else
        {
            // 
            // !!! IL patch logic assumes reference encoding
            //

            opcode = *(unsigned short*)(address+1);
        }
    }

    Unlock();

    return opcode;
}

// @mfunc void|DebuggerController|UnapplyPatchInCodeCopy|Takes 
// all the break opcodes out of the given range of
// the given method.
// How: Iterates through patch table, and for each patch, makes
// sure that all the fields in the patch match up with the args, then
// does an UnapplyPatchAt.
// @access public
void DebuggerController::UnapplyPatchesInCodeCopy(Module *module, 
                                                  mdMethodDef md,
                                                  DebuggerJitInfo *dji,
                                                  MethodDesc *fd,
                                                  bool native,
                                                  BYTE *code, 
                                                  SIZE_T startOffset, 
                                                  SIZE_T endOffset)
{
    const BYTE *codeStart;
    SIZE_T codeSize;

    // We never patch IL code, so can't unapply
    if (!native)
        return;

    // If this is null then there have been no patches ever created
    // and so none need to be removed.
    if (g_patches == NULL)
        return;
    
    if (dji)
    {
        _ASSERTE(dji->m_fd->GetMemberDef() == md);
        _ASSERTE(dji->m_fd->GetModule() == module);

        codeStart = (const BYTE*)dji->m_addrOfCode;
        codeSize = dji->m_sizeOfCode;
    }
    else
    {
        _ASSERTE(fd != NULL);
        
        codeStart = g_pEEInterface->GetFunctionAddress(fd);
        codeSize = g_pEEInterface->GetFunctionSize(fd);
    }
    
    _ASSERTE(code != NULL);
    _ASSERTE(startOffset <= endOffset);
    Lock();

    //
    // We have to iterate through all of the patches - bleah.
    //
    
    HASHFIND info;
    for (DebuggerControllerPatch *patch = g_patches->GetFirstPatch(&info);
         patch != NULL;
         patch = g_patches->GetNextPatch(&info))
    {
        if (patch->key.module == module
            && patch->key.md == md
            && patch->address != NULL
            // these next two lines make sure that we'll only unapply patches
            // in the same EnC version as the code we want unpatched.
            && patch->address >= codeStart
            && patch->address < codeStart + codeSize
            && (patch->native != 0) == native
            && patch->offset >= startOffset 
            && patch->offset < endOffset)
        {
            //
            // Make sure we unapply each pach only once - only unapply for the 
            // first patch at each address.
            //

            if (g_patches->GetPatch(patch->address) == patch)
                UnapplyPatchAt(patch, code + (patch->offset - startOffset));
        }
    }

    Unlock();
}

// @mfunc void|DebuggerController|UnapplyPatchesInMemoryCopy|Same as 
// UnapplyPathcesInCodeCopy, except that since
// we don't know that the memory is code, we don't bother try to match up
// Module*,mdMethodDef,etc.
// Iterate through patch table, and if the patch->address is
// within (start,end], then UnapplyPatchAt().  Very useful for making sure
// that any buffers we send back to the right side don't contain any
// breakpoints that we've put there (and should be invisible to the user)
// @access public
// @parm BYTE *|memory|Start address of the memory blob in which to unapply 
//      patches.  It's assumed that at this address is end-start bytes
//      of writable memory
// @parm CORDB_ADDRESS|start|Start of the range of addresses.
// @parm CORDB_ADDRESS|end|End of the range of addresses.
void DebuggerController::UnapplyPatchesInMemoryCopy(BYTE *memory, 
                                                    CORDB_ADDRESS start, 
                                                    CORDB_ADDRESS end)
{
    // If no patches exist, none to remove
    if (g_patches == NULL)
        return;

    Lock();

    // We have to iterate through all of the patches - bleah.
    HASHFIND info;
    for (DebuggerControllerPatch *patch = g_patches->GetFirstPatch(&info);
         patch != NULL;
         patch = g_patches->GetNextPatch(&info))
    {
        if (   patch->address != NULL
            && PTR_TO_CORDB_ADDRESS(patch->address) >= start 
            && PTR_TO_CORDB_ADDRESS(patch->address)  < end  )
        {
            // Make sure we unapply each pach only once - only unapply for the 
            // first patch at each address.
            if (g_patches->GetPatch(patch->address) == patch)
            {
                CORDB_ADDRESS addrToUnpatch = PTR_TO_CORDB_ADDRESS(memory) + (PTR_TO_CORDB_ADDRESS(patch->address) - start);
                UnapplyPatchAt( patch, (BYTE *)addrToUnpatch );
            }
        }
    }

    Unlock();
}


// @mfunc bool|DebuggerController|ReapplyPatchesInMemory| For the 
// given range or memory, invokes "ApplyPatch"
// per address that should be patched.
// How:Lock(); Iterate through all patches in the patch table, and
// for those that have addresses within the (start,end] range, if no
// patch has been applied yet, to ApplyPatch on it. Unlock();
// @access public
// @parm CORDB_ADDRESS |start|Beginning address of the range of memory
//      in which to reapply patches.
// @parm CORDB_ADDRESS |end| End address of the range of memory in which
//      to reapply patches.
// @rdesc Returns true if we were able to reapply all the patches in the
//      given range, false otherwise.  If we return false, some patches
//      may have been reapplied, while others weren't.
bool DebuggerController::ReapplyPatchesInMemory(CORDB_ADDRESS start, CORDB_ADDRESS end )
{
    if (g_patches == NULL)
        return true;

    Lock();

    // We have to iterate through all of the patches - bleah.
    HASHFIND info;
    for (DebuggerControllerPatch *patch = g_patches->GetFirstPatch(&info);
         patch != NULL;
         patch = g_patches->GetNextPatch(&info))
    {
        if (   patch->address != NULL
            && PTR_TO_CORDB_ADDRESS(patch->address) >= start 
            && PTR_TO_CORDB_ADDRESS(patch->address)  < end  )
        {
            // Make sure we apply each pach only once - only apply for the 
            // first patch at each address.
            if (g_patches->GetPatch(patch->address) == patch)
            {
                if (!DebuggerController::ApplyPatch( patch ) )
                {
                    Unlock(); // !!! IMPORTANT  !!! //
                    return false;
                }
            }
        }
    }

    Unlock();
    return true;
}

// @mfunc void|DebuggerController|ActivatePatch|Place a breakpoint 
// so that threads will trip over this patch.
// If there any patches at the address already, then copy
// their opcode into this one & return.  Otherwise,
// call ApplyPatch(patch).  There is an implicit list of patches at this
// address by virtue of the fact that we can iterate through all the
// patches in the patch with the same address.
// @access private
// @parm DebuggerControllerPatch *|patch|The patch to activate
void DebuggerController::ActivatePatch(DebuggerControllerPatch *patch)
{
    _ASSERTE(g_patches != NULL);
    _ASSERTE(patch->address != NULL);

    //
    // See if we already have an active patch at this address.
    //

    for (DebuggerControllerPatch *p = g_patches->GetPatch(patch->address);
         p != NULL;
         p = g_patches->GetNextPatch(p))
    {
        if (p != patch)
        {
            patch->opcode = p->opcode;
            _ASSERTE( patch->opcode == 0 || patch->address != NULL);
            return;
        }
    }

    //
    // This is the only patch at this address - apply the patch
    // to the code.
    //

    ApplyPatch(patch);
}

// @mfunc void|DebuggerController|DeactivatePatch|Make sure that a 
// patch won't be hit.
// How: If this patch is the last one at this address, then
// UnapplyPatch.  The caller should then invoke RemovePatch to remove the
// patch from the patch table.
// @access private
// @parm DebuggerControllerPatch *|patch|Patch to deactivate
void DebuggerController::DeactivatePatch(DebuggerControllerPatch *patch)
{
    _ASSERTE(g_patches != NULL);

    if (patch->address != NULL)
    {
        //
        // See if we already have an active patch at this address.
        //

        for (DebuggerControllerPatch *p = g_patches->GetPatch(patch->address);
             p != NULL;
             p = g_patches->GetNextPatch(p))
        {
            if (p != patch)
                return;
        }

        UnapplyPatch(patch);
    }
    
    //
    // Patch must now be removed from the table.
    //    
}

// @mfunc void | DebuggerController | AddPatch | What: Creates
// a patch, BindPatch if it wasn't added by address, then
// ActivatePatch it.
// How: Lock();  patch = g_patches->AddPatch of the same args.
// If BindPatch(patch) then ActivatePatch(); Unlock();
BOOL DebuggerController::AddPatch(Module *module, 
                                  mdMethodDef md,
                                  SIZE_T offset, 
                                  bool native, 
                                  void *fp,
                                  DebuggerJitInfo *dji,
                                  BOOL fStrict)
{
    _ASSERTE(g_patches != NULL);

    const BYTE *pb = NULL;
    BOOL succeed = FALSE;
    
    Lock();

    DebuggerControllerPatch *patch = g_patches->AddPatch(this, 
                                     module, 
                                     md, 
                                     offset, 
                                     native, 
                                     fp,
                                     m_pAppDomain,
                                     dji);

    if (dji != NULL && dji->m_jitComplete)
    {
        pb = g_pEEInterface->GetFunctionAddress(dji->m_fd);

        if (pb == NULL)
        {
            pb = (const BYTE *)dji->m_addrOfCode;
            _ASSERTE(pb != NULL);
        }
    }

    BOOL failedBecauseOfInvalidOffset;
    if (BindPatch(patch, pb, &failedBecauseOfInvalidOffset))
    {
        ActivatePatch(patch);
        succeed = TRUE;
    }

    //  If we were unable to bind b/c we know the offset is bad,
    // then we've got a genuine failure.  Otherwise, the bind might
    // fail,it might not, but we can't know that now.
    if (!failedBecauseOfInvalidOffset)
        succeed = TRUE;
    
    
    Unlock();

    return succeed;
}

void DebuggerController::AddPatch(MethodDesc *fd,
                                  SIZE_T offset, 
                                  bool native, 
                                  void *fp,
                                  BOOL fAttemptBind, 
                                  DebuggerJitInfo *dji,
                                  SIZE_T pid)
{
    _ASSERTE(g_patches != NULL);

    Lock();

    DebuggerControllerPatch *patch = 
                            g_patches->AddPatch(this,  
                            g_pEEInterface->MethodDescGetModule(fd), 
                            fd->GetMemberDef(), 
                            offset, 
                            native, 
                            fp,
                            m_pAppDomain,
                            dji,
                            pid);

    if (fAttemptBind && BindPatch(patch, NULL, NULL))
        ActivatePatch(patch);

    Unlock();
}

void DebuggerController::AddPatch(MethodDesc *fd,
                                  SIZE_T offset, 
                                  bool native, 
                                  void *fp,
                                  DebuggerJitInfo *dji,
                                  AppDomain *pAppDomain)
{
    _ASSERTE(g_patches != NULL);

    Lock();

    LOG((LF_CORDB,LL_INFO10000,"DC::AP: Add to %s::%s, at offs 0x%x native"
            "?:0x%x fp:0x%x AD:0x%x\n", fd->m_pszDebugClassName, 
            fd->m_pszDebugMethodName,
            offset, native, fp, pAppDomain));

    DebuggerControllerPatch *patch = 
                            g_patches->AddPatch(this, 
                            g_pEEInterface->MethodDescGetModule(fd), 
                            fd->GetMemberDef(), 
                            offset, 
                            native, 
                            fp, 
                            pAppDomain,
                            dji);
                            
    const BYTE *pbCode = NULL;
    if (dji != NULL && dji->m_jitComplete)
        pbCode = (const BYTE *)dji->m_addrOfCode;

    if (BindPatch(patch, pbCode, NULL))
    {
        LOG((LF_CORDB,LL_INFO1000,"BindPatch went fine, doing ActivatePatch\n"));
        ActivatePatch(patch);
    }

    Unlock();
}

void DebuggerController::AddPatch(DebuggerController *dc,
                                  MethodDesc *fd, 
                                  bool native, 
                                  const BYTE *address, 
                                  void *fp,
                                  DebuggerJitInfo *dji, 
                                  SIZE_T pid,
                                  SIZE_T natOffset)
{
    _ASSERTE(g_patches != NULL);

    Lock();

    DebuggerControllerPatch *patch 
      = g_patches->AddPatch(dc, 
                            fd, 
                            natOffset, 
                            native, 
                            TRUE, 
                            address, 
                            fp, 
                            dc->m_pAppDomain,
                            dji,
                            pid);

    ActivatePatch(patch);

    Unlock();
}

// This version is particularly useful b/c it doesn't assume that the
// patch is inside a managed method.
DebuggerControllerPatch *DebuggerController::AddPatch(const BYTE *address, 
                                  void *fp, 
                                  bool managed,
                                  TraceType traceType, 
                                  DebuggerJitInfo *dji,
                                  AppDomain *pAppDomain)
{
    _ASSERTE(g_patches != NULL);

    Lock();

    DebuggerControllerPatch *patch 
      = g_patches->AddPatch(this, 
                            NULL, 
                            0, 
                            TRUE, 
                            managed, 
                            address, 
                            fp, 
                            pAppDomain, 
                            dji,
                            DebuggerPatchTable::DCP_PID_INVALID, 
                            traceType);

    ActivatePatch(patch);

    Unlock();

    return patch;
}

// @mfunc void|DebuggerController|BindFunctionPatches |Make sure 
// that all the patches for the given function are active.  This
// is invoked when a method is JITted (in the FunctionStubInitialized
// callback from the JITter, which is invoked shortly after the
// JITComplete callback), so that if any breakpoints were placed in the
// method prior to it's being JITted, those breakpoints will now be 
// properly placed in the actual, executable code.
// How: Iterate through patches for the given function, and invoke
// BindPatch and ActivatePatch on each of them.
//
// ********* NOTE ************
// If you modify this, also look into Debugger::MapAndBindFunctionPatches
// ********* NOTE ************
//
// @access public
// @parm MethodDesc *|fd|MethodDesc of the newly JITted method
// @parm const BYTE *|code|Address of the first byte of the code
void DebuggerController::BindFunctionPatches(MethodDesc *fd, 
                                             const BYTE *code)
{
    if (g_patches == NULL)
        return;

    Lock();

    DebuggerControllerPatch *p = g_patches->GetPatch(fd);

    while (p != NULL)
    {
        //
        // Get next patch now, since binding the patch will change
        // it's hash value
        //

        DebuggerControllerPatch *pNext = g_patches->GetNextPatch(p);

        _ASSERTE(p->address == NULL);

        if (BindPatch(p, code, NULL))
            ActivatePatch(p);
        
        p->fSaveOpcode = false;

        p = pNext;
    }

    Unlock();
}

// @mfunc void|DebuggerController|UnbindFunctionPatches |Make sure 
// that all the patches for the given function are inactive.  This
// is invoked when a method is pitched (in the PitchCode
// callback from the JITter), so that if any breakpoints were placed in the
// method prior to it's being pitched, those breakpoints will now be 
// properly rehashed by {Module,MethodDef}
// How: Iterate through patches for the given function, and invoke
// DeactivatePatch and UnbindPatch on each of them.
// @access public
// @parm MethodDesc *|fd|MethodDesc of the newly JITted method
// @parm const BYTE *|code|Address of the first byte of the code
// @todo PITCH ENC This will have to be refined if both at same time.
void DebuggerController::UnbindFunctionPatches(MethodDesc *fd, 
                                                bool fSaveOpcodes)
{
    _ASSERTE( fd != NULL );

    if (g_patches == NULL)
        return;

    Lock();

    HASHFIND search;
    Module  *module=NULL;
    mdMethodDef md = mdTokenNil;

    DebuggerControllerPatch *p = g_patches->GetFirstPatch(&search);
    DebuggerControllerPatch *pNext = NULL;

    while (p != NULL)
    {
        // Get next patch now, since binding the patch will change
        // it's hash value
        pNext = g_patches->GetNextPatch(&search);

        _ASSERTE( p->opcode == 0 || p->address != NULL);
        if (p->address != NULL && p->opcode != 0) //must be an active patch
        {
#ifdef LOGGING
            if (p->key.module!= NULL && p->key.md!= mdTokenNil)
            {
                MethodDesc *pFD = g_pEEInterface->LookupMethodDescFromToken(
                    p->key.module,p->key.md);

                if (strcmp(fd->m_pszDebugClassName,
                                pFD->m_pszDebugClassName)==0 &&
                    strcmp(fd->m_pszDebugMethodName,
                                pFD->m_pszDebugMethodName)==0)
                {
                    LOG((LF_CORDB,LL_INFO10000, 
                        "DC::UFP: Found active patch (0x%x) for %s::%s, "
                        "offset:0x%x native:0x%x\n", p, pFD->m_pszDebugClassName, 
                        pFD->m_pszDebugMethodName, p->offset, p->native));
                }
            }
#endif //LOGGING
            
            if (module==NULL|| md==mdTokenNil)
            {
                module = g_pEEInterface->MethodDescGetModule(fd); 
                md = fd->GetMemberDef();
            }

            if (p->key.module == module && p->key.md == md)
            {
                // If all of the above is true, this patch must apply to
                // the provided fd.

                if (fSaveOpcodes)
                {
                    LOG((LF_CORDB,LL_INFO10000, "DC::UFP: Saved opcode 0x%x\n", p->opcode));
                    p->fSaveOpcode = true;
                }
                
                LOG((LF_CORDB,LL_INFO10000, "DC::UFP: Unbinding patch at addr0x%x\n",
                    p->address));
                DeactivatePatch(p);
                g_patches->UnbindPatch(p);

                _ASSERTE(p->opcode == 0 || p->address != NULL);
                p->opcode = 0; //zero out opcode for right side
                p->address = NULL; //so we don't barf when we do a BindFunctionPatches
                _ASSERTE( p->opcode == 0 || p->address != NULL);
                
                p->dji = (DebuggerJitInfo*)
                        DebuggerJitInfo::DJI_VERSION_INVALID; // so we don't barf if
                    // we're doing this b/c of being pitched.  This also signals
                    // MapAndBindFunctionPatches that we'll be doing a rebind.
            }
        }
        p = pNext;
    }

    Unlock();
}

//
// Returns true if the given address is in an internal helper
// function, false if its not.
//
// This is a temporary hack function to avoid having us stop in
// unmanaged code belonging to the Runtime during a StepIn operation.
//
static bool _AddrIsJITHelper(const BYTE *addr)
{
    static void *helperFuncs[CORINFO_HELP_COUNT];
    static bool tableLoaded = false;

    BYTE *pBase = (BYTE *)g_pMSCorEE;
            
    IMAGE_DOS_HEADER *pDOS = (IMAGE_DOS_HEADER *)pBase;

    // Bad header? Assume its a helper...
    if (pDOS->e_magic != IMAGE_DOS_SIGNATURE ||
        pDOS->e_lfanew == 0)
        return true;

    IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*)(pBase + pDOS->e_lfanew);

    // Bad header? Assume its a helper...
    if (pNT->Signature != IMAGE_NT_SIGNATURE ||
        pNT->FileHeader.SizeOfOptionalHeader !=
        IMAGE_SIZEOF_NT_OPTIONAL_HEADER ||
        pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) 
        return true;

    // Is the address in mscoree.dll at all? (All helpers are in
    // mscoree.dll)
    if (addr >= pBase && addr < pBase + pNT->OptionalHeader.SizeOfImage) 
    {
        if (!tableLoaded)
        {
            HRESULT hr = LoadHelperTable(NULL,
                                         helperFuncs,
                                         CORINFO_HELP_COUNT);
            _ASSERTE(hr == S_OK);
            
            tableLoaded = true;
        }

        for (unsigned int i = 0; i < CORINFO_HELP_COUNT; i++)
        {
            if (helperFuncs[i] == (void*)addr)
            {
                LOG((LF_CORDB, LL_INFO10000, 
                     "_ANIM: address of helper function found: 0x%08x\n",
                     addr));
                
                return true;
            }
        }

        LOG((LF_CORDB, LL_INFO10000, 
             "_ANIM: address within mscoree.dll, but not a helper function "
             "0x%08x\n", addr));
    }

    return false;
}

// @mfunc bool | DebuggerController | PatchTrace | What: Invoke
// AddPatch depending on the type of the given TraceDestination.
// How: Invokes AddPatch based on the trace type: TRACE_OTHER will
// return false, the others will obtain args for a call to an AddPatch
// method & return true.
bool DebuggerController::PatchTrace(TraceDestination *trace, 
                                    void *fp,
                                    bool fStopInUnmanaged)
{
    DebuggerControllerPatch *dcp = NULL;
    
    switch (trace->type)
    {
    case TRACE_UNMANAGED:
        LOG((LF_CORDB, LL_INFO10000, 
             "DC::PT: Setting unmanaged trace patch at 0x%x(%x)\n",
             trace->address, fp));

        if (RunningOnWin95() && WIN9X_NONWRITABLE_ADDRESS(trace->address))
            return false;

        if (fStopInUnmanaged && !_AddrIsJITHelper(trace->address))
        {
            AddPatch(trace->address, 
                     fp, 
                     FALSE, 
                     trace->type, 
                     NULL,
                     NULL);
            return true;
        }
        else
        {
            LOG((LF_CORDB, LL_INFO10000, "DC::PT: decided to NOT "
                "place a patch in unmanaged code\n"));
            return false;
        }

    case TRACE_MANAGED:
        LOG((LF_CORDB, LL_INFO10000, 
             "Setting managed trace patch at 0x%x(%x)\n", trace->address, fp));

        MethodDesc *fd;
        fd = g_pEEInterface->GetNativeCodeMethodDesc(trace->address);
        _ASSERTE(fd);
        
        DebuggerJitInfo *dji;
        dji = g_pDebugger->GetJitInfo(fd, trace->address);
        //_ASSERTE(dji); //we'd like to assert this, but attach won't work

        SIZE_T offset;
        
        if (dji == NULL || dji->m_addrOfCode == 0)
        {
            _ASSERTE(g_pEEInterface->GetFunctionAddress(fd) != NULL);
            offset = trace->address - g_pEEInterface->GetFunctionAddress(fd);
        }
        else
            offset = (SIZE_T)trace->address - (SIZE_T)dji->m_addrOfCode;

        AddPatch(fd, 
                 offset,
                 TRUE,
                 fp, 
                 dji, 
                 NULL);
        return true;

    case TRACE_UNJITTED_METHOD:
        // trace->address is actually a MethodDesc* of the method that we'll
        // soon JIT, so put a relative bp at offset zero in.
        LOG((LF_CORDB, LL_INFO10000, 
            "Setting unjitted method patch in MethodDesc 0x%x(%x)\n",
            (MethodDesc*)trace->address ));

        // Note: we have to make sure to bind here. If this function is prejitted, this may be our only chance to get a
        // DebuggerJITInfo and thereby cause a JITComplete callback.
        AddPatch((MethodDesc*)trace->address, 
                 0, 
                 TRUE, 
                 fp, 
                 NULL, 
                 NULL);
    
        return true;
        
    case TRACE_FRAME_PUSH:
        LOG((LF_CORDB, LL_INFO10000, 
             "Setting frame patch at 0x%x(%x)\n", trace->address, fp));

        AddPatch(trace->address, 
                 fp, 
                 TRUE, 
                 trace->type, 
                 NULL, 
                 NULL);
        return true;

    case TRACE_MGR_PUSH:
        LOG((LF_CORDB, LL_INFO10000, 
             "Setting frame patch (TRACE_MGR_PUSH) at 0x%x(%x)\n",
             trace->address, fp));

        dcp = AddPatch(trace->address, 
                       fp, 
                       TRUE, 
                       DPT_DEFAULT_TRACE_TYPE, // TRACE_OTHER
                       NULL, 
                       NULL);
        // Now copy over the trace field since TriggerPatch will expect this
        // to be set for this case.
        if (dcp != NULL)
            dcp->trace = *trace;
            
        return true;

    case TRACE_OTHER:
        LOG((LF_CORDB, LL_INFO10000,
             "Can't set a trace patch for TRACE_OTHER...\n"));
        return false;

    default:
        _ASSERTE(0);
        return false;
    }
}

bool DebuggerController::MatchPatch(Thread *thread, 
                                    CONTEXT *context,
                                    DebuggerControllerPatch *patch)
{
    LOG((LF_CORDB, LL_INFO100000, "DC::MP: EIP:0x%x\n", context->Eip));

    // RAID 67173 - we'll make sure that intermediate patches have NULL
    // pAppDomain so that we don't end up running to completion when
    // the appdomain switches halfway through a step.
    if (patch->pAppDomain != NULL)
    {
        AppDomain *pAppDomainCur = thread->GetDomain();

        if (pAppDomainCur != patch->pAppDomain)
        {
            LOG((LF_CORDB, LL_INFO10000, "DC::MP: patches didn't match b/c of "
                "appdomains!\n"));
            return false;
        }
    }
    else
    {
        if (!thread->GetDomain()->IsDebuggerAttached())
        {
            LOG((LF_CORDB, LL_INFO10000, "DC::MP: patches didn't match b/c debugger"
                " not attached to this appdomain!\n"));
            return false;
        }
    }

    if (patch->controller->m_thread != NULL && patch->controller->m_thread != thread)
    {    
        LOG((LF_CORDB, LL_INFO10000, "DC::MP: patches didn't match b/c threads\n"));
        return false;
    }
    
    if (patch->fp == NULL)
        return true;
        
    ControllerStackInfo info;

    info.GetStackInfo(thread, NULL, context, TRUE);

    // !!! This check should really be != , but there is some ambiguity about which frame is the parent frame
    // in the destination returned from Frame::TraceFrame, so this allows some slop there.

    if (info.m_returnFrame.fp < patch->fp)
    {
        LOG((LF_CORDB, LL_INFO10000, "Patch hit but frame not matched at %x (current=%x, patch=%x)\n",
            patch->address, info.m_returnFrame.fp, patch->fp));

        return false;
    }

    _ASSERTE(patch->address == (const BYTE *)context->Eip);

    return true;
}

// For other platforms, eip will actually be PC, or whatever other register.
DebuggerPatchSkip *DebuggerController::ActivatePatchSkip(Thread *thread, 
                                                         const BYTE *eip,
                                                         BOOL fForEnC)
{
    LOG((LF_CORDB,LL_INFO10000, "DC::APS\n"));
    _ASSERTE(g_patches != NULL);

    //      Previously, we assumed that if we got to this point & the patch
    // was still there that we'd have to skip the patch.  SetIP changes
    // this like so:
    //      A breakpoint is set, and hit (but not removed), and all the 
    // EE threads come to a skreeching halt.  The Debugger RC thread
    // continues along, and is told to SetIP of the thread that hit
    // the BP to whatever.  Eventually the RC thread is told to continue,
    // and at that point the EE thread is released, finishes DispatchPatchOrSingleStep,
    // and shows up here.  
    //      At that point, if the thread's current EIP is
    // different from the patch EIP, then SetIP must have moved it elsewhere
    // & we shouldn't do this patch skip (which will put us back to where
    // we were, which is clearly wrong).  If the EIP _is_ the same, then
    // the thread hasn't been moved, the patch is still in the code stream,
    // and we want to do the patch skip thing in order to execute this 
    // instruction w/o removing it from the code stream.
    
    DebuggerControllerPatch *patch = g_patches->GetPatch(eip);

    DebuggerPatchSkip *skip = NULL;

    if (patch != NULL && patch->native)
    {
        //
        // We adjust the thread's EIP to someplace where we write
        // the next instruction, then
        // we single step over that, then we set the EIP back here so
        // we don't let other threads race past here while we're stepping
        // this one.
        //
        // !!! check result 
        LOG((LF_CORDB,LL_INFO10000, "DC::APS: About to skip from Eip=0x%x\n", eip));
        skip = new (interopsafe) DebuggerPatchSkip(thread, patch, thread->GetDomain());
        TRACE_ALLOC(skip);
    }

    return skip;
}

BOOL DebuggerController::ScanForTriggers(const BYTE *address,
                                         Thread *thread,
                                         CONTEXT *context,
                                         DebuggerControllerQueue *pDcq,
                                         SCAN_TRIGGER stWhat,
                                         TP_RESULT *pTpr)
{
    LOG((LF_CORDB, LL_INFO10000, "DC::SFT: starting scan for addr:0x%x"
            " thread:0x%x\n", address, thread));

    _ASSERTE( pTpr != NULL );

    DebuggerControllerPatch *patch = NULL;

    if (g_patches != NULL)
        patch = g_patches->GetPatch(address);

    USHORT iEvent = 0xFFFF;
    USHORT iEventNext = 0xFFFF;
    BOOL fDone = FALSE;

    // This is a debugger exception if there's a patch here, or
    // we're here for something like a single step.
    BOOL used = (patch != NULL) || !IsPatched(address, TRUE);
    
    TP_RESULT tpr = TPR_IGNORE;
    
    while (stWhat & ST_PATCH && 
           patch != NULL && 
           !fDone)
    {
        DebuggerControllerPatch *patchNext 
          = g_patches->GetNextPatch(patch);

        // Annoyingly, TriggerPatch may add patches, which may cause
        // the patch table to move, which may, in turn, invalidate
        // the patch (and patchNext) pointers.  Store indeces, instead.
        iEvent = g_patches->GetItemIndex( (HASHENTRY *)patch );
        
        if (patchNext != NULL)
            iEventNext = g_patches->GetItemIndex((HASHENTRY *)patchNext);

        if (MatchPatch(thread, context, patch))
        {
            patch->triggering = true;

            tpr = patch->controller->TriggerPatch(patch,
                                                thread,
                                                patch->key.module, 
                                                patch->key.md, 
                                                patch->offset,
                                                patch->managed,
                                                TY_NORMAL);
            if (tpr == TPR_TRIGGER || 
                tpr == TPR_TRIGGER_ONLY_THIS ||
                tpr == TPR_TRIGGER_ONLY_THIS_AND_LOOP)
            {
                // Make sure we've still got a valid pointer.
                patch = (DebuggerControllerPatch *)
                    DebuggerController::g_patches->GetEntryPtr( iEvent );
                pDcq->dcqEnqueue(patch->controller, TRUE); // @todo Return value
            }

            // Make sure we've got a valid pointer in case TriggerPatch
            // returned false but still caused the table to move.
            patch = (DebuggerControllerPatch *)
                g_patches->GetEntryPtr( iEvent );
            
            patch->triggering = false;

            if (patch->deleted)
            {
                DeactivatePatch(patch);
                g_patches->RemovePatch(patch);
            }
        }

        if (tpr == TPR_IGNORE_STOP || 
            tpr == TPR_TRIGGER_ONLY_THIS ||
            tpr == TPR_TRIGGER_ONLY_THIS_AND_LOOP)
        {      
#ifdef _DEBUG
            if (tpr == TPR_TRIGGER_ONLY_THIS ||
                tpr == TPR_TRIGGER_ONLY_THIS_AND_LOOP)
                _ASSERTE(pDcq->dcqGetCount() == 1);
#endif //_DEBUG

            fDone = TRUE;
        }
        else if (patchNext != NULL)
        {
            patch = (DebuggerControllerPatch *)
                g_patches->GetEntryPtr(iEventNext);
        }
        else
        {
            patch = NULL;
        }
    }

    if (stWhat & ST_SINGLE_STEP &&
        tpr != TPR_TRIGGER_ONLY_THIS)
    {
        //
        // Now, go ahead & trigger all controllers with
        // single step events
        //

        DebuggerController *p;

        p = g_controllers;
        while (p != NULL)
        {
            DebuggerController *pNext = p->m_next;

            if (p->m_thread == thread && p->m_singleStep)
            {
                used = true;

                if (p->TriggerSingleStep(thread, address))
                {
                    pDcq->dcqEnqueue(p, FALSE);
                }
            }

            p = pNext;
        }

        //
        // See if we have any steppers still active for this thread, if so
        // re-apply the trace flag.
        // 

        p = g_controllers;
        while (p != NULL)
        {
            if (p->m_thread == thread && p->m_singleStep)
            {
                ApplyTraceFlag(thread);
                break;
            }

            p = p->m_next;
        }
    }

    // Significant speed increase from single dereference, I bet :)
    (*pTpr) = tpr;
    
    LOG((LF_CORDB, LL_INFO10000, "DC::SFT returning 0x%x as used\n",used));
    return used;
}

DebuggerControllerPatch *DebuggerController::IsXXXPatched(const BYTE *eip,
                                                          DEBUGGER_CONTROLLER_TYPE dct)
{                                                          
    _ASSERTE(g_patches != NULL);

    DebuggerControllerPatch *patch = g_patches->GetPatch(eip);

    while(patch != NULL &&
          (int)patch->controller->GetDCType() <= (int)dct)
    {
        if (patch->native &&
            patch->controller->GetDCType()==dct)
        {
            return patch;
        }
        patch = g_patches->GetNextPatch(patch);
    }

    return NULL;
}

BOOL DebuggerController::IsJittedMethodEnCd(const BYTE *address)
{
    MethodDesc *md = NULL;
    if( g_pEEInterface->IsManagedNativeCode(address) )
    {
        md = g_pEEInterface->GetNativeCodeMethodDesc(address);

        DebuggerJitInfo *dji = g_pDebugger->GetJitInfo(md, address);
        if (dji == NULL)
            return FALSE;

        return (dji->m_encBreakpointsApplied?TRUE:FALSE);
    }
    return FALSE;
}

// @mfunc bool|DebuggerController|DispatchPatchOrSingleStep|Ask any patches that are active at a given address if they
// want to do anything about the exception that's occured there.  How: For the given address, go through the list of
// patches & see if any of them are interested (by invoking their DebuggerController's TriggerPatch).  Put the indices
// of any DC's that are into an array, and if there are any, do the Hideous Dance of Death (see Patches.html).  @access
// public
BOOL DebuggerController::DispatchPatchOrSingleStep(Thread *thread, CONTEXT *context, const BYTE *address, SCAN_TRIGGER which)
{
    LOG((LF_CORDB,LL_INFO1000,"DC:DPOSS at 0x%x trigger:0x%x\n", address, which));

    BOOL used = false;

    DebuggerControllerQueue dcq;
    USHORT iEvent = 0xFFFF;

    if (!g_patchTableValid)
    {
        LOG((LF_CORDB, LL_INFO1000, "DC::DPOSS returning, no patch table.\n"));
        return (FALSE);
    }

    _ASSERTE(g_patches != NULL);
    
    Lock();

    TP_RESULT tpr;
    used = ScanForTriggers(address, thread, context, &dcq, which, &tpr);

#ifdef _DEBUG
    // If we do a SetIP after this point, the value of address will be garbage.  Set it to a distictive pattern now, so
    // we don't accidentally use what will (98% of the time) appear to be a valid value.
    address = (const BYTE *)0xAABBCCFF;
#endif //_DEBUG    

    if (dcq.dcqGetCount()> 0)
    {
        Unlock();

        // Mark if we're at an unsafe place.
        bool atSafePlace = g_pDebugger->IsThreadAtSafePlace(thread);

        if (!atSafePlace)
            g_pDebugger->IncThreadsAtUnsafePlaces();
        
        bool disabled = g_pEEInterface->IsPreemptiveGCDisabled();
        
        if (disabled)
            g_pEEInterface->EnablePreemptiveGC();

        // Lock the debugger for sending events. We have to do this around the SendEvent loop below, otherwise we can't
        // be sure that all events for this thread will be received by the Right Side on the same synchronizaion.
        g_pDebugger->LockForEventSending();

        // Send the events outside of the controller lock

        bool anyEventsSent = false;
        int cEvents = dcq.dcqGetCount();
        int iEvent = 0; 
        
        while (iEvent < cEvents)
        {
            DebuggerController *event = dcq.dcqGetElement(iEvent);

            if (!event->m_deleted)
            {
                if (thread->GetDomain()->IsDebuggerAttached())
                {
                    event->SendEvent(thread);
                    anyEventsSent = true;
                }
            }

            iEvent++;
        }

        // Trap all threads if necessary, but only if we actually sent a event up (i.e., all the queued events weren't
        // deleted before we got a chance to get the EventSending lock.)
        BOOL threadStoreLockOwner = FALSE;
        
        if (anyEventsSent)
        {
//            LOG((LF_CORDB,LL_INFO1000, "About to SAT!\n"));
            threadStoreLockOwner = g_pDebugger->SyncAllThreads();
            LOG((LF_CORDB,LL_INFO1000, "SAT called!\n"));
        }

        
        // Release the debugger for event sending.
        g_pDebugger->UnlockFromEventSending();
        LOG((LF_CORDB,LL_INFO1000, "UnlockFromEventSending done!\n"));
        
        // If we need to to a re-abort (see below), then save the current IP in the thread's context before we block and
        // possibly let another func eval get setup.
        BOOL reabort = thread->m_StateNC & Thread::TSNC_DebuggerReAbort;

        // Block and release the thread store lock, if we're holding it.
        g_pDebugger->BlockAndReleaseTSLIfNecessary(threadStoreLockOwner);
///        LOG((LF_CORDB,LL_INFO1000, "BlockAndReleaseTSLIfNecessary done!\n"));
        
        // Pulse GC mode to trip thread in case someone else is syncing.
        g_pEEInterface->DisablePreemptiveGC();
//        LOG((LF_CORDB,LL_INFO1000, "DisablePreemptiveGC done!\n"));
        
        if (!disabled)
            g_pEEInterface->EnablePreemptiveGC();

        if (!atSafePlace)
            g_pDebugger->DecThreadsAtUnsafePlaces();
        
        Lock();

        // Dequeue the events while we have the controller lock.
        iEvent = 0;
        while (iEvent < cEvents)
        {
            dcq.dcqDequeue();
            iEvent++;
        }

        // If a func eval completed with a ThreadAbortException, go ahead and setup the thread to re-abort itself now
        // that we're continuing the thread. Note: we make sure that the thread's IP hasn't changed between now and when
        // we blocked above. While blocked above, the debugger has a chance to setup another func eval on this
        // thread. If that happens, we don't want to setup the reabort just yet.
        if (reabort)
        {
#ifdef _X86_
            if ((DWORD) Debugger::FuncEvalHijack != context->Eip)
#endif //_X86_
            {
                HRESULT hr = g_pDebugger->FuncEvalSetupReAbort(thread);
                _ASSERTE(SUCCEEDED(hr));
            }
        }
    }

    // Note: if the thread filter context is NULL, then SetIP would have failed & thus we should do the patch skip
    // thing.
    CONTEXT *pCtx = g_pEEInterface->GetThreadFilterContext( thread );
    _ASSERTE(!ISREDIRECTEDTHREAD(thread));
    _ASSERTE(pCtx != NULL);

    BOOL fMethodEnCPatchedAfter = IsJittedMethodEnCd((const BYTE *)pCtx->Eip);
    DebuggerControllerPatch *dcpEnC = NULL;

    if (fMethodEnCPatchedAfter)
        dcpEnC = IsXXXPatched((const BYTE*)(pCtx->Eip), DEBUGGER_CONTROLLER_ENC);

    // If we're sitting on an EnC patch, then instead of skipping it, executing the old code, and hitting the EnC bp at
    // the next sequence point, we will 'short-circuit' the whole thing & do it now.  This will make things look right
    // for the bottommost frame, although other frames on the stack may look/behave weird since they can't
    // short-circuit.
    if (fMethodEnCPatchedAfter && dcpEnC != NULL && pCtx->Eip != (ULONG)Debugger::FuncEvalHijack) 
    {
        TP_RESULT tpr;
        
        LOG((LF_CORDB,LL_INFO10000, "DC::APS: EnC short-circuit!\n"));
        tpr = dcpEnC->controller->TriggerPatch(dcpEnC,
                                               thread,
                                               dcpEnC->key.module, 
                                               dcpEnC->key.md, 
                                               dcpEnC->offset,
                                               dcpEnC->managed,
                                               TY_SHORT_CIRCUIT);
        _ASSERTE(TPR_IGNORE==tpr);

        // If we got here, then EnC failed & we want to continue to operate in the old version.  We may have JITted the
        // new version, or not.
    }

    if (tpr != TPR_TRIGGER_ONLY_THIS_AND_LOOP) // see DebuggerEnCRemap class
        ActivatePatchSkip(thread, (const BYTE*)pCtx->Eip, FALSE);

    Unlock();

    return used;
}

void DebuggerController::EnableSingleStep()
{
    EnableSingleStep(m_thread);
    m_singleStep = true;
}

// Note that this doesn't tell us if Single Stepping is currently enabled
// at the hardware level (ie, for x86, if (context->EFlags & 0x100), but
// rather, if we WANT single stepping enabled (pThread->m_State &Thread::TS_DebuggerIsStepping)
// This gets called from exactly one place - ActivatePatchSkipForEnC
BOOL DebuggerController::IsSingleStepEnabled(Thread *pThread)
{
    // This should be an atomic operation, do we 
    // don't need to lock it.
    if(pThread->m_StateNC & Thread::TSNC_DebuggerIsStepping)
    {
        _ASSERTE(pThread->m_StateNC & Thread::TSNC_DebuggerIsStepping);
        
        return TRUE;
    }
    else
        return FALSE;
}

void DebuggerController::EnableSingleStep(Thread *pThread)
{
    LOG((LF_CORDB,LL_INFO1000, "DC::EnableSingleStep\n"));

    _ASSERTE(pThread != NULL);

    Lock();
    {
        ApplyTraceFlag(pThread);
    }
    Unlock();
}

void DebuggerController::DisableSingleStep()
{
    _ASSERTE(m_thread != NULL);

    LOG((LF_CORDB,LL_INFO1000, "DC::DisableSingleStep\n"));

    Lock();
    {
        DebuggerController *p = g_controllers;
        
        m_singleStep = false;

        while (p != NULL)
        {
            if (p->m_thread == m_thread 
                && p->m_singleStep)
                break;

            p = p->m_next;
        }

        if (p == NULL)
            UnapplyTraceFlag(m_thread);
    }
    Unlock();
}

//
// ApplyTraceFlag sets the trace flag for a thread.
//

void DebuggerController::ApplyTraceFlag(Thread *thread)
{
    LOG((LF_CORDB,LL_INFO1000, "DC::ApplyTraceFlag thread:0x%x [0x%0x]\n", thread, thread->GetThreadId()));
    
    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);

    CONTEXT tempContext;

    if (context == NULL)
    {
        if (ISREDIRECTEDTHREAD(thread))
        {
            LOG((LF_CORDB,LL_INFO1000, "DC::ApplyTraceFlag Redirected Context\n"));
            RedirectedThreadFrame *pFrame = (RedirectedThreadFrame *) thread->GetFrame();
            context = pFrame->GetContext();
        }
        else
        {
            LOG((LF_CORDB,LL_INFO1000, "DC::ApplyTraceFlag NULL Context\n"));
            // We can't play with our own context!
            _ASSERTE(thread->GetThreadId() != GetCurrentThreadId());

            tempContext.ContextFlags = CONTEXT_CONTROL;

            if (!GetThreadContext(thread->GetThreadHandle(), &tempContext))
                _ASSERTE(!"GetThreadContext failed.");

            context = &tempContext;
            LOG((LF_CORDB,LL_INFO1000, "DC::ApplyTraceFlag using tempContext\n"));
        }
    }

#ifdef _X86_
    context->EFlags |= 0x100;

    g_pEEInterface->MarkThreadForDebugStepping(thread, true);

    LOG((LF_CORDB,LL_INFO1000, "DC::ApplyTraceFlag marked thread for debug stepping\n"));
    
#endif

    if (context == &tempContext)
    {
        LOG((LF_CORDB,LL_INFO1000, "DC::ApplyTraceFlag still using tempContext\n"));
    
        if (!SetThreadContext(thread->GetThreadHandle(), &tempContext))
        {
            LOG((LF_CORDB,LL_INFO1000, "DC::ApplyTraceFlag SetThreadContext failed\n"));
            _ASSERTE(!"SetThreadContext failed.");
        }
    }

    LOG((LF_CORDB,LL_INFO1000, "DC::ApplyTraceFlag Leaving, baby!\n"));
}

//
// UnapplyTraceFlag sets the trace flag for a thread.
//

void DebuggerController::UnapplyTraceFlag(Thread *thread)
{
    LOG((LF_CORDB,LL_INFO1000, "DC::UnapplyTraceFlag thread:0x%x\n", thread));
    
    // Don't do any work in here if we're shutting down since the
    // thread we're working with is most probably gone by now.
    if (g_uninitializing)
        return;

    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);

    CONTEXT tempContext;

    if (context == NULL)
    {
        if (ISREDIRECTEDTHREAD(thread))
        {
            LOG((LF_CORDB,LL_INFO1000, "DC::UnapplyTraceFlag Redirected Context\n"));
            RedirectedThreadFrame *pFrame = (RedirectedThreadFrame *) thread->GetFrame();
            context = pFrame->GetContext();
        }

        // We can't play with our own context, so just leave it null
        // if we try to. There is a case in managed/unmanaged
        // debugging where we may need to disable single stepping for
        // a stepper from the thread that was supposed to be
        // stepping. This path is through
        // DebuggerStepper::TriggerUnwind.
        else if (thread->GetThreadId() != GetCurrentThreadId())
        {
            tempContext.ContextFlags = CONTEXT_CONTROL;
        
            if (!GetThreadContext(thread->GetThreadHandle(), &tempContext))
                _ASSERTE(!"GetThreadContext failed.");
            
            context = &tempContext;
        }
    }

#ifdef _X86_
    if (context)
        context->EFlags &= ~0x100;

    // Always need to unmark for stepping
    g_pEEInterface->MarkThreadForDebugStepping(thread, false);
#endif

    if (context == &tempContext)
    {
        if (!SetThreadContext(thread->GetThreadHandle(), &tempContext))
            _ASSERTE(!"SetThreadContext failed.");
    }
}

void DebuggerController::EnableExceptionHook()
{
    _ASSERTE(m_thread != NULL);

    Lock();
    {
        m_exceptionHook = true;
    }
    Unlock();
}

void DebuggerController::DisableExceptionHook()
{
    _ASSERTE(m_thread != NULL);

    Lock();
    {
        m_exceptionHook = false;
    }
    Unlock();
}


// @mfunc void|DebuggerController|DispatchExceptionHook|Called before 
// the switch statement in DispatchNativeException (therefore
// when any exception occurs), this allows patches to do something before the
// regular DispatchX methods.
// How: Iterate through list of controllers.  If m_exceptionHook
// is set & m_thread is either thread or NULL, then invoke TriggerExceptionHook()
// @access private
BOOL DebuggerController::DispatchExceptionHook(Thread *thread,
                                               CONTEXT *context, //@todo unused param?
                                               EXCEPTION_RECORD *pException)
{
    LOG((LF_CORDB, LL_INFO1000, "DC:: DispatchExceptionHook\n"));

    if (!g_patchTableValid)
    {
        LOG((LF_CORDB, LL_INFO1000, "DC::DEH returning, no patch table.\n"));
        return (TRUE);
    }

    _ASSERTE(g_patches != NULL);

    Lock();

    TP_RESULT tpr = TPR_IGNORE;
    DebuggerController *p;

    p = g_controllers;
    while (p != NULL)
    {
        DebuggerController *pNext = p->m_next;

        if (p->m_exceptionHook
            && (p->m_thread == NULL || p->m_thread == thread) &&
            tpr != TPR_IGNORE_STOP)
        {
                        LOG((LF_CORDB, LL_INFO1000, "DC::DEH calling TEH...\n"));
            tpr = p->TriggerExceptionHook(thread, pException);
                        LOG((LF_CORDB, LL_INFO1000, "DC::DEH ... returned.\n"));
            
            if (tpr == TPR_IGNORE_STOP)
            {
                LOG((LF_CORDB, LL_INFO1000, "DC:: DEH: leaving early!\n"));
                break;
            }
        }

        p = pNext;
    }

    Unlock();

    LOG((LF_CORDB, LL_INFO1000, "DC:: DEH: returning 0x%x!\n", tpr));

    return (tpr != TPR_IGNORE_STOP);
}

//
// EnableUnwind enables an unwind event to be called when the stack is unwound
// (via an exception) to or past the given pointer.
//

void DebuggerController::EnableUnwind(void *fp)
{
    ASSERT(m_thread != NULL);
    LOG((LF_CORDB,LL_EVERYTHING,"DC:EU EnableUnwind at 0x%x\n", fp));

    Lock();
    {
        m_unwindFP = fp;
    }
    Unlock();
}

void* DebuggerController::GetUnwind()
{
    return m_unwindFP;
}

//
// DisableUnwind disables the unwind event for the controller.
//

void DebuggerController::DisableUnwind()
{
    ASSERT(m_thread != NULL);

    LOG((LF_CORDB,LL_INFO1000, "DC::DU\n"));

    Lock();
    {
        m_unwindFP = NULL;
    }
    Unlock();
}

//
// DispatchUnwind is called when an unwind happens.
// the event to the appropriate controllers.
//

bool DebuggerController::DispatchUnwind(Thread *thread,
                                        MethodDesc *newFD, SIZE_T newOffset, 
                                        const BYTE *handlerEBP,
                                        CorDebugStepReason unwindReason) 
{
    _ASSERTE(unwindReason == STEP_EXCEPTION_FILTER || unwindReason == STEP_EXCEPTION_HANDLER);

    bool used = false;

    LOG((LF_CORDB, LL_INFO10000, "DC: Dispatch Unwind\n"));

    Lock();

    {
        DebuggerController *p;

        p = g_controllers;

        while (p != NULL)
        {
            DebuggerController *pNext = p->m_next;

            if (p->m_thread == thread && p->m_unwindFP != NULL)
            {
                LOG((LF_CORDB, LL_INFO10000, "Dispatch Unwind: Found candidate\n"));

                
                //  Assumptions here:
                //      Function with handlers are -ALWAYS- EBP-frame based (JIT assumption)
                //
                //      newFrame is the EBP for the handler
                //      p->m_unwindFP points to the stack slot with the return address of the function.
                //
                //  For the interesting case: stepover, we want to know if the handler is in the same function
                //  as the stepper, if its above it (caller) o under it (callee) in order to know if we want
                //  to patch the handler or not.
                //
                //  3 cases:
                //
                //      a) Handler is in a function under the function where the step happened. It therefore is
                //         a stepover. We don't want to patch this handler. The handler will have an EBP frame.
                //         So it will be at least be 2 DWORDs away from the m_unwindFP of the controller (
                //         1 DWORD from the pushed return address and 1 DWORD for the push EBP).
                //
                //      b) Handler is in the same function as the stepper. We want to patch the handler. In this
                //         case handlerEBP will be the same as p->m_unwindFP-sizeof(void*). Why? p->m_unwindFP
                //         stores a pointer to the return address of the function. As a function with a handler
                //         is always EBP frame based it will have the following code in the prolog:
                //                 
                //                  push ebp        <- ( sub esp, 4 ; mov [esp], ebp )
                //                  mov  esp, ebp
                //
                //         Therefore EBP will be equal to &CallerReturnAddress-4.
                //      
                //      c) Handler is above the function where the stepper is. We want to patch the handler. handlerEBP
                //         will be always greater than the pointer to the return address of the function where the 
                //         stepper is.
                //
                //
                //

                if ( handlerEBP + sizeof(void*) >= ((BYTE*) p->m_unwindFP))
                {
                    used = true;

                    //
                    // Assume that this isn't going to block us at all --
                    // other threads may be waiting to patch or unpatch something,
                    // or to dispatch.
                    //
                    LOG((LF_CORDB, LL_INFO10000, 
                        "Unwind trigger at offset %x; handlerEBP: %x unwindReason: %x.\n",
                         newOffset, handlerEBP, unwindReason));

                    p->TriggerUnwind(thread, 
                                     newFD, 
                                     newOffset, 
                                     handlerEBP + sizeof(void*),
                                     unwindReason);
                }
                else
                {
                    LOG((LF_CORDB, LL_INFO10000, 
                        "Unwind trigger at offset %x; handlerEBP: %x unwindReason: %x.\n",
                         newOffset, handlerEBP, unwindReason));
                }
            }

            p = pNext;
        }
    }

    Unlock();

    return used;
}

bool DebuggerController::DispatchCLRCatch(Thread *thread)
{
    LOG((LF_CORDB, LL_INFO10000, "DC::DCLRC: thread=0x%08x\n", thread));
    
    bool used=false;

    Lock();
    {
        DebuggerController *p;

        p = g_controllers;

        while (p != NULL)
        {
            DebuggerController *pNext = p->m_next;

            if ((p->GetDCType() == DEBUGGER_CONTROLLER_STEPPER) && (p->m_thread == thread))
            {    
                LOG((LF_CORDB, LL_INFO10000, "DC::DCLRC: disabling stepper 0x%08x, p->m_traceCallFP=0x%08x\n",
                     p, p->m_traceCallFP));
                
                p->DisableAll();
                p->EnableTraceCall(NULL);

                used = true;
            }

            p = pNext;
        }
    }
    Unlock();

    return used;
}

//
// EnableTraceCall enables a call event on the controller
//

void DebuggerController::EnableTraceCall(void *maxFrame)
{
    ASSERT(m_thread != NULL);

    LOG((LF_CORDB,LL_INFO1000, "DC::ETC maxFrame=0x%x, thread=0x%x\n",
         maxFrame, m_thread->GetThreadId()));

    Lock();
    {
        if (!m_traceCall)
        {
            m_traceCall = true;
            g_pEEInterface->EnableTraceCall(m_thread);
        }

        if (maxFrame < m_traceCallFP)
            m_traceCallFP = maxFrame;
    }
    Unlock();
}

//
// DisableTraceCall disables call events on the controller
//

void DebuggerController::DisableTraceCall()
{
    ASSERT(m_thread != NULL);

    Lock();
    {
        if (m_traceCall)
        {
            // Don't do any work in here if we're shutting down since the
            // thread we're working with is most probably gone by now.
            if (!g_uninitializing)
            {
                LOG((LF_CORDB,LL_INFO1000, "DC::DTC thread=0x%x\n",
                 m_thread->GetThreadId()));

                g_pEEInterface->DisableTraceCall(m_thread);
            }
            
            m_traceCall = false;
            m_traceCallFP = FRAME_TOP;
        }
    }
    Unlock();
}

//
// DispatchTraceCall is called when a call is traced in the EE
// It dispatches the event to the appropriate controllers.
//

bool DebuggerController::DispatchTraceCall(Thread *thread, 
                                           const BYTE *ip)
{
    bool used = false;

    LOG((LF_CORDB, LL_INFO10000, 
         "DC::DTC: TraceCall at 0x%x\n", ip));

    Lock();
    {
        DebuggerController *p;

        p = g_controllers;
        while (p != NULL)
        {
            DebuggerController *pNext = p->m_next;

            if (p->m_thread == thread && p->m_traceCall)
            {
                bool trigger;

                if (p->m_traceCallFP == NULL)
                    trigger = true;
                else
                {
                    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
                    _ASSERTE(!ISREDIRECTEDTHREAD(thread));
                    CONTEXT tempContext;
                    ControllerStackInfo info;

                    if (context == NULL)
                        info.GetStackInfo(thread, NULL, &tempContext, FALSE);
                    else
                        info.GetStackInfo(thread, NULL, context, TRUE);

                    // This says that if the current frame is closer
                    // to the leaf than we were when we enabled trace
                    // call, then don't trigger. Put another way, this
                    // says to trigger only if the current frame is
                    // higher in the callstack (closer to main) than
                    // we were when we enabled trace call.
                    trigger = (info.m_activeFrame.fp >= p->m_traceCallFP);
                }

                if (trigger)
                {
                    used = true;

                    p->TriggerTraceCall(thread, ip);
                }
            }

            p = pNext;
        }
    }
    Unlock();

    return used;
}

//
// DispatchPossibleTraceCall is called when a UnmanagedToManaged type of stub attempts to disable preemptify GC on its
// way into the Runtime. We know one of two things if this is called: 1) its been called from StubRareDisableWorker and
// that the stub has just pushed a frame, or 2) its been called from UMThunkStubRareDisableWorker and we have a pointer
// to the UMEntryThunk that can tell us where the call is going.
//
bool DebuggerController::DispatchPossibleTraceCall(Thread *thread, UMEntryThunk *pUMEntryThunk, Frame *pFrame)
{
    // This can get called after a thread has exited, believe it or not, so we have to be sure that we've got a valid
    // thread object before continuing.
    if (thread != NULL)
    {
        LOG((LF_CORDB, LL_INFO10000, "DC::DPTC: Thread %x PossibleTraceCall\n", thread->GetThreadId()));

        // If we were passed a non-NULL pUMEntryThunk, then we know that we have a UMEntryThunk that can tell us were
        // we're going, so use it.
        if (pUMEntryThunk != NULL)
        {
            LOG((LF_CORDB, LL_INFO10000, "DC::DPTC: using UMEntryThunk 0x%08x\n", pUMEntryThunk));
            
            // Grab the managed target address.
            MethodDesc *pMD = pUMEntryThunk->GetMethod();
            
            if (pMD != NULL)
            {
                const BYTE *mt = pMD->GetAddrofCode();
                
                // Do a DispatchTraceCall if we've got a valid target.  
                if (mt != NULL)
                    return DispatchTraceCall(thread, mt);
            }   
        }
        
        // pFrame is passed in, because it may not have been installed on the thread yet

        // If the thread's got a valid frame...
        if ((pFrame != NULL) && (pFrame != FRAME_TOP))
        {
            LOG((LF_CORDB, LL_INFO10000, "DC::DPTC: got frame 0x%08x, type %d\n", pFrame, pFrame->GetFrameType()));

            // ... see what type it is. We're only interested in entry frames.
            if (pFrame->GetFrameType() == Frame::TYPE_ENTRY)
            {
                // The only entry frames are UnmanagedToManagedFrames.
                UnmanagedToManagedFrame *utmf = (UnmanagedToManagedFrame*)pFrame;

                // Grab the managed target address.
                const BYTE *mt = utmf->GetManagedTarget();

                LOG((LF_CORDB, LL_INFO10000, "DC::DPTC: frame is entry, managed target ix 0x%08x\n", mt));
                
                // Do a DispatchTraceCall if we've got a valid target.
                if (mt != NULL)
                    return DispatchTraceCall(thread, mt);
            }
        }

        LOG((LF_CORDB, LL_INFO10000, "DC::DPTC: no frame, not entry frame, or no managed target. pFrame=0x%08x\n", pFrame));
    }

    return false;
}

//
// AddProtection adds page protection to (at least) the given range of
// addresses
//

void DebuggerController::AddProtection(const BYTE *start, const BYTE *end, 
                                       bool readable)
{
    // !!! 
    _ASSERTE(!"Not implemented yet");
}

//
// RemoveProtection removes page protection from the given
// addresses. The parameters should match an earlier call to
// AddProtection
//

void DebuggerController::RemoveProtection(const BYTE *start, const BYTE *end, 
                                          bool readable)
{
    // !!! 
    _ASSERTE(!"Not implemented yet");
}

// @mfunc bool |  DebuggerController | TriggerPatch | What: Tells the
// static DC whether this patch should be activated now.
// Returns true if it should be, false otherwise.
// How: Base class implementation returns false.  Others may
// return true.
TP_RESULT DebuggerController::TriggerPatch(DebuggerControllerPatch *patch,
                                      Thread *thread, 
                                      Module *module, 
                                      mdMethodDef md, 
                                      SIZE_T offset, 
                                      BOOL managed,
                                      TRIGGER_WHY tyWhy)
{
    LOG((LF_CORDB, LL_INFO10000, "DC::TP: in default TriggerPatch\n"));
    return TPR_IGNORE;
}

bool DebuggerController::TriggerSingleStep(Thread *thread, 
                                           const BYTE *ip)
{
    LOG((LF_CORDB, LL_INFO10000, "DC::TP: in default TriggerSingleStep\n"));
    return false;
}

bool DebuggerController::TriggerPageProtection(Thread *thread, 
                                               const BYTE *ip, 
                                               const BYTE *address, 
                                               bool read)
{
    LOG((LF_CORDB, LL_INFO10000, "DC::TP: in default TriggerPageProtection\n"));
    return false;
}

void DebuggerController::TriggerUnwind(Thread *thread, 
                                       MethodDesc *fd, SIZE_T offset, 
                                       const BYTE *frame,
                                       CorDebugStepReason unwindReason)
{
    LOG((LF_CORDB, LL_INFO10000, "DC::TP: in default TriggerUnwind\n"));
}

void DebuggerController::TriggerTraceCall(Thread *thread, 
                                          const BYTE *ip)
{
    LOG((LF_CORDB, LL_INFO10000, "DC::TP: in default TriggerTraceCall\n"));
}

TP_RESULT DebuggerController::TriggerExceptionHook(Thread *thread, 
                                              EXCEPTION_RECORD *exception)
{
    LOG((LF_CORDB, LL_INFO10000, "DC::TP: in default TriggerExceptionHook\n"));
    return TPR_IGNORE;
}

void DebuggerController::SendEvent(Thread *thread)
{
    LOG((LF_CORDB, LL_INFO10000, "DC::TP: in default SendEvent\n"));
}

void DebuggerController::DoDeferedPatch(DebuggerJitInfo *pDji,
                                        Thread *pThread,
                                        void *fp)
{
    LOG((LF_CORDB, LL_INFO10000, "DC::TP: in default DoDeferedPatch\n"));
}


// @mfunc bool|DebuggerController|DispatchAccessViolation|DispatchAccessViolation 
// should be called when an access violation happens.
// The appropriate controllers will be notified.
BOOL DebuggerController::DispatchAccessViolation(Thread *thread,
                                                 CONTEXT *context, 
                                                 const BYTE *ip, 
                                                 const BYTE *address, 
                                                 bool read)
{
    return FALSE;
}


// @mfunc bool|DebuggerController|DispatchNativeException|Figures out 
// if any debugger controllers will handle
// the exception.
// DispatchNativeException should be called by the EE when a native exception
// occurs.  If it returns true, the exception was generated by a Controller and
// should be ignored.
// How: Calls DispatchExceptionHook to see if anything is
// interested in ExceptionHook, then does a switch on dwCode:
//      EXCEPTION_BREAKPOINT means invoke DispatchPatchOrSingleStep(ST_PATCH).
//      EXCEPTION_SINGLE_STEP means DispatchPatchOrSingleStep(ST_SINGLE_STEP).
//      EXCEPTION_ACCESS_VIOLATION means invoke DispatchAccessViolation.
// @access public
// @rdesc Returns true if the exception was actually meant for the debugger,
//      returns false otherwise.
bool DebuggerController::DispatchNativeException(EXCEPTION_RECORD *pException,
                                                 CONTEXT *pContext,
                                                 DWORD dwCode,
                                                 Thread *pCurThread)
{
#ifdef _X86_
    LOG((LF_CORDB, LL_INFO10000, 
         "Native exception at 0x%x\n", pContext->Eip));
#else
#ifdef _ALPHA_
    LOG((LF_CORDB, LL_INFO10000,
        "Native exception at 0x%x\n", pContext->Fir));
#endif // _ALPHA_
#endif // _X86_

    // _ASSERTE(g_pEEInterface->IsPreemptiveGCDisabled());
    _ASSERTE(pCurThread != NULL);

    CONTEXT *pOldContext = pCurThread->GetFilterContext();

    g_pEEInterface->SetThreadFilterContext(pCurThread, pContext);

    if (dwCode == EXCEPTION_BREAKPOINT &&
        g_runningOnWin95)
    {
        //
        // Note: on Windows 9x, EIP points past the breakpoint
        // opcode, while on Windows NT EIP points at the
        // breakpoint opcode. This will adjust EIP to the NT way,
        // which is the right way, so the debugger sees a
        // consistent value.
        //

        CORDbgAdjustPCForBreakInstruction(pContext);
    }

    LOG((LF_CORDB, LL_INFO10000, "DC::DNE, calling DEH...\n"));
    BOOL fDispatch = DebuggerController::DispatchExceptionHook(pCurThread,
                                                               pContext, 
                                                               pException);
    LOG((LF_CORDB, LL_INFO10000, "DC::DNE, ... DEH returned.\n"));

    BOOL result = FALSE;

    // It's possible we're here without a debugger (since we have to call the
    // patch skippers). The Debugger may detach anytime,
    // so remember the attach state now.
    bool fWasAttached = (CORDebuggerAttached() != 0);
    
    if (fDispatch)
    {
        const BYTE *ip = (const BYTE *) GetIP(pContext);

        switch (dwCode)
        {
        case EXCEPTION_BREAKPOINT:
            // Even on Win9x, EIP should be properly set up at this point.
            result = DebuggerController::DispatchPatchOrSingleStep(pCurThread, 
                                                       pContext, 
                                                       ip,
                                                       ST_PATCH);

            // If we detached, we should remove all our breakpoints. So if we try
            // to handle this breakpoint, make sure that we're attached.
            if (result) 
            {
                _ASSERTE(fWasAttached);
            }
            break;

        case EXCEPTION_SINGLE_STEP:

            result = DebuggerController::DispatchPatchOrSingleStep(pCurThread, 
                                                            pContext, 
                                                            ip,
                                        (SCAN_TRIGGER)(ST_PATCH|ST_SINGLE_STEP));
                // We pass patch | single step since single steps actually
                // do both (eg, you SS onto a breakpoint).
            break;

        case EXCEPTION_ACCESS_VIOLATION:

            result = DebuggerController::DispatchAccessViolation(pCurThread,
                                     pContext, ip, 
                                     (const BYTE *) 
                                               pException->ExceptionInformation[1],
                                       pException->ExceptionInformation[0] == 0);
            break;

        default:
            break;
        }

    }
#ifdef _DEBUG
    else
    {
        LOG((LF_CORDB, LL_INFO1000, "DC:: DNE step-around fDispatch:0x%x!\n", fDispatch));
    }
#endif //_DEBUG

    g_pEEInterface->SetThreadFilterContext(pCurThread, pOldContext);
    
    LOG((LF_CORDB, LL_INFO10000, "DC::DNE, returning.\n"));

    
    return (fDispatch?(result?true:false):true);
}

// * -------------------------------------------------------------------------
// * DebuggerPatchSkip routines
// * -------------------------------------------------------------------------

DebuggerPatchSkip::DebuggerPatchSkip(Thread *thread, 
                                     DebuggerControllerPatch *patch,
                                     AppDomain *pAppDomain)
  : DebuggerController(thread, pAppDomain), 
    m_address(patch->address)
{
    LOG((LF_CORDB, LL_INFO10000, 
         "Patch skip 0x%x\n", patch->address));

    //
    // Set up patch bypass information
    //

    SIZE_T instructionLength = sizeof(m_patchBypass);

    // Copy the instruction block over to the patch skip
    CopyInstructionBlock(m_patchBypass, patch->address,
                         instructionLength);
    
    CORDbgSetInstruction(m_patchBypass, patch->opcode);
    _ASSERTE( patch->opcode == 0 || patch->address != NULL);
    //
    // Look at instruction to get some attributes
    //
    DecodeInstruction(m_patchBypass);

    //
    // Set IP of context to point to patch bypass buffer
    //

    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
    _ASSERTE(!ISREDIRECTEDTHREAD(thread));
    CONTEXT c;

    if (context == NULL)
    {
        // We can't play with our own context!
        _ASSERTE(thread->GetThreadId() != GetCurrentThreadId());

        c.ContextFlags = CONTEXT_CONTROL;
        
        GetThreadContext(thread->GetThreadHandle(), &c);
        context = &c;
    }

#ifdef _X86_
    context->Eip = (DWORD) m_patchBypass;
#endif

    if (context == &c)
        SetThreadContext(thread->GetThreadHandle(), &c);

    LOG((LF_CORDB, LL_INFO10000, 
         "Bypass at 0x%x\n", m_patchBypass));

    //
    // Turn on single step so we can fix up state after the instruction
    // is executed.
    // Also turn on exception hook so we can adjust IP in exceptions
    //

    EnableSingleStep();
    EnableExceptionHook();
}

//
// We have to have a whole seperate function for this because you
// can't use __try in a function that requires object unwinding...
//
void DebuggerPatchSkip::CopyInstructionBlock(BYTE *to,
                                             const BYTE* from,
                                             SIZE_T len)
{
    // We wrap the memcpy in an exception handler to handle the
    // extremely rare case where we're copying an instruction off the
    // end of a method that is also at the end of a page, and the next
    // page is unmapped.
    __try
    {
        memcpy(to, from, len);
    }
    __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER :
             EXCEPTION_CONTINUE_SEARCH)
    {
        // The whole point is that if we copy up the the AV, then
        // that's enough to execute, otherwise we would not have been
        // able to execute the code anyway. So we just ignore the
        // exception.
        LOG((LF_CORDB, LL_INFO10000,
             "DPS::DPS: AV copying instruction block ignored.\n"));
    }
}

TP_RESULT DebuggerPatchSkip::TriggerPatch(DebuggerControllerPatch *patch,
                              Thread *thread, 
                              Module *module, 
                              mdMethodDef md, 
                              SIZE_T offset, 
                              BOOL managed,
                              TRIGGER_WHY tyWhy)
{
    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
    _ASSERTE(!ISREDIRECTEDTHREAD(thread));
    LOG((LF_CORDB, LL_INFO1000, "DPS::TP: We've patched 0x%x (byPass:0x%x) "
        "for a skip after an EnC update!\n", context->Eip, 
        GetBypassAddress()));
        
    _ASSERTE(g_patches != NULL);

#ifdef _DEBUG
    // We shouldn't have mucked with EIP, yet.
    _ASSERTE(context->Eip == (DWORD)GetBypassAddress());

    //We should be the _only_ patch here
    DebuggerControllerPatch *patchCheck = g_patches->
        GetPatch((const BYTE *)context->Eip);
    _ASSERTE(patchCheck == patch);
    _ASSERTE(patchCheck->controller == patch->controller);

    patchCheck = g_patches->GetNextPatch(patchCheck);
    _ASSERTE(patchCheck == NULL);
#endif // _DEBUG

    DisableAll();
    EnableExceptionHook();
    EnableSingleStep(); //gets us back to where we want.

    return TPR_IGNORE; // don't actually want to stop here....
}

TP_RESULT DebuggerPatchSkip::TriggerExceptionHook(Thread *thread, 
                                                  EXCEPTION_RECORD *exception)
{
    if (m_pAppDomain != NULL)
    {
        AppDomain *pAppDomainCur = thread->GetDomain();

        if (pAppDomainCur != m_pAppDomain)
        {
            LOG((LF_CORDB,LL_INFO10000, "DPS::TEH: Appdomain mismatch - not skiiping!\n"));
            return TPR_IGNORE;
        }
    }

    LOG((LF_CORDB,LL_INFO10000, "DPS::TEH: doing the patch-skip thing\n"));

    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
    _ASSERTE(!ISREDIRECTEDTHREAD(thread));
    CONTEXT c;

    if (context == NULL)
    {
        // We can't play with our own context!
        _ASSERTE(thread->GetThreadId() != GetCurrentThreadId());

        c.ContextFlags = CONTEXT_CONTROL;
        
        GetThreadContext(thread->GetThreadHandle(), &c);
        context = &c;
    }


    if (m_isCall && exception->ExceptionCode == EXCEPTION_SINGLE_STEP)
    {
        // Fixup return address on stack

#ifdef _X86_
        DWORD *sp = (DWORD *) context->Esp;

        LOG((LF_CORDB, LL_INFO10000, 
             "Bypass call return address redirected from 0x%x\n", *sp));

        *sp -= m_patchBypass - m_address;

        LOG((LF_CORDB, LL_INFO10000, "to 0x%x\n", *sp));

#endif
    }

    if (exception->ExceptionCode != EXCEPTION_SINGLE_STEP || !m_isAbsoluteBranch)
    {
        // Fixup IP

#ifdef _X86_
        LOG((LF_CORDB, LL_INFO10000, "Bypass instruction redirected from 0x%x\n", context->Eip));

    
        if (exception->ExceptionCode == EXCEPTION_SINGLE_STEP)
        {
            // If we're on NT, then check if the current IP is anywhere near the exception dispatcher logic.
            // If it is, ignore the exception, as the real exception is coming next.
            if (RunningOnWinNT())
            {
                static FARPROC pExcepDispProc = NULL;

                if (!pExcepDispProc)
                {
                    HMODULE hNtDll = WszGetModuleHandle(L"ntdll.dll");

                    if (hNtDll != NULL)
                    {
                        pExcepDispProc = GetProcAddress(hNtDll, "KiUserExceptionDispatcher");

                        if (!pExcepDispProc)
                            pExcepDispProc = (FARPROC)0xFFFFFFFF;
                    }
                    else
                        pExcepDispProc = (FARPROC)0xFFFFFFFF;
                }

                _ASSERTE(pExcepDispProc != NULL);

                if ((DWORD)pExcepDispProc != 0xFFFFFFFF &&
                    context->Eip > (DWORD)pExcepDispProc &&
                    context->Eip <= ((DWORD)pExcepDispProc + MAX_INSTRUCTION_LENGTH * 2 + 1))
                {
                    LOG((LF_CORDB, LL_INFO10000, "Bypass instruction not redirected. Landed in exception dispatcher.\n"));
                    return (TPR_IGNORE_STOP);
                }
            }

            // If the IP is close to the skip patch start, or if we were skipping over a call, then assume the IP needs
            // adjusting.
            if (m_isCall ||
                (context->Eip > (DWORD)m_patchBypass && context->Eip <= (DWORD)(m_patchBypass + MAX_INSTRUCTION_LENGTH + 1)))
            {
                LOG((LF_CORDB, LL_INFO10000, "Bypass instruction redirected because still in skip area.\n"));
                context->Eip -= m_patchBypass - m_address;
            }
            else
            {
                // Otherwise, need to see if the IP is managed code - if not, we ignore the exception
                DWORD newIP = context->Eip;
                newIP -= m_patchBypass - m_address;

                if (!IsBadReadPtr((const VOID *)newIP, sizeof(BYTE)) &&
                    g_pEEInterface->IsManagedNativeCode((const BYTE *)newIP))
                {
                    LOG((LF_CORDB, LL_INFO10000, "Bypass instruction redirected because we landed in managed code\n"));
                    context->Eip = newIP;
                }

                // If we have no idea where things have gone, then we assume that the IP needs no adjusting (which
                // could happen if the instruction we were trying to patch skip caused an AV).  In this case we want
                // to claim it as ours but ignore it and continue execution.
                else
                {
                    LOG((LF_CORDB, LL_INFO10000, "Bypass instruction not redirected because we're not in managed code.\n"));
                    return (TPR_IGNORE_STOP);
            }
        }
        }
        else
        {
            LOG((LF_CORDB, LL_INFO10000, "Bypass instruction redirected because it wasn't a single step exception.\n"));
            context->Eip -= m_patchBypass - m_address;
        }
    
        _ASSERTE(!IsBadReadPtr((const VOID *)context->Eip, 1));
    
        LOG((LF_CORDB, LL_INFO10000, "to 0x%x\n", context->Eip));
    
#elif defined(_ALPHA_)
        LOG((LF_CORDB, LL_INFO10000, "Bypass instruction redirected from 0x%x\n", context->Fir));
        context->Fir -= m_patchBypass - m_address;
        LOG((LF_CORDB, LL_INFO10000, "to 0x%x\n", context->Fir));
#endif // _X86_

        if (context == &c)
            SetThreadContext(thread->GetThreadHandle(), &c);
    }

    // Don't delete the controller yet if this is a single step exception, as the code will still want to dispatch to
    // our single step method, and if it doesn't find something to dispatch to we won't continue from the exception.
    //
    // (This is kind of broken behavior but is easily worked around here
    // by this test)
    if (exception->ExceptionCode != EXCEPTION_SINGLE_STEP)
        Delete();

    DisableExceptionHook();

    return TPR_TRIGGER;
}

bool DebuggerPatchSkip::TriggerSingleStep(Thread *thread, const BYTE *ip)
{
    LOG((LF_CORDB,LL_INFO10000, "DPS::TSS: basically a no-op\n"));

    if (m_pAppDomain != NULL)
    {
        AppDomain *pAppDomainCur = thread->GetDomain();

        if (pAppDomainCur != m_pAppDomain)
        {
            LOG((LF_CORDB,LL_INFO10000, "DPS::TSS: Appdomain mismatch - "
                "not SingSteping!!\n"));
            return false;
        }
    }

    LOG((LF_CORDB,LL_INFO10000, "DPS::TSS: triggered, about to delete\n"));
    TRACE_FREE(this);
    Delete();
    return false;
}

void DebuggerPatchSkip::DecodeInstruction(const BYTE *address)
{
#ifdef _X86_

    //
    // Skip instruction prefixes
    //

    LOG((LF_CORDB, LL_INFO10000, "Patch decode: "));

    do 
    {
        switch (*address)
        {
        // Segment overrides
        case 0x26: // ES
        case 0x2E: // CS
        case 0x36: // SS
        case 0x3E: // DS 
        case 0x64: // FS
        case 0x65: // GS

        // Size overrides
        case 0x66: // Operand-Size
        case 0x67: // Address-Size

        // Lock
        case 0xf0:

        // String REP prefixes
        case 0xf1:
        case 0xf2: // REPNE/REPNZ
        case 0xf3: 
            LOG((LF_CORDB, LL_INFO10000, "prefix:%0.2x ", *address));
            address++;
            continue;

        default:
            break;
        }
    } while (0);

    //
    // Look at opcode to tell if it's a call or an
    // absolute branch.
    //

    m_isCall = false;
    m_isAbsoluteBranch = false;

    switch (*address)
    {
    case 0xEA: // JMP far
    case 0xC2: // RET
    case 0xC3: // RET N
        m_isAbsoluteBranch = true;
        LOG((LF_CORDB, LL_INFO10000, "ABS:%0.2x\n", *address));
        break;

    case 0xE8: // CALL relative
        m_isCall = true;
        LOG((LF_CORDB, LL_INFO10000, "CALL REL:%0.2x\n", *address));
        break;

    case 0xA2: // CALL absolute
    case 0xC8: // ENTER
        m_isCall = true;
        m_isAbsoluteBranch = true;
        LOG((LF_CORDB, LL_INFO10000, "CALL ABS:%0.2x\n", *address));
        break;

    case 0xFF: // CALL/JMP modr/m

        //
        // Read opcode modifier from modr/m
        //

        switch ((address[1]&0x38)>>3)
        {
        case 2:
        case 3:
            m_isCall = true;
            // fall through
        case 4:
        case 5:
            m_isAbsoluteBranch = true;
        }
        LOG((LF_CORDB, LL_INFO10000, "CALL/JMP modr/m:%0.2x\n", *address));
        break;

    default:
        LOG((LF_CORDB, LL_INFO10000, "NORMAL:%0.2x\n", *address));
    }
#endif
}


// * -------------------------------------------------------------------------
// * DebuggerBreakpoint routines
// * -------------------------------------------------------------------------
// @mfunc NONE | DebuggerBreakpoint | DebuggerBreakpoint | The constructor
// invokes AddPatch to set the breakpoint if fAddPatchImmediately is true
// (this is the common case), or stores the value away for later use by
// DoDeferedPatch (if we've EnC'd a method, but we haven't actually hit an
// EnC BP in that method, and someone tries to put a BP in that method,
// since what they mean is to put a bp in that method AFTER the EnC
// takes place, we'll defer actually doing the AddPatch till then).
DebuggerBreakpoint::DebuggerBreakpoint(Module *module, 
                                       mdMethodDef md, 
                                       AppDomain *pAppDomain,
                                       SIZE_T offset, 
                                       bool native, 
                                       DebuggerJitInfo *dji,
                                       BOOL *pSucceed,
                                       BOOL fDeferBinding)
  : DebuggerController(NULL, pAppDomain) 
{
    _ASSERTE(pSucceed != NULL);

    if (fDeferBinding)
    {
        m_module = module;
        m_md = md;
        m_offset = offset;
        m_native = native; 
        m_dji = dji;
        (*pSucceed) = TRUE; // may or may not work, but we can't know it doesn't, now
    }
    else
        (*pSucceed) = AddPatch(module, 
                               md, 
                               offset, 
                               native, 
                               NULL, 
                               dji, 
                               TRUE);
}

void DebuggerBreakpoint::DoDeferedPatch(DebuggerJitInfo *pDji,
                                        Thread *pThread,
                                        void *fp)
{
    _ASSERTE(m_module != NULL);
    _ASSERTE(m_md != NULL);
    _ASSERTE(m_dji != NULL);
    HRESULT hr = S_OK;

    LOG((LF_CORDB, LL_INFO100000,
         "DB::DDP: Breakpoint 0x%x, added after "
         "EnC is now being processed\n", this));
    
    if (m_native)
    {
        CorDebugMappingResult map;
        SIZE_T which;
        
        m_offset = m_dji->MapNativeOffsetToIL(m_offset, &map, &which);
        m_native = false;
    }
    _ASSERTE(!m_native);

    // Since the defered patches were placed relative to the 'next'
    // version, we should only do this map-forwards if it's a couple of 
    // versions behind.
    if (m_dji->m_nextJitInfo != NULL &&
        m_dji->m_nextJitInfo != pDji)
    {
        BOOL fAccurateIgnore; // @todo Debugger will eventuall do this for us.
        hr = g_pDebugger->MapThroughVersions(m_offset,
                                             m_dji->m_nextJitInfo, 
                                             &m_offset, 
                                             pDji, 
                                             TRUE,
                                             &fAccurateIgnore);
    }
    
    if (hr == S_OK)
    {
        AddPatch(m_module, 
                 m_md, 
                 m_offset, 
                 m_native, 
                 NULL, 
                 pDji, 
                 TRUE);
    }
}


// @mfunc bool | DebuggerBreakpoint | TriggerPatch |
// What: This patch will always be activated.
// How: return true.
TP_RESULT DebuggerBreakpoint::TriggerPatch(DebuggerControllerPatch *patch,
                                      Thread *thread,
                                      Module *module, 
                                      mdMethodDef md, 
                                      SIZE_T offset, 
                                      BOOL managed,
                                      TRIGGER_WHY tyWhy)
{
    LOG((LF_CORDB, LL_INFO10000, "DB::TP\n"));

    return TPR_TRIGGER;
}

// @mfunc void | DebuggerBreakpoint | SendEvent | What: Inform
// the right side that the breakpoint was reached.
// How: g_pDebugger->SendBreakpoint()
void DebuggerBreakpoint::SendEvent(Thread *thread)
{
    LOG((LF_CORDB, LL_INFO10000, "DB::SE: in DebuggerBreakpoint's SendEvent\n"));

    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);

    g_pDebugger->SendBreakpoint(thread, context, this);
}

//* -------------------------------------------------------------------------
// * DebuggerStepper routines
// * -------------------------------------------------------------------------

DebuggerStepper::DebuggerStepper(Thread *thread,
                                 CorDebugUnmappedStop rgfMappingStop,
                                 CorDebugIntercept interceptStop,
                                 AppDomain *appDomain)
  : DebuggerController(thread, appDomain), 
    m_stepIn(false), 
    m_range(NULL), 
    m_rangeCount(0),
    m_realRangeCount(0),
    m_fp(NULL),
    m_reason(STEP_NORMAL), 
    m_rgfMappingStop(rgfMappingStop),
    m_rgfInterceptStop(interceptStop), 
    m_fpException(0),
    m_fdException(0), 
    m_djiVersion(NULL),
    m_fpStepInto(NULL),
    m_rgStepRanges(NULL),
    m_cStepRanges(0),
    m_djiSource(NULL)
{
}

DebuggerStepper::~DebuggerStepper()
{
    if (m_range != NULL)
    {
        TRACE_FREE(m_range);
        DeleteInteropSafe(m_range);
    }
}

//@mfunc bool | DebuggerStepper | ShouldContinueStep | Return true if
// the stepper should not stop at this address.  The stepper should not
// stop here if: here is in the {prolog,epilog,etc};
// and the stepper is interested in stopping here.
// We assume that this is being called in the frame which the stepper steps
// through.  Unless, of course, we're returning from a call, in which
// case we want to stop in the epilog even if the user didn't say so,
// to prevent stepping out of multiple frames at once.
// @comm Possible optimization: GetJitInfo, then AddPatch @ end of prolog?
bool DebuggerStepper::ShouldContinueStep( ControllerStackInfo *info,
                                          SIZE_T nativeOffset)
{    
    if (m_rgfMappingStop != STOP_ALL && (m_reason != STEP_EXIT) )
    {

        DebuggerJitInfo *ji = g_pDebugger->GetJitInfo(info->m_activeFrame.md,
                (const BYTE*)*info->m_activeFrame.registers.pPC);
        if ( ji != NULL )
        {
            LOG((LF_CORDB,LL_INFO10000,"DeSt::ShCoSt: For code 0x%x, got "
            "DJI 0x%x, from 0x%x to 0x%x\n",
            (const BYTE*)*info->m_activeFrame.registers.pPC, 
            ji, ji->m_addrOfCode, ji->m_addrOfCode+ji->m_sizeOfCode));
        }
        else
        {
            LOG((LF_CORDB,LL_INFO10000,"DeSt::ShCoSt: For code 0x%x, didn't "
                "get DJI\n",(const BYTE*)*info->m_activeFrame.registers.pPC));

            return false; // Haven't a clue if we should continue, so
                          // don't
        }
        
        CorDebugMappingResult map;    
        DWORD whichIDontCare;
        DWORD irrelvantILOffset = ji->MapNativeOffsetToIL( nativeOffset,
                                                            &map,
                                                            &whichIDontCare);
        unsigned int interestingMappings =
            (map & ~(MAPPING_APPROXIMATE | MAPPING_EXACT));
    
        LOG((LF_CORDB,LL_INFO10000, 
             "DeSt::ShContSt: interestingMappings:0x%x m_rgfMappingStop%x\n",
             interestingMappings,m_rgfMappingStop));

        // If we're in a prolog,epilog, then we may want to skip
        // over it or stop
        if ( interestingMappings )
        {
            if ( interestingMappings & m_rgfMappingStop )
                return false;
            else
                return true;
        }
    }
    return false;
}


// @mfunc bool | DebuggerStepper | IsInRange | Given the native offset ip,
// returns true if ip falls within any of the native offset ranges specified
// by the array of COR_DEBUG_STEP_RANGEs.
// @rdesc Returns true if ip falls within any of the ranges.  Returns false
// if ip doesn't, or if there are no ranges (rangeCount==0). Note that a
// COR_DEBUG_STEP_RANGE with an endOffset of zero is interpreted as extending
// from startOffset to the end of the method.
// @parm SIZE_T|ip|Native offset, relative to the beginning of the method.
// @parm COR_DEBUG_STEP_RANGE *|range|An array of ranges, which are themselves
//      native offsets, to compare against ip.
// @parm SIZE_T|rangeCount|Number of elements in range
bool DebuggerStepper::IsInRange(SIZE_T ip,
            COR_DEBUG_STEP_RANGE *range, SIZE_T rangeCount)
{
    LOG((LF_CORDB,LL_INFO10000,"DS::IIR: off=0x%x\n", ip));
    
    COR_DEBUG_STEP_RANGE *r = range;
    COR_DEBUG_STEP_RANGE *rEnd = r + rangeCount;

    while (r < rEnd)
    {
        SIZE_T endOffset = r->endOffset ? r->endOffset : ~0;
        LOG((LF_CORDB,LL_INFO100000,"DS::IIR: so=0x%x, eo=0x%x\n",
             r->startOffset, endOffset));
        
        if (ip >= r->startOffset && ip < endOffset)
        {
            LOG((LF_CORDB,LL_INFO1000,"DS::IIR:this:0x%x Found native offset "
                "0x%x to be in the range"
                "[0x%x, 0x%x), index 0x%x\n\n", this, ip, r->startOffset, 
                endOffset, ((r-range)/sizeof(COR_DEBUG_STEP_RANGE *)) ));
            return true;
        }
        
        r++;
    }

    LOG((LF_CORDB,LL_INFO10000,"DS::IIR: not in range\n"));
    return false;
}

//@mfunc bool | DebuggerStepper | DetectHandleInterceptors | Return true if
// the current execution takes place within an interceptor (that is, either
// the current frame, or the parent frame is a framed frame whose
// GetInterception method returns something other than INTERCEPTION_NONE),
// and this stepper doesn't want to stop in an interceptor, and we successfully
// set a breakpoint after the top-most interceptor in the stack.
bool DebuggerStepper::DetectHandleInterceptors(ControllerStackInfo *info)
{
    LOG((LF_CORDB,LL_INFO10000,"DS::DHI: Start DetectHandleInterceptors\n"));
    LOG((LF_CORDB,LL_INFO10000,"DS::DHI: active frame=0x%08x, has return frame=%d, return frame=0x%08x m_reason:%d\n",
         info->m_activeFrame.frame, info->HasReturnFrame(), info->m_returnFrame.frame, m_reason));

    // If this is a normal step, then we want to continue stepping, even if we
    // are in an interceptor.
    if (m_reason == STEP_NORMAL || m_reason == STEP_RETURN || m_reason == STEP_EXCEPTION_HANDLER)
    {
        LOG((LF_CORDB,LL_INFO1000,"DS::DHI: Returning false while stepping within function, finally!\n"));
        return false;
    }

    CorDebugIntercept intFrame = INTERCEPT_NONE;
    bool fAttemptStepOut = false;

    if (m_rgfInterceptStop != INTERCEPT_ALL) // we may have to skip out of one
    {    
        if (info->m_activeFrame.frame != NULL &&
            info->m_activeFrame.frame != FRAME_TOP &&
            info->m_activeFrame.frame->GetInterception() != Frame::INTERCEPTION_NONE)
        {
            if (!((CorDebugIntercept)info->m_activeFrame.frame->GetInterception() & Frame::Interception(m_rgfInterceptStop)))
            {
                LOG((LF_CORDB,LL_INFO10000,"DS::DHI: Stepping out b/c of excluded frame type:0x%x\n",
                     info->m_returnFrame. frame->GetInterception()));
                
                fAttemptStepOut = true;
            }               
            else
            {
                LOG((LF_CORDB,LL_INFO10000,"DS::DHI: 0x%x set to STEP_INTERCEPT\n", this));

                m_reason = STEP_INTERCEPT; //remember why we've stopped
            }
        }

        if ((m_reason == STEP_EXCEPTION_FILTER) ||
            (info->HasReturnFrame() && 
            info->m_returnFrame.frame != NULL &&
            info->m_returnFrame.frame != FRAME_TOP &&
             info->m_returnFrame.frame->GetInterception() != Frame::INTERCEPTION_NONE))
        {
            if (m_reason == STEP_EXCEPTION_FILTER)
            {
                // Exceptions raised inside of the EE by COMPlusThrow, FCThrow, etc will not
                // insert an ExceptionFrame, and hence info->m_returnFrame.frame->GetInterception()
                // will not be accurate. Hence we use m_reason instead

                if (!(Frame::INTERCEPTION_EXCEPTION & Frame::Interception(m_rgfInterceptStop)))
        {
                    LOG((LF_CORDB,LL_INFO10000,"DS::DHI: Stepping out b/c of excluded INTERCEPTION_EXCEPTION\n"));
                    
                    fAttemptStepOut = true;
                }
            }
            else if (!(info->m_returnFrame.frame->GetInterception() & Frame::Interception(m_rgfInterceptStop)))
            {
                LOG((LF_CORDB,LL_INFO10000,"DS::DHI: Stepping out b/c of excluded return frame type:0x%x\n",
                     info->m_returnFrame.frame->GetInterception()));
                
                fAttemptStepOut = true;
            }

            if (!fAttemptStepOut)
            {
                LOG((LF_CORDB,LL_INFO10000,"DS::DHI 0x%x set to STEP_INTERCEPT\n", this));
                
                m_reason = STEP_INTERCEPT; //remember why we've stopped
            }
        }
        else if (info->m_specialChainReason != CHAIN_NONE)
        {
            if(!(info->m_specialChainReason & CorDebugChainReason(m_rgfInterceptStop)) )
            {
                LOG((LF_CORDB,LL_INFO10000, "DS::DHI: (special) Stepping out b/c of excluded return frame type:0x%x\n",
                     info->m_specialChainReason));
                
                fAttemptStepOut = true;
            }
            else
            {
                LOG((LF_CORDB,LL_INFO10000,"DS::DHI 0x%x set to STEP_INTERCEPT\n", this));
                
                m_reason = STEP_INTERCEPT; //remember why we've stopped
            }
        }
    }

    if (fAttemptStepOut)
    {
        LOG((LF_CORDB,LL_INFO1000,"DS::DHI: Doing TSO!\n"));

        // TrapStepOut could alter the step reason if we're stepping out of an inteceptor and it looks like we're
        // running off the top of the program. So hold onto it here, and if our step reason becomes STEP_EXIT, then
        // reset it to what it was.
        CorDebugStepReason holdReason = m_reason;
        
        TrapStepOut(info);
        EnableUnwind(m_fp);            

        if (m_reason == STEP_EXIT)
            m_reason = holdReason;
        
        return true;
    }

    // We're not in a special area of code, so we don't want to continue unless some other part of the code decides that
    // we should.
    LOG((LF_CORDB,LL_INFO1000,"DS::DHI: Returning false, finally!\n"));
    
    return false;   
}

bool DebuggerStepper::TrapStepInto(ControllerStackInfo *info, 
                                   const BYTE *ip, 
                                   TraceDestination *pTD)
{
    _ASSERTE( pTD != NULL );
    EnableTraceCall(NULL);
    m_fpStepInto = max(info->m_activeFrame.fp, m_fpStepInto);

    LOG((LF_CORDB, LL_INFO1000, "Ds::TSI this:0x%x m_fpStepInto:0x%x\n",
        this, m_fpStepInto));

    TraceDestination trace;

    if (!g_pEEInterface->TraceStub(ip, &trace)
        || !g_pEEInterface->FollowTrace(&trace))
    {
        return false;
    }

    
    (*pTD) = trace; //bitwise copy
    return PatchTrace(&trace, 
                      info->m_activeFrame.fp,
                      (m_rgfMappingStop&STOP_UNMANAGED)?(true):(false));
}

//@mfunc bool | DebuggerStepper | TrapStep | TrapStep attepts to set a
// patch at the next IL instruction to be executed.  If we're stepping in &
// the next IL instruction is a call, then this'll set a breakpoint inside
// the code that will be called.
// How: There are a number of cases, depending on where the IP
// currently is:
// Unmanaged code: EnableTraceCall() & return false - try and get
// it when it returns.
// In a frame: if the <p in> param is true, then do an
// EnableTraceCall().  If the frame isn't the top frame, also do
// g_pEEInterface->TraceFrame(), g_pEEInterface->FollowTrace, and
// PatchTrace.
// Normal managed frame: create a Walker (currently, only an
// x86Walker), and walk the instructions until either leave the provided
// range (AddPatch there, return true), or we don't know what the next
// instruction is (say, after a call, or return, or branch - return false).
// @rdesc A boolean indicating if we were able to set a patch successfully
// in either this method, or (if in == true & the next instruction is a call)
// inside a callee method.
// @flag true | Patch successfully placed either in this method or a callee,
// so the stepping is taken care of.
// @flag false | Unable to place patch in either this method or any
// applicable callee methods, so the only option the caller has to put
// patch to control flow is to call TrapStepOut & try and place a patch
// on the method that called the current frame's method.
bool DebuggerStepper::TrapStep(ControllerStackInfo *info, bool in)
{
    LOG((LF_CORDB,LL_INFO10000,"DS::TS: this:0x%x\n", this));

    if (!info->m_activeFrame.managed)
    {
        // 
        // We're not in managed code.  Patch up all paths back in.
        //

        LOG((LF_CORDB,LL_INFO10000, "DS::TS: not in managed code\n"));   
        
        if (in)
            EnableTraceCall(NULL);

        return false;
    }

    if (info->m_activeFrame.frame != NULL)
    {

        LOG((LF_CORDB,LL_INFO10000, "DS::TS: in a weird frame\n"));
        //
        // We're in some kind of weird frame.  Patch further entry to the frame.
        // or if we can't, patch return from the frame
        //

        LOG((LF_CORDB,LL_INFO10000, "DS::TS: in a weird frame\n"));

        if (in)
        {
            EnableTraceCall(NULL);

            if (info->m_activeFrame.frame != FRAME_TOP)
            {
                TraceDestination trace;
                if (g_pEEInterface->TraceFrame(GetThread(), 
                                               info->m_activeFrame.frame, 
                                               FALSE, &trace,
                                               &(info->m_activeFrame.registers))
                    && g_pEEInterface->FollowTrace(&trace)
                    && PatchTrace(&trace, info->m_activeFrame.fp, 
                                  (m_rgfMappingStop&STOP_UNMANAGED)?
                                    (true):(false)))
                                    
                {
                    return true;
                }
            }
        }

        return false;
    }

    // This is really annoying - code anywhere, even in the stack can be 
    // pitched, and so we have to check against ji->m_codePitched.  
    // Most importantly, we need this info 
    // so that we don't try and set a breakpoint at the absolute
    // address of a formerly JITted method
    //
    // Note that if we're attaching, all bets are off here....

    LOG((LF_CORDB,LL_INFO1000, "GetJitInfo for pc = 0x%x (addr of "
        "that value:0x%x)\n", (const BYTE*)*info->m_activeFrame.registers.pPC,
        info->m_activeFrame.registers.pPC));

    // Note: we used to pass in the IP from the active frame to GetJitInfo, but there seems to be no value in that, and
    // it was causing problems creating a stepper while sitting in ndirect stubs after we'd returned from the unmanaged
    // function that had been called.
    DebuggerJitInfo *ji = g_pDebugger->GetJitInfo(info->m_activeFrame.md, NULL);

    if( ji != NULL )
    {
        LOG((LF_CORDB,LL_INFO10000,"DeSt::TrSt: For code 0x%x, got DJI 0x%x, "
            "from 0x%x to 0x%x\n",
            (const BYTE*)*info->m_activeFrame.registers.pPC, 
            ji, ji->m_addrOfCode, ji->m_addrOfCode+ji->m_sizeOfCode));
    }
    else
    {
        LOG((LF_CORDB,LL_INFO10000,"DeSt::TrSt: For code 0x%x, "
            "didn't get a DJI \n",
            (const BYTE*)*info->m_activeFrame.registers.pPC));
    }


    if (ji != NULL && ji->m_codePitched)
    {
        // This will actually set a patch at the next instruction to execute,
        // so that we'll hit this before executing the next instruction,
        // and then deal w/ the situation once there's actual code around.
        LOG((LF_CORDB,LL_INFO1000,"DS::TS: this:0x%x,Pitched "
            "code, so doing AddPatch by offset", this));
        AddPatch(info->m_activeFrame.md, 
                 info->m_activeFrame.relOffset,
                 TRUE,
                 info->m_activeFrame.fp, 
                 ji, 
                 NULL);
            
        m_rangeCount = m_realRangeCount;
        m_range[m_rangeCount].startOffset = info->m_activeFrame.relOffset;
        m_range[m_rangeCount].endOffset = info->m_activeFrame.relOffset+1;
            //+1 for boundary check in IsInRange
        m_realRangeCount = m_rangeCount++;
        
        return true;
    }
    
    //
    // We're in a normal managed frame - walk the code
    //

    Walker *walker;

    // !!! Eventually when using the fjit, we'll want
    // to walk the IL to get the next location, & then map 
    // it back to native.
    
#ifdef _X86_
    x86Walker x86walker(&info->m_activeFrame.registers);
    walker = &x86walker;
#endif

    // What's the differnce between this and
    //info->m_activeFrame.registers.pContext->Eip?
    walker->SetIP((BYTE*)*info->m_activeFrame.registers.pPC);

    // If m_activeFrame is not the actual active frame,
    // we should skip this first switch - never single step, and
    // assume our context is bogus.
    TraceDestination td; 
    const BYTE *codeStart = NULL;
    const BYTE *codeEnd = NULL;
    
    if (info->m_activeFrame.fp == info->m_bottomFP)
    {
        LOG((LF_CORDB,LL_INFO10000, "DC::TS: immediate?\n"));

        // Note that by definition our walker must always be able to step 
        // through a single instruction, so any return
        // of NULL IP's from those cases on the first step 
        // means that an exception is going to be generated.
        //
        // (On future steps, it can also mean that the destination
        // simply can't be computed.)
        WALK_TYPE wt = walker->GetOpcodeWalkType();
        bool fDone;
        do
        {
            fDone = true;
            switch (wt)
            {
            case WALK_RETURN:
                {
                    LOG((LF_CORDB,LL_INFO10000, "DC::TS:Imm:WALK_RETURN\n"));
                    
                    // In some cases (ie, finally's), we'll 'return' to
                    // some other point in the same frame, so turn this into
                    // a single step instead.

                    void * EspAfterReturn = (void*)(info->m_activeFrame.registers.Esp
                                                    + sizeof(void*)); // return will pop atleast the return address off the stack
                    if (info->m_activeFrame.fp > EspAfterReturn)
                    {
                        LOG((LF_CORDB,LL_INFO10000,"DS::TS: intramethod return in fp:0x%08x with Esp:0x%08x\n",
                             info->m_activeFrame.fp, info->m_activeFrame.registers.Esp));
#ifdef _DEBUG
                        const BYTE *returnTo = *(BYTE**)info->m_activeFrame.registers.Esp;
                        _ASSERTE(IsAddrWithinMethod(ji, info->m_activeFrame.md, returnTo));
#endif
                        fDone = false;
                        wt = WALK_UNKNOWN;
                        continue;
                    }
                    else
                    {
                        //we should note the reason for the step now
                        LOG((LF_CORDB,LL_INFO10000,"DS::TS: 0x%x m_reason = "
                            "STEP_RETURN\n",this));
                        m_reason = STEP_RETURN;
                        
                        return false;
                    }
                }
                
            case WALK_BRANCH:
                // A branch can be handled just like a call. If the branch is within the current method, then we just
                // down to LWALK_UNKNOWN, otherwise we handle it just like a call.  Note: we need to force in=true
                // because for a jmp, in or over is the same thing, we're still going there, and the in==true case is
                // the case we want to use...
                in = true;

                // fall through...
                
            case WALK_CALL:
                LOG((LF_CORDB,LL_INFO10000, "DC::TS:Imm:WALK_CALL\n"));
                    
                // If we're doing some sort of intra-method jump (usually, to get EIP in a clever way, via the CALL
                // instruction), then put the bp where we're going, NOT at the instruction following the call
                if (IsAddrWithinMethod(ji, info->m_activeFrame.md, walker->GetNextIP()))
                {
                    LOG((LF_CORDB, LL_INFO1000, "Walk call within method!" ));
                    goto LWALK_UNKNOWN;
                }

                if (in
                    && walker->GetNextIP() != NULL
                    && TrapStepInto(info, walker->GetNextIP(), &td))
                {
                    if (td.type == TRACE_MANAGED )
                    {
                        // Possible optimization: Roll all of g_pEEInterface calls into 
                        // one function so we don't repeatedly get the CodeMan,etc
                        MethodDesc *md = NULL;
                        _ASSERTE( g_pEEInterface->IsManagedNativeCode(td.address) );
                        md = g_pEEInterface->GetNativeCodeMethodDesc(td.address);
                
                        if ( g_pEEInterface->GetNativeAddressOfCode(md) == td.address ||
                             g_pEEInterface->GetFunctionAddress(md) == td.address)
                        {
                            LOG((LF_CORDB,LL_INFO1000,"\tDS::TS 0x%x m_reason = STEP_CALL"
                                 "@ip0x%x\n", this,
                                 (BYTE*)*info->m_activeFrame.registers.pPC));
                            m_reason = STEP_CALL;
                        }
                        else
                        {
                            LOG((LF_CORDB, LL_INFO1000, "Didn't step: md:0x%x"
                                 "td.type:%s td.address:0x%x,  gnaoc:0x%x gfa:0x%x\n",
                                 md, GetTType(td.type), td.address, 
                                 g_pEEInterface->GetNativeAddressOfCode(md),
                                 g_pEEInterface->GetFunctionAddress(md)));
                        }
                    }
                    else
                    {
                        LOG((LF_CORDB,LL_INFO10000,"DS::TS else 0x%x m_reason = STEP_CALL\n",
                             this));
                        m_reason = STEP_CALL;
                    }
                    
                    return true;
                }
                if (walker->GetSkipIP() == NULL)
                {
                    LOG((LF_CORDB,LL_INFO10000,"DS::TS 0x%x m_reason = STEP_CALL (skip)\n",
                         this));
                    m_reason = STEP_CALL;
                    
                    return true;
                }

                walker->Skip();
                break;

            case WALK_UNKNOWN:
    LWALK_UNKNOWN:
                LOG((LF_CORDB,LL_INFO10000,"DS::TS:WALK_UNKNOWN - curIP:0x%x "
                    "nextIP:0x%x skipIP:0x%x 1st byte of opcode:0x%x\n", (BYTE*)*info->m_activeFrame.
                    registers.pPC, walker->GetNextIP(),walker->GetSkipIP(),
                    *(BYTE*)*info->m_activeFrame.registers.pPC));

                EnableSingleStep();
                return true;
                
            default:
                if (walker->GetNextIP() == NULL)
                    return true;

                walker->Next();
            }
        } while (!fDone);
    }

    const BYTE *codeBase;
    if (ji != NULL && ji->m_addrOfCode != NULL)
        codeBase = (const BYTE *)ji->m_addrOfCode;
    else
        codeBase = g_pEEInterface->GetFunctionAddress(info->m_activeFrame.md);
    _ASSERTE(codeBase != NULL);
    
    //
    // Use our range, if we're in the original
    // frame.
    //

    COR_DEBUG_STEP_RANGE    *range;
    SIZE_T                  rangeCount;

    if (info->m_activeFrame.fp == m_fp)
    {
        range = m_range;
        rangeCount = m_rangeCount;
    }
    else
    {
        range = NULL;
        rangeCount = 0;
    }
        
    //
    // Keep walking until either we're out of range, or
    // else we can't predict ahead any more.
    //

    while (TRUE)
    {
        codeStart = NULL;
        codeEnd = NULL;
        const BYTE *ip = walker->GetIP();

        SIZE_T offset = ip - codeBase;

        LOG((LF_CORDB, LL_INFO1000, "Walking to ip 0x%x (natOff:0x%x)\n",ip,offset));
            
        if (!IsInRange(offset, range, rangeCount)
            && !ShouldContinueStep( info, offset ))
        {
            AddPatch(info->m_activeFrame.md, 
                     offset,
                     TRUE, 
                     info->m_returnFrame.fp, 
                     ji,
                     NULL);
            return true;
        }

        switch (walker->GetOpcodeWalkType())
        {
        case WALK_RETURN:
            // In the loop above, if we're at the return address, we'll check & see
            // if we're returning to elsewhere within the same method, and if so,
            // we'll single step rather than TrapStepOut. If we see a return in the
            // code stream, then we'll set a breakpoint there, so that we can 
            // examine the return address, and decide whether to SS or TSO then
            AddPatch(info->m_activeFrame.md, 
                     offset,
                     TRUE, 
                     info->m_returnFrame.fp, 
                     ji,
                     NULL);
            return true;

        case WALK_CALL:
            // If we're doing some sort of intra-method jump (usually, to get EIP in a clever way, via the CALL
            // instruction), then put the bp where we're going, NOT at the instruction following the call
            if (IsAddrWithinMethod(ji, info->m_activeFrame.md, walker->GetNextIP()))
            {
                // How else to detect this?
                AddPatch(info->m_activeFrame.md, 
                         walker->GetNextIP() - codeBase, 
                         TRUE, 
                         info->m_returnFrame.fp, 
                         ji, 
                         NULL);
                return true;
            }
            
            if (in)
            {
                if (walker->GetNextIP() == NULL)
                {
                    AddPatch(info->m_activeFrame.md, 
                             offset,
                             TRUE, 
                             info->m_returnFrame.fp, 
                             ji, 
                             NULL);

                    LOG((LF_CORDB,LL_INFO10000,"DS0x%x m_reason=STEP_CALL 2\n",
                         this));
                    m_reason = STEP_CALL;
                    
                    return true;
                }

                if (TrapStepInto(info, walker->GetNextIP(), &td))
                {
                        if (td.type == TRACE_MANAGED )
                        {
                            MethodDesc *md = NULL;
                            _ASSERTE( g_pEEInterface->IsManagedNativeCode(td.address) );
                            md = g_pEEInterface->GetNativeCodeMethodDesc(td.address);
            
                            if ( g_pEEInterface->GetNativeAddressOfCode(md) == td.address ||
                                 g_pEEInterface->GetFunctionAddress(md) == td.address)
                            {
                                LOG((LF_CORDB,LL_INFO10000,"\tDS 0x%x m_reason"
                                     "= STEP_CALL\n", this));
                                m_reason = STEP_CALL;
                            }
                            else
                            {
                                LOG((LF_CORDB,LL_INFO1000,"Didn't step: md:0x%x"
                                     "td.type:%s td.address:0x%x,  "
                                     "gnaoc:0x%x gfa:0x%x\n",
                                     md, GetTType(td.type),td.address,
                                    g_pEEInterface->GetNativeAddressOfCode(md),
                                     g_pEEInterface->GetFunctionAddress(md)));
                            }
                        }
                        else
                            m_reason = STEP_CALL;
                            
                    return true;
                }
            }

            if (walker->GetSkipIP() == NULL)
            {
                AddPatch(info->m_activeFrame.md, 
                         offset,
                         TRUE, 
                         info->m_returnFrame.fp, 
                         ji, 
                         NULL);

                LOG((LF_CORDB,LL_INFO10000,"DS 0x%x m_reason=STEP_CALL4\n",this));
                m_reason = STEP_CALL;
                
                return true;
            }

            walker->Skip();
            LOG((LF_CORDB, LL_INFO10000, "DS::TS: skipping over call.\n"));
            break;

        default:
            if (walker->GetNextIP() == NULL)
            {
                AddPatch(info->m_activeFrame.md, 
                         offset,
                         TRUE, 
                         info->m_returnFrame.fp, 
                         ji, 
                         NULL);
                return true;
            }
            walker->Next();
            break;
        }
    }
    LOG((LF_CORDB,LL_INFO1000,"Ending TrapStep\n"));
}

bool DebuggerStepper::IsAddrWithinMethod(DebuggerJitInfo *dji, MethodDesc *pMD, const BYTE *addr)
{
    const BYTE *codeStart = NULL;
    const BYTE *codeEnd = NULL;
    
    // If we have a dji, then use the addr and size from that since its fast. Otherwise, look it all up based on the md.
    if (dji != NULL)
    {
        _ASSERTE(dji->m_fd == pMD);
        
        codeStart = (const BYTE*)dji->m_addrOfCode;
        codeEnd = (const BYTE*)(dji->m_addrOfCode+dji->m_sizeOfCode);
    }
    else
    {
        _ASSERTE(pMD != NULL);
        
        codeStart = g_pEEInterface->GetFunctionAddress(pMD);
        codeEnd = codeStart +g_pEEInterface->GetFunctionSize(pMD);
    }

    LOG((LF_CORDB, LL_INFO1000, "DS::IAWM: addr:0x%x Range: 0x%x-0x%x (%s::%s)\n",
         addr, codeStart, codeEnd,
         (dji != NULL) ? dji->m_fd->m_pszDebugClassName : "<Unknown>",
         (dji != NULL) ? dji->m_fd->m_pszDebugMethodName : "<Unknown"));
        
    if (codeStart != NULL && codeEnd != NULL &&
            addr >  codeStart && 
            addr <=  codeEnd)
    {   //how else to detect this?
        return true;
    }

    return false;
}

void DebuggerStepper::TrapStepOut(ControllerStackInfo *info)
{
    ControllerStackInfo returnInfo;
    CONTEXT tempContext;
    DebuggerJitInfo *dji;

    LOG((LF_CORDB, LL_INFO10000, "DS::TSO this:0x%x\n", this));

    while (info->HasReturnFrame())
    {
        // Continue walking up the stack & set a patch upon the next
        // frame up.  We will eventually either hit managed code
        // (which we can set a definite patch in), or the top of the
        // stack.
        returnInfo.GetStackInfo(GetThread(), info->m_returnFrame.fp, 
                                &tempContext, FALSE);
        info = &returnInfo;

        if (info->m_activeFrame.managed)
        {
            LOG((LF_CORDB, LL_INFO10000,
                 "DS::TSO: return frame is managed.\n"));
                
            if (info->m_activeFrame.frame == NULL)
            {
                // Returning normally to managed code.
                _ASSERTE(info->m_activeFrame.md != NULL);

                // Note: we used to pass in the IP from the active frame to GetJitInfo, but there seems to be no value
                // in that, and it was causing problems creating a stepper while sitting in ndirect stubs after we'd
                // returned from the unmanaged function that had been called.
                dji = g_pDebugger->GetJitInfo(info->m_activeFrame.md, NULL);

                AddPatch(info->m_activeFrame.md,
                         info->m_activeFrame.relOffset,
                         TRUE, 
                         info->m_returnFrame.fp,
                         dji,
                         NULL);
                         
                LOG((LF_CORDB, LL_INFO10000,
                     "DS::TSO:normally managed code AddPatch"
                     " in %s::%s, offset 0x%x, m_reason=STEP_RETURN\n",
                     info->m_activeFrame.md->m_pszDebugClassName, 
                     info->m_activeFrame.md->m_pszDebugMethodName,
                     info->m_activeFrame.relOffset));

                m_reason = STEP_RETURN;
                break;
            }
            else if (info->m_activeFrame.frame == FRAME_TOP)
            {
                // We're walking off the top of the stack.
                EnableTraceCall(info->m_activeFrame.fp);
                
                LOG((LF_CORDB, LL_INFO1000,
                     "DS::TSO: Off top of frame!\n"));
                
                m_reason = STEP_EXIT; //we're on the way out..
                
                // @todo not that it matters since we don't send a
                // stepComplete message to the right side.
                break;
            }
            else if (info->m_activeFrame.frame->GetFrameType() == Frame::TYPE_FUNC_EVAL)
            {
                // Note: we treat walking off the top of the stack and
                // walking off the top of a func eval the same way,
                // except that we don't enable trace call since we
                // know exactly where were going.

                LOG((LF_CORDB, LL_INFO1000,
                     "DS::TSO: Off top of func eval!\n"));

                m_reason = STEP_EXIT;
                break;
            }
            else if (info->m_activeFrame.frame->GetFrameType() == Frame::TYPE_SECURITY &&
                     info->m_activeFrame.frame->GetInterception() == Frame::INTERCEPTION_NONE) 
            {
                // If we're stepping out of something that was protected by (declarative) security, 
                // the security subsystem may leave a frame on the stack to cache it's computation.
                // HOWEVER, this isn't a real frame, and so we don't want to stop here.  On the other
                // hand, if we're in the security goop (sec. executes managed code to do stuff), then
                // we'll want to use the "returning to stub case", below.  GetInterception()==NONE
                // indicates that the frame is just a cache frame:
                // Skip it and keep on going
                LOG((LF_CORDB, LL_INFO10000,
                     "DS::TSO: returning to a non-intercepting frame. Keep unwinding\n"));
                continue;
            }
            else
            {
                LOG((LF_CORDB, LL_INFO10000,
                     "DS::TSO: returning to a stub frame.\n"));
                
                // We're returning to some funky frame.
                // (E.g. a security frame has called a native method.)

                // Patch the frame from entering other methods.  
                // 
                // !!! For now, we assume that the TraceFrame entry
                // point is smart enough to tell where it is in the
                // calling sequence.  We'll see how this holds up.
                TraceDestination trace;

                EnableTraceCall(info->m_activeFrame.fp);

                if (g_pEEInterface->TraceFrame(GetThread(), 
                                               info->m_activeFrame.frame, FALSE,
                                               &trace, &(info->m_activeFrame.registers))
                    && g_pEEInterface->FollowTrace(&trace)
                    && PatchTrace(&trace, info->m_activeFrame.fp,
                                  true)) 
                    break;

                // !!! Problem: we don't know which return frame to use - 
                // the TraceFrame patch may be in a frame below the return
                // frame, or in a frame parallel with it 
                // (e.g. prestub popping itself & then calling.)
                //
                // For now, I've tweaked the FP comparison in the 
                // patch dispatching code to allow either case.
            }  
        }
        else
        {   
            LOG((LF_CORDB, LL_INFO10000,
                 "DS::TSO: return frame is not managed.\n"));

            // Only step out to unmanaged code if we're actually
            // marked to stop in unamanged code. Otherwise, just loop
            // to get us past the unmanaged frames.
            if (m_rgfMappingStop & STOP_UNMANAGED)
            {
                LOG((LF_CORDB, LL_INFO10000,
                     "DS::TSO: return to unmanaged code "
                     "m_reason=STEP_RETURN\n"));

                m_reason = STEP_RETURN;
                
                // We're stepping out into unmanaged code
                LOG((LF_CORDB, LL_INFO10000, 
                 "DS::TSO: Setting unmanaged trace patch at 0x%x(%x)\n", 
                     *info->m_activeFrame.registers.pPC, 
                     info->m_returnFrame.fp));

                AddPatch((BYTE*)*info->m_activeFrame.registers.pPC, 
                         info->m_returnFrame.fp, 
                         FALSE, 
                         TRACE_UNMANAGED,
                         NULL, 
                         NULL);
                
                break;
            }
        }
    }

    // If we get here, we may be stepping out of the last frame.  Our thread 
    // exit logic should catch this case. (@todo) 
    LOG((LF_CORDB, LL_INFO10000,"DS::TSO: done\n"));
}

  
// @mfunc void | DebuggerStepper | Step |
// Called by Debugger::HandleIPCEvent  to setup
// everything so that the process will step over the range of IL
// correctly.
// How: Converts the provided array of ranges from IL ranges to
// native ranges (if they're not native already), and then calls
// TrapStep or TrapStepOut, like so:
//   Get the appropriate MethodDesc & JitInfo
//   Iterate through array of IL ranges, use
//   JitInfo::MapILRangeToMapEntryRange to translate IL to native
//   ranges.
// Set member variables to remember that the DebuggerStepper now uses
// the ranges: m_ranges, m_rangeCount, m_stepIn, m_fp
// If (!TrapStep()) then {m_stepIn = true; TrapStepOut()}
// EnableUnwind( m_fp );
void DebuggerStepper::StepOut(void *fp)
{
    LOG((LF_CORDB, LL_INFO10000, "Attempting to step out, fp:0x%x this:0x%x"
        "\n", fp, this ));

    Thread *thread = GetThread();
    CONTEXT tempContext;
    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
    ControllerStackInfo info;

    _ASSERTE(!(g_pEEInterface->GetThreadFilterContext(thread) && ISREDIRECTEDTHREAD(thread)));

    if (context == NULL)
        info.GetStackInfo(thread, fp, &tempContext, FALSE);
    else
        info.GetStackInfo(thread, fp, context, TRUE);

    
    ResetRange();

    
    m_stepIn = FALSE;
    m_fp = info.m_activeFrame.fp;

    _ASSERTE((fp == NULL) || (info.m_activeFrame.md != NULL) || (info.m_returnFrame.md != NULL));

    TrapStepOut(&info);
    EnableUnwind(m_fp);
}

// @mfunc void|DebuggerStepper|Step| Tells the stepper to step over
// the provided ranges.
// @parm void *|fp|frame pointer.
// @parm bool|in|true if we want to step into a function within the range,
//      false if we want to step over functions within the range.
// @parm COR_DEBUG_STEP_RANGE *|ranges|Assumed to be nonNULL, it will
//      always hold at least one element.
// @parm SIZE_T|rangeCount|One less than the true number of elements in
//      the ranges argument.
// @parm bool|rangeIL|true if the ranges are provided in IL (they'll be
//      converted to native before the <t DebuggerStepper> uses them,
//      false if they already are IL.
void DebuggerStepper::Step(void *fp, bool in,
                           COR_DEBUG_STEP_RANGE *ranges, SIZE_T rangeCount,
                           bool rangeIL)
{
    LOG((LF_CORDB, LL_INFO1000, "DeSt:Step this:0x%x  ", this));
    if (rangeCount>0)
        LOG((LF_CORDB,LL_INFO10000," start,end[0]:(0x%x,0x%x)\n",
             ranges[0].startOffset, ranges[0].endOffset));
    else
        LOG((LF_CORDB,LL_INFO10000," single step\n"));
    
    Thread *thread = GetThread();
    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
    CONTEXT tempContext;
    ControllerStackInfo info;

    _ASSERTE(!(g_pEEInterface->GetThreadFilterContext(thread) && ISREDIRECTEDTHREAD(thread)));

    if (context == NULL)
        info.GetStackInfo(thread, fp, &tempContext, FALSE);
    else
        info.GetStackInfo(thread, fp, context, TRUE);

    _ASSERTE((fp == NULL) || (info.m_activeFrame.md != NULL) ||
             (info.m_returnFrame.md != NULL));
    
    m_stepIn = in;

    MethodDesc *fd = info.m_activeFrame.md;

    if (fd == NULL)
    {
        // !!! ERROR range step in frame with no code
        DeleteInteropSafe(ranges);
        ranges = NULL;
        rangeCount = 0;
    }

    // Note: we used to pass in the IP from the active frame to GetJitInfo, but there seems to be no value in that, and
    // it was causing problems creating a stepper while sitting in ndirect stubs after we'd returned from the unmanaged
    // function that had been called.
    DebuggerJitInfo *dji = g_pDebugger->GetJitInfo(fd, NULL);

    m_djiVersion = dji; // Record the version we started in....
    LOG((LF_CORDB,LL_INFO100000, "DS::Step: Starting in dji 0x%x (ver:0x%x)\n",
        dji, (dji!=NULL?dji->m_nVersion:0)));

    //
    // Ranges must always be in native offsets, so if they're IL, we'll switch them to native.
    //

    if (dji != NULL && 
        dji->m_encBreakpointsApplied)
    {
        LOG((LF_CORDB, LL_INFO100000,
             "DS::S: The stepper will be re-stepped after "
             "the EnC is actually done\n"));    
            
        if (rangeCount > 0)
        {
            m_rgStepRanges = new (interopsafe) COR_DEBUG_STEP_RANGE[rangeCount];
            if (m_rgStepRanges != NULL)
            {
                SIZE_T i = 0;

                while (i < rangeCount)
                {
                    m_rgStepRanges[i] = ranges[i];
                    i++;
                }
            }
        }
        
        m_cStepRanges = rangeCount;
        m_fpDefered = fp;
        m_in = in;
        m_rangeIL = rangeIL; //@todo Should we convert this to IL first?

        if(S_OK == dji->AddToDeferedQueue(this))
        {
            m_djiSource = dji; 
        }
    }

    if (rangeCount > 0 && rangeIL)
    {
        if (dji != NULL)
        {
            LOG((LF_CORDB,LL_INFO10000,"DeSt::St: For code 0x%x, got DJI "
                "0x%x, from 0x%x to 0x%x\n",
                (const BYTE*)info.m_activeFrame.registers.pPC, 
                dji, dji->m_addrOfCode, (ULONG)dji->m_addrOfCode
                + (ULONG)dji->m_sizeOfCode));
            //
            // Map ranges to native offsets for jitted code
            //

            COR_DEBUG_STEP_RANGE *r = ranges;
            COR_DEBUG_STEP_RANGE *rEnd = r + rangeCount;

            for(/**/; r < rEnd; r++)
            {
                if (r->startOffset == 0 && r->endOffset == ~0)
                {
                    // {0...-1} means use the entire method as the range
                    // Code dup'd from below case.
                    LOG((LF_CORDB, LL_INFO10000, "DS:Step: Have DJI, special (0,-1) entry\n"));
                    r->endOffset = g_pEEInterface->GetFunctionSize(fd);
                }
                else
                {
                    //
                    // One IL range may consist of multiple
                    // native ranges.
                    //

                    DebuggerILToNativeMap *mStart, *mEnd;

                    dji->MapILRangeToMapEntryRange(r->startOffset, 
                                                    r->endOffset,
                                                    &mStart, 
                                                    &mEnd);

                    if (mStart == NULL)
                    {
                        // @todo Won't this result in us stepping across
                        // the entire method?
                        r->startOffset = 0;
                        r->endOffset = 0;
                    }
                    else if (mStart == mEnd)
                    {
                        r->startOffset = mStart->nativeStartOffset;
                        r->endOffset = mStart->nativeEndOffset;
                    }
                    else
                    {
                        //
                        // !!! need to allow for > 1 entry here.
                        // (We should really build a new range array.)
                        // For now, we'll just take the first one.
                        //
                            
                        r->startOffset = mStart->nativeStartOffset;

                        //
                        // @todo right now I'm assuming 1) that the
                        // mEnd points to the last range, not past the
                        // last range and 2) that the ranges between
                        // mStart and mEnd form a contigious region of
                        // native code.
                        //
                        // -- mikemag Mon Nov 30 10:31:37 1998
                        //
                        if (mEnd != NULL)
                            r->endOffset = mEnd->nativeEndOffset;
                        else
                            r->endOffset = mStart->nativeEndOffset;
                    }
                }

                    LOG((LF_CORDB, LL_INFO10000, "DS:Step: nat off:0x%x to 0x%x\n",
                        r->startOffset, r->endOffset));
            }
        }
        else
        {
            // Even if we don't have debug info, we'll be able to
            // step through the method
            SIZE_T functionSize = g_pEEInterface->GetFunctionSize(fd);

            COR_DEBUG_STEP_RANGE *r = ranges;
            COR_DEBUG_STEP_RANGE *rEnd = r + rangeCount;

            for(/**/; r < rEnd; r++)
            {
                if (r->startOffset == 0 && r->endOffset == ~0)
                {
                    LOG((LF_CORDB, LL_INFO10000, "DS:Step:No DJI, (0,-1) special entry\n"));
                    // Code dup'd from above case.
                    // {0...-1} means use the entire method as the range
                    r->endOffset = functionSize;
                }
                else
                {
                    LOG((LF_CORDB, LL_INFO10000, "DS:Step:No DJI, regular entry\n"));
                    // We can't just leave ths IL entry - we have to 
                    // get rid of it.
                    // This will just be ignored
                    r->startOffset = r->endOffset = functionSize;
                }
            }
        }
    }
    else
    {
        // !!! ERROR cannot map IL ranges
        DeleteInteropSafe(ranges);
        ranges = NULL;
        rangeCount = 0;
    }

    if (m_range != NULL)
    {
        TRACE_FREE(m_range);
        DeleteInteropSafe(m_range);
    }

    m_range = ranges;
    m_rangeCount = rangeCount;
    m_realRangeCount = rangeCount;

    m_fp = info.m_activeFrame.fp;

    LOG((LF_CORDB,LL_INFO10000,"DS 0x%x STep: STEP_NORMAL\n",this));
    m_reason = STEP_NORMAL; //assume it'll be a normal step & set it to
    //something else if we walk over it
    if (!TrapStep(&info, in))
    {
        LOG((LF_CORDB,LL_INFO10000,"DS:Step: Did TS\n"));        
        m_stepIn = true;
        TrapStepOut(&info);
    }

    LOG((LF_CORDB,LL_INFO10000,"DS:Step: Did TS,TSO\n"));

    EnableUnwind(m_fp);
}

// @mfunc bool| DebuggerStepper | TriggerPatch |
// What: Triggers patch if we're not in a stub, and we're
// outside of the stepping range.  Otherwise sets another patch so as to
// step out of the stub, or in the next instruction within the range.
// How: If module==NULL & managed==> we're in a stub:
// TrapStepOut() and return false.  Module==NULL&!managed==> return
// true.  If m_range != NULL & execution is currently in the range,
// attempt a TrapStep (TrapStepOut otherwise) & return false.  Otherwise,
// return true.
TP_RESULT DebuggerStepper::TriggerPatch(DebuggerControllerPatch *patch,
                                   Thread *thread,
                                   Module *module, 
                                   mdMethodDef md, 
                                   SIZE_T offset, 
                                   BOOL managed,
                                   TRIGGER_WHY tyWhy)
{
    LOG((LF_CORDB, LL_INFO10000, "DeSt::TP\n"));
    
    ControllerStackInfo info;
    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
    CONTEXT tempContext;

    _ASSERTE(!ISREDIRECTEDTHREAD(thread));

    if (context == NULL)
        info.GetStackInfo(thread, NULL, &tempContext, FALSE);
    else
        info.GetStackInfo(thread, NULL, context, TRUE);

    LOG((LF_CORDB, LL_INFO10000, "DS::TP: this:0x%x in %s::%s (fp:0x%x, "
        "off:0x%x md:0x%x), \n\texception source:%s::%s (fp:0x%x)\n", 
        this,
        info.m_activeFrame.md!=NULL?info.m_activeFrame.md->m_pszDebugClassName:"Unknown",
        info.m_activeFrame.md!=NULL?info.m_activeFrame.md->m_pszDebugMethodName:"Unknown", 
        info.m_activeFrame.fp, offset, md,
        m_fdException!=NULL?m_fdException->m_pszDebugClassName:"None",
        m_fdException!=NULL?m_fdException->m_pszDebugMethodName:"None",
         m_fpException));

    DisableAll();

    if (module == NULL)
    {
        if (managed)
        {

            LOG((LF_CORDB, LL_INFO10000, 
                 "Frame (stub) patch hit at offset 0x%x\n", offset));

            // This is a stub patch. If it was a TRACE_FRAME_PUSH that
            // got us here, then the stub's frame is pushed now, so we
            // tell the frame to apply the real patch. If we got here
            // via a TRACE_MGR_PUSH, however, then there is no frame
            // and we tell the stub manager that generated the
            // TRACE_MGR_PUSH to apply the real patch.
            TraceDestination trace;
            bool traceOk;
            void *frameFP;
            BYTE *traceManagerRetAddr = NULL;

            if (patch->trace.type == TRACE_MGR_PUSH)
            {
                _ASSERTE(context != NULL);
                
                traceOk = g_pEEInterface->TraceManager(
                                                 thread,
                                                 patch->trace.stubManager,
                                                 &trace,
                                                 context,
                                                 &traceManagerRetAddr);
                
                // We don't hae an active frame here, so patch with a
                // FP of NULL so anything will match.
                //
                // @todo: should we take Esp out of the context?
                frameFP = NULL;
            }
            else
            {
                traceOk = g_pEEInterface->TraceFrame(thread,
                                                     thread->GetFrame(),
                                                     TRUE,
                                                     &trace,
                                                     &(info.m_activeFrame.registers));

                frameFP = info.m_activeFrame.fp;
            }
            
            if (!traceOk
                || !g_pEEInterface->FollowTrace(&trace)
                || !PatchTrace(&trace, frameFP,
                               (m_rgfMappingStop&STOP_UNMANAGED)?
                                    (true):(false)))
            {
                //
                // We can't set a patch in the frame -- we need
                // to trap returning from this frame instead.
                //
                // Note: if we're in the TRACE_MGR_PUSH case from
                // above, then we must place a patch where the
                // TraceManager function told us to, since we can't
                // actually unwind from here.
                //
                if (patch->trace.type != TRACE_MGR_PUSH)
                {
                    LOG((LF_CORDB,LL_INFO10000,"TSO for non TRACE_MGR_PUSH case\n"));
                    TrapStepOut(&info);                    
                }
                else
                {
                    LOG((LF_CORDB, LL_INFO10000,
                         "TSO for TRACE_MGR_PUSH case."));

                    // We'd better have a valid return address.
                    _ASSERTE(traceManagerRetAddr != NULL);
                    _ASSERTE(g_pEEInterface->IsManagedNativeCode(
                                                        traceManagerRetAddr));

                    // Find the method that the return is to.
                    MethodDesc *md = g_pEEInterface->GetNativeCodeMethodDesc(
                                                         traceManagerRetAddr);
                    _ASSERTE(md != NULL);

                    // Compute the relative offset into the method.
                    _ASSERTE(g_pEEInterface->GetFunctionAddress(md) != NULL);
                    SIZE_T offset = traceManagerRetAddr -
                        g_pEEInterface->GetFunctionAddress(md);
                    
                    // Grab the jit info for the method.
                    DebuggerJitInfo *dji;
                    dji = g_pDebugger->GetJitInfo(md, traceManagerRetAddr);

                    // Place the patch.
                    AddPatch(md, 
                             offset, 
                             TRUE, 
                             NULL, 
                             dji, 
                             NULL);
                         
                    LOG((LF_CORDB, LL_INFO10000,
                         "DS::TP: normally managed code AddPatch"
                         " in %s::%s, offset 0x%x\n",
                         md->m_pszDebugClassName, 
                         md->m_pszDebugMethodName,
                         offset));
                }

                m_reason = STEP_NORMAL; //we tried to do a STEP_CALL, but since it didn't
                //work, we're doing what amounts to a normal step.
                LOG((LF_CORDB,LL_INFO10000,"DS 0x%x m_reason = STEP_NORMAL"
                     "(attempted call thru stub manager, SM didn't know where"
                     " we're going, so did a step out to original call\n",this));
            }
            else
            {
                m_reason = STEP_CALL;
            }

            EnableTraceCall(NULL);
            EnableUnwind(m_fp);
            return TPR_IGNORE;
        }
        else
        {
            if (DetectHandleInterceptors(&info) )
                return TPR_IGNORE; //don't actually want to stop

            LOG((LF_CORDB, LL_INFO10000, 
                 "Unmanaged step patch hit at 0x%x\n", offset));
            
            return TPR_TRIGGER;
        }
    }

    // If we're inside an interceptor but don't want to be,then we'll set a
    // patch outside the current function.
    if (DetectHandleInterceptors(&info) )
        return TPR_IGNORE; //don't actually want to stop

    LOG((LF_CORDB,LL_INFO10000, "DS: m_fp:0x%x, activeFP:0x%x fpExc:0x%x\n",
        m_fp, info.m_activeFrame.fp, m_fpException));

    if (( m_range != NULL &&
          (info.m_activeFrame.fp == m_fp ||
            (  info.m_activeFrame.md == m_fdException && 
               info.m_activeFrame.fp >= m_fpException
            )
          ) && 
          IsInRange( offset, m_range, m_rangeCount)
        ) ||
        ShouldContinueStep( &info, offset) )
    {
        LOG((LF_CORDB, LL_INFO10000, 
             "Intermediate step patch hit at 0x%x\n", offset));

        if (!TrapStep(&info, m_stepIn))
            TrapStepOut(&info);

        EnableUnwind(m_fp);
        return TPR_IGNORE;
    }
    else
    {
        LOG((LF_CORDB, LL_INFO10000, 
             "Step patch hit at 0x%x\n", offset));

        return TPR_TRIGGER;
    }
}

bool DebuggerStepper::TriggerSingleStep(Thread *thread, const BYTE *ip)
{
    LOG((LF_CORDB,LL_INFO10000,"DS:TSS this:0x%x, @ ip:0x%x\n", this, ip));

    //
    // there's one weird case here - if the last instruction generated
    // a hardware exception, we may be in lala land.  If so, rely on the unwind
    // handler to figure out what happened.
    //
    // @todo this could be wrong when we have the incremental collector going
    //

    if (!g_pEEInterface->IsManagedNativeCode(ip))
    {
        LOG((LF_CORDB,LL_INFO10000, "DS::TSS: not in managed code, Returning false (case 0)!\n"));
        DisableSingleStep();
        return false;
    }

    // If we EnC the method, we'll blast the function address,
    // and so have to get it from teh DJI that we'll have.  If
    // we haven't gotten debugger info about a regular function, then
    // we'll have to get the info from the EE, which will be valid
    // since we're standing in the function at this point, and 
    // EnC couldn't have happened yet.
    MethodDesc *fd = g_pEEInterface->GetNativeCodeMethodDesc(ip);

    SIZE_T offset;
    const BYTE *pbEEAddr;
    DebuggerJitInfo *dji = g_pDebugger->GetJitInfo(fd, ip);
    
    if(dji != NULL)
    {
        pbEEAddr = (const BYTE *)dji->m_addrOfCode;
    }
    else
    {
        pbEEAddr = g_pEEInterface->GetFunctionAddress(fd);
        _ASSERTE(NULL != pbEEAddr);
    }

    offset = ip - pbEEAddr;

    DisableAll();

    CONTEXT tempContext;
    ControllerStackInfo info;
    info.GetStackInfo(GetThread(), NULL, &tempContext, FALSE);

    LOG((LF_CORDB,LL_INFO10000, "DS::TSS m_fp:0x%x, activeFP:0x%x fpExc:0x%x\n",
        m_fp, info.m_activeFrame.fp, m_fpException));

    if ((m_range != NULL &&
        (info.m_activeFrame.fp == m_fp ||
            (info.m_activeFrame.md == m_fdException && 
             info.m_activeFrame.fp >= m_fpException))
        && IsInRange(offset, m_range, m_rangeCount)) ||
        ShouldContinueStep( &info, offset))
    {
        if (!TrapStep(&info, m_stepIn))
            TrapStepOut(&info);

        EnableUnwind(m_fp);

        LOG((LF_CORDB,LL_INFO10000, "DS::TSS: Returning false Case 1!\n"));
        return false;
    }
    else
    {
        LOG((LF_CORDB,LL_INFO10000, "DS::TSS: Returning true Case 2 for reason STEP_%02x!\n", m_reason));
        return true;
    }
}

void DebuggerStepper::TriggerTraceCall(Thread *thread, const BYTE *ip)
{
    LOG((LF_CORDB,LL_INFO10000,"DS:TTC this:0x%x, @ ip:0x%x\n",this,ip));
    TraceDestination trace;

    if (g_pEEInterface->TraceStub(ip, &trace)
        && g_pEEInterface->FollowTrace(&trace)
        && PatchTrace(&trace, NULL,
            (m_rgfMappingStop&STOP_UNMANAGED)?(true):(false)))
    {
        // !!! We really want to know ahead of time if PatchTrace will succeed.  
        DisableAll();
        PatchTrace(&trace, NULL,(m_rgfMappingStop&STOP_UNMANAGED)?
            (true):(false));

        // If we're triggering a trace call, and we're following a trace into either managed code or unjitted managed
        // code, then we need to update our stepper's reason to STEP_CALL to reflect the fact that we're going to land
        // into a new function because of a call.
        if ((trace.type == TRACE_UNJITTED_METHOD) || (trace.type == TRACE_MANAGED))
            m_reason = STEP_CALL;

        EnableUnwind(m_fp);

        LOG((LF_CORDB, LL_INFO10000, "DS::TTC potentially a step call!\n"));
    }
}

void DebuggerStepper::TriggerUnwind(Thread *thread, MethodDesc *fd, SIZE_T offset,
                                    const BYTE *frame,
                                    CorDebugStepReason unwindReason)
{
    LOG((LF_CORDB,LL_INFO10000,"DS::TU this:0x%x, in %s::%s, offset 0x%x "
        "frame:0x%x unwindReason:0x%x\n", this, fd->m_pszDebugClassName,
        fd->m_pszDebugMethodName, offset, frame, unwindReason));

    _ASSERTE(unwindReason == STEP_EXCEPTION_FILTER || unwindReason == STEP_EXCEPTION_HANDLER);

    if (frame > (BYTE*) GetUnwind())
    {
        // This will be like a Step Out, so we don't need any range 
        ResetRange();        
    }

    // Remember the origin of the exception, so that if the step looks like
    // it's going to complete in a different frame, but the code comes from the
    // same frame as the one we're in, we won't stop twice in the "same" range
    m_fpException = (void *)frame;
    m_fdException = fd;

    //
    // An exception is ruining our stepping.  Set a patch on 
    // the filter/handler.
    // 

    DisableAll();

    AddPatch(fd, offset, true, NULL, NULL, NULL);

    LOG((LF_CORDB,LL_INFO100000,"Step reason:%s\n", unwindReason==STEP_EXCEPTION_FILTER
        ? "STEP_EXCEPTION_FILTER":"STEP_EXCEPTION_HANDLER"));
    m_reason = unwindReason;
}


void DebuggerStepper::SendEvent(Thread *thread)
{
    LOG((LF_CORDB, LL_INFO10000, "DS::SE m_fpStepInto:0x%x\n", m_fpStepInto));

    if (m_fpStepInto)
    {
        ControllerStackInfo csi;

        CONTEXT ctx;
        csi.GetStackInfo(thread, NULL, &ctx, false);
        if (csi.m_targetFrameFound && 
            m_fpStepInto > csi.m_activeFrame.fp)
        {
            m_reason = STEP_CALL;        
            LOG((LF_CORDB, LL_INFO10000, "DS::SE this:0x%x STEP_CALL!\n", this));
        }
#ifdef _DEBUG
        else
        {
            LOG((LF_CORDB, LL_INFO10000, "DS::SE this:0x%x not a step call!\n", this));
        }
#endif
    }

    if (m_djiSource != NULL)
        m_djiSource->RemoveFromDeferedQueue(this);

    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
    _ASSERTE(!ISREDIRECTEDTHREAD(thread));
    g_pDebugger->SendStep(thread, context, this, m_reason);
}

void DebuggerStepper::ResetRange()
{
    if (m_range)
    {
        TRACE_FREE(m_range);
        DeleteInteropSafe(m_range);

        m_range = NULL;
    }    
}

void DebuggerStepper::MoveToCurrentVersion( DebuggerJitInfo *djiNew)
{
    _ASSERTE(m_djiVersion->m_fd == djiNew->m_fd);

#ifdef LOGGING
    if (m_djiVersion)
        LOG((LF_CORDB,LL_EVERYTHING, "DS::MTCV: m_djiVersion:0x%x (%s::%s)\n",
            m_djiVersion, m_djiVersion->m_fd->m_pszDebugClassName,
            m_djiVersion->m_fd->m_pszDebugMethodName));
    else
        LOG((LF_CORDB,LL_EVERYTHING, "DS::MTCV:Version unknown!\n"));
#endif //LOGGING    

    if (m_djiVersion != NULL)
    {
        if (m_djiVersion != djiNew)
        {
            LOG((LF_CORDB,LL_INFO100000, "DS::MTCV: from ver 0x%x (dji:0x%x) "
                "to ver 0x%x (dji:0x%x)\n", m_djiVersion->m_nVersion, 
                m_djiVersion, djiNew->m_nVersion, djiNew));

            for(UINT i = 0; i < m_realRangeCount;i++)
            {
                CorDebugMappingResult map;
                DWORD which;
                DWORD ilOld;
                SIZE_T naNew;
                BOOL fAccurateIrrelevant;

#define MOVE_TO_CURRENT_VERSION_BODY(field)                                 \
    ilOld = m_djiVersion->MapNativeOffsetToIL(m_range[i].##field, &map,     \
                    &which);                                                \
    if (map == MAPPING_APPROXIMATE || map == MAPPING_EXACT)                 \
        naNew = djiNew->MapILOffsetToNative(ilOld);                         \
    else                                                                    \
        naNew = djiNew->MapSpecialToNative(map, which,&fAccurateIrrelevant);\
    LOG((LF_CORDB,LL_INFO100000, "DS::MTCV:From Na(IL,Map,Which):0x%x"      \
          "(0x%x,0x%x,0x%x) to new Na:0x%x", m_range[i].##field, ilOld,     \
          map, which, naNew));                                              \
    m_range[i].##field = naNew;                                             

                MOVE_TO_CURRENT_VERSION_BODY(startOffset);
                MOVE_TO_CURRENT_VERSION_BODY(endOffset);
#undef MOVE_TO_CURRENT_VERSION_BODY
            }
        }
    }
}

void DebuggerStepper::DoDeferedPatch(DebuggerJitInfo *pDji,
                                     Thread *pThread,
                                     void *fp)
{
    LOG((LF_CORDB, LL_INFO100000,
         "DS::DDP: Stepper 0x%x about to be re-stepped after "
         "EnC is now being processed\n", this));

    if (GetThread() == pThread && m_fpDefered == fp)
    {
        DisableAll(); //get rid of anything that's there....
        Step(m_fpDefered, m_in, m_rgStepRanges, m_cStepRanges, m_rangeIL);
    }
}

// * ------------------------------------------------------------------------ 
// * DebuggerThreadStarter routines
// * ------------------------------------------------------------------------

DebuggerThreadStarter::DebuggerThreadStarter(Thread *thread)
  : DebuggerController(thread, NULL) 
{
    LOG((LF_CORDB, LL_INFO1000, "DTS::DTS: this:0x%x Thread:0x%x\n",
        this, thread));
}

//@mfunc bool |  DebuggerThreadStarter | TriggerPatch | If we're in a
// stub (module==NULL&&managed) then do a PatchTrace up the stack &
// return false.  Otherwise DisableAll & return
// true
TP_RESULT DebuggerThreadStarter::TriggerPatch(DebuggerControllerPatch *patch,
                                         Thread *thread,
                                         Module *module, 
                                         mdMethodDef md, 
                                         SIZE_T offset, 
                                         BOOL managed,
                                         TRIGGER_WHY tyWhy)
{
    LOG((LF_CORDB,LL_INFO1000, "DebuggerThreadStarter::TriggerPatch for thread 0x%x\n", thread->GetThreadId()));

    if (module == NULL && managed)
    {
        // This is a stub patch. If it was a TRACE_FRAME_PUSH that got us here, then the stub's frame is pushed now, so
        // we tell the frame to apply the real patch. If we got here via a TRACE_MGR_PUSH, however, then there is no
        // frame and we go back to the stub manager that generated the stub for where to patch next.
        TraceDestination trace;
        bool traceOk;

        if (patch->trace.type == TRACE_MGR_PUSH)
        {
            BYTE *dummy = NULL;
            CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
            _ASSERTE(!ISREDIRECTEDTHREAD(thread));
            _ASSERTE(context != NULL);
                
            traceOk = g_pEEInterface->TraceManager(thread, patch->trace.stubManager, &trace, context, &dummy);
        }
        else if ((patch->trace.type == TRACE_FRAME_PUSH) && (thread->GetFrame()->IsTransitionToNativeFrame()))
        {
            // If we've got a frame that is transitioning to native, there's no reason to try to keep tracing. So we
            // bail early and save ourselves some effort. This also works around a problem where we deadlock trying to
            // do too much work to determine the destination of a ComPlusMethodFrame. (See bug 87103.)
            //
            // Note: trace call is still enabled, so we can just ignore this patch and wait for trace call to fire
            // again...
            return TPR_IGNORE;
        }
        else
        {
            ControllerStackInfo csi;
            CONTEXT Context;
            csi.GetStackInfo(thread, NULL, &Context, FALSE);
        
            traceOk = g_pEEInterface->TraceFrame(thread, thread->GetFrame(), TRUE, &trace, &(csi.m_activeFrame.registers));
        }
            
        if (traceOk && g_pEEInterface->FollowTrace(&trace))
            PatchTrace(&trace, NULL, TRUE);
        
        return TPR_IGNORE;
    }
    else
    {
        // We've hit user code; trigger our event.
        DisableAll();

        return TPR_TRIGGER;
    }
}

void DebuggerThreadStarter::TriggerTraceCall(Thread *thread, const BYTE *ip)
{ 
    if (thread->GetDomain()->IsDebuggerAttached())
    {
        TraceDestination trace;

        if (g_pEEInterface->TraceStub(ip, &trace) && g_pEEInterface->FollowTrace(&trace))
            PatchTrace(&trace, NULL, true);
    }
}

void DebuggerThreadStarter::SendEvent(Thread *thread)
{
    LOG((LF_CORDB, LL_INFO10000, "DTS::SE: in DebuggerThreadStarter's SendEvent\n"));

    // Send the thread started event.
    g_pDebugger->ThreadStarted(thread, FALSE);

    // We delete this now because its no longer needed. We can call
    // delete here because the queued count is above 0. This object
    // will really be deleted when its dequeued shortly after this
    // call returns.
    Delete();
}

// * ------------------------------------------------------------------------ 
// * DebuggerUserBreakpoint routines
// * ------------------------------------------------------------------------

DebuggerUserBreakpoint::DebuggerUserBreakpoint(Thread *thread)
  : DebuggerStepper(thread, STOP_NONE, INTERCEPT_NONE,  NULL) 
{
    // Setup a step out from the current frame (which we know is
    // unmanaged, actually...)
    StepOut(NULL);
}

TP_RESULT DebuggerUserBreakpoint::TriggerPatch(DebuggerControllerPatch *patch,
                                          Thread *thread,
                                          Module *module, 
                                          mdMethodDef md, 
                                          SIZE_T offset, 
                                          BOOL managed,
                                          TRIGGER_WHY tyWhy)
{
    LOG((LF_CORDB, LL_INFO10000, "DUB::TP\n"));
    
    // First disable the patch
    DisableAll();

    //
    // Now we try to see if we've landed in code that's not in the namespace
    // "Debugger.Diagnostics"
    //


    // First, get the active frame.
    ControllerStackInfo info;
    CONTEXT *context = g_pEEInterface->GetThreadFilterContext(thread);
    _ASSERTE(!ISREDIRECTEDTHREAD(thread));
    CONTEXT tempContext;

    if (context == NULL)
        info.GetStackInfo(thread, NULL, &tempContext, FALSE);
    else
        info.GetStackInfo(thread, NULL, context, TRUE);

    // Now get the namespace of the active frame
    MethodDesc *pMD = NULL;
    EEClass *pClass = NULL;

    if ((pMD = info.m_activeFrame.md) != NULL && (pClass = pMD->GetClass()) != NULL)
    {
        LPCUTF8 szNamespace = NULL;
        LPCUTF8 szClassName = pClass->GetFullyQualifiedNameInfo(&szNamespace);

        if (szClassName != NULL && szNamespace != NULL)
        {
            MAKE_WIDEPTR_FROMUTF8(wszNamespace, szNamespace);
            MAKE_WIDEPTR_FROMUTF8(wszClassName, szClassName);
            if (wcscmp(wszClassName, L"Debugger") == 0 &&
                wcscmp(wszNamespace, L"System.Diagnostics") == 0)
            {
                StepOut(NULL);
                return TPR_IGNORE;
            }
        }
    }

    return TPR_TRIGGER;
}

void DebuggerUserBreakpoint::SendEvent(Thread *thread)
{
    LOG((LF_CORDB, LL_INFO10000,
         "DUB::SE: in DebuggerUserBreakpoint's SendEvent\n"));

    // Send the user breakpoint event.
    g_pDebugger->SendRawUserBreakpoint(thread);

    // We delete this now because its no longer needed. We can call
    // delete here because the queued count is above 0. This object
    // will really be deleted when its dequeued shortly after this
    // call returns.
    Delete();
}

// * ------------------------------------------------------------------------ 
// * DebuggerFuncEvalComplete routines
// * ------------------------------------------------------------------------

DebuggerFuncEvalComplete::DebuggerFuncEvalComplete(Thread *thread,
                                                   void *dest)
  : DebuggerController(thread, NULL) 
{
    // Add an unmanaged patch at the destination.
    AddPatch((BYTE*)dest, NULL, FALSE, TRACE_UNMANAGED, NULL, NULL);
}

TP_RESULT DebuggerFuncEvalComplete::TriggerPatch(DebuggerControllerPatch *patch,
                                            Thread *thread,
                                            Module *module, 
                                            mdMethodDef md, 
                                            SIZE_T offset, 
                                            BOOL managed,
                                            TRIGGER_WHY tyWhy)
{
    // It had better be an unmanaged patch...
    _ASSERTE((module == NULL) && !managed);

    // We've hit our patch, so simply disable all (which removes the
    // patch) and trigger the event.
    DisableAll();
    return TPR_TRIGGER;
}

void DebuggerFuncEvalComplete::SendEvent(Thread *thread)
{
#ifdef _X86_ // Reliance on pCtx->Eip
    LOG((LF_CORDB, LL_INFO10000, "DFEC::SE: in DebuggerFuncEval's SendEvent\n"));

    // Grab our filter context.
    CONTEXT *pCtx = g_pEEInterface->GetThreadFilterContext(thread);
    _ASSERTE(!ISREDIRECTEDTHREAD(thread));
    _ASSERTE(pCtx != NULL);

    // The DebuggerEval is at our faulting address.
    DebuggerEval *pDE = (DebuggerEval*)(pCtx->Eip);

    // Restore the thread's context to what it was before we hijacked it for this func eval.
    _CopyThreadContext(pCtx, &(pDE->m_context));
    
    // Send the func eval complete (or exception) event.
    g_pDebugger->FuncEvalComplete(thread, pDE);

    // If we need to rethrow a ThreadAbortException then set the thread's state so we remember that.
    if (pDE->m_rethrowAbortException)
        thread->SetThreadStateNC(Thread::TSNC_DebuggerReAbort);

    // We delete this now because its no longer needed. We can call
    // delete here because the queued count is above 0. This object
    // will really be deleted when its dequeued shortly after this
    // call returns.
    Delete();
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - SendEvent (Controller.cpp)");
#endif // _X86_
}


// * ------------------------------------------------------------------------ *
// * DebuggerEnCPatchToSkip routines
// * ------------------------------------------------------------------------ *
DebuggerEnCPatchToSkip::DebuggerEnCPatchToSkip(const BYTE *address, 
                           void *fp, 
                           bool managed,
                           TraceType traceType, 
                           DebuggerJitInfo *dji,
                           Thread *pThread)
  : m_jitInfo(dji), DebuggerController(pThread, NULL)
{
    _ASSERTE(dji!= NULL );

    LOG((LF_CORDB, LL_INFO10000, "DEnCPTS::DEnCPTS addr:0x%x managed:0x%x "
        "dji:0x%x\n", address, managed, dji));

    if( !IsXXXPatched(address, DEBUGGER_CONTROLLER_ENC_PATCH_TO_SKIP))
    {
        LOG((LF_CORDB, LL_INFO10000, "DEnCPTS::DEnCPTS not a dup!\n"));
            
        AddPatch(address, fp, managed, traceType, dji, m_pAppDomain);
        EnableExceptionHook();
    }
}

TP_RESULT DebuggerEnCPatchToSkip::TriggerExceptionHook(Thread *thread, 
                               EXCEPTION_RECORD *exception)
{
    LOG((LF_CORDB, LL_INFO10000, "DEnCPTS::TEH About to switch!\n"));

    DisableAll();
    Delete();
    DebuggerController::EnableSingleStep(thread);

    LOG((LF_CORDB,LL_INFO1000, "DEnCPTS::TEH done da work!\n"));

    return TPR_IGNORE_STOP;
}

// * ------------------------------------------------------------------------ *
// * DebuggerEnCBreakpoint routines
// * ------------------------------------------------------------------------ *

DebuggerEnCBreakpoint::DebuggerEnCBreakpoint(Module *module,
                                             mdMethodDef md,
                                             SIZE_T offset, 
                                             bool native,
                                             DebuggerJitInfo *jitInfo,
                                             AppDomain *pAppDomain)
  : DebuggerController(NULL, pAppDomain),
    m_jitInfo(jitInfo)
{
    _ASSERTE( jitInfo != NULL );
    AddPatch(module, md, offset, native, NULL, jitInfo, FALSE);
}

TP_RESULT DebuggerEnCBreakpoint::TriggerPatch(DebuggerControllerPatch *patch,
                                         Thread *thread,
                                         Module *module,
                                         mdMethodDef md, 
                                         SIZE_T offset,
                                         BOOL managed,
                                         TRIGGER_WHY tyWhy)
{
    //
    // @todo honestly, this is a little nasty. What follows is only
    // temporary to unblock E&C work for M8. We should be able to get
    // it fixed up properly in M9. What's happening is this: we've
    // placed E&C breakpoints at every IL sequence point in the method
    // that has been replaced. Now we've hit one. We don't really want
    // to do any of the rest of the logic in DispatchPatchOrSingleStep. Since
    // we're calling Jen's ResumeInUpdatedFunction at the end of this,
    // this TriggerPatch will actually never return. This is okay,
    // since there is no global state that has been effected in
    // DispatchPatchOrSingleStep yet, and since ResumeInUpdatedFunction will fixup
    // the stack for us.
    //
    // What we really need to do is to ensure in the UpdateFunction
    // that we remove any patches in the function and map them over to
    // the new (not yet jitted) function before placing the E&C
    // breakpoints. That will ensure that when hitting an E&C
    // breakpoint that no other patches will be hit either. Then, when
    // we hit an E&C breakpoint, we need to do the work below but
    // cooperate nicely with the rest o the DispatchPatchOrSingleStep logic.
    //
    
    LOG((LF_ENC, LL_INFO100,
         "DEnCBP::TP: triggered E&C breakpoint: tid=0x%x, module=0x%08x, "
         "method def=0x%08x, native offset=0x%x, managed=%d\n this=0x%x",
         thread, module, md, offset, managed, this));

    _ASSERTE(managed != FALSE);
    
    // Grab the MethodDesc for this function.
    _ASSERTE(module != NULL);
    MethodDesc *pFD = g_pEEInterface->LookupMethodDescFromToken(module, md);

    _ASSERTE(pFD != NULL);

    LOG((LF_ENC, LL_INFO100,
         "DEnCBP::TP: in %s::%s\n", pFD->m_pszDebugClassName,pFD->m_pszDebugMethodName));

    // Grab the jit info for the original copy of the method, which is
    // what we are executing right now.
    DebuggerJitInfo *pJitInfo = m_jitInfo;
    _ASSERTE(pJitInfo);

    if (pJitInfo->m_illegalToTransitionFrom)
    {
        _ASSERTE(!"About to ignore an illegal transition from between versions of"
            " a method wherein the local variable layout changes");
        return TPR_IGNORE;
    }

    // Map the current native offset back to the IL offset in the old
    // function.  This will be mapped to the new native offset within
    // ResumeInUpdatedFunction
    CorDebugMappingResult map;
    DWORD which;
    DWORD resumeIP = pJitInfo->MapNativeOffsetToIL(offset, 
            &map, &which);

    // We only lay DebuggerEnCBreakpoints at "good" sites
    _ASSERTE(map == MAPPING_EXACT);

    LOG((LF_ENC, LL_INFO100,
         "DEnCBP::TP: resume IL offset is 0x%x\n", resumeIP));
    
    // Grab the context for this thread. This is the context that was
    // passed to COMPlusFrameHandler.
    CONTEXT *pContext = g_pEEInterface->GetThreadFilterContext(thread);
    _ASSERTE(!ISREDIRECTEDTHREAD(thread));

    // We use the module the current function is in.
    _ASSERTE(module->IsEditAndContinue());
    EditAndContinueModule *pModule = (EditAndContinueModule*)module;

    BOOL fIgnoreJitOnly = TRUE;
#ifdef _DEBUG
    // At some point, we're going to say that lack of an IL 
    // map means that EnC doesn't work.  We still want to JIT
    // the method, so the next time we call it we'll get the new version.
    //
    // Right now we've got a 
    // choice, in part b/c our COR tests aren't going to work otherwise....
    static ConfigDWORD ignoreJitOnly(L"EnCIgnoreLackOfILMaps", 1);
    fIgnoreJitOnly = ignoreJitOnly.val() != 0;
    if (fIgnoreJitOnly) 
    {
        LOG((LF_CORDB, LL_INFO10000, "DEnCB::TP: If we're lacking IL Mapping info"
            ", then we're ignoring that fact\n"));
    }
#endif // _DEBUG
    
    BOOL fJitOnly = (pJitInfo->m_cOldILToNewIL==0) && !fIgnoreJitOnly;

    DebuggerController::Unlock();
    
    // This will JIT the function if necessary, fixup the new stack,
    // and resume execution at the new location. 
    g_pEEInterface->ResumeInUpdatedFunction(pModule, 
                                            pFD,
                                            resumeIP,
                                            (UINT)map, 
                                            which, 
                                            (void*)pJitInfo, 
                                            pContext,
                                            fJitOnly,
                                            tyWhy==TY_SHORT_CIRCUIT);

    LOG((LF_CORDB, LL_INFO10000, "DEnCB::TP: We've returned from ResumeInUpd"
        "atedFunction, we're going to skip the EnC patch ####\n"));

    // If we're returning then we'll have to re-get this lock.
    DebuggerController::Lock(); 

    return TPR_IGNORE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\frameinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: frameinfo.cpp
//
// Code to find control info about a stack frame.
//
// @doc
//*****************************************************************************

#include "stdafx.h"

/* ------------------------------------------------------------------------- *
 * DebuggerFrameInfo routines
 * ------------------------------------------------------------------------- */

//@struct DebuggerFrameData | Contains info used by the DebuggerWalkStackProc
// to do a stack walk.  The info and pData fields are handed to the pCallback
// routine at each frame,
struct DebuggerFrameData
{
    Thread                  *thread;
    void                    *targetFP;
    bool                    targetFound;
    bool                    needParentInfo;
    bool                    lastFrameWasEntry;
    FrameInfo               info;
    REGDISPLAY              regDisplay;
    DebuggerStackCallback   pCallback;
    void                    *pData;
    Context                 *newContext;
    bool                    needEnterManaged;
    FrameInfo               enterManagedInfo;
    bool                    needUnmanagedExit;
    BOOL                    ignoreNonmethodFrames;
};

//@func StackWalkAction | DebuggerWalkStackProc | This is the callback called
// by the EE.
// @comm Note that since we don't know what the frame pointer for frame
// X is until we've looked at the caller of frame X, we actually end up
// stashing the info and pData pointers in the DebuggerFrameDat struct, and
// then invoking pCallback when we've moved up one level, into the caller's
// frame.  We use the needParentInfo field to indicate that the previous frame
// needed this (parental) info, and so when it's true we should invoke
// pCallback.
// What happens is this: if the previous frame set needParentInfo, then we
// do pCallback (and set needParentInfo to false).
// Then we look at the current frame - if it's frameless (ie,
// managed), then we set needParentInfo to callback in the next frame.
// Otherwise we must be at a chain boundary, and so we set the chain reason
// appropriately.  We then figure out what type of frame it is, setting
// flags depending on the type.  If the user should see this frame, then
// we'll set needParentInfo to record it's existence.  Lastly, if we're in
// a funky frame, we'll explicitly update the register set, since the
// CrawlFrame doesn't do it automatically.
StackWalkAction DebuggerWalkStackProc(CrawlFrame *pCF, void *data)
{
	DebuggerFrameData *d = (DebuggerFrameData *)data;

	Frame *frame = g_pEEInterface->GetFrame(pCF);
    
	// The fp for a frame must be obtained from the
	// _next_ frame. Fill it in now for the previous frame, if 
	// appropriate.
	//

	if (d->needParentInfo)
	{
        LOG((LF_CORDB, LL_INFO100000, "DWSP: NeedParentInfo.\n"));

        if (!pCF->IsFrameless() && d->info.frame != NULL)
        {
            // 
            // If we're in an explicit frame now, and the previous frame was 
            // also an explicit frame, pPC will not have been updated.  So
            // use the address of the frame itself as fp.
		//
            d->info.fp = d->info.frame;
        }
        else
        {
            //
            // Otherwise use pPC as the frame pointer, as this will be 
		// pointing to the return address on the stack.
		//
		d->info.fp = d->regDisplay.pPC;
        }

		//
		// If we just got a managed code frame, we might need
		// to label it with an ENTER_MANAGED chainReason.  This
		// is because sometimes the entry frame is omitted from
		// ecalls.

        // TODO: The concept of needEntryManaged is not needed
        // This should be ripped out as it 
        // creates chains that are of zero length.  (see bug 71357)
		// However we have not pulled it right now since this could
        // be destabilizing Please revist post V1.  

		if (d->info.frame == NULL && frame != NULL)
        {
            int frameType = frame->GetFrameType();

            if (frameType == Frame::TYPE_EXIT)
            {
                d->info.chainReason = CHAIN_ENTER_MANAGED;
            }
            else if (frameType == Frame::TYPE_INTERNAL)
            {
                d->needEnterManaged = true;
                d->enterManagedInfo = d->info;
                d->enterManagedInfo.chainReason = CHAIN_ENTER_MANAGED;
                d->enterManagedInfo.registers = d->regDisplay;
                d->enterManagedInfo.md = NULL;
                d->enterManagedInfo.pIJM = NULL;
                d->enterManagedInfo.MethodToken = NULL;
            }
        }

		d->needParentInfo = false;

		//
		// If we're looking for a specific frame, make sure that
		// this is actually the right one.
		//

		if (!d->targetFound && d->targetFP <= d->info.fp)
			d->targetFound = true;

		if (d->targetFound)
		{
            // When we're interop debugging, there is a special case where we may need to send a enter unmanaged chain
            // before the first useful managed frame that we send. In such a case, we'll save off the current info
            // struct we've built up, send up the special chain, then resore the info and send it up like normal.
            if (d->needUnmanagedExit)
            {
                // We only do this for frames which are chain boundaries or are not marked internal. This matches a test
                // in DebuggerThread::TraceAndSendStackCallback, and we do it here too to ensure that we send this
                // special chain at the latest possible moment. (We want the unmanaged chain to include as much
                // unmanaged code as possible.)
                if (!((d->info.chainReason == CHAIN_NONE) && (d->info.internal || (d->info.md == NULL))))
                {
                    // We only do this once.
                    d->needUnmanagedExit = false;

                    // Save off the good info.
                    FrameInfo goodInfo = d->info;

                    // Setup the special chain.
                    d->info.md = NULL;
                    d->info.internal = false;
                    d->info.managed = false;
                    d->info.chainReason = CHAIN_ENTER_UNMANAGED;

                    // Note, for this special frame, we load the registers directly from the filter context if there is
                    // one.
                    CONTEXT *c = d->thread->GetFilterContext();

                    if (c == NULL)
                    {
                        d->info.registers = d->regDisplay;
                    }
                    else
                    {
#ifdef _X86_
                        REGDISPLAY *rd = &(d->info.registers);
                        rd->pContext = c;
                        rd->pEdi = &(c->Edi);
                        rd->pEsi = &(c->Esi);
                        rd->pEbx = &(c->Ebx);
                        rd->pEdx = &(c->Edx);
                        rd->pEcx = &(c->Ecx);
                        rd->pEax = &(c->Eax);
                        rd->pEbp = &(c->Ebp);
                        rd->Esp  =   c->Esp;
                        rd->pPC  = (SLOT*)&(c->Eip);
#else
                        // @todo port: need to port to other processors
                        d->info.registers = d->regDisplay;
#endif                        
                    }
                    
                    if ((d->pCallback)(&d->info, d->pData) == SWA_ABORT)
                        return SWA_ABORT;
                
                    // Restore the good info.
                    d->info = goodInfo;
                }
            }
            
			if ((d->pCallback)(&d->info, d->pData) == SWA_ABORT)
				return SWA_ABORT;
		}

		//
		// Update context for next frame.
		//

		if (d->newContext != NULL)
		{
			d->info.context = d->newContext;
			d->newContext = NULL;
		}
	}

    bool use=false;

    //
    // Examine the frame.
    //

    MethodDesc *md = pCF->GetFunction();

    // We assume that the stack walker is just updating the
    // register display we passed in - assert it to be sure
    _ASSERTE(pCF->GetRegisterSet() == &d->regDisplay);

    d->info.frame = frame;
    d->lastFrameWasEntry = false;

    // Record the appdomain that the thread was in when it
    // was running code for this frame.
    d->info.currentAppDomain = pCF->GetAppDomain();
    
    //  Grab all the info from CrawlFrame that we need to 
    //  check for "Am I in an exeption code blob?" now.

	if (pCF->IsFrameless())
	{
		use = true;
		d->info.managed = true;
		d->info.internal = false;
		d->info.chainReason = CHAIN_NONE;
		d->needParentInfo = true; // Possibly need chain reason
		d->info.relOffset =  pCF->GetRelOffset();
        d->info.pIJM = pCF->GetJitManager();
        d->info.MethodToken = pCF->GetMethodToken();
	}
	else
	{
        d->info.pIJM = NULL;
        d->info.MethodToken = NULL;
		//
		// Retrieve any interception info
		//

		switch (frame->GetInterception())
		{
		case Frame::INTERCEPTION_CLASS_INIT:
			d->info.chainReason = CHAIN_CLASS_INIT;
			break;

		case Frame::INTERCEPTION_EXCEPTION:
			d->info.chainReason = CHAIN_EXCEPTION_FILTER;
			break;

		case Frame::INTERCEPTION_CONTEXT:
			d->info.chainReason = CHAIN_CONTEXT_POLICY;
			break;

		case Frame::INTERCEPTION_SECURITY:
			d->info.chainReason = CHAIN_SECURITY;
			break;

		default:
			d->info.chainReason = CHAIN_NONE;
		}

		//
		// Look at the frame type to figure out how to treat it.
		//

		switch (frame->GetFrameType())
		{
		case Frame::TYPE_INTERNAL:

			/* If we have a specific interception type, use it. However, if this
			   is the top-most frame (with a specific type), we can ignore it
			   and it wont appear in the stack-trace */
#define INTERNAL_FRAME_ACTION(d, use)                              \
    (d)->info.managed = true;       \
    (d)->info.internal = false;     \
    use = true

            if (d->info.chainReason == CHAIN_NONE || pCF->IsActiveFrame())
            {
                use = false;
            }
            else
            {
			    INTERNAL_FRAME_ACTION(d, use);
            }
			break;

		case Frame::TYPE_ENTRY:
			d->info.managed = true;
			d->info.internal = true;
			d->info.chainReason = CHAIN_ENTER_MANAGED;
			d->lastFrameWasEntry = true;
            d->needEnterManaged = false;
			use = true;
			break;

		case Frame::TYPE_EXIT:
            LOG((LF_CORDB, LL_INFO100000, "DWSP: TYPE_EXIT.\n"));

			// 
			// This frame is used to represent the unmanaged
			// stack segment.
			//

			void *returnIP, *returnSP;

			frame->GetUnmanagedCallSite(NULL, &returnIP, &returnSP);

			// Check to see if we are inside the unmanaged call. We want to make sure we only reprot an exit frame after
			// we've really exited. There is a short period between where we setup the frame and when we actually exit
			// the runtime. This check is intended to ensure we're actually outside now.
            LOG((LF_CORDB, LL_INFO100000,
                 "DWSP: TYPE_EXIT: returnIP=0x%08x, returnSP=0x%08x, frame=0x%08x, threadFrame=0x%08x, regSP=0x%08x\n",
                 returnIP, returnSP, frame, d->thread->GetFrame(), GetRegdisplaySP(&d->regDisplay)));

			if ((frame != d->thread->GetFrame()) || (returnSP == NULL) || (GetRegdisplaySP(&d->regDisplay) <= returnSP))
			{
				// Send notification for this unmanaged frame.
                LOG((LF_CORDB, LL_INFO100000, "DWSP: Sending notification for unmanaged frame.\n"));
			
				if (!d->targetFound && d->targetFP <= returnSP)
					d->targetFound = true;

				if (d->targetFound)
				{
                    LOG((LF_CORDB, LL_INFO100000, "DWSP: TYPE_EXIT target found.\n"));
                    // Do we need to send out a enter managed chain
                    // first?
                    if (d->needEnterManaged)
                    {
                        d->needEnterManaged = false;
                        
                        if ((d->pCallback)(&d->enterManagedInfo,
                                           d->pData) == SWA_ABORT)
                            return SWA_ABORT;
                    }
            
					CorDebugChainReason oldReason = d->info.chainReason;

					d->info.md = NULL; // ??? md ?
					d->info.registers = d->regDisplay;

                    // If we have no call site, manufacture a FP
                    // using the current frame.

                    if (returnSP == NULL)
                        d->info.fp = ((BYTE*)frame) - sizeof(void*);
                    else
					d->info.fp = returnSP;
                    
					d->info.internal = false;
					d->info.managed = false;
					d->info.chainReason = CHAIN_ENTER_UNMANAGED;

					if ((d->pCallback)(&d->info, d->pData) == SWA_ABORT)
						return SWA_ABORT;

					d->info.chainReason = oldReason;

                    // We just sent a enter unmanaged chain, so we no longer
                    // need to send a special one for interop debugging.
                    d->needUnmanagedExit = false;
				}
			}

			d->info.managed = true;
			d->info.internal = true;
			use = true;
			break;

		case Frame::TYPE_INTERCEPTION:
        case Frame::TYPE_SECURITY: // Security is a sub-type of interception
			d->info.managed = true;
			d->info.internal = true;
			use = true;
			break;

		case Frame::TYPE_CALL:
			d->info.managed = true;
			d->info.internal = false;
			use = true;
			break;

        case Frame::TYPE_FUNC_EVAL:
            d->info.managed = true;
            d->info.internal = true;
            d->info.chainReason = CHAIN_FUNC_EVAL;
            use = true;
            break;

        // Put frames we want to ignore here:
        case Frame::TYPE_MULTICAST:
            if (d->ignoreNonmethodFrames)
            {
                // Multicast frames exist only to gc protect the arguments
                // between invocations of a delegate.  They don't have code that
                // we can (currently) show the user (we could change this with 
                // work, but why bother?  It's an internal stub, and even if the
                // user could see it, they can't modify it).
                LOG((LF_CORDB, LL_INFO100000, "DWSP: Skipping frame 0x%x b/c it's "
                    "a multicast frame!\n", frame));
                use = false;
            }
            else
            {
                LOG((LF_CORDB, LL_INFO100000, "DWSP: NOT Skipping frame 0x%x even thought it's "
                    "a multicast frame!\n", frame));
                INTERNAL_FRAME_ACTION(d, use);
            }
            break;
            
        case Frame::TYPE_TP_METHOD_FRAME:
            if (d->ignoreNonmethodFrames)
            {
                // Transparant Proxies push a frame onto the stack that they
                // use to figure out where they're really going; this frame
                // doesn't actually contain any code, although it does have
                // enough info into fooling our routines into thinking it does:
                // Just ignore these.
                LOG((LF_CORDB, LL_INFO100000, "DWSP: Skipping frame 0x%x b/c it's "
                    "a transparant proxy frame!\n", frame));
                use = false;
            }
            else
            {
                // Otherwise do the same thing as for internal frames
                LOG((LF_CORDB, LL_INFO100000, "DWSP: NOT Skipping frame 0x%x even though it's "
                    "a transparant proxy frame!\n", frame));
                INTERNAL_FRAME_ACTION(d, use);
            }
            break;

		default:
			_ASSERTE(!"Invalid frame type!");
			break;
		}
	}

	if (use)
	{
		d->info.md = md;
		d->info.registers = d->regDisplay;

		d->needParentInfo = true;
	}

	//
	// The stackwalker doesn't update the register set for the
	// case where a non-frameless frame is returning to another 
	// non-frameless frame.  Cover this case.
	// 
	// !!! This assumes that updating the register set multiple times
	// for a given frame times is not a bad thing...
	//

	if (!pCF->IsFrameless())
		pCF->GetFrame()->UpdateRegDisplay(&d->regDisplay);

	return SWA_CONTINUE;
}

StackWalkAction DebuggerWalkStack(Thread *thread, 
                                  void *targetFP,
								  CONTEXT *context, 
								  BOOL contextValid,
								  DebuggerStackCallback pCallback, 
								  void *pData,
								  BOOL fIgnoreNonmethodFrames,
                                  IpcTarget iWhich)
{
    _ASSERTE(context != NULL);

    DebuggerFrameData data;
    StackWalkAction result = SWA_CONTINUE;
    bool fRegInit = false;
    
    // For the in-process case, we need to be able to handle a thread trying to trace itself.
#ifdef _X86_
    if(contextValid || g_pEEInterface->GetThreadFilterContext(thread) != NULL)
    {
        fRegInit = g_pEEInterface->InitRegDisplay(thread, &data.regDisplay, context, contextValid != 0);

        // This should only have the possiblilty of failing on Win9x or inprocess debugging
        _ASSERTE(fRegInit || iWhich == IPC_TARGET_INPROC || RunningOnWin95());
    }    
#else
    _ASSERTE(!"NYI on non-x86 platform.");
#endif    

    if (!fRegInit)
    {
        // Note: the size of a CONTEXT record contains the extended registers, but the context pointer we're given
        // here may not have room for them. Therefore, we only set the non-extended part of the context to 0.
        memset((void *)context, 0, offsetof(CONTEXT, ExtendedRegisters));
        memset((void *)&data, 0, sizeof(data));
        data.regDisplay.pPC = (SLOT*)&(context->Eip);
    }

    data.thread = thread;
    data.info.quickUnwind = false;
    data.targetFP = targetFP;
    data.targetFound = (targetFP == NULL);
    data.needParentInfo = false;
    data.pCallback = pCallback;
    data.pData = pData;
    data.info.context = thread->GetContext();
    data.newContext = NULL;
    data.lastFrameWasEntry = true;
    data.needEnterManaged = false;
    data.needUnmanagedExit = ((thread->m_StateNC & Thread::TSNC_DebuggerStoppedInRuntime) != 0);
    data.ignoreNonmethodFrames = fIgnoreNonmethodFrames;
    
	if ((result != SWA_FAILED) && !thread->IsUnstarted() && !thread->IsDead())
	{
		int flags = 0;

		result = g_pEEInterface->StackWalkFramesEx(thread, &data.regDisplay, 
												   DebuggerWalkStackProc, 
												   &data, flags | HANDLESKIPPEDFRAMES);
	}
	else
		result = SWA_DONE;

	if (result == SWA_DONE || result == SWA_FAILED) // SWA_FAILED if no frames
	{
		if (data.needParentInfo)
		{
			data.info.fp = data.regDisplay.pPC;

			//
			// If we're looking for a specific frame, make sure that
			// this is actually the right one.
			//

			if (!data.targetFound
				&& data.targetFP <= data.info.fp)
					data.targetFound = true;

			if (data.targetFound)
			{
				if ((data.pCallback)(&data.info, data.pData) == SWA_ABORT)
					return SWA_ABORT;
			}
		}

		// 
		// Top off the stack trace as necessary.  If the topmost frame
		// was an entry frame, include the top part of the stack as an
		// unmanaged segment.  Otherwise, don't.
		//

		void *stackTop = (void*) FRAME_TOP;

		data.info.managed = !data.lastFrameWasEntry;

		data.info.md = NULL;
		data.info.internal = false;
		data.info.frame = (Frame *) FRAME_TOP;

		data.info.fp = stackTop;
		data.info.registers = data.regDisplay;
		data.info.chainReason = CHAIN_THREAD_START;
        data.info.currentAppDomain = NULL;

		result = data.pCallback(&data.info, data.pData);
	}

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\frameinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: frameinfo.h
//
// Debugger stack walker
//
// @doc
//*****************************************************************************

#ifndef FRAMEINFO_H_
#define FRAMEINFO_H_

/* ========================================================================= */

/* ------------------------------------------------------------------------- *
 * Classes
 * ------------------------------------------------------------------------- */

enum
{
    // Add an extra interception reason
    INTERCEPTION_THREAD_START = Frame::INTERCEPTION_COUNT
};

// @struct FrameInfo | Contains the information that will be handed to
// DebuggerStackCallback functions (along with their own, individual
// pData pointers).
//
// @field Frame *|frame|The current frame.  NULL implies that
//      the frame is frameless, meaning either unmanaged or managed.  This
//      is set to be FRAME_TOP (0xFFffFFff) if the frame is the topmost, EE
//      placed frame.
//
// @field   MethodDesc *|md|MetdhodDesc for the method that's
//      executing in this frame.  Will be NULL if there is no MethodDesc
// 
// @field void *|fp|frame pointer.  Actually filled in from
//      caller (parent) frame, so the DebuggerStackWalkProc must delay
//      the user callback for one frame.
//
// @field SIZE_T|reOffset|Native offset from the beginning of the method.
struct FrameInfo
{
    Frame               *frame; 
    MethodDesc          *md; 
    REGDISPLAY           registers;
    void                *fp; 
    bool                 quickUnwind; 
    bool                 internal; 
    bool                 managed; 
    Context             *context; 
    CorDebugChainReason  chainReason; 
    ULONG                relOffset; 
    IJitManager         *pIJM;
    METHODTOKEN          MethodToken;
    AppDomain           *currentAppDomain;
};

//@func StackWalkAction | DebuggerStackCallback | This callback will
// be invoked by DebuggerWalkStackProc at each frame, passing the FrameInfo
// and callback-defined pData to the method.  The callback then returns a
// SWA - if SWA_ABORT is returned then the walk stops immediately.  If
// SWA_CONTINUE is called, then the frame is walked & the next higher frame
// will be used.  If the current frame is at the top of the stack, then
// in the next iteration, DSC will be invoked with frame->frame == FRAME_TOP
// @xref <t FrameInfo>
typedef StackWalkAction (*DebuggerStackCallback)(FrameInfo *frame, void *pData);

//@func StackWalkAction | DebuggerWalkStack | Sets up everything for a
// stack walk for the debugger, starts the stack walk (via
// g_pEEInterface->StackWalkFramesEx), then massages the output.  Note that it
// takes a DebuggerStackCallback as an argument, but at each frame
// DebuggerWalkStackProc gets called, which in turn calls the
// DebuggerStackCallback.
// @parm Thread * | thread | Thread
// @parm void *|targetFP | If you're looking for a specific frame, then
//  this should be set to the fp for that frame, and the callback won't
//  be called until that frame is reached.  Otherwise, set it to NULL &
//  the callback will be called on every frame.
// @parm CONTEXT * | context | Never NULL, b/c the callbacks require the
//  CONTEXT as a place to store some information.  Either it points to an
//  uninitialized CONTEXT (contextValid should be false), or
//  a pointer to a valid CONTEXT for the thread.  If it's NULL, InitRegDisplay
//  will fill it in for us, so we shouldn't go out of our way to set this up.
// @parm bool | contextValid | TRUE if context points to a valid CONTEXT, FALSE
//  otherwise.
// @parm DebuggerStackCallback | pCallback | User supplied callback to
//  be invoked at every frame that's at targetFP or higher.
// @parm void * | pData | User supplied data that we shuffle around,
//  and then hand to pCallback.
// @xref <f DebuggerStackCallback>
StackWalkAction DebuggerWalkStack(Thread *thread, 
                                  void *targetFP,
								  CONTEXT *pContext, 
								  BOOL contextValid,
								  DebuggerStackCallback pCallback,
                                  void *pData, 
                                  BOOL fIgnoreNonmethodFrames,
                                  IpcTarget iWhich = IPC_TARGET_OUTOFPROC);

#endif // FRAMEINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\ilwalker.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: ilwalker.cpp
//
// IL instruction decoding/stepping logic
//
//*****************************************************************************

#include "stdafx.h"

#include "walker.h"

#include "frames.h"
#include "openum.h"
#include "opmaps.h"

/* ------------------------------------------------------------------------- *
 * Opcode tables
 * ------------------------------------------------------------------------- */

//
// table of opcode control flow types
//

#undef OPDEF
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl)      WALK_ ## ctrl,

static WALK_TYPE controlTypes[] =
{
#include "opcode.def"
};

//
// table of opcode argument sizes
//

enum
{
	SIZE_Inline0 = 0,
	SIZE_InlineU1 = 1,
	SIZE_InlineU2 = 2,
	SIZE_InlineU4 = 4,
	SIZE_InlineI1 = 1,
	SIZE_InlineI2 = 2,
	SIZE_InlineI4 = 4,
	SIZE_InlineI8 = 8,
	SIZE_InlineR4 = 4,
	SIZE_InlineR8 = 8,
	SIZE_InlinePcrel1 = 1,
	SIZE_InlinePcrel4 = 4,
	SIZE_InlineDescr4 = 4,
	SIZE_InlineClsgn4 = 4,
	SIZE_InlineTok = 4,
	SIZE_InlineU2Tok = 6,
	SIZE_InlineSwitch = -1        // not a fixed size
};

#undef OPDEF
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl)      SIZE_ ## args,

static char argSizes[] =
{
#include "opcode.def"
};

/* ------------------------------------------------------------------------- *
 * Useful macros
 * ------------------------------------------------------------------------- */

#define READ_STREAM_VALUE(p, t) (*((t*&)(p))++)
#define POP_STACK_VALUE(p, t)   (p += sizeof(t), *(t*)(p-sizeof(t)))

/* ------------------------------------------------------------------------- *
 * Opcode traversal and stepping routines
 * ------------------------------------------------------------------------- */

void ILWalker::Decode()
{
	const BYTE *ip = m_ip;

	//
	// First, read opcode
	//

	OpMap *opMap = g_pEEInterface->GetOpcodeMap(m_frame);

	DWORD opcode = opMap[0][*ip++];

	switch (opcode)
    {
    case CEE_PREFIXREF:
		opcode = READ_STREAM_VALUE(ip, unsigned short);
		break;

    case CEE_PREFIX1:
    case CEE_PREFIX2:
    case CEE_PREFIX3:
    case CEE_PREFIX4:
    case CEE_PREFIX5:
    case CEE_PREFIX6:
    case CEE_PREFIX7:
    case CEE_PREFIX8:
		// we assume they are in order
		_ASSERTE(CEE_PREFIX2 == CEE_PREFIX1 + 1);
		_ASSERTE(CEE_PREFIX3 == CEE_PREFIX1 + 2);
		_ASSERTE(CEE_PREFIX4 == CEE_PREFIX1 + 3);
		_ASSERTE(CEE_PREFIX5 == CEE_PREFIX1 + 4);
		_ASSERTE(CEE_PREFIX6 == CEE_PREFIX1 + 5);
		_ASSERTE(CEE_PREFIX7 == CEE_PREFIX1 + 6);
		_ASSERTE(CEE_PREFIX8 == CEE_PREFIX1 + 7);
		opcode = (OPCODE) opMap[opcode-CEE_PREFIX1+1][*ip++];
		break;

    default:
		// !!! error on macro?
		break;
    }

	if (opcode == CEE_BREAK)
		opcode = DebuggerController::GetPatchedOpcode(m_ip);

	m_opcode = opcode;

	//
	// Now, set opcode type
	//

	m_type = controlTypes[opcode];

	//
	// Set skip IP
	//

	if (opcode == CEE_SWITCH)
    {
		const BYTE *switchIP = ip;
		unsigned int numcases = READ_STREAM_VALUE(switchIP, int);
		m_skipIP = switchIP + (numcases*4);
    }
	else
		m_skipIP = ip + argSizes[opcode];

	//
	// Set the next IP if we can.
	//

	m_function = NULL;
	m_nextIP = NULL;

	switch (m_type)
	{
	case WALK_NEXT:
		m_nextIP = m_skipIP;
		break;

	case WALK_BRANCH:
		NextBranchIP(ip);
		break;

	case WALK_COND_BRANCH:
		if (m_frame != NULL)
			NextConditionalBranchIP(ip);
		break;

	case WALK_CALL:
		if (m_frame != NULL)
			NextCallIP(ip);
		break;

	case WALK_RETURN:
	case WALK_BREAK:
	case WALK_THROW:
	case WALK_META:
	case WALK_UNKNOWN:
	default:
		break;
	}
}

//
// NextBranchIP returns the address that the given branch opcode
// will branch to.
// ip           -> pointer to opcode's argument in the instruction stream
//

void ILWalker::NextBranchIP(const BYTE *ip)
{
  _ASSERTE(controlTypes[m_opcode] == WALK_BRANCH);

#define BRANCH(addtype)                                 \
    {                                                   \
        addtype offset = READ_STREAM_VALUE(ip, addtype);\
        ip += offset;                                   \
    }                                                   \
    break

    switch (m_opcode)
	{
	case CEE_ANN_DATA:
	case CEE_BR:
        BRANCH(int);
	case CEE_BR_S:
        BRANCH(char);

	default:
        _ASSERTE(!"bad branch opcode");
	}

	m_nextIP = ip;
}

//
// NextConditionalBranchIP returns the address that the
// given conditional branch will branch to (or the next instruction,
// if no branch).
// ip           -> pointer to opcode's argument in the instruction stream
//

void ILWalker::NextConditionalBranchIP(const BYTE *ip)
{
	_ASSERTE(controlTypes[m_opcode] == WALK_COND_BRANCH);

	// !!! EE

	BYTE *sp = m_frame->GetOpStackTop();

#define CONDITIONAL_BRANCH_1(addtype, optype, test)     \
    {                                                   \
        addtype offset = READ_STREAM_VALUE(ip, addtype);\
        optype value1 = POP_STACK_VALUE(sp, optype);    \
        if (test value1)                                \
          ip += offset;                                 \
    }                                                   \
    break

#define CONDITIONAL_BRANCH_2(addtype, optype, op)       \
    {                                                   \
        addtype offset = READ_STREAM_VALUE(ip, addtype);\
        optype value2 = POP_STACK_VALUE(sp, optype);    \
        optype value1 = POP_STACK_VALUE(sp, optype);    \
        if (value1 op value2)                           \
          ip += offset;                                 \
    }                                                   \
    break

    switch (m_opcode)
	{
	case CEE_BRFALSE:
		CONDITIONAL_BRANCH_1(int, int, !);
	case CEE_BRFALSE_S:
		CONDITIONAL_BRANCH_1(char, int, !);
	case CEE_BRTRUE:
		CONDITIONAL_BRANCH_1(int, int, +);
	case CEE_BRTRUE_S:
		CONDITIONAL_BRANCH_1(char, int, +);

	case CEE_DEPRECATED_BEQ_I4:
		CONDITIONAL_BRANCH_2(int, int, ==);
	case CEE_DEPRECATED_BEQ_I4_S:
		CONDITIONAL_BRANCH_2(char, int, ==);
	case CEE_DEPRECATED_BEQ_I8:
		CONDITIONAL_BRANCH_2(int, __int64, ==);
	case CEE_DEPRECATED_BEQ_I8_S:
		CONDITIONAL_BRANCH_2(char, __int64, ==);
	case CEE_DEPRECATED_BEQ_I:
		CONDITIONAL_BRANCH_2(int, void *, ==);
	case CEE_DEPRECATED_BEQ_I_S:
		CONDITIONAL_BRANCH_2(char, void *, ==);
	case CEE_DEPRECATED_BEQ_R4:
		CONDITIONAL_BRANCH_2(int, float, ==);
	case CEE_DEPRECATED_BEQ_R4_S:
		CONDITIONAL_BRANCH_2(char, float, ==);
	case CEE_DEPRECATED_BEQ_R8:
		CONDITIONAL_BRANCH_2(int, double, ==);
	case CEE_DEPRECATED_BEQ_R8_S:
		CONDITIONAL_BRANCH_2(char, double, ==);

	case CEE_DEPRECATED_BGT_I4:
		CONDITIONAL_BRANCH_2(int, int, >);
	case CEE_DEPRECATED_BGT_I4_S:
		CONDITIONAL_BRANCH_2(char, int, >);
	case CEE_DEPRECATED_BGT_I8:
		CONDITIONAL_BRANCH_2(int, __int64, >);
	case CEE_DEPRECATED_BGT_I8_S:
		CONDITIONAL_BRANCH_2(char, __int64, >);
	case CEE_DEPRECATED_BGT_U:
		CONDITIONAL_BRANCH_2(int, void *, >);
	case CEE_DEPRECATED_BGT_U_S:
		CONDITIONAL_BRANCH_2(char, void *, >);
	case CEE_DEPRECATED_BGT_R4:
		CONDITIONAL_BRANCH_2(int, float, >);
	case CEE_DEPRECATED_BGT_R4_S:
		CONDITIONAL_BRANCH_2(char, float, >);
	case CEE_DEPRECATED_BGT_R8:
		CONDITIONAL_BRANCH_2(int, double, >);
	case CEE_DEPRECATED_BGT_R8_S:
		CONDITIONAL_BRANCH_2(char, double, >);

	case CEE_DEPRECATED_BGE_I4:
		CONDITIONAL_BRANCH_2(int, int, >=);
	case CEE_DEPRECATED_BGE_I4_S:
		CONDITIONAL_BRANCH_2(char, int, >=);
	case CEE_DEPRECATED_BGE_I8:
		CONDITIONAL_BRANCH_2(int, __int64, >=);
	case CEE_DEPRECATED_BGE_I8_S:
		CONDITIONAL_BRANCH_2(char, __int64, >=);
	case CEE_DEPRECATED_BGE_U:
		CONDITIONAL_BRANCH_2(int, void *, >=);
	case CEE_DEPRECATED_BGE_U_S:
		CONDITIONAL_BRANCH_2(char, void *, >=);
	case CEE_DEPRECATED_BGE_R4:
		CONDITIONAL_BRANCH_2(int, float, >=);
	case CEE_DEPRECATED_BGE_R4_S:
		CONDITIONAL_BRANCH_2(char, float, >=);
	case CEE_DEPRECATED_BGE_R8:
		CONDITIONAL_BRANCH_2(int, double, >=);
	case CEE_DEPRECATED_BGE_R8_S:
		CONDITIONAL_BRANCH_2(char, double, >=);

	case CEE_DEPRECATED_BLT_I4:
		CONDITIONAL_BRANCH_2(int, int, <);
	case CEE_DEPRECATED_BLT_I4_S:
		CONDITIONAL_BRANCH_2(char, int, <);
	case CEE_DEPRECATED_BLT_I8:
		CONDITIONAL_BRANCH_2(int, __int64, <);
	case CEE_DEPRECATED_BLT_I8_S:
		CONDITIONAL_BRANCH_2(char, __int64, <);
	case CEE_DEPRECATED_BLT_U:
		CONDITIONAL_BRANCH_2(int, void *, <);
	case CEE_DEPRECATED_BLT_U_S:
		CONDITIONAL_BRANCH_2(char, void *, <);
	case CEE_DEPRECATED_BLT_R4:
		CONDITIONAL_BRANCH_2(int, float, <);
	case CEE_DEPRECATED_BLT_R4_S:
		CONDITIONAL_BRANCH_2(char, float, <);
	case CEE_DEPRECATED_BLT_R8:
		CONDITIONAL_BRANCH_2(int, double, <);
	case CEE_DEPRECATED_BLT_R8_S:
		CONDITIONAL_BRANCH_2(char, double, <);

	case CEE_DEPRECATED_BLE_I4:
		CONDITIONAL_BRANCH_2(int, int, <=);
	case CEE_DEPRECATED_BLE_I4_S:
		CONDITIONAL_BRANCH_2(char, int, <=);
	case CEE_DEPRECATED_BLE_I8:
		CONDITIONAL_BRANCH_2(int, __int64, <=);
	case CEE_DEPRECATED_BLE_I8_S:
		CONDITIONAL_BRANCH_2(char, __int64, <=);
	case CEE_DEPRECATED_BLE_U:
		CONDITIONAL_BRANCH_2(int, void *, <=);
	case CEE_DEPRECATED_BLE_U_S:
		CONDITIONAL_BRANCH_2(char, void *, <=);
	case CEE_DEPRECATED_BLE_R4:
		CONDITIONAL_BRANCH_2(int, float, <=);
	case CEE_DEPRECATED_BLE_R4_S:
		CONDITIONAL_BRANCH_2(char, float, <=);
	case CEE_DEPRECATED_BLE_R8:
		CONDITIONAL_BRANCH_2(int, double, <=);
	case CEE_DEPRECATED_BLE_R8_S:
		CONDITIONAL_BRANCH_2(char, double, <=);

	case CEE_DEPRECATED_BNE_I4:
		CONDITIONAL_BRANCH_2(int, int, !=);
	case CEE_DEPRECATED_BNE_I4_S:
		CONDITIONAL_BRANCH_2(char, int, !=);
	case CEE_DEPRECATED_BNE_I8:
		CONDITIONAL_BRANCH_2(int, __int64, !=);
	case CEE_DEPRECATED_BNE_I8_S:
		CONDITIONAL_BRANCH_2(char, __int64, !=);
	case CEE_DEPRECATED_BNE_U:
		CONDITIONAL_BRANCH_2(int, void *, !=);
	case CEE_DEPRECATED_BNE_U_S:
		CONDITIONAL_BRANCH_2(char, void *, !=);
	case CEE_DEPRECATED_BNE_UN_R4:
		CONDITIONAL_BRANCH_2(int, float, !=);
	case CEE_DEPRECATED_BNE_UN_R4_S:
		CONDITIONAL_BRANCH_2(char, float, !=);
	case CEE_DEPRECATED_BNE_UN_R8:
		CONDITIONAL_BRANCH_2(int, double, !=);
	case CEE_DEPRECATED_BNE_UN_R8_S:
		CONDITIONAL_BRANCH_2(char, double, !=);

	case CEE_SWITCH:
		{
			unsigned int numcases = READ_STREAM_VALUE(ip, int);
			unsigned int value = POP_STACK_VALUE(sp, int);

			unsigned int offset;
			if (value < numcases)
				offset = ((int *)ip)[value];
			else
				offset = 0;

			ip += (numcases*4) + offset;
		}
	break;

	default:
		_ASSERTE("not a branch statement");
	}

    m_nextIP = ip;
}

//
// NextCallFunction returns the next function to be executed after
// a call opcode.
//
// ip           -> pointer to opcode's argument in the instruction stream
//

void ILWalker::NextCallIP(const BYTE *ip)
{
	_ASSERTE(controlTypes[m_opcode] == WALK_CALL);

	BYTE *sp = m_frame->GetOpStackTop();

	m_nextIP = NULL;
	m_function = NULL;

	switch (m_opcode)
	{
	case CEE_CALL:
	case CEE_NEWOBJ:
		{
			unsigned int token = READ_STREAM_VALUE(ip, unsigned int);
			m_function = 
			  g_pEEInterface->GetNonvirtualMethod(
						 g_pEEInterface->MethodDescGetModule(
												   m_frame->GetFunction()),
												   token);
		}
		break;

	case CEE_CALLVIRT:
		{
			unsigned int token = READ_STREAM_VALUE(ip, unsigned int);
			Object *object = POP_STACK_VALUE(sp, Object *);

			if (object == NULL)
				break;

			m_function = (MethodDesc *) 
			  g_pEEInterface->GetVirtualMethod(
						 g_pEEInterface->MethodDescGetModule(
												   m_frame->GetFunction()),
											   object, token);
		}
		break;

	case CEE_CALLI:
		m_nextIP = (POP_STACK_VALUE(sp, const BYTE *));
		break;

	default:
		_ASSERTE(!"bad call opcode");
	}

	if (m_function != NULL)
		m_nextIP = m_function->GetPreStubAddr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\lscommon.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: LsCommon.cpp
//
// This file exists to pull in files from the right side
//
// @doc
//*****************************************************************************
#include "StdAfx.h"

#define UNDEFINE_RIGHT_SIDE_ONLY

#include ".\..\DI\Common.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\lshash.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: LsHash.cpp
//
// This file exists to pull in files from the right side
//
// @doc
//*****************************************************************************
#include "StdAfx.h"

#define UNDEFINE_RIGHT_SIDE_ONLY

#include "..\Di\Hash.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\lsdivalue.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: LsDiValue.cpp
//
// This file exists to pull in files from the right side
//
// @doc
//*****************************************************************************
#include "StdAfx.h"

#define UNDEFINE_RIGHT_SIDE_ONLY

#include "..\Di\DiValue.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\lsmodule.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: LsModule.cpp
//
// This file exists to pull in files from the right side
//
// @doc
//*****************************************************************************
#include "StdAfx.h"

#define UNDEFINE_RIGHT_SIDE_ONLY

#include "..\Di\Module.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\lsprocess.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: LsProcess.cpp
//
// This file exists to pull in files from the right side
//
// @doc
//*****************************************************************************
#include "StdAfx.h"

#define UNDEFINE_RIGHT_SIDE_ONLY

#include "..\DI\Process.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\lsthread.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: LsThread.cpp
//
// This file exists to pull in files from the right side
//
// @doc
//*****************************************************************************
#include "StdAfx.h"

#define UNDEFINE_RIGHT_SIDE_ONLY

#include "..\Di\RsThread.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: stdafx.h
//
//*****************************************************************************
#include <stdio.h>

#include <Windows.h>
#include <WinWrap.h>

#include <util.hpp>

#include <cordbpriv.h>
#include <DbgIPCEvents.h>
#include <debugger.h>
#include <controller.h>
#include <walker.h>
#include <frameinfo.h>
#include <CorError.h>
#include "..\Inc\Common.h"

#include "CorPub.h"
#include "Cordb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\rcthread.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: RCThread.cpp
//
// Runtime Controller Thread
//
//*****************************************************************************

#include <stdafx.h>
#include <aclapi.h>

#include "IPCManagerInterface.h"
#include "corsvcpriv.h"

// Get version numbers for IPCHeader stamp
#include "__file__.ver"

#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION 0x1000
#endif


//
// Constructor
//
DebuggerRCThread::DebuggerRCThread(Debugger* debugger)
    : m_debugger(debugger), m_rgDCB(NULL), m_thread(NULL), m_run(true),
      m_SetupSyncEvent(NULL), 
      m_threadControlEvent(NULL), 
      m_helperThreadCanGoEvent(NULL),
      m_FavorAvailableEvent(NULL),
      m_FavorReadEvent(NULL),
      m_cordb(NULL),
      m_fDetachRightSide(false)
{
    _ASSERTE(debugger != NULL);

    for( int i = 0; i < IPC_TARGET_COUNT;i++)
        m_rgfInitRuntimeOffsets[i] = true;

    // Initialize this here because we Destroy it in the DTOR. 
    // Note that this function can't fail. 
    InitializeCriticalSection(&m_FavorLock);
}


//
// Destructor. Cleans up all of the open handles the RC thread uses.
// This expects that the RC thread has been stopped and has terminated
// before being called.
//
DebuggerRCThread::~DebuggerRCThread()
{
    LOG((LF_CORDB,LL_INFO1000, "DebuggerRCThread::~DebuggerRCThread\n"));

    if( m_rgDCB != NULL)
    {
        for (int i = 0; i < IPC_TARGET_COUNT; i++)
        {
            if (m_rgDCB[i] != NULL)
            {
                if (m_rgDCB[i]->m_rightSideEventAvailable != NULL)
                    CloseHandle(m_rgDCB[i]->m_rightSideEventAvailable);

                if (m_rgDCB[i]->m_rightSideEventRead != NULL)
                    CloseHandle(m_rgDCB[i]->m_rightSideEventRead);

                if (m_rgDCB[i]->m_leftSideEventAvailable != NULL)
                    CloseHandle(m_rgDCB[i]->m_leftSideEventAvailable);

                if (m_rgDCB[i]->m_leftSideEventRead != NULL)
                    CloseHandle(m_rgDCB[i]->m_leftSideEventRead);

                if (m_rgDCB[i]->m_rightSideProcessHandle != NULL)
                    CloseHandle(m_rgDCB[i]->m_rightSideProcessHandle);

                if (m_rgDCB[i]->m_leftSideUnmanagedWaitEvent != NULL)
                    CloseHandle(m_rgDCB[i]->m_leftSideUnmanagedWaitEvent);

                if (m_rgDCB[i]->m_syncThreadIsLockFree != NULL)
                    CloseHandle(m_rgDCB[i]->m_syncThreadIsLockFree);

                if (m_rgDCB[i]->m_runtimeOffsets != NULL )
                {
                    delete m_rgDCB[i]->m_runtimeOffsets;
                    m_rgDCB[i]->m_runtimeOffsets = NULL;
                }
            }
        }

        delete [] m_rgDCB;
    }
    
    if (m_SetupSyncEvent != NULL)
        CloseHandle(m_SetupSyncEvent);

    if (m_thread != NULL)
        CloseHandle(m_thread);

    if (m_threadControlEvent != NULL)
        CloseHandle(m_threadControlEvent);

    if (m_helperThreadCanGoEvent != NULL)
        CloseHandle(m_helperThreadCanGoEvent);

    if (m_FavorAvailableEvent != NULL)
        CloseHandle(m_FavorAvailableEvent);

    if (m_FavorReadEvent != NULL)
        CloseHandle(m_FavorReadEvent);

    DeleteCriticalSection(&m_FavorLock);

    if (m_cordb != NULL)
    {
        m_cordb->Release();
        m_cordb = NULL;
    }
}

void DebuggerRCThread::CloseIPCHandles(IpcTarget iWhich)
{
	int i = (int)iWhich;

    if( m_rgDCB != NULL && m_rgDCB[i] != NULL)
    {
        if (m_rgDCB[i]->m_leftSideEventAvailable != NULL)
        {
            CloseHandle(m_rgDCB[i]->m_leftSideEventAvailable);
            m_rgDCB[i]->m_leftSideEventAvailable = NULL;
		}
		
        if (m_rgDCB[i]->m_leftSideEventRead != NULL)
        {
            CloseHandle(m_rgDCB[i]->m_leftSideEventRead);
            m_rgDCB[i]->m_leftSideEventRead = NULL;
		}

        if (m_rgDCB[i]->m_rightSideProcessHandle != NULL)
        {
            CloseHandle(m_rgDCB[i]->m_rightSideProcessHandle);
            m_rgDCB[i]->m_rightSideProcessHandle = NULL;
		}
    }
}    

HRESULT DebuggerRCThread::CreateSetupSyncEvent(void)
{
	WCHAR tmpName[256];
	HRESULT hr = S_OK;
	
	// Attempt to create the Setup Sync event.

    // PERF: We are no longer calling GetSystemMetrics in an effort to prevent
    //       superfluous DLL loading on startup.  Instead, we're prepending
    //       "Global\" to named kernel objects if we are on NT5 or above.  The
    //       only bad thing that results from this is that you can't debug
    //       cross-session on NT4.  Big bloody deal.
    if (RunningOnWinNT5())
        swprintf(tmpName, L"Global\\" CorDBIPCSetupSyncEventName, GetCurrentProcessId());
    else
        swprintf(tmpName, CorDBIPCSetupSyncEventName, GetCurrentProcessId());

    LOG((LF_CORDB, LL_INFO10000,
         "DRCT::I: creating setup sync event with name [%S]\n", tmpName));

    SECURITY_ATTRIBUTES *pSA = NULL;

    hr = g_pIPCManagerInterface->GetSecurityAttributes(GetCurrentProcessId(), &pSA);

    if (FAILED(hr))
        goto exit;
    
    m_SetupSyncEvent = WszCreateEvent(pSA, TRUE, FALSE, tmpName);
    
    // Do not fail because we cannot create the setup sync event.
    // This is to fix the security issue with debugger.
    //
    // if (m_SetupSyncEvent == NULL)
    // {
    //     hr = HRESULT_FROM_WIN32(GetLastError());
    //     goto exit;
    // }
    
exit:
    g_pIPCManagerInterface->DestroySecurityAttributes(pSA);
    
	return hr;
}

//
// Init sets up all the objects that the RC thread will need to run.
//
HRESULT DebuggerRCThread::Init(void)
{
    HRESULT hr = S_OK;
    HANDLE rightSideEventAvailable = NULL;
    HANDLE rightSideEventRead = NULL;
    HANDLE leftSideUnmanagedWaitEvent = NULL;
    HANDLE syncThreadIsLockFree = NULL;
    WCHAR tmpName[256];
    NAME_EVENT_BUFFER;
    SECURITY_ATTRIBUTES *pSA = NULL;

		
    if (m_debugger == NULL)
        return E_INVALIDARG;

    // Init should only be called once.
    if (g_pRCThread != NULL) 
        return E_FAIL;

    g_pRCThread = this;

    m_rgDCB = new DebuggerIPCControlBlock *[IPC_TARGET_COUNT];
    if (NULL == m_rgDCB)
    {
        return E_OUTOFMEMORY;
    }
    memset( m_rgDCB, 0, sizeof(DebuggerIPCControlBlock *)*IPC_TARGET_COUNT);


    // Create 2 events for managing favors: unnamed, auto-reset, default=not-signaled
    m_FavorAvailableEvent = WszCreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_FavorAvailableEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
    
    m_FavorReadEvent = WszCreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_FavorReadEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    // Create the thread control event.
    m_threadControlEvent = WszCreateEvent(NULL, FALSE, FALSE, NAME_EVENT(L"ThreadControlEvent"));
    if (m_threadControlEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    // Create the helper thread can go event. Manual reset, and
    // initially signaled.
    m_helperThreadCanGoEvent = WszCreateEvent(NULL, TRUE, TRUE, NAME_EVENT(L"HelperThreadCanGoEvent"));
    if (m_helperThreadCanGoEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    // We need to setup the shared memory and control block.
	// Get shared memory block from the IPCManager.
	if (g_pIPCManagerInterface == NULL) 
	{
		LOG((LF_CORDB, LL_INFO10000,
         "DRCT::I: g_pIPCManagerInterface == NULL, can't create IPC Block\n"));
		hr = E_FAIL;
		goto exit;
	}

    hr = g_pIPCManagerInterface->GetSecurityAttributes(GetCurrentProcessId(), &pSA);

    if (FAILED(hr))
        goto exit;

    // Create the events that the thread will need to receive events
    // from the out of process piece on the right side.
    // We will not fail out if CreateEvent fails for RSEA or RSER. Because
    // the worst case is that debugger cannot attach to debuggee.
    //
    rightSideEventAvailable = WszCreateEvent(pSA, FALSE, FALSE, NAME_EVENT(L"RightSideEventAvailable"));
    rightSideEventRead = WszCreateEvent(pSA, FALSE, FALSE, NAME_EVENT(L"RightSideEventRead"));

    leftSideUnmanagedWaitEvent = WszCreateEvent(NULL, TRUE, FALSE, NAME_EVENT(L"LeftSideUnmanagedWaitEvent"));

    if (leftSideUnmanagedWaitEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    syncThreadIsLockFree = WszCreateEvent(NULL, TRUE, FALSE, NAME_EVENT(L"SyncThreadIsLockFree"));

    if (syncThreadIsLockFree == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

	m_rgDCB[IPC_TARGET_OUTOFPROC] = g_pIPCManagerInterface->GetDebugBlock();

    // Don't fail out because the SHM failed to create
#if _DEBUG
    if (m_rgDCB[IPC_TARGET_OUTOFPROC] == NULL)
	{
	   LOG((LF_CORDB, LL_INFO10000,
             "DRCT::I: Failed to get Debug IPC block from IPCManager.\n"));
	}
#endif // _DEBUG

    // Copy RSEA and RSER into the control block only if SHM is created without error.
    if (m_rgDCB[IPC_TARGET_OUTOFPROC])
	{
        m_rgDCB[IPC_TARGET_OUTOFPROC]->Init(rightSideEventAvailable,
                                            rightSideEventRead, 
                                            NULL, 
                                            NULL,
                                            leftSideUnmanagedWaitEvent,
                                            syncThreadIsLockFree);

        // We have to ensure that most of the runtime offsets for the out-of-proc DCB are initialized right away. This is
        // needed to support certian races during an interop attach. Since we can't know whether an interop attach will ever
        // happen or not, we are forced to do this now. Note: this is really too early, as some data structures haven't been
        // initialized yet!
        hr = EnsureRuntimeOffsetsInit(IPC_TARGET_OUTOFPROC);
        if (FAILED(hr))
            goto exit;

        // Note: we have to mark that we need the runtime offsets re-initialized for the out-of-proc DCB. This is because
        // things like the patch table aren't initialized yet. Calling NeedRuntimeOffsetsReInit() ensures that this happens
        // before we really need the patch table.
        NeedRuntimeOffsetsReInit(IPC_TARGET_OUTOFPROC);

        m_rgDCB[IPC_TARGET_OUTOFPROC]->m_helperThreadStartAddr =
            DebuggerRCThread::ThreadProcStatic;

        m_rgDCB[IPC_TARGET_OUTOFPROC]->m_leftSideProtocolCurrent = CorDB_LeftSideProtocolCurrent;
        m_rgDCB[IPC_TARGET_OUTOFPROC]->m_leftSideProtocolMinSupported = CorDB_LeftSideProtocolMinSupported;
        
        LOG((LF_CORDB, LL_INFO10,
             "DRCT::I: version info: %d.%d.%d current protocol=%d, min protocol=%d\n",
             m_rgDCB[IPC_TARGET_OUTOFPROC]->m_verMajor, 
             m_rgDCB[IPC_TARGET_OUTOFPROC]->m_verMinor, 
             m_rgDCB[IPC_TARGET_OUTOFPROC]->m_checkedBuild,
             m_rgDCB[IPC_TARGET_OUTOFPROC]->m_leftSideProtocolCurrent,
             m_rgDCB[IPC_TARGET_OUTOFPROC]->m_leftSideProtocolMinSupported));
    }

    // Next we'll create the setup sync event for the right side - this
    // solves a race condition of "who gets to the setup code first?"
    // Since there's no guarantee that the thread executing managed
    // code will be executed after us, we've got to do this for
    // the inproc portion of the code, as well.

	hr = CreateSetupSyncEvent();
	if (FAILED(hr))
		goto exit;

    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // the event already exists.
        LOG((LF_CORDB, LL_INFO10000,
             "DRCT::I: setup sync event already exists.\n"));

        // Need to do some delayed initialization of the debugger services.
        DebuggerController::Initialize();

        // Wait for the Setup Sync event before continuing. 
        DWORD ret = WaitForSingleObject(m_SetupSyncEvent, INFINITE);

        if (ret != WAIT_OBJECT_0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        // We no longer need this event now.
        CloseHandle(m_SetupSyncEvent);
        m_SetupSyncEvent = NULL;

		// Open LSEA and LSER (which would have been 
		// created by Right side)

        // PERF: We are no longer calling GetSystemMetrics in an effort to prevent
        //       superfluous DLL loading on startup.  Instead, we're prepending
        //       "Global\" to named kernel objects if we are on NT5 or above.  The
        //       only bad thing that results from this is that you can't debug
        //       cross-session on NT4.  Big bloody deal.
        if (RunningOnWinNT5())
            swprintf(tmpName, L"Global\\" CorDBIPCLSEventAvailName,
                     GetCurrentProcessId());
        else
            swprintf(tmpName, CorDBIPCLSEventAvailName, GetCurrentProcessId());

        if (m_rgDCB[IPC_TARGET_OUTOFPROC])
        {
		    m_rgDCB[IPC_TARGET_OUTOFPROC]->m_leftSideEventAvailable = 
		        WszOpenEvent(EVENT_ALL_ACCESS,
						    true,
						    tmpName
						    );
		    
		    if (m_rgDCB[IPC_TARGET_OUTOFPROC]->m_leftSideEventAvailable == NULL)
		    {
			    hr = HRESULT_FROM_WIN32(GetLastError());
			    goto exit;
		    }
        }

        if (RunningOnWinNT5())
            swprintf(tmpName, L"Global\\" CorDBIPCLSEventReadName,
                     GetCurrentProcessId());
        else
            swprintf(tmpName, CorDBIPCLSEventReadName, GetCurrentProcessId());

        if (m_rgDCB[IPC_TARGET_OUTOFPROC])
        {
		    m_rgDCB[IPC_TARGET_OUTOFPROC]->m_leftSideEventRead = 
		            WszOpenEvent(EVENT_ALL_ACCESS,
				                true,
							    tmpName
							    );
		    
		    if (m_rgDCB[IPC_TARGET_OUTOFPROC]->m_leftSideEventRead == NULL)
		    {
			    hr = HRESULT_FROM_WIN32(GetLastError());
			    goto exit;
		    }
        }
        
        // At this point, the control block is complete and all four
        // events are available and valid for this process.
        
        // Since the sync event was created by the Right Side,
        // we'll need to mark the debugger as "attached."
        g_pEEInterface->MarkDebuggerAttached();
        m_debugger->m_debuggerAttached = TRUE;
    }
    else
    {
		LOG((LF_CORDB, LL_INFO10000,
			 "DRCT::I: setup sync event was created.\n"));	

        // At this point, only RSEA and RSER are in the control
        // block. LSEA and LSER will remain invalid until the first
        // receipt of an event from the Right Side.
        
        // Set the Setup Sync event to let the Right Side know that
        // we've finished setting up the control block.
        SetEvent(m_SetupSyncEvent);
    }
    
    // Now do this all again for the inproc stuff
    m_rgDCB[IPC_TARGET_INPROC] = GetInprocControlBlock();
    if (m_rgDCB[IPC_TARGET_INPROC] == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    m_rgDCB[IPC_TARGET_INPROC]->Init(NULL, 
                                     NULL, 
                                     NULL, 
                                     NULL,
                                     NULL,
                                     NULL);

exit:
    g_pIPCManagerInterface->DestroySecurityAttributes(pSA);
    return hr;
}


//
// Setup the Runtime Offsets struct.
//
HRESULT DebuggerRCThread::SetupRuntimeOffsets(DebuggerIPCControlBlock *pDCB)
{
    // Allocate the struct if needed. We just fill in any existing one.
    DebuggerIPCRuntimeOffsets *pRO = pDCB->m_runtimeOffsets;
    
    if (pRO == NULL)
    {
        pRO = new DebuggerIPCRuntimeOffsets();

        if (pRO == NULL)
            return E_OUTOFMEMORY;
    }

    // Fill out the struct.
    pRO->m_firstChanceHijackFilterAddr = Debugger::FirstChanceHijackFilter;
    pRO->m_genericHijackFuncAddr = Debugger::GenericHijackFunc;
    pRO->m_secondChanceHijackFuncAddr = Debugger::SecondChanceHijackFunc;
    pRO->m_excepForRuntimeBPAddr = Debugger::ExceptionForRuntime;
    pRO->m_excepForRuntimeHandoffStartBPAddr = Debugger::ExceptionForRuntimeHandoffStart;
    pRO->m_excepForRuntimeHandoffCompleteBPAddr = Debugger::ExceptionForRuntimeHandoffComplete;
    pRO->m_excepNotForRuntimeBPAddr = Debugger::ExceptionNotForRuntime;
    pRO->m_notifyRSOfSyncCompleteBPAddr = Debugger::NotifyRightSideOfSyncComplete;
    pRO->m_notifySecondChanceReadyForData = Debugger::NotifySecondChanceReadyForData;

    pRO->m_EEBuiltInExceptionCode1 = EXCEPTION_COMPLUS;
    pRO->m_EEBuiltInExceptionCode2 = EXCEPTION_MSVC;

    pRO->m_pPatches = DebuggerController::GetPatchTable();
    pRO->m_pPatchTableValid = DebuggerController::GetPatchTableValidAddr();
    pRO->m_offRgData = DebuggerPatchTable::GetOffsetOfEntries();
    pRO->m_offCData = DebuggerPatchTable::GetOffsetOfCount();
    pRO->m_cbPatch = sizeof(DebuggerControllerPatch);
    pRO->m_offAddr = offsetof(DebuggerControllerPatch, address);
    pRO->m_offOpcode = offsetof(DebuggerControllerPatch, opcode);
    pRO->m_cbOpcode = sizeof(((DebuggerControllerPatch*)0)->opcode);
    pRO->m_offTraceType = offsetof(DebuggerControllerPatch, trace.type);
    pRO->m_traceTypeUnmanaged = TRACE_UNMANAGED;

    g_pEEInterface->GetRuntimeOffsets(&pRO->m_TLSIndex,
                                      &pRO->m_EEThreadStateOffset,
                                      &pRO->m_EEThreadStateNCOffset,
                                      &pRO->m_EEThreadPGCDisabledOffset,
                                      &pRO->m_EEThreadPGCDisabledValue,
                                      &pRO->m_EEThreadDebuggerWord2Offset,
                                      &pRO->m_EEThreadFrameOffset,
                                      &pRO->m_EEThreadMaxNeededSize,
                                      &pRO->m_EEThreadSteppingStateMask,
                                      &pRO->m_EEMaxFrameValue,
                                      &pRO->m_EEThreadDebuggerWord1Offset,
                                      &pRO->m_EEThreadCantStopOffset,
                                      &pRO->m_EEFrameNextOffset,
                                      &pRO->m_EEIsManagedExceptionStateMask);

    // Remember the struct in the control block.
    pDCB->m_runtimeOffsets = pRO;

    return S_OK;
}
    

static LONG _debugFilter(LPEXCEPTION_POINTERS ep,
                         DebuggerIPCEvent *event)
{
    LOG((LF_CORDB, LL_INFO10,
         "Unhandled exception in Debugger::HandleIPCEvent\n"));
    
    DWORD pid = GetCurrentProcessId();
    DWORD tid = GetCurrentThreadId();
    
    int result = CorMessageBox(NULL, IDS_DEBUG_UNHANDLEDEXCEPTION_IPC, IDS_DEBUG_SERVICE_CAPTION,
                               MB_OK | MB_ICONEXCLAMATION, TRUE,
							   event->type & DB_IPCE_TYPE_MASK,
							   ep->ExceptionRecord->ExceptionCode,
                               ep->ContextRecord->Eip,
							   pid, pid, tid, tid);

    return EXCEPTION_CONTINUE_SEARCH;
}


//
// Primary function of the Runtime Controller thread. First, we let
// the Debugger Interface know that we're up and running. Then, we run
// the main loop.
//
void DebuggerRCThread::ThreadProc(void)
{
		// This message actually serves a purpose (which is why it is always run)
		// The Stress log is run during hijacking, when other threads can be suspended  
		// at arbitrary locations (including when holding a lock that NT uses to serialize 
		// all memory allocations).  By sending a message now, we insure that the stress 
		// log will not allocate memory at these critical times an avoid deadlock. 
	STRESS_LOG0(LF_ALL, LL_ALWAYS, "Debugger Thread spinning up\n");

    LOG((LF_CORDB, LL_INFO1000, "DRCT::TP: helper thread spinning up...\n"));
    
    // In case the SHM is not initialized properly, it will be noop
    if (m_rgDCB[IPC_TARGET_OUTOFPROC] == NULL)
        return;

    // Lock the debugger before spinning up.
    m_debugger->Lock();
 
    // Mark that we're the true helper thread. Now that we've marked
    // this, no other threads will ever become the temporary helper
    // thread.
    m_rgDCB[IPC_TARGET_OUTOFPROC]->m_helperThreadId = GetCurrentThreadId();

    LOG((LF_CORDB, LL_INFO1000, "DRCT::TP: helper thread id is 0x%x helperThreadId\n",
         m_rgDCB[IPC_TARGET_OUTOFPROC]->m_helperThreadId));
    
    // If there is a temporary helper thread, then we need to wait for
    // it to finish being the helper thread before we can become the
    // helper thread.
    if (m_rgDCB[IPC_TARGET_OUTOFPROC]->m_temporaryHelperThreadId != 0)
    {
        LOG((LF_CORDB, LL_INFO1000,
             "DRCT::TP: temporary helper thread 0x%x is in the way, "
             "waiting...\n",
             m_rgDCB[IPC_TARGET_OUTOFPROC]->m_temporaryHelperThreadId));

        m_debugger->Unlock();

        // Wait for the temporary helper thread to finish up.
        DWORD ret = WaitForSingleObject(m_helperThreadCanGoEvent, INFINITE);

        LOG((LF_CORDB, LL_INFO1000,
             "DRCT::TP: done waiting for temp help to finish up.\n"));
        
        _ASSERTE(ret == WAIT_OBJECT_0);
        _ASSERTE(m_rgDCB[IPC_TARGET_OUTOFPROC]->m_temporaryHelperThreadId==0);
    }
    else
    {
        LOG((LF_CORDB, LL_INFO1000,
             "DRCT::TP: no temp help in the way...\n"));
        
        m_debugger->Unlock();
    }

    // Run the main loop as the true helper thread.
    MainLoop(false);
}

void DebuggerRCThread::RightSideDetach(void)
{
    _ASSERTE( m_fDetachRightSide == false );
    m_fDetachRightSide = true;
    CloseIPCHandles(IPC_TARGET_OUTOFPROC);
}

//
// These defines control how many times we spin while waiting for threads to sync and how often. Note its higher in
// debug builds to allow extra time for threads to sync.
//
#define CorDB_SYNC_WAIT_TIMEOUT  125

#ifdef _DEBUG
#define CorDB_MAX_SYNC_SPIN_COUNT 80  // 80 * 125 = 10000 (10 seconds)
#else 
#define CorDB_MAX_SYNC_SPIN_COUNT 24  // 24 * 125 = 3000 (3 seconds)
#endif

//
// Main loop of the Runtime Controller thread. It waits for IPC events
// and dishes them out to the Debugger object for processing.
//
// Some of this logic is copied in Debugger::VrpcToVls
//
void DebuggerRCThread::MainLoop(bool temporaryHelp)
{
    LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: running main loop, temporaryHelp=%d\n", temporaryHelp));
         
    SIZE_T iWhich;
    HANDLE waitSet[DRCT_COUNT_FINAL];
    DWORD syncSpinCount = 0;

    // Make room for any Right Side event on the stack.
	DebuggerIPCEvent *e = NULL;
    
    // We start out just listening on RSEA and the thread control event...
    unsigned int waitCount = DRCT_COUNT_INITIAL;
    DWORD waitTimeout = INFINITE;
    waitSet[DRCT_CONTROL_EVENT] = m_threadControlEvent;
    waitSet[DRCT_RSEA] = m_rgDCB[IPC_TARGET_OUTOFPROC]->m_rightSideEventAvailable;
    waitSet[DRCT_FAVORAVAIL] = m_FavorAvailableEvent;

    while (m_run)
    {
        LOG((LF_CORDB, LL_INFO1000, "DRCT::ML: waiting for event.\n"));

        // If there is a debugger attached, wait on its handle, too...
        if (waitCount == DRCT_COUNT_INITIAL && m_rgDCB[IPC_TARGET_OUTOFPROC]->m_rightSideProcessHandle != NULL)
        {
            _ASSERTE((waitCount + 1) == DRCT_COUNT_FINAL);
            
            waitSet[DRCT_DEBUGGER_EVENT] = m_rgDCB[IPC_TARGET_OUTOFPROC]->m_rightSideProcessHandle;
            waitCount = DRCT_COUNT_FINAL;
        }

		if (m_fDetachRightSide)
		{
			m_fDetachRightSide = false;
			
            _ASSERTE(waitCount == DRCT_COUNT_FINAL);
            _ASSERTE((waitCount-1) == DRCT_COUNT_INITIAL);
            
            waitSet[DRCT_DEBUGGER_EVENT] = NULL;                
            waitCount = DRCT_COUNT_INITIAL;
		}

        // Wait for an event from the Right Side.
        DWORD ret = WaitForMultipleObjects(waitCount, waitSet, FALSE, waitTimeout);

        if (!m_run)
            continue;

        if (ret == WAIT_OBJECT_0 + DRCT_DEBUGGER_EVENT)
        {
            // If the handle of the right side process is signaled, then we've lost our controlling debugger. We
            // terminate this process immediatley in such a case.
            LOG((LF_CORDB, LL_INFO1000, "DRCT::ML: terminating this process. Right Side has exited.\n"));
            
            TerminateProcess(GetCurrentProcess(), 0);
            _ASSERTE(!"Should never reach this point.");
        }

        else if (ret == WAIT_OBJECT_0 + DRCT_FAVORAVAIL) 
        {
            // execute the callback set by DoFavor()
            (*m_fpFavor)(m_pFavorData);
            
            SetEvent(m_FavorReadEvent);
        }
        
        else if (ret == WAIT_OBJECT_0 + DRCT_RSEA)
        {
            iWhich = IPC_TARGET_OUTOFPROC;

            LOG((LF_CORDB,LL_INFO10000, "RSEA from out of process (right side)\n"));

            if (e == NULL)
                e = (DebuggerIPCEvent *) _alloca(CorDBIPC_BUFFER_SIZE);

            // If the RSEA is signaled, then handle the event from the Right Side.
            memcpy(e, GetIPCEventReceiveBuffer((IpcTarget)iWhich), CorDBIPC_BUFFER_SIZE);

            // If no reply is required, then let the Right Side go since we've got a copy of the event now.
            _ASSERTE(!e->asyncSend || !e->replyRequired);
            
            if (!e->replyRequired && !e->asyncSend)
            {
                LOG((LF_CORDB, LL_INFO1000, "DRCT::ML: no reply required, letting Right Side go.\n"));

                BOOL succ = SetEvent(m_rgDCB[iWhich]->m_rightSideEventRead);

                if (!succ)
                    CORDBDebuggerSetUnrecoverableWin32Error(m_debugger, 0, true);
            }
#ifdef LOGGING
            else if (e->asyncSend)
                LOG((LF_CORDB, LL_INFO1000, "DRCT::ML: async send.\n"));
            else
                LOG((LF_CORDB, LL_INFO1000, "DRCT::ML: reply required, holding Right Side...\n"));
#endif

            // Pass the event to the debugger for handling. Returns true if the event was a Continue event and we can
            // stop looking for stragglers.  We wrap this whole thing in an exception handler to help us debug faults.
            bool wasContinue = false;
            
            __try
            {
                wasContinue = m_debugger->HandleIPCEvent(e, (IpcTarget)iWhich);
            }
            __except(_debugFilter(GetExceptionInformation(), e))
            {
                LOG((LF_CORDB, LL_INFO10, "Unhandled exception caught in Debugger::HandleIPCEvent\n"));
            }

            if (wasContinue)
            {
                // Always reset the syncSpinCount to 0 on a continue so that we have the maximum number of possible
                // spins the next time we need to sync.
                syncSpinCount = 0;
                
                if (waitTimeout != INFINITE)
                {
                    LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: don't check for stragglers due to continue.\n"));
                
                    waitTimeout = INFINITE;
                }

                // If this thread was running the Main Loop in place of the real helper thread, then exit now that we
                // have received a continue message.
                if (temporaryHelp)
                    goto Exit;
            }
        }
        else if (ret == WAIT_OBJECT_0 + DRCT_CONTROL_EVENT)
        {
            LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: straggler event set.\n"));

            m_debugger->Lock();

            // Make sure that we're still synchronizing...
            if (m_debugger->IsSynchronizing())
            {
                LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: dropping the timeout.\n"));
                
                waitTimeout = CorDB_SYNC_WAIT_TIMEOUT;
            }
#ifdef LOGGING
            else
                LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: told to wait, but not syncing anymore.\n"));
#endif
            
            m_debugger->Unlock();
        }
        else if (ret == WAIT_TIMEOUT)
        {
            LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: wait timed out.\n"));
            
            m_debugger->Lock();

            // We should still be synchronizing, otherwise we would not have timed out.
            _ASSERTE(m_debugger->IsSynchronizing());

            // Only sweep if we're not stopped yet.
            if (!m_debugger->IsStopped())
            {
                LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: sweeping the thread list.\n"));
                
                // The wait has timed out. We only care if we're waiting on Runtime threads to sync. We run over the
                // current set of threads and see if any can be suspended now. If all threads are taken care of by this
                // call, it returns true so we know to that the current set is empty.
                //
                // We only do this a fixed number of times in Interop debugging mode. If it takes too long, we assume
                // that the current set of pending threads are deadlocked while still in preemptive GC mode and we give
                // up on them and sync anyway, leaving them suspended. Passing true to SweepThreadForDebug() causes this
                // to happen.
                bool timeToStop = false;

                if (m_rgDCB[IPC_TARGET_OUTOFPROC]->m_rightSideIsWin32Debugger &&
                    (syncSpinCount++ > CorDB_MAX_SYNC_SPIN_COUNT))
                {
                    LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: max spin count hit, forcing sync. syncSpinCount=%d\n",
                         syncSpinCount));

                    timeToStop = true;
                }
                
                if (g_pEEInterface->SweepThreadsForDebug(timeToStop))
                {
                    LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: wait set empty after sweep.\n"));

                    // There are no more threads to wait for, so go ahead and send the sync complete event.
                    m_debugger->Unlock();
                    m_debugger->SuspendComplete(TRUE);
                    m_debugger->Lock();
                    
                    waitTimeout = INFINITE;

                    // Note: we hold the thread store lock now...
                    m_debugger->m_RCThreadHoldsThreadStoreLock = TRUE;
                }
#ifdef LOGGING
                else
                    LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: threads still syncing after sweep.\n"));
#endif
            }
            else
            {
                LOG((LF_CORDB, LL_INFO1000, "DRCT::ML:: sweep unnecessary. Already stopped.\n"));

                waitTimeout = INFINITE; 
            }

            m_debugger->Unlock();
        }
    }

Exit:
    LOG((LF_CORDB, LL_INFO1000, "DRCT::ML: exiting, temporaryHelp=%d\n",
         temporaryHelp));
}


//
// This is the thread's real thread proc. It simply calls to the
// thread proc on the RCThread object.
//
/*static*/ DWORD WINAPI DebuggerRCThread::ThreadProcStatic(LPVOID parameter)
{
#ifdef _DEBUG
    dbgOnly_IdentifySpecialEEThread();
#endif

    DebuggerRCThread* t = (DebuggerRCThread*) parameter;
    t->ThreadProc();
    return 0;
}

//
// Start actually creates and starts the RC thread. It waits for the thread
// to come up and perform initial synchronization with the Debugger
// Interface before returning.
//
HRESULT DebuggerRCThread::Start(void)
{
    HRESULT hr = S_OK;

    DWORD dummy;

    // Note: strange as it may seem, the Right Side depends on us
    // using CreateThread to create the helper thread here. If you
    // ever change this to some other thread creation routine, you
    // need to update the logic in process.cpp where we discover the
    // helper thread on CREATE_THREAD_DEBUG_EVENTs...
    m_thread = CreateThread(NULL, 0, DebuggerRCThread::ThreadProcStatic,
                            (LPVOID) this, 0, &dummy);

    if (m_thread == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
    
exit:
    return hr;
}


//
// Stop causes the RC thread to stop receiving events and exit. It
// waits for it to exit before returning.
//
HRESULT DebuggerRCThread::Stop(void)
{
    HRESULT hr = S_OK;
    
    if (m_thread != NULL)
    {
        m_run = FALSE;

        if (m_rgDCB[IPC_TARGET_OUTOFPROC] && m_rgDCB[IPC_TARGET_OUTOFPROC]->m_rightSideEventAvailable != NULL)
        {
            BOOL succ = SetEvent(m_rgDCB[IPC_TARGET_OUTOFPROC]->m_rightSideEventAvailable);
            
            if (succ)
            {
                // Wait with a timeout. If we timeout, then that means
                // the helper thread is stuck on the loader lock and
                // we are doing this with the loader lock held,
                // probably in a DllMain somewhere. We only want to
                // wait for the thread to exit to ensure that its out
                // of our code before we rip the DLL out of memory,
                // and being stuck on the loader lock out of our
                // thread proc is just as good. So if we timeout, then
                // we don't care and we just keep going.
                DWORD ret = WaitForSingleObject(m_thread, 1000);
                
                if ((ret != WAIT_OBJECT_0) && (ret != WAIT_TIMEOUT))
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

HRESULT inline DebuggerRCThread::EnsureRuntimeOffsetsInit(int i)
{
    HRESULT hr = S_OK;
    
    if (m_rgfInitRuntimeOffsets[i] == true)         
    {                                               
        hr = SetupRuntimeOffsets(m_rgDCB[i]);       
        if (FAILED(hr))                             
            return hr;

        // RuntimeOffsets structure is setup.           
        m_rgfInitRuntimeOffsets[i] = false;             
    }                                               

    return hr;
}

//
// Call this function to tell the rc thread that we need the runtime offsets re-initialized at the next avaliable time.
//
void DebuggerRCThread::NeedRuntimeOffsetsReInit(int i)
{
    m_rgfInitRuntimeOffsets[i] = true;
}


//
// SendIPCEvent is used by the Debugger object to send IPC events to
// the Debugger Interface. It waits for acknowledgement from the DI
// before returning.
//
// NOTE: this assumes that the event send buffer has been properly
// filled in. All it does it wake up the DI and let it know that its
// safe to copy the event out of this process.
//
HRESULT DebuggerRCThread::SendIPCEvent(IpcTarget iTarget)
{
    // one inproc, one right side    
    _ASSERTE(IPC_TARGET_INPROC + 1 == IPC_TARGET_OUTOFPROC );
    _ASSERTE(IPC_TARGET_OUTOFPROC + 1 == IPC_TARGET_COUNT );
    _ASSERTE(m_debugger->ThreadHoldsLock());

    HRESULT hr = S_OK;
    DWORD ret = 0;
	BOOL succ;
    int i;
    int n;
	DebuggerIPCEvent* event;
    
	// check if we need to init the RuntimeOffsets structure in the 
	// IPC buffer.
    if (iTarget > IPC_TARGET_COUNT)    
    {
        i = 0;
        n = IPC_TARGET_COUNT;
    }
    else
    {
        i = iTarget;
        n = iTarget+1;
    }

    // Setup the Runtime Offsets struct.
    for(; i < n; i++)
    {
        // If the sending is to Any Attached debugger (for a given appdomain)
        // then we should skip those that aren't attached.
    
        // Tell the Debugger Interface there is an event for it to read.
        switch(i)
        {
            case IPC_TARGET_INPROC:
            {
                hr = EnsureRuntimeOffsetsInit(IPC_TARGET_INPROC);
                if (FAILED(hr))
                {
                    goto LError;
                }
                
                DebuggerIPCEvent* eventClone;
                eventClone = GetIPCEventSendBuffer(IPC_TARGET_INPROC);
                    
                _ASSERTE(m_cordb != NULL);

                if (FAILED(hr))
                {
                    goto LError;
                }

                // For broadcast or any, the caller put the
                // the message is in the out-of-proc's buffer
                if (iTarget != IPC_TARGET_INPROC)
                {
                    event = GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);

                    memmove( eventClone, event,sizeof(BYTE)*CorDBIPC_BUFFER_SIZE);
                }
                
                CordbProcess *proc;
                proc = (CordbProcess *) m_cordb->m_processes.GetBase(
                    ::GetCurrentProcessId());
                
                _ASSERTE(SUCCEEDED(hr)); //This should never fail

                LOG((LF_CORDB,LL_INFO1000, "SendIPCEvent %s "
                    "to inproc\n", IPCENames::GetName(eventClone->type)));
                
                m_cordb->m_rcEventThread->VrpcToVrs(proc, 
                                                    eventClone);

                LOG((LF_CORDB,LL_INFO1000, "SendIPCEvent %s "
                    "to inproc finished\n", IPCENames::GetName(eventClone->type)));
            
                break;
            }
            case IPC_TARGET_OUTOFPROC:
            {
                // This is a little strange, since we can send events to the
                // OOP _before_ we've attached to it.
                if (m_debugger->m_debuggerAttached 
                    || iTarget == IPC_TARGET_OUTOFPROC)
                {
                    event = GetIPCEventSendBuffer(IPC_TARGET_OUTOFPROC);

                    LOG((LF_CORDB,LL_INFO1000, "SendIPCEvent %s (tid:0x%x(%d))"
                        "to outofproc appD 0x%x, pid 0x%x(%d) tid:0x%x(%d)\n", IPCENames::GetName(event->type), 
                        event->threadId, event->threadId, event->appDomainToken, 
                        GetCurrentProcessId(), GetCurrentProcessId(),
                        GetCurrentThreadId(), GetCurrentThreadId()));

                    hr = EnsureRuntimeOffsetsInit(IPC_TARGET_OUTOFPROC);
                    if (FAILED(hr))
                    {
                        goto LError;
                    }

                    succ = SetEvent(
                        m_rgDCB[IPC_TARGET_OUTOFPROC]->m_leftSideEventAvailable);

                    LOG((LF_CORDB,LL_INFO1000, "Set lsea\n"));

                    if (!succ)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        m_debugger->UnrecoverableError(hr, 
                                                       0, 
                                                       __FILE__, 
                                                       __LINE__, 
                                                       false);
                        goto LError;
                    }

                    // Wait for the Debugger Interface to tell us that its read our event.
                    LOG((LF_CORDB,LL_INFO1000, "Waiting on lser\n"));
                    ret = WaitForSingleObject(
                            m_rgDCB[IPC_TARGET_OUTOFPROC]->m_leftSideEventRead, 
                            INFINITE);

                    if (ret != WAIT_OBJECT_0)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        m_debugger->UnrecoverableError(hr, 
                                                       0, 
                                                       __FILE__, 
                                                       __LINE__, 
                                                       false);
                        goto LError;
                    }
                    
                    LOG((LF_CORDB,LL_INFO1000,"SendIPCEvent %s "
                        "to outofproc finished\n", IPCENames::GetName(event->type)));
                }                        
                break;        
            }
        }
LError:        
        ; //try the next debugger
    }
    
    return hr;
}

//
// Return true if the helper thread is up & running
//
bool DebuggerRCThread::IsRCThreadReady()
{
    // The simplest check. If the threadid isn't set, we're not ready.
    if (GetDCB(IPC_TARGET_OUTOFPROC)->m_helperThreadId == 0)
        return false;

    // a more subtle check. It's possible the thread was up, but then
    // an evil call to ExitProcess suddenly terminated the helper thread,
    // leaving the threadid still non-0. So check the actual thread object
    // and make sure it's still around.
    if (WaitForSingleObject(m_thread, 0) != WAIT_TIMEOUT)
        return false;

    return true;
}
	
//
// A normal thread may hit a stack overflow and so we want to do
// any stack-intensive work on the Helper thread so that we don't
// blow the grace memory.
// Note that DoFavor will block until the fp is executed
//
void DebuggerRCThread::DoFavor(FAVORCALLBACK fp, void * pData)
{
    // We'll have problems if another thread comes in and 
    // deletes the RCThread object on us while we're in this call.
    if (IsRCThreadReady()) 
    {
        // If the helper thread calls this, we deadlock.
        // (Since we wait on an event that only the helper thread sets)
        _ASSERTE(GetRCThreadId() != GetCurrentThreadId());
    
        // Only lock if we're waiting on the helper thread.
        // This should be the only place the FavorLock is used.
        EnterCriticalSection(&m_FavorLock);
    
        m_fpFavor = fp;
        m_pFavorData = pData;
        
        // Our main message loop operating on the Helper thread will
        // pickup that event, call the fp, and set the Read event
        SetEvent(m_FavorAvailableEvent);

        LOG((LF_CORDB, LL_INFO10000, "DRCT::DF - Waiting on FavorReadEvent for favor 0x%08x\n", fp));
        
        // Wait for either the FavorEventRead to be set (which means that the favor 
        // was executed by the helper thread) or the helper thread's handle (which means
        // that the helper thread exited without doing the favor, so we should do it)
        //                                                                             
        // Note we are assuming that there's only 2 ways the helper thread can exit:
        // 1) Someone calls ::ExitProcess, killing all threads. That will kill us too, so we're "ok".
        // 2) Someone calls Stop(), causing the helper to exit gracefully. That's ok too. The helper
        // didn't execute the Favor (else the FREvent would have been set first) and so we can.
        //                                                                             
        // Beware of problems:
        // 1) If the helper can block, we may deadlock.
        // 2) If the helper can exit magically (or if we change the Wait to include a timeout) ,
        // the helper thread may have not executed the favor, partially executed the favor, 
        // or totally executed the favor but not yet signaled the FavorReadEvent. We don't
        // know what it did, so we don't know what we can do; so we're in an unstable state.
        
        const HANDLE waitset [] = { m_FavorReadEvent, m_thread };
        
        DWORD ret = WaitForMultipleObjects(
            NumItems(waitset),
            waitset,  
            FALSE, 
            INFINITE
        );

        DWORD wn = (ret - WAIT_OBJECT_0);
        if (wn == 0) // m_FavorEventRead
        {
            // Favor was executed, nothing to do here.
            LOG((LF_CORDB, LL_INFO10000, "DRCT::DF - favor 0x%08x finished, ret = %d\n", fp, ret));
        } 
        else 
        {
            LOG((LF_CORDB, LL_INFO10000, "DRCT::DF - lost helper thread during wait, "
                "doing favor 0x%08x on current thread\n", fp));
                
            // Since we have no timeout, we shouldn't be able to get an error on the wait,
            // but just in case ...
            _ASSERTE(ret != WAIT_FAILED);
            _ASSERTE((wn == 1) && !"DoFavor - unexpected return from WFMO");
            
            // Thread exited without doing favor, so execute it on our thread.
            // If we're here because of a stack overflow, this may push us over the edge,
            // but there's nothing else we can really do            
            (*fp)(pData);

            ResetEvent(m_FavorAvailableEvent);
        } 

        // m_fpFavor & m_pFavorData are meaningless now. We could set them
        // to NULL, but we may as well leave them as is to leave a trail.
         
        LeaveCriticalSection(&m_FavorLock);
    }
    else 
    {
        LOG((LF_CORDB, LL_INFO10000, "DRCT::DF - helper thread not ready, "
            "doing favor 0x%08x on current thread\n", fp));
        // If helper isn't ready yet, go ahead and execute the favor 
        // on the callee's space
        (*fp)(pData);
    }

    // Drop a log message so that we know if we survived a stack overflow or not
    LOG((LF_CORDB, LL_INFO10000, "DRCT::DF - Favor 0x%08x completed successfully\n", fp));
}


//
// SendIPCReply simply indicates to the Right Side that a reply to a
// two-way event is ready to be read and that the last event sent from
// the Right Side has been fully processed.
//
// NOTE: this assumes that the event receive buffer has been properly
// filled in. All it does it wake up the DI and let it know that its
// safe to copy the event out of this process.
//
HRESULT DebuggerRCThread::SendIPCReply(IpcTarget iTarget)
{
    HRESULT hr = S_OK;
    
#ifdef LOGGING    
    DebuggerIPCEvent* event = GetIPCEventReceiveBuffer(iTarget);

    LOG((LF_CORDB, LL_INFO10000, "D::SIPCR: replying with %s.\n",
         IPCENames::GetName(event->type)));
#endif

    if (iTarget == IPC_TARGET_OUTOFPROC)
    {
        BOOL succ = SetEvent(m_rgDCB[iTarget]->m_rightSideEventRead);

        if (!succ)
            hr = CORDBDebuggerSetUnrecoverableWin32Error(m_debugger, 0, false);
    }
    
    return hr;
}

//
// EarlyHelperThreadDeath handles the case where the helper
// thread has been ripped out from underneath of us by
// ExitProcess or TerminateProcess. These calls are pure evil, wacking
// all threads except the caller in the process. This can happen, for
// instance, when an app calls ExitProcess. All threads are wacked,
// the main thread calls all DLL main's, and the EE starts shutting
// down in its DLL main with the helper thread nuked.
//
void DebuggerRCThread::EarlyHelperThreadDeath(void)
{
    LOG((LF_CORDB, LL_INFO10000, "DRCT::EHTD\n"));
    
    // If we ever spun up a thread...
    if (m_thread != NULL && m_rgDCB[IPC_TARGET_OUTOFPROC])
    {
        m_debugger->Lock();

        m_rgDCB[IPC_TARGET_OUTOFPROC]->m_helperThreadId = 0;

        LOG((LF_CORDB, LL_INFO10000, "DRCT::EHTD helperThreadId\n"));
            
        m_debugger->Unlock();
    }
}

HRESULT DebuggerRCThread::InitInProcDebug(void)
{
    _ASSERTE(m_debugger != NULL);
    _ASSERTE(g_pDebugger != NULL);

    HRESULT hr = S_OK;

    // Check if the initialization has already happened
    if (m_cordb != NULL)
        goto LExit;

    m_cordb = new Cordb();
    TRACE_ALLOC(m_cordb);
    if (!m_cordb)
    {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }
    
    // Note that this creates no threads, nor CoCreateInstance()s
    // the metadata dispenser.
    hr = m_cordb->Initialize();
    if (FAILED(hr))
    {
        LOG((LF_CORDB, LL_INFO10000, "D::IIPD: Failed to Initialize "
            "ICorDebug\n"));

        goto LExit;
    }
    
    m_cordb->AddRef(); // we want to keep this around, for our use
    
    // We need to load this process, alone, into the cordb.
    CordbProcess *procThis;
    procThis= new CordbProcess(m_cordb,
                               m_debugger->GetPid(),
                               GetCurrentProcess());

    if (!procThis)
    {
        m_cordb->Release();
        m_cordb = NULL;
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    hr = procThis->Init(false); //NOT win32 attached
    _ASSERTE(SUCCEEDED(hr));
    
    // Add process to the hash
    hr = m_cordb->AddProcess(procThis);

    if (FAILED(hr))
        goto LExit;

    // Hold on to this process as ours.
    procThis->AddRef();
    m_cordb->m_procThis = procThis;

 LExit:
    return hr;
}


HRESULT DebuggerRCThread::UninitInProcDebug(void)
{
    HRESULT     hr = S_OK;

    // Free up the entire tree for this case, otherwise cycles will leak the
    // entire world.
    if (m_cordb)
    {
        m_cordb->Neuter();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: stdafx.cpp
//
// Host for precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\x86walker.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: x86walker.cpp
//
// x86 instruction decoding/stepping logic
//
//*****************************************************************************

#include "stdafx.h"

#include "walker.h"

#include "frames.h"
#include "openum.h"


#ifdef _X86_

//
// Decode the mod/rm part of an instruction.
//
void x86Walker::DecodeModRM(BYTE mod, BYTE reg, BYTE rm, const BYTE *ip)
{
    switch (mod)
    {
    case 0:
        {
            if (rm == 5)
            {
                // rm == 5 is a basic disp32
                m_nextIP =
                    (BYTE*) *(*((UINT32**)ip));
                m_skipIP = ip + 4;
            }
            else if (rm == 4)
            {
                // rm == 4 means a SIB follows.
                BYTE sib = *ip++;
                BYTE scale = (sib & 0xC0) >> 6;
                BYTE index = (sib & 0x38) >> 3;
                BYTE base  = (sib & 0x07);

                // grab the index register
                DWORD indexVal = 0;
                            
                if (m_registers != NULL)
                    indexVal = GetRegisterValue(index);

                // scale the index
                indexVal *= 1 << scale;
                            
                // base == 5 indicates a 32 bit displacement
                if (base == 5)
                {
                    // Grab the displacement
                    UINT32 disp = *((UINT32*)ip);

                    // nextIP is [index + disp]...
                    m_nextIP = (BYTE*) *((UINT32*) (indexVal +
                                                    disp));

                    // Make sure to skip the disp.
                    m_skipIP = ip + 4;
                }
                else
                {
                    // nextIP is just [index]
                    m_nextIP = (BYTE*) *((UINT32*) indexVal);
                    m_skipIP = ip;
                }
            }
            else
            {
                // rm == 0, 1, 2, 3, 6, 7 is [register]
                if (m_registers != NULL)
                    m_nextIP = (BYTE*) *((UINT32*) GetRegisterValue(rm));

                m_skipIP = ip;
            }

            break;
        }

    case 1:
        {
            char tmp = *ip; // it's important that tmp is a _signed_ value

            if (m_registers != NULL)
                m_nextIP = (BYTE*) *((UINT32*)(GetRegisterValue(rm) + tmp));

            m_skipIP = ip + 1;

            break;
        }

    case 2:
        {
            /* !!! seems wrong... */
            UINT32 tmp = *(UINT32*)ip;

            if (m_registers != NULL)
                m_nextIP = (BYTE*) *((UINT32*)(GetRegisterValue(rm) + tmp));

            m_skipIP = ip + 4;
            break;
        }
                
    case 3:
        {
            if (m_registers != NULL)
                m_nextIP = (BYTE*) GetRegisterValue(rm);

            m_skipIP = ip;
            break;
        }
                
    default:
        _ASSERTE(!"Invalid mod!");
    }
}

//
// The x86 walker is currently pretty minimal.  It only recognizes call and return opcodes, plus a few jumps.  The rest
// is treated as unknown.
//
void x86Walker::Decode()
{
	const BYTE *ip = m_ip;

	// Read the opcode
	m_opcode = *ip++;

	if (m_opcode == 0xcc)
		m_opcode = DebuggerController::GetPatchedOpcode(m_ip);

	m_type = WALK_UNKNOWN;
	m_skipIP = NULL;
	m_nextIP = NULL;

	// Analyze what we can of the opcode
	switch (m_opcode)
	{
	case 0xff:
        {
            // This doesn't decode all the possible addressing modes of the call instruction, just the ones I know we're
            // using right now. We really need this to decode everything someday...
            BYTE modrm = *ip++;
			BYTE mod = (modrm & 0xC0) >> 6;
			BYTE reg = (modrm & 0x38) >> 3;
			BYTE rm  = (modrm & 0x07);

            switch (reg)
            {
			case 2:
                // reg == 2 indicates that these are the "FF /2" calls (CALL r/m32)
                m_type = WALK_CALL;
                DecodeModRM(mod, reg, rm, ip);
                break;

            case 4:
                // FF /4 -- JMP r/m32
                m_type = WALK_BRANCH;
                DecodeModRM(mod, reg, rm, ip);
                break;

            case 5:
                // FF /5 -- JMP m16:32
                m_type = WALK_BRANCH;
                DecodeModRM(mod, reg, rm, ip);
                break;
                
            default:
                // A call or JMP we don't decode.
                break;
            }

			break;
		}

	case 0xe8:
        {
			m_type = WALK_CALL;

            UINT32 disp = *((UINT32*)ip);
            m_nextIP = ip + 4 + disp;
            m_skipIP = ip + 4;

			break;
        }
	case 0x9a:
        {
			m_type = WALK_CALL;

            m_nextIP = (BYTE*) *((UINT32*)ip);
            m_skipIP = ip + 4;

			break;
        }

	case 0xc2:
	case 0xc3:
	case 0xca:
	case 0xcb:
		m_type = WALK_RETURN;
		break;

	default:
		break;
	}
}


//
// Given a regdisplay and a register number, return the value of the register.
//

DWORD x86Walker::GetRegisterValue(int registerNumber)
{
    switch (registerNumber)
    {
    case 0:
        return *m_registers->pEax;
        break;
    case 1:
        return *m_registers->pEcx;
        break;
    case 2:
        return *m_registers->pEdx;
        break;
    case 3:
        return *m_registers->pEbx;
        break;
    case 4:
        return m_registers->Esp;
        break;
    case 5:
        return *m_registers->pEbp;
        break;
    case 6:
        return *m_registers->pEsi;
        break;
    case 7:
        return *m_registers->pEdi;
        break;
    default:
        _ASSERTE(!"Invalid register number!");
    }
    
    return 0;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\sources.inc ===
#
# Viper build instructions for this directory
#
#   Bob Atkinson
#   April 1997

!include $(NTMAKEENV)\sources.cor

INCLUDES        =$(INCLUDES);.;..;..\..\..\vm;..\..\..\vm\$(_TGTCPU);..\..\..\CeeGen\inc;..\..\inc;..\..\..\inc

C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE -DJIT_OR_NATIVE_SUPPORTED=1 $(USER_SPECIFIC_C_DEFINES)

# Don't turn this on!
USE_RTTI        = FALSE

MINORCOMP       = cor

TARGETNAME      =$(CORBUILDENV)cordbee_$(_CORFLAVOR)
TARGETPATH      =$(TARGETCORLIB)
TARGETTYPE      =LIBRARY

### CCover, for some reason, has a problem instrumenting 
### source in the precompiled headers for this directory.
!ifndef CCOVER
PRECOMPILED_INCLUDE     = ..\stdafx.h
PRECOMPILED_CXX         = 1
PRECOMPILED_SOURCEFILE  = ..\stdafx.cpp
!endif

#
# BUILD_DEBUGGER is defined in sources.cor
#
#BUILD_DEBUGGER=yes
#!if "$(BUILD_DEBUGGER)"=="yes"
SOURCES=                \
    ..\Debugger.cpp        \
    ..\RCThread.cpp        \
    ..\Thread.cpp          \
    ..\controller.cpp      \
    ..\x86walker.cpp       \
    ..\frameinfo.cpp       \
    ..\LsCommon.cpp        \
    ..\LsProcess.cpp       \
    ..\LsHash.cpp          \
    ..\LsModule.cpp        \
    ..\LsThread.cpp        \
    ..\LsDiValue.cpp
#!else
#SOURCES=
#!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\inc\common.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef DEBUGGER_COMMON_H
#define DEBUGGER_COMMON_H

// Handles are named under _DEBUG.
// But with multiple cordb's in same proc, they contend with the same events.
#ifdef _DEBUG_Bug85551Fixed
void vDbgNameEvent(PWCHAR wczName, DWORD dwNameSize, DWORD dwLine, PCHAR szFile, const PWCHAR wczEventName);
#define NAME_EVENT_BUFFER WCHAR ___wczName[1024]
#define NAME_EVENT(wczEventName) (vDbgNameEvent(___wczName, 1024, __LINE__, __FILE__, wczEventName), ___wczName)
#else
#define NAME_EVENT_BUFFER   
#define NAME_EVENT(wczEventName) NULL
#endif

#define PTR_TO_CORDB_ADDRESS(_ptr) (CORDB_ADDRESS)(ULONG)(_ptr)
            
/* ------------------------------------------------------------------------- *
 * Constant declarations
 * ------------------------------------------------------------------------- */

enum
{
    NULL_THREAD_ID = -1,
    NULL_PROCESS_ID = -1
};
/* ------------------------------------------------------------------------- *
 * Macros
 * ------------------------------------------------------------------------- */
// Put this line in to detext these errors more easily
//    _ASSERTE( !"Null ptr where there shouldn't be!" );                       \

#define VALIDATE_POINTER_TO_OBJECT(ptr, type)                                \
if ((ptr) == NULL)                                                           \
{                                                                            \
    return E_INVALIDARG;                                                     \
}

#define VALIDATE_POINTER_TO_OBJECT_OR_NULL(ptr, type)                        \
if ((ptr) == NULL)                                                           \
    goto LEndOfValidation##ptr;                                              \
VALIDATE_POINTER_TO_OBJECT((ptr), (type));                                   \
LEndOfValidation##ptr:

#define VALIDATE_POINTER_TO_OBJECT_ARRAY(ptr, type, cElt, fRead, fWrite)     \
if ((ptr) == NULL)                                                           \
{                                                                            \
    return E_INVALIDARG;                                                     \
}                                                                            \
if ((fRead) == true && IsBadReadPtr( (const void *)(ptr),                    \
    (cElt)*sizeof(type)))                                                    \
{                                                                            \
    return E_INVALIDARG;                                                     \
}                                                                            \
if ((fWrite) == true && IsBadWritePtr( (void *)(ptr),                        \
    (cElt)*sizeof(type)))                                                    \
{                                                                            \
    return E_INVALIDARG;                                                     \
}                                                                            

#define VALIDATE_POINTER_TO_OBJECT_ARRAY_OR_NULL(ptr, type,cElt,fRead,fWrite)\
if ((ptr)==NULL)                                                             \
{                                                                            \
    goto LEndOfValidation##ptr;                                              \
}                                                                            \
VALIDATE_POINTER_TO_OBJECT_ARRAY(ptr,type,cElt,fRead,fWrite);                \
LEndOfValidation##ptr:

/* ------------------------------------------------------------------------- *
 * Function Prototypes
 * ------------------------------------------------------------------------- */

// _skipFunkyModifiersInSignature will skip the modifiers that
// we don't care about.  Everything we care about is listed as
// a case in CreateValueByType. 
ULONG _skipFunkyModifiersInSignature(PCCOR_SIGNATURE sig);

// Skips past the calling convention, argument count (saving that into
// *pCount), then moves past the return type.
ULONG _skipMethodSignatureHeader(PCCOR_SIGNATURE sig, ULONG *pCount);

// _skipTypeInSignature -- skip past a type in a given signature.
// Returns the number of bytes used by the type in the signature.
//
// @todo: just yanked this from the shell. We really need something in
// utilcode to do this stuff...
ULONG _skipTypeInSignature(PCCOR_SIGNATURE sig,
                           bool *pfPassedVarArgSentinel = NULL);

// Returns 0 if the next thing in the signature ISN'T a VarArgs sentinel;
// returns the size (in bytes) of the VA sentinel otherwise.
ULONG _detectAndSkipVASentinel(PCCOR_SIGNATURE sig);

// Return the size of the next element in the method.  U1, I1 = 1 byte,etc.
//
// If the type is a value class, we'll assign the token of the class to
// *pmdValueClass, if pmdValueClass is nonNULL.  The caller can then
// invoke something like EEClass::GetAlignedNumInstanceFieldBytes(), or
// CordbClass::GetObjectSize() to get the actual size.  The return value
// will be zero, in this case.  If the type isn't a value class, then
// pmdValueClass is mdTokenNil after _sizeOfElementInstance returns.
ULONG _sizeOfElementInstance(PCCOR_SIGNATURE sig,
                             mdTypeDef *pmdValueClass = NULL);

void _CopyThreadContext(CONTEXT *c1, CONTEXT *c2);

// We only want to use ReadProcessMemory if we're truely out of process
#ifdef RIGHT_SIDE_ONLY

#define ReadProcessMemoryI ReadProcessMemory

#else //in-proc

BOOL inline ReadProcessMemoryI(
  HANDLE hProcess,  // handle to the process whose memory is read
  LPCVOID lpBaseAddress,
                    // address to start reading
  LPVOID lpBuffer,  // address of buffer to place read data
  DWORD nSize,      // number of bytes to read
  LPDWORD lpNumberOfBytesRead 
                    // address of number of bytes read
)
{
    return (ReadProcessMemory(GetCurrentProcess(), lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead));
}

#endif //RIGHT_SIDE_ONLY

// Linear search through an array of NativeVarInfos, to find
// the variable of index dwIndex, valid at the given ip.
//
// returns CORDBG_E_IL_VAR_NOT_AVAILABLE if the variable isn't
// valid at the given ip.
//
// This should be inlined
HRESULT FindNativeInfoInILVariableArray(DWORD dwIndex,
                                        SIZE_T ip,
                                        ICorJitInfo::NativeVarInfo **ppNativeInfo,
                                        unsigned int nativeInfoCount,
                                        ICorJitInfo::NativeVarInfo *nativeInfo);


#define VALIDATE_HEAP
//HeapValidate(GetProcessHeap(), 0, NULL);


// This contains enough information to determine what went wrong with
// an edit and continue.  One info per error reported.
#define ENCERRORINFO_MAX_STRING_SIZE (60)
typedef struct tagEnCErrorInfo
{
	HRESULT 	m_hr;
	void 	   *m_module; // In the left side, this is a pointer to a
					 // DebuggerModule, which then is used to look
					 // up the CordbModule on the right side.
	void       *m_appDomain; // The domain to which the changes are
					// being applied.
	mdToken		m_token; // Metadata token that the error pertains to.
	WCHAR		m_sz[ENCERRORINFO_MAX_STRING_SIZE];
					// in-line for ease-of-transfer across processes.
	
} EnCErrorInfo;

#define ADD_ENC_ERROR_ENTRY(pEnCError, hr, module, token)					\
	(pEnCError)->m_hr = (hr);												\
	(pEnCError)->m_module = (module);										\
	(pEnCError)->m_token = (token);												

typedef CUnorderedArray<EnCErrorInfo, 11> UnorderedEnCErrorInfoArray;

typedef struct tagEnCRemapInfo
{
    BOOL            m_fAccurate;
    void           *m_debuggerModuleToken; //LS pointer to DebuggerModule
    // Carry along enough info to instantiate, if we have to.
    mdMethodDef     m_funcMetadataToken ;
    mdToken         m_localSigToken;
    ULONG           m_RVA;
    DWORD           m_threadId;
    void           *m_pAppDomainToken;
} EnCRemapInfo;

typedef CUnorderedArray<EnCRemapInfo, 31> UnorderedEnCRemapArray;



#ifndef RIGHT_SIDE_ONLY

// This can be called from anywhere.
#define CHECK_INPROC_PROCESS_STATE() (g_pGCHeap->IsGCInProgress() && g_profControlBlock.fIsSuspended)

// To be used only from a CordbThread object.
#define CHECK_INPROC_THREAD_STATE() (CHECK_INPROC_PROCESS_STATE() || m_fThreadInprocIsActive)

#endif

//  @struct DebuggerILToNativeMap| Holds the IL to Native offset map
//	Great pains are taken to ensure that this each entry corresponds to the
//	first IL instruction in a source line.  It isn't actually a mapping
//	of _every_ IL instruction in a method, just those for source lines.
//  @field SIZE_T|ilOffset|IL offset of a source line.
//  @field SIZE_T|nativeStartOffset|Offset within the method where the native
//		instructions corresponding to the IL offset begin.
//  @field SIZE_T|nativeEndOffset|Offset within the method where the native
//		instructions corresponding to the IL offset end.
//
//  Note: any changes to this struct need to be reflected in
//  COR_DEBUG_IL_TO_NATIVE_MAP in CorDebug.idl. These structs must
//  match exactly.
//
struct DebuggerILToNativeMap
{
    ULONG ilOffset;
    ULONG nativeStartOffset;
    ULONG nativeEndOffset;
    ICorDebugInfo::SourceTypes source;
};

void ExportILToNativeMap(ULONG32 cMap,             
             COR_DEBUG_IL_TO_NATIVE_MAP mapExt[],  
             struct DebuggerILToNativeMap mapInt[],
             SIZE_T sizeOfCode);
             
#endif //DEBUGGER_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\walker.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: walker.h
//
// Debugger code stream analysis routines
//
//*****************************************************************************

#ifndef WALKER_H_
#define WALKER_H_

/* ========================================================================= */

/* ------------------------------------------------------------------------- *
 * Constants
 * ------------------------------------------------------------------------- */

enum WALK_TYPE
{
  WALK_NEXT,
  WALK_BRANCH,
  WALK_COND_BRANCH,
  WALK_CALL,
  WALK_RETURN,
  WALK_BREAK,
  WALK_THROW,
  WALK_META,
  WALK_UNKNOWN
};

/* ------------------------------------------------------------------------- *
 * Classes
 * ------------------------------------------------------------------------- */

class Walker
{
protected:
	Walker()
	  : m_ip(0), m_opcode(0), m_type(WALK_UNKNOWN), m_skipIP(0), m_nextIP(0)
	  {}

public:
	void SetIP(const BYTE *ip)
	  { m_ip = ip; Decode(); }

	const BYTE *GetIP()
	  { return m_ip; }

	DWORD GetOpcode()
	  { return m_opcode; }

	WALK_TYPE GetOpcodeWalkType()
	  { return m_type; }

	const BYTE *GetSkipIP()
	  { return m_skipIP; }

	const BYTE *GetNextIP()
	  { return m_nextIP; }

	virtual void Next() { SetIP(m_nextIP); }
	virtual void Skip() { SetIP(m_skipIP); }
	virtual void Decode() = 0;

protected:
	const BYTE			*m_ip;

	DWORD				m_opcode;
	WALK_TYPE			m_type;
	const BYTE			*m_skipIP;
	const BYTE			*m_nextIP;
};

#ifdef _X86_

class x86Walker : public Walker
{
public:
	x86Walker(REGDISPLAY *registers) 
	  : m_registers(registers) {}

	void SetRegDisplay(REGDISPLAY *registers)
	  { m_registers = registers; }
	REGDISPLAY *GetRegDisplay()
	  { return m_registers; }

	void Next()
	  { m_registers = NULL; Walker::Next(); }
	void Skip()
	  { m_registers = NULL; Walker::Skip(); }

	void Decode();
    void DecodeModRM(BYTE mod, BYTE reg, BYTE rm, const BYTE *ip);

private:
	DWORD GetRegisterValue(int registerNumber);

private:
	REGDISPLAY		*m_registers;
};

#endif


#endif // WALKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\ee\thread.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: thread.cpp
//
// Debugger thread routines
//
//*****************************************************************************

#include "stdafx.h"
#include "Common.h"
#include "..\..\VM\Threads.h"
/* ------------------------------------------------------------------------- *
 * DebuggerThread routines
 * ------------------------------------------------------------------------- */

//
// Struct used to pass data to the two stack walk callback functions.
//
struct _RefreshStackFramesData
{
    unsigned int          totalFrames;
    unsigned int          totalChains;
    Thread*				  thread;
    DebuggerRCThread*     rcThread;
    unsigned int          eventSize;
    unsigned int          eventMaxSize;
    DebuggerIPCEvent*     pEvent; // Current working event, changes for
                                  // Inproc, not used for OutOfProc.
    DebuggerIPCE_STRData* currentSTRData;
	bool				  needChainRegisters;
	REGDISPLAY			  chainRegisters;
	IpcTarget             iWhich;
};


BYTE *GetAddressOfRegisterJit(ICorDebugInfo::RegNum reg, REGDISPLAY *rd)
{
    BYTE *ret = NULL;
#ifdef _X86_
    switch(reg)
    {
        case ICorDebugInfo::RegNum::REGNUM_EAX:
        {
            ret = *(BYTE**)rd->pEax;
            break;
        }
        case ICorDebugInfo::RegNum::REGNUM_ECX:
        {
            ret = *(BYTE**)rd->pEcx;
            break;
        }
        case ICorDebugInfo::RegNum::REGNUM_EDX:
        {
            ret = *(BYTE**)rd->pEdx;
            break;
        }
        case ICorDebugInfo::RegNum::REGNUM_EBX:
        {
            ret = *(BYTE**)rd->pEbx;
            break;
        }
        case ICorDebugInfo::RegNum::REGNUM_ESP:
        {
            ret = *(BYTE**)(&(rd->Esp));
            break;
        }
        case ICorDebugInfo::RegNum::REGNUM_EBP:
        {
            ret = *(BYTE**)rd->pEbp;
            break;
        }
        case ICorDebugInfo::RegNum::REGNUM_ESI:
        {
            ret = *(BYTE**)rd->pEsi;
            break;
        }    
        case ICorDebugInfo::RegNum::REGNUM_EDI:
        {
            ret = *(BYTE**)rd->pEdi;
            break;
        }
        default:
        {
            ret = NULL;
            break;
        }
    }
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - GetAddressOfRegisterJit (Thread.cpp)");
#endif // _X86_
    
    return ret;
}

BYTE *GetPtrFromValue(ICorJitInfo::NativeVarInfo *pJITInfo,
                      REGDISPLAY *rd)
{
    BYTE *pAddr = NULL;
    BYTE *pRegAddr = NULL;
    
    switch (pJITInfo->loc.vlType)
    {
        case ICorJitInfo::VLT_REG:
                pAddr = 
                    GetAddressOfRegisterJit(pJITInfo->loc.vlReg.vlrReg, rd);
            break;

        case ICorJitInfo::VLT_STK:
                pRegAddr = 
                    GetAddressOfRegisterJit(pJITInfo->loc.vlStk.vlsBaseReg, 
                                            rd);
                pAddr = pRegAddr + pJITInfo->loc.vlStk.vlsOffset;
            break;

        case ICorJitInfo::VLT_MEMORY:
                pAddr = (BYTE *)pJITInfo->loc.vlMemory.rpValue;
            break;

        case ICorJitInfo::VLT_REG_REG:
        case ICorJitInfo::VLT_REG_STK:
        case ICorJitInfo::VLT_STK_REG:
        case ICorJitInfo::VLT_STK2:
        case ICorJitInfo::VLT_FPSTK:
            _ASSERTE( "GPFV: Can't convert multi-part values into a ptr!" );
            break;

        case ICorJitInfo::VLT_FIXED_VA:
            _ASSERTE(!"GPFV:VLT_FIXED_VA is an invalid value!");
            break;
    }

    LOG((LF_CORDB,LL_INFO100000, "GPFV: Derrived ptr 0x%x from type "
        "0x%x\n", pAddr, pJITInfo->loc.vlType));
    return pAddr;
}

void GetVAInfo(bool *pfVarArgs,
               void **ppSig,
               SIZE_T *pcbSig,
               void **ppFirstArg,
               MethodDesc *pMD,
               REGDISPLAY *rd,
               SIZE_T relOffset)
{
    HRESULT hr = S_OK;
#ifdef _X86_
    ICorJitInfo::NativeVarInfo *pNativeInfo;
    PCCOR_SIGNATURE sig = pMD->GetSig();
    ULONG callConv = CorSigUncompressCallingConv(sig);

    if ( (callConv & IMAGE_CEE_CS_CALLCONV_MASK)&
         IMAGE_CEE_CS_CALLCONV_VARARG)
    {
        LOG((LF_CORDB,LL_INFO100000, "GVAI: %s::%s is a varargs fnx!\n",
             pMD->m_pszDebugClassName,pMD->m_pszDebugMethodName));

        // This is a VARARGs function, so pass over the instance-specific
        // info.
        DebuggerJitInfo *dji=g_pDebugger->GetJitInfo(pMD,(BYTE*)(*(rd->pPC)));

        if (dji != NULL)
        {
            hr = FindNativeInfoInILVariableArray(ICorDebugInfo::VARARGS_HANDLE,
                                                 relOffset,
                                                 &pNativeInfo,
                                                 dji->m_varNativeInfoCount,
                                                 dji->m_varNativeInfo);
        }

        if (dji == NULL || FAILED(hr) || pNativeInfo==NULL)
        {
#ifdef _DEBUG
            if (dji == NULL)
                LOG((LF_CORDB, LL_INFO1000, "GVAI: varargs? no DJI\n"));
            else if (CORDBG_E_IL_VAR_NOT_AVAILABLE==hr)
                LOG((LF_CORDB, LL_INFO1000, "GVAI: varargs? No VARARGS_HANDLE "
                    "found!\n"));
            else if (pNativeInfo == NULL)
                LOG((LF_CORDB, LL_INFO1000, "GVAI: varargs? No native info\n"));
            else
            {
                _ASSERTE(FAILED(hr));
                LOG((LF_CORDB, LL_INFO1000, "GVAI: varargs? Failed with "
                    "hr:0x%x\n", hr));
            }
#endif //_DEBUG

            // Is this ever bad....
            (*pfVarArgs) = true;
            (*ppSig) = NULL;
            (*pcbSig) = 0;
            (*ppFirstArg) = NULL;
            return;
        }

        BYTE *pvStart = GetPtrFromValue(pNativeInfo, rd);
        VASigCookie *vasc = *(VASigCookie**)pvStart;        
        PCCOR_SIGNATURE sigStart = vasc->mdVASig;
        PCCOR_SIGNATURE sigEnd = sigStart;
        ULONG cArg;
        ULONG iArg;

        sigEnd += _skipMethodSignatureHeader(sigEnd, &cArg);
        for(iArg = 0; iArg< cArg; iArg++)
        {
            sigEnd += _skipTypeInSignature(sigEnd);
        }
        
        (*pfVarArgs) = true;
        (*ppSig) = (void *)vasc->mdVASig;
        (*pcbSig) = sigEnd - sigStart;
        // Note: the first arg is relative to the start of the VASigCookie
        // on the stack
        (*ppFirstArg) = (void *)(pvStart - sizeof(void *) + vasc->sizeOfArgs);
        
        LOG((LF_CORDB,LL_INFO10000, "GVAI: Base Ptr for args is 0x%x\n", 
            (*ppFirstArg)));
    }
    else
    {
        LOG((LF_CORDB,LL_INFO100000, "GVAI: %s::%s NOT VarArg!\n",
             pMD->m_pszDebugClassName,pMD->m_pszDebugMethodName));
        
        (*pfVarArgs) = false;

        // So that on the right side we don't wrongly init CordbJITILFrame
        (*ppFirstArg) = (void *)0;
        (*ppSig) = (void *)0;
        (*pcbSig) = (SIZE_T)0;
    }
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - GetVAInfo (Thread.cpp)");
#endif // _X86_
}

void CopyEventInfo(DebuggerIPCEvent *src, DebuggerIPCEvent *dst)
{
    _ASSERTE( src != NULL && dst != NULL && src != dst );
    
    dst->type = src->type;
    dst->processId = src->processId;
    dst->threadId = src->threadId;
    dst->hr = src->hr;
    switch( src->type )
    {
        case DB_IPCE_STACK_TRACE_RESULT:
        {
            dst->StackTraceResultData.traceCount = src->StackTraceResultData.traceCount;
            dst->StackTraceResultData.pContext  = src->StackTraceResultData.pContext;
            dst->StackTraceResultData.totalFrameCount = src->StackTraceResultData.totalFrameCount;
            dst->StackTraceResultData.totalChainCount = src->StackTraceResultData.totalChainCount;
            dst->StackTraceResultData.threadUserState = src->StackTraceResultData.threadUserState;
            break;
        }
        default:
        {
            _ASSERTE( !"CopyEventInfo on unsupported event type!" );
        }
    }
}


//
// Callback for walking a thread's stack. Sends required frame data to the
// DI as send buffers fill up.
//
StackWalkAction DebuggerThread::TraceAndSendStackCallback(FrameInfo *pInfo, VOID* data)
{
    _RefreshStackFramesData *rsfd = (_RefreshStackFramesData*) data;
    Thread *t = rsfd->thread;
    DebuggerIPCEvent *pEvent = NULL;

    if (rsfd->iWhich == IPC_TARGET_INPROC)
    {
        pEvent = rsfd->pEvent;
    }
    else
    {
        _ASSERTE( rsfd->iWhich == IPC_TARGET_OUTOFPROC );
        pEvent = rsfd->rcThread->GetIPCEventSendBuffer(rsfd->iWhich);
    }

	// Record registers for the start of the next chain, if appropriate.
	if (rsfd->needChainRegisters)
	{
		rsfd->chainRegisters = pInfo->registers;
		rsfd->needChainRegisters = false;
    }

	// Only report frames which are chain boundaries, or are not marked internal.
    LOG((LF_CORDB, LL_INFO1000, "DT::TASSC:chainReason:0x%x internal:0x%x  "
         "md:0x%x **************************\n", pInfo->chainReason, 
         pInfo->internal, pInfo->md));

	if (pInfo->chainReason == 0 && (pInfo->internal || pInfo->md == NULL))
		return SWA_CONTINUE;

#ifdef LOGGING
	if( pInfo->quickUnwind == true )
	    LOG((LF_CORDB, LL_INFO10000, "DT::TASSC: rsfd => Doing quick unwind\n"));
#endif
	
	//
	// If we've filled this event, send it off to the Right Side
	// before continuing the walk.
	//
	if ((rsfd->eventSize + sizeof(DebuggerIPCE_STRData)) >= rsfd->eventMaxSize)
	{
		//
		// @todo: need to pass hr through to caller and abort the walk
		// if the send fails.
		//
        pEvent->StackTraceResultData.threadUserState = g_pEEInterface->GetUserState(t);
        
        if (rsfd->iWhich == IPC_TARGET_OUTOFPROC)            
        {
            HRESULT hr = rsfd->rcThread->SendIPCEvent(rsfd->iWhich);
        }
        else
        {
            DebuggerIPCEvent *peT;
            peT = rsfd->rcThread->GetIPCEventSendBufferContinuation(pEvent);

            if (peT == NULL)
            {
                pEvent->hr = E_OUTOFMEMORY;
                return SWA_ABORT; // @todo Handle case on VRS, too
            }
            
            CopyEventInfo(pEvent, peT);
            pEvent = peT;
            rsfd->pEvent = peT;
            rsfd->eventSize = 0;
        }
		//
		// Reset for the next set of frames.
		//
        pEvent->StackTraceResultData.traceCount = 0;
		rsfd->currentSTRData = &(pEvent->StackTraceResultData.traceData);
		rsfd->eventSize = (UINT_PTR)(rsfd->currentSTRData) - (UINT_PTR)(pEvent);
	}

	MethodDesc* fd = pInfo->md;
    
	if (fd != NULL && !pInfo->internal)
	{
		//
		// Send a frame
		//

		rsfd->currentSTRData->isChain = false;
		rsfd->currentSTRData->fp = pInfo->fp;
		rsfd->currentSTRData->quicklyUnwound = pInfo->quickUnwind;

        // Pass the appdomain that this thread was in when it was executing this frame to the Right Side.
        rsfd->currentSTRData->currentAppDomainToken = (void*)pInfo->currentAppDomain;

		REGDISPLAY* rd = &pInfo->registers;
		DebuggerREGDISPLAY* drd = &(rsfd->currentSTRData->rd);

#ifdef _X86_

        //
        // PUSHED_REG_ADDR gives us NULL if the register still lives in the thread's context, or it gives us the address
        // of where the register was pushed for this frame.
        //
#define PUSHED_REG_ADDR(_a) (((UINT_PTR)(_a) >= (UINT_PTR)rd->pContext) && ((UINT_PTR)(_a) <= ((UINT_PTR)rd->pContext + sizeof(CONTEXT)))) ? NULL : (_a)
            
        drd->pEdi = PUSHED_REG_ADDR(rd->pEdi);
		drd->Edi  = (rd->pEdi == NULL ? 0 : *(rd->pEdi));
        drd->pEsi = PUSHED_REG_ADDR(rd->pEsi);
		drd->Esi  = (rd->pEsi == NULL ? 0 : *(rd->pEsi));
        drd->pEbx = PUSHED_REG_ADDR(rd->pEbx);
		drd->Ebx  = (rd->pEbx == NULL ? 0 : *(rd->pEbx));
        drd->pEdx = PUSHED_REG_ADDR(rd->pEdx);
		drd->Edx  = (rd->pEdx == NULL ? 0 : *(rd->pEdx));
        drd->pEcx = PUSHED_REG_ADDR(rd->pEcx);
		drd->Ecx  = (rd->pEcx == NULL ? 0 : *(rd->pEcx));
        drd->pEax = PUSHED_REG_ADDR(rd->pEax);
		drd->Eax  = (rd->pEax == NULL ? 0 : *(rd->pEax));
        drd->pEbp = PUSHED_REG_ADDR(rd->pEbp);
		drd->Ebp  = (rd->pEbp == NULL ? 0 : *(rd->pEbp));
		drd->Esp  =  rd->Esp;
		drd->PC   = (SIZE_T)*(rd->pPC);
		
		// Please leave EBP, ESP, EIP at the front so I don't have to scroll
		// left to see the most important registers.  Thanks!
		LOG( (LF_CORDB, LL_INFO1000, "DT::TASSC:Registers:"
		    "Ebp = %x   Esp = %x   Eip = %x Edi:%d"
		    "Esi = %x   Ebx = %x   Edx = %x   Ecx = %x   Eax = %x\n",
		    drd->Ebp, drd->Esp, drd->PC, drd->Edi,
			drd->Esi, drd->Ebx, drd->Edx, drd->Ecx, drd->Eax ) );
#else
		drd->PC  = *(rd->pPC);
#endif
            
		DebuggerIPCE_FuncData* currentFuncData = &rsfd->currentSTRData->funcData;
        _ASSERTE(fd != NULL);

        GetVAInfo(&(currentFuncData->fVarArgs),
                  &(currentFuncData->rpSig),
                  &(currentFuncData->cbSig),
                  &(currentFuncData->rpFirstArg),
                  fd,
                  rd,
                  pInfo->relOffset);


		LOG((LF_CORDB, LL_INFO10000, "DT::TASSC: good frame for %s::%s\n",
			 fd->m_pszDebugClassName,
			 fd->m_pszDebugMethodName));

		//
		// Fill in information about the function that goes with this
		// frame.
		//
		currentFuncData->funcRVA = g_pEEInterface->MethodDescGetRVA(fd);
		_ASSERTE (t != NULL);
		
		Module *pRuntimeModule = g_pEEInterface->MethodDescGetModule(fd);
		AppDomain *pAppDomain = pInfo->currentAppDomain;
		currentFuncData->funcDebuggerModuleToken = (void*) g_pDebugger->LookupModule(pRuntimeModule, pAppDomain);
        
        if (currentFuncData->funcDebuggerModuleToken == NULL && rsfd->iWhich == IPC_TARGET_INPROC)
        {
            currentFuncData->funcDebuggerModuleToken = (void*)g_pDebugger->AddDebuggerModule(pRuntimeModule, pAppDomain);
            
            LOG((LF_CORDB, LL_INFO100, "DT::TASSC: load module Mod:%#08x AD:%#08x isDynamic:%#x runtimeMod:%#08x\n",
                 currentFuncData->funcDebuggerModuleToken, pAppDomain, pRuntimeModule->IsReflection(), pRuntimeModule));
        }                                   
		_ASSERTE(currentFuncData->funcDebuggerModuleToken != 0);
		
		currentFuncData->funcDebuggerAssemblyToken = 
			(g_pEEInterface->MethodDescGetModule(fd))->GetClassLoader()->GetAssembly();
		currentFuncData->funcMetadataToken = fd->GetMemberDef();

        currentFuncData->classMetadataToken = fd->GetClass()->GetCl();

        // Pass back the local var signature token.
        COR_ILMETHOD *CorILM = g_pEEInterface->MethodDescGetILHeader(fd);

        if (CorILM == NULL )
        {
            currentFuncData->localVarSigToken = mdSignatureNil;
            currentFuncData->ilStartAddress = NULL;
            currentFuncData->ilSize = 0;
            rsfd->currentSTRData->ILIP = NULL;

            currentFuncData->nativeStartAddressPtr = NULL;
            currentFuncData->nativeSize = 0;
            currentFuncData->nativenVersion = DebuggerJitInfo::DJI_VERSION_FIRST_VALID;
        }
        else
        {
            COR_ILMETHOD_DECODER ILHeader(CorILM);

            if (ILHeader.LocalVarSigTok != 0)
                currentFuncData->localVarSigToken = ILHeader.LocalVarSigTok;
            else
                currentFuncData->localVarSigToken = mdSignatureNil; 
            //
            // @todo always filling in the IL address and size will be bogus
            // for native managed code.
            //
            currentFuncData->ilStartAddress = const_cast<BYTE*>(ILHeader.Code);
            currentFuncData->ilSize = ILHeader.CodeSize;

            currentFuncData->ilnVersion = g_pDebugger->GetVersionNumber(fd);

            LOG((LF_CORDB,LL_INFO10000,"Sending il Ver:0x%x in stack trace!\n", currentFuncData->ilnVersion));

            DebuggerJitInfo *jitInfo = g_pDebugger->GetJitInfo(fd, (const BYTE*)*pInfo->registers.pPC);

            if (jitInfo == NULL)
            {
                //EnC: Couldn't find the code;
                //@todo What do we do if pitching & EnC work at the same time?
                rsfd->currentSTRData->ILIP = NULL;

                // Note: always send back the size of the method. This
                // allows us to get the code, even when we haven't
                // been tracking. (Handling of the GetCode message
                // knows how to find the start address of the code, or
                // how to respond if is been pitched.)
                currentFuncData->nativeSize = g_pEEInterface->GetFunctionSize(fd);

                currentFuncData->nativeStartAddressPtr = NULL;
                currentFuncData->nativenVersion = DebuggerJitInfo::DJI_VERSION_FIRST_VALID;
                currentFuncData->CodeVersionToken = NULL;
                currentFuncData->ilToNativeMapAddr = NULL;
                currentFuncData->ilToNativeMapSize = 0;
                currentFuncData->nVersionMostRecentEnC = currentFuncData->ilnVersion;
		    }
		    else
		    {
                LOG((LF_CORDB,LL_INFO10000,"DeTh::TASSC: Code: 0x%x Got DJI "
                     "0x%x, from 0x%x to 0x%x\n",(const BYTE*)drd->PC,jitInfo, 
                     jitInfo->m_addrOfCode, jitInfo->m_addrOfCode + 
                     jitInfo->m_sizeOfCode));
			    
			    SIZE_T whichIrrelevant;
			    rsfd->currentSTRData->ILIP = const_cast<BYTE*>(ILHeader.Code) 
                    + jitInfo->MapNativeOffsetToIL((SIZE_T)pInfo->relOffset,
                                                   &rsfd->currentSTRData->mapping,
                                                   &whichIrrelevant);

                // Pass back the pointers to the sequence point map so
                // that the RIght Side can copy it out if needed.
                _ASSERTE(jitInfo->m_sequenceMapSorted);
                
                currentFuncData->ilToNativeMapAddr = jitInfo->m_sequenceMap;
                currentFuncData->ilToNativeMapSize = jitInfo->m_sequenceMapCount;
                
			    if (!jitInfo->m_codePitched)
			    {	// It's there & life is groovy
				    currentFuncData->nativeStartAddressPtr = &(jitInfo->m_addrOfCode);
				    currentFuncData->nativeSize = g_pEEInterface->GetFunctionSize(fd);
				    currentFuncData->nativenVersion = jitInfo->m_nVersion;
				    currentFuncData->CodeVersionToken = (void *)jitInfo;
			    }
			    else
			    {
				    // It's been pitched
				    currentFuncData->nativeStartAddressPtr = NULL;
				    currentFuncData->nativeSize = 0;
			    }
			    
			    LOG((LF_CORDB,LL_INFO10000,"Sending native Ver:0x%x Tok:0x%x in stack trace!\n",
                     currentFuncData->nativenVersion,currentFuncData->CodeVersionToken));
		    }
        }

        currentFuncData->nativeOffset = (SIZE_T)pInfo->relOffset;

		//
		// Bump our pointers to the next space for the next frame.
		//
		pEvent->StackTraceResultData.traceCount++;
		rsfd->currentSTRData++;
		rsfd->eventSize += sizeof(DebuggerIPCE_STRData);
	}

	if (pInfo->chainReason != 0)
	{
        //
        // If we've filled this event, send it off to the Right Side
        // before continuing the walk.
        //
        if ((rsfd->eventSize + sizeof(DebuggerIPCE_STRData)) >=
            rsfd->eventMaxSize)
        {
            //
            // @todo: need to pass hr through to caller and abort the walk
            // if the send fails.
            //
            pEvent->StackTraceResultData.threadUserState = 
                g_pEEInterface->GetUserState(t);
                
            if (rsfd->iWhich == IPC_TARGET_OUTOFPROC)            
            {
                HRESULT hr = rsfd->rcThread->SendIPCEvent(rsfd->iWhich);
            }
            else
            {
                DebuggerIPCEvent *peT;
                peT = rsfd->rcThread->GetIPCEventSendBufferContinuation(pEvent);
                
                if (peT == NULL)
                {
                    pEvent->hr = E_OUTOFMEMORY;
                    return SWA_ABORT; // @todo Handle case on VRS, too
                }
                
                CopyEventInfo(pEvent, peT);                    
                pEvent = peT;
                rsfd->pEvent = peT;
                rsfd->eventSize = 0;
            }

            //
            // Reset for the next set of frames.
            //
            pEvent->StackTraceResultData.traceCount = 0;
            rsfd->currentSTRData = &(pEvent->StackTraceResultData.traceData);
            rsfd->eventSize = (UINT_PTR)(rsfd->currentSTRData) -
                (UINT_PTR)(pEvent);
        }

		//
		// Send a chain boundary
		//

		rsfd->currentSTRData->isChain = true;
		rsfd->currentSTRData->chainReason = pInfo->chainReason;
		rsfd->currentSTRData->managed = pInfo->managed;
		rsfd->currentSTRData->context = pInfo->context;
		rsfd->currentSTRData->fp = pInfo->fp;
		rsfd->currentSTRData->quicklyUnwound = pInfo->quickUnwind;

		REGDISPLAY* rd = &rsfd->chainRegisters;
		DebuggerREGDISPLAY* drd = &(rsfd->currentSTRData->rd);

#ifdef _X86_
        drd->pEdi = PUSHED_REG_ADDR(rd->pEdi);
        drd->Edi  = (rd->pEdi == NULL ? 0 : *(rd->pEdi));
        drd->pEsi = PUSHED_REG_ADDR(rd->pEsi);
        drd->Esi  = (rd->pEsi == NULL ? 0 : *(rd->pEsi));
        drd->pEbx = PUSHED_REG_ADDR(rd->pEbx);
        drd->Ebx  = (rd->pEbx == NULL ? 0 : *(rd->pEbx));
        drd->pEdx = PUSHED_REG_ADDR(rd->pEdx);
        drd->Edx  = (rd->pEdx == NULL ? 0 : *(rd->pEdx));
        drd->pEcx = PUSHED_REG_ADDR(rd->pEcx);
        drd->Ecx  = (rd->pEcx == NULL ? 0 : *(rd->pEcx));
        drd->pEax = PUSHED_REG_ADDR(rd->pEax);
        drd->Eax  = (rd->pEax == NULL ? 0 : *(rd->pEax));
        drd->pEbp = PUSHED_REG_ADDR(rd->pEbp);
        drd->Ebp  = (rd->pEbp == NULL ? 0 : *(rd->pEbp));
        drd->Esp  =  rd->Esp;
        drd->PC   = (SIZE_T)*(rd->pPC);

		LOG( (LF_CORDB, LL_INFO1000, "DT::TASSC:Registers:  Edi:%d \
  Esi = %x   Ebx = %x   Edx = %x   Ecx = %x   Eax = %x \
  Ebp = %x   Esp = %x   Eip = %x\n", drd->Edi,
			  drd->Esi, drd->Ebx, drd->Edx, drd->Ecx, drd->Eax,
			  drd->Ebp, drd->Esp, drd->PC) );
#else
		drd->PC  = *(rd->pPC);
#endif
            
		rsfd->needChainRegisters = true;

		//
		// Bump our pointers to the next space for the next frame.
		//
		pEvent->StackTraceResultData.traceCount++;
		rsfd->currentSTRData++;
		rsfd->eventSize += sizeof(DebuggerIPCE_STRData);
	}

	return SWA_CONTINUE;
}

//
// Callback for walking a thread's stack. Simply counts the total number
// of frames and contexts for a given thread.
//
StackWalkAction DebuggerThread::StackWalkCount(FrameInfo *pInfo,
											   VOID* data)
{
    CORDB_ADDRESS pCurrentObjContext = NULL;
    _RefreshStackFramesData* rsfd = (_RefreshStackFramesData*) data;

	if (pInfo->chainReason != 0)
		rsfd->totalChains++;
	if (!pInfo->internal && pInfo->md != NULL)
		rsfd->totalFrames++;

	return SWA_CONTINUE;
}


//
// TraceAndSendStack unwinds the thread's stack and sends all needed data
// back to the DI for processing and storage. Nothing is kept on the RC side.
//
// Note: this method must work while the RC is in restricted mode.
//
// Note: the right side is waiting for a response, so if an error occurs,
// you MUST send a reply back telling what happened.  Otherwise we'll deadlock.
// Note also that the HRESULT this function returns is for HandleIPCEvent's use,
// and is otherwise dropped on the floor.
//
HRESULT DebuggerThread::TraceAndSendStack(Thread *thread, 
                                          DebuggerRCThread* rcThread,
                                          IpcTarget iWhich)
{
    struct _RefreshStackFramesData rsfd;
    HRESULT hr = S_OK;

#ifndef RIGHT_SIDE_ONLY
    memset((void *)&rsfd, 0, sizeof(rsfd));
#endif

    // Initialize the event that we'll be sending back to the right side.
    // The same event is sent over and over, depending on how many frames
    // there are. The frameCount is simply reset each time the event is sent.
    DebuggerIPCEvent *pEvent = rcThread->GetIPCEventSendBuffer(iWhich);
    pEvent->type = DB_IPCE_STACK_TRACE_RESULT;
    pEvent->processId = GetCurrentProcessId();
    pEvent->threadId = thread->GetThreadId();
    pEvent->hr = S_OK;
    pEvent->StackTraceResultData.traceCount = 0;

    Thread::ThreadState ts = thread->GetSnapshotState();

	if ((ts & Thread::ThreadState::TS_Dead) ||
		(ts & Thread::ThreadState::TS_Unstarted) ||
        (ts & Thread::ThreadState::TS_Detached))
	{
		pEvent->hr =  CORDBG_E_BAD_THREAD_STATE;
        
	    if (iWhich == IPC_TARGET_OUTOFPROC)            
	    {
	        return rcThread->SendIPCEvent(iWhich);
	    }
	    else
	    	return CORDBG_E_BAD_THREAD_STATE;
	}
	
    LOG((LF_CORDB,LL_INFO1000, "thread id:0x%x userThreadState:0x%x \n", 
         thread->GetThreadId(), pEvent->StackTraceResultData.threadUserState));

	//EEIface will set this to NULL if we're not in an exception, and to the
	//address of the proper context (which isn't the current context) otherwise
	pEvent->StackTraceResultData.pContext = g_pEEInterface->GetThreadFilterContext(thread);

    //
    // Setup data to be passed to the stack trace callback.
    //
    rsfd.totalFrames = 0;
    rsfd.totalChains = 0;
    rsfd.thread = thread;
    rsfd.pEvent = pEvent;
    rsfd.rcThread = rcThread;
    rsfd.eventMaxSize = CorDBIPC_BUFFER_SIZE;
    rsfd.currentSTRData = &(pEvent->StackTraceResultData.traceData);
    rsfd.eventSize = (UINT_PTR)(rsfd.currentSTRData) - (UINT_PTR)(pEvent);
    rsfd.needChainRegisters = true;
    rsfd.iWhich = iWhich;

#ifndef RIGHT_SIDE_ONLY
    // In in-process, default the registers to zero.
    memset((void *)&rsfd.chainRegisters, 0, sizeof(rsfd.chainRegisters));
#endif

	LOG((LF_CORDB, LL_INFO10000, "DT::TASS: tracking stack...\n"));

    __try
    {
        //
        // If the hardware context of this thread is set, then we've hit
        // a native breakpoint for this thread. We need to initialize
        // or walk with the context of the thread when it faulted, not with
        // its current context. 
        //
        CONTEXT *pContext = g_pEEInterface->GetThreadFilterContext(thread);
        CONTEXT ctx;

        BOOL contextValid = (pContext != NULL);

        if (!contextValid)
            pContext = &ctx;

        StackWalkAction res = DebuggerWalkStack(thread, NULL,
                                                pContext, contextValid,
                                                DebuggerThread::StackWalkCount,
                                                (VOID*)(&rsfd), 
                                                TRUE, iWhich);
        if (res == SWA_FAILED)
        {
            pEvent->hr =  E_FAIL;
            if (iWhich == IPC_TARGET_OUTOFPROC)            
            {
                HRESULT hr = rcThread->SendIPCEvent(iWhich);
            }
        }
        else if (res == SWA_ABORT)
        {
            return E_FAIL; // Note that we'll have already sent off the error message.
        }
    
        pEvent->StackTraceResultData.totalFrameCount = rsfd.totalFrames;
        pEvent->StackTraceResultData.totalChainCount = rsfd.totalChains;
        pEvent->StackTraceResultData.threadUserState = 
            g_pEEInterface->GetUserState(thread);

        LOG((LF_CORDB, LL_INFO10000, "DT::TASS: found %d frames & %d chains.\n",
             rsfd.totalFrames, rsfd.totalChains));
    
        //
        // If there are any frames, walk again and send the detailed info about
        // each one.
        //
        if (rsfd.totalFrames > 0 || rsfd.totalChains > 0)
        {
            res = DebuggerWalkStack(thread, NULL,
                                    pContext, contextValid,
                                    DebuggerThread::TraceAndSendStackCallback,
                                    (VOID*)(&rsfd), TRUE, iWhich);
            if (res == SWA_FAILED)
            {
                pEvent->hr =  E_FAIL;
                if (iWhich == IPC_TARGET_OUTOFPROC)            
                {
                    HRESULT hr = rcThread->SendIPCEvent(iWhich);
                }
            }
            else if (res == SWA_ABORT)
            {
                return E_FAIL; // Note that we'll have already sent off the error message.
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = pEvent->hr = CORDBG_E_BAD_THREAD_STATE;
    }

    if (iWhich == IPC_TARGET_OUTOFPROC)        
        hr = rsfd.rcThread->SendIPCEvent(iWhich);
    
    return hr;
}



//
// Read the FPU state for this thread and send it back to the right side.
//
HRESULT DebuggerThread::GetAndSendFloatState(Thread *thread, 
											 DebuggerRCThread *rcThread,
											 IpcTarget iWhich)
{
    //
    // Setup the event that we'll be sending the results in.
    //
    DebuggerIPCEvent* event = rcThread->GetIPCEventSendBuffer(iWhich);
    event->type = DB_IPCE_GET_FLOAT_STATE_RESULT;
    event->processId = GetCurrentProcessId();
    event->threadId = 0;
    event->hr = S_OK;

    event->GetFloatStateResult.floatStateValid = false;
    event->GetFloatStateResult.floatStackTop = 0;
    
#ifdef _X86_    
    //
    // On X86, we do this by saving our current FPU state, loading
    // the other thread's FPU state into our own, saving out each
    // value off the FPU stack, and then restoring our FPU state.
    //
    CONTEXT* pContext = g_pEEInterface->GetThreadFilterContext(thread);
    CONTEXT tempContext;

    // If the filter context is NULL, then we use the true context of
    // the thread.
    if (pContext == NULL)
    {
        tempContext.ContextFlags = CONTEXT_FULL;

        BOOL succ = GetThreadContext(thread->GetThreadHandle(), &tempContext);

        if (succ)
            pContext = &tempContext;
        else
        {
            HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
            event->hr = hr;

            hr = rcThread->SendIPCEvent(iWhich);
            
            return hr;
        }
    }
    
    FLOATING_SAVE_AREA floatarea = pContext->FloatSave; // copy FloatSave

    //
    // Suck the TOP out of the FPU status word. Note, our version of the
    // stack runs from 0->7, not 7->0...
    //
    unsigned int floatStackTop = 7 - ((floatarea.StatusWord & 0x3800) >> 11);

    FLOATING_SAVE_AREA currentFPUState;

    __asm fnsave currentFPUState // save the current FPU state.

        floatarea.StatusWord &= 0xFF00; // remove any error codes.
    floatarea.ControlWord |= 0x3F; // mask all exceptions.

    __asm
        {
            fninit
                frstor floatarea          ;; reload the threads FPU state.
                                                 }

    unsigned int i;
        
    for (i = 0; i <= floatStackTop; i++)
    {
        double td;
        __asm fstp td // copy out the double
            event->GetFloatStateResult.floatValues[i] = td;
    }

    __asm
        {
            fninit
                frstor currentFPUState    ;; restore our saved FPU state.
                                                 }

    event->GetFloatStateResult.floatStateValid = true;
    event->GetFloatStateResult.floatStackTop = floatStackTop;

#if 0
    for (i = 0; i < 8; i++)
	{	
        fprintf( stderr, "DT::GASFT: FSA[%d]: %.16g\n", i, (double)(event->GetFloatStateResult.floatValues[i]));
	}
#endif 
#endif //_X86_

    HRESULT hr = S_OK;

    if (iWhich == IPC_TARGET_OUTOFPROC)
    {
        //
        // Send off the data to the right side.
        //
        hr = rcThread->SendIPCEvent(iWhich);
    }    
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\inc\cordb.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: cordb.h
//
//*****************************************************************************

/* ------------------------------------------------------------------------- *
 * cordb.h - header file for debugger-side classes of COM+ debugger
 * ------------------------------------------------------------------------- */

#ifndef CORDB_H_
#define CORDB_H_

#include <winwrap.h>
#include <Windows.h>

#include <UtilCode.h>

#ifdef _DEBUG
#define LOGGING
#endif

#include <Log.h>
#include <CorError.h>

#include "cor.h"

#include "cordebug.h"
#include "cordbpriv.h"
#include "mscoree.h"

#include <cordbpriv.h>
#include <DbgIPCEvents.h>

#include "IPCManagerInterface.h"
// !!! need better definitions...

// for _skipFunkyModifiersInSignature
#include "Common.h"

#undef ASSERT
#define CRASH(x)  _ASSERTE(!x)
#define ASSERT(x) _ASSERTE(x)
#define PRECONDITION _ASSERTE
#define POSTCONDITION _ASSERTE


/* ------------------------------------------------------------------------- *
 * Forward class declarations
 * ------------------------------------------------------------------------- */

class CordbBase;
class CordbValue;
class CordbModule;
class CordbClass;
class CordbFunction;
class CordbCode;
class CordbFrame;
class CordbJITILFrame;
class CordbChain;
class CordbContext;
class CordbThread;
class CordbUnmanagedThread;
struct CordbUnmanagedEvent;
class CordbProcess;
class CordbAppDomain;
class CordbAssembly;
class CordbBreakpoint;
class CordbStepper;
class Cordb;
class CordbEnCSnapshot;
class CordbWin32EventThread; 
class CordbRCEventThread; 
class CordbRegisterSet;
class CordbNativeFrame; 
class CordbObjectValue; 
class CordbEnCErrorInfo;
class CordbEnCErrorInfoEnum;

class CorpubPublish;
class CorpubProcess;
class CorpubAppDomain;
class CorpubProcessEnum;
class CorpubAppDomainEnum;

/* ------------------------------------------------------------------------- *
 * Typedefs
 * ------------------------------------------------------------------------- */

typedef void* REMOTE_PTR;

/* ------------------------------------------------------------------------- *
 * Helpful macros
 * ------------------------------------------------------------------------- */

#define CORDBSetUnrecoverableError(__p, __hr, __code) \
    ((__p)->UnrecoverableError((__hr), (__code), __FILE__, __LINE__))

#define CORDBProcessSetUnrecoverableWin32Error(__p, __code) \
    ((__p)->UnrecoverableError(HRESULT_FROM_WIN32(GetLastError()), \
                               (__code), __FILE__, __LINE__), \
     HRESULT_FROM_WIN32(GetLastError()))

#define CORDBCheckProcessStateOK(__p) \
    (!((__p)->m_unrecoverableError) && !((__p)->m_terminated) && !((__p)->m_detached))

#define CORDBCheckProcessStateOKAndSync(__p, __c) \
    (!((__p)->m_unrecoverableError) && !((__p)->m_terminated) && !((__p)->m_detached) && \
    (__p)->GetSynchronized())

#define CORDBHRFromProcessState(__p, __c) \
        ((__p)->m_unrecoverableError ? CORDBG_E_UNRECOVERABLE_ERROR : \
         ((__p)->m_detached ? CORDBG_E_PROCESS_DETACHED : \
         ((__p)->m_terminated ? CORDBG_E_PROCESS_TERMINATED : \
         (!(__p)->GetSynchronized() ? CORDBG_E_PROCESS_NOT_SYNCHRONIZED \
         : S_OK))))

#define CORDBRequireProcessStateOK(__p) { \
    if (!CORDBCheckProcessStateOK(__p)) \
        return CORDBHRFromProcessState(__p, NULL); }

#define CORDBRequireProcessStateOKAndSync(__p,__c) { \
    if (!CORDBCheckProcessStateOKAndSync(__p, __c)) \
        return CORDBHRFromProcessState(__p, __c); }

#define CORDBRequireProcessSynchronized(__p, __c) { \
    if (!(__p)->GetSynchronized()) return CORDBG_E_PROCESS_NOT_SYNCHRONIZED;}

#define CORDBSyncFromWin32StopIfNecessary(__p) { \
        HRESULT hr = (__p)->StartSyncFromWin32Stop(NULL); \
        if (FAILED(hr)) return hr; \
    }

// Slightly different form of CORDBSyncFromWin32StopIfNecessary. This one only does the sync if we're really Win32
// stopped. There are some checks in StartSyncFromWin32Stop() that will stop us if we're Win32 attached and just not
// synchronized. That's a pretty broad check, and its too broad for things that you want to do while the debuggee is
// running, i.e., setting a breakpoint. Use this stricter form instead, which ensures that we're really supposed to be
// stopped before slipping the process.
#define CORDBSyncFromWin32StopIfStopped(__p) { \
        if ((__p)->m_state & CordbProcess::PS_WIN32_STOPPED) {\
            HRESULT hr = (__p)->StartSyncFromWin32Stop(NULL); \
            if (FAILED(hr)) return hr; \
        }\
    }

#define CORDBSyncFromWin32StopIfNecessaryCheck(__p, __c) { \
        HRESULT hr = (__p)->StartSyncFromWin32Stop((__c)); \
        if (FAILED(hr)) return hr; \
    }

#define CORDBLeftSideDeadIsOkay(__p) { \
        if ((__p)->m_helperThreadDead) return S_OK; \
    }

#ifndef RIGHT_SIDE_ONLY
extern CRITICAL_SECTION g_csInprocLock;

#define INPROC_INIT_LOCK() InitializeCriticalSection(&g_csInprocLock);

#ifdef _DEBUG
    extern DWORD            g_dwInprocLockOwner;
    extern DWORD            g_dwInprocLockRecursionCount;

    #define INPROC_LOCK()                                                   \
        LOG((LF_CORDB, LL_INFO10000, "About EnterCriticalSection\n"));      \
        LOCKCOUNTINCL("INPROC_LOCK in cordb.h");                            \
        EnterCriticalSection(&g_csInprocLock);                              \
        g_dwInprocLockOwner = GetCurrentThreadId();                         \
        g_dwInprocLockRecursionCount++
    
    #define INPROC_UNLOCK()                                                 \
        LOG((LF_CORDB, LL_INFO10000, "About LeaveCriticalSection\n"));      \
        g_dwInprocLockRecursionCount--;                                     \
        if (g_dwInprocLockRecursionCount == 0)                              \
            g_dwInprocLockOwner = 0;                                        \
        LeaveCriticalSection(&g_csInprocLock);                              \
        LOCKCOUNTDECL("INPROC_UNLOCK in cordb.h")

    #define HOLDS_INPROC_LOCK() (g_dwInprocLockOwner == GetCurrentThreadId())

#else    
    #define INPROC_LOCK()                                                   \
        LOG((LF_CORDB, LL_INFO10000, "About EnterCriticalSection\n"));      \
        LOCKCOUNTINCL("INPROC_LOCK in cordb.h");                            \
        EnterCriticalSection(&g_csInprocLock)
    
    #define INPROC_UNLOCK()                                                 \
        LOG((LF_CORDB, LL_INFO10000, "About LeaveCriticalSection\n"));      \
        LeaveCriticalSection(&g_csInprocLock);                              \
        LOCKCOUNTDECL("INPROC_UNLOCK in cordb.h")
#endif // _DEBUG
    
    
#define INPROC_UNINIT_LOCK() DeleteCriticalSection(&g_csInprocLock);

#else

#define INPROC_INIT_LOCK()
#define INPROC_LOCK()
#define INPROC_UNLOCK()
#define INPROC_UNINIT_LOCK()

#endif //RIGHT_SIDE_ONLY

/* ------------------------------------------------------------------------- *
 * Base class
 * ------------------------------------------------------------------------- */

#define COM_METHOD  HRESULT STDMETHODCALLTYPE

typedef enum {
    enumCordbUnknown,       //  0   
    enumCordb,              //  1   1  [1]x1
    enumCordbProcess,       //  2   1  [1]x1
    enumCordbAppDomain,     //  3   1  [1]x1
    enumCordbAssembly,      //  4   
    enumCordbModule,        //  5   15 [27-38,55-57]x1
    enumCordbClass,         //  6   
    enumCordbFunction,      //  7
    enumCordbThread,        //  8   2  [4,7]x1
    enumCordbCode,          //  9
    enumCordbChain,         //  0
    enumCordbChainEnum,     //  11
    enumCordbContext,       //  12
    enumCordbFrame,         //  13
    enumCordbFrameEnum,     //  14
    enumCordbValueEnum,     //  15
    enumCordbRegisterSet,   //  16
    enumCordbJITILFrame,    //  17
    enumCordbBreakpoint,    //  18
    enumCordbStepper,       //  19
    enumCordbValue,         //  20
    enumCordbEnCSnapshot,   //  21
    enumCordbEval,          //  22
    enumCordbUnmanagedThread,// 23 
    enumCorpubPublish,      //  24
    enumCorpubProcess,      //  25
    enumCorpubAppDomain,    //  26
    enumCorpubProcessEnum,  //  27
    enumCorpubAppDomainEnum,//  28
    enumCordbEnumFilter,    //  29
    enumCordbEnCErrorInfo,  //  30
    enumCordbEnCErrorInfoEnum,//31  
    enumCordbUnmanagedEvent,//  32
    enumCordbWin32EventThread,//33  
    enumCordbRCEventThread, //  34
    enumCordbNativeFrame,   //  35
    enumCordbObjectValue,   //  36
    enumMaxDerived,         //  37
    enumMaxThis = 1024
} enumCordbDerived;



class CordbHashTable;

class CordbBase : public IUnknown
{
public:
#ifdef _DEBUG
    static LONG m_saDwInstance[enumMaxDerived]; // instance x this
    static LONG m_saDwAlive[enumMaxDerived];
    static PVOID m_sdThis[enumMaxDerived][enumMaxThis];
    DWORD m_dwInstance;
    enumCordbDerived m_type;
#endif
    
public: 
    UINT_PTR    m_id;
    SIZE_T      m_refCount;

    CordbBase(UINT_PTR id, enumCordbDerived type)
    {
        init(id, type);
    }
    
    CordbBase(UINT_PTR id)
    {
        init(id, enumCordbUnknown);
    }
    
    void init(UINT_PTR id, enumCordbDerived type)
    {
        m_id = id;
        m_refCount = 0;

#ifdef _DEBUG
        //m_type = type;
        //m_dwInstance = CordbBase::m_saDwInstance[m_type];
        //InterlockedIncrement(&CordbBase::m_saDwInstance[m_type]);
        //InterlockedIncrement(&CordbBase::m_saDwAlive[m_type]);
        //if (m_dwInstance < enumMaxThis)
        //{
        //    m_sdThis[m_type][m_dwInstance] = this;
        //}
#endif
    }
    
    virtual ~CordbBase()
    {
#ifdef _DEBUG
        //InterlockedDecrement(&CordbBase::m_saDwAlive[m_type]);
        //if (m_dwInstance < enumMaxThis)
        //{
        //    m_sdThis[m_type][m_dwInstance] = NULL;
        //}
#endif
    }


    /*   
        Documented: Chris (chrisk), May 2, 2001
        
        Member function behavior of a neutered COM object:

             1. AddRef(), Release(), QueryInterface() work as normal. 
                 a. This gives folks who are responsable for pairing a Release() with 
                    an AddRef() a chance to dereferance thier pointer and call Release()
                    when they are informed, explicitly or implicitly, that the object is neutered.

             2. Any other member function will return an error code unless documented.
                 a. If a member fuction returns information when the COM object is 
                    neutered then the semantics of that function need to be documented.
                    (ie. If an AppDomain is unloaded and you have a referance to the COM
                    object representing the AppDomain, how _should_ it behave? That behavior
                    should be documented)


        Postcondions of Neuter():

             1. All circular referances (aka back-pointers) are "broken". They are broken
                by calling Release() on all "Weak Referances" to the object. If you're a purist,
                these pointers should also be NULLed out. 
                 a. Weak Referances/Strong Referances: 
                     i. If any objects are not "reachable" from the root (ie. stack or from global pointers)
                        they should be reclaimed. If they are not, they are leaked and there is a bug.
                    ii. There must be a partial order on the objects such that if A < B then:
                         1. A has a referance to B. This referance is a "strong referance"
                         2. A, and thus B, is reachable from the root
      